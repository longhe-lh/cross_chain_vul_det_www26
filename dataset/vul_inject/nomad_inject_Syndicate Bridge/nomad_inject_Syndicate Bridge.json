{"project": "Syndicate Bridge", "functions": ["function addCosigner(address cosaddr, uint256 chainId)\n public\n override\n onlyOwner\n {\n Cosigner memory cosigner = _cosigners[cosaddr];\n require(!cosigner.active, \"BCM: ALREADY_EXIST\");\n require(cosaddr != address(0), \"BCM: ZERO_ADDRESS\");\n uint256 currentChainId;\n assembly {\n currentChainId := chainid()\n }\n require(currentChainId != chainId, \"BCM: ONLY_EXTERNAL\");\n _cosaddrs[chainId].push(cosaddr);\n _cosigners[cosaddr] = Cosigner(\n cosaddr,\n chainId,\n _cosaddrs[chainId].length - 1,\n true\n );\n emit CosignerAdded(cosaddr, chainId);\n }", "function process(bytes memory _message) public returns (bool _success) {\n        \n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        \n        bytes32 _messageHash = _m.keccak();\n        require(acceptableRoot(messages[_messageHash]), \"!proven\");\n        \n        require(entered == 1, \"!reentrant\");\n        entered = 0;\n        \n        messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n        \n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        \n        emit Process(_messageHash, true, \"\");\n        \n        entered = 1;\n        \n        return true;\n    }"], "label": "Yes", "detail": "Because confirmAt[bytes32(0)] was initialized to 1, acceptableRoot(bytes32(0)) always returns true, so attackers can submit arbitrary messages without proof and drain funds by calling process()"}
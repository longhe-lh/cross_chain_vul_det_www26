{"project": "Oswap CrossChain Bridge", "functions": ["function cancelOrder(bytes[] calldata signatures, uint256 orderId, bool canceledByOrderOwner, uint256 protocolFee) external override whenNotPaused {\n Order storage order = orders[orderId];\n require(orderStatus[orderId] == OrderStatus.Pending || orderStatus[orderId] == OrderStatus.RequestAmend, \"BridgeVault: cancel not requested\");\n (,,address govTokenOracle, address assetTokenOracle, uint256 baseFee,) = configStore.getBridgeParams(asset);\n uint256 price = assetPriceAgainstGovToken(govTokenOracle, assetTokenOracle);\n (uint256[] memory signers, ) = _verifyStakedValue(signatures, hashCancelOrderParams(orderId, canceledByOrderOwner, protocolFee), order.inAmount * 1e18 / price);\n uint256 refundAmount = orders[orderId].inAmount;\n \n uint256 fee;\n if (canceledByOrderOwner) {\n fee = baseFee + protocolFee;\n refundAmount -= fee;\n imbalance -= toInt256(fee);\n protocolFeeBalance += fee;\n }\n orderRefunds[orderId] = refundAmount;\n orderStatus[orderId] = OrderStatus.RefundApproved;\n emit OrderCanceled(orderId, msg.sender, signers, canceledByOrderOwner, imbalance, protocolFeeBalance);\n }", "function _verifyStakedValue(address msgSender, bytes[] calldata signatures, bytes32 paramsHash) internal returns (uint256 superTrollCount, uint totalStake, uint256[] memory signers) {\n require(!usedNonce[paramsHash], \"nonce used\");\n usedNonce[paramsHash] = true;\n uint256 generalTrollCount;\n {\n uint256 length = signatures.length;\n signers = new uint256[](length);\n address lastSigningTroll;\n for (uint256 i = 0; i < length; ++i) {\n address troll = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", paramsHash)).recover(signatures[i]);\n require(troll != address(0), \"Invalid signer\");\n uint256 trollProfileIndex = trollRegistry.trollProfileInv(troll);\n if (trollProfileIndex > 0 && troll > lastSigningTroll) {\n signers[i] = trollProfileIndex;\n if (trollRegistry.isSuperTroll(troll, true)) {\n superTrollCount++;\n } else if (trollRegistry.isGeneralTroll(troll, true)) {\n generalTrollCount++;\n }\n totalStake += trollStakesBalances[trollProfileIndex];\n lastSigningTroll = troll;\n }\n }\n }\n (uint256 generalTrollMinCount, uint256 superTrollMinCount, uint256 transactionsGap) = configStore.getSignatureVerificationParams();\n require(generalTrollCount >= generalTrollMinCount, \"OSWAP_BridgeVault: Mininum general troll count not met\");\n require(superTrollCount >= superTrollMinCount, \"OSWAP_BridgeVault: Mininum super troll count not met\");\n \n uint256 _transactionsCount = (++transactionsCount);\n require((lastTrollTxCount[msgSender] + transactionsGap < _transactionsCount) || (_transactionsCount <= transactionsGap), \"too soon\");\n lastTrollTxCount[msgSender] = _transactionsCount;\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
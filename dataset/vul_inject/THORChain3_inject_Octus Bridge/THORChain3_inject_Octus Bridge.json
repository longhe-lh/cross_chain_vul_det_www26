{"project": "Octus Bridge", "functions": ["function deposit(\n DepositParams memory d\n )\n external\n payable\n override\n nonReentrant\n tokenNotBlacklisted(d.token)\n initializeToken(d.token)\n onlyEmergencyDisabled\n {\n _deposit(d, msg.value, msg.sender);\n }", "function _deposit(\n DepositParams memory d,\n uint256 _value,\n address tokens_owner\n ) internal drainGas {\n MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\n uint fee = _calculateMovementFee(\n d.amount,\n d.token,\n IMultiVaultFacetFees.Fee.Deposit\n );\n bool isNative = s.tokens_[d.token].isNative;\n \n address token = s.tokens_[d.token].custom == address(0) ? d.token : s.tokens_[d.token].custom;\n if (isNative) {\n IMultiVaultToken(token).burn(\n msg.sender,\n d.amount\n );\n d.amount -= fee;\n _transferToEverscaleNative(d, fee, msg.value);\n } else {\n if (tokens_owner != address(this)) {\n IERC20(token).safeTransferFrom(\n tokens_owner,\n address(this),\n d.amount\n );\n }\n d.amount -= fee;\n _transferToEverscaleAlien(d, fee, _value);\n }\n _increaseTokenFee(d.token, fee);\n }", "function _withdraw(\n address recipient,\n uint amount,\n uint fee,\n IMultiVaultFacetTokens.TokenType tokenType,\n bytes32 payloadId,\n address token\n ) internal {\n if (tokenType == IMultiVaultFacetTokens.TokenType.Native) {\n IMultiVaultToken(token).mint(recipient, amount - fee);\n } else {\n IERC20(token).safeTransfer(recipient, amount - fee);\n }\n emit Withdraw(\n tokenType,\n payloadId,\n token,\n recipient,\n amount,\n fee\n );\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didnâ€™t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
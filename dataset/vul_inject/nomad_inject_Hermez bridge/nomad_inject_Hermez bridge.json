{"project": "Hermez bridge", "functions": ["function withdrawCircuit(\n uint256[2] calldata proofA,\n uint256[2][2] calldata proofB,\n uint256[2] calldata proofC,\n uint32 tokenID,\n uint192 amount,\n uint32 numExitRoot,\n uint48 idx,\n bool instantWithdraw\n ) external {\n \n if (instantWithdraw) {\n require(\n _processInstantWithdrawal(tokenList[tokenID], amount),\n \"Hermez::withdrawCircuit: INSTANT_WITHDRAW_WASTED_FOR_THIS_USD_RANGE\"\n );\n }\n require(\n exitNullifierMap[numExitRoot][idx] == false,\n \"Hermez::withdrawCircuit: WITHDRAW_ALREADY_DONE\"\n );\n \n uint256 exitRoot = exitRootsMap[numExitRoot];\n uint256 input = uint256(\n sha256(abi.encodePacked(exitRoot, msg.sender, tokenID, amount, idx))\n ) % _RFIELD;\n \n require(\n withdrawVerifier.verifyProof(proofA, proofB, proofC, [input]) ==\n true,\n \"Hermez::withdrawCircuit: INVALID_ZK_PROOF\"\n );\n \n exitNullifierMap[numExitRoot][idx] = true;\n function _withdrawFunds(...) {...}\n_withdrawFunds(amount, tokenID, instantWithdraw);\n emit WithdrawEvent(idx, numExitRoot, instantWithdraw);\n }", "function _withdrawFunds(\n uint192 amount,\n uint32 tokenID,\n bool instantWithdraw\n ) internal {\n if (instantWithdraw) {\n function _safeTransfer(...) {...}\nfunction _safeApprove(...) {...}\n_safeTransfer(tokenList[tokenID], msg.sender, amount);\n } else {\n if (tokenID == 0) {\n withdrawDelayerContract.deposit{value: amount}(\n msg.sender,\n address(0),\n amount\n );\n } else {\n address tokenAddress = tokenList[tokenID];\n _safeApprove(\n tokenAddress,\n address(withdrawDelayerContract),\n amount\n );\n withdrawDelayerContract.deposit(\n msg.sender,\n tokenAddress,\n amount\n );\n }\n }\n }", "function _safeTransfer(address token, address to, uint256 value) internal {\n \n if (token == address(0)) {\n \n (bool success, ) = msg.sender.call{value: value}(new bytes(0));\n require(success, \"Hermez::_safeTransfer: ETH_TRANSFER_FAILED\");\n } else {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_TRANSFER_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeTransfer: ERC20_TRANSFER_FAILED\"\n );\n }\n }", "function _safeApprove(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_APPROVE_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeApprove: ERC20_APPROVE_FAILED\"\n );\n }", "function process(bytes memory _message) public returns (bool _success) {\n        \n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        \n        bytes32 _messageHash = _m.keccak();\n        require(acceptableRoot(messages[_messageHash]), \"!proven\");\n        \n        require(entered == 1, \"!reentrant\");\n        entered = 0;\n        \n        messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n        \n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        \n        emit Process(_messageHash, true, \"\");\n        \n        entered = 1;\n        \n        return true;\n    }"], "label": "Yes", "detail": "Because confirmAt[bytes32(0)] was initialized to 1, acceptableRoot(bytes32(0)) always returns true, so attackers can submit arbitrary messages without proof and drain funds by calling process()"}
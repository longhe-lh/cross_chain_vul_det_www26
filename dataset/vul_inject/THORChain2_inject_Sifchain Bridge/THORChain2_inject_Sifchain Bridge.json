{"project": "Sifchain Bridge", "functions": ["function lock(\n bytes memory _recipient,\n address _token,\n uint256 _amount\n ) public payable onlyEthTokenWhiteList(_token) validSifAddress(_recipient) whenNotPaused {\n string memory symbol;\n \n if (msg.value > 0) {\n require(\n _token == address(0),\n \"!address(0)\"\n );\n require(\n msg.value == _amount,\n \"incorrect eth amount\"\n );\n symbol = \"eth\";\n \n } else {\n IERC20 tokenToTransfer = IERC20(_token);\n tokenToTransfer.safeTransferFrom(\n msg.sender,\n address(this),\n _amount\n );\n symbol = BridgeToken(_token).symbol();\n }\n if (_amount > maxTokenAmount[symbol]) {\n revert(\"Amount being transferred is over the limit\");\n }\n lockFunds(msg.sender, _recipient, _token, symbol, _amount);\n }", "function lockFunds(\n address payable _sender,\n bytes memory _recipient,\n address _token,\n string memory _symbol,\n uint256 _amount\n ) internal {\n lockBurnNonce = lockBurnNonce.add(1);\n \n lockedTokenList[_symbol] = _token;\n lockedFunds[_token] = lockedFunds[_token].add(_amount);\n emit LogLock(_sender, _recipient, _token, _symbol, _amount, lockBurnNonce);\n }", "function mintNewBridgeTokens(\n address payable _intendedRecipient,\n address _bridgeTokenAddress,\n string memory _symbol,\n uint256 _amount\n ) internal {\n require(\n controlledBridgeTokens[_symbol] == _bridgeTokenAddress,\n \"Token must be a controlled bridge token\"\n );\n \n require(\n BridgeToken(_bridgeTokenAddress).mint(_intendedRecipient, _amount),\n \"Attempted mint of bridge tokens failed\"\n );\n emit LogBridgeTokenMint(\n _bridgeTokenAddress,\n _symbol,\n _amount,\n _intendedRecipient\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_16", "functions": ["function burn(address to, uint amount) external {\n function burn(...) {...}\ntoken.burn(msg.sender, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n nonce,\n Step.Burn\n );\n nonce++;\n }", "function mint(address to, uint amount, uint otherChainNonce) external {\n require(msg.sender == admin, \"only admin\");\n require(\n processedNonces[otherChainNonce] == false,\n \"transfer already processed\"\n );\n processedNonces[otherChainNonce] = true;\n function mint(...) {...}\ntoken.mint(to, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n otherChainNonce,\n Step.Mint\n );\n }", "function process(bytes memory _message) public returns (bool _success) {\n        \n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        \n        bytes32 _messageHash = _m.keccak();\n        require(acceptableRoot(messages[_messageHash]), \"!proven\");\n        \n        require(entered == 1, \"!reentrant\");\n        entered = 0;\n        \n        messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n        \n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        \n        emit Process(_messageHash, true, \"\");\n        \n        entered = 1;\n        \n        return true;\n    }"], "label": "Yes", "detail": "Because confirmAt[bytes32(0)] was initialized to 1, acceptableRoot(bytes32(0)) always returns true, so attackers can submit arbitrary messages without proof and drain funds by calling process()"}
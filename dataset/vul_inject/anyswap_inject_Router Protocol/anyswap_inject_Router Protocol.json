{"project": "Router Protocol", "functions": ["function voteProposal(\n uint8 chainID,\n uint64 depositNonce,\n bytes32 resourceID,\n bytes32 dataHash\n ) public virtual isResourceID(resourceID) onlyRole(RELAYER_ROLE) whenNotPaused {\n bytes32 proposalHash = keccak256(abi.encodePacked(chainID, depositNonce, dataHash));\n if (_proposals[proposalHash] == 0) {\n uint256 id = _voter.createProposal(block.number + _expiry, _quorum);\n _proposals[proposalHash] = id;\n _proposalDetails[id] = proposalStruct(chainID, depositNonce, resourceID, dataHash);\n emit ProposalEvent(chainID, depositNonce, IVoterUpgradeable.ProposalStatus.Active, dataHash);\n } else if (_voter.fetchIsExpired(_proposals[proposalHash])) {\n _voter.setStatus(_proposals[proposalHash]);\n emit ProposalEvent(chainID, depositNonce, _voter.getStatus(_proposals[proposalHash]), dataHash);\n return;\n }\n if (_voter.getStatus(_proposals[proposalHash]) != IVoterUpgradeable.ProposalStatus.Cancelled) {\n _voter.vote(_proposals[proposalHash], 1, msg.sender);\n emit ProposalVote(chainID, depositNonce, _voter.getStatus(_proposals[proposalHash]), dataHash);\n if (_voter.getStatus(_proposals[proposalHash]) == IVoterUpgradeable.ProposalStatus.Passed) {\n emit ProposalEvent(chainID, depositNonce, _voter.getStatus(_proposals[proposalHash]), dataHash);\n }\n }\n }", "function vote(\n uint256 issueId,\n uint8 option,\n address relayer\n )\n public\n virtual\n isBridge\n isvalidIssue(issueId)\n isNotVoted(issueId, relayer)\n isValidOption(option)\n isNotEnded(issueId)\n isValidbalance(relayer)\n returns (bool success)\n {\n uint256 balance = balanceOf(relayer);\n hasVoted[issueId][relayer] = hasVotedStruct(true, option);\n voteWeight[issueId][option] = voteWeight[issueId][option] + balance;\n issueMap[issueId].maxVotes = issueMap[issueId].maxVotes + balance;\n uint256 yes = voteWeight[issueId][1];\n uint256 yesPercent = (yes * (10000)) / (totalSupply()); \n if (yesPercent > issueMap[issueId].quorum) _setStatus(issueId, 1, ProposalStatus.Passed);\n emit OnVote(issueId, relayer, balance);\n return true;\n }", "function depositWithPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns (uint) {\n        IERC20(underlying).permit(target, address(this), value, deadline, v, r, s);\n        IERC20(underlying).safeTransferFrom(target, address(this), value);\n        return _deposit(value, to);\n    }"], "label": "Yes", "detail": "The attacker exploited the fact that some tokens do not implement `permit()` but include a fallback function that silently accepts calls without reverting. By invoking `depositWithPermit`, the attacker could spoof the `target` (the victim address) and bypass approval checks because `permit()` succeeded trivially. Afterwards, `safeTransferFrom(target, ...)` would transfer tokens from the victim to the attacker-controlled contract. This is an authentication bypass in the cross-chain liquidity pool contract, allowing theft of user funds without a valid permit or signature."}
{"project": "Boba Gateway bridge", "functions": ["function enqueue(\n address _target,\n uint256 _gasLimit,\n bytes memory _data\n ) external {\n require(\n _data.length <= MAX_ROLLUP_TX_SIZE,\n \"Transaction data size exceeds maximum for rollup transaction.\"\n );\n require(\n _gasLimit <= maxTransactionGasLimit,\n \"Transaction gas limit exceeds maximum for rollup transaction.\"\n );\n require(\n _gasLimit >= MIN_ROLLUP_TX_GAS,\n \"Transaction gas limit too low to enqueue.\"\n );\n \n \n \n \n \n \n \n \n \n \n \n \n if (_gasLimit > enqueueL2GasPrepaid) {\n uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) /\n l2GasDiscountDivisor;\n uint256 startingGas = gasleft();\n \n \n require(\n startingGas > gasToConsume,\n \"Insufficient gas for L2 rate limiting burn.\"\n );\n uint256 i;\n while (startingGas - gasleft() < gasToConsume) {\n i++;\n }\n }\n \n \n \n \n \n address sender;\n if (msg.sender == tx.origin) {\n sender = msg.sender;\n } else {\n sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n }\n bytes32 transactionHash = keccak256(\n abi.encode(sender, _target, _gasLimit, _data)\n );\n queueElements.push(\n Lib_OVMCodec.QueueElement({\n transactionHash: transactionHash,\n timestamp: uint40(block.timestamp),\n blockNumber: uint40(block.number)\n })\n );\n uint256 queueIndex = queueElements.length - 1;\n emit TransactionEnqueued(\n sender,\n _target,\n _gasLimit,\n _data,\n queueIndex,\n block.timestamp\n );\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
{"project": "QANX Bridge", "functions": ["function bridgeSend(address beneficiary, uint256 amount, uint256 withdrawChainId) external returns (bytes32) {\n \n bytes32 txid = keccak256(abi.encode(msg.sender, block.chainid, withdrawChainId, _nonces[msg.sender][block.chainid][withdrawChainId]++, beneficiary, amount));\n \n require(_qanx.transferFrom(msg.sender, address(this), amount));\n \n return txid;\n }", "function transferFrom(\n address from,\n address to,\n uint256 amount\n ) external virtual override returns (bool) {\n address spender = _msgSender();\n function _spendAllowance(...) {...}\nfunction _transfer(...) {...}\n_spendAllowance(from, spender, amount);\n _transfer(from, to, amount);\n return true;\n }", "function _transfer(\n address from,\n address to,\n uint256 amount\n ) internal virtual {\n require(from != address(0), \"ERC20: transfer from the zero address\");\n require(to != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(from, to, amount);\n uint256 fromBalance = _balances[from];\n require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n unchecked {\n _balances[from] = fromBalance - amount;\n \n \n _balances[to] += amount;\n }\n emit Transfer(from, to, amount);\n _afterTokenTransfer(from, to, amount);\n }", "function bridgeWithdraw(address beneficiary, uint256 amount, uint256 depositChainId, bytes calldata signature) external returns (bool) {\n \n bytes32 txid = keccak256(abi.encode(msg.sender, depositChainId, block.chainid, _nonces[msg.sender][depositChainId][block.chainid]++, beneficiary, amount));\n \n function verifySignature(...) {...}\nrequire(verifySignature(txid, signature, amount), \"ERR_SIG\");\n \n uint256 fee = amount / 100 * feePercentage;\n feesCollected += fee;\n \n require(_qanx.transfer(beneficiary, amount - fee), \"ERR_TXN\");\n return true;\n }", "function verifySignature(bytes32 txid, bytes memory signature, uint256 amount) internal view returns (bool) {\n \n bytes32 r;\n bytes32 vs;\n \n assembly {\n r := mload(add(signature, 32))\n vs := mload(add(signature, 64))\n }\n \n bytes32 s = vs & 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n uint8 v = 27 + uint8(uint256(vs) >> 255);\n \n return amount < signers[ecrecover(txid, v, r, s)];\n }", "function transfer(address to, uint256 amount) external virtual override returns (bool) {\n address owner = _msgSender();\n function _transfer(...) {...}\n_transfer(owner, to, amount);\n return true;\n }", "function _transfer(\n address from,\n address to,\n uint256 amount\n ) internal virtual {\n require(from != address(0), \"ERC20: transfer from the zero address\");\n require(to != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(from, to, amount);\n uint256 fromBalance = _balances[from];\n require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n unchecked {\n _balances[from] = fromBalance - amount;\n \n \n _balances[to] += amount;\n }\n emit Transfer(from, to, amount);\n _afterTokenTransfer(from, to, amount);\n }", "function anySwapOutUnderlyingWithPermit(\n        address from,\n        address token,\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external {\n        address _underlying = AnyswapV1ERC20(token).underlying();\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n        AnyswapV1ERC20(token).depositVault(amount, from);\n        _anySwapOut(from, token, to, amount, toChainID);\n    }"], "label": "Yes", "detail": "On February 15, 2023, the AnyswapV4Router contract of Multichain was exploited via a frontrunning MEV bot. The attacker used a crafted transaction to call the anySwapOutUnderlyingWithPermit function before a legitimate user's transaction could execute. The function assumed the underlying token (WETH) supported the ERC-2612 permit interface, but WETH lacked the permit method. Consequently, the fallback deposit function was triggered instead of validating the signature. The attacker then successfully used safeTransferFrom to transfer the WETH to their own address without proper authorization, gaining approximately 87 ETH (~$130,000)."}
{"project": "Terra Bridge", "functions": ["function burn(\n address user,\n address receiverOfUnderlying,\n uint256 amount,\n uint256 index\n ) external override onlyLendingPool {\n uint256 amountScaled = amount.rayDiv(index);\n require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n _burn(user, amountScaled);\n IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n emit Transfer(user, address(0), amount);\n emit Burn(user, receiverOfUnderlying, amount, index);\n }", "function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), 'ERC20: burn from the zero address');\n _beforeTokenTransfer(account, address(0), amount);\n uint256 oldTotalSupply = _totalSupply;\n _totalSupply = oldTotalSupply.sub(amount);\n uint256 oldAccountBalance = _balances[account];\n _balances[account] = oldAccountBalance.sub(amount, 'ERC20: burn amount exceeds balance');\n if (address(_getIncentivesController()) != address(0)) {\n _getIncentivesController().handleAction(account, oldTotalSupply, oldAccountBalance);\n }\n }", "function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\n        }\n    }"], "label": "Yes", "detail": "The attacker on Ethereum called deposit() with malicious data but no actual ETH; since tokenAddress was zero, safeTransferFrom succeeded silently and a Deposit event was emitted. On BSC, relayers listened to that event and called voteProposal multiple times, leading to massive xETH minting."}
{"project": "NFT OmniBridge", "functions": ["function bridgeSpecificActionsOnTokenTransfer(\n address _token,\n address _from,\n address _receiver,\n uint256[] memory _tokenIds,\n uint256[] memory _values\n ) internal override {\n if (!isTokenRegistered(_token)) {\n _setNativeTokenIsRegistered(_token, REGISTERED);\n }\n function _prepareMessage(...) {...}\nfunction _isOracleDrivenLaneAllowed(...) {...}\nfunction _recordBridgeOperation(...) {...}\nbytes memory data = _prepareMessage(_token, _receiver, _tokenIds, _values);\n bytes32 _messageId = _passMessage(data, _isOracleDrivenLaneAllowed(_token, _from, _receiver));\n _recordBridgeOperation(_messageId, _token, _from, _tokenIds, _values);\n }", "function _prepareMessage(\n address _token,\n address _receiver,\n uint256[] memory _tokenIds,\n uint256[] memory _values\n ) internal returns (bytes memory) {\n require(_receiver != address(0) && _receiver != mediatorContractOnOtherSide());\n address nativeToken = nativeTokenAddress(_token);\n \n if (nativeToken == address(0)) {\n string[] memory tokenURIs = new string[](_tokenIds.length);\n if (_values.length > 0) {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n uint256 oldBalance = mediatorOwns(_token, _tokenIds[i]);\n uint256 newBalance = oldBalance.add(_values[i]);\n require(IERC1155(_token).balanceOf(address(this), _tokenIds[i]) >= newBalance);\n _setMediatorOwns(_token, _tokenIds[i], newBalance);\n tokenURIs[i] = _readERC1155TokenURI(_token, _tokenIds[i]);\n }\n } else {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n require(mediatorOwns(_token, _tokenIds[i]) == 0);\n require(IERC721(_token).ownerOf(_tokenIds[i]) == address(this));\n _setMediatorOwns(_token, _tokenIds[i], 1);\n tokenURIs[i] = _readERC721TokenURI(_token, _tokenIds[i]);\n }\n }\n \n if (isBridgedTokenDeployAcknowledged(_token)) {\n require(_tokenIds.length <= MAX_BATCH_BRIDGE_LIMIT);\n return\n abi.encodeWithSelector(\n this.handleBridgedNFT.selector,\n _token,\n _receiver,\n _tokenIds,\n _values,\n tokenURIs\n );\n }\n require(_tokenIds.length <= MAX_BATCH_BRIDGE_AND_DEPLOY_LIMIT);\n string memory name = _readName(_token);\n string memory symbol = _readSymbol(_token);\n return\n abi.encodeWithSelector(\n this.deployAndHandleBridgedNFT.selector,\n _token,\n name,\n symbol,\n _receiver,\n _tokenIds,\n _values,\n tokenURIs\n );\n }\n \n if (_values.length > 0) {\n IBurnableMintableERC1155Token(_token).burn(_tokenIds, _values);\n } else {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n IBurnableMintableERC721Token(_token).burn(_tokenIds[i]);\n }\n }\n return abi.encodeWithSelector(this.handleNativeNFT.selector, nativeToken, _receiver, _tokenIds, _values);\n }", "function _handleTokens(\n address _token,\n bool _isNative,\n address _recipient,\n uint256[] calldata _tokenIds,\n uint256[] calldata _values\n ) internal {\n require(isTokenExecutionAllowed(_token));\n function _releaseTokens(...) {...}\n_releaseTokens(_token, _isNative, _recipient, _tokenIds, _values);\n emit TokensBridged(_token, _recipient, _tokenIds, _values, messageId());\n }", "function _releaseTokens(\n address _token,\n bool _isNative,\n address _recipient,\n uint256[] memory _tokenIds,\n uint256[] memory _values\n ) internal {\n if (_values.length > 0) {\n if (_isNative) {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n _setMediatorOwns(_token, _tokenIds[i], mediatorOwns(_token, _tokenIds[i]).sub(_values[i]));\n }\n IERC1155(_token).safeBatchTransferFrom(address(this), _recipient, _tokenIds, _values, new bytes(0));\n } else {\n IBurnableMintableERC1155Token(_token).mint(_recipient, _tokenIds, _values);\n }\n } else {\n if (_isNative) {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n _setMediatorOwns(_token, _tokenIds[i], 0);\n IERC721(_token).transferFrom(address(this), _recipient, _tokenIds[i]);\n }\n } else {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n IBurnableMintableERC721Token(_token).mint(_recipient, _tokenIds[i]);\n }\n }\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
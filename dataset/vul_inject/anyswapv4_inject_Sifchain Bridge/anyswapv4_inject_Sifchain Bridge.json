{"project": "Sifchain Bridge", "functions": ["function lock(\n bytes memory _recipient,\n address _token,\n uint256 _amount\n ) public payable onlyEthTokenWhiteList(_token) validSifAddress(_recipient) whenNotPaused {\n string memory symbol;\n \n if (msg.value > 0) {\n require(\n _token == address(0),\n \"!address(0)\"\n );\n require(\n msg.value == _amount,\n \"incorrect eth amount\"\n );\n symbol = \"eth\";\n \n } else {\n IERC20 tokenToTransfer = IERC20(_token);\n tokenToTransfer.safeTransferFrom(\n msg.sender,\n address(this),\n _amount\n );\n symbol = BridgeToken(_token).symbol();\n }\n if (_amount > maxTokenAmount[symbol]) {\n revert(\"Amount being transferred is over the limit\");\n }\n lockFunds(msg.sender, _recipient, _token, symbol, _amount);\n }", "function lockFunds(\n address payable _sender,\n bytes memory _recipient,\n address _token,\n string memory _symbol,\n uint256 _amount\n ) internal {\n lockBurnNonce = lockBurnNonce.add(1);\n \n lockedTokenList[_symbol] = _token;\n lockedFunds[_token] = lockedFunds[_token].add(_amount);\n emit LogLock(_sender, _recipient, _token, _symbol, _amount, lockBurnNonce);\n }", "function mintNewBridgeTokens(\n address payable _intendedRecipient,\n address _bridgeTokenAddress,\n string memory _symbol,\n uint256 _amount\n ) internal {\n require(\n controlledBridgeTokens[_symbol] == _bridgeTokenAddress,\n \"Token must be a controlled bridge token\"\n );\n \n require(\n BridgeToken(_bridgeTokenAddress).mint(_intendedRecipient, _amount),\n \"Attempted mint of bridge tokens failed\"\n );\n emit LogBridgeTokenMint(\n _bridgeTokenAddress,\n _symbol,\n _amount,\n _intendedRecipient\n );\n }", "function anySwapOutUnderlyingWithPermit(\n        address from,\n        address token,\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external {\n        address _underlying = AnyswapV1ERC20(token).underlying();\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n        AnyswapV1ERC20(token).depositVault(amount, from);\n        _anySwapOut(from, token, to, amount, toChainID);\n    }"], "label": "Yes", "detail": "On February 15, 2023, the AnyswapV4Router contract of Multichain was exploited via a frontrunning MEV bot. The attacker used a crafted transaction to call the anySwapOutUnderlyingWithPermit function before a legitimate user's transaction could execute. The function assumed the underlying token (WETH) supported the ERC-2612 permit interface, but WETH lacked the permit method. Consequently, the fallback deposit function was triggered instead of validating the signature. The attacker then successfully used safeTransferFrom to transfer the WETH to their own address without proper authorization, gaining approximately 87 ETH (~$130,000)."}
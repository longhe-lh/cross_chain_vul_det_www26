{"project": "Sovryn Bridge", "functions": ["function burn(address usr, uint wad) external {\n require(balanceOf[usr] >= wad, \"Dai/insufficient-balance\");\n if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\n require(allowance[usr][msg.sender] >= wad, \"Dai/insufficient-allowance\");\n allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\n }\n function sub(...) {...}\nbalanceOf[usr] = sub(balanceOf[usr], wad);\n totalSupply = sub(totalSupply, wad);\n emit Transfer(usr, address(0), wad);\n }", "function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n uint fee = (_value.mul(basisPointsRate)).div(10000);\n if (fee > maximumFee) {\n fee = maximumFee;\n }\n uint sendAmount = _value.sub(fee);\n function sub(...) {...}\nfunction add(...) {...}\nbalances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(sendAmount);\n if (fee > 0) {\n balances[owner] = balances[owner].add(fee);\n Transfer(msg.sender, owner, fee);\n }\n Transfer(msg.sender, _to, sendAmount);\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
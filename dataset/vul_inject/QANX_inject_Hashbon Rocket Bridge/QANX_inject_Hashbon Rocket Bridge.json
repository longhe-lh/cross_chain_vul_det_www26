{"project": "Hashbon Rocket Bridge", "functions": ["function addOrder(\n uint _offerId,\n address _withdrawAddress,\n uint _amount,\n uint _payAmount\n ) public {\n require(_offerId < offers.length, \"Incorrect offerId\");\n require(offers[_offerId].active == true, \"Offer is inactive\");\n require(_amount > 0 || _payAmount > 0, \"Amount must be greater than 0\");\n uint rate = offers[_offerId].rate;\n if (_amount > 0) {\n _payAmount = (_amount * rate) / (10 ** RATE_DECIMALS);\n } else {\n _amount = (_payAmount * (10 ** RATE_DECIMALS)) / rate;\n }\n require(\n _amount >= offers[_offerId].minPurchase,\n \"Amount is less than the minimum purchase\"\n );\n uint blockedAmount = _getBlockedAmount(_offerId);\n require(\n _amount <= offers[_offerId].amount - blockedAmount,\n \"Not enough tokens in the offer\"\n );\n address _payAddress = offers[_offerId].payAddress;\n uint reservedUntil = block.timestamp + reservationTime;\n uint orderId = orders.length;\n orders.push(\n Order(\n _offerId,\n rate,\n msg.sender,\n _withdrawAddress,\n _amount,\n _payAmount,\n _payAddress,\n reservedUntil,\n false\n )\n );\n emit OrderAdd(\n orderId,\n _offerId,\n msg.sender,\n rate,\n _withdrawAddress,\n _amount,\n _payAmount,\n _payAddress,\n reservedUntil\n );\n }", "function withdrawTokens(uint _orderId, bytes calldata _sign) public {\n require(_orderId < orders.length, \"Incorrect orderId\");\n require(orders[_orderId].complete == false, \"Tokens already withdrawn\");\n uint offerId = orders[_orderId].offerId;\n uint amount = orders[_orderId].amount;\n uint payAmount = orders[_orderId].payAmount;\n address payToken = offers[offerId].payToken;\n address payAddress = orders[_orderId].payAddress;\n require(\n orders[_orderId].reservedUntil >= block.timestamp ||\n offers[offerId].amount - _getBlockedAmount(offerId) >= amount,\n \"Not enough tokens in the offer\"\n );\n bytes32 data = keccak256(\n abi.encodePacked(_orderId, payAmount, payToken, payAddress)\n );\n require(_verifySign(data, _sign), \"Incorrect signature\");\n TransferHelper.safeTransfer(\n offers[offerId].token,\n orders[_orderId].withdrawAddress,\n amount\n );\n orders[_orderId].complete = true;\n offers[offerId].amount -= amount;\n emit OrderComplete(_orderId, offers[offerId].amount);\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::safeTransfer: transfer failed\"\n );\n }", "function verifySignature(bytes32 txid, bytes memory signature, uint256 amount) internal view returns (bool) {\n        \n        bytes32 r;\n        bytes32 vs;\n        \n        assembly {\n            r := mload(add(signature, 32))\n            vs := mload(add(signature, 64))\n        }\n        \n        bytes32 s = vs & 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        uint8 v = 27 + uint8(uint256(vs) >> 255);\n        \n        return amount < signers[ecrecover(txid, v, r, s)];\n    }"], "label": "Yes", "detail": "The attacker cloned the original QANX Bridge contract, modified specific behaviors, and deployed it onto the BSC chain as a 'fake contract.' This fake contract's deposit behavior made it accept any input QANX amount as a parameter while only transferring 1 QANX internally. The fake contract created a transaction hash (`txid`) that looked legitimate and submitted this hash to the real QANX Bridge's signing nodes for authorization. Because the `verifySignature` function did not validate the transaction's `to` field (`tx.to`), the signing nodes failed to differentiate between the fake contract and the legitimate bridge contract, signing the malicious transaction. This allowed the attacker to withdraw 4.5 million QANX tokens from Ethereum, even though only 1 QANX token was legitimately bridged to the BSC chain."}
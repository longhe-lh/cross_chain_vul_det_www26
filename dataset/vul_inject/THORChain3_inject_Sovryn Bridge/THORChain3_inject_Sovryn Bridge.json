{"project": "Sovryn Bridge", "functions": ["function _executeTransaction(\n address originalTokenAddress,\n address receiver,\n uint256 amount,\n string memory symbol,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex,\n uint8 decimals,\n uint256 granularity,\n bytes memory userData,\n SignatureInfo[] memory signaturesInfos\n ) internal onlyMember returns (bool) {\n \n require(\n initStageDone == true,\n \"Federation: Cannot process TX while initStageDone == false\"\n );\n bytes32 transactionId = getTransactionId(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity\n );\n if (processed[transactionId]) return true;\n \n \n \n \n \n \n \n \n \n if (\n processSignedTransaction(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData,\n signaturesInfos\n )\n ) {\n \n \n return true;\n }\n return true;\n }", "function processSignedTransaction(\n address originalTokenAddress,\n address receiver,\n uint256 amount,\n string memory symbol,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex,\n uint8 decimals,\n uint256 granularity,\n bytes memory userData,\n SignatureInfo[] memory signaturesInfos\n ) internal returns (bool) {\n bytes32 transactionIdU = getTransactionIdU(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n if (processed[transactionIdU]) return true;\n \n function _msgSender(...) {...}\nvotes[transactionIdU][_msgSender()] = true;\n uint256 memberValidations = 1;\n emit Signed(transactionIdU, _msgSender());\n for (uint256 i; i < signaturesInfos.length; i += 1) {\n require(\n signaturesInfos[i].deadline > block.timestamp,\n \"Some signature is not valid anymore\"\n );\n uint256 chainId;\n assembly {\n chainId := chainid()\n }\n bytes32 hash = keccak256(\n abi.encodePacked(\n \"\\x19Ethereum Signed Message:\\n116\",\n abi.encodePacked(\n transactionIdU,\n chainId,\n address(this),\n signaturesInfos[i].deadline\n )\n )\n );\n address signer = ECDSA.recover(hash, signaturesInfos[i].signature);\n require(isMember[signer], \"Signature doesn't match any member\");\n if (!votes[transactionIdU][signer]) {\n votes[transactionIdU][signer] = true;\n memberValidations += 1;\n emit Signed(transactionIdU, signer);\n }\n }\n require(\n memberValidations >= required && memberValidations >= members.length / 2 + 1,\n \"Not enough validations\"\n );\n processed[transactionIdU] = true;\n releaseTokensOnBridge(\n transactionIdU,\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n emit Executed(transactionIdU);\n return true;\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didnâ€™t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
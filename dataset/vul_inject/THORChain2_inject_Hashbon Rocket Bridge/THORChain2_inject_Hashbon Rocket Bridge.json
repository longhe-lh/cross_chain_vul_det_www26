{"project": "Hashbon Rocket Bridge", "functions": ["function addOrder(\n uint _offerId,\n address _withdrawAddress,\n uint _amount,\n uint _payAmount\n ) public {\n require(_offerId < offers.length, \"Incorrect offerId\");\n require(offers[_offerId].active == true, \"Offer is inactive\");\n require(_amount > 0 || _payAmount > 0, \"Amount must be greater than 0\");\n uint rate = offers[_offerId].rate;\n if (_amount > 0) {\n _payAmount = (_amount * rate) / (10 ** RATE_DECIMALS);\n } else {\n _amount = (_payAmount * (10 ** RATE_DECIMALS)) / rate;\n }\n require(\n _amount >= offers[_offerId].minPurchase,\n \"Amount is less than the minimum purchase\"\n );\n uint blockedAmount = _getBlockedAmount(_offerId);\n require(\n _amount <= offers[_offerId].amount - blockedAmount,\n \"Not enough tokens in the offer\"\n );\n address _payAddress = offers[_offerId].payAddress;\n uint reservedUntil = block.timestamp + reservationTime;\n uint orderId = orders.length;\n orders.push(\n Order(\n _offerId,\n rate,\n msg.sender,\n _withdrawAddress,\n _amount,\n _payAmount,\n _payAddress,\n reservedUntil,\n false\n )\n );\n emit OrderAdd(\n orderId,\n _offerId,\n msg.sender,\n rate,\n _withdrawAddress,\n _amount,\n _payAmount,\n _payAddress,\n reservedUntil\n );\n }", "function withdrawTokens(uint _orderId, bytes calldata _sign) public {\n require(_orderId < orders.length, \"Incorrect orderId\");\n require(orders[_orderId].complete == false, \"Tokens already withdrawn\");\n uint offerId = orders[_orderId].offerId;\n uint amount = orders[_orderId].amount;\n uint payAmount = orders[_orderId].payAmount;\n address payToken = offers[offerId].payToken;\n address payAddress = orders[_orderId].payAddress;\n require(\n orders[_orderId].reservedUntil >= block.timestamp ||\n offers[offerId].amount - _getBlockedAmount(offerId) >= amount,\n \"Not enough tokens in the offer\"\n );\n bytes32 data = keccak256(\n abi.encodePacked(_orderId, payAmount, payToken, payAddress)\n );\n require(_verifySign(data, _sign), \"Incorrect signature\");\n TransferHelper.safeTransfer(\n offers[offerId].token,\n orders[_orderId].withdrawAddress,\n amount\n );\n orders[_orderId].complete = true;\n offers[offerId].amount -= amount;\n emit OrderComplete(_orderId, offers[offerId].amount);\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::safeTransfer: transfer failed\"\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
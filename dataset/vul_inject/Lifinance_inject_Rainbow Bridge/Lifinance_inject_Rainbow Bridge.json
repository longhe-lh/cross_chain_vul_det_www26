{"project": "Rainbow Bridge", "functions": ["function addLightClientBlock(bytes memory data) public override pausable(PAUSED_ADD_BLOCK) {\n require(initialized, \"Contract is not initialized\");\n require(balanceOf[msg.sender] >= lockEthAmount, \"Balance is not enough\");\n Borsh.Data memory borsh = Borsh.from(data);\n NearDecoder.LightClientBlock memory nearBlock = borsh.decodeLightClientBlock();\n borsh.done();\n \n if (block.timestamp < lastValidAt) {\n require(\n nearBlock.inner_lite.timestamp >= untrustedTimestamp.add(replaceDuration),\n \"Can only replace with a sufficiently newer block\"\n );\n } else if (lastValidAt != 0) {\n curHeight = untrustedHeight;\n if (untrustedNextEpoch) {\n curEpoch = (curEpoch + 1) % 3;\n }\n lastValidAt = 0;\n blockHashes_[curHeight] = untrustedHash;\n blockMerkleRoots_[curHeight] = untrustedMerkleRoot;\n }\n \n require(nearBlock.inner_lite.height > curHeight, \"New block must have higher height\");\n \n bool fromNextEpoch;\n if (nearBlock.inner_lite.epoch_id == epochs[curEpoch].epochId) {\n fromNextEpoch = false;\n } else if (nearBlock.inner_lite.epoch_id == epochs[(curEpoch + 1) % 3].epochId) {\n fromNextEpoch = true;\n } else {\n revert(\"Epoch id of the block is not valid\");\n }\n \n Epoch storage thisEpoch = epochs[fromNextEpoch ? (curEpoch + 1) % 3 : curEpoch];\n \n require(nearBlock.approvals_after_next.length >= thisEpoch.numBPs, \"Approval list is too short\");\n \n uint256 votedFor = 0;\n for ((uint i, uint cnt) = (0, thisEpoch.numBPs); i != cnt; ++i) {\n bytes32 stakes = thisEpoch.packedStakes[i >> 1];\n if (nearBlock.approvals_after_next[i].some) {\n votedFor += uint128(bytes16(stakes));\n }\n if (++i == cnt) {\n break;\n }\n if (nearBlock.approvals_after_next[i].some) {\n votedFor += uint128(uint256(stakes));\n }\n }\n require(votedFor > thisEpoch.stakeThreshold, \"Too few approvals\");\n \n if (fromNextEpoch) {\n require(nearBlock.next_bps.some, \"Next next_bps should not be None\");\n require(\n nearBlock.next_bps.hash == nearBlock.inner_lite.next_bp_hash,\n \"Hash of block producers does not match\"\n );\n }\n untrustedHeight = nearBlock.inner_lite.height;\n untrustedTimestamp = nearBlock.inner_lite.timestamp;\n untrustedHash = nearBlock.hash;\n untrustedMerkleRoot = nearBlock.inner_lite.block_merkle_root;\n untrustedNextHash = nearBlock.next_hash;\n uint256 signatureSet = 0;\n for ((uint i, uint cnt) = (0, thisEpoch.numBPs); i < cnt; i++) {\n NearDecoder.OptionalSignature memory approval = nearBlock.approvals_after_next[i];\n if (approval.some) {\n signatureSet |= 1 << i;\n untrustedSignatures[i] = approval.signature;\n }\n }\n untrustedSignatureSet = signatureSet;\n untrustedNextEpoch = fromNextEpoch;\n if (fromNextEpoch) {\n Epoch storage nextEpoch = epochs[(curEpoch + 2) % 3];\n nextEpoch.epochId = nearBlock.inner_lite.next_epoch_id;\n setBlockProducers(nearBlock.next_bps.blockProducers, nextEpoch);\n }\n lastSubmitter = msg.sender;\n lastValidAt = block.timestamp.add(lockDuration);\n }", "function setBlockProducers(NearDecoder.BlockProducer[] memory src, Epoch storage epoch) internal {\n uint cnt = src.length;\n require(cnt <= MAX_BLOCK_PRODUCERS);\n epoch.numBPs = cnt;\n for (uint i = 0; i < cnt; i++) {\n epoch.keys[i] = src[i].publicKey.k;\n }\n uint256 totalStake = 0; \n for (uint i = 0; i != cnt; ++i) {\n uint128 stake1 = src[i].stake;\n totalStake += stake1;\n if (++i == cnt) {\n epoch.packedStakes[i >> 1] = bytes32(bytes16(stake1));\n break;\n }\n uint128 stake2 = src[i].stake;\n totalStake += stake2;\n epoch.packedStakes[i >> 1] = bytes32(uint256(bytes32(bytes16(stake1))) + stake2);\n }\n epoch.stakeThreshold = (totalStake * 2) / 3;\n }", "function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n            \n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n            \n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n            _cBridgeData.amount = _postSwapBalance;\n        }\n        _startBridge(_cBridgeData);\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }"], "label": "Yes", "detail": "The attacker crafted a payload where the first element performs a small legitimate swap to pass the function's flow, while subsequent entries invoke transferFrom calls directlyâ€”leveraging users' infinite token approvals to siphon assets from multiple wallets. After draining funds, the contract continues normal bridge execution (_startBridge) to avoid transaction failure. The root cause is swapAndStartBridgeTokensViaCBridge allowing arbitrary call execution via LibSwap.swap() without any parameter validation or restrictions."}
{"project": "Snow Bridge", "functions": ["function submitFinal(Commitment calldata commitment, uint256[] calldata bitfield, ValidatorProof[] calldata proofs)\n public\n {\n (bytes32 commitmentHash, bytes32 ticketID) = validate(commitment, bitfield);\n Ticket storage ticket = tickets[ticketID];\n if (commitment.validatorSetID != currentValidatorSet.id) {\n revert InvalidCommitment();\n }\n verifyCommitment(commitmentHash, bitfield, currentValidatorSet, ticket, proofs);\n bytes32 newMMRRoot = getFirstMMRRoot(commitment);\n latestMMRRoot = newMMRRoot;\n latestBeefyBlock = commitment.blockNumber;\n emit NewMMRRoot(newMMRRoot, commitment.blockNumber);\n delete tickets[ticketID];\n }", "function verifyCommitment(\n bytes32 commitmentHash,\n uint256[] calldata bitfield,\n ValidatorSet memory vset,\n Ticket storage ticket,\n ValidatorProof[] calldata proofs\n ) internal view {\n \n uint256 signatureCount = minimumSignatureThreshold(vset.length);\n if (proofs.length != signatureCount) {\n revert InvalidValidatorProof();\n }\n \n uint256[] memory finalbitfield = Bitfield.subsample(ticket.prevRandao, bitfield, signatureCount, vset.length);\n for (uint256 i = 0; i < proofs.length;) {\n ValidatorProof calldata proof = proofs[i];\n \n if (!Bitfield.isSet(finalbitfield, proof.index)) {\n revert InvalidValidatorProof();\n }\n \n if (!isValidatorInSet(vset, proof.account, proof.index, proof.proof)) {\n revert InvalidValidatorProof();\n }\n \n if (ECDSA.recover(commitmentHash, proof.v, proof.r, proof.s) != proof.account) {\n revert InvalidSignature();\n }\n \n Bitfield.unset(finalbitfield, proof.index);\n unchecked {\n i++;\n }\n }\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didnâ€™t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
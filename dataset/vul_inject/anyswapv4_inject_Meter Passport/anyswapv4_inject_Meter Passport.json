{"project": "Meter Passport", "functions": ["function deposit(\n bytes32 resourceID,\n uint8 destinationChainID,\n uint64 depositNonce,\n address depositer,\n bytes calldata data\n ) external override onlyBridge {\n bytes memory recipientAddress;\n uint256 amount;\n uint256 lenRecipientAddress;\n assembly {\n amount := calldataload(0xC4)\n recipientAddress := mload(0x40)\n lenRecipientAddress := calldataload(0xE4)\n mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))\n calldatacopy(\n recipientAddress, \n 0xE4, \n sub(calldatasize(), 0xE) \n )\n }\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress != _wtokenAddress) {\n if (_burnList[tokenAddress]) {\n burnERC20(tokenAddress, depositer, amount);\n } else {\n lockERC20(tokenAddress, depositer, address(this), amount);\n }\n }\n _depositRecords[destinationChainID][depositNonce] = DepositRecord(\n tokenAddress,\n uint8(lenRecipientAddress),\n destinationChainID,\n resourceID,\n recipientAddress,\n depositer,\n amount\n );\n }", "function burnERC20(address tokenAddress, address owner, uint256 amount) internal {\n ERC20Burnable erc20 = ERC20Burnable(tokenAddress);\n function burnFrom(...) {...}\nerc20.burnFrom(owner, amount);\n }", "function lockERC20(address tokenAddress, address owner, address recipient, uint256 amount) internal {\n IERC20 erc20 = IERC20(tokenAddress);\n function _safeTransferFrom(...) {...}\n_safeTransferFrom(erc20, owner, recipient, amount);\n }", "function _safeTransferFrom(IERC20 token, address from, address to, uint256 value) private {\n function _safeCall(...) {...}\n_safeCall(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n }", "function _safeCall(IERC20 token, bytes memory data) private { \n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"ERC20: call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"ERC20: operation did not succeed\");\n }\n }", "function deposit(\n bytes32 resourceID,\n uint8 destinationChainID,\n uint64 depositNonce,\n address depositer,\n bytes calldata data\n ) external override onlyBridge {\n bytes memory recipientAddress;\n uint256 amount;\n uint256 lenRecipientAddress;\n assembly {\n amount := calldataload(0xC4)\n recipientAddress := mload(0x40)\n lenRecipientAddress := calldataload(0xE4)\n mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))\n calldatacopy(\n recipientAddress, \n 0xE4, \n sub(calldatasize(), 0xE) \n )\n }\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress != _wtokenAddress) {\n if (_burnList[tokenAddress]) {\n burnERC20(tokenAddress, depositer, amount);\n } else {\n lockERC20(tokenAddress, depositer, address(this), amount);\n }\n }\n _depositRecords[destinationChainID][depositNonce] = DepositRecord(\n tokenAddress,\n uint8(lenRecipientAddress),\n destinationChainID,\n resourceID,\n recipientAddress,\n depositer,\n amount\n );\n }", "function burnERC20(address tokenAddress, address owner, uint256 amount) internal {\n ERC20Burnable erc20 = ERC20Burnable(tokenAddress);\n function burnFrom(...) {...}\nerc20.burnFrom(owner, amount);\n }", "function lockERC20(address tokenAddress, address owner, address recipient, uint256 amount) internal {\n IERC20 erc20 = IERC20(tokenAddress);\n function _safeTransferFrom(...) {...}\n_safeTransferFrom(erc20, owner, recipient, amount);\n }", "function _safeTransferFrom(IERC20 token, address from, address to, uint256 value) private {\n function _safeCall(...) {...}\n_safeCall(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n }", "function _safeCall(IERC20 token, bytes memory data) private { \n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"ERC20: call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"ERC20: operation did not succeed\");\n }\n }", "function anySwapOutUnderlyingWithPermit(\n        address from,\n        address token,\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external {\n        address _underlying = AnyswapV1ERC20(token).underlying();\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n        AnyswapV1ERC20(token).depositVault(amount, from);\n        _anySwapOut(from, token, to, amount, toChainID);\n    }"], "label": "Yes", "detail": "On February 15, 2023, the AnyswapV4Router contract of Multichain was exploited via a frontrunning MEV bot. The attacker used a crafted transaction to call the anySwapOutUnderlyingWithPermit function before a legitimate user's transaction could execute. The function assumed the underlying token (WETH) supported the ERC-2612 permit interface, but WETH lacked the permit method. Consequently, the fallback deposit function was triggered instead of validating the signature. The attacker then successfully used safeTransferFrom to transfer the WETH to their own address without proper authorization, gaining approximately 87 ETH (~$130,000)."}
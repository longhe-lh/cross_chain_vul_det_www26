{"project": "SOY Bridge", "functions": ["function depositTokens(\n address receiver, \n address token, \n uint256 value, \n uint256 toChainId \n ) \n external\n payable\n notFrozen\n {\n require(functionMapping & 1 == 0, \"locked\"); \n require(receiver != address(0), \"Incorrect receiver address\");\n address pair_token = _deposit(token, value, toChainId);\n emit Deposit(token, receiver, value, toChainId, pair_token);\n }", "function _deposit(\n address token, \n uint256 value, \n uint256 toChainId \n ) \n internal \n returns (address pair_token) \n {\n Token memory pair = tokenPair[toChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n pair_token = pair.token;\n uint256 fee = msg.value;\n if (token <= MAX_NATIVE_COINS) {\n require(value <= msg.value, \"Wrong value\");\n fee -= value;\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).burnFrom(msg.sender, value);\n } else {\n tokenDeposits[token] += value;\n token.safeTransferFrom(msg.sender, address(this), value);\n }\n }\n if (fee != 0) {\n feeTo.safeTransferETH(fee);\n emit Fee(msg.sender, fee);\n }\n }", "function claim(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n isTxProcessed[fromChainId][txId] = true;\n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n function safeTransfer(...) {...}\ntoken.safeTransfer(to, value);\n }\n }\n emit Claim(token, to, value, txId, fromChainId, pair.token);\n }", "function process(bytes memory _message) public returns (bool _success) {\n        \n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        \n        bytes32 _messageHash = _m.keccak();\n        require(acceptableRoot(messages[_messageHash]), \"!proven\");\n        \n        require(entered == 1, \"!reentrant\");\n        entered = 0;\n        \n        messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n        \n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        \n        emit Process(_messageHash, true, \"\");\n        \n        entered = 1;\n        \n        return true;\n    }"], "label": "Yes", "detail": "Because confirmAt[bytes32(0)] was initialized to 1, acceptableRoot(bytes32(0)) always returns true, so attackers can submit arbitrary messages without proof and drain funds by calling process()"}
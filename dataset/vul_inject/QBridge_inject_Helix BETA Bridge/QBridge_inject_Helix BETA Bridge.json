{"project": "Helix BETA Bridge", "functions": ["function lockAndRemoteIssuing(\n uint32 remoteSpecVersion,\n uint256 remoteReceiveGasLimit,\n address token,\n address recipient,\n uint256 amount\n ) external payable whenNotPaused {\n require(\n IERC20(token).transferFrom(msg.sender, address(this), amount),\n \"Backing:transfer tokens failed\"\n );\n _lockAndRemoteIssuing(\n remoteSpecVersion,\n remoteReceiveGasLimit,\n token,\n recipient,\n amount,\n msg.value,\n false\n );\n }", "function _lockAndRemoteIssuing(\n uint32 remoteSpecVersion,\n uint256 remoteReceiveGasLimit,\n address token,\n address recipient,\n uint256 amount,\n uint256 prepaid,\n bool isNative\n ) internal {\n bytes memory issueMappingToken = abi.encodeWithSelector(\n IErc20MappingTokenFactory.issueMappingToken.selector,\n token,\n recipient,\n amount\n );\n (uint256 transferId, uint256 totalFee) = _sendMessage(\n remoteSpecVersion,\n remoteReceiveGasLimit,\n issueMappingToken,\n prepaid\n );\n require(\n lockedMessages[transferId].hash == bytes32(0),\n \"backing: message exist\"\n );\n bytes32 lockMessageHash = hash(\n abi.encodePacked(transferId, token, msg.sender, amount)\n );\n lockedMessages[transferId] = LockedInfo(lockMessageHash, false);\n emit TokenLocked(\n transferId,\n isNative,\n token,\n msg.sender,\n recipient,\n amount,\n totalFee\n );\n }", "function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\n        }\n    }"], "label": "Yes", "detail": "The attacker on Ethereum called deposit() with malicious data but no actual ETH; since tokenAddress was zero, safeTransferFrom succeeded silently and a Deposit event was emitted. On BSC, relayers listened to that event and called voteProposal multiple times, leading to massive xETH minting."}
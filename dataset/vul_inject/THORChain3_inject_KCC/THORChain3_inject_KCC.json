{"project": "KCC", "functions": ["function depositNative(string memory _targetAddress, string memory chain) public payable {\n require(msg.value >= swapFee, \"Bridge:insufficient swap fee\");\n if (swapFee != 0) {\n payable(feeTo).transfer(swapFee);\n }\n emit DepositNative(msg.sender, msg.value - swapFee, _targetAddress, chain, swapFee);\n }", "function withdrawNative(address payable to, uint value, string memory proof, bytes32 taskHash) public\n onlyOperator\n whenNotPaused\n positiveValue(value)\n returns (bool)\n {\n require(address(this).balance >= value, \"Bridge:not enough native token\");\n require(taskHash == keccak256((abi.encodePacked(to, value, proof))), \"Bridge:taskHash is wrong\");\n require(!filledTx[taskHash], \"Bridge:tx filled already\");\n uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n if (status == logic.TASKPROCESSING()) {\n emit WithdrawingNative(to, value, proof);\n } else if (status == logic.TASKDONE()) {\n emit WithdrawingNative(to, value, proof);\n emit WithdrawDoneNative(to, value, proof);\n to.transfer(value);\n filledTx[taskHash] = true;\n logic.removeTask(taskHash);\n }\n return true;\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didnâ€™t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
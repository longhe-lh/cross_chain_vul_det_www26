{"project": "Arbitrum Bridge", "functions": ["function executeCall(\n address to,\n uint256 value,\n bytes calldata data\n ) external returns (bool success, bytes memory returnData) {\n if (!allowedOutboxesMap[msg.sender].allowed)\n revert NotOutbox(msg.sender);\n if (data.length > 0 && !to.isContract()) revert NotContract(to);\n address prevOutbox = _activeOutbox;\n _activeOutbox = msg.sender;\n \n \n \n \n (success, returnData) = to.call{value: value}(data);\n _activeOutbox = prevOutbox;\n emit BridgeCallTriggered(msg.sender, to, value, data);\n }", "function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external {\n if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);\n roots[root] = l2BlockHash;\n emit SendRootUpdated(root, l2BlockHash);\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
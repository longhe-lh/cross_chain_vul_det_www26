{"project": "Boba Gateway bridge", "functions": ["function appendSequencerBatch() external {\n uint40 shouldStartAtElement;\n uint24 totalElementsToAppend;\n uint24 numContexts;\n assembly {\n shouldStartAtElement := shr(216, calldataload(4))\n totalElementsToAppend := shr(232, calldataload(9))\n numContexts := shr(232, calldataload(12))\n }\n require(\n shouldStartAtElement == getTotalElements(),\n \"Actual batch start index does not match expected start index.\"\n );\n require(\n msg.sender == resolve(\"OVM_Sequencer\"),\n \"Function can only be called by the Sequencer.\"\n );\n uint40 nextTransactionPtr = uint40(\n BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts\n );\n require(\n msg.data.length >= nextTransactionPtr,\n \"Not enough BatchContexts provided.\"\n );\n \n uint32 numSequencerTransactions = 0;\n \n \n \n uint40 nextQueueIndex = _nextQueueIndex;\n BatchContext memory curContext;\n for (uint32 i = 0; i < numContexts; i++) {\n BatchContext memory nextContext = _getBatchContext(i);\n \n curContext = nextContext;\n \n numSequencerTransactions += uint32(\n curContext.numSequencedTransactions\n );\n \n nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);\n }\n require(\n nextQueueIndex <= queueElements.length,\n \"Attempted to append more elements than are available in the queue.\"\n );\n \n uint40 numQueuedTransactions = totalElementsToAppend -\n numSequencerTransactions;\n uint40 blockTimestamp;\n uint40 blockNumber;\n if (curContext.numSubsequentQueueTransactions == 0) {\n \n \n blockTimestamp = uint40(curContext.timestamp);\n blockNumber = uint40(curContext.blockNumber);\n } else {\n \n \n \n \n \n Lib_OVMCodec.QueueElement memory lastElement = queueElements[\n nextQueueIndex - 1\n ];\n blockTimestamp = lastElement.timestamp;\n blockNumber = lastElement.blockNumber;\n }\n \n _appendBatch(\n blockhash(block.number - 1),\n totalElementsToAppend,\n numQueuedTransactions,\n blockTimestamp,\n blockNumber\n );\n emit SequencerBatchAppended(\n nextQueueIndex - numQueuedTransactions,\n numQueuedTransactions,\n getTotalElements()\n );\n \n _nextQueueIndex = nextQueueIndex;\n }", "function _appendBatch(\n bytes32 _transactionRoot,\n uint256 _batchSize,\n uint256 _numQueuedTransactions,\n uint40 _timestamp,\n uint40 _blockNumber\n ) internal {\n IChainStorageContainer batchesRef = batches();\n (\n uint40 totalElements,\n uint40 nextQueueIndex,\n ,\n ) = _getBatchExtraData();\n Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec\n .ChainBatchHeader({\n batchIndex: batchesRef.length(),\n batchRoot: _transactionRoot,\n batchSize: _batchSize,\n prevTotalElements: totalElements,\n extraData: hex\"\"\n });\n emit TransactionBatchAppended(\n header.batchIndex,\n header.batchRoot,\n header.batchSize,\n header.prevTotalElements,\n header.extraData\n );\n bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\n bytes27 latestBatchContext = _makeBatchExtraData(\n totalElements + uint40(header.batchSize),\n nextQueueIndex + uint40(_numQueuedTransactions),\n _timestamp,\n _blockNumber\n );\n batchesRef.push(batchHeaderHash, latestBatchContext);\n }", "function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n        \n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n        uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\n        uint n = polyChainBKs.length;\n        if (header.height >= curEpochStartHeight) {\n            \n            require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n        } else {\n            \n            require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n            \n            ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\n            bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);\n            require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n        }\n        \n        bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\n        \n        ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\n        require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n        require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n        \n        require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");\n        \n        address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\n        \n        require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n        \n        \n        emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\n        return true;\n    }"], "label": "Yes", "detail": "The PolyNetwork attack exploited a critical flaw in the EthCrossChainManager contract, which failed to properly validate the `method` string in incoming cross-chain requests. By crafting a transaction from Ontology that appeared legitimate and passed through PolyChain, the attacker called `putCurEpochConPubKeyBytes` on the Ethereum-side EthCrossChainData contract. This replaced the authorized keeper public keys with attacker-controlled keys. Subsequent fake transactions using forged signatures were accepted, leading to unauthorized asset minting and withdrawal across multiple blockchains. The exploit occurred because there was no method whitelist or contract-level access control on cross-chain delegated calls."}
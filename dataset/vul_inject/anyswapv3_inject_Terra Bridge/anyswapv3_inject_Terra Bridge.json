{"project": "Terra Bridge", "functions": ["func (self *RecvMsg) Run(workid int, ch chan interface{}) bool {\n\tif workid < 0 || workid >= RPCMaxWorker { \n\t\tres2 := RpcDcrmRes{Ret: \"\", Tip: \"dcrm back-end internal error:get worker id fail\", Err: fmt.Errorf(\"no find worker.\")}\n\t\tch <- res2\n\t\treturn false\n\t}\n\tres := self.msg\n\tif res == \"\" { \n\t\tres2 := RpcDcrmRes{Ret: \"\", Tip: \"dcrm back-end internal error:get data fail in RecvMsg.Run\", Err: fmt.Errorf(\"no find worker.\")}\n\t\tch <- res2\n\t\treturn false\n\t}\n\tmsgdata, errdec := DecryptMsg(res) \n\tif errdec == nil {\n\t\tres = msgdata\n\t}\n\tmm := strings.Split(res, common.Sep)\n\tif len(mm) >= 2 {\n\t\t\n\t\t\n\t\tDisMsg(res)\n\t\treturn true\n\t}\n\tmsgmap := make(map[string]string)\n\terr := json.Unmarshal([]byte(res), &msgmap)\n\tif err == nil {\n\t\t\n\t\tif msgmap[\"Type\"] == \"PreSign\" {\n\t\t\tps := &PreSign{}\n\t\t\tif err = ps.UnmarshalJSON([]byte(msgmap[\"PreSign\"])); err == nil {\n\t\t\t\tw := workers[workid]\n\t\t\t\tw.sid = ps.Nonce\n\t\t\t\tw.groupid = ps.Gid\n\t\t\t\tw.DcrmFrom = ps.Pub\n\t\t\t\tgcnt, _ := GetGroup(w.groupid)\n\t\t\t\tw.NodeCnt = gcnt \n\t\t\t\tw.ThresHold = gcnt\n\t\t\t\tdcrmpks, _ := hex.DecodeString(ps.Pub)\n\t\t\t\texsit, da := GetPubKeyDataFromLocalDb(string(dcrmpks[:]))\n\t\t\t\tif !exsit {\n\t\t\t\t\ttime.Sleep(time.Duration(5000000000))\n\t\t\t\t\texsit, da = GetPubKeyDataFromLocalDb(string(dcrmpks[:]))\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif !exsit {\n\t\t\t\t\tcommon.Debug(\"============================PreSign at RecvMsg.Run,not exist presign data===========================\", \"pubkey\", ps.Pub)\n\t\t\t\t\tres := RpcDcrmRes{Ret: \"\", Tip: \"dcrm back-end internal error:get presign data from db fail\", Err: fmt.Errorf(\"get presign data from db fail\")}\n\t\t\t\t\tch <- res\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tpd, ok := da.(*PubKeyData)\n\t\t\t\tif !ok {\n\t\t\t\t\tcommon.Debug(\"============================PreSign at RecvMsg.Run,presign data error==========================\", \"pubkey\", ps.Pub)\n\t\t\t\t\tres := RpcDcrmRes{Ret: \"\", Tip: \"dcrm back-end internal error:get presign data from db fail\", Err: fmt.Errorf(\"get presign data from db fail\")}\n\t\t\t\t\tch <- res\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tsave := (da.(*PubKeyData)).Save\n\t\t\t\t\n\t\t\t\tda2 := GetSkU1FromLocalDb(string(dcrmpks[:]))\n\t\t\t\tif da2 == nil {\n\t\t\t\t\tres := RpcDcrmRes{Ret: \"\", Tip: \"presign get sku1 fail\", Err: fmt.Errorf(\"presign get sku1 fail\")}\n\t\t\t\t\tch <- res\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tsku1 := new(big.Int).SetBytes(da2)\n\t\t\t\tif sku1 == nil {\n\t\t\t\t\tres := RpcDcrmRes{Ret: \"\", Tip: \"presign get sku1 fail\", Err: fmt.Errorf(\"presign get sku1 fail\")}\n\t\t\t\t\tch <- res\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\texsit, da3 := GetValueFromPubKeyData(pd.Key)\n\t\t\t\tac, ok := da3.(*AcceptReqAddrData)\n\t\t\t\tif ok {\n\t\t\t\t\tHandleC1Data(ac, w.sid, workid)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar ch1 = make(chan interface{}, 1)\n\t\t\t\tpre := PreSign_ec3(w.sid, save, sku1, \"ECDSA\", ch1, workid)\n\t\t\t\tif pre == nil {\n\t\t\t\t\tres := RpcDcrmRes{Ret: \"\", Tip: \"presign fail\", Err: fmt.Errorf(\"presign fail\")}\n\t\t\t\t\tch <- res\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpre.Key = w.sid\n\t\t\t\tpre.Gid = w.groupid\n\t\t\t\tpre.Used = false\n\t\t\t\tDtPreSign.Lock()\n\t\t\t\tes, err := Encode2(pre)\n\t\t\t\tcommon.Debug(\"========================PreSign at RecvMsg.Run finish,ecode pre-sign data.=================\", \"err\", err, \"pick key\", pre.Key)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpub := Keccak256Hash([]byte(strings.ToLower(ps.Pub + \":\" + ps.Gid))).Hex()\n\t\t\t\t\tPutPreSign(pub, pre)\n\t\t\t\t\tkd := UpdataPreSignData{Key: []byte(strings.ToLower(pub)), Del: false, Data: es, ThresHold: w.ThresHold}\n\t\t\t\t\tPrePubKeyDataChan <- kd\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tDtPreSign.Unlock()\n\t\t\t\t\n\t\t\t\tres := RpcDcrmRes{Ret: \"success\", Tip: \"\", Err: nil}\n\t\t\t\tch <- res\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\t\n\t\tif msgmap[\"Type\"] == \"SignData\" {\n\t\t\tsd := &SignData{}\n\t\t\tif err = sd.UnmarshalJSON([]byte(msgmap[\"SignData\"])); err == nil {\n\t\t\t\tcommon.Debug(\"===============RecvMsg.Run,it is signdata===================\", \"msgprex\", sd.MsgPrex, \"key\", sd.Key)\n\t\t\t\tys := secp256k1.S256().Marshal(sd.Pkx, sd.Pky)\n\t\t\t\tpubkeyhex := hex.EncodeToString(ys)\n\t\t\t\tpub := Keccak256Hash([]byte(strings.ToLower(pubkeyhex + \":\" + sd.GroupId))).Hex()\n\t\t\t\tpre := GetPrePubDataBak(pub, sd.PickKey)\n\t\t\t\tif pre == nil {\n\t\t\t\t\tcommon.Info(\"===============RecvMsg.Run,it is signdata, get pre sign data fail===================\", \"msgprex\", sd.MsgPrex, \"key\", sd.Key, \"pick key\", sd.PickKey, \"pub\", pub)\n\t\t\t\t\tres2 := RpcDcrmRes{Ret: \"\", Tip: \"dcrm back-end internal error:get pre sign data fail\", Err: fmt.Errorf(\"get pre sign data fail\")}\n\t\t\t\t\tch <- res2\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tw := workers[workid]\n\t\t\t\tw.sid = sd.Key\n\t\t\t\tw.groupid = sd.GroupId\n\t\t\t\tw.NodeCnt = sd.NodeCnt\n\t\t\t\tw.ThresHold = sd.ThresHold\n\t\t\t\tw.DcrmFrom = sd.DcrmFrom\n\t\t\t\tdcrmpks, _ := hex.DecodeString(pubkeyhex)\n\t\t\t\texsit, da := GetPubKeyDataFromLocalDb(string(dcrmpks[:]))\n\t\t\t\tif exsit {\n\t\t\t\t\tpd, ok := da.(*PubKeyData)\n\t\t\t\t\tif ok {\n\t\t\t\t\t\texsit, da2 := GetValueFromPubKeyData(pd.Key)\n\t\t\t\t\t\tif exsit {\n\t\t\t\t\t\t\tac, ok := da2.(*AcceptReqAddrData)\n\t\t\t\t\t\t\tif ok {\n\t\t\t\t\t\t\t\tHandleC1Data(ac, sd.Key, workid)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar ch1 = make(chan interface{}, 1)\n\t\t\t\tfor i := 0; i < recalc_times; i++ {\n\t\t\t\t\tcommon.Debug(\"===============RecvMsg.Run,sign recalc===================\", \"i\", i, \"msgprex\", sd.MsgPrex, \"key\", sd.Key)\n\t\t\t\t\tif len(ch1) != 0 {\n\t\t\t\t\t\t<-ch1\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tSign_ec3(sd.Key, sd.Txhash, sd.Keytype, sd.Pkx, sd.Pky, ch1, workid, pre)\n\t\t\t\t\tcommon.Info(\"===============RecvMsg.Run, ec3 sign finish ===================\", \"WaitMsgTimeGG20\", WaitMsgTimeGG20)\n\t\t\t\t\tret, _, cherr := GetChannelValue(WaitMsgTimeGG20+10, ch1)\n\t\t\t\t\tif ret != \"\" && cherr == nil {\n\t\t\t\t\t\tww, err2 := FindWorker(sd.MsgPrex)\n\t\t\t\t\t\tif err2 != nil || ww == nil {\n\t\t\t\t\t\t\tres2 := RpcDcrmRes{Ret: \"\", Tip: \"dcrm back-end internal error:no find worker\", Err: fmt.Errorf(\"no find worker\")}\n\t\t\t\t\t\t\tch <- res2\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcommon.Info(\"===============RecvMsg.Run, ec3 sign success ===================\", \"i\", i, \"get ret\", ret, \"cherr\", cherr, \"msgprex\", sd.MsgPrex, \"key\", sd.Key)\n\t\t\t\t\t\tww.rsv.PushBack(ret)\n\t\t\t\t\t\tres2 := RpcDcrmRes{Ret: ret, Tip: \"\", Err: nil}\n\t\t\t\t\t\tch <- res2\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\tcommon.Info(\"===============RecvMsg.Run,ec3 sign fail===================\", \"ret\", ret, \"cherr\", cherr, \"msgprex\", sd.MsgPrex, \"key\", sd.Key)\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tres2 := RpcDcrmRes{Ret: \"\", Tip: \"sign fail\", Err: fmt.Errorf(\"sign fail\")}\n\t\t\t\tch <- res2\n\t\t\t\treturn false\n\t\t\t} \n\t\t}\n\t\t\n\t\tif msgmap[\"Type\"] == \"PreSignDataStatus\" {\n\t\t\tpsds := &PreSignDataStatus{}\n\t\t\tif err = psds.UnmarshalJSON([]byte(msgmap[\"PreSignDataStatus\"])); err == nil {\n\t\t\t\tw := workers[workid]\n\t\t\t\tw.sid = psds.MsgPrex\n\t\t\t\tw.groupid = psds.Gid\n\t\t\t\tw.ThresHold = psds.ThresHold\n\t\t\t\tif CheckAllSignNodesPreSignDataStatus(psds.MsgPrex, ch, w) == false {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\tsignbrocast, err := UnCompressSignBrocastData(res)\n\tif err == nil {\n\t\terrtmp := InitAcceptData2(signbrocast, workid, self.sender, ch)\n\t\tif errtmp == nil {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\t\n\terrtmp := InitAcceptData(res, workid, self.sender, ch)\n\tif errtmp == nil {\n\t\treturn true\n\t}\n\tcommon.Debug(\"================RecvMsg.Run, init accept data fail=================\", \"res\", res, \"err\", errtmp)\n\treturn false\n}"], "label": "Yes", "detail": "The vulnerability occurred in the off-chain MPC signature system of Anyswap V3 Router. During the processing of incoming SignData messages in RecvMsg.Run(), the function GetPrePubDataBak retrieves previously cached PrePubData which contains signature intermediate states. This PrePubData is reused in the signing function Sign_ec3 without regenerating a new random nonce k, causing multiple ECDSA signatures to share the same R value. As a result, attackers were able to collect valid (r, s, hash) signature tuples with identical R values on multiple chains (Ethereum, BSC, Fantom), and successfully derived the private key of the MPC signer using ECDSA key recovery formulas. Additionally, the function PutPreSign does not enforce strong deduplication or cleanup of old PrePubData, which further increased the risk when the MPC node was restarted. The attacker eventually used the recovered private key to forge signatures and invoke anySwapIn() on destination chains to withdraw assets illegally. Total losses exceeded $6 million."}
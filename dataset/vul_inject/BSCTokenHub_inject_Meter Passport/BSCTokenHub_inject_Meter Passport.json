{"project": "Meter Passport", "functions": ["function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint256 amount;\n bytes memory destinationRecipientAddress;\n assembly {\n amount := calldataload(0x64)\n destinationRecipientAddress := mload(0x40)\n let lenDestinationRecipientAddress := calldataload(0x84)\n mstore(0x40, add(0x20, add(destinationRecipientAddress, lenDestinationRecipientAddress)))\n \n calldatacopy(\n destinationRecipientAddress, \n 0x84, \n sub(calldatasize(), 0x84) \n )\n }\n bytes20 recipientAddress;\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress == _wtokenAddress) {\n IWETH(_wtokenAddress).withdraw(amount);\n \n TransferHelper.safeTransferETH(address(recipientAddress), amount);\n return;\n }\n if (_burnList[tokenAddress]) {\n mintERC20(tokenAddress, address(recipientAddress), amount);\n } else {\n releaseERC20(tokenAddress, address(recipientAddress), amount);\n }\n }", "function mintERC20(address tokenAddress, address recipient, uint256 amount) internal {\n ERC20PresetMinterPauser erc20 = ERC20PresetMinterPauser(tokenAddress);\n function mint(...) {...}\nerc20.mint(recipient, amount);\n }", "function releaseERC20(address tokenAddress, address recipient, uint256 amount) internal {\n IERC20 erc20 = IERC20(tokenAddress);\n function _safeTransfer(...) {...}\n_safeTransfer(erc20, recipient, amount);\n }", "function _safeTransfer(IERC20 token, address to, uint256 value) private {\n function _safeCall(...) {...}\n_safeCall(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n }", "function _safeCall(IERC20 token, bytes memory data) private { \n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"ERC20: call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"ERC20: operation did not succeed\");\n }\n }", "function voteProposal(\n uint8 domainID,\n uint64 depositNonce,\n bytes32 resourceID,\n bytes calldata data\n ) external onlyRelayers whenNotPaused nonReentrant {\n address handler = _resourceIDToHandlerAddress[resourceID];\n uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(domainID);\n bytes32 dataHash = keccak256(\n abi.encodePacked(resourceID, handler, data)\n );\n Proposal memory proposal = _proposals[nonceAndID][dataHash];\n require(\n _resourceIDToHandlerAddress[resourceID] != address(0),\n \"no handler for resourceID\"\n );\n if (proposal._status == ProposalStatus.Passed) {\n _executeProposal(domainID, depositNonce, data, resourceID, true);\n return;\n }\n address sender = _msgSender();\n require(\n uint256(proposal._status) <= 1,\n \"proposal already executed/cancelled\"\n );\n require(!_hasVoted(proposal, sender), \"relayer already voted\");\n if (proposal._status == ProposalStatus.Inactive) {\n proposal = Proposal({\n _status: ProposalStatus.Active,\n _yesVotes: 0,\n _yesVotesTotal: 0,\n _proposedBlock: uint40(block.number) \n });\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Active,\n dataHash\n );\n } else if (\n uint40(sub(block.number, proposal._proposedBlock)) > _expiry\n ) {\n \n \n proposal._status = ProposalStatus.Cancelled;\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Cancelled,\n dataHash\n );\n }\n if (proposal._status != ProposalStatus.Cancelled) {\n proposal._yesVotes = (proposal._yesVotes | _relayerBit(sender))\n .toUint200();\n proposal._yesVotesTotal++; \n emit ProposalVote(\n domainID,\n depositNonce,\n proposal._status,\n dataHash\n );\n \n if (proposal._yesVotesTotal >= _relayerThreshold) {\n proposal._status = ProposalStatus.Passed;\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Passed,\n dataHash\n );\n }\n }\n _proposals[nonceAndID][dataHash] = proposal;\n if (proposal._status == ProposalStatus.Passed) {\n _executeProposal(domainID, depositNonce, data, resourceID, false);\n }\n }", "func (pin ProofInnerNode) Hash(childHash []byte) ([]byte, error) {\n\thasher := sha256.New()\n\tbuf := bufPool.Get().(*bytes.Buffer)\n\tbuf.Reset()\n\tdefer bufPool.Put(buf)\n\terr := encoding.EncodeVarint(buf, int64(pin.Height))\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Size)\n\t}\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Version)\n\t}\n\tif len(pin.Left) == 0 {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Right)\n\t\t}\n\t} else {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Left)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to hash ProofInnerNode: %v\", err)\n\t}\n\t_, err = hasher.Write(buf.Bytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn hasher.Sum(nil), nil\n}"], "label": "Yes", "detail": "An attacker exploited this by constructing an IAVL proof containing multiple leaves and deliberately populating `LeftPath[1].Right` and `Leaves[1]` with fabricated values. Since the `Hash` function ignored `pin.Right` when `pin.Left` was set, the resulting root hash remained correct and passed `bytes.Equal(rootHash, lpath.Right)` checks. SharkTeam explicitly notes the vulnerability: “when pin.Left is not empty, the situation where pin.Right is null or not is not handled… pin.Right does not participate in the calculation of Hash” :contentReference[oaicite:1]{index=1}."}
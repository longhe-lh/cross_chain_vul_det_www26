{"project": "MapProtocol", "functions": ["function transferOutTokenBurn(address token, address to, uint amount, uint toChainId) external payable\n checkBalance(token,msg.sender,amount) {\n function safeTransferFrom(...) {...}\nTransferHelper.safeTransferFrom(token,msg.sender,address(this),amount);\n collectChainFee(toChainId,0);\n uint outAmount = getAmountWithdraw(amount);\n transferFeeList[token] = transferFeeList[token].add(amount).sub(outAmount);\n IMAPToken(token).burn(outAmount);\n bytes32 orderId = getOrderID(token, msg.sender, to, outAmount, toChainId);\n emit mapTransferOut(token, msg.sender, to, orderId, outAmount, selfChainId, toChainId);\n }", "function safeTransferFrom(address token, address from, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n }", "function transferInToken(address token, address from, address payable to, uint amount, bytes32 orderId, uint fromChain, uint toChain)\n external checkOrder(orderId) nonReentrant onlyManager{\n uint outAmount = getAmountWithdraw(amount);\n if (toChain == selfChainId) {\n require(IERC20(token).balanceOf(address(this)) >= amount,\"balance too low\");\n function safeTransfer(...) {...}\nTransferHelper.safeTransfer(token,to,amount);\n emit mapTransferIn(token, from, to, orderId, outAmount, fromChain, toChain);\n }else{\n emit mapTransferOut(token, from, to, orderId, outAmount, fromChain, toChain);\n }\n }", "function safeTransfer(address token, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n }", "function anySwapOutUnderlyingWithPermit(\n        address from,\n        address token,\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external {\n        address _underlying = AnyswapV1ERC20(token).underlying();\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n        AnyswapV1ERC20(token).depositVault(amount, from);\n        _anySwapOut(from, token, to, amount, toChainID);\n    }"], "label": "Yes", "detail": "On February 15, 2023, the AnyswapV4Router contract of Multichain was exploited via a frontrunning MEV bot. The attacker used a crafted transaction to call the anySwapOutUnderlyingWithPermit function before a legitimate user's transaction could execute. The function assumed the underlying token (WETH) supported the ERC-2612 permit interface, but WETH lacked the permit method. Consequently, the fallback deposit function was triggered instead of validating the signature. The attacker then successfully used safeTransferFrom to transfer the WETH to their own address without proper authorization, gaining approximately 87 ETH (~$130,000)."}
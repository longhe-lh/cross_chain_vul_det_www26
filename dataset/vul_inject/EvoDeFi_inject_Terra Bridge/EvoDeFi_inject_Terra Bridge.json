{"project": "Terra Bridge", "functions": ["function mint(\n address user,\n uint256 amount,\n uint256 index\n ) external override onlyLendingPool returns (bool) {\n uint256 previousBalance = super.balanceOf(user);\n uint256 amountScaled = amount.rayDiv(index);\n require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n _mint(user, amountScaled);\n emit Transfer(address(0), user, amount);\n emit Mint(user, amount, index);\n return previousBalance == 0;\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), 'ERC20: mint to the zero address');\n _beforeTokenTransfer(address(0), account, amount);\n uint256 oldTotalSupply = _totalSupply;\n _totalSupply = oldTotalSupply.add(amount);\n uint256 oldAccountBalance = _balances[account];\n _balances[account] = oldAccountBalance.add(amount);\n if (address(_getIncentivesController()) != address(0)) {\n _getIncentivesController().handleAction(account, oldTotalSupply, oldAccountBalance);\n }\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
{"project": "Router Protocol", "functions": ["function voteProposal(\n uint8 chainID,\n uint64 depositNonce,\n bytes32 resourceID,\n bytes32 dataHash\n ) public virtual isResourceID(resourceID) onlyRole(RELAYER_ROLE) whenNotPaused {\n bytes32 proposalHash = keccak256(abi.encodePacked(chainID, depositNonce, dataHash));\n if (_proposals[proposalHash] == 0) {\n uint256 id = _voter.createProposal(block.number + _expiry, _quorum);\n _proposals[proposalHash] = id;\n _proposalDetails[id] = proposalStruct(chainID, depositNonce, resourceID, dataHash);\n emit ProposalEvent(chainID, depositNonce, IVoterUpgradeable.ProposalStatus.Active, dataHash);\n } else if (_voter.fetchIsExpired(_proposals[proposalHash])) {\n _voter.setStatus(_proposals[proposalHash]);\n emit ProposalEvent(chainID, depositNonce, _voter.getStatus(_proposals[proposalHash]), dataHash);\n return;\n }\n if (_voter.getStatus(_proposals[proposalHash]) != IVoterUpgradeable.ProposalStatus.Cancelled) {\n _voter.vote(_proposals[proposalHash], 1, msg.sender);\n emit ProposalVote(chainID, depositNonce, _voter.getStatus(_proposals[proposalHash]), dataHash);\n if (_voter.getStatus(_proposals[proposalHash]) == IVoterUpgradeable.ProposalStatus.Passed) {\n emit ProposalEvent(chainID, depositNonce, _voter.getStatus(_proposals[proposalHash]), dataHash);\n }\n }\n }", "function vote(\n uint256 issueId,\n uint8 option,\n address relayer\n )\n public\n virtual\n isBridge\n isvalidIssue(issueId)\n isNotVoted(issueId, relayer)\n isValidOption(option)\n isNotEnded(issueId)\n isValidbalance(relayer)\n returns (bool success)\n {\n uint256 balance = balanceOf(relayer);\n hasVoted[issueId][relayer] = hasVotedStruct(true, option);\n voteWeight[issueId][option] = voteWeight[issueId][option] + balance;\n issueMap[issueId].maxVotes = issueMap[issueId].maxVotes + balance;\n uint256 yes = voteWeight[issueId][1];\n uint256 yesPercent = (yes * (10000)) / (totalSupply()); \n if (yesPercent > issueMap[issueId].quorum) _setStatus(issueId, 1, ProposalStatus.Passed);\n emit OnVote(issueId, relayer, balance);\n return true;\n }", "func (pin ProofInnerNode) Hash(childHash []byte) ([]byte, error) {\n\thasher := sha256.New()\n\tbuf := bufPool.Get().(*bytes.Buffer)\n\tbuf.Reset()\n\tdefer bufPool.Put(buf)\n\terr := encoding.EncodeVarint(buf, int64(pin.Height))\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Size)\n\t}\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Version)\n\t}\n\tif len(pin.Left) == 0 {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Right)\n\t\t}\n\t} else {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Left)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to hash ProofInnerNode: %v\", err)\n\t}\n\t_, err = hasher.Write(buf.Bytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn hasher.Sum(nil), nil\n}"], "label": "Yes", "detail": "An attacker exploited this by constructing an IAVL proof containing multiple leaves and deliberately populating `LeftPath[1].Right` and `Leaves[1]` with fabricated values. Since the `Hash` function ignored `pin.Right` when `pin.Left` was set, the resulting root hash remained correct and passed `bytes.Equal(rootHash, lpath.Right)` checks. SharkTeam explicitly notes the vulnerability: “when pin.Left is not empty, the situation where pin.Right is null or not is not handled… pin.Right does not participate in the calculation of Hash” :contentReference[oaicite:1]{index=1}."}
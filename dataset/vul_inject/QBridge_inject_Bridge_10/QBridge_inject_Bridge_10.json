{"project": "Bridge_10", "functions": ["function swap(\n address recepient,\n uint256 amount,\n address erc20from,\n uint256 chainIdto,\n address erc20to\n ) external isBridgeValid(erc20from, chainIdto, erc20to) {\n IExampleToken(erc20from).burn(msg.sender, amount);\n nonce += 1;\n emit SwapInitialized(\n msg.sender,\n recepient,\n amount,\n getChainID(),\n erc20from,\n chainIdto,\n erc20to,\n nonce\n );\n }", "function burn(\n address account,\n uint256 amount\n ) public onlyRole(BURNER_ROLE) enoughTokens(account, amount) {\n balances[account] -= amount;\n totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }", "modifier isBridgeValid(\n address erc20from,\n uint256 chainIdto,\n address erc20to\n ) {\n require(\n isERC20valid[getChainID()][erc20from],\n \"ERC20 address from is not valid\"\n );\n require(\n isERC20valid[chainIdto][erc20to],\n \"Chain id or ERC20 address to is not valid\"\n );\n _;\n }", "function getChainID() public view returns (uint256) {\n uint256 id;\n assembly {\n id := chainid()\n }\n return id;\n }", "function redeem(\n address recepient,\n uint256 amount,\n uint256 chainIdfrom,\n address erc20from,\n address erc20to,\n uint256 nonce,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external {\n require(\n isERC20valid[chainIdfrom][erc20from],\n \"Chain id or ERC20 address from is not valid\"\n );\n require(\n isERC20valid[getChainID()][erc20to],\n \"ERC20 on this chain is not valid\"\n );\n require(\n checkSign(\n recepient,\n amount,\n chainIdfrom,\n erc20from,\n nonce,\n v,\n r,\n s\n ),\n \"Input is not valid\"\n );\n bytes32 redeemHash = keccak256(\n abi.encodePacked(\n recepient,\n amount,\n chainIdfrom,\n erc20from,\n nonce,\n v,\n r,\n s\n )\n );\n redeemStatus[redeemHash] = Status.Undone;\n require(redeemStatus[redeemHash] == Status.Undone, \"Hash is not valid\");\n redeemStatus[redeemHash] = Status.Done;\n IExampleToken(erc20to).mint(recepient, amount);\n emit RedeemInitialized(\n recepient,\n amount,\n erc20to,\n chainIdfrom,\n erc20from,\n nonce\n );\n }", "function checkSign(\n address recepient,\n uint256 amount,\n uint256 chainIdfrom,\n address erc20from,\n uint256 nonce,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public view returns (bool) {\n bytes32 message = keccak256(\n abi.encodePacked(recepient, amount, chainIdfrom, erc20from, nonce)\n );\n address function hashMessage(...) {...}\naddr = ecrecover(hashMessage(message), v, r, s);\n if (addr == validator) {\n return true;\n } else {\n return false;\n }\n }", "function hashMessage(bytes32 message) private pure returns (bytes32) {\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n return keccak256(abi.encodePacked(prefix, message));\n }", "function mint(\n address account,\n uint256 amount\n ) public onlyRole(MINTER_ROLE) {\n balances[account] += amount;\n totalSupply += amount;\n emit Transfer(address(0), account, amount);\n }", "function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\n        }\n    }"], "label": "Yes", "detail": "The attacker on Ethereum called deposit() with malicious data but no actual ETH; since tokenAddress was zero, safeTransferFrom succeeded silently and a Deposit event was emitted. On BSC, relayers listened to that event and called voteProposal multiple times, leading to massive xETH minting."}
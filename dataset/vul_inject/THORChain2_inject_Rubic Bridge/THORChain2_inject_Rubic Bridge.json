{"project": "Rubic Bridge", "functions": ["function crossChainWithSwap(\n BaseCrossChainParams calldata _params,\n string calldata _providerName\n )\n external\n payable\n nonReentrant\n whenNotPaused\n eventEmitter(_params, _providerName)\n {\n IntegratorFeeInfo memory _info = integratorToFeeInfo[\n _params.integrator\n ];\n IERC20(_params.srcInputToken).transferFrom(\n msg.sender,\n address(this),\n _params.srcInputAmount\n );\n accrueFixedCryptoFee(_params.integrator, _info);\n uint256 _amountIn = accrueTokenFees(\n _params.integrator,\n _info,\n _params.srcInputAmount,\n 0,\n _params.srcInputToken\n );\n SmartApprove.smartApprove(\n _params.srcInputToken,\n _amountIn,\n _params.router\n );\n ITestDEX(_params.router).swap(\n _params.srcInputToken,\n _amountIn,\n _params.dstOutputToken\n );\n }", "function accrueFixedCryptoFee(\n address _integrator,\n IntegratorFeeInfo memory _info\n ) internal returns (uint256) {\n uint256 _fixedCryptoFee;\n uint256 _RubicPart;\n if (_info.isIntegrator) {\n _fixedCryptoFee = uint256(_info.fixedFeeAmount);\n if (_fixedCryptoFee > 0) {\n _RubicPart =\n (_fixedCryptoFee *\n _info.RubicFixedCryptoShare) /\n DENOMINATOR;\n availableIntegratorCryptoFee[_integrator] +=\n _fixedCryptoFee -\n _RubicPart;\n }\n } else {\n _fixedCryptoFee = fixedCryptoFee;\n _RubicPart = _fixedCryptoFee;\n }\n availableRubicCryptoFee += _RubicPart;\n emit FixedCryptoFee(\n _RubicPart,\n _fixedCryptoFee - _RubicPart,\n _integrator\n );\n \n return (msg.value - _fixedCryptoFee);\n }", "function accrueTokenFees(\n address _integrator,\n IntegratorFeeInfo memory _info,\n uint256 _amountWithFee,\n uint256 _initBlockchainNum,\n address _token\n ) internal returns (uint256) {\n (uint256 _totalFees, uint256 _RubicFee) = _calculateFee(\n _info,\n _amountWithFee,\n _initBlockchainNum\n );\n if (_integrator != address(0)) {\n availableIntegratorTokenFee[_token][_integrator] +=\n _totalFees -\n _RubicFee;\n }\n availableRubicTokenFee[_token] += _RubicFee;\n emit TokenFee(\n _RubicFee,\n _totalFees - _RubicFee,\n _integrator,\n _token\n );\n return _amountWithFee - _totalFees;\n }", "function smartApprove(\n address _tokenIn,\n uint256 _amount,\n address _to\n ) internal {\n IERC20Upgradeable tokenIn = IERC20Upgradeable(_tokenIn);\n uint256 _allowance = tokenIn.allowance(\n address(this),\n _to\n );\n if (_allowance < _amount) {\n if (_allowance == 0) {\n tokenIn.safeApprove(_to, type(uint256).max);\n } else {\n try\n tokenIn.approve(_to, type(uint256).max)\n returns (bool res) {\n if (!res) {\n revert ApproveFailed();\n }\n } catch {\n tokenIn.safeApprove(_to, 0);\n tokenIn.safeApprove(_to, type(uint256).max);\n }\n }\n }\n }", "function changeTxStatus(\n bytes32 _id,\n SwapStatus _statusCode\n ) external onlyManagerOrAdmin {\n if (_statusCode == SwapStatus.Null) {\n revert CantSetToNull();\n }\n SwapStatus _status = processedTransactions[_id];\n if (\n _status == SwapStatus.Succeeded ||\n _status == SwapStatus.Fallback\n ) {\n revert Unchangeable();\n }\n processedTransactions[_id] = _statusCode;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
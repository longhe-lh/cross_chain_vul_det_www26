{"project": "NFT OmniBridge", "functions": ["function bridgeSpecificActionsOnTokenTransfer(\n address _token,\n address _from,\n address _receiver,\n uint256[] memory _tokenIds,\n uint256[] memory _values\n ) internal override {\n if (!isTokenRegistered(_token)) {\n _setNativeTokenIsRegistered(_token, REGISTERED);\n }\n function _prepareMessage(...) {...}\nfunction _isOracleDrivenLaneAllowed(...) {...}\nfunction _recordBridgeOperation(...) {...}\nbytes memory data = _prepareMessage(_token, _receiver, _tokenIds, _values);\n bytes32 _messageId = _passMessage(data, _isOracleDrivenLaneAllowed(_token, _from, _receiver));\n _recordBridgeOperation(_messageId, _token, _from, _tokenIds, _values);\n }", "function _prepareMessage(\n address _token,\n address _receiver,\n uint256[] memory _tokenIds,\n uint256[] memory _values\n ) internal returns (bytes memory) {\n require(_receiver != address(0) && _receiver != mediatorContractOnOtherSide());\n address nativeToken = nativeTokenAddress(_token);\n \n if (nativeToken == address(0)) {\n string[] memory tokenURIs = new string[](_tokenIds.length);\n if (_values.length > 0) {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n uint256 oldBalance = mediatorOwns(_token, _tokenIds[i]);\n uint256 newBalance = oldBalance.add(_values[i]);\n require(IERC1155(_token).balanceOf(address(this), _tokenIds[i]) >= newBalance);\n _setMediatorOwns(_token, _tokenIds[i], newBalance);\n tokenURIs[i] = _readERC1155TokenURI(_token, _tokenIds[i]);\n }\n } else {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n require(mediatorOwns(_token, _tokenIds[i]) == 0);\n require(IERC721(_token).ownerOf(_tokenIds[i]) == address(this));\n _setMediatorOwns(_token, _tokenIds[i], 1);\n tokenURIs[i] = _readERC721TokenURI(_token, _tokenIds[i]);\n }\n }\n \n if (isBridgedTokenDeployAcknowledged(_token)) {\n require(_tokenIds.length <= MAX_BATCH_BRIDGE_LIMIT);\n return\n abi.encodeWithSelector(\n this.handleBridgedNFT.selector,\n _token,\n _receiver,\n _tokenIds,\n _values,\n tokenURIs\n );\n }\n require(_tokenIds.length <= MAX_BATCH_BRIDGE_AND_DEPLOY_LIMIT);\n string memory name = _readName(_token);\n string memory symbol = _readSymbol(_token);\n return\n abi.encodeWithSelector(\n this.deployAndHandleBridgedNFT.selector,\n _token,\n name,\n symbol,\n _receiver,\n _tokenIds,\n _values,\n tokenURIs\n );\n }\n \n if (_values.length > 0) {\n IBurnableMintableERC1155Token(_token).burn(_tokenIds, _values);\n } else {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n IBurnableMintableERC721Token(_token).burn(_tokenIds[i]);\n }\n }\n return abi.encodeWithSelector(this.handleNativeNFT.selector, nativeToken, _receiver, _tokenIds, _values);\n }", "function _handleTokens(\n address _token,\n bool _isNative,\n address _recipient,\n uint256[] calldata _tokenIds,\n uint256[] calldata _values\n ) internal {\n require(isTokenExecutionAllowed(_token));\n function _releaseTokens(...) {...}\n_releaseTokens(_token, _isNative, _recipient, _tokenIds, _values);\n emit TokensBridged(_token, _recipient, _tokenIds, _values, messageId());\n }", "function _releaseTokens(\n address _token,\n bool _isNative,\n address _recipient,\n uint256[] memory _tokenIds,\n uint256[] memory _values\n ) internal {\n if (_values.length > 0) {\n if (_isNative) {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n _setMediatorOwns(_token, _tokenIds[i], mediatorOwns(_token, _tokenIds[i]).sub(_values[i]));\n }\n IERC1155(_token).safeBatchTransferFrom(address(this), _recipient, _tokenIds, _values, new bytes(0));\n } else {\n IBurnableMintableERC1155Token(_token).mint(_recipient, _tokenIds, _values);\n }\n } else {\n if (_isNative) {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n _setMediatorOwns(_token, _tokenIds[i], 0);\n IERC721(_token).transferFrom(address(this), _recipient, _tokenIds[i]);\n }\n } else {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n IBurnableMintableERC721Token(_token).mint(_recipient, _tokenIds[i]);\n }\n }\n }\n }", "function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n            \n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n            \n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n            _cBridgeData.amount = _postSwapBalance;\n        }\n        _startBridge(_cBridgeData);\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }"], "label": "Yes", "detail": "The attacker crafted a payload where the first element performs a small legitimate swap to pass the function's flow, while subsequent entries invoke transferFrom calls directlyâ€”leveraging users' infinite token approvals to siphon assets from multiple wallets. After draining funds, the contract continues normal bridge execution (_startBridge) to avoid transaction failure. The root cause is swapAndStartBridgeTokensViaCBridge allowing arbitrary call execution via LibSwap.swap() without any parameter validation or restrictions."}
{"project": "iotube", "functions": ["function depositTo(address _token, address _to, uint256 _amount) public whenNotPaused payable {\n require(_to != address(0), \"invalid destination\");\n bool isCoin = false;\n uint256 fee = msg.value;\n if (_token == address(0)) {\n require(msg.value >= _amount, \"insufficient msg.value\");\n fee = msg.value - _amount;\n wrappedCoin.deposit.value(_amount)();\n _token = address(wrappedCoin);\n isCoin = true;\n }\n require(fee >= depositFee, \"insufficient fee\");\n for (uint256 i = 0; i < tokenLists.length; i++) {\n if (tokenLists[i].isAllowed(_token)) {\n require(_amount >= tokenLists[i].minAmount(_token), \"amount too low\");\n require(_amount <= tokenLists[i].maxAmount(_token), \"amount too high\");\n if (tokenSafes[i] == address(0)) {\n require(!isCoin && safeTransferFrom(_token, msg.sender, address(this), _amount), \"fail to transfer token to cashier\");\n \n (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x42966c68, _amount));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"fail to burn token\");\n } else {\n if (isCoin) {\n require(safeTransfer(_token, tokenSafes[i], _amount), \"failed to put into safe\");\n } else {\n require(safeTransferFrom(_token, msg.sender, tokenSafes[i], _amount), \"failed to put into safe\");\n }\n }\n counts[_token] += 1;\n emit Receipt(_token, counts[_token], msg.sender, _to, _amount, fee);\n return;\n }\n }\n revert(\"not a whitelisted token\");\n }", "function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n \n (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x23b872dd, _from, _to, _amount));\n return success && (data.length == 0 || abi.decode(data, (bool)));\n }", "function safeTransfer(address _token, address _to, uint256 _amount) internal returns (bool) {\n \n (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0xa9059cbb, _to, _amount));\n return success && (data.length == 0 || abi.decode(data, (bool)));\n }", "function addToken(address _token, uint256 _min, uint256 _max) public onlyOwner returns (bool success_) {\n if (activateItem(_token)) {\n require(_min > 0 && _max > _min, \"invalid parameters\");\n settings[_token] = Setting(_min, _max);\n emit TokenAdded(_token, _min, _max);\n success_ = true;\n }\n }", "function activateItem(address _item) internal returns (bool) {\n if (existAndActives[_item].active) {\n return false;\n }\n if (!existAndActives[_item].exist) {\n items.push(_item);\n }\n num++;\n existAndActives[_item] = ExistAndActive(true, true);\n return true;\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didnâ€™t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
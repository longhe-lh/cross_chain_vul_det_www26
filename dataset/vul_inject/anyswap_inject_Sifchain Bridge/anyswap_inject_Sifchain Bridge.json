{"project": "Sifchain Bridge", "functions": ["function mintNewBridgeTokens(\n address payable _intendedRecipient,\n address _bridgeTokenAddress,\n string memory _symbol,\n uint256 _amount\n ) internal {\n require(\n controlledBridgeTokens[_symbol] == _bridgeTokenAddress,\n \"Token must be a controlled bridge token\"\n );\n \n require(\n BridgeToken(_bridgeTokenAddress).mint(_intendedRecipient, _amount),\n \"Attempted mint of bridge tokens failed\"\n );\n emit LogBridgeTokenMint(\n _bridgeTokenAddress,\n _symbol,\n _amount,\n _intendedRecipient\n );\n }", "function unlock(\n address payable _recipient,\n string memory _symbol,\n uint256 _amount\n ) public onlyCosmosBridge whenNotPaused {\n \n require(\n getLockedFunds(_symbol) >= _amount,\n \"!Bank funds\"\n );\n \n address tokenAddress = lockedTokenList[_symbol];\n if (tokenAddress == address(0)) {\n require(\n ((address(this)).balance) >= _amount,\n \"Insufficient ethereum balance for delivery.\"\n );\n } else {\n require(\n BridgeToken(tokenAddress).balanceOf(address(this)) >= _amount,\n \"Insufficient ERC20 token balance for delivery.\"\n );\n }\n unlockFunds(_recipient, tokenAddress, _symbol, _amount);\n }", "function unlockFunds(\n address payable _recipient,\n address _token,\n string memory _symbol,\n uint256 _amount\n ) internal {\n \n lockedFunds[_token] = lockedFunds[_token].sub(_amount);\n \n if (_token == address(0)) {\n (bool success,) = _recipient.call.value(_amount)(\"\");\n require(success, \"error sending ether\");\n } else {\n IERC20 tokenToTransfer = IERC20(_token);\n tokenToTransfer.safeTransfer(_recipient, _amount);\n }\n emit LogUnlock(_recipient, _token, _symbol, _amount);\n }", "function depositWithPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns (uint) {\n        IERC20(underlying).permit(target, address(this), value, deadline, v, r, s);\n        IERC20(underlying).safeTransferFrom(target, address(this), value);\n        return _deposit(value, to);\n    }"], "label": "Yes", "detail": "The attacker exploited the fact that some tokens do not implement `permit()` but include a fallback function that silently accepts calls without reverting. By invoking `depositWithPermit`, the attacker could spoof the `target` (the victim address) and bypass approval checks because `permit()` succeeded trivially. Afterwards, `safeTransferFrom(target, ...)` would transfer tokens from the victim to the attacker-controlled contract. This is an authentication bypass in the cross-chain liquidity pool contract, allowing theft of user funds without a valid permit or signature."}
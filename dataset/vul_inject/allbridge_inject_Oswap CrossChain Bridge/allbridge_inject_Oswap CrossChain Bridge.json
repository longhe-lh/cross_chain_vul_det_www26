{"project": "Oswap CrossChain Bridge", "functions": ["function cancelOrder(bytes[] calldata signatures, uint256 orderId, bool canceledByOrderOwner, uint256 protocolFee) external override whenNotPaused {\n Order storage order = orders[orderId];\n require(orderStatus[orderId] == OrderStatus.Pending || orderStatus[orderId] == OrderStatus.RequestAmend, \"BridgeVault: cancel not requested\");\n (,,address govTokenOracle, address assetTokenOracle, uint256 baseFee,) = configStore.getBridgeParams(asset);\n uint256 price = assetPriceAgainstGovToken(govTokenOracle, assetTokenOracle);\n (uint256[] memory signers, ) = _verifyStakedValue(signatures, hashCancelOrderParams(orderId, canceledByOrderOwner, protocolFee), order.inAmount * 1e18 / price);\n uint256 refundAmount = orders[orderId].inAmount;\n \n uint256 fee;\n if (canceledByOrderOwner) {\n fee = baseFee + protocolFee;\n refundAmount -= fee;\n imbalance -= toInt256(fee);\n protocolFeeBalance += fee;\n }\n orderRefunds[orderId] = refundAmount;\n orderStatus[orderId] = OrderStatus.RefundApproved;\n emit OrderCanceled(orderId, msg.sender, signers, canceledByOrderOwner, imbalance, protocolFeeBalance);\n }", "function _verifyStakedValue(address msgSender, bytes[] calldata signatures, bytes32 paramsHash) internal returns (uint256 superTrollCount, uint totalStake, uint256[] memory signers) {\n require(!usedNonce[paramsHash], \"nonce used\");\n usedNonce[paramsHash] = true;\n uint256 generalTrollCount;\n {\n uint256 length = signatures.length;\n signers = new uint256[](length);\n address lastSigningTroll;\n for (uint256 i = 0; i < length; ++i) {\n address troll = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", paramsHash)).recover(signatures[i]);\n require(troll != address(0), \"Invalid signer\");\n uint256 trollProfileIndex = trollRegistry.trollProfileInv(troll);\n if (trollProfileIndex > 0 && troll > lastSigningTroll) {\n signers[i] = trollProfileIndex;\n if (trollRegistry.isSuperTroll(troll, true)) {\n superTrollCount++;\n } else if (trollRegistry.isGeneralTroll(troll, true)) {\n generalTrollCount++;\n }\n totalStake += trollStakesBalances[trollProfileIndex];\n lastSigningTroll = troll;\n }\n }\n }\n (uint256 generalTrollMinCount, uint256 superTrollMinCount, uint256 transactionsGap) = configStore.getSignatureVerificationParams();\n require(generalTrollCount >= generalTrollMinCount, \"OSWAP_BridgeVault: Mininum general troll count not met\");\n require(superTrollCount >= superTrollMinCount, \"OSWAP_BridgeVault: Mininum super troll count not met\");\n \n uint256 _transactionsCount = (++transactionsCount);\n require((lastTrollTxCount[msgSender] + transactionsGap < _transactionsCount) || (_transactionsCount <= transactionsGap), \"too soon\");\n lastTrollTxCount[msgSender] = _transactionsCount;\n }", "function swapToVUsd(address user, uint256 amount) external onlyRouter returns (uint256) {\n        uint256 result; \n        uint256 fee;\n        if (amount > 0) {\n            fee = amount * feeShareBP / BP;\n            uint256 amountIn = toSystemPrecision(amount - fee);\n            \n            fee = amount - fromSystemPrecision(amountIn);\n            tokenBalance += amountIn;\n            uint256 vUsdNewAmount = this.getY(tokenBalance);\n            if (vUsdBalance > vUsdNewAmount) {\n                result = vUsdBalance - vUsdNewAmount;\n            }\n            vUsdBalance = vUsdNewAmount;\n            token.safeTransferFrom(user, address(this), amount);\n            _addRewards(fee);\n        }\n        emit SwappedToVUsd(user, address(token), amount, result, fee);\n        return result;\n    }"], "label": "Yes", "detail": "The attacker took out a 7.5 million BUSD flash loan, then made large deposits and swaps in the BUSD–vUSD and USDT–vUSD pools to manipulate exchange rates. They then swapped assets in the reverse direction to gain profits of approximately 550,000 BUSD before repaying the flash loan."}
{"project": "Instant Cross", "functions": ["function exchangeBuy(bytes32 pmId,bytes32 channel,bytes32 xHash, bytes memory goodsInfo, address goodsReceiptor,address payToken)public {\n bytes32 cctTxHash = keccak256(abi.encodePacked(nonce,address(this)));\n ProofRecord storage proofRecord = proofHistory[cctTxHash];\n require((proofRecord.cctTxHash == 0x0),\"proofRecord is exists\");\n proofRecord.toChain = cctChannel.getChannelCrossChain(channel);\n proofRecord.pmId = pmId;\n proofRecord.channel = channel;\n proofRecord.cctTxHash = cctTxHash;\n proofRecord.status = ProofStatus.LOCK;\n \n exchangBuyLockHandle(cctTxHash, channel,xHash, goodsInfo, goodsReceiptor,payToken);\n nonce +=1;\n currentTxHash = cctTxHash;\n emit ExchangeBuy(chainId,proofRecord.toChain,proofRecord.pmId,proofRecord.channel,cctTxHash,SRVID,ENTRYMOD_EXCHANGEBUYLOCK,xHash,goodsInfo,goodsReceiptor,payToken);\n }", "function exchangBuyLockHandle(bytes32 cctTxHash, bytes32 channel,bytes32 xHash, bytes memory goodsInfo, address goodsReceiptor,address payToken) private returns(bool){\n \n address goodsOwner;\n address receiptToken;\n uint amount;\n address subSrvGoods;\n subSrvGoods = cctChannel.getChannelSubSrv(channel,SRVID_GOODS);\n require(contractExists(subSrvGoods),\"GoodsProxy not exists\");\n (goodsOwner,receiptToken,amount) = GoodsProxy(subSrvGoods).buyLock(cctTxHash,xHash, goodsInfo, goodsReceiptor);\n setSubSrvStatus(cctTxHash,SRVID_GOODS,ProofStatus.LOCK);\n address subSrvExchange;\n address exchangeReceiptor;\n subSrvExchange = cctChannel.getChannelSubSrv(channel,SRVID_EXCHANGE);\n require(contractExists(subSrvExchange),\"ExchangeProxy not exists\");\n (exchangeReceiptor,amount) = ExchangeProxy(subSrvExchange).exchangeLock(cctTxHash,xHash, payToken, receiptToken,amount,goodsOwner);\n setSubSrvStatus(cctTxHash,SRVID_EXCHANGE,ProofStatus.LOCK);\n wrch_.lock(cctTxHash,xHash, payToken, amount, msg.sender,exchangeReceiptor);\n setSubSrvStatus(cctTxHash,SRVID_WRCH,ProofStatus.CONFIRM);\n return true;\n }", "function commit( bytes32 cctTxHash, bytes32 x) public{\n ProofRecord storage proofRecord = proofHistory[cctTxHash];\n\t require(proofRecord.cctTxHash != 0x0, \"proofRecord not exists\");\n require(proofRecord.status == ProofStatus.CONFIRM,\"proofRecord valid\");\n uint i;\n for (i = 0; i < proofRecord.subSrvStatuList.length; i++) {\n address subSrv;\n if(proofRecord.subSrvStatuList[i].srvId == SRVID_EXCHANGE){\n subSrv = cctChannel.getChannelSubSrv(proofRecord.channel,SRVID_EXCHANGE);\n \n Exchange(subSrv).exchangeCommit(cctTxHash,x);\n }else if(proofRecord.subSrvStatuList[i].srvId == SRVID_GOODS){\n subSrv = cctChannel.getChannelSubSrv(proofRecord.channel,SRVID_GOODS);\n \n Goods(subSrv).buyCommit(cctTxHash, x);\n }else{\n require(false,\"\");\n }\n }\n proofRecord.status = ProofStatus.COMMIT;\n emit Commit(chainId,cctChannel.getChannelCrossChain(proofRecord.channel),proofRecord.pmId,proofRecord.channel,proofRecord.cctTxHash,SRVID,ENTRYMOD_EXCHANGEBUYCOMMIT,x);\n }", "function exchangeCommit(bytes32 cctTxHash, bytes32 x) public authorized returns(bool){\n bytes32 xHash = keccak256(abi.encodePacked(x));\n HTLCInfo storage htlc = htlcHistory[cctTxHash];\n if(htlc.xHash == 0x0 || htlc.xHash != xHash || htlc.expireTime < now || htlc.status != HTLCStatus.LOCKED){\n return false;\n }\n htlc.status = HTLCStatus.COMMIT;\n incomeMap[htlc.currencyToken] = SafeMath.add(incomeMap[htlc.currencyToken],htlc.originAmount);\n emit ExchangeCommit(cctTxHash);\n return true;\n }", "function buyCommit(bytes32 cctTxHash, bytes32 x) public authorized returns(bool){\n bytes32 xHash = keccak256(abi.encodePacked(x));\n HTLCInfo storage htlc = htlcHistory[cctTxHash];\n if(htlc.xHash == 0x0 || htlc.xHash != xHash || htlc.expireTime < now || htlc.status != HTLCStatus.LOCKED){\n return false;\n }\n htlc.status = HTLCStatus.COMMIT;\n emit GoodsCommit(cctTxHash);\n return true;\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
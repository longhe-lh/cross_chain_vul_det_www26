{"project": "SOY Bridge", "functions": ["function claim(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n isTxProcessed[fromChainId][txId] = true;\n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n function safeTransfer(...) {...}\ntoken.safeTransfer(to, value);\n }\n }\n emit Claim(token, to, value, txId, fromChainId, pair.token);\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didnâ€™t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
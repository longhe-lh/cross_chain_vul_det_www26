{"project": "Hyphen", "functions": ["function sendFundsToUser(\n address tokenAddress,\n uint256 amount,\n address payable receiver,\n bytes calldata depositHash,\n uint256 tokenGasPrice,\n uint256 fromChainId\n ) external nonReentrant onlyExecutor whenNotPaused {\n uint256 initialGas = gasleft();\n TokenConfig memory config = tokenManager.getTransferConfig(\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Withdraw amount not in Cap limit\"\n );\n require(receiver != address(0), \"Bad receiver address\");\n (bytes32 hashSendTransaction, bool status) = checkHashStatus(\n tokenAddress,\n amount,\n receiver,\n depositHash\n );\n require(!status, \"Already Processed\");\n processedHash[hashSendTransaction] = true;\n \n uint256[4] memory transferDetails = getAmountToTransfer(\n initialGas,\n tokenAddress,\n amount,\n tokenGasPrice\n );\n liquidityProviders.decreaseCurrentLiquidity(\n tokenAddress,\n transferDetails[0]\n );\n if (tokenAddress == NATIVE) {\n (bool success, ) = receiver.call{value: transferDetails[0]}(\"\");\n require(success, \"Native Transfer Failed\");\n } else {\n SafeERC20Upgradeable.safeTransfer(\n IERC20Upgradeable(tokenAddress),\n receiver,\n transferDetails[0]\n );\n }\n emit AssetSent(\n tokenAddress,\n amount,\n transferDetails[0],\n receiver,\n depositHash,\n fromChainId,\n transferDetails[1],\n transferDetails[2],\n transferDetails[3]\n );\n }", "function getAmountToTransfer(\n uint256 initialGas,\n address tokenAddress,\n uint256 amount,\n uint256 tokenGasPrice\n ) internal returns (uint256[4] memory) {\n TokenInfo memory tokenInfo = tokenManager.getTokensInfo(tokenAddress);\n uint256 transferFeePerc = _getTransferFee(\n tokenAddress,\n amount,\n tokenInfo\n );\n uint256 lpFee;\n if (transferFeePerc > tokenInfo.equilibriumFee) {\n \n lpFee = (amount * tokenInfo.equilibriumFee) / BASE_DIVISOR;\n unchecked {\n incentivePool[tokenAddress] +=\n (amount * (transferFeePerc - tokenInfo.equilibriumFee)) /\n BASE_DIVISOR;\n }\n } else {\n lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n }\n uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n liquidityProviders.addLPFee(tokenAddress, lpFee);\n uint256 totalGasUsed = initialGas +\n tokenInfo.transferOverhead +\n baseGas -\n gasleft();\n uint256 gasFee = totalGasUsed * tokenGasPrice;\n gasFeeAccumulatedByToken[tokenAddress] += gasFee;\n gasFeeAccumulated[tokenAddress][_msgSender()] += gasFee;\n uint256 amountToTransfer = amount - (transferFeeAmount + gasFee);\n return [amountToTransfer, lpFee, transferFeeAmount, gasFee];\n }", "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\ttokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}"], "label": "Yes", "detail": "The getAssetFromTokenAddress function in THORChain's Ethereum scanner fails to properly handle ERC20 tokens with 'ETH' symbol. When processing deposits, it defaults to native ETH asset type if the token metadata isn't found in local storage. An attacker can deploy a malicious ERC20 token with 'ETH' symbol, causing the bridge to incorrectly identify the token as native Ethereum. This allows fake tokens to be treated as genuine ETH in cross-chain transactions."}
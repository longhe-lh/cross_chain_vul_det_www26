{"project": "Ronin Bridge", "functions": ["function withdrawERC20For(\n uint256 _withdrawalId,\n address _user,\n address _token,\n uint256 _amount,\n bytes memory _signatures\n )\n public\n whenNotPaused\n onlyMappedToken(_token, 20)\n {\n bytes32 _hash = keccak256(\n abi.encodePacked(\n \"withdrawERC20\",\n _withdrawalId,\n _user,\n _token,\n _amount\n )\n );\n function verifySignatures(...) {...}\nfunction sub(...) {...}\nfunction mint(...) {...}\nfunction transfer(...) {...}\nrequire(verifySignatures(_hash, _signatures));\n if (_token == registry.getContract(registry.WETH_TOKEN())) {\n _withdrawETHFor(_user, _amount);\n } else {\n uint256 _gatewayBalance = IERC20(_token).balanceOf(address(this));\n if (_gatewayBalance < _amount) {\n require(\n IERC20Mintable(_token).mint(address(this), _amount.sub(_gatewayBalance)),\n \"MainchainGatewayManager: Minting ERC20 token to gateway failed\"\n );\n }\n require(IERC20(_token).transfer(_user, _amount), \"Transfer failed\");\n }\n _insertWithdrawalEntry(\n _withdrawalId,\n _user,\n _token,\n _amount\n );\n }", "function withdrawERC721For(\n uint256 _withdrawalId,\n address _user,\n address _token,\n uint256 _tokenId,\n bytes memory _signatures\n )\n public\n whenNotPaused\n onlyMappedToken(_token, 721)\n {\n bytes32 _hash = keccak256(\n abi.encodePacked(\n \"withdrawERC721\",\n _withdrawalId,\n _user,\n _token,\n _tokenId\n )\n );\n function verifySignatures(...) {...}\nfunction mint(...) {...}\nrequire(verifySignatures(_hash, _signatures));\n if (!_tryERC721TransferFrom(_token, address(this), _user, _tokenId)) {\n require(\n IERC721Mintable(_token).mint(_user, _tokenId),\n \"MainchainGatewayManager: Minting ERC721 token to gateway failed\"\n );\n }\n _insertWithdrawalEntry(_withdrawalId, _user, _token, _tokenId);\n }", "function _insertWithdrawalEntry(\n uint256 _withdrawalId,\n address _owner,\n address _token,\n uint256 _number\n )\n internal\n onlyNewWithdrawal(_withdrawalId)\n {\n WithdrawalEntry memory _entry = WithdrawalEntry(\n _owner,\n _token,\n _number\n );\n withdrawals[_withdrawalId] = _entry;\n emit TokenWithdrew(_withdrawalId, _owner, _token, _number);\n }", "function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n        _chargeFee();\n        require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n        uint N = signatures.length;\n        require(N >= MappingTokenFactory(factory).getConfig(_minSignatures_), 'too few signatures');\n        for(uint i=0; i<N; i++) {\n            for(uint j=0; j<i; j++)\n                require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n            bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n            bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _DOMAIN_SEPARATOR, structHash));\n            address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n            require(signatory != address(0), \"invalid signature\");\n            require(signatory == signatures[i].signatory, \"unauthorized\");\n            _decreaseAuthQuota(signatures[i].signatory, volume);\n            emit Authorize(fromChainId, to, nonce, volume, signatory);\n        }\n        received[fromChainId][to][nonce] = volume;\n        _receive(to, volume);\n        emit Receive(fromChainId, to, nonce, volume);\n    }"], "label": "Yes", "detail": "The receive function of the Chainswap contract failed to properly validate the signatory field of incoming signatures. By supplying a forged signatory, an attacker was able to bypass the authorization process. Due to the absence of mapping key validation in Solidity, the system calculated an unreasonably high quota for the forged signatory, enabling the attacker to mint and withdraw unauthorized funds. The root cause is improper validation of mapping-based access control. Additionally, the platform had reduced the required number of signatures to 1 prior to the attack, making exploitation easier."}
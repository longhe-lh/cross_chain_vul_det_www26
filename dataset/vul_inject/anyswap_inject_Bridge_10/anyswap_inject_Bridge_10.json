{"project": "Bridge_10", "functions": ["function swap(\n address recepient,\n uint256 amount,\n address erc20from,\n uint256 chainIdto,\n address erc20to\n ) external isBridgeValid(erc20from, chainIdto, erc20to) {\n IExampleToken(erc20from).burn(msg.sender, amount);\n nonce += 1;\n emit SwapInitialized(\n msg.sender,\n recepient,\n amount,\n getChainID(),\n erc20from,\n chainIdto,\n erc20to,\n nonce\n );\n }", "function burn(\n address account,\n uint256 amount\n ) public onlyRole(BURNER_ROLE) enoughTokens(account, amount) {\n balances[account] -= amount;\n totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }", "modifier isBridgeValid(\n address erc20from,\n uint256 chainIdto,\n address erc20to\n ) {\n require(\n isERC20valid[getChainID()][erc20from],\n \"ERC20 address from is not valid\"\n );\n require(\n isERC20valid[chainIdto][erc20to],\n \"Chain id or ERC20 address to is not valid\"\n );\n _;\n }", "function getChainID() public view returns (uint256) {\n uint256 id;\n assembly {\n id := chainid()\n }\n return id;\n }", "function redeem(\n address recepient,\n uint256 amount,\n uint256 chainIdfrom,\n address erc20from,\n address erc20to,\n uint256 nonce,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external {\n require(\n isERC20valid[chainIdfrom][erc20from],\n \"Chain id or ERC20 address from is not valid\"\n );\n require(\n isERC20valid[getChainID()][erc20to],\n \"ERC20 on this chain is not valid\"\n );\n require(\n checkSign(\n recepient,\n amount,\n chainIdfrom,\n erc20from,\n nonce,\n v,\n r,\n s\n ),\n \"Input is not valid\"\n );\n bytes32 redeemHash = keccak256(\n abi.encodePacked(\n recepient,\n amount,\n chainIdfrom,\n erc20from,\n nonce,\n v,\n r,\n s\n )\n );\n redeemStatus[redeemHash] = Status.Undone;\n require(redeemStatus[redeemHash] == Status.Undone, \"Hash is not valid\");\n redeemStatus[redeemHash] = Status.Done;\n IExampleToken(erc20to).mint(recepient, amount);\n emit RedeemInitialized(\n recepient,\n amount,\n erc20to,\n chainIdfrom,\n erc20from,\n nonce\n );\n }", "function checkSign(\n address recepient,\n uint256 amount,\n uint256 chainIdfrom,\n address erc20from,\n uint256 nonce,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public view returns (bool) {\n bytes32 message = keccak256(\n abi.encodePacked(recepient, amount, chainIdfrom, erc20from, nonce)\n );\n address function hashMessage(...) {...}\naddr = ecrecover(hashMessage(message), v, r, s);\n if (addr == validator) {\n return true;\n } else {\n return false;\n }\n }", "function hashMessage(bytes32 message) private pure returns (bytes32) {\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n return keccak256(abi.encodePacked(prefix, message));\n }", "function mint(\n address account,\n uint256 amount\n ) public onlyRole(MINTER_ROLE) {\n balances[account] += amount;\n totalSupply += amount;\n emit Transfer(address(0), account, amount);\n }", "function depositWithPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns (uint) {\n        IERC20(underlying).permit(target, address(this), value, deadline, v, r, s);\n        IERC20(underlying).safeTransferFrom(target, address(this), value);\n        return _deposit(value, to);\n    }"], "label": "Yes", "detail": "The attacker exploited the fact that some tokens do not implement `permit()` but include a fallback function that silently accepts calls without reverting. By invoking `depositWithPermit`, the attacker could spoof the `target` (the victim address) and bypass approval checks because `permit()` succeeded trivially. Afterwards, `safeTransferFrom(target, ...)` would transfer tokens from the victim to the attacker-controlled contract. This is an authentication bypass in the cross-chain liquidity pool contract, allowing theft of user funds without a valid permit or signature."}
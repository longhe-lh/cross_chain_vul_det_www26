{"project": "Hyphen", "functions": ["function swapAndSendFundsToUser(\n address tokenAddress,\n uint256 amount,\n address payable receiver,\n bytes calldata depositHash,\n uint256 nativeTokenPriceInTransferredToken,\n uint256 tokenGasBaseFee,\n uint256 fromChainId,\n uint256 swapGasOverhead,\n SwapRequest[] calldata swapRequests,\n string memory swapAdaptor\n ) external nonReentrant onlyExecutor whenNotPaused {\n require(swapRequests.length > 0, \"Wrong method call\");\n require(\n swapAdaptorMap[swapAdaptor] != address(0),\n \"Swap adaptor not found\"\n );\n uint256[4]\n memory transferDetails = _calculateAmountAndDecreaseAvailableLiquidity(\n tokenAddress,\n amount,\n receiver,\n depositHash,\n nativeTokenPriceInTransferredToken,\n tokenGasBaseFee\n );\n if (tokenAddress == NATIVE) {\n (bool success, ) = swapAdaptorMap[swapAdaptor].call{\n value: transferDetails[0]\n }(\"\");\n require(success, \"Native Transfer to Adaptor Failed\");\n ISwapAdaptor(swapAdaptorMap[swapAdaptor]).swapNative(\n transferDetails[0],\n receiver,\n swapRequests\n );\n } else {\n {\n uint256 gasBeforeApproval = gasleft();\n SafeERC20Upgradeable.safeApprove(\n IERC20Upgradeable(tokenAddress),\n address(swapAdaptorMap[swapAdaptor]),\n 0\n );\n SafeERC20Upgradeable.safeApprove(\n IERC20Upgradeable(tokenAddress),\n address(swapAdaptorMap[swapAdaptor]),\n transferDetails[0]\n );\n swapGasOverhead += (gasBeforeApproval - gasleft());\n }\n {\n uint256 swapGasFee = calculateGasFee(\n tokenAddress,\n nativeTokenPriceInTransferredToken,\n swapGasOverhead,\n 0,\n _msgSender()\n );\n transferDetails[0] -= swapGasFee; \n transferDetails[3] += swapGasFee; \n }\n ISwapAdaptor(swapAdaptorMap[swapAdaptor]).swap(\n tokenAddress,\n transferDetails[0],\n receiver,\n swapRequests\n );\n }\n emit AssetSent(\n tokenAddress,\n amount,\n transferDetails[0],\n receiver,\n depositHash,\n fromChainId,\n transferDetails[1],\n transferDetails[2],\n transferDetails[3]\n );\n }", "function _calculateAmountAndDecreaseAvailableLiquidity(\n address tokenAddress,\n uint256 amount,\n address payable receiver,\n bytes calldata depositHash,\n uint256 nativeTokenPriceInTransferredToken,\n uint256 tokenGasBaseFee\n ) internal returns (uint256[4] memory) {\n uint256 initialGas = gasleft();\n TokenConfig memory config = tokenManager.getTransferConfig(\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Withdraw amount not in Cap limit\"\n );\n require(receiver != address(0), \"Bad receiver address\");\n (bytes32 hashSendTransaction, bool status) = checkHashStatus(\n tokenAddress,\n amount,\n receiver,\n depositHash\n );\n require(!status, \"Already Processed\");\n processedHash[hashSendTransaction] = true;\n \n uint256[4] memory transferDetails = getAmountToTransferV2(\n initialGas,\n tokenAddress,\n amount,\n nativeTokenPriceInTransferredToken,\n tokenGasBaseFee\n );\n liquidityProviders.decreaseCurrentLiquidity(\n tokenAddress,\n transferDetails[0]\n );\n return transferDetails;\n }", "function getAmountToTransferV2(\n uint256 initialGas,\n address tokenAddress,\n uint256 amount,\n uint256 nativeTokenPriceInTransferredToken,\n uint256 tokenGasBaseFee\n ) internal returns (uint256[4] memory) {\n TokenInfo memory tokenInfo = tokenManager.getTokensInfo(tokenAddress);\n uint256 transferFeePerc = _getTransferFee(\n tokenAddress,\n amount,\n tokenInfo\n );\n uint256 lpFee;\n if (transferFeePerc > tokenInfo.equilibriumFee) {\n \n lpFee = (amount * tokenInfo.equilibriumFee) / BASE_DIVISOR;\n unchecked {\n incentivePool[tokenAddress] +=\n (amount * (transferFeePerc - tokenInfo.equilibriumFee)) /\n BASE_DIVISOR;\n }\n } else {\n lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n }\n uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n liquidityProviders.addLPFee(tokenAddress, lpFee);\n uint256 totalGasUsed = initialGas +\n tokenInfo.transferOverhead +\n baseGas -\n gasleft();\n uint256 gasFee = calculateGasFee(\n tokenAddress,\n nativeTokenPriceInTransferredToken,\n totalGasUsed,\n tokenGasBaseFee,\n _msgSender()\n );\n require(\n transferFeeAmount + gasFee <= amount,\n \"Insufficient funds to cover transfer fee\"\n );\n unchecked {\n uint256 amountToTransfer = amount - (transferFeeAmount + gasFee);\n return [amountToTransfer, lpFee, transferFeeAmount, gasFee];\n }\n }", "fn verify_signatures(\n    ctx: &ExecutionContext,\n    accs: &mut VerifySignatures,\n    data: VerifySignaturesData,\n) -> Result<()> {\n    accs.guardian_set\n        .verify_derivation(ctx.program_id, &(&*accs).into())?;\n    let sig_infos: Vec<SigInfo> = data\n        .signers\n        .iter()\n        .enumerate()\n        .filter_map(|(i, p)| {\n            if *p == -1 {\n                return None;\n            }\n            return Some(SigInfo {\n                sig_index: *p as u8,\n                signer_index: i as u8,\n            });\n        })\n        .collect();\n    let current_instruction = solana_program::sysvar::instructions::load_current_index(\n        &accs.instruction_acc.try_borrow_mut_data()?,\n    );\n    if current_instruction == 0 {\n        return Err(InstructionAtWrongIndex.into());\n    }\n    \n    let secp_ix_index = (current_instruction - 1) as u8;\n    let secp_ix = solana_program::sysvar::instructions::load_instruction_at(\n        secp_ix_index as usize,\n        &accs.instruction_acc.try_borrow_mut_data()?,\n    )\n    .map_err(|_| ProgramError::InvalidAccountData)?;\n    \n    if secp_ix.program_id != solana_program::secp256k1_program::id() {\n        return Err(InvalidSecpInstruction.into());\n    }\n    let secp_data_len = secp_ix.data.len();\n    if secp_data_len < 2 {\n        return Err(InvalidSecpInstruction.into());\n    }\n    let sig_len = secp_ix.data[0];\n    let mut index = 1;\n    let mut secp_ixs: Vec<SecpInstructionPart> = Vec::with_capacity(sig_len as usize);\n    for i in 0..sig_len {\n        let _sig_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]) as usize;\n        index += 2;\n        let sig_ix = secp_ix.data[index];\n        index += 1;\n        let address_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]) as usize;\n        index += 2;\n        let address_ix = secp_ix.data[index];\n        index += 1;\n        let msg_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]);\n        index += 2;\n        let msg_size = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]);\n        index += 2;\n        let msg_ix = secp_ix.data[index];\n        index += 1;\n        if address_ix != secp_ix_index || msg_ix != secp_ix_index || sig_ix != secp_ix_index {\n            return Err(InvalidSecpInstruction.into());\n        }\n        let address: &[u8] = &secp_ix.data[address_offset..address_offset + 20];\n        \n        if i > 0 {\n            if msg_offset != secp_ixs[0].msg_offset || msg_size != secp_ixs[0].msg_size {\n                return Err(InvalidSecpInstruction.into());\n            }\n        }\n        secp_ixs.push(SecpInstructionPart {\n            address,\n            msg_offset,\n            msg_size,\n        });\n    }\n    if sig_infos.len() != secp_ixs.len() {\n        return Err(ProgramError::InvalidArgument.into());\n    }\n    \n    if secp_ixs[0].msg_size != 32 {\n        return Err(ProgramError::InvalidArgument.into());\n    }\n    \n    let message = &secp_ix.data\n        [secp_ixs[0].msg_offset as usize..(secp_ixs[0].msg_offset + secp_ixs[0].msg_size) as usize];\n    \n    let mut msg_hash: [u8; 32] = [0u8; 32];\n    msg_hash.copy_from_slice(message);\n    if !accs.signature_set.is_initialized() {\n        accs.signature_set.signatures = vec![false; accs.guardian_set.keys.len()];\n        accs.signature_set.guardian_set_index = accs.guardian_set.index;\n        accs.signature_set.hash = msg_hash;\n        let size = accs.signature_set.size();\n        let ix = solana_program::system_instruction::create_account(\n            accs.payer.key,\n            accs.signature_set.info().key,\n            Exempt.amount(size),\n            size as u64,\n            ctx.program_id,\n        );\n        solana_program::program::invoke(&ix, ctx.accounts)?;\n    } else {\n        \n        if accs.signature_set.guardian_set_index != accs.guardian_set.index {\n            return Err(GuardianSetMismatch.into());\n        }\n        if accs.signature_set.hash != msg_hash {\n            return Err(InvalidHash.into());\n        }\n    }\n    \n    for s in sig_infos {\n        if s.signer_index > accs.guardian_set.num_guardians() {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        if s.sig_index + 1 > sig_len {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        let key = accs.guardian_set.keys[s.signer_index as usize];\n        \n        if key != secp_ixs[s.sig_index as usize].address {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        \n        accs.signature_set.signatures[s.signer_index as usize] = true;\n    }\n    Ok(())\n}"], "label": "Yes", "detail": "The attacker used a forged sysvar account to call the \"verify_signatures\" function. The function \"load_current_index\" used inside did not verify whether the provided sysvar account was the legitimate system sysvar. This allowed the attacker to bypass signature verification, create a malicious VAA claiming to mint 120,000 WETH, and ultimately transfer the minted tokens to Ethereum."}
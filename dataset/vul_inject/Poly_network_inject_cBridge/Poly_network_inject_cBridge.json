{"project": "cBridge", "functions": ["function send(\n address _receiver,\n address _token,\n uint256 _amount,\n uint64 _dstChainId,\n uint64 _nonce,\n uint32 _maxSlippage \n ) external nonReentrant whenNotPaused {\n bytes32 transferId = _send(\n _receiver,\n _token,\n _amount,\n _dstChainId,\n _nonce,\n _maxSlippage\n );\n IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n emit Send(\n transferId,\n msg.sender,\n _receiver,\n _token,\n _amount,\n _dstChainId,\n _nonce,\n _maxSlippage\n );\n }", "function _send(\n address _receiver,\n address _token,\n uint256 _amount,\n uint64 _dstChainId,\n uint64 _nonce,\n uint32 _maxSlippage\n ) private returns (bytes32) {\n require(_amount > minSend[_token], \"amount too small\");\n require(\n maxSend[_token] == 0 || _amount <= maxSend[_token],\n \"amount too large\"\n );\n require(_maxSlippage > minimalMaxSlippage, \"max slippage too small\");\n bytes32 transferId = keccak256(\n \n abi.encodePacked(\n msg.sender,\n _receiver,\n _token,\n _amount,\n _dstChainId,\n _nonce,\n uint64(block.chainid)\n )\n );\n require(transfers[transferId] == false, \"transfer exists\");\n transfers[transferId] = true;\n return transferId;\n }", "function relay(\n bytes calldata _relayRequest,\n bytes[] calldata _sigs,\n address[] calldata _signers,\n uint256[] calldata _powers\n ) external whenNotPaused {\n bytes32 domain = keccak256(\n abi.encodePacked(block.chainid, address(this), \"Relay\")\n );\n verifySigs(\n abi.encodePacked(domain, _relayRequest),\n _sigs,\n _signers,\n _powers\n );\n PbBridge.Relay memory request = PbBridge.decRelay(_relayRequest);\n bytes32 transferId = keccak256(\n abi.encodePacked(\n request.sender,\n request.receiver,\n request.token,\n request.amount,\n request.srcChainId,\n request.dstChainId,\n request.srcTransferId\n )\n );\n require(transfers[transferId] == false, \"transfer exists\");\n transfers[transferId] = true;\n _updateVolume(request.token, request.amount);\n uint256 delayThreshold = delayThresholds[request.token];\n if (delayThreshold > 0 && request.amount > delayThreshold) {\n _addDelayedTransfer(\n transferId,\n request.receiver,\n request.token,\n request.amount\n );\n } else {\n _sendToken(request.receiver, request.token, request.amount);\n }\n emit Relay(\n transferId,\n request.sender,\n request.receiver,\n request.token,\n request.amount,\n request.srcChainId,\n request.srcTransferId\n );\n }", "function withdraw(\n bytes calldata _wdmsg,\n bytes[] calldata _sigs,\n address[] calldata _signers,\n uint256[] calldata _powers\n ) external whenNotPaused {\n bytes32 domain = keccak256(\n abi.encodePacked(block.chainid, address(this), \"WithdrawMsg\")\n );\n verifySigs(abi.encodePacked(domain, _wdmsg), _sigs, _signers, _powers);\n \n PbPool.WithdrawMsg memory wdmsg = PbPool.decWithdrawMsg(_wdmsg);\n bytes32 wdId = keccak256(\n abi.encodePacked(\n wdmsg.chainid,\n wdmsg.seqnum,\n wdmsg.receiver,\n wdmsg.token,\n wdmsg.amount\n )\n );\n require(withdraws[wdId] == false, \"withdraw already succeeded\");\n withdraws[wdId] = true;\n _updateVolume(wdmsg.token, wdmsg.amount);\n uint256 delayThreshold = delayThresholds[wdmsg.token];\n if (delayThreshold > 0 && wdmsg.amount > delayThreshold) {\n _addDelayedTransfer(\n wdId,\n wdmsg.receiver,\n wdmsg.token,\n wdmsg.amount\n );\n } else {\n function _sendToken(...) {...}\n_sendToken(wdmsg.receiver, wdmsg.token, wdmsg.amount);\n }\n emit WithdrawDone(\n wdId,\n wdmsg.seqnum,\n wdmsg.receiver,\n wdmsg.token,\n wdmsg.amount,\n wdmsg.refid\n );\n }", "function _sendToken(\n address _receiver,\n address _token,\n uint256 _amount\n ) internal {\n if (_token == nativeWrap) {\n \n function withdraw(...) {...}\nIWETH(nativeWrap).withdraw(_amount);\n (bool sent, ) = _receiver.call{value: _amount, gas: 50000}(\"\");\n require(sent, \"failed to send native token\");\n } else {\n IERC20(_token).safeTransfer(_receiver, _amount);\n }\n }", "function mint(\n bytes calldata _request,\n bytes[] calldata _sigs,\n address[] calldata _signers,\n uint256[] calldata _powers\n ) external whenNotPaused {\n bytes32 domain = keccak256(\n abi.encodePacked(block.chainid, address(this), \"Mint\")\n );\n sigsVerifier.verifySigs(\n abi.encodePacked(domain, _request),\n _sigs,\n _signers,\n _powers\n );\n PbPegged.Mint memory request = PbPegged.decMint(_request);\n bytes32 mintId = keccak256(\n \n abi.encodePacked(\n request.account,\n request.token,\n request.amount,\n request.depositor,\n request.refChainId,\n request.refId\n )\n );\n require(records[mintId] == false, \"record exists\");\n records[mintId] = true;\n _updateVolume(request.token, request.amount);\n uint256 delayThreshold = delayThresholds[request.token];\n if (delayThreshold > 0 && request.amount > delayThreshold) {\n _addDelayedTransfer(\n mintId,\n request.account,\n request.token,\n request.amount\n );\n } else {\n function mint(...) {...}\nIPeggedToken(request.token).mint(request.account, request.amount);\n }\n emit Mint(\n mintId,\n request.token,\n request.account,\n request.amount,\n request.refChainId,\n request.refId,\n request.depositor\n );\n }", "function _updateVolume(address _token, uint256 _amount) internal {\n if (epochLength == 0) {\n return;\n }\n uint256 cap = epochVolumeCaps[_token];\n if (cap == 0) {\n return;\n }\n uint256 volume = epochVolumes[_token];\n uint256 timestamp = block.timestamp;\n uint256 epochStartTime = (timestamp / epochLength) * epochLength;\n if (lastOpTimestamps[_token] < epochStartTime) {\n volume = _amount;\n } else {\n volume += _amount;\n }\n require(volume <= cap, \"volume exceeds cap\");\n epochVolumes[_token] = volume;\n lastOpTimestamps[_token] = timestamp;\n }", "function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n        \n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n        uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\n        uint n = polyChainBKs.length;\n        if (header.height >= curEpochStartHeight) {\n            \n            require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n        } else {\n            \n            require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n            \n            ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\n            bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);\n            require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n        }\n        \n        bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\n        \n        ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\n        require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n        require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n        \n        require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");\n        \n        address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\n        \n        require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n        \n        \n        emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\n        return true;\n    }"], "label": "Yes", "detail": "The PolyNetwork attack exploited a critical flaw in the EthCrossChainManager contract, which failed to properly validate the `method` string in incoming cross-chain requests. By crafting a transaction from Ontology that appeared legitimate and passed through PolyChain, the attacker called `putCurEpochConPubKeyBytes` on the Ethereum-side EthCrossChainData contract. This replaced the authorized keeper public keys with attacker-controlled keys. Subsequent fake transactions using forged signatures were accepted, leading to unauthorized asset minting and withdrawal across multiple blockchains. The exploit occurred because there was no method whitelist or contract-level access control on cross-chain delegated calls."}
{"project": "SOY Bridge", "functions": ["function claim(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n isTxProcessed[fromChainId][txId] = true;\n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n function safeTransfer(...) {...}\ntoken.safeTransfer(to, value);\n }\n }\n emit Claim(token, to, value, txId, fromChainId, pair.token);\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
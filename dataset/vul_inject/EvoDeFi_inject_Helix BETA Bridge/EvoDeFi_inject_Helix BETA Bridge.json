{"project": "Helix BETA Bridge", "functions": ["function receiveMessage(\n uint256 _srcAppChainId,\n address _remoteAppAddress,\n address _localAppAddress,\n bytes memory _message\n ) external onlyMsgline {\n uint256 srcChainId = _fromChainId();\n RemoteMessager memory remoteMessager = remoteMessagers[_srcAppChainId];\n require(\n srcChainId == remoteMessager.msglineRemoteChainId,\n \"invalid remote chainid\"\n );\n require(\n remoteMessager.messager == _xmsgSender(),\n \"invalid remote messager\"\n );\n bytes32 key = keccak256(abi.encodePacked(srcChainId, _localAppAddress));\n \n if (_remoteAppAddress != remoteAppSenders[key]) {\n emit CallerUnMatched(_srcAppChainId, _remoteAppAddress);\n return;\n }\n (bool success, ) = _localAppAddress.call(_message);\n \n emit CallResult(_srcAppChainId, success);\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
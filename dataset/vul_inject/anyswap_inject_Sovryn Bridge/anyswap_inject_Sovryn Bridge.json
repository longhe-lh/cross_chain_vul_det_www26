{"project": "Sovryn Bridge", "functions": ["function _voteTransaction(\n address originalTokenAddress,\n address receiver,\n uint256 amount,\n string memory symbol,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex,\n uint8 decimals,\n uint256 granularity,\n bytes memory userData\n ) internal onlyMember returns (bool) {\n \n require(\n initStageDone == true,\n \"Federation: Cannot process TX while initStageDone == false\"\n );\n bytes32 transactionId = getTransactionId(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity\n );\n if (processed[transactionId]) return true;\n \n \n \n \n \n \n \n \n \n if (\n processTransaction(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n )\n ) {\n \n \n return true;\n }\n return true;\n }", "function processTransaction(\n address originalTokenAddress,\n address receiver,\n uint256 amount,\n string memory symbol,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex,\n uint8 decimals,\n uint256 granularity,\n bytes memory userData\n ) internal returns (bool) {\n bytes32 transactionIdU = getTransactionIdU(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n if (processed[transactionIdU]) return true;\n if (votes[transactionIdU][_msgSender()]) return true;\n function _msgSender(...) {...}\nvotes[transactionIdU][_msgSender()] = true;\n \n emit Voted(\n _msgSender(),\n transactionIdU,\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n uint256 transactionCount = getTransactionCount(transactionIdU);\n if (transactionCount >= required && transactionCount >= members.length / 2 + 1) {\n processed[transactionIdU] = true;\n bool acceptTransfer = bridge.acceptTransferAt(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n require(acceptTransfer, \"Federation: Bridge acceptTransfer error\");\n emit Executed(transactionIdU);\n return true;\n }\n }", "function depositWithPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns (uint) {\n        IERC20(underlying).permit(target, address(this), value, deadline, v, r, s);\n        IERC20(underlying).safeTransferFrom(target, address(this), value);\n        return _deposit(value, to);\n    }"], "label": "Yes", "detail": "The attacker exploited the fact that some tokens do not implement `permit()` but include a fallback function that silently accepts calls without reverting. By invoking `depositWithPermit`, the attacker could spoof the `target` (the victim address) and bypass approval checks because `permit()` succeeded trivially. Afterwards, `safeTransferFrom(target, ...)` would transfer tokens from the victim to the attacker-controlled contract. This is an authentication bypass in the cross-chain liquidity pool contract, allowing theft of user funds without a valid permit or signature."}
{"project": "MultiBridge", "functions": ["function dispatchMessage(uint256 _toChainId, address _to, bytes calldata _data)\n external\n payable\n override\n onlyMultiMessageSender\n returns (bytes32 msgId)\n {\n address receiverAdapter = receiverAdapters[_toChainId];\n if (receiverAdapter == address(0)) {\n revert Error.ZERO_RECEIVER_ADAPTER();\n }\n string memory destinationChain = chainIdMap[_toChainId];\n if (bytes(destinationChain).length <= 0) {\n revert Error.INVALID_DST_CHAIN();\n }\n msgId = _getNewMessageId(_toChainId, _to);\n _callContract(destinationChain, receiverAdapter, msgId, _to, _data);\n emit MessageDispatched(msgId, msg.sender, _toChainId, _to, _data);\n }", "function _callContract(\n string memory destinationChain,\n address receiverAdapter,\n bytes32 msgId,\n address multibridgeReceiver,\n bytes calldata data\n ) internal {\n string memory receiverAdapterInString = StringAddressConversion.toString(receiverAdapter);\n bytes memory payload =\n abi.encode(AdapterPayload(msgId, address(msg.sender), receiverAdapter, multibridgeReceiver, data));\n gasService.payNativeGasForContractCall{value: msg.value}(\n msg.sender, destinationChain, receiverAdapterInString, payload, msg.sender\n );\n gateway.callContract(destinationChain, receiverAdapterInString, payload);\n }", "function executeMessage(bytes32 msgId) external {\n ExecutionData memory _execData = msgReceived[msgId];\n \n if (block.timestamp > _execData.expiration) {\n revert Error.MSG_EXECUTION_PASSED_DEADLINE();\n }\n \n if (isExecuted[msgId]) {\n revert Error.MSG_ID_ALREADY_EXECUTED();\n }\n isExecuted[msgId] = true;\n \n if (messageVotes[msgId] < quorum) {\n revert Error.INVALID_QUORUM_FOR_EXECUTION();\n }\n \n IGovernanceTimelock(governanceTimelock).scheduleTransaction(\n _execData.target, _execData.value, _execData.callData\n );\n emit MessageExecuted(msgId, _execData.target, _execData.value, _execData.nonce, _execData.callData);\n }", "function scheduleTransaction(address _target, uint256 _value, bytes memory _data) external override onlyAdmin {\n if (_target == address(0)) {\n revert Error.INVALID_TARGET();\n }\n \n ++txCounter;\n uint256 eta = block.timestamp + delay;\n scheduledTransaction[txCounter] = keccak256(abi.encodePacked(_target, _value, _data, eta));\n emit TransactionScheduled(txCounter, _target, _value, _data, eta);\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
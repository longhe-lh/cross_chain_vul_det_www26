{"project": "Meter Passport", "functions": ["function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint256 amount;\n bytes memory destinationRecipientAddress;\n assembly {\n amount := calldataload(0x64)\n destinationRecipientAddress := mload(0x40)\n let lenDestinationRecipientAddress := calldataload(0x84)\n mstore(0x40, add(0x20, add(destinationRecipientAddress, lenDestinationRecipientAddress)))\n \n calldatacopy(\n destinationRecipientAddress, \n 0x84, \n sub(calldatasize(), 0x84) \n )\n }\n bytes20 recipientAddress;\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress == _wtokenAddress) {\n IWETH(_wtokenAddress).withdraw(amount);\n \n TransferHelper.safeTransferETH(address(recipientAddress), amount);\n return;\n }\n if (_burnList[tokenAddress]) {\n mintERC20(tokenAddress, address(recipientAddress), amount);\n } else {\n releaseERC20(tokenAddress, address(recipientAddress), amount);\n }\n }", "function mintERC20(address tokenAddress, address recipient, uint256 amount) internal {\n ERC20PresetMinterPauser erc20 = ERC20PresetMinterPauser(tokenAddress);\n function mint(...) {...}\nerc20.mint(recipient, amount);\n }", "function releaseERC20(address tokenAddress, address recipient, uint256 amount) internal {\n IERC20 erc20 = IERC20(tokenAddress);\n function _safeTransfer(...) {...}\n_safeTransfer(erc20, recipient, amount);\n }", "function _safeTransfer(IERC20 token, address to, uint256 value) private {\n function _safeCall(...) {...}\n_safeCall(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n }", "function _safeCall(IERC20 token, bytes memory data) private { \n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"ERC20: call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"ERC20: operation did not succeed\");\n }\n }", "function voteProposal(\n uint8 domainID,\n uint64 depositNonce,\n bytes32 resourceID,\n bytes calldata data\n ) external onlyRelayers whenNotPaused nonReentrant {\n address handler = _resourceIDToHandlerAddress[resourceID];\n uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(domainID);\n bytes32 dataHash = keccak256(\n abi.encodePacked(resourceID, handler, data)\n );\n Proposal memory proposal = _proposals[nonceAndID][dataHash];\n require(\n _resourceIDToHandlerAddress[resourceID] != address(0),\n \"no handler for resourceID\"\n );\n if (proposal._status == ProposalStatus.Passed) {\n _executeProposal(domainID, depositNonce, data, resourceID, true);\n return;\n }\n address sender = _msgSender();\n require(\n uint256(proposal._status) <= 1,\n \"proposal already executed/cancelled\"\n );\n require(!_hasVoted(proposal, sender), \"relayer already voted\");\n if (proposal._status == ProposalStatus.Inactive) {\n proposal = Proposal({\n _status: ProposalStatus.Active,\n _yesVotes: 0,\n _yesVotesTotal: 0,\n _proposedBlock: uint40(block.number) \n });\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Active,\n dataHash\n );\n } else if (\n uint40(sub(block.number, proposal._proposedBlock)) > _expiry\n ) {\n \n \n proposal._status = ProposalStatus.Cancelled;\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Cancelled,\n dataHash\n );\n }\n if (proposal._status != ProposalStatus.Cancelled) {\n proposal._yesVotes = (proposal._yesVotes | _relayerBit(sender))\n .toUint200();\n proposal._yesVotesTotal++; \n emit ProposalVote(\n domainID,\n depositNonce,\n proposal._status,\n dataHash\n );\n \n if (proposal._yesVotesTotal >= _relayerThreshold) {\n proposal._status = ProposalStatus.Passed;\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Passed,\n dataHash\n );\n }\n }\n _proposals[nonceAndID][dataHash] = proposal;\n if (proposal._status == ProposalStatus.Passed) {\n _executeProposal(domainID, depositNonce, data, resourceID, false);\n }\n }", "function swap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy\n    ) external returns (uint256) {\n        {\n            \n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n            require(\n                dx <= tokenFrom.balanceOf(msg.sender),\n                \"Cannot swap more than you own\"\n            );\n            \n            uint256 beforeBalance = tokenFrom.balanceOf(address(this));     \n            tokenFrom.safeTransferFrom(msg.sender, address(this), dx);      \n            \n            dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);     \n        }\n        uint256 dy; \n        uint256 dyFee;  \n        uint256[] memory balances = self.balances;\n        \n        (dy, dyFee) = _calculateSwap(\n            self,\n            tokenIndexFrom,\n            tokenIndexTo,\n            dx,\n            balances\n        );\n        require(dy >= minDy, \"Swap didn't result in min tokens\");   \n        uint256 dyAdminFee =\n            dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n                self.tokenPrecisionMultipliers[tokenIndexTo]\n            );  \n        \n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n        \n        self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(\n            dyAdminFee\n        );\n        \n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n        \n        emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n        return dy;\n    }"], "label": "Yes", "detail": "The attack on Nerve's MetaPool was made possible by inconsistent implementations of the getXp() pricing function in two libraries: SwapUtils and MetaSwapUtils. The MetaSwap contract, which was forked from Saddle.Finance (itself a Solidity port of Curve's MetaPool), contained two key swap functions—swap() and swapUnderlying()—used for exchanging between LP tokens and stablecoins. During the attack, swap() underestimated the LP token value due to ignoring the virtual price, while swapUnderlying() calculated it correctly. The attacker repeatedly swapped stablecoins for undervalued LP tokens via swap(), removed liquidity to extract base tokens, and finally used swapUnderlying() to convert base tokens back to more stablecoins at a favorable rate. This loop drained the pool of liquidity. The vulnerability stems from inconsistent logic across forked components and highlights the risk of modifying or porting code without preserving behavioral equivalence. The attacker reportedly profited ~900 BNB. A similar attack had occurred on Synapse’s MetaPool one week earlier, exploiting the same flaw."}
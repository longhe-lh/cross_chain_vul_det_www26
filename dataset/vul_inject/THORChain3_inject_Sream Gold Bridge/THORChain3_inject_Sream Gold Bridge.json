{"project": "Sream Gold Bridge", "functions": ["function onStateReceive(uint256 stateId, bytes calldata _data) external override {\n require(msg.sender == address(0x0000000000000000000000000000000000001001), \"Invalid sender\");\n (address rootMessageSender, address receiver, bytes memory data) = abi.decode(_data, (address, address, bytes));\n emit NewFxMessage(rootMessageSender, receiver, data);\n IFxMessageProcessor(receiver).processMessageFromRoot(stateId, rootMessageSender, data);\n }", "function processMessageFromRoot(\n uint256 stateId,\n address rootMessageSender,\n bytes calldata data\n ) external override {\n require(msg.sender == fxBridge, \"FxBaseBridgeTunnel: INVALID_SENDER\");\n _processMessageFromRoot(stateId, rootMessageSender, data);\n }", "function _processMessageFromRoot(\n uint256, \n address sender,\n bytes memory data\n ) internal override validateSender(sender) {\n \n (bytes32 syncType, bytes memory syncData) = abi.decode(data, (bytes32, bytes));\n if (syncType == DEPOSIT) {\n function _syncDeposit(...) {...}\n_syncDeposit(syncData);\n } else if (syncType == MAP_TOKEN) {\n _mapToken(syncData);\n } else {\n revert(\"FxERC20BridgeTunnel: INVALID_SYNC_TYPE\");\n }\n }", "function _syncDeposit(bytes memory syncData) internal {\n (address rootToken, address depositor, address to, uint256 amount, bytes memory depositData) = abi.decode(\n syncData,\n (address, address, address, uint256, bytes)\n );\n address bridgeToken = rootToBridgeToken[rootToken];\n require(bridgeToken != address(0), \"Bridge Token cannot be zero address\");\n \n IFxERC20 bridgeTokenContract = IFxERC20(bridgeToken);\n bridgeTokenContract.mint(to, amount);\n \n \n if (_isContract(to)) {\n uint256 txGas = 2000000;\n bool success = false;\n bytes memory data = abi.encodeWithSignature(\n \"onTokenTransfer(address,address,address,address,uint256,bytes)\",\n rootToken,\n bridgeToken,\n depositor,\n to,\n amount,\n depositData\n );\n \n assembly {\n success := call(txGas, to, 0, add(data, 0x20), mload(data), 0, 0)\n }\n }\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didnâ€™t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
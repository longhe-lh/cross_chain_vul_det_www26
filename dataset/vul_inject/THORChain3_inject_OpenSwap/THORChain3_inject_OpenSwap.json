{"project": "OpenSwap", "functions": ["function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock onlyEndUser {\n require(isLive, \"PAUSED\");\n uint256 amount0In;\n uint256 amount1In;\n amount0In = IERC20(token0).balanceOf(address(this)).sub(lastToken0Balance);\n amount1In = IERC20(token1).balanceOf(address(this)).sub(lastToken1Balance);\n uint256 protocolFeeCollected;\n if (amount0Out == 0 && amount1Out != 0){\n (amount1Out, protocolFeeCollected) = _swap(to, true, amount0In, amount1Out, data);\n _safeTransfer(token1, to, amount1Out); \n protocolFeeBalance0 = protocolFeeBalance0.add(protocolFeeCollected);\n } else if (amount0Out != 0 && amount1Out == 0){\n (amount0Out, protocolFeeCollected) = _swap(to, false, amount1In, amount0Out, data);\n _safeTransfer(token0, to, amount0Out); \n protocolFeeBalance1 = protocolFeeBalance1.add(protocolFeeCollected);\n } else {\n revert(\"Not supported\");\n }\n _sync();\n }", "function _swap(address to, bool direction, uint256 amountIn, uint256 _amountOut, bytes calldata data) internal returns (uint256 amountOut, uint256 protocolFeeCollected) {\n uint256 amountInMinusProtocolFee;\n {\n uint256 price;\n uint256 tradeFeeCollected;\n uint256 tradeFee;\n uint256 protocolFee;\n (amountOut, price, tradeFeeCollected, tradeFee, protocolFee) = _getSwappedAmount(direction, amountIn, data);\n require(amountOut >= _amountOut, \"INSUFFICIENT_AMOUNT\");\n if (protocolFee == 0) {\n amountInMinusProtocolFee = amountIn;\n } else {\n protocolFeeCollected = amountIn.mul(tradeFee.mul(protocolFee)).div(FEE_BASE_SQ);\n amountInMinusProtocolFee = amountIn.sub(protocolFeeCollected);\n }\n emit Swap(to, direction, price, amountIn, amountOut, tradeFeeCollected, protocolFeeCollected);\n }\n uint256 remainOut = amountOut;\n uint256 index = first[direction];\n Offer storage offer;\n Offer storage counteroffer;\n while (remainOut > 0 && index != 0) {\n offer = offers[direction][index];\n if (offer.expire < block.timestamp) {\n index = _dequeue(direction, index);\n } else {\n counteroffer = offers[!direction][index];\n uint256 amount = offer.amount;\n if (remainOut >= amount) {\n \n remainOut = remainOut.sub(amount);\n uint256 providerShare = amountInMinusProtocolFee.mul(amount).div(amountOut);\n counteroffer.reserve = counteroffer.reserve.add(providerShare);\n offer.amount = 0;\n emit SwappedOneProvider(offer.provider, direction, amount, providerShare, 0, counteroffer.reserve);\n \n index = _dequeue(direction, index);\n } else {\n \n uint256 providerShare = amountInMinusProtocolFee.mul(remainOut).div(amountOut);\n counteroffer.reserve = counteroffer.reserve.add(providerShare);\n offer.amount = offer.amount.sub(remainOut);\n emit SwappedOneProvider(offer.provider, direction, remainOut, providerShare, offer.amount, counteroffer.reserve);\n remainOut = 0;\n }\n }\n }\n require(remainOut == 0, \"Amount exceeds available fund\");\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didnâ€™t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
{"project": "Instant Cross", "functions": ["function addCrossData(bytes32 fromChain, bytes32 toChain, bytes32 pmId, bytes memory proofData, bytes memory crossData) public {\n require(fromChain != toChain,\"fromChain is the same as the toChain\");\n require(cctRoot.getChainId() == toChain, \"bad chainId\");\n require(cctRoot.verify(pmId,proofData,crossData),\"no authorized pmId\");\n \n RLP.RLPItem[] memory ls = crossData.toRLPItem().toList(); \n uint i;\n for(i = 0; i < ls.length; i++){\n RLP.RLPItem[] memory pd = ls[i].toList();\n if(pd.length !=5 && pd.length != 4) {\n emit BadProofData(crossData,1);\n continue;\n }\n bytes32 channel = pd[0].toBytes32();\n bytes32 cctTxHash = pd[1].toBytes32();\n bytes32 fromSrv = pd[2].toBytes32();\n uint entryMod = pd[3].toUint();\n bytes memory businessProof = pd[4].toBytes();\n if(!cctChannel.authorized(pmId,channel)) {\n emit BadProofData(crossData,2);\n continue;\n }\n address entry = cctChannel.getChannelEntry(channel);\n if(entry == address(0x0) || !contractExists(entry)){\n emit ProofEvent(fromChain,toChain, pmId,channel,fromSrv,entryMod,cctTxHash,businessProof,false);\n continue;\n }\n if(BIZ(entry).handleProof(fromChain,toChain, pmId,channel,fromSrv,entryMod,cctTxHash,businessProof)){\n emit ProofEvent(fromChain,toChain, pmId,channel,fromSrv,entryMod,cctTxHash,businessProof,true);\n }else{\n emit ProofEvent(fromChain,toChain, pmId,channel,fromSrv,entryMod,cctTxHash,businessProof,false);\n }\n }\n }", "function exchangeBuyLock(bytes32 toChain, bytes32 pmId, bytes32 channel,bytes32 cctTxHash, bytes memory businessProof) private returns(bool){\n ProofRecord storage proofRecord = proofHistory[cctTxHash];\n if(proofRecord.cctTxHash != 0x0) return false;\n bytes32 xHash;\n bytes memory goodsInfo; \n address goodsReceiptor;\n address payToken;\n \n (xHash,goodsInfo,goodsReceiptor,payToken) = decodeBuyLock(businessProof);\n if(xHash == 0x0 && goodsReceiptor == address(0x0) && payToken == address(0x0)) return false;\n proofRecord.toChain = toChain;\n proofRecord.pmId = pmId;\n proofRecord.channel = channel;\n proofRecord.cctTxHash = cctTxHash;\n proofRecord.status = ProofStatus.LOCK;\n exchangBuyLockHandle(cctTxHash,channel,xHash, goodsInfo, goodsReceiptor,payToken);\n calAndUpdateProofStatus(cctTxHash);\n if (proofRecord.status == ProofStatus.CONFIRM){\n emit ExchangeBuyConfirm(chainId, cctChannel.getChannelCrossChain(channel), proofRecord.pmId, proofRecord.channel,cctTxHash, SRVID, ENTRYMOD_EXCHANGEBUYCOMFIRM);\n return true;\n }else{\n return false;\n }\n }", "function exchangBuyLockHandle(bytes32 cctTxHash,bytes32 channel,bytes32 xHash, bytes memory goodsInfo, address goodsReceiptor,address payToken) private returns(bool){\n address goodsOwner;\n address receiptToken;\n uint amount;\n address subSrvGoods;\n address subSrvExchange;\n bool goodsFlag = false;\n subSrvGoods = cctChannel.getChannelSubSrv(channel,SRVID_GOODS);\n \n (goodsOwner,receiptToken,amount) = Goods(subSrvGoods).buyLock(cctTxHash,xHash, goodsInfo, goodsReceiptor);\n if(goodsOwner == address(0x0) && receiptToken == address(0x0) && amount == 0) {\n setSubSrvStatus(cctTxHash,SRVID_GOODS,ProofStatus.LOCK);\n goodsFlag = false;\n }else{\n setSubSrvStatus(cctTxHash,SRVID_GOODS,ProofStatus.CONFIRM);\n goodsFlag = true;\n }\n bool exchangeFlag = false;\n subSrvExchange = cctChannel.getChannelSubSrv(channel,SRVID_EXCHANGE);\n \n if(!Exchange(subSrvExchange).exchangeLock(cctTxHash,xHash, payToken, receiptToken, amount, goodsOwner)) {\n setSubSrvStatus(cctTxHash,SRVID_EXCHANGE,ProofStatus.LOCK);\n exchangeFlag = false;\n }else{\n setSubSrvStatus(cctTxHash,SRVID_EXCHANGE,ProofStatus.CONFIRM);\n exchangeFlag = true;\n }\n return exchangeFlag && goodsFlag;\n }", "function process(bytes memory _message) public returns (bool _success) {\n        \n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        \n        bytes32 _messageHash = _m.keccak();\n        require(acceptableRoot(messages[_messageHash]), \"!proven\");\n        \n        require(entered == 1, \"!reentrant\");\n        entered = 0;\n        \n        messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n        \n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        \n        emit Process(_messageHash, true, \"\");\n        \n        entered = 1;\n        \n        return true;\n    }"], "label": "Yes", "detail": "Because confirmAt[bytes32(0)] was initialized to 1, acceptableRoot(bytes32(0)) always returns true, so attackers can submit arbitrary messages without proof and drain funds by calling process()"}
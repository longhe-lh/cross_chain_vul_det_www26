{"project": "Oswap CrossChain Bridge", "functions": ["function swap(\n bytes[] calldata signatures,\n address _owner,\n uint256 _orderId,\n uint256 amendment,\n uint256 protocolFee,\n address[] calldata pair,\n Order calldata order\n ) external override nonReentrant whenNotPaused returns (uint256 amount) {\n bytes32 orderId = hashOrder(_owner, order.peerChain, _orderId);\n amount = order.inAmount;\n \n require(swapOrderStatus[orderId] == OrderStatus.NotSpecified,\"BridgeVault: Order already processed\");\n require(trollRegistry.isSuperTroll(msg.sender, true), \"not a super troll\");\n function lastKnownBalance(...) {...}\nrequire(lastKnownBalance() >= amount, \"BridgeVault: insufficient balance\");\n address router;\n uint256 price;\n {\n uint256 fee;\n address govTokenOracle;\n address assetTokenOracle;\n uint256 baseFee;\n uint256 transactionFee; \n IOSWAP_SwapPolicy swapPolicy;\n (swapPolicy, router, govTokenOracle, assetTokenOracle, baseFee, transactionFee) = configStore.getBridgeParams(asset);\n if (address(swapPolicy) != address(0)) {\n require(swapPolicy.allowToSwap(order), \"swap policy not met\");\n }\n transactionFee = amount * transactionFee / 1e18;\n fee = transactionFee + baseFee + protocolFee;\n require(amount > fee, \"Input amount too small\");\n imbalance -= toInt256(amount);\n lpAssetBalance += transactionFee;\n protocolFeeBalance += baseFee + protocolFee;\n price = assetPriceAgainstGovToken(govTokenOracle, assetTokenOracle);\n amount = amount - fee;\n }\n (uint256[] memory signers, ) = _verifyStakedValue(signatures, hashSwapParams(orderId, amendment, order, protocolFee, pair), amount * 1e18 / price);\n swapOrderStatus[orderId] = OrderStatus.Executed;\n if (pair.length == 0) {\n require(address(asset) == order.outToken, \"Invalid token\");\n require(amount >= order.minOutAmount, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n IERC20(order.outToken).safeTransfer(order.to, amount);\n } else {\n asset.safeIncreaseAllowance(address(router), amount);\n uint[] memory amounts;\n if (order.outToken == address(0)) {\n (, amounts) = IOSWAP_HybridRouter2(router).swapExactTokensForETH(amount, order.minOutAmount, pair, order.to, order.expire, \"0x00\");\n } else {\n address[] memory paths;\n (paths, amounts) = IOSWAP_HybridRouter2(router).swapExactTokensForTokens(amount, order.minOutAmount, pair, address(asset), order.to, order.expire, \"0x00\");\n require(paths[paths.length-1] == order.outToken,\"BridgeVault: Token out not match\");\n }\n amount = amounts[amounts.length-1];\n }\n emit Swap(_orderId, msg.sender, signers, _owner, amendment, order, amount, imbalance, lpAssetBalance, protocolFeeBalance);\n }", "function _verifyStakedValue(address msgSender, bytes[] calldata signatures, bytes32 paramsHash) internal returns (uint256 superTrollCount, uint totalStake, uint256[] memory signers) {\n require(!usedNonce[paramsHash], \"nonce used\");\n usedNonce[paramsHash] = true;\n uint256 generalTrollCount;\n {\n uint256 length = signatures.length;\n signers = new uint256[](length);\n address lastSigningTroll;\n for (uint256 i = 0; i < length; ++i) {\n address troll = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", paramsHash)).recover(signatures[i]);\n require(troll != address(0), \"Invalid signer\");\n uint256 trollProfileIndex = trollRegistry.trollProfileInv(troll);\n if (trollProfileIndex > 0 && troll > lastSigningTroll) {\n signers[i] = trollProfileIndex;\n if (trollRegistry.isSuperTroll(troll, true)) {\n superTrollCount++;\n } else if (trollRegistry.isGeneralTroll(troll, true)) {\n generalTrollCount++;\n }\n totalStake += trollStakesBalances[trollProfileIndex];\n lastSigningTroll = troll;\n }\n }\n }\n (uint256 generalTrollMinCount, uint256 superTrollMinCount, uint256 transactionsGap) = configStore.getSignatureVerificationParams();\n require(generalTrollCount >= generalTrollMinCount, \"OSWAP_BridgeVault: Mininum general troll count not met\");\n require(superTrollCount >= superTrollMinCount, \"OSWAP_BridgeVault: Mininum super troll count not met\");\n \n uint256 _transactionsCount = (++transactionsCount);\n require((lastTrollTxCount[msgSender] + transactionsGap < _transactionsCount) || (_transactionsCount <= transactionsGap), \"too soon\");\n lastTrollTxCount[msgSender] = _transactionsCount;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Synbiosis", "functions": ["function synthesize(\n uint256 _stableBridgingFee,\n address _token,\n uint256 _amount,\n address _chain2address,\n address _receiveSide,\n address _oppositeBridge,\n address _revertableAddress,\n uint256 _chainID,\n bytes32 _clientID\n ) external whenNotPaused returns (bytes32) {\n require(tokenWhitelist[_token], \"Symb: unauthorized token\");\n require(_amount >= tokenThreshold[_token], \"Symb: amount under threshold\");\n TransferHelper.safeTransferFrom(\n _token,\n _msgSender(),\n address(this),\n _amount\n );\n return\n sendSynthesizeRequest(\n _stableBridgingFee,\n _token,\n _amount,\n _chain2address,\n _receiveSide,\n _oppositeBridge,\n _revertableAddress,\n _chainID,\n _clientID\n );\n }", "function sendSynthesizeRequest(\n uint256 _stableBridgingFee,\n address _token,\n uint256 _amount,\n address _chain2address,\n address _receiveSide,\n address _oppositeBridge,\n address _revertableAddress,\n uint256 _chainID,\n bytes32 _clientID\n ) internal returns (bytes32 internalID) {\n balanceOf[_token] = balanceOf[_token] + _amount;\n if (_revertableAddress == address(0)) {\n _revertableAddress = _chain2address;\n }\n internalID = keccak256(abi.encodePacked(this, requestCount, block.chainid));\n {\n bytes32 externalID = keccak256(abi.encodePacked(internalID, _receiveSide, _revertableAddress, _chainID));\n {\n bytes memory out = abi.encodeWithSelector(\n bytes4(\n keccak256(\n bytes(\n \"mintSyntheticToken(uint256,bytes32,address,uint256,uint256,address)\"\n )\n )\n ),\n _stableBridgingFee,\n externalID,\n _token,\n block.chainid,\n _amount,\n _chain2address\n );\n requests[externalID] = TxState({\n recipient : _msgSender(),\n chain2address : _chain2address,\n rtoken : _token,\n amount : _amount,\n state : RequestState.Sent\n });\n requestCount++;\n IBridge(bridge).transmitRequestV2(\n out,\n _receiveSide,\n _oppositeBridge,\n _chainID\n );\n }\n }\n emit SynthesizeRequest(\n internalID,\n _msgSender(),\n _chainID,\n _revertableAddress,\n _chain2address,\n _amount,\n _token\n );\n emit ClientIdLog(internalID, _clientID);\n }", "function mintSyntheticToken(\n uint256 _stableBridgingFee,\n bytes32 _externalID,\n address _tokenReal,\n uint256 _chainID,\n uint256 _amount,\n address _to\n ) external onlyBridge whenNotPaused {\n require(\n synthesizeStates[_externalID] == SynthesizeState.Default,\n \"Symb: revertSynthesizedRequest called or tokens have been already synthesized\"\n );\n synthesizeStates[_externalID] = SynthesizeState.Synthesized;\n address syntReprAddr = ISyntFabric(fabric).getSyntRepresentation(_tokenReal, _chainID);\n require(syntReprAddr != address(0), \"Symb: There is no synt representation for this token\");\n ISyntFabric(fabric).synthesize(\n _to,\n _amount - _stableBridgingFee,\n syntReprAddr\n );\n ISyntFabric(fabric).synthesize(\n bridge,\n _stableBridgingFee,\n syntReprAddr\n );\n emit SynthesizeCompleted(_externalID, _to, _amount - _stableBridgingFee, _stableBridgingFee, _tokenReal);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
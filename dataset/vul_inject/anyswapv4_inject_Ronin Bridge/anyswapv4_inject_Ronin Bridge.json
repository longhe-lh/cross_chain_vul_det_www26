{"project": "Ronin Bridge", "functions": ["function withdrawERC20For(\n uint256 _withdrawalId,\n address _user,\n address _token,\n uint256 _amount,\n bytes memory _signatures\n )\n public\n whenNotPaused\n onlyMappedToken(_token, 20)\n {\n bytes32 _hash = keccak256(\n abi.encodePacked(\n \"withdrawERC20\",\n _withdrawalId,\n _user,\n _token,\n _amount\n )\n );\n function verifySignatures(...) {...}\nfunction sub(...) {...}\nfunction mint(...) {...}\nfunction transfer(...) {...}\nrequire(verifySignatures(_hash, _signatures));\n if (_token == registry.getContract(registry.WETH_TOKEN())) {\n _withdrawETHFor(_user, _amount);\n } else {\n uint256 _gatewayBalance = IERC20(_token).balanceOf(address(this));\n if (_gatewayBalance < _amount) {\n require(\n IERC20Mintable(_token).mint(address(this), _amount.sub(_gatewayBalance)),\n \"MainchainGatewayManager: Minting ERC20 token to gateway failed\"\n );\n }\n require(IERC20(_token).transfer(_user, _amount), \"Transfer failed\");\n }\n _insertWithdrawalEntry(\n _withdrawalId,\n _user,\n _token,\n _amount\n );\n }", "function withdrawERC721For(\n uint256 _withdrawalId,\n address _user,\n address _token,\n uint256 _tokenId,\n bytes memory _signatures\n )\n public\n whenNotPaused\n onlyMappedToken(_token, 721)\n {\n bytes32 _hash = keccak256(\n abi.encodePacked(\n \"withdrawERC721\",\n _withdrawalId,\n _user,\n _token,\n _tokenId\n )\n );\n function verifySignatures(...) {...}\nfunction mint(...) {...}\nrequire(verifySignatures(_hash, _signatures));\n if (!_tryERC721TransferFrom(_token, address(this), _user, _tokenId)) {\n require(\n IERC721Mintable(_token).mint(_user, _tokenId),\n \"MainchainGatewayManager: Minting ERC721 token to gateway failed\"\n );\n }\n _insertWithdrawalEntry(_withdrawalId, _user, _token, _tokenId);\n }", "function _insertWithdrawalEntry(\n uint256 _withdrawalId,\n address _owner,\n address _token,\n uint256 _number\n )\n internal\n onlyNewWithdrawal(_withdrawalId)\n {\n WithdrawalEntry memory _entry = WithdrawalEntry(\n _owner,\n _token,\n _number\n );\n withdrawals[_withdrawalId] = _entry;\n emit TokenWithdrew(_withdrawalId, _owner, _token, _number);\n }", "function anySwapOutUnderlyingWithPermit(\n        address from,\n        address token,\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external {\n        address _underlying = AnyswapV1ERC20(token).underlying();\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n        AnyswapV1ERC20(token).depositVault(amount, from);\n        _anySwapOut(from, token, to, amount, toChainID);\n    }"], "label": "Yes", "detail": "On February 15, 2023, the AnyswapV4Router contract of Multichain was exploited via a frontrunning MEV bot. The attacker used a crafted transaction to call the anySwapOutUnderlyingWithPermit function before a legitimate user's transaction could execute. The function assumed the underlying token (WETH) supported the ERC-2612 permit interface, but WETH lacked the permit method. Consequently, the fallback deposit function was triggered instead of validating the signature. The attacker then successfully used safeTransferFrom to transfer the WETH to their own address without proper authorization, gaining approximately 87 ETH (~$130,000)."}
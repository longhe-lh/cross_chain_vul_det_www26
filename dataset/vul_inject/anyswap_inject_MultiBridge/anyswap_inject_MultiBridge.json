{"project": "MultiBridge", "functions": ["function execute(\n bytes32 commandId,\n string calldata sourceChain,\n string calldata sourceAddress,\n bytes calldata payload\n ) external override {\n \n if (keccak256(bytes(sourceChain)) != keccak256(bytes(senderChain))) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, keccak256(payload))) {\n revert Error.NOT_APPROVED_BY_GATEWAY();\n }\n \n if (sourceAddress.toAddress() != senderAdapter) {\n revert Error.INVALID_SENDER_ADAPTER();\n }\n \n AdapterPayload memory decodedPayload = abi.decode(payload, (AdapterPayload));\n bytes32 msgId = decodedPayload.msgId;\n \n if (commandIdStatus[commandId] || isMessageExecuted[msgId]) {\n revert MessageIdAlreadyExecuted(msgId);\n }\n \n if (decodedPayload.finalDestination != gac.getMultiMessageReceiver(block.chainid)) {\n revert Error.INVALID_FINAL_DESTINATION();\n }\n isMessageExecuted[msgId] = true;\n commandIdStatus[commandId] = true;\n MessageLibrary.Message memory _data = abi.decode(decodedPayload.data, (MessageLibrary.Message));\n try IMultiMessageReceiver(decodedPayload.finalDestination).receiveMessage(_data, name) {\n emit MessageIdExecuted(_data.srcChainId, msgId);\n } catch (bytes memory lowLevelData) {\n revert MessageFailure(msgId, lowLevelData);\n }\n }", "function receiveMessage(MessageLibrary.Message calldata _message, string memory _bridgeName)\n external\n override\n onlyReceiverAdapter\n {\n if (_message.dstChainId != block.chainid) {\n revert Error.INVALID_DST_CHAIN();\n }\n if (_message.target == address(0)) {\n revert Error.INVALID_TARGET();\n }\n \n if (_message.srcChainId != 1) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n \n bytes32 msgId = MessageLibrary.computeMsgId(_message);\n if (isDuplicateAdapter[msgId][msg.sender]) {\n revert Error.DUPLICATE_MESSAGE_DELIVERY_BY_ADAPTER();\n }\n if (isExecuted[msgId]) {\n revert Error.MSG_ID_ALREADY_EXECUTED();\n }\n isDuplicateAdapter[msgId][msg.sender] = true;\n \n ++messageVotes[msgId];\n \n ExecutionData memory prevStored = msgReceived[msgId];\n \n if (prevStored.target == address(0)) {\n msgReceived[msgId] = ExecutionData(\n _message.target, _message.callData, _message.nativeValue, _message.nonce, _message.expiration\n );\n }\n emit SingleBridgeMsgReceived(msgId, _bridgeName, _message.nonce, msg.sender);\n }", "function depositWithPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns (uint) {\n        IERC20(underlying).permit(target, address(this), value, deadline, v, r, s);\n        IERC20(underlying).safeTransferFrom(target, address(this), value);\n        return _deposit(value, to);\n    }"], "label": "Yes", "detail": "The attacker exploited the fact that some tokens do not implement `permit()` but include a fallback function that silently accepts calls without reverting. By invoking `depositWithPermit`, the attacker could spoof the `target` (the victim address) and bypass approval checks because `permit()` succeeded trivially. Afterwards, `safeTransferFrom(target, ...)` would transfer tokens from the victim to the attacker-controlled contract. This is an authentication bypass in the cross-chain liquidity pool contract, allowing theft of user funds without a valid permit or signature."}
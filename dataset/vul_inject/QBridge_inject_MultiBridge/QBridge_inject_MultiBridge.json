{"project": "MultiBridge", "functions": ["function dispatchMessage(uint256 _toChainId, address _to, bytes calldata _data)\n external\n payable\n override\n onlyMultiMessageSender\n returns (bytes32 msgId)\n {\n if (_toChainId == 0) {\n revert Error.ZERO_CHAIN_ID();\n }\n address receiverAdapter = receiverAdapters[_toChainId];\n if (receiverAdapter == address(0)) {\n revert Error.ZERO_RECEIVER_ADAPTER();\n }\n msgId = _getNewMessageId(_toChainId, _to);\n bytes memory payload = abi.encode(AdapterPayload(msgId, msg.sender, receiverAdapter, _to, _data));\n IMessageBus(msgBus).sendMessage{value: msg.value}(receiverAdapter, _toChainId, payload);\n emit MessageDispatched(msgId, msg.sender, _toChainId, _to, _data);\n }", "function executeTransaction(uint256 _txId, address _target, uint256 _value, bytes memory _data, uint256 _eta)\n external\n payable\n override\n {\n \n if (_txId == 0 || _txId > txCounter) {\n revert Error.INVALID_TX_ID();\n }\n \n if (isExecuted[_txId]) {\n revert Error.TX_ALREADY_EXECUTED();\n }\n \n if (scheduledTransaction[_txId] != keccak256(abi.encodePacked(_target, _value, _data, _eta))) {\n revert Error.INVALID_TX_INPUT();\n }\n \n if (_eta > block.timestamp) {\n revert Error.TX_TIMELOCKED();\n }\n \n if (block.timestamp > _eta + GRACE_PERIOD) {\n revert Error.TX_EXPIRED();\n }\n \n if (msg.value != _value) {\n revert Error.INVALID_MSG_VALUE();\n }\n isExecuted[_txId] = true;\n (bool status,) = _target.call{value: _value}(_data);\n if (!status) {\n revert Error.EXECUTION_FAILS_ON_DST();\n }\n emit TransactionExecuted(_txId, _target, _value, _data, _eta);\n }", "function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\n        }\n    }"], "label": "Yes", "detail": "The attacker on Ethereum called deposit() with malicious data but no actual ETH; since tokenAddress was zero, safeTransferFrom succeeded silently and a Deposit event was emitted. On BSC, relayers listened to that event and called voteProposal multiple times, leading to massive xETH minting."}
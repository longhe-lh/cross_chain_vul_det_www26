{"project": "Counterstake Bridge", "functions": ["function claim(\n Settings storage settings,\n mapping(string => uint) storage claim_nums,\n mapping(uint => Claim) storage claims,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n ClaimRequest memory req\n ) external {\n require(req.amount > 0, \"0 claim\");\n require(req.stake >= req.required_stake, \"the stake is too small\");\n require(block.timestamp >= req.txts + settings.min_tx_age, \"too early\");\n if (req.recipient_address == address(0))\n req.recipient_address = payable(msg.sender);\n if (req.reward < 0)\n require(\n req.recipient_address == payable(msg.sender),\n \"the sender disallowed third-party claiming by setting a negative reward\"\n );\n string memory claim_id = getClaimId(\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.data\n );\n require(\n claim_nums[claim_id] == 0,\n \"this transfer has already been claimed\"\n );\n bool is_large = (settings.large_threshold > 0 &&\n req.stake >= settings.large_threshold);\n uint32 expiry_ts = uint32(\n block.timestamp + getChallengingPeriod(settings, 0, is_large)\n ); \n claim_nums[claim_id] = claim_num;\n \n claims[claim_num] = Claim({\n amount: req.amount,\n \n recipient_address: req.recipient_address,\n claimant_address: payable(msg.sender),\n sender_address: req.sender_address,\n \n data: req.data,\n yes_stake: req.stake,\n no_stake: 0,\n current_outcome: Side.yes,\n is_large: is_large,\n period_number: 0,\n txts: req.txts,\n ts: uint32(block.timestamp),\n expiry_ts: expiry_ts,\n \n withdrawn: false,\n finished: false\n });\n stakes[claim_num][Side.yes][msg.sender] = req.stake;\n emit NewClaim(\n claim_num,\n msg.sender,\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.stake,\n req.data,\n expiry_ts\n );\n \n }", "function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\n        }\n    }"], "label": "Yes", "detail": "The attacker on Ethereum called deposit() with malicious data but no actual ETH; since tokenAddress was zero, safeTransferFrom succeeded silently and a Deposit event was emitted. On BSC, relayers listened to that event and called voteProposal multiple times, leading to massive xETH minting."}
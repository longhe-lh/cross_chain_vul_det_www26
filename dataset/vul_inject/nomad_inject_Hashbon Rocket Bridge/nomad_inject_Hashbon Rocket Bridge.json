{"project": "Hashbon Rocket Bridge", "functions": ["function updateOffer(\n uint _offerId,\n uint _amount,\n uint _rate,\n address _payAddress,\n uint _minPurchase\n ) public {\n _checkOfferAccess(_offerId);\n require(_rate > 0, \"Rate must be greater than 0\");\n uint blockedAmount = _getBlockedAmount(_offerId);\n require(\n _amount >= blockedAmount,\n \"You can not withdraw tokens ordered by customers\"\n );\n if (_amount > offers[_offerId].amount) {\n TransferHelper.safeTransferFrom(\n offers[_offerId].token,\n msg.sender,\n address(this),\n _amount - offers[_offerId].amount\n );\n } else {\n TransferHelper.safeTransfer(\n offers[_offerId].token,\n msg.sender,\n offers[_offerId].amount - _amount\n );\n }\n offers[_offerId].amount = _amount;\n offers[_offerId].rate = _rate;\n offers[_offerId].payAddress = _payAddress;\n offers[_offerId].minPurchase = _minPurchase;\n emit OfferUpdate(\n _offerId,\n _payAddress,\n _amount,\n _rate,\n _minPurchase,\n offers[_offerId].active\n );\n }", "function safeTransferFrom(\n address token,\n address from,\n address to,\n uint256 value\n ) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0x23b872dd, from, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::transferFrom: transferFrom failed\"\n );\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::safeTransfer: transfer failed\"\n );\n }", "function withdrawTokens(uint _orderId, bytes calldata _sign) public {\n require(_orderId < orders.length, \"Incorrect orderId\");\n require(orders[_orderId].complete == false, \"Tokens already withdrawn\");\n uint offerId = orders[_orderId].offerId;\n uint amount = orders[_orderId].amount;\n uint payAmount = orders[_orderId].payAmount;\n address payToken = offers[offerId].payToken;\n address payAddress = orders[_orderId].payAddress;\n require(\n orders[_orderId].reservedUntil >= block.timestamp ||\n offers[offerId].amount - _getBlockedAmount(offerId) >= amount,\n \"Not enough tokens in the offer\"\n );\n bytes32 data = keccak256(\n abi.encodePacked(_orderId, payAmount, payToken, payAddress)\n );\n require(_verifySign(data, _sign), \"Incorrect signature\");\n TransferHelper.safeTransfer(\n offers[offerId].token,\n orders[_orderId].withdrawAddress,\n amount\n );\n orders[_orderId].complete = true;\n offers[offerId].amount -= amount;\n emit OrderComplete(_orderId, offers[offerId].amount);\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::safeTransfer: transfer failed\"\n );\n }", "function process(bytes memory _message) public returns (bool _success) {\n        \n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        \n        bytes32 _messageHash = _m.keccak();\n        require(acceptableRoot(messages[_messageHash]), \"!proven\");\n        \n        require(entered == 1, \"!reentrant\");\n        entered = 0;\n        \n        messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n        \n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        \n        emit Process(_messageHash, true, \"\");\n        \n        entered = 1;\n        \n        return true;\n    }"], "label": "Yes", "detail": "Because confirmAt[bytes32(0)] was initialized to 1, acceptableRoot(bytes32(0)) always returns true, so attackers can submit arbitrary messages without proof and drain funds by calling process()"}
{"project": "Meson", "functions": ["function postSwap(uint256 encodedSwap, bytes32 r, bytes32 s, uint8 v, uint200 postingValue)\n external matchProtocolVersion(encodedSwap) forInitialChain(encodedSwap)\n {\n require(_postedSwaps[encodedSwap] == 0, \"Swap already exists\");\n uint256 amount = _amountFrom(encodedSwap);\n require(amount <= MAX_SWAP_AMOUNT, \"For security reason, amount cannot be greater than 100k\");\n uint256 delta = _expireTsFrom(encodedSwap) - block.timestamp;\n \n require(delta > MIN_BOND_TIME_PERIOD, \"Expire ts too early\");\n require(delta < MAX_BOND_TIME_PERIOD, \"Expire ts too late\");\n uint40 poolIndex = _poolIndexFromPosted(postingValue);\n if (poolIndex > 0) {\n \n require(poolOfAuthorizedAddr[_msgSender()] == poolIndex, \"Signer should be an authorized address of the given pool\");\n } \n address initiator = _initiatorFromPosted(postingValue);\n _checkRequestSignature(encodedSwap, r, s, v, initiator);\n _postedSwaps[encodedSwap] = postingValue;\n uint8 tokenIndex = _inTokenIndexFrom(encodedSwap);\n _unsafeDepositToken(tokenForIndex[tokenIndex], initiator, amount, tokenIndex);\n emit SwapPosted(encodedSwap);\n }", "function _checkRequestSignature(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_33 : TRON_SIGN_HEADER, encodedSwap));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER, encodedSwap));\n } else {\n bytes32 typehash = REQUEST_TYPE_HASH;\n assembly {\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 32))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }", "function _unsafeDepositToken(\n address token,\n address sender,\n uint256 amount,\n uint8 tokenIndex\n ) internal {\n require(token != address(0), \"Token not supported\");\n require(amount > 0, \"Amount must be greater than zero\");\n require(Address.isContract(token), \"The given token address is not a contract\");\n if (_needAdjustAmount(tokenIndex)) {\n amount *= 1e12;\n }\n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(\n ERC20_TRANSFER_FROM_SELECTOR,\n sender,\n address(this),\n amount\n ));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"transferFrom failed\");\n }", "function lock(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address initiator\n ) external matchProtocolVersion(encodedSwap) forTargetChain(encodedSwap) {\n bytes32 swapId = _getSwapId(encodedSwap, initiator);\n require(_lockedSwaps[swapId] == 0, \"Swap already exists\");\n _checkRequestSignature(encodedSwap, r, s, v, initiator);\n uint40 poolIndex = poolOfAuthorizedAddr[_msgSender()];\n require(poolIndex != 0, \"Caller not registered. Call depositAndRegister.\");\n uint256 until = block.timestamp + LOCK_TIME_PERIOD;\n require(until < _expireTsFrom(encodedSwap) - 5 minutes, \"Cannot lock because expireTs is soon.\");\n uint48 poolTokenIndex = _poolTokenIndexForOutToken(encodedSwap, poolIndex);\n \n _balanceOfPoolToken[poolTokenIndex] -= (_amountFrom(encodedSwap) - _feeForLp(encodedSwap));\n _lockedSwaps[swapId] = _lockedSwapFrom(until, poolIndex);\n emit SwapLocked(encodedSwap);\n }", "function _checkRequestSignature(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_33 : TRON_SIGN_HEADER, encodedSwap));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER, encodedSwap));\n } else {\n bytes32 typehash = REQUEST_TYPE_HASH;\n assembly {\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 32))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
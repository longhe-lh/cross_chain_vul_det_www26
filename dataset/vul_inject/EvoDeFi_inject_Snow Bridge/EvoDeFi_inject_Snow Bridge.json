{"project": "Snow Bridge", "functions": ["function submit(Message calldata message, bytes32[] calldata leafProof, bytes calldata headerProof) external {\n bytes32 leafHash = keccak256(abi.encode(message));\n bytes32 commitment = MerkleProof.processProof(leafProof, leafHash);\n if (!parachainClient.verifyCommitment(commitment, headerProof)) {\n revert InvalidProof();\n }\n if (message.nonce != nonce[message.origin] + 1) {\n revert InvalidNonce();\n }\n \n \n \n \n \n \n \n nonce[message.origin]++;\n \n \n \n vault.withdraw(message.origin, payable(msg.sender), reward);\n \n \n \n \n if (gasleft() < gasToForward + GAS_BUFFER) {\n revert NotEnoughGas();\n }\n address recipient = resolve(message.recipient);\n DispatchResult result = DispatchResult.Success;\n try IRecipient(recipient).handle{gas: gasToForward}(message.origin, message.payload) {}\n catch {\n result = DispatchResult.Failure;\n }\n emit MessageDispatched(message.origin, message.nonce, result);\n }", "function handle(ParaID origin, bytes calldata message) external override onlyRole(SENDER_ROLE) {\n ensureOrigin(origin, assetHubParaID);\n Message memory decoded = abi.decode(message, (Message));\n if (decoded.action == Action.Unlock) {\n UnlockPayload memory payload = abi.decode(decoded.payload, (UnlockPayload));\n vault.withdraw(payload.recipient, payload.token, payload.amount);\n emit Unlocked(payload.recipient, payload.token, payload.amount);\n }\n }", "function lock(address token, ParaID dest, bytes calldata recipient, uint128 amount) external payable {\n if (amount == 0) {\n revert InvalidAmount();\n }\n vault.deposit(msg.sender, token, amount);\n bytes memory payload = NativeTokensTypes.Mint(address(registry), token, dest, recipient, amount);\n outboundQueue().submit{value: msg.value}(assetHubParaID, payload);\n emit Locked(recipient, token, amount);\n }", "function deposit(address sender, address token, uint128 amount) external onlyRole(DEPOSIT_ROLE) {\n balance[token] += amount;\n IERC20(token).safeTransferFrom(sender, address(this), amount);\n emit Deposit(sender, token, amount);\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
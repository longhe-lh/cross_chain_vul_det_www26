{"project": "Sifchain Bridge", "functions": ["function mintNewBridgeTokens(\n address payable _intendedRecipient,\n address _bridgeTokenAddress,\n string memory _symbol,\n uint256 _amount\n ) internal {\n require(\n controlledBridgeTokens[_symbol] == _bridgeTokenAddress,\n \"Token must be a controlled bridge token\"\n );\n \n require(\n BridgeToken(_bridgeTokenAddress).mint(_intendedRecipient, _amount),\n \"Attempted mint of bridge tokens failed\"\n );\n emit LogBridgeTokenMint(\n _bridgeTokenAddress,\n _symbol,\n _amount,\n _intendedRecipient\n );\n }", "function unlock(\n address payable _recipient,\n string memory _symbol,\n uint256 _amount\n ) public onlyCosmosBridge whenNotPaused {\n \n require(\n getLockedFunds(_symbol) >= _amount,\n \"!Bank funds\"\n );\n \n address tokenAddress = lockedTokenList[_symbol];\n if (tokenAddress == address(0)) {\n require(\n ((address(this)).balance) >= _amount,\n \"Insufficient ethereum balance for delivery.\"\n );\n } else {\n require(\n BridgeToken(tokenAddress).balanceOf(address(this)) >= _amount,\n \"Insufficient ERC20 token balance for delivery.\"\n );\n }\n unlockFunds(_recipient, tokenAddress, _symbol, _amount);\n }", "function unlockFunds(\n address payable _recipient,\n address _token,\n string memory _symbol,\n uint256 _amount\n ) internal {\n \n lockedFunds[_token] = lockedFunds[_token].sub(_amount);\n \n if (_token == address(0)) {\n (bool success,) = _recipient.call.value(_amount)(\"\");\n require(success, \"error sending ether\");\n } else {\n IERC20 tokenToTransfer = IERC20(_token);\n tokenToTransfer.safeTransfer(_recipient, _amount);\n }\n emit LogUnlock(_recipient, _token, _symbol, _amount);\n }", "function process(bytes memory _message) public returns (bool _success) {\n        \n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        \n        bytes32 _messageHash = _m.keccak();\n        require(acceptableRoot(messages[_messageHash]), \"!proven\");\n        \n        require(entered == 1, \"!reentrant\");\n        entered = 0;\n        \n        messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n        \n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        \n        emit Process(_messageHash, true, \"\");\n        \n        entered = 1;\n        \n        return true;\n    }"], "label": "Yes", "detail": "Because confirmAt[bytes32(0)] was initialized to 1, acceptableRoot(bytes32(0)) always returns true, so attackers can submit arbitrary messages without proof and drain funds by calling process()"}
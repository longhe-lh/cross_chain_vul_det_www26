{"project": "Sream Gold Bridge", "functions": ["function onStateReceive(uint256 stateId, bytes calldata _data) external override {\n require(msg.sender == address(0x0000000000000000000000000000000000001001), \"Invalid sender\");\n (address rootMessageSender, address receiver, bytes memory data) = abi.decode(_data, (address, address, bytes));\n emit NewFxMessage(rootMessageSender, receiver, data);\n IFxMessageProcessor(receiver).processMessageFromRoot(stateId, rootMessageSender, data);\n }", "function processMessageFromRoot(\n uint256 stateId,\n address rootMessageSender,\n bytes calldata data\n ) external override {\n require(msg.sender == fxBridge, \"FxBaseBridgeTunnel: INVALID_SENDER\");\n _processMessageFromRoot(stateId, rootMessageSender, data);\n }", "function _processMessageFromRoot(\n uint256, \n address sender,\n bytes memory data\n ) internal override validateSender(sender) {\n \n (bytes32 syncType, bytes memory syncData) = abi.decode(data, (bytes32, bytes));\n if (syncType == DEPOSIT) {\n function _syncDeposit(...) {...}\n_syncDeposit(syncData);\n } else if (syncType == MAP_TOKEN) {\n _mapToken(syncData);\n } else {\n revert(\"FxERC20BridgeTunnel: INVALID_SYNC_TYPE\");\n }\n }", "function _syncDeposit(bytes memory syncData) internal {\n (address rootToken, address depositor, address to, uint256 amount, bytes memory depositData) = abi.decode(\n syncData,\n (address, address, address, uint256, bytes)\n );\n address bridgeToken = rootToBridgeToken[rootToken];\n require(bridgeToken != address(0), \"Bridge Token cannot be zero address\");\n \n IFxERC20 bridgeTokenContract = IFxERC20(bridgeToken);\n bridgeTokenContract.mint(to, amount);\n \n \n if (_isContract(to)) {\n uint256 txGas = 2000000;\n bool success = false;\n bytes memory data = abi.encodeWithSignature(\n \"onTokenTransfer(address,address,address,address,uint256,bytes)\",\n rootToken,\n bridgeToken,\n depositor,\n to,\n amount,\n depositData\n );\n \n assembly {\n success := call(txGas, to, 0, add(data, 0x20), mload(data), 0, 0)\n }\n }\n }", "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\ttokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}"], "label": "Yes", "detail": "The getAssetFromTokenAddress function in THORChain's Ethereum scanner fails to properly handle ERC20 tokens with 'ETH' symbol. When processing deposits, it defaults to native ETH asset type if the token metadata isn't found in local storage. An attacker can deploy a malicious ERC20 token with 'ETH' symbol, causing the bridge to incorrectly identify the token as native Ethereum. This allows fake tokens to be treated as genuine ETH in cross-chain transactions."}
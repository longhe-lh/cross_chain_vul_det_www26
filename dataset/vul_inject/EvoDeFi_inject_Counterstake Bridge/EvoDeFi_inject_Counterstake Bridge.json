{"project": "Counterstake Bridge", "functions": ["function challenge(\n Settings storage settings,\n Claim storage c,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n Side stake_on,\n uint stake\n ) external {\n require(\n block.timestamp < c.expiry_ts,\n \"the challenging period has expired\"\n );\n require(\n stake_on != c.current_outcome,\n \"this outcome is already current\"\n );\n uint excess;\n uint challenging_target = ((\n c.current_outcome == Side.yes ? c.yes_stake : c.no_stake\n ) * settings.counterstake_coef100) / 100;\n {\n \n uint stake_on_proposed_outcome = (\n stake_on == Side.yes ? c.yes_stake : c.no_stake\n ) + stake;\n bool would_override_current_outcome = stake_on_proposed_outcome >=\n challenging_target;\n excess = would_override_current_outcome\n ? stake_on_proposed_outcome - challenging_target\n : 0;\n uint accepted_stake = stake - excess;\n if (stake_on == Side.yes) c.yes_stake += accepted_stake;\n else c.no_stake += accepted_stake;\n if (would_override_current_outcome) {\n c.period_number++;\n c.current_outcome = stake_on;\n c.expiry_ts = uint32(\n block.timestamp +\n getChallengingPeriod(\n settings,\n c.period_number,\n c.is_large\n )\n );\n challenging_target =\n (challenging_target * settings.counterstake_coef100) /\n 100;\n }\n stakes[claim_num][stake_on][msg.sender] += accepted_stake;\n }\n emit NewChallenge(\n claim_num,\n msg.sender,\n stake,\n stake_on,\n c.current_outcome,\n c.yes_stake,\n c.no_stake,\n c.expiry_ts,\n challenging_target\n );\n if (excess > 0) {\n if (settings.tokenAddress == address(0))\n payable(msg.sender).transfer(excess);\n else IERC20(settings.tokenAddress).safeTransfer(msg.sender, excess);\n }\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
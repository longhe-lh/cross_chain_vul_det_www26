{"project": "Wrap Protocol", "functions": ["function execTransaction(\n address to,\n uint256 value,\n bytes calldata data,\n string calldata tezosOperation,\n bytes calldata signatures\n )\n external\n returns (bool success)\n {\n require(tezosOperations[tezosOperation] == false, 'WRAP: TRANSACTION_ALREADY_PROCESSED');\n tezosOperations[tezosOperation] = true;\n bytes memory txHashData = encodeTransactionData(\n to, value, data,\n tezosOperation\n );\n bytes32 txHash = keccak256(txHashData);\n function _checkSignatures(...) {...}\nfunction _execute(...) {...}\n_checkSignatures(txHash, signatures);\n success = _execute(to, value, data, gasleft());\n if (success) emit ExecutionSuccess(txHash);\n else emit ExecutionFailure(txHash);\n }", "function _checkSignatures(\n bytes32 dataHash,\n bytes memory signatures\n )\n internal\n view\n {\n uint256 _threshold = threshold;\n require(_threshold > 0, \"WRAP: THRESHOLD_NOT_DEFINED\");\n require(signatures.length >= _threshold.mul(65), \"WRAP: SIGNATURES_DATA_TOO_SHORT\");\n address lastOwner = address(0);\n address currentOwner;\n uint8 v;\n bytes32 r;\n bytes32 s;\n uint256 i;\n for (i = 0; i < _threshold; i++) {\n (v, r, s) = _signatureSplit(signatures, i);\n currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v, r, s);\n require (\n currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n \"WRAP: INVALID_OWNER_PROVIDED\"\n );\n lastOwner = currentOwner;\n }\n }", "function _execute(\n address to,\n uint256 value,\n bytes memory data,\n uint256 txGas\n )\n internal\n returns (bool success)\n {\n assembly {\n success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n }\n }", "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\ttokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}"], "label": "Yes", "detail": "The getAssetFromTokenAddress function in THORChain's Ethereum scanner fails to properly handle ERC20 tokens with 'ETH' symbol. When processing deposits, it defaults to native ETH asset type if the token metadata isn't found in local storage. An attacker can deploy a malicious ERC20 token with 'ETH' symbol, causing the bridge to incorrectly identify the token as native Ethereum. This allows fake tokens to be treated as genuine ETH in cross-chain transactions."}
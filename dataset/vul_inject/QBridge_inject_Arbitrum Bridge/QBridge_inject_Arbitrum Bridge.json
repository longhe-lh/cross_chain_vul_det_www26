{"project": "Arbitrum Bridge", "functions": ["function executeCall(\n address to,\n uint256 value,\n bytes calldata data\n ) external returns (bool success, bytes memory returnData) {\n if (!allowedOutboxesMap[msg.sender].allowed)\n revert NotOutbox(msg.sender);\n if (data.length > 0 && !to.isContract()) revert NotContract(to);\n address prevOutbox = _activeOutbox;\n _activeOutbox = msg.sender;\n \n \n \n \n (success, returnData) = to.call{value: value}(data);\n _activeOutbox = prevOutbox;\n emit BridgeCallTriggered(msg.sender, to, value, data);\n }", "function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external {\n if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);\n roots[root] = l2BlockHash;\n emit SendRootUpdated(root, l2BlockHash);\n }", "function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\n        }\n    }"], "label": "Yes", "detail": "The attacker on Ethereum called deposit() with malicious data but no actual ETH; since tokenAddress was zero, safeTransferFrom succeeded silently and a Deposit event was emitted. On BSC, relayers listened to that event and called voteProposal multiple times, leading to massive xETH minting."}
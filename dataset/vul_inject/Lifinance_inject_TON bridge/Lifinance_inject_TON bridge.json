{"project": "TON bridge", "functions": ["function voteForMinting(SwapData memory data, Signature[] memory signatures) override public {\n bytes32 _id = getSwapDataId(data);\n function generalVote(...) {...}\nfunction executeMinting(...) {...}\ngeneralVote(_id, signatures);\n executeMinting(data);\n }", "function generalVote(bytes32 digest, Signature[] memory signatures) internal {\n \n \n require(signatures.length >= 2 * oraclesSet.length / 3, \"Not enough signatures\");\n require(!finishedVotings[digest], \"Vote is already finished\");\n uint signum = signatures.length;\n uint last_signer = 0;\n for(uint i=0; i<signum; i++) {\n address signer = signatures[i].signer;\n require(isOracle[signer], \"Unauthorized signer\");\n uint next_signer = uint(signer);\n require(next_signer > last_signer, \"Signatures are not sorted\");\n last_signer = next_signer;\n checkSignature(digest, signatures[i]);\n }\n finishedVotings[digest] = true;\n }", "function checkSignature(bytes32 digest, Signature memory sig) public pure {\n if (sig.signature.length != 65) {\n revert(\"ECDSA: invalid signature length\");\n }\n \n bytes32 r;\n bytes32 s;\n uint8 v;\n bytes memory signature = sig.signature;\n \n \n \n assembly {\n r := mload(add(signature, 0x20))\n s := mload(add(signature, 0x40))\n v := byte(0, mload(add(signature, 0x60)))\n }\n if (\n uint256(s) >\n 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n ) {\n revert(\"ECDSA: invalid signature 's' value\");\n }\n if (v != 27 && v != 28) {\n revert(\"ECDSA: invalid signature 'v' value\");\n }\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, digest));\n require(ecrecover(prefixedHash, v, r, s) == sig.signer, \"Wrong signature\");\n }", "function executeMinting(SwapData memory data) internal {\n mint(data);\n }", "function mint(SwapData memory sd) internal {\n _mint(sd.receiver, sd.amount);\n emit SwapTonToEth(sd.tx.address_.workchain, sd.tx.address_.address_hash, sd.tx.tx_hash, sd.tx.lt, sd.receiver, sd.amount);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n _totalSupply += amount;\n _balances[account] += amount;\n emit Transfer(address(0), account, amount);\n }", "function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n            \n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n            \n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n            _cBridgeData.amount = _postSwapBalance;\n        }\n        _startBridge(_cBridgeData);\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }"], "label": "Yes", "detail": "The attacker crafted a payload where the first element performs a small legitimate swap to pass the function's flow, while subsequent entries invoke transferFrom calls directlyâ€”leveraging users' infinite token approvals to siphon assets from multiple wallets. After draining funds, the contract continues normal bridge execution (_startBridge) to avoid transaction failure. The root cause is swapAndStartBridgeTokensViaCBridge allowing arbitrary call execution via LibSwap.swap() without any parameter validation or restrictions."}
{"project": "Hop.Exchange", "functions": ["function bondTransferRoot(\n bytes32 rootHash,\n uint256 destinationChainId,\n uint256 totalAmount\n )\n external\n onlyBonder\n requirePositiveBalance\n {\n bytes32 transferRootId = getTransferRootId(rootHash, totalAmount);\n require(transferRootCommittedAt[destinationChainId][transferRootId] == 0, \"L1_BRG: TransferRoot has already been confirmed\");\n require(transferBonds[transferRootId].createdAt == 0, \"L1_BRG: TransferRoot has already been bonded\");\n uint256 currentTimeSlot = getTimeSlot(block.timestamp);\n uint256 bondAmount = getBondForTransferAmount(totalAmount);\n timeSlotToAmountBonded[currentTimeSlot][msg.sender] = timeSlotToAmountBonded[currentTimeSlot][msg.sender].add(bondAmount);\n transferBonds[transferRootId] = TransferBond(\n msg.sender,\n block.timestamp,\n totalAmount,\n uint256(0),\n address(0),\n false\n );\n function _distributeTransferRoot(...) {...}\n_distributeTransferRoot(rootHash, destinationChainId, totalAmount);\n emit TransferRootBonded(rootHash, totalAmount);\n }", "function _setTransferRoot(bytes32 rootHash, uint256 totalAmount) internal {\n bytes32 transferRootId = getTransferRootId(rootHash, totalAmount);\n require(_transferRoots[transferRootId].total == 0, \"BRG: Transfer root already set\");\n require(totalAmount > 0, \"BRG: Cannot set TransferRoot totalAmount of 0\");\n _transferRoots[transferRootId] = TransferRoot(totalAmount, 0, block.timestamp);\n emit TransferRootSet(rootHash, totalAmount);\n }", "function bondWithdrawal(\n address recipient,\n uint256 amount,\n bytes32 transferNonce,\n uint256 bonderFee\n )\n external\n onlyBonder\n requirePositiveBalance\n nonReentrant\n {\n bytes32 transferId = getTransferId(\n getChainId(),\n recipient,\n amount,\n transferNonce,\n bonderFee,\n 0,\n 0\n );\n function _bondWithdrawal(...) {...}\nfunction _fulfillWithdraw(...) {...}\n_bondWithdrawal(transferId, amount);\n _fulfillWithdraw(transferId, recipient, amount, bonderFee);\n }", "function _bondWithdrawal(bytes32 transferId, uint256 amount) internal {\n require(_bondedWithdrawalAmounts[msg.sender][transferId] == 0, \"BRG: Withdrawal has already been bonded\");\n _addDebit(msg.sender, amount);\n _bondedWithdrawalAmounts[msg.sender][transferId] = amount;\n emit WithdrawalBonded(transferId, amount);\n }", "function _addDebit(address bonder, uint256 amount) internal {\n _debit[bonder] = _debit[bonder].add(amount);\n }", "function _fulfillWithdraw(\n bytes32 transferId,\n address recipient,\n uint256 amount,\n uint256 bonderFee\n ) private {\n function _markTransferSpent(...) {...}\n_markTransferSpent(transferId);\n _transferFromBridge(recipient, amount.sub(bonderFee));\n if (bonderFee > 0) {\n _transferFromBridge(msg.sender, bonderFee);\n }\n }", "function _markTransferSpent(bytes32 transferId) internal {\n require(!_spentTransferIds[transferId], \"BRG: The transfer has already been withdrawn\");\n _spentTransferIds[transferId] = true;\n }", "func (pin ProofInnerNode) Hash(childHash []byte) ([]byte, error) {\n\thasher := sha256.New()\n\tbuf := bufPool.Get().(*bytes.Buffer)\n\tbuf.Reset()\n\tdefer bufPool.Put(buf)\n\terr := encoding.EncodeVarint(buf, int64(pin.Height))\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Size)\n\t}\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Version)\n\t}\n\tif len(pin.Left) == 0 {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Right)\n\t\t}\n\t} else {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Left)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to hash ProofInnerNode: %v\", err)\n\t}\n\t_, err = hasher.Write(buf.Bytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn hasher.Sum(nil), nil\n}"], "label": "Yes", "detail": "An attacker exploited this by constructing an IAVL proof containing multiple leaves and deliberately populating `LeftPath[1].Right` and `Leaves[1]` with fabricated values. Since the `Hash` function ignored `pin.Right` when `pin.Left` was set, the resulting root hash remained correct and passed `bytes.Equal(rootHash, lpath.Right)` checks. SharkTeam explicitly notes the vulnerability: “when pin.Left is not empty, the situation where pin.Right is null or not is not handled… pin.Right does not participate in the calculation of Hash” :contentReference[oaicite:1]{index=1}."}
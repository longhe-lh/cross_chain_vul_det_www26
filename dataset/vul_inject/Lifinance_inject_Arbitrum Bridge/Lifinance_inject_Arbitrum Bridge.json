{"project": "Arbitrum Bridge", "functions": ["function addSequencerL2BatchFromOrigin(\n uint256 sequenceNumber,\n bytes calldata data,\n uint256 afterDelayedMessagesRead,\n IGasRefunder gasRefunder\n ) external refundsGas(gasRefunder) {\n \n if (msg.sender != tx.origin) revert NotOrigin();\n if (!isBatchPoster[msg.sender]) revert NotBatchPoster();\n (bytes32 dataHash, TimeBounds memory timeBounds) = formDataHash(\n data,\n afterDelayedMessagesRead\n );\n (\n uint256 seqMessageIndex,\n bytes32 beforeAcc,\n bytes32 delayedAcc,\n bytes32 afterAcc\n ) = addSequencerL2BatchImpl(\n dataHash,\n afterDelayedMessagesRead,\n data.length\n );\n if (seqMessageIndex != sequenceNumber)\n revert BadSequencerNumber(seqMessageIndex, sequenceNumber);\n emit SequencerBatchDelivered(\n sequenceNumber,\n beforeAcc,\n afterAcc,\n delayedAcc,\n totalDelayedMessagesRead,\n timeBounds,\n BatchDataLocation.TxInput\n );\n }", "function addSequencerL2BatchImpl(\n bytes32 dataHash,\n uint256 afterDelayedMessagesRead,\n uint256 calldataLengthPosted\n )\n internal\n returns (\n uint256 seqMessageIndex,\n bytes32 beforeAcc,\n bytes32 delayedAcc,\n bytes32 acc\n )\n {\n if (afterDelayedMessagesRead < totalDelayedMessagesRead)\n revert DelayedBackwards();\n if (afterDelayedMessagesRead > bridge.delayedMessageCount())\n revert DelayedTooFar();\n (seqMessageIndex, beforeAcc, delayedAcc, acc) = bridge\n .enqueueSequencerMessage(dataHash, afterDelayedMessagesRead);\n totalDelayedMessagesRead = afterDelayedMessagesRead;\n if (calldataLengthPosted > 0) {\n \n \n address batchPoster = msg.sender;\n bytes memory spendingReportMsg = abi.encodePacked(\n block.timestamp,\n batchPoster,\n dataHash,\n seqMessageIndex,\n block.basefee\n );\n uint256 msgNum = bridge.submitBatchSpendingReport(\n batchPoster,\n keccak256(spendingReportMsg)\n );\n \n emit InboxMessageDelivered(msgNum, spendingReportMsg);\n }\n }", "function enqueueSequencerMessage(\n bytes32 dataHash,\n uint256 afterDelayedMessagesRead\n )\n external\n onlySequencerInbox\n returns (\n uint256 seqMessageIndex,\n bytes32 beforeAcc,\n bytes32 delayedAcc,\n bytes32 acc\n )\n {\n seqMessageIndex = sequencerInboxAccs.length;\n if (sequencerInboxAccs.length > 0) {\n beforeAcc = sequencerInboxAccs[sequencerInboxAccs.length - 1];\n }\n if (afterDelayedMessagesRead > 0) {\n delayedAcc = delayedInboxAccs[afterDelayedMessagesRead - 1];\n }\n acc = keccak256(abi.encodePacked(beforeAcc, dataHash, delayedAcc));\n sequencerInboxAccs.push(acc);\n }", "function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n            \n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n            \n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n            _cBridgeData.amount = _postSwapBalance;\n        }\n        _startBridge(_cBridgeData);\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }"], "label": "Yes", "detail": "The attacker crafted a payload where the first element performs a small legitimate swap to pass the function's flow, while subsequent entries invoke transferFrom calls directlyâ€”leveraging users' infinite token approvals to siphon assets from multiple wallets. After draining funds, the contract continues normal bridge execution (_startBridge) to avoid transaction failure. The root cause is swapAndStartBridgeTokensViaCBridge allowing arbitrary call execution via LibSwap.swap() without any parameter validation or restrictions."}
{"project": "Ronin Bridge", "functions": ["function removeValidator(address _validator) external onlyAdmin {\n function _removeValidator(...) {...}\n_removeValidator(nonce++, _validator);\n }", "function _removeValidator(uint256 _id, address _validator)\n internal\n {\n function isValidator(...) {...}\nrequire(isValidator(_validator));\n uint256 _index;\n for (uint256 _i = 0; _i < validatorCount; _i++) {\n if (validators[_i] == _validator) {\n _index = _i;\n break;\n }\n }\n validatorMap[_validator] = false;\n validators[_index] = validators[validatorCount - 1];\n validators.pop();\n validatorCount--;\n emit ValidatorRemoved(_id, _validator);\n }", "function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\n        }\n    }"], "label": "Yes", "detail": "The attacker on Ethereum called deposit() with malicious data but no actual ETH; since tokenAddress was zero, safeTransferFrom succeeded silently and a Deposit event was emitted. On BSC, relayers listened to that event and called voteProposal multiple times, leading to massive xETH minting."}
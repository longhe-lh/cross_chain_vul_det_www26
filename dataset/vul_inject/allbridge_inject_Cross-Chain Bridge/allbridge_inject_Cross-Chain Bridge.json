{"project": "Cross-Chain Bridge", "functions": ["function _releaseERC20(\n uint8[] memory sigV,\n bytes32[] memory sigR,\n bytes32[] memory sigS,\n address receiverAddress,\n address sourceNetworkTokenAddress,\n uint256 amount,\n uint256 depositChainId,\n uint256 depositNumber,\n bool keepTokensInBridge\n ) private whenNotPaused returns (uint256 releaseAmountAfterFees) {\n \n require(\n !releasedDeposits[depositChainId][depositNumber],\n \"CrossChainBridgeERC20: Deposit was already processed and released\"\n );\n require(\n receiverAddress != address(0),\n \"CrossChainBridgeERC20: invalid receiverAddress provided\"\n );\n require(\n sourceNetworkTokenAddress != address(0),\n \"CrossChainBridgeERC20: invalid sourceNetworkTokenAddress provided\"\n );\n require(amount > 0, \"CrossChainBridgeERC20: amount cannot be 0\");\n \n require(\n multiSignatureOracle.signaturesCheckERC20(\n sigV,\n sigR,\n sigS,\n receiverAddress,\n sourceNetworkTokenAddress,\n amount,\n depositChainId,\n depositNumber\n ),\n \"CrossChainBridgeERC20: Release not permitted. Not enough signatures from permitted oracles\"\n );\n \n \n address releaseChainTokenAddress = sourceNetworkTokenAddress;\n \n if (outsidePeggedTokens[sourceNetworkTokenAddress] != address(0)) {\n releaseChainTokenAddress = outsidePeggedTokens[\n sourceNetworkTokenAddress\n ];\n }\n IERC20 token = ERC20(releaseChainTokenAddress);\n \n require(\n token.balanceOf(address(this)) >= amount,\n \"CrossChainBridgeERC20: Not enough liquidity in bridge\"\n );\n \n \n uint256 relativeFee = bridgeFees[releaseChainTokenAddress] > 0\n ? bridgeFees[releaseChainTokenAddress]\n : defaultBridgeFee;\n \n \n uint256 bridgingFee = (amount * relativeFee) / 1000000;\n \n uint256 bridgingFeeToCollectAddress = (bridgingFee *\n collectBridgeFeePercentage) / 1000000;\n \n uint256 bridgingFeeToLiquidityMining = (bridgingFee *\n liquidityMiningFeePercentage) / 1000000;\n \n uint256 bridgingFeeToRewardPool = bridgingFee -\n bridgingFeeToCollectAddress -\n bridgingFeeToLiquidityMining;\n \n releasedDeposits[depositChainId][depositNumber] = true;\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(buyBackAndBurn)\n ] += bridgingFeeToCollectAddress;\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] += bridgingFeeToLiquidityMining;\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] += bridgingFeeToRewardPool;\n \n if (\n lastTransferBlock[releaseChainTokenAddress][address(rewardPools)] +\n blocksBetweenFeeTransfersToRewardPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] >\n 0\n ) {\n \n rewardPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(rewardPools)\n ] = block.number;\n } else if (\n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] +\n blocksBetweenFeeTransfersToLiquidityMiningPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] >\n 0\n ) {\n \n \n liquidityMiningPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = block.number;\n }\n releaseAmountAfterFees = amount - bridgingFee;\n \n \n if (!keepTokensInBridge) {\n \n token.safeTransfer(receiverAddress, releaseAmountAfterFees);\n }\n emit TokensReleased(\n sourceNetworkTokenAddress,\n releaseAmountAfterFees,\n receiverAddress,\n depositChainId,\n depositNumber\n );\n }", "function addRewards(\n IERC20 token,\n uint256 amount\n ) external whenNotPaused nonReentrant {\n \n require(\n address(token) != address(0),\n \"RewardPoolsV1: invalid address provided\"\n );\n \n if (!rewardPools[address(token)].exists) {\n \n rewardPools[address(token)] = RewardPool({\n rewardToken: token,\n interestBearingToken: new PoolsInterestBearingToken(\n \"Cross-Chain Bridge RP LPs\",\n \"BRIDGE-RP\",\n address(token)\n ),\n minStakeAmount: 1,\n maxStakeAmount: 0,\n maxPoolSize: 0,\n totalStakedAmount: 0,\n totalRewardAmount: 0,\n accRewardPerShare: 0,\n lastRewardAmount: 0,\n exists: true\n });\n \n PoolsInterestBearingToken(\n address(rewardPools[address(token)].interestBearingToken)\n ).setPoolsContract(address(this));\n }\n \n token.safeTransferFrom(_msgSender(), address(this), amount);\n \n \n \n if (rewardPools[address(token)].totalStakedAmount == 0) {\n \n require(\n token.approve(address(buyBackAndBurnContract), amount),\n \"RewardPoolsV1: approval failed\"\n );\n buyBackAndBurnContract.depositERC20(token, amount);\n } else {\n \n rewardPools[address(token)].totalRewardAmount =\n rewardPools[address(token)].totalRewardAmount +\n amount;\n }\n \n emit RewardsAdded(address(token), amount);\n }", "function buyBackAndBurnERC20(\n address collectedToken\n ) external whenNotPaused nonReentrant {\n \n require(\n collectedToken != address(0),\n \"BuyBackAndBurnV1: invalid token address\"\n );\n \n \n bridgeERC20.sendCollectedTokensToBuyBackAndBurn(IERC20(collectedToken));\n \n uint256 amount = collectedERC20ToBurn[collectedToken];\n require(amount > 0, \"BuyBackAndBurnV1: no tokens to burn\");\n \n if (\n IERC20(collectedToken).allowance(address(this), address(router)) <\n amount\n ) {\n IERC20(collectedToken).approve(address(router), type(uint256).max);\n }\n \n uint256 burnAmount = router.tradeERC20(\n IERC20(collectedToken),\n burnToken,\n amount\n );\n \n uint256 balanceBurnToken = burnToken.balanceOf(address(this));\n ERC20Burnable(address(burnToken)).burn(balanceBurnToken);\n \n collectedERC20ToBurn[collectedToken] = 0;\n \n emit BoughtBackAndBurned(\n collectedToken,\n amount,\n address(burnToken),\n balanceBurnToken\n );\n }", "function swapToVUsd(address user, uint256 amount) external onlyRouter returns (uint256) {\n        uint256 result; \n        uint256 fee;\n        if (amount > 0) {\n            fee = amount * feeShareBP / BP;\n            uint256 amountIn = toSystemPrecision(amount - fee);\n            \n            fee = amount - fromSystemPrecision(amountIn);\n            tokenBalance += amountIn;\n            uint256 vUsdNewAmount = this.getY(tokenBalance);\n            if (vUsdBalance > vUsdNewAmount) {\n                result = vUsdBalance - vUsdNewAmount;\n            }\n            vUsdBalance = vUsdNewAmount;\n            token.safeTransferFrom(user, address(this), amount);\n            _addRewards(fee);\n        }\n        emit SwappedToVUsd(user, address(token), amount, result, fee);\n        return result;\n    }"], "label": "Yes", "detail": "The attacker took out a 7.5 million BUSD flash loan, then made large deposits and swaps in the BUSD–vUSD and USDT–vUSD pools to manipulate exchange rates. They then swapped assets in the reverse direction to gain profits of approximately 550,000 BUSD before repaying the flash loan."}
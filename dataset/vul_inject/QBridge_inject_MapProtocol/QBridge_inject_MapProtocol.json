{"project": "MapProtocol", "functions": ["function bindingWorker(uint256 _chainId, bytes32 _worker)\n external\n override\n onlyRelayer\n {\n require(\n bindRelayer[_worker][_chainId] == address(0),\n \"Relayer: worker already binded\"\n );\n _setBindAddress(msg.sender, _worker, _chainId);\n emit WorkerSet(msg.sender, _chainId, _worker);\n }", "function _setBindAddress(\n address _relayer,\n bytes32 _worker,\n uint256 _chainId\n ) internal {\n RelayerInfo storage ri = _relayerInfo[_relayer];\n if (ri.worker[_chainId] == bytes32(0)) {\n \n ri.chainIdList.push(_chainId);\n }\n ri.worker[_chainId] = _worker;\n bindRelayer[_worker][_chainId] = _relayer;\n }", "function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\n        }\n    }"], "label": "Yes", "detail": "The attacker on Ethereum called deposit() with malicious data but no actual ETH; since tokenAddress was zero, safeTransferFrom succeeded silently and a Deposit event was emitted. On BSC, relayers listened to that event and called voteProposal multiple times, leading to massive xETH minting."}
{"project": "EYWA Bridge", "functions": ["function receiveV2(\n ReceiveParams[] calldata params\n ) external override onlyRole(VALIDATOR_ROLE) nonReentrant returns (bool) {\n require(state != State.Inactive, \"Bridge: state inactive\");\n for (uint256 i = 0; i < params.length; ++i) {\n bytes32 epochHash = Block.epochHash(params[i].blockHeader);\n \n if (epochHash == currentEpoch.epochHash) {\n require(currentEpoch.isSet(), \"Bridge: epoch not set\");\n verifyEpoch(currentEpoch, params[i]);\n } else if (epochHash == previousEpoch.epochHash) {\n require(previousEpoch.isSet(), \"Bridge: epoch not set\");\n verifyEpoch(previousEpoch, params[i]);\n } else {\n revert(\"Bridge: wrong epoch\");\n }\n \n bytes memory payload = Merkle.prove(\n params[i].merkleProof,\n Block.txRootHash(params[i].blockHeader)\n );\n \n (\n bytes32 requestId,\n bytes memory receivedData,\n address to,\n uint64 chainIdTo\n ) = Block.decodeRequest(payload);\n require(chainIdTo == block.chainid, \"Bridge: wrong chain id\");\n require(to.isContract(), \"Bridge: receiver is not a contract\");\n bool isRequestIdUniq;\n if (epochHash == currentEpoch.epochHash) {\n isRequestIdUniq = currentRequestIdChecker.check(requestId);\n } else {\n isRequestIdUniq = previousRequestIdChecker.check(requestId);\n }\n string memory err;\n if (isRequestIdUniq) {\n (bytes memory data, bytes memory check) = abi.decode(\n receivedData,\n (bytes, bytes)\n );\n bytes memory result = to.functionCall(check);\n require(abi.decode(result, (bool)), \"Bridge: check failed\");\n to.functionCall(data, \"Bridge: receive failed\");\n } else {\n revert(\"Bridge: request id already seen\");\n }\n emit RequestReceived(requestId, err);\n }\n return true;\n }", "function verifyEpoch(\n Bls.Epoch storage epoch,\n ReceiveParams calldata params\n ) internal view {\n Block.verify(\n epoch,\n params.blockHeader,\n params.votersPubKey,\n params.votersSignature,\n params.votersMask\n );\n }", "function check(bytes32 id) public onlyOwner returns (bool) {\n if (checks[id] == false) {\n checks[id] = true;\n return true;\n }\n return false;\n }", "function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\n        }\n    }"], "label": "Yes", "detail": "The attacker on Ethereum called deposit() with malicious data but no actual ETH; since tokenAddress was zero, safeTransferFrom succeeded silently and a Deposit event was emitted. On BSC, relayers listened to that event and called voteProposal multiple times, leading to massive xETH minting."}
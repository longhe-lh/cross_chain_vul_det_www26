{"project": "MapProtocol", "functions": ["function transferOutTokenBurn(address token, address to, uint amount, uint toChainId) external payable\n checkBalance(token,msg.sender,amount) {\n function safeTransferFrom(...) {...}\nTransferHelper.safeTransferFrom(token,msg.sender,address(this),amount);\n collectChainFee(toChainId,0);\n uint outAmount = getAmountWithdraw(amount);\n transferFeeList[token] = transferFeeList[token].add(amount).sub(outAmount);\n IMAPToken(token).burn(outAmount);\n bytes32 orderId = getOrderID(token, msg.sender, to, outAmount, toChainId);\n emit mapTransferOut(token, msg.sender, to, orderId, outAmount, selfChainId, toChainId);\n }", "function safeTransferFrom(address token, address from, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n }", "function transferInToken(address token, address from, address payable to, uint amount, bytes32 orderId, uint fromChain, uint toChain)\n external checkOrder(orderId) nonReentrant onlyManager{\n uint outAmount = getAmountWithdraw(amount);\n if (toChain == selfChainId) {\n require(IERC20(token).balanceOf(address(this)) >= amount,\"balance too low\");\n function safeTransfer(...) {...}\nTransferHelper.safeTransfer(token,to,amount);\n emit mapTransferIn(token, from, to, orderId, outAmount, fromChain, toChain);\n }else{\n emit mapTransferOut(token, from, to, orderId, outAmount, fromChain, toChain);\n }\n }", "function safeTransfer(address token, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n }", "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\ttokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}"], "label": "Yes", "detail": "The getAssetFromTokenAddress function in THORChain's Ethereum scanner fails to properly handle ERC20 tokens with 'ETH' symbol. When processing deposits, it defaults to native ETH asset type if the token metadata isn't found in local storage. An attacker can deploy a malicious ERC20 token with 'ETH' symbol, causing the bridge to incorrectly identify the token as native Ethereum. This allows fake tokens to be treated as genuine ETH in cross-chain transactions."}
{"project": "TON bridge", "functions": ["function voteForMinting(SwapData memory data, Signature[] memory signatures) override public {\n bytes32 _id = getSwapDataId(data);\n function generalVote(...) {...}\nfunction executeMinting(...) {...}\ngeneralVote(_id, signatures);\n executeMinting(data);\n }", "function generalVote(bytes32 digest, Signature[] memory signatures) internal {\n \n \n require(signatures.length >= 2 * oraclesSet.length / 3, \"Not enough signatures\");\n require(!finishedVotings[digest], \"Vote is already finished\");\n uint signum = signatures.length;\n uint last_signer = 0;\n for(uint i=0; i<signum; i++) {\n address signer = signatures[i].signer;\n require(isOracle[signer], \"Unauthorized signer\");\n uint next_signer = uint(signer);\n require(next_signer > last_signer, \"Signatures are not sorted\");\n last_signer = next_signer;\n checkSignature(digest, signatures[i]);\n }\n finishedVotings[digest] = true;\n }", "function checkSignature(bytes32 digest, Signature memory sig) public pure {\n if (sig.signature.length != 65) {\n revert(\"ECDSA: invalid signature length\");\n }\n \n bytes32 r;\n bytes32 s;\n uint8 v;\n bytes memory signature = sig.signature;\n \n \n \n assembly {\n r := mload(add(signature, 0x20))\n s := mload(add(signature, 0x40))\n v := byte(0, mload(add(signature, 0x60)))\n }\n if (\n uint256(s) >\n 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n ) {\n revert(\"ECDSA: invalid signature 's' value\");\n }\n if (v != 27 && v != 28) {\n revert(\"ECDSA: invalid signature 'v' value\");\n }\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, digest));\n require(ecrecover(prefixedHash, v, r, s) == sig.signer, \"Wrong signature\");\n }", "function executeMinting(SwapData memory data) internal {\n mint(data);\n }", "function mint(SwapData memory sd) internal {\n _mint(sd.receiver, sd.amount);\n emit SwapTonToEth(sd.tx.address_.workchain, sd.tx.address_.address_hash, sd.tx.tx_hash, sd.tx.lt, sd.receiver, sd.amount);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n _totalSupply += amount;\n _balances[account] += amount;\n emit Transfer(address(0), account, amount);\n }", "function anySwapOutUnderlyingWithPermit(\n        address from,\n        address token,\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external {\n        address _underlying = AnyswapV1ERC20(token).underlying();\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n        AnyswapV1ERC20(token).depositVault(amount, from);\n        _anySwapOut(from, token, to, amount, toChainID);\n    }"], "label": "Yes", "detail": "On February 15, 2023, the AnyswapV4Router contract of Multichain was exploited via a frontrunning MEV bot. The attacker used a crafted transaction to call the anySwapOutUnderlyingWithPermit function before a legitimate user's transaction could execute. The function assumed the underlying token (WETH) supported the ERC-2612 permit interface, but WETH lacked the permit method. Consequently, the fallback deposit function was triggered instead of validating the signature. The attacker then successfully used safeTransferFrom to transfer the WETH to their own address without proper authorization, gaining approximately 87 ETH (~$130,000)."}
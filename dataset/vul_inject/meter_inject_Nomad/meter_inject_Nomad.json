{"project": "Nomad", "functions": ["function send(\n address _token,\n uint256 _amount,\n uint32 _destination,\n bytes32 _recipient,\n bool _enableFast\n ) external {\n require(_amount > 0, \"!amnt\");\n require(_recipient != bytes32(0), \"!recip\");\n \n bytes32 _remote = _mustHaveRemote(_destination);\n \n IBridgeToken _t = IBridgeToken(_token);\n bytes32 _detailsHash;\n \n if (tokenRegistry.isLocalOrigin(_token)) {\n \n \n IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n \n _detailsHash = BridgeMessage.getDetailsHash(\n _t.name(),\n _t.symbol(),\n _t.decimals()\n );\n } else {\n \n \n _t.burn(msg.sender, _amount);\n _detailsHash = _t.detailsHash();\n }\n \n bytes29 _action = BridgeMessage.formatTransfer(\n _recipient,\n _amount,\n _detailsHash,\n _enableFast\n );\n \n (uint32 _domain, bytes32 _id) = tokenRegistry.getTokenId(_token);\n bytes29 _tokenId = BridgeMessage.formatTokenId(_domain, _id);\n \n Home(xAppConnectionManager.home()).dispatch(\n _destination,\n _remote,\n BridgeMessage.formatMessage(_tokenId, _action)\n );\n \n emit Send(\n _token,\n msg.sender,\n _destination,\n _recipient,\n _amount,\n _enableFast\n );\n }", "function dispatch(\n uint32 _destinationDomain,\n bytes32 _recipientAddress,\n bytes memory _messageBody\n ) external notFailed {\n require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \"msg too long\");\n \n uint32 _nonce = nonces[_destinationDomain];\n nonces[_destinationDomain] = _nonce + 1;\n \n bytes memory _message = Message.formatMessage(\n localDomain,\n bytes32(uint256(uint160(msg.sender))),\n _nonce,\n _destinationDomain,\n _recipientAddress,\n _messageBody\n );\n \n bytes32 _messageHash = keccak256(_message);\n tree.insert(_messageHash);\n \n queue.enqueue(root());\n \n \n emit Dispatch(\n _messageHash,\n count() - 1,\n _destinationAndNonce(_destinationDomain, _nonce),\n committedRoot,\n _message\n );\n }", "function _handleTransfer(\n uint32 _origin,\n uint32 _nonce,\n bytes29 _tokenId,\n bytes29 _action,\n bool _fastEnabled\n ) internal {\n \n \n \n \n address _token = tokenRegistry.ensureLocalToken(\n _tokenId.domain(),\n _tokenId.id()\n );\n \n address _recipient = _action.evmRecipient();\n if (_fastEnabled) {\n \n \n bytes32 _id = BridgeMessage.getPreFillId(\n _origin,\n _nonce,\n _tokenId,\n _action\n );\n address _lp = liquidityProvider[_id];\n if (_lp != address(0)) {\n _recipient = _lp;\n delete liquidityProvider[_id];\n }\n }\n \n uint256 _amount = _action.amnt();\n \n if (tokenRegistry.isLocalOrigin(_token)) {\n \n \n \n \n IERC20(_token).safeTransfer(_recipient, _amount);\n } else {\n \n \n IBridgeToken(_token).mint(_recipient, _amount);\n \n IBridgeToken(_token).setDetailsHash(_action.detailsHash());\n }\n \n emit Receive(\n _originAndNonce(_origin, _nonce),\n _token,\n _recipient,\n address(0),\n _amount\n );\n }", "function safeTransfer(IERC20 token, address to, uint256 value) internal {\n function _callOptionalReturn(...) {...}\n_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n }", "function deposit(uint8 destinationChainID, bytes32 resourceID, bytes calldata data) external payable whenNotPaused {\n        uint256 fee = _getFee(destinationChainID);\n        require(msg.value == fee, \"Incorrect fee supplied\");\n        address handler = _resourceIDToHandlerAddress[resourceID];\n        require(handler != address(0), \"resourceID not mapped to handler\");\n        uint64 depositNonce = ++_depositCounts[destinationChainID];\n        _depositRecords[depositNonce][destinationChainID] = data;\n        IDepositExecute depositHandler = IDepositExecute(handler);\n        depositHandler.deposit(resourceID, destinationChainID, depositNonce, msg.sender, data);\n        emit Deposit(destinationChainID, resourceID, depositNonce);\n    }"], "label": "Yes", "detail": "The Meter.io cross-chain bridge exploit occurred because the Bridge contract failed to properly handle deposits of wrapped assets like WBNB when using the deposit() function. Normally, WETH or WBNB should only be deposited via depositETH(), which handles asset wrapping and ensures actual value is transferred. However, deposit() allowed deposits for any resourceID—including those mapped to WBNB—without checking if tokens were truly received or burned. The attacker exploited this by submitting a fake deposit using a crafted resourceID that resolved to the WBNB contract address, but without sending real tokens. Since no validation was enforced and the event was indistinguishable from a legitimate deposit, the relayers propagated the deposit event to target chains (Ethereum, Moonriver), where equivalent tokens were minted and withdrawn by the attacker. This resulted in severe financial loss, as no real assets backed the minted tokens. The root cause lies in inconsistent validation paths between depositETH() and deposit(), and the lack of enforcement for secure asset custody when dealing with wrapped native tokens."}
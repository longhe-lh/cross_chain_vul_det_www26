{"project": "Counterstake Bridge", "functions": ["function claim(\n Settings storage settings,\n mapping(string => uint) storage claim_nums,\n mapping(uint => Claim) storage claims,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n ClaimRequest memory req\n ) external {\n require(req.amount > 0, \"0 claim\");\n require(req.stake >= req.required_stake, \"the stake is too small\");\n require(block.timestamp >= req.txts + settings.min_tx_age, \"too early\");\n if (req.recipient_address == address(0))\n req.recipient_address = payable(msg.sender);\n if (req.reward < 0)\n require(\n req.recipient_address == payable(msg.sender),\n \"the sender disallowed third-party claiming by setting a negative reward\"\n );\n string memory claim_id = getClaimId(\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.data\n );\n require(\n claim_nums[claim_id] == 0,\n \"this transfer has already been claimed\"\n );\n bool is_large = (settings.large_threshold > 0 &&\n req.stake >= settings.large_threshold);\n uint32 expiry_ts = uint32(\n block.timestamp + getChallengingPeriod(settings, 0, is_large)\n ); \n claim_nums[claim_id] = claim_num;\n \n claims[claim_num] = Claim({\n amount: req.amount,\n \n recipient_address: req.recipient_address,\n claimant_address: payable(msg.sender),\n sender_address: req.sender_address,\n \n data: req.data,\n yes_stake: req.stake,\n no_stake: 0,\n current_outcome: Side.yes,\n is_large: is_large,\n period_number: 0,\n txts: req.txts,\n ts: uint32(block.timestamp),\n expiry_ts: expiry_ts,\n \n withdrawn: false,\n finished: false\n });\n stakes[claim_num][Side.yes][msg.sender] = req.stake;\n emit NewClaim(\n claim_num,\n msg.sender,\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.stake,\n req.data,\n expiry_ts\n );\n \n }", "func (pin ProofInnerNode) Hash(childHash []byte) ([]byte, error) {\n\thasher := sha256.New()\n\tbuf := bufPool.Get().(*bytes.Buffer)\n\tbuf.Reset()\n\tdefer bufPool.Put(buf)\n\terr := encoding.EncodeVarint(buf, int64(pin.Height))\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Size)\n\t}\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Version)\n\t}\n\tif len(pin.Left) == 0 {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Right)\n\t\t}\n\t} else {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Left)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to hash ProofInnerNode: %v\", err)\n\t}\n\t_, err = hasher.Write(buf.Bytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn hasher.Sum(nil), nil\n}"], "label": "Yes", "detail": "An attacker exploited this by constructing an IAVL proof containing multiple leaves and deliberately populating `LeftPath[1].Right` and `Leaves[1]` with fabricated values. Since the `Hash` function ignored `pin.Right` when `pin.Left` was set, the resulting root hash remained correct and passed `bytes.Equal(rootHash, lpath.Right)` checks. SharkTeam explicitly notes the vulnerability: “when pin.Left is not empty, the situation where pin.Right is null or not is not handled… pin.Right does not participate in the calculation of Hash” :contentReference[oaicite:1]{index=1}."}
{"project": "Rainbow Bridge", "functions": ["function depositToEVM(\n string memory ethRecipientOnNear, \n uint256 fee\n )\n external\n payable\n pausable(PAUSED_DEPOSIT_TO_EVM)\n {\n require(\n fee < msg.value,\n 'The fee cannot be bigger than the transferred amount.'\n );\n string memory separator = ':';\n string memory protocolMessage = string(\n abi.encodePacked(\n string(nearProofProducerAccount_),\n separator, ethRecipientOnNear\n )\n );\n emit Deposited(\n msg.sender, \n protocolMessage, \n msg.value, \n fee\n );\n }", "function withdraw(\n bytes calldata proofData, \n uint64 proofBlockHeight\n )\n external\n pausable(PAUSED_WITHDRAW)\n {\n ProofDecoder.ExecutionStatus memory status = _parseAndConsumeProof(proofData, proofBlockHeight);\n BurnResult memory result = _decodeBurnResult(status.successValue);\n require(\n result.ethCustodian == address(this),\n 'Can only withdraw coins that were expected for the current contract'\n );\n payable(result.recipient).transfer(result.amount);\n emit Withdrawn(\n result.recipient,\n result.amount\n );\n }", "function updatePower(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 currentPower = user.power;\n        uint powerBonus = 100;\n        if (user.lastPoweredBlock >= block.number) {\n            powerBonus += proxy.getNFTPowerBonus();\n        }\n        powerBonus += proxy.bonus(msg.sender);\n        user.power = user.amount.mul(powerBonus).div(100);\n        pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n    }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
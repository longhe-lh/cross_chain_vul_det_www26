{"project": "OpenSwap", "functions": ["function removeLiquidity(address provider, bool direction, uint256 unstake, uint256 afterIndex, uint256 amountOut, uint256 reserveOut, uint256 expire, bool enable) external override lock {\n require(msg.sender == oracleLiquidityProvider || msg.sender == provider, \"Not from router or owner\");\n require(expire > block.timestamp, \"Already expired\");\n uint256 index = providerOfferIndex[provider];\n require(index > 0, \"Provider liquidity not found\");\n Offer storage offer = offers[direction][index];\n uint256 newAmount = offer.amount.sub(amountOut);\n function minLotSize(...) {...}\nrequire(newAmount == 0 || newAmount >= minLotSize(direction), \"Minium lot size not met\");\n uint256 staked = offer.staked.sub(unstake);\n offer.enabled = enable;\n if (amountOut > 0)\n offer.amount = newAmount;\n if (unstake > 0)\n offer.staked = staked;\n offer.reserve = offer.reserve.sub(reserveOut);\n offer.expire = expire;\n if (enable) {\n if (offer.isActive) {\n if (unstake > 0 && (index != afterIndex || offers[direction][offer.next].staked >= staked)) {\n _halfDequeue(direction, index);\n _enqueue(direction, index, staked, afterIndex, newAmount, expire);\n }\n } else {\n _enqueue(direction, index, staked, afterIndex, newAmount, expire);\n }\n } else {\n if (offer.isActive)\n _dequeue(direction, index);\n }\n if (unstake > 0) {\n stakeBalance = stakeBalance.sub(unstake);\n _safeTransfer(govToken, msg.sender, unstake); \n }\n if (amountOut > 0 || reserveOut > 0)\n _safeTransfer(direction ? token1 : token0, msg.sender, amountOut.add(reserveOut)); \n emit RemoveLiquidity(provider, direction, unstake, amountOut, reserveOut, offer.staked, offer.amount, offer.reserve, expire, enable);\n _sync();\n }", "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\ttokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}"], "label": "Yes", "detail": "The getAssetFromTokenAddress function in THORChain's Ethereum scanner fails to properly handle ERC20 tokens with 'ETH' symbol. When processing deposits, it defaults to native ETH asset type if the token metadata isn't found in local storage. An attacker can deploy a malicious ERC20 token with 'ETH' symbol, causing the bridge to incorrectly identify the token as native Ethereum. This allows fake tokens to be treated as genuine ETH in cross-chain transactions."}
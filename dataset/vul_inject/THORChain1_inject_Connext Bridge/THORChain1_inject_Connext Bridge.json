{"project": "Connext Bridge", "functions": ["function swapToLocalAssetIfNeeded(\n bytes32 _key,\n address _asset,\n address _local,\n uint256 _amount,\n uint256 _slippage\n ) internal returns (uint256) {\n \n if (_amount == 0) {\n return 0;\n }\n \n if (_local == _asset) {\n return _amount;\n }\n \n TokenConfig storage config = getConfig(_key);\n \n (uint256 out, ) = _swapAsset(\n _key,\n _asset,\n _local,\n _amount,\n calculateSlippageBoundary(\n config.adoptedDecimals,\n config.representationDecimals,\n _amount,\n _slippage\n )\n );\n return out;\n }", "function calculateSlippageBoundary(\n uint8 _in,\n uint8 _out,\n uint256 _amountIn,\n uint256 _slippage\n ) internal pure returns (uint256) {\n if (_amountIn == 0) {\n return 0;\n }\n \n uint256 min = (_amountIn *\n (Constants.BPS_FEE_DENOMINATOR - _slippage)) /\n Constants.BPS_FEE_DENOMINATOR;\n return normalizeDecimals(_in, _out, min);\n }", "function normalizeDecimals(\n uint8 _in,\n uint8 _out,\n uint256 _amount\n ) internal pure returns (uint256) {\n if (_in == _out) {\n return _amount;\n }\n \n uint256 normalized;\n if (_in < _out) {\n normalized = _amount * (10 ** (_out - _in));\n } else {\n normalized = _amount / (10 ** (_in - _out));\n }\n return normalized;\n }", "function swapFromLocalAssetIfNeeded(\n bytes32 _key,\n address _asset,\n uint256 _amount,\n uint256 _slippage,\n uint256 _normalizedIn\n ) internal returns (uint256, address) {\n \n TokenConfig storage config = getConfig(_key);\n address adopted = config.adopted;\n \n if (adopted == _asset) {\n return (_amount, adopted);\n }\n \n if (_amount == 0) {\n return (_amount, adopted);\n }\n \n return\n _swapAsset(\n _key,\n _asset,\n adopted,\n _amount,\n \n \n \n calculateSlippageBoundary(\n Constants.DEFAULT_NORMALIZED_DECIMALS,\n config.adoptedDecimals,\n _normalizedIn,\n _slippage\n )\n );\n }", "function calculateSlippageBoundary(\n uint8 _in,\n uint8 _out,\n uint256 _amountIn,\n uint256 _slippage\n ) internal pure returns (uint256) {\n if (_amountIn == 0) {\n return 0;\n }\n \n uint256 min = (_amountIn *\n (Constants.BPS_FEE_DENOMINATOR - _slippage)) /\n Constants.BPS_FEE_DENOMINATOR;\n return normalizeDecimals(_in, _out, min);\n }", "function normalizeDecimals(\n uint8 _in,\n uint8 _out,\n uint256 _amount\n ) internal pure returns (uint256) {\n if (_in == _out) {\n return _amount;\n }\n \n uint256 normalized;\n if (_in < _out) {\n normalized = _amount * (10 ** (_out - _in));\n } else {\n normalized = _amount / (10 ** (_in - _out));\n }\n return normalized;\n }", "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\ttokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}"], "label": "Yes", "detail": "The getAssetFromTokenAddress function in THORChain's Ethereum scanner fails to properly handle ERC20 tokens with 'ETH' symbol. When processing deposits, it defaults to native ETH asset type if the token metadata isn't found in local storage. An attacker can deploy a malicious ERC20 token with 'ETH' symbol, causing the bridge to incorrectly identify the token as native Ethereum. This allows fake tokens to be treated as genuine ETH in cross-chain transactions."}
{"project": "Bridge_15", "functions": ["function proposeTransaction(\n address sender,\n address receiver,\n uint amount,\n address[] memory potentialSigners,\n address proposer,\n bytes calldata signature\n ) public {\n \n bytes32 message = prefixed(\n keccak256(abi.encodePacked(sender, receiver, amount))\n );\n require(\n recoverSigner(message, signature) == proposer,\n \"Signature Error: Not Signed by the Proposer\"\n );\n \n require(\n potentialSigners.length == 3,\n \"Three potential signers are required\"\n );\n \n transactions[message] = Transaction(\n potentialSigners,\n new address[](0),\n sender,\n receiver,\n amount\n );\n \n transactions[message].signers.push(msg.sender);\n \n emit Proposed(sender, receiver, amount, proposer, signature);\n }", "function prefixed(bytes32 hash) internal pure returns (bytes32) {\n return\n keccak256(\n abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n );\n }", "function recoverSigner(\n bytes32 message,\n bytes memory sig\n ) internal pure returns (address) {\n uint8 v;\n bytes32 r;\n bytes32 s;\n function splitSignature(...) {...}\n(v, r, s) = splitSignature(sig);\n return ecrecover(message, v, r, s);\n }", "function splitSignature(\n bytes memory sig\n ) internal pure returns (uint8, bytes32, bytes32) {\n require(sig.length == 65);\n bytes32 r;\n bytes32 s;\n uint8 v;\n assembly {\n \n r := mload(add(sig, 32))\n \n s := mload(add(sig, 64))\n \n v := byte(0, mload(add(sig, 96)))\n }\n return (v, r, s);\n }", "function confirmTransaction(\n address sender,\n address receiver,\n uint amount,\n address signer,\n bytes memory signature\n ) public {\n \n \n bytes32 message = prefixed(\n keccak256(abi.encodePacked(sender, receiver, amount))\n );\n require(\n recoverSigner(message, signature) == signer,\n \"Signature Error: Not Signed by the Sender\"\n );\n \n \n require(\n addressExists(transactions[message].potentialSigners, signer),\n \"Provided Address is not a potential signer for this transaction\"\n );\n \n require(\n !addressExists(transactions[message].signers, signer),\n \"Sender has already signed this transaction\"\n );\n \n transactions[message].signers.push(signer);\n \n emit Confirmed(sender, receiver, amount, signer, signature);\n if (transactions[message].signers.length >= 2) {\n Transaction memory trx = transactions[message];\n burn(trx.sender, trx.receiver, trx.amount);\n }\n }", "function addressExists(\n address[] memory _arr,\n address _address\n ) internal view returns (bool) {\n for (uint256 i = 0; i < _arr.length; i++) {\n if (_arr[i] == _address) {\n return true;\n }\n }\n return false;\n }", "function prefixed(bytes32 hash) internal pure returns (bytes32) {\n return\n keccak256(\n abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n );\n }", "function recoverSigner(\n bytes32 message,\n bytes memory sig\n ) internal pure returns (address) {\n uint8 v;\n bytes32 r;\n bytes32 s;\n function splitSignature(...) {...}\n(v, r, s) = splitSignature(sig);\n return ecrecover(message, v, r, s);\n }", "function splitSignature(\n bytes memory sig\n ) internal pure returns (uint8, bytes32, bytes32) {\n require(sig.length == 65);\n bytes32 r;\n bytes32 s;\n uint8 v;\n assembly {\n \n r := mload(add(sig, 32))\n \n s := mload(add(sig, 64))\n \n v := byte(0, mload(add(sig, 96)))\n }\n return (v, r, s);\n }", "function burn(address from, address to, uint256 amount) internal {\n function burn(...) {...}\ntoken.burn(from, amount);\n emit Transfer(from, to, amount, Step.Burn);\n }", "function mint(address from, address to, uint256 amount) external {\n function mint(...) {...}\ntoken.mint(to, amount);\n \n emit Transfer(from, to, amount, Step.Mint);\n }", "function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n        _chargeFee();\n        require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n        uint N = signatures.length;\n        require(N >= MappingTokenFactory(factory).getConfig(_minSignatures_), 'too few signatures');\n        for(uint i=0; i<N; i++) {\n            for(uint j=0; j<i; j++)\n                require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n            bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n            bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _DOMAIN_SEPARATOR, structHash));\n            address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n            require(signatory != address(0), \"invalid signature\");\n            require(signatory == signatures[i].signatory, \"unauthorized\");\n            _decreaseAuthQuota(signatures[i].signatory, volume);\n            emit Authorize(fromChainId, to, nonce, volume, signatory);\n        }\n        received[fromChainId][to][nonce] = volume;\n        _receive(to, volume);\n        emit Receive(fromChainId, to, nonce, volume);\n    }"], "label": "Yes", "detail": "The receive function of the Chainswap contract failed to properly validate the signatory field of incoming signatures. By supplying a forged signatory, an attacker was able to bypass the authorization process. Due to the absence of mapping key validation in Solidity, the system calculated an unreasonably high quota for the forged signatory, enabling the attacker to mint and withdraw unauthorized funds. The root cause is improper validation of mapping-based access control. Additionally, the platform had reduced the required number of signatures to 1 prior to the attack, making exploitation easier."}
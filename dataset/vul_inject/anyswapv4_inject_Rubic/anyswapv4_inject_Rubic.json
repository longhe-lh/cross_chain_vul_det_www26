{"project": "Rubic", "functions": ["function crossChainWithSwap(\n BaseCrossChainParams calldata _params,\n string calldata _providerName\n )\n external\n payable\n nonReentrant\n whenNotPaused\n eventEmitter(_params, _providerName)\n {\n IntegratorFeeInfo memory _info = integratorToFeeInfo[\n _params.integrator\n ];\n IERC20(_params.srcInputToken).transferFrom(\n msg.sender,\n address(this),\n _params.srcInputAmount\n );\n accrueFixedCryptoFee(_params.integrator, _info);\n uint256 _amountIn = accrueTokenFees(\n _params.integrator,\n _info,\n _params.srcInputAmount,\n 0,\n _params.srcInputToken\n );\n SmartApprove.smartApprove(\n _params.srcInputToken,\n _amountIn,\n _params.router\n );\n ITestDEX(_params.router).swap(\n _params.srcInputToken,\n _amountIn,\n _params.dstOutputToken\n );\n }", "function accrueFixedCryptoFee(\n address _integrator,\n IntegratorFeeInfo memory _info\n ) internal returns (uint256) {\n uint256 _fixedCryptoFee;\n uint256 _RubicPart;\n if (_info.isIntegrator) {\n _fixedCryptoFee = uint256(_info.fixedFeeAmount);\n if (_fixedCryptoFee > 0) {\n _RubicPart =\n (_fixedCryptoFee *\n _info.RubicFixedCryptoShare) /\n DENOMINATOR;\n availableIntegratorCryptoFee[_integrator] +=\n _fixedCryptoFee -\n _RubicPart;\n }\n } else {\n _fixedCryptoFee = fixedCryptoFee;\n _RubicPart = _fixedCryptoFee;\n }\n availableRubicCryptoFee += _RubicPart;\n emit FixedCryptoFee(\n _RubicPart,\n _fixedCryptoFee - _RubicPart,\n _integrator\n );\n \n return (msg.value - _fixedCryptoFee);\n }", "function accrueTokenFees(\n address _integrator,\n IntegratorFeeInfo memory _info,\n uint256 _amountWithFee,\n uint256 _initBlockchainNum,\n address _token\n ) internal returns (uint256) {\n (uint256 _totalFees, uint256 _RubicFee) = _calculateFee(\n _info,\n _amountWithFee,\n _initBlockchainNum\n );\n if (_integrator != address(0)) {\n availableIntegratorTokenFee[_token][_integrator] +=\n _totalFees -\n _RubicFee;\n }\n availableRubicTokenFee[_token] += _RubicFee;\n emit TokenFee(\n _RubicFee,\n _totalFees - _RubicFee,\n _integrator,\n _token\n );\n return _amountWithFee - _totalFees;\n }", "function smartApprove(\n address _tokenIn,\n uint256 _amount,\n address _to\n ) internal {\n IERC20Upgradeable tokenIn = IERC20Upgradeable(_tokenIn);\n uint256 _allowance = tokenIn.allowance(\n address(this),\n _to\n );\n if (_allowance < _amount) {\n if (_allowance == 0) {\n tokenIn.safeApprove(_to, type(uint256).max);\n } else {\n try\n tokenIn.approve(_to, type(uint256).max)\n returns (bool res) {\n if (!res) {\n revert ApproveFailed();\n }\n } catch {\n tokenIn.safeApprove(_to, 0);\n tokenIn.safeApprove(_to, type(uint256).max);\n }\n }\n }\n }", "function swap(\n address _fromToken,\n uint256 _inputAmount,\n address _toToken\n ) external override {\n IERC20(_fromToken).transferFrom(\n msg.sender,\n address(this),\n _inputAmount\n );\n IERC20(_toToken).transfer(\n msg.sender,\n _inputAmount * price\n );\n }", "function changeTxStatus(\n bytes32 _id,\n SwapStatus _statusCode\n ) external onlyManagerOrAdmin {\n if (_statusCode == SwapStatus.Null) {\n revert CantSetToNull();\n }\n SwapStatus _status = processedTransactions[_id];\n if (\n _status == SwapStatus.Succeeded ||\n _status == SwapStatus.Fallback\n ) {\n revert Unchangeable();\n }\n processedTransactions[_id] = _statusCode;\n }", "function anySwapOutUnderlyingWithPermit(\n        address from,\n        address token,\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external {\n        address _underlying = AnyswapV1ERC20(token).underlying();\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n        AnyswapV1ERC20(token).depositVault(amount, from);\n        _anySwapOut(from, token, to, amount, toChainID);\n    }"], "label": "Yes", "detail": "On February 15, 2023, the AnyswapV4Router contract of Multichain was exploited via a frontrunning MEV bot. The attacker used a crafted transaction to call the anySwapOutUnderlyingWithPermit function before a legitimate user's transaction could execute. The function assumed the underlying token (WETH) supported the ERC-2612 permit interface, but WETH lacked the permit method. Consequently, the fallback deposit function was triggered instead of validating the signature. The attacker then successfully used safeTransferFrom to transfer the WETH to their own address without proper authorization, gaining approximately 87 ETH (~$130,000)."}
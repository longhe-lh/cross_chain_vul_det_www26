{"project": "Syndicate Bridge", "functions": ["function enter(\n Token memory token,\n address from,\n address to,\n uint256 amount\n ) internal returns (Token memory) {\n require(token.exist, \"RT: NOT_LISTED\");\n if (token.issueType == IssueType.MINTABLE) {\n IBridgeToken(token.addr).burn(from, amount);\n } else if (token.issueType == IssueType.DEFAULT) {\n IERC20(token.addr).safeTransferFrom(from, to, amount);\n } else {\n assert(false);\n }\n return token;\n }", "function burn(address _from, uint256 _amnt) external override onlyOwner {\n _burn(_from, _amnt);\n }", "function exit(\n Token memory token,\n address from,\n address to,\n uint256 amount\n ) internal returns (Token memory) {\n require(token.exist, \"RT: NOT_LISTED\");\n if (token.addr == address(0)) {\n unsafeTransfer(from, to, amount);\n } else if (token.issueType == IssueType.MINTABLE) {\n IBridgeToken(token.addr).mint(to, amount);\n } else if (token.issueType == IssueType.DEFAULT) {\n IERC20(token.addr).safeTransfer(to, amount);\n } else {\n assert(false);\n }\n return token;\n }", "function verify(\n bytes32 commitment,\n uint256 chainId,\n bytes[] calldata signatures\n ) external view override returns (bool) {\n uint8 _required = getCosignCount(chainId);\n if (_required > signatures.length) {\n return false;\n }\n address[] memory cached = new address[](signatures.length);\n uint8 signersMatch;\n for (uint8 i = 0; i < signatures.length; i++) {\n address signer = recover(commitment, signatures[i]);\n Cosigner memory cosigner = _cosigners[signer];\n if (\n cosigner.active &&\n cosigner.chainId == chainId &&\n !_inCache(cached, signer)\n ) {\n signersMatch++;\n cached[i] = signer;\n if (signersMatch == _required) return true;\n }\n }\n return false;\n }", "function mint(address _to, uint256 _amnt) external override onlyOwner {\n _mint(_to, _amnt);\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didnâ€™t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
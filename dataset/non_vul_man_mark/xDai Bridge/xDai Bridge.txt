Folder Structure
--------------------------------------------------
contracts/
    AAVEInterestERC20.sol
    Address.sol
    BaseRelayer.sol
    BasicAMBMediator.sol
    BasicNFTOmnibridge.sol
    BridgedTokensRegistry.sol
    BridgeOperationsStorage.sol
    BridgeValidators.sol
    Bytes.sol
    Context.sol
    Distribution.sol
    EnumerableMap.sol
    EnumerableSet.sol
    ERC1155.sol
    ERC1155BridgeToken.sol
    ERC1155Relayer.sol
    ERC1155TokenProxy.sol
    ERC165.sol
    ERC677MultiBridgeToken.sol
    ERC721.sol
    ERC721BridgeToken.sol
    ERC721Relayer.sol
    ERC721TokenProxy.sol
    EternalStorage.sol
    EternalStorageProxy.sol
    FailedMessagesProcessor.sol
    ForeignAMB.sol
    ForeignAMBErc677ToErc677.sol
    ForeignBridge.sol
    ForeignBridgeErcToNative.sol
    ForeignMultiAMBErc20ToErc677.sol
    ForeignNFTOmnibridge.sol
    ForeignOmnibridge.sol
    GasLimitManager.sol
    IAMB.sol
    IBurnableMintableERC1155Token.sol
    IBurnableMintableERC721Token.sol
    IERC1155.sol
    IERC1155MetadataURI.sol
    IERC1155Receiver.sol
    IERC1155TokenReceiver.sol
    IERC165.sol
    IERC721.sol
    IERC721Enumerable.sol
    IERC721Metadata.sol
    IERC721Receiver.sol
    Initializable.sol
    IOwnable.sol
    IUpgradeabilityOwnerStorage.sol
    MetadataReader.sol
    MultipleDistribution.sol
    MultiSigWallet.sol
    NativeTokensRegistry.sol
    NFTBridgeLimits.sol
    NFTMediatorBalanceStorage.sol
    NFTOmnibridgeInfo.sol
    Ownable.sol
    Proxy.sol
    ReentrancyGuard.sol
    SafeMath.sol
    Strings.sol
    TokenImageStorage.sol
    Upgradeable.sol
    VersionableBridge.sol
    WETHOmnibridgeRouter.sol
    XDaiForeignBridge.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\AAVEInterestERC20.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-10-15

*/



// File: @openzeppelin/contracts/token/ERC20/IERC20.sol





pragma solidity ^0.7.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: @openzeppelin/contracts/math/SafeMath.sol





pragma solidity ^0.7.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: contracts/interfaces/IAToken.sol



pragma solidity 0.7.5;





interface IAToken is IERC20 {

    // solhint-disable-next-line func-name-mixedcase

    function UNDERLYING_ASSET_ADDRESS() external returns (address);

}



// File: contracts/interfaces/IOwnable.sol



pragma solidity 0.7.5;



interface IOwnable {

    function owner() external view returns (address);

}



// File: contracts/interfaces/ILendingPool.sol



pragma solidity 0.7.5;





interface ILendingPool {

    function deposit(

        address asset,

        uint256 amount,

        address onBehalfOf,

        uint16 referralCode

    ) external;



    function withdraw(

        address asset,

        uint256 amount,

        address to

    ) external returns (uint256);



    function borrow(

        address asset,

        uint256 amount,

        uint256 interestRateMode,

        uint16 referralCode,

        address onBehalfOf

    ) external returns (uint256);



    function repay(

        address asset,

        uint256 amount,

        uint256 rateMode,

        address onBehalfOf

    ) external returns (uint256);



    // workaround to omit usage of abicoder v2

    // see real signature at https://github.com/aave/protocol-v2/blob/master/contracts/protocol/libraries/types/DataTypes.sol

    function getReserveData(address asset) external returns (address[12] memory);

}



// File: contracts/interfaces/IStakedTokenIncentivesController.sol



pragma solidity 0.7.5;



interface IStakedTokenIncentivesController {

    function claimRewards(

        address[] calldata assets,

        uint256 amount,

        address to

    ) external;



    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);



    function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;



    function setDistributionEnd(uint256 distributionEnd) external;



    function initialize(address addressesProvider) external;

}



// File: contracts/interfaces/ILegacyERC20.sol



pragma solidity 0.7.5;



interface ILegacyERC20 {

    function approve(address spender, uint256 amount) external; // returns (bool);

}



// File: @openzeppelin/contracts/utils/Address.sol





pragma solidity ^0.7.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: contracts/upgradeable_contracts/modules/OwnableModule.sol



pragma solidity 0.7.5;





/**

 * @title OwnableModule

 * @dev Common functionality for multi-token extension non-upgradeable module.

 */

contract OwnableModule {

    address public owner;



    /**

     * @dev Initializes this contract.

     * @param _owner address of the owner that is allowed to perform additional actions on the particular module.

     */

    constructor(address _owner) {

        owner = _owner;

    }



    /**

     * @dev Throws if sender is not the owner of this contract.

     */

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    /**

     * @dev Changes the owner of this contract.

     * @param _newOwner address of the new owner.

     */

    function transferOwnership(address _newOwner) external onlyOwner {

        owner = _newOwner;

    }

}



// File: contracts/upgradeable_contracts/modules/MediatorOwnableModule.sol



pragma solidity 0.7.5;







/**

 * @title MediatorOwnableModule

 * @dev Common functionality for non-upgradeable Omnibridge extension module.

 */

contract MediatorOwnableModule is OwnableModule {

    address public mediator;



    /**

     * @dev Initializes this contract.

     * @param _mediator address of the deployed Omnibridge extension for which this module is deployed.

     * @param _owner address of the owner that is allowed to perform additional actions on the particular module.

     */

    constructor(address _mediator, address _owner) OwnableModule(_owner) {

        require(Address.isContract(_mediator));

        mediator = _mediator;

    }



    /**

     * @dev Throws if sender is not the Omnibridge extension.

     */

    modifier onlyMediator {

        require(msg.sender == mediator);

        _;

    }

}



// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol





pragma solidity ^0.7.0;









/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



// File: contracts/interfaces/IInterestReceiver.sol



pragma solidity 0.7.5;



interface IInterestReceiver {

    function onInterestReceived(address _token) external;

}



// File: contracts/interfaces/IInterestImplementation.sol



pragma solidity 0.7.5;





interface IInterestImplementation {

    event InterestEnabled(address indexed token, address xToken);

    event InterestDustUpdated(address indexed token, uint96 dust);

    event InterestReceiverUpdated(address indexed token, address receiver);

    event MinInterestPaidUpdated(address indexed token, uint256 amount);

    event PaidInterest(address indexed token, address to, uint256 value);

    event ForceDisable(address indexed token, uint256 tokensAmount, uint256 xTokensAmount, uint256 investedAmount);



    function isInterestSupported(address _token) external view returns (bool);



    function invest(address _token, uint256 _amount) external;



    function withdraw(address _token, uint256 _amount) external;



    function investedAmount(address _token) external view returns (uint256);

}



// File: contracts/upgradeable_contracts/modules/interest/BaseInterestERC20.sol



pragma solidity 0.7.5;













/**

 * @title BaseInterestERC20

 * @dev This contract contains common logic for investing ERC20 tokens into different interest-earning protocols.

 */

abstract contract BaseInterestERC20 is IInterestImplementation {

    using SafeERC20 for IERC20;



    /**

     * @dev Ensures that caller is an EOA.

     * Functions with such modifier cannot be called from other contract (as well as from GSN-like approaches)

     */

    modifier onlyEOA {

        // solhint-disable-next-line avoid-tx-origin

        require(msg.sender == tx.origin);

        /* solcov ignore next */

        _;

    }



    /**

     * @dev Internal function transferring interest tokens to the interest receiver.

     * Calls a callback on the receiver, interest receiver is a contract.

     * @param _receiver address of the tokens receiver.

     * @param _token address of the token contract to send.

     * @param _amount amount of tokens to transfer.

     */

    function _transferInterest(

        address _receiver,

        address _token,

        uint256 _amount

    ) internal {

        require(_receiver != address(0));



        IERC20(_token).safeTransfer(_receiver, _amount);



        if (Address.isContract(_receiver)) {

            IInterestReceiver(_receiver).onInterestReceived(_token);

        }



        emit PaidInterest(_token, _receiver, _amount);

    }

}



// File: contracts/upgradeable_contracts/modules/interest/AAVEInterestERC20.sol



pragma solidity 0.7.5;





















/**

 * @title AAVEInterestERC20

 * @dev This contract contains token-specific logic for investing ERC20 tokens into AAVE protocol.

 */

contract AAVEInterestERC20 is BaseInterestERC20, MediatorOwnableModule {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;

    using SafeERC20 for IAToken;



    struct InterestParams {

        IAToken aToken;

        uint96 dust;

        uint256 investedAmount;

        address interestReceiver;

        uint256 minInterestPaid;

    }



    mapping(address => InterestParams) public interestParams;

    uint256 public minAavePaid;

    address public aaveReceiver;



    constructor(

        address _omnibridge,

        address _owner,

        uint256 _minAavePaid,

        address _aaveReceiver

    ) MediatorOwnableModule(_omnibridge, _owner) {

        minAavePaid = _minAavePaid;

        aaveReceiver = _aaveReceiver;

    }



    /**

     * @dev Tells the module interface version that this contract supports.

     * @return major value of the version

     * @return minor value of the version

     * @return patch value of the version

     */

    function getModuleInterfacesVersion()

        external

        pure

        returns (

            uint64 major,

            uint64 minor,

            uint64 patch

        )

    {

        return (1, 0, 0);

    }



    /**

     * @dev Tells the address of the LendingPool contract in the Ethereum Mainnet.

     */

    function lendingPool() public pure virtual returns (ILendingPool) {

        return ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);

    }



    /**

     * @dev Tells the address of the StakedTokenIncentivesController contract in the Ethereum Mainnet.

     */

    function incentivesController() public pure virtual returns (IStakedTokenIncentivesController) {

        return IStakedTokenIncentivesController(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);

    }



    /**

     * @dev Tells the address of the StkAAVE token contract in the Ethereum Mainnet.

     */

    function stkAAVEToken() public pure virtual returns (address) {

        return 0x4da27a545c0c5B758a6BA100e3a049001de870f5;

    }



    /**

     * @dev Enables support for interest earning through a specific aToken.

     * @param _token address of the token contract for which to enable interest.

     * @param _dust small amount of underlying tokens that cannot be paid as an interest. Accounts for possible truncation errors.

     * @param _interestReceiver address of the interest receiver for underlying token.

     * @param _minInterestPaid min amount of underlying tokens to be paid as an interest.

     */

    function enableInterestToken(

        address _token,

        uint96 _dust,

        address _interestReceiver,

        uint256 _minInterestPaid

    ) external onlyOwner {

        IAToken aToken = IAToken(lendingPool().getReserveData(_token)[7]);

        require(aToken.UNDERLYING_ASSET_ADDRESS() == _token);



        // disallow reinitialization of tokens that were already initialized and invested

        require(interestParams[_token].investedAmount == 0);



        interestParams[_token] = InterestParams(aToken, _dust, 0, _interestReceiver, _minInterestPaid);



        // SafeERC20.safeApprove does not work here in case of possible interest reinitialization,

        // since it does not allow positive->positive allowance change. However, it would be safe to make such change here.

        ILegacyERC20(_token).approve(address(lendingPool()), uint256(-1));



        emit InterestEnabled(_token, address(aToken));

        emit InterestDustUpdated(_token, _dust);

        emit InterestReceiverUpdated(_token, _interestReceiver);

        emit MinInterestPaidUpdated(_token, _minInterestPaid);

    }



    /**

     * @dev Tells the current amount of underlying tokens that was invested into the AAVE protocol.

     * @param _token address of the underlying token.

     * @return currently invested value.

     */

    function investedAmount(address _token) external view override returns (uint256) {

        return interestParams[_token].investedAmount;

    }



    /**

     * @dev Tells if interest earning is supported for the specific underlying token contract.

     * @param _token address of the token contract.

     * @return true, if interest earning is supported for the given token.

     */

    function isInterestSupported(address _token) external view override returns (bool) {

        return address(interestParams[_token].aToken) != address(0);

    }



    /**

     * @dev Invests the given amount of tokens to the AAVE protocol.

     * Only Omnibridge contract is allowed to call this method.

     * Converts _amount of TOKENs into aTOKENs.

     * @param _token address of the invested token contract.

     * @param _amount amount of tokens to invest.

     */

    function invest(address _token, uint256 _amount) external override onlyMediator {

        InterestParams storage params = interestParams[_token];

        params.investedAmount = params.investedAmount.add(_amount);

        lendingPool().deposit(_token, _amount, address(this), 0);

    }



    /**

     * @dev Withdraws at least min(_amount, investedAmount) of tokens from the AAVE protocol.

     * Only Omnibridge contract is allowed to call this method.

     * Converts aTOKENs into _amount of TOKENs.

     * @param _token address of the invested token contract.

     * @param _amount minimal amount of tokens to withdraw.

     */

    function withdraw(address _token, uint256 _amount) external override onlyMediator {

        InterestParams storage params = interestParams[_token];

        uint256 invested = params.investedAmount;

        uint256 redeemed = _safeWithdraw(_token, _amount > invested ? invested : _amount);

        params.investedAmount = redeemed > invested ? 0 : invested - redeemed;

        IERC20(_token).safeTransfer(mediator, redeemed);

    }



    /**

     * @dev Tells the current accumulated interest on the invested tokens, that can be withdrawn and payed to the interest receiver.

     * @param _token address of the invested token contract.

     * @return amount of accumulated interest.

     */

    function interestAmount(address _token) public view returns (uint256) {

        InterestParams storage params = interestParams[_token];

        (IAToken aToken, uint96 dust) = (params.aToken, params.dust);

        uint256 balance = aToken.balanceOf(address(this));

        // small portion of tokens are reserved for possible truncation/round errors

        uint256 reserved = params.investedAmount.add(dust);

        return balance > reserved ? balance - reserved : 0;

    }



    /**

     * @dev Pays collected interest for the underlying token.

     * Anyone can call this function.

     * Earned interest is withdrawn and transferred to the specified interest receiver account.

     * @param _token address of the invested token contract in which interest should be paid.

     */

    function payInterest(address _token) external onlyEOA {

        InterestParams storage params = interestParams[_token];

        uint256 interest = interestAmount(_token);

        require(interest >= params.minInterestPaid);

        _transferInterest(params.interestReceiver, address(_token), _safeWithdraw(_token, interest));

    }



    /**

     * @dev Tells the amount of earned stkAAVE tokens for supplying assets into the protocol that can be withdrawn.

     * Intended to be called via eth_call to obtain the current accumulated value for stkAAVE.

     * @param _assets aTokens addresses to claim stkAAVE for.

     * @return amount of accumulated stkAAVE tokens across given markets.

     */

    function aaveAmount(address[] calldata _assets) public view returns (uint256) {

        return incentivesController().getRewardsBalance(_assets, address(this));

    }



    /**

     * @dev Claims stkAAVE token received by supplying underlying tokens and transfers it to the associated AAVE receiver.

     * @param _assets aTokens addresses to claim stkAAVE for.

     */

    function claimAaveAndPay(address[] calldata _assets) external onlyEOA {

        uint256 balance = aaveAmount(_assets);

        require(balance >= minAavePaid);



        incentivesController().claimRewards(_assets, balance, address(this));



        _transferInterest(aaveReceiver, stkAAVEToken(), balance);

    }



    /**

     * @dev Last-resort function for returning assets to the Omnibridge contract in case of some failures in the logic.

     * Disables this contract and transfers locked tokens back to the mediator.

     * Only owner is allowed to call this method.

     * @param _token address of the invested token contract that should be disabled.

     */

    function forceDisable(address _token) external onlyOwner {

        InterestParams storage params = interestParams[_token];

        IAToken aToken = params.aToken;



        uint256 aTokenBalance = 0;

        // try to redeem all aTokens

        // it is safe to specify uint256(-1) as max amount of redeemed tokens

        // since the withdraw method of the pool contract will return the entire balance

        try lendingPool().withdraw(_token, uint256(-1), mediator) {} catch {

            aTokenBalance = aToken.balanceOf(address(this));

            aToken.safeTransfer(mediator, aTokenBalance);

        }



        uint256 balance = IERC20(_token).balanceOf(address(this));

        IERC20(_token).safeTransfer(mediator, balance);

        IERC20(_token).safeApprove(address(lendingPool()), 0);



        emit ForceDisable(_token, balance, aTokenBalance, params.investedAmount);



        delete interestParams[_token];

    }



    /**

     * @dev Updates dust parameter for the particular token.

     * Only owner is allowed to call this method.

     * @param _token address of the invested token contract.

     * @param _dust new amount of underlying tokens that cannot be paid as an interest. Accounts for possible truncation errors.

     */

    function setDust(address _token, uint96 _dust) external onlyOwner {

        interestParams[_token].dust = _dust;

        emit InterestDustUpdated(_token, _dust);

    }



    /**

     * @dev Updates address of the interest receiver. Can be any address, EOA or contract.

     * Set to 0x00..00 to disable interest transfers.

     * Only owner is allowed to call this method.

     * @param _token address of the invested token contract.

     * @param _receiver address of the interest receiver.

     */

    function setInterestReceiver(address _token, address _receiver) external onlyOwner {

        interestParams[_token].interestReceiver = _receiver;

        emit InterestReceiverUpdated(_token, _receiver);

    }



    /**

     * @dev Updates min interest amount that can be transferred in single call.

     * Only owner is allowed to call this method.

     * @param _token address of the invested token contract.

     * @param _minInterestPaid new amount of TOKENS and can be transferred to the interest receiver in single operation.

     */

    function setMinInterestPaid(address _token, uint256 _minInterestPaid) external onlyOwner {

        interestParams[_token].minInterestPaid = _minInterestPaid;

        emit MinInterestPaidUpdated(_token, _minInterestPaid);

    }



    /**

     * @dev Updates min stkAAVE amount that can be transferred in single call.

     * Only owner is allowed to call this method.

     * @param _minAavePaid new amount of stkAAVE and can be transferred to the interest receiver in single operation.

     */

    function setMinAavePaid(uint256 _minAavePaid) external onlyOwner {

        minAavePaid = _minAavePaid;

        emit MinInterestPaidUpdated(address(stkAAVEToken()), _minAavePaid);

    }



    /**

     * @dev Updates address of the accumulated stkAAVE receiver. Can be any address, EOA or contract.

     * Set to 0x00..00 to disable stkAAVE claims and transfers.

     * Only owner is allowed to call this method.

     * @param _receiver address of the interest receiver.

     */

    function setAaveReceiver(address _receiver) external onlyOwner {

        aaveReceiver = _receiver;

        emit InterestReceiverUpdated(address(stkAAVEToken()), _receiver);

    }



    /**

     * @dev Internal function for securely withdrawing assets from the underlying protocol.

     * @param _token address of the invested token contract.

     * @param _amount minimal amount of underlying tokens to withdraw from AAVE.

     * @return amount of redeemed tokens, at least as much as was requested.

     */

    function _safeWithdraw(address _token, uint256 _amount) private returns (uint256) {

        uint256 balance = IERC20(_token).balanceOf(address(this));



        lendingPool().withdraw(_token, _amount, address(this));



        uint256 redeemed = IERC20(_token).balanceOf(address(this)) - balance;



        require(redeemed >= _amount);



        return redeemed;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: value }(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.staticcall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.delegatecall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\BaseRelayer.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../../libraries/Bytes.sol";



/**

 * @title BaseRelayer

 * @dev Basic functionality for relaying different NFT tokens to the other side of the bridge.

 */

abstract contract BaseRelayer {

    /**

     * @dev Helper function for alternative receiver feature. Chooses the actual receiver out of sender and passed data.

     * @param _from address of the token sender.

     * @param _data passed data in the transfer message.

     * @return recipient address of the receiver on the other side.

     */

    function _chooseReceiver(address _from, bytes memory _data) internal pure returns (address recipient) {

        recipient = _from;

        if (_data.length > 0) {

            require(_data.length == 20);

            recipient = Bytes.bytesToAddress(_data);

        }

    }



    /**

     * @dev Wraps a given uint256 value into an array with a single element.

     * @param _value argument to wrap.

     * @return wrapper array.

     */

    function _singletonArray(uint256 _value) internal pure returns (uint256[] memory) {

        uint256[] memory array = new uint256[](1);

        array[0] = _value;

        return array;

    }



    function bridgeSpecificActionsOnTokenTransfer(

        address _token,

        address _from,

        address _receiver,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) internal virtual;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\BasicAMBMediator.sol
File type: .sol
pragma solidity 0.7.5;



import "./Ownable.sol";

import "../interfaces/IAMB.sol";

import "@openzeppelin/contracts/utils/Address.sol";



/**

 * @title BasicAMBMediator

 * @dev Basic storage and methods needed by mediators to interact with AMB bridge.

 */

abstract contract BasicAMBMediator is Ownable {

    bytes32 internal constant BRIDGE_CONTRACT = 0x811bbb11e8899da471f0e69a3ed55090fc90215227fc5fb1cb0d6e962ea7b74f; // keccak256(abi.encodePacked("bridgeContract"))

    bytes32 internal constant MEDIATOR_CONTRACT = 0x98aa806e31e94a687a31c65769cb99670064dd7f5a87526da075c5fb4eab9880; // keccak256(abi.encodePacked("mediatorContract"))



    /**

     * @dev Throws if caller on the other side is not an associated mediator.

     */

    modifier onlyMediator {

        _onlyMediator();

        _;

    }



    /**

     * @dev Internal function for reducing onlyMediator modifier bytecode overhead.

     */

    function _onlyMediator() internal view {

        IAMB bridge = bridgeContract();

        require(msg.sender == address(bridge));

        require(bridge.messageSender() == mediatorContractOnOtherSide());

    }



    /**

     * @dev Sets the AMB bridge contract address. Only the owner can call this method.

     * @param _bridgeContract the address of the bridge contract.

     */

    function setBridgeContract(address _bridgeContract) external onlyOwner {

        _setBridgeContract(_bridgeContract);

    }



    /**

     * @dev Sets the mediator contract address from the other network. Only the owner can call this method.

     * @param _mediatorContract the address of the mediator contract.

     */

    function setMediatorContractOnOtherSide(address _mediatorContract) external onlyOwner {

        _setMediatorContractOnOtherSide(_mediatorContract);

    }



    /**

     * @dev Get the AMB interface for the bridge contract address

     * @return AMB interface for the bridge contract address

     */

    function bridgeContract() public view returns (IAMB) {

        return IAMB(addressStorage[BRIDGE_CONTRACT]);

    }



    /**

     * @dev Tells the mediator contract address from the other network.

     * @return the address of the mediator contract.

     */

    function mediatorContractOnOtherSide() public view virtual returns (address) {

        return addressStorage[MEDIATOR_CONTRACT];

    }



    /**

     * @dev Stores a valid AMB bridge contract address.

     * @param _bridgeContract the address of the bridge contract.

     */

    function _setBridgeContract(address _bridgeContract) internal {

        require(Address.isContract(_bridgeContract));

        addressStorage[BRIDGE_CONTRACT] = _bridgeContract;

    }



    /**

     * @dev Stores the mediator contract address from the other network.

     * @param _mediatorContract the address of the mediator contract.

     */

    function _setMediatorContractOnOtherSide(address _mediatorContract) internal {

        addressStorage[MEDIATOR_CONTRACT] = _mediatorContract;

    }



    /**

     * @dev Tells the id of the message originated on the other network.

     * @return the id of the message originated on the other network.

     */

    function messageId() internal view returns (bytes32) {

        return bridgeContract().messageId();

    }



    /**

     * @dev Tells the maximum gas limit that a message can use on its execution by the AMB bridge on the other network.

     * @return the maximum gas limit value.

     */

    function maxGasPerTx() internal view returns (uint256) {

        return bridgeContract().maxGasPerTx();

    }



    function _passMessage(bytes memory _data, bool _useOracleLane) internal virtual returns (bytes32);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\BasicNFTOmnibridge.sol
File type: .sol
pragma solidity 0.7.5;

// solhint-disable-next-line compiler-version

pragma abicoder v2;



import "../Initializable.sol";

import "../Upgradeable.sol";

import "../../interfaces/IBurnableMintableERC1155Token.sol";

import "./components/common/BridgeOperationsStorage.sol";

import "./components/common/FailedMessagesProcessor.sol";

import "./components/common/NFTBridgeLimits.sol";

import "./components/common/ERC721Relayer.sol";

import "./components/common/ERC1155Relayer.sol";

import "./components/common/NFTOmnibridgeInfo.sol";

import "./components/native/NativeTokensRegistry.sol";

import "./components/native/MetadataReader.sol";

import "./components/bridged/BridgedTokensRegistry.sol";

import "./components/bridged/TokenImageStorage.sol";

import "./components/bridged/ERC721TokenProxy.sol";

import "./components/bridged/ERC1155TokenProxy.sol";

import "./components/native/NFTMediatorBalanceStorage.sol";

import "../../tokens/ERC721BridgeToken.sol";



/**

 * @title BasicNFTOmnibridge

 * @dev Commong functionality for multi-token mediator for ERC721 tokens intended to work on top of AMB bridge.

 */

abstract contract BasicNFTOmnibridge is

    Initializable,

    Upgradeable,

    BridgeOperationsStorage,

    BridgedTokensRegistry,

    NativeTokensRegistry,

    NFTOmnibridgeInfo,

    NFTBridgeLimits,

    MetadataReader,

    TokenImageStorage,

    ERC721Relayer,

    ERC1155Relayer,

    NFTMediatorBalanceStorage,

    FailedMessagesProcessor

{

    using SafeMath for uint256;



    // Workaround for storing variable up-to-32 bytes suffix

    uint256 private immutable SUFFIX_SIZE;

    bytes32 private immutable SUFFIX;



    // Since contract is intended to be deployed under EternalStorageProxy, only constant and immutable variables can be set here

    constructor(string memory _suffix) {

        require(bytes(_suffix).length <= 32);

        bytes32 suffix;

        assembly {

            suffix := mload(add(_suffix, 32))

        }

        SUFFIX = suffix;

        SUFFIX_SIZE = bytes(_suffix).length;

    }



    /**

     * @dev Checks if specified token was already bridged at least once and it is registered in the Omnibridge.

     * @param _token address of the token contract.

     * @return true, if token was already bridged.

     */

    function isTokenRegistered(address _token) public view override returns (bool) {

        return isRegisteredAsNativeToken(_token) || nativeTokenAddress(_token) != address(0);

    }



    /**

     * @dev Handles the bridged token for the first time, includes deployment of new ERC721TokenProxy contract.

     * @param _token address of the native ERC721 token on the other side.

     * @param _name name of the native token, name suffix will be appended, if empty, symbol will be used instead.

     * @param _symbol symbol of the bridged token, if empty, name will be used instead.

     * @param _recipient address that will receive the tokens.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values amounts of bridged tokens. Should be empty list for ERC721.

     * @param _tokenURIs URIs for the bridged token instances.

     */

    function deployAndHandleBridgedNFT(

        address _token,

        string memory _name,

        string memory _symbol,

        address _recipient,

        uint256[] calldata _tokenIds,

        uint256[] calldata _values,

        string[] calldata _tokenURIs

    ) external onlyMediator {

        address bridgedToken = bridgedTokenAddress(_token);

        if (bridgedToken == address(0)) {

            if (bytes(_name).length == 0) {

                if (bytes(_symbol).length > 0) {

                    _name = _transformName(_symbol);

                }

            } else {

                if (bytes(_symbol).length == 0) {

                    _symbol = _name;

                }

                _name = _transformName(_name);

            }

            bridgedToken = _values.length > 0

                ? address(new ERC1155TokenProxy(tokenImageERC1155(), _name, _symbol, address(this)))

                : address(new ERC721TokenProxy(tokenImageERC721(), _name, _symbol, address(this)));

            _setTokenAddressPair(_token, bridgedToken);

        }



        _handleTokens(bridgedToken, false, _recipient, _tokenIds, _values);

        _setTokensURI(bridgedToken, _tokenIds, _tokenURIs);

    }



    /**

     * @dev Handles the bridged token for the already registered token pair.

     * Checks that the bridged token is inside the execution limits and invokes the Mint accordingly.

     * @param _token address of the native ERC721 token on the other side.

     * @param _recipient address that will receive the tokens.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values amounts of bridged tokens. Should be empty list for ERC721.

     * @param _tokenURIs URIs for the bridged token instances.

     */

    function handleBridgedNFT(

        address _token,

        address _recipient,

        uint256[] calldata _tokenIds,

        uint256[] calldata _values,

        string[] calldata _tokenURIs

    ) external onlyMediator {

        address token = bridgedTokenAddress(_token);



        _handleTokens(token, false, _recipient, _tokenIds, _values);

        _setTokensURI(token, _tokenIds, _tokenURIs);

    }



    /**

     * @dev Handles the bridged token that are native to this chain.

     * Checks that the bridged token is inside the execution limits and invokes the Unlock accordingly.

     * @param _token address of the native ERC721 token contract.

     * @param _recipient address that will receive the tokens.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values amounts of bridged tokens. Should be empty list for ERC721.

     */

    function handleNativeNFT(

        address _token,

        address _recipient,

        uint256[] calldata _tokenIds,

        uint256[] calldata _values

    ) external onlyMediator {

        require(isRegisteredAsNativeToken(_token));



        _setNativeTokenIsRegistered(_token, REGISTERED_AND_DEPLOYED);



        _handleTokens(_token, true, _recipient, _tokenIds, _values);

    }



    /**

     * @dev Allows to pre-set the bridged token contract for not-yet bridged token.

     * Only the owner can call this method.

     * @param _nativeToken address of the token contract on the other side that was not yet bridged.

     * @param _bridgedToken address of the bridged token contract.

     */

    function setCustomTokenAddressPair(address _nativeToken, address _bridgedToken) external onlyOwner {

        require(Address.isContract(_bridgedToken));

        require(!isTokenRegistered(_bridgedToken));

        require(bridgedTokenAddress(_nativeToken) == address(0));

        // Unfortunately, there is no simple way to verify that the _nativeToken address

        // does not belong to the bridged token on the other side,

        // since information about bridged tokens addresses is not transferred back.

        // Therefore, owner account calling this function SHOULD manually verify on the other side of the bridge that

        // nativeTokenAddress(_nativeToken) == address(0) && isTokenRegistered(_nativeToken) == false.



        _setTokenAddressPair(_nativeToken, _bridgedToken);

    }



    /**

     * @dev Allows to send to the other network some ERC721 token that can be forced into the contract

     * without the invocation of the required methods. (e. g. regular transferFrom without a call to onERC721Received)

     * Before calling this method, it must be carefully investigated how imbalance happened

     * in order to avoid an attempt to steal the funds from a token with double addresses.

     * @param _token address of the token contract.

     * @param _receiver the address that will receive the token on the other network.

     * @param _tokenIds unique ids of the bridged tokens.

     */

    function fixMediatorBalanceERC721(

        address _token,

        address _receiver,

        uint256[] calldata _tokenIds

    ) external onlyIfUpgradeabilityOwner {

        require(isRegisteredAsNativeToken(_token));

        require(_tokenIds.length > 0);



        uint256[] memory values = new uint256[](0);



        bytes memory data = _prepareMessage(_token, _receiver, _tokenIds, values);

        bytes32 _messageId = _passMessage(data, true);

        _recordBridgeOperation(_messageId, _token, _receiver, _tokenIds, values);

    }



    /**

     * @dev Allows to send to the other network some ERC1155 token that can be forced into the contract

     * without the invocation of the required methods.

     * Before calling this method, it must be carefully investigated how imbalance happened

     * in order to avoid an attempt to steal the funds from a token with double addresses.

     * @param _token address of the token contract.

     * @param _receiver the address that will receive the token on the other network.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values corresponding amounts of the bridged tokens.

     */

    function fixMediatorBalanceERC1155(

        address _token,

        address _receiver,

        uint256[] calldata _tokenIds,

        uint256[] calldata _values

    ) external onlyIfUpgradeabilityOwner {

        require(isRegisteredAsNativeToken(_token));

        require(_tokenIds.length == _values.length);

        require(_tokenIds.length > 0);



        bytes memory data = _prepareMessage(_token, _receiver, _tokenIds, _values);

        bytes32 _messageId = _passMessage(data, true);

        _recordBridgeOperation(_messageId, _token, _receiver, _tokenIds, _values);

    }



    /**

     * @dev Executes action on deposit of ERC721 token.

     * @param _token address of the ERC721 token contract.

     * @param _from address of token sender.

     * @param _receiver address of token receiver on the other side.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values amounts of bridged tokens. Should be empty list for ERC721.

     */

    function bridgeSpecificActionsOnTokenTransfer(

        address _token,

        address _from,

        address _receiver,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) internal override {

        if (!isTokenRegistered(_token)) {

            _setNativeTokenIsRegistered(_token, REGISTERED);

        }



        bytes memory data = _prepareMessage(_token, _receiver, _tokenIds, _values);



        bytes32 _messageId = _passMessage(data, _isOracleDrivenLaneAllowed(_token, _from, _receiver));



        _recordBridgeOperation(_messageId, _token, _from, _tokenIds, _values);

    }



    /**

     * @dev Constructs the message to be sent to the other side. Burns/locks bridged token.

     * @param _token bridged token address.

     * @param _receiver address of the tokens receiver on the other side.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values amounts of bridged tokens. Should be empty list for ERC721.

     */

    function _prepareMessage(

        address _token,

        address _receiver,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) internal returns (bytes memory) {

        require(_receiver != address(0) && _receiver != mediatorContractOnOtherSide());



        address nativeToken = nativeTokenAddress(_token);



        // process token is native with respect to this side of the bridge

        if (nativeToken == address(0)) {

            string[] memory tokenURIs = new string[](_tokenIds.length);



            if (_values.length > 0) {

                for (uint256 i = 0; i < _tokenIds.length; i++) {

                    uint256 oldBalance = mediatorOwns(_token, _tokenIds[i]);

                    uint256 newBalance = oldBalance.add(_values[i]);

                    require(IERC1155(_token).balanceOf(address(this), _tokenIds[i]) >= newBalance);

                    _setMediatorOwns(_token, _tokenIds[i], newBalance);

                    tokenURIs[i] = _readERC1155TokenURI(_token, _tokenIds[i]);

                }

            } else {

                for (uint256 i = 0; i < _tokenIds.length; i++) {

                    require(mediatorOwns(_token, _tokenIds[i]) == 0);

                    require(IERC721(_token).ownerOf(_tokenIds[i]) == address(this));

                    _setMediatorOwns(_token, _tokenIds[i], 1);

                    tokenURIs[i] = _readERC721TokenURI(_token, _tokenIds[i]);

                }

            }



            // process token which bridged alternative was already ACKed to be deployed

            if (isBridgedTokenDeployAcknowledged(_token)) {

                require(_tokenIds.length <= MAX_BATCH_BRIDGE_LIMIT);

                return

                    abi.encodeWithSelector(

                        this.handleBridgedNFT.selector,

                        _token,

                        _receiver,

                        _tokenIds,

                        _values,

                        tokenURIs

                    );

            }



            require(_tokenIds.length <= MAX_BATCH_BRIDGE_AND_DEPLOY_LIMIT);



            string memory name = _readName(_token);

            string memory symbol = _readSymbol(_token);



            return

                abi.encodeWithSelector(

                    this.deployAndHandleBridgedNFT.selector,

                    _token,

                    name,

                    symbol,

                    _receiver,

                    _tokenIds,

                    _values,

                    tokenURIs

                );

        }



        // process already known token that is bridged from other chain

        if (_values.length > 0) {

            IBurnableMintableERC1155Token(_token).burn(_tokenIds, _values);

        } else {

            for (uint256 i = 0; i < _tokenIds.length; i++) {

                IBurnableMintableERC721Token(_token).burn(_tokenIds[i]);

            }

        }

        return abi.encodeWithSelector(this.handleNativeNFT.selector, nativeToken, _receiver, _tokenIds, _values);

    }



    /**

     * @dev Unlock/Mint back the bridged token that was bridged to the other network but failed.

     * @param _token address that bridged token contract.

     * @param _recipient address that will receive the tokens.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values amounts of bridged tokens. Should be empty list for ERC721.

     */

    function executeActionOnFixedTokens(

        address _token,

        address _recipient,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) internal override {

        _releaseTokens(_token, nativeTokenAddress(_token) == address(0), _recipient, _tokenIds, _values);

    }



    /**

     * @dev Handles the bridged token that came from the other side of the bridge.

     * Checks that the operation is inside the execution limits and invokes the Mint or Unlock accordingly.

     * @param _token token contract address on this side of the bridge.

     * @param _isNative true, if given token is native to this chain and Unlock should be used.

     * @param _recipient address that will receive the tokens.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values amounts of bridged tokens. Should be empty list for ERC721.

     */

    function _handleTokens(

        address _token,

        bool _isNative,

        address _recipient,

        uint256[] calldata _tokenIds,

        uint256[] calldata _values

    ) internal {

        require(isTokenExecutionAllowed(_token));



        _releaseTokens(_token, _isNative, _recipient, _tokenIds, _values);



        emit TokensBridged(_token, _recipient, _tokenIds, _values, messageId());

    }



    /**

     * Internal function for setting token URI for the bridged token instance.

     * @param _token address of the token contract.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _tokenURIs URIs for the bridged token instances.

     */

    function _setTokensURI(

        address _token,

        uint256[] calldata _tokenIds,

        string[] calldata _tokenURIs

    ) internal {

        for (uint256 i = 0; i < _tokenIds.length; i++) {

            if (bytes(_tokenURIs[i]).length > 0) {

                IBurnableMintableERC721Token(_token).setTokenURI(_tokenIds[i], _tokenURIs[i]);

            }

        }

    }



    /**

     * Internal function for unlocking/minting some specific ERC721 token.

     * @param _token address of the token contract.

     * @param _isNative true, if the token contract is native w.r.t to the bridge.

     * @param _recipient address of the tokens receiver.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values amounts of bridged tokens. Should be empty list for ERC721.

     */

    function _releaseTokens(

        address _token,

        bool _isNative,

        address _recipient,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) internal {

        if (_values.length > 0) {

            if (_isNative) {

                for (uint256 i = 0; i < _tokenIds.length; i++) {

                    _setMediatorOwns(_token, _tokenIds[i], mediatorOwns(_token, _tokenIds[i]).sub(_values[i]));

                }

                IERC1155(_token).safeBatchTransferFrom(address(this), _recipient, _tokenIds, _values, new bytes(0));

            } else {

                IBurnableMintableERC1155Token(_token).mint(_recipient, _tokenIds, _values);

            }

        } else {

            if (_isNative) {

                for (uint256 i = 0; i < _tokenIds.length; i++) {

                    _setMediatorOwns(_token, _tokenIds[i], 0);

                    IERC721(_token).transferFrom(address(this), _recipient, _tokenIds[i]);

                }

            } else {

                for (uint256 i = 0; i < _tokenIds.length; i++) {

                    IBurnableMintableERC721Token(_token).mint(_recipient, _tokenIds[i]);

                }

            }

        }

    }



    /**

     * @dev Internal function for recording bridge operation for further usage.

     * Recorded information is used for fixing failed requests on the other side.

     * @param _messageId id of the sent message.

     * @param _token bridged token address.

     * @param _sender address of the tokens sender.

     * @param _tokenIds unique ids of the bridged tokens.

     * @param _values amounts of bridged tokens. Should be empty list for ERC721.

     */

    function _recordBridgeOperation(

        bytes32 _messageId,

        address _token,

        address _sender,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) internal {

        require(isTokenBridgingAllowed(_token));



        setMessageChecksum(_messageId, _messageChecksum(_token, _sender, _tokenIds, _values));



        emit TokensBridgingInitiated(_token, _sender, _tokenIds, _values, _messageId);

    }



    /**

     * @dev Checks if bridge operation is allowed to use oracle driven lane.

     * @param _token address of the token contract on the foreign side of the bridge.

     * @param _sender address of the tokens sender on the home side of the bridge.

     * @param _receiver address of the tokens receiver on the foreign side of the bridge.

     * @return true, if message can be forwarded to the oracle-driven lane.

     */

    function _isOracleDrivenLaneAllowed(

        address _token,

        address _sender,

        address _receiver

    ) internal view virtual returns (bool) {

        (_token, _sender, _receiver);

        return true;

    }



    /**

     * @dev Internal function for transforming the bridged token name. Appends a side-specific suffix.

     * @param _name bridged token from the other side.

     * @return token name for this side of the bridge.

     */

    function _transformName(string memory _name) internal view returns (string memory) {

        string memory result = string(abi.encodePacked(_name, SUFFIX));

        uint256 size = SUFFIX_SIZE;

        assembly {

            mstore(result, add(mload(_name), size))

        }

        return result;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\BridgedTokensRegistry.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../../upgradeability/EternalStorage.sol";



/**

 * @title BridgedTokensRegistry

 * @dev Functionality for keeping track of registered bridged token pairs.

 */

contract BridgedTokensRegistry is EternalStorage {

    event NewTokenRegistered(address indexed nativeToken, address indexed bridgedToken);



    /**

     * @dev Retrieves address of the bridged token contract associated with a specific native token contract on the other side.

     * @param _nativeToken address of the native token contract on the other side.

     * @return address of the deployed bridged token contract.

     */

    function bridgedTokenAddress(address _nativeToken) public view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("homeTokenAddress", _nativeToken))];

    }



    /**

     * @dev Retrieves address of the native token contract associated with a specific bridged token contract.

     * @param _bridgedToken address of the created bridged token contract on this side.

     * @return address of the native token contract on the other side of the bridge.

     */

    function nativeTokenAddress(address _bridgedToken) public view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("foreignTokenAddress", _bridgedToken))];

    }



    /**

     * @dev Internal function for updating a pair of addresses for the bridged token.

     * @param _nativeToken address of the native token contract on the other side.

     * @param _bridgedToken address of the created bridged token contract on this side.

     */

    function _setTokenAddressPair(address _nativeToken, address _bridgedToken) internal {

        addressStorage[keccak256(abi.encodePacked("homeTokenAddress", _nativeToken))] = _bridgedToken;

        addressStorage[keccak256(abi.encodePacked("foreignTokenAddress", _bridgedToken))] = _nativeToken;



        emit NewTokenRegistered(_nativeToken, _bridgedToken);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\BridgeOperationsStorage.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../../upgradeability/EternalStorage.sol";



/**

 * @title BridgeOperationsStorage

 * @dev Functionality for storing processed bridged operations.

 */

abstract contract BridgeOperationsStorage is EternalStorage {

    /**

     * @dev Set bridged message checksum.

     * @param _messageId id of the sent AMB message.

     * @param _checksum checksum of the bridge operation.

     */

    function setMessageChecksum(bytes32 _messageId, bytes32 _checksum) internal {

        uintStorage[keccak256(abi.encodePacked("messageChecksum", _messageId))] = uint256(_checksum);

    }



    /**

     * @dev Tells the bridged message checksum.

     * @param _messageId id of the sent AMB message.

     * @return saved message checksum associated with the given message id.

     */

    function getMessageChecksum(bytes32 _messageId) internal view returns (bytes32) {

        return bytes32(uintStorage[keccak256(abi.encodePacked("messageChecksum", _messageId))]);

    }



    /**

     * @dev Calculates message checksum, used for verifying correctness of the given parameters when fixing message.

     * @param _token address of the bridged token contract on this side current side of the bridge.

     * @param _sender address of the tokens sender.

     * @param _tokenIds list of ids of sent tokens.

     * @param _values list of sent token amounts. Should be an empty array for ERC721 tokens.

     * @return message checksum.

     */

    function _messageChecksum(

        address _token,

        address _sender,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) internal pure returns (bytes32) {

        return keccak256(abi.encode(_token, _sender, _tokenIds, _values));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\BridgeValidators.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2019-12-18

*/



// File: contracts/upgradeability/EternalStorage.sol



pragma solidity 0.4.24;



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {

    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;



}



// File: contracts/upgradeable_contracts/Ownable.sol



pragma solidity 0.4.24;





/**

 * @title Ownable

 * @dev This contract has an owner address providing basic authorization control

 */

contract Ownable is EternalStorage {

    /**

    * @dev Event to show ownership has been transferred

    * @param previousOwner representing the address of the previous owner

    * @param newOwner representing the address of the new owner

    */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner());

        /* solcov ignore next */

        _;

    }



    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked("owner"))



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function owner() public view returns (address) {

        return addressStorage[OWNER];

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner the address to transfer ownership to.

    */

    function transferOwnership(address newOwner) external onlyOwner {

        require(newOwner != address(0));

        setOwner(newOwner);

    }



    /**

    * @dev Sets a new owner address

    */

    function setOwner(address newOwner) internal {

        emit OwnershipTransferred(owner(), newOwner);

        addressStorage[OWNER] = newOwner;

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.4.24;





/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (_a == 0) {

      return 0;

    }



    c = _a * _b;

    assert(c / _a == _b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {

    // assert(_b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = _a / _b;

    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold

    return _a / _b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {

    assert(_b <= _a);

    return _a - _b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    c = _a + _b;

    assert(c >= _a);

    return c;

  }

}



// File: contracts/upgradeable_contracts/Initializable.sol



pragma solidity 0.4.24;





contract Initializable is EternalStorage {

    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked("isInitialized"))



    function setInitialize() internal {

        boolStorage[INITIALIZED] = true;

    }



    function isInitialized() public view returns (bool) {

        return boolStorage[INITIALIZED];

    }

}



// File: contracts/upgradeable_contracts/InitializableBridge.sol



pragma solidity 0.4.24;





contract InitializableBridge is Initializable {

    bytes32 internal constant DEPLOYED_AT_BLOCK = 0xb120ceec05576ad0c710bc6e85f1768535e27554458f05dcbb5c65b8c7a749b0; // keccak256(abi.encodePacked("deployedAtBlock"))



    function deployedAtBlock() external view returns (uint256) {

        return uintStorage[DEPLOYED_AT_BLOCK];

    }

}



// File: contracts/upgradeable_contracts/BaseBridgeValidators.sol



pragma solidity 0.4.24;









contract BaseBridgeValidators is InitializableBridge, Ownable {

    using SafeMath for uint256;



    address public constant F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;

    uint256 internal constant MAX_VALIDATORS = 100;

    bytes32 internal constant REQUIRED_SIGNATURES = 0xd18ea17c351d6834a0e568067fb71804d2a588d5e26d60f792b1c724b1bd53b1; // keccak256(abi.encodePacked("requiredSignatures"))

    bytes32 internal constant VALIDATOR_COUNT = 0x8656d603d9f985c3483946a92789d52202f49736384ba131cb92f62c4c1aa082; // keccak256(abi.encodePacked("validatorCount"))



    event ValidatorAdded(address indexed validator);

    event ValidatorRemoved(address indexed validator);

    event RequiredSignaturesChanged(uint256 requiredSignatures);



    function setRequiredSignatures(uint256 _requiredSignatures) external onlyOwner {

        require(validatorCount() >= _requiredSignatures);

        require(_requiredSignatures != 0);

        uintStorage[REQUIRED_SIGNATURES] = _requiredSignatures;

        emit RequiredSignaturesChanged(_requiredSignatures);

    }



    function getBridgeValidatorsInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {

        return (2, 3, 0);

    }



    function validatorList() external view returns (address[]) {

        address[] memory list = new address[](validatorCount());

        uint256 counter = 0;

        address nextValidator = getNextValidator(F_ADDR);

        require(nextValidator != address(0));



        while (nextValidator != F_ADDR) {

            list[counter] = nextValidator;

            nextValidator = getNextValidator(nextValidator);

            counter++;



            require(nextValidator != address(0));

        }



        return list;

    }



    function _addValidator(address _validator) internal {

        require(_validator != address(0) && _validator != F_ADDR);

        require(!isValidator(_validator));



        address firstValidator = getNextValidator(F_ADDR);

        require(firstValidator != address(0));

        setNextValidator(_validator, firstValidator);

        setNextValidator(F_ADDR, _validator);

        setValidatorCount(validatorCount().add(1));

    }



    function _removeValidator(address _validator) internal {

        require(validatorCount() > requiredSignatures());

        require(isValidator(_validator));

        address validatorsNext = getNextValidator(_validator);

        address index = F_ADDR;

        address next = getNextValidator(index);

        require(next != address(0));



        while (next != _validator) {

            index = next;

            next = getNextValidator(index);



            require(next != F_ADDR && next != address(0));

        }



        setNextValidator(index, validatorsNext);

        deleteItemFromAddressStorage("validatorsList", _validator);

        setValidatorCount(validatorCount().sub(1));

    }



    function requiredSignatures() public view returns (uint256) {

        return uintStorage[REQUIRED_SIGNATURES];

    }



    function validatorCount() public view returns (uint256) {

        return uintStorage[VALIDATOR_COUNT];

    }



    function isValidator(address _validator) public view returns (bool) {

        return _validator != F_ADDR && getNextValidator(_validator) != address(0);

    }



    function getNextValidator(address _address) public view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("validatorsList", _address))];

    }



    function deleteItemFromAddressStorage(string _mapName, address _address) internal {

        delete addressStorage[keccak256(abi.encodePacked(_mapName, _address))];

    }



    function setValidatorCount(uint256 _validatorCount) internal {

        uintStorage[VALIDATOR_COUNT] = _validatorCount;

    }



    function setNextValidator(address _prevValidator, address _validator) internal {

        addressStorage[keccak256(abi.encodePacked("validatorsList", _prevValidator))] = _validator;

    }



    function isValidatorDuty(address _validator) external view returns (bool) {

        uint256 counter = 0;

        address next = getNextValidator(F_ADDR);

        require(next != address(0));



        while (next != F_ADDR) {

            if (next == _validator) {

                return (block.number % validatorCount() == counter);

            }



            next = getNextValidator(next);

            counter++;



            require(next != address(0));

        }



        return false;

    }

}



// File: contracts/upgradeable_contracts/BridgeValidators.sol



pragma solidity 0.4.24;





contract BridgeValidators is BaseBridgeValidators {

    function initialize(uint256 _requiredSignatures, address[] _initialValidators, address _owner)

        external

        returns (bool)

    {

        require(!isInitialized());

        require(_owner != address(0));

        setOwner(_owner);

        require(_requiredSignatures != 0);

        require(_initialValidators.length >= _requiredSignatures);

        require(_initialValidators.length <= MAX_VALIDATORS);



        for (uint256 i = 0; i < _initialValidators.length; i++) {

            require(_initialValidators[i] != address(0) && _initialValidators[i] != F_ADDR);

            require(!isValidator(_initialValidators[i]));



            if (i == 0) {

                setNextValidator(F_ADDR, _initialValidators[i]);

                if (_initialValidators.length == 1) {

                    setNextValidator(_initialValidators[i], F_ADDR);

                }

            } else if (i == _initialValidators.length - 1) {

                setNextValidator(_initialValidators[i - 1], _initialValidators[i]);

                setNextValidator(_initialValidators[i], F_ADDR);

            } else {

                setNextValidator(_initialValidators[i - 1], _initialValidators[i]);

            }



            emit ValidatorAdded(_initialValidators[i]);

        }



        setValidatorCount(_initialValidators.length);

        uintStorage[REQUIRED_SIGNATURES] = _requiredSignatures;

        uintStorage[DEPLOYED_AT_BLOCK] = block.number;

        setInitialize();

        emit RequiredSignaturesChanged(_requiredSignatures);



        return isInitialized();

    }



    function addValidator(address _validator) external onlyOwner {

        _addValidator(_validator);

        emit ValidatorAdded(_validator);

    }



    function removeValidator(address _validator) external onlyOwner {

        _removeValidator(_validator);

        emit ValidatorRemoved(_validator);

    }



    function upgradeToV230() public {

        bytes32 upgradeStorage = 0x2e8a0420c66b3c19df2ac1cd4ffadb5637da547c6fd49388c7fe28dc8c13a8dd; // keccak256(abi.encodePacked('isUpgradedToV230'))

        require(!boolStorage[upgradeStorage]);

        address validator1 = 0x9ad83402C19Af24F76afa1930a2B2EEC2F47A8C5;

        address validator2 = 0x4D1c96B9A49C4469A0b720a22b74b034EDdFe051;

        address validator3 = 0x491FC792e78CDadd7D31446Bb7bDDef876a69AD6;

        address validator4 = 0xc073C8E5ED9Aa11CF6776C69b3e13b259Ba9F506;



        setNextValidator(F_ADDR, validator1);

        setNextValidator(validator1, validator2);

        setNextValidator(validator2, validator3);

        setNextValidator(validator3, validator4);

        setNextValidator(validator4, F_ADDR);

        boolStorage[upgradeStorage] = true;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\Bytes.sol
File type: .sol
pragma solidity 0.7.5;



/**

 * @title Bytes

 * @dev Helper methods to transform bytes to other solidity types.

 */

library Bytes {

    /**

     * @dev Truncate bytes array if its size is more than 20 bytes.

     * NOTE: This function does not perform any checks on the received parameter.

     * Make sure that the _bytes argument has a correct length, not less than 20 bytes.

     * A case when _bytes has length less than 20 will lead to the undefined behaviour,

     * since assembly will read data from memory that is not related to the _bytes argument.

     * @param _bytes to be converted to address type

     * @return addr address included in the firsts 20 bytes of the bytes array in parameter.

     */

    function bytesToAddress(bytes memory _bytes) internal pure returns (address addr) {

        assembly {

            addr := mload(add(_bytes, 20))

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity >=0.6.0 <0.8.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\Distribution.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-04-14

*/



pragma solidity 0.5.10;



interface IMultipleDistribution {

    function initialize(address _tokenAddress) external;

    function poolStake() external view returns (uint256);

}





interface IDistribution {

    function supply() external view returns(uint256);

    function poolAddress(uint8) external view returns(address);

}





interface IERC677MultiBridgeToken {

    function transfer(address _to, uint256 _value) external returns (bool);

    function transferDistribution(address _to, uint256 _value) external returns (bool);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);

    function balanceOf(address _account) external view returns (uint256);

}









/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be aplied to your functions to restrict their use to

 * the owner.

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * > Note: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}







/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, "SafeMath: division by zero");

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0, "SafeMath: modulo by zero");

        return a % b;

    }

}







/**

 * @dev Collection of functions related to the address type,

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * This test is non-exhaustive, and there may be false-negatives: during the

     * execution of a contract's constructor, its address will be reported as

     * not containing a contract.

     *

     * > It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies in extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}











/// @dev Distributes STAKE tokens.

contract Distribution is Ownable, IDistribution {

    using SafeMath for uint256;

    using Address for address;



    /// @dev Emits when `preInitialize` method has been called.

    /// @param token The address of ERC677MultiBridgeToken.

    /// @param caller The address of the caller.

    event PreInitialized(address token, address caller);



    /// @dev Emits when `initialize` method has been called.

    /// @param caller The address of the caller.

    event Initialized(address caller);



    /// @dev Emits when an installment for the specified pool has been made.

    /// @param pool The index of the pool.

    /// @param value The installment value.

    /// @param caller The address of the caller.

    event InstallmentMade(uint8 indexed pool, uint256 value, address caller);



    /// @dev Emits when the pool address was changed.

    /// @param pool The index of the pool.

    /// @param oldAddress Old address.

    /// @param newAddress New address.

    event PoolAddressChanged(uint8 indexed pool, address oldAddress, address newAddress);



    /// @dev The instance of ERC677MultiBridgeToken.

    IERC677MultiBridgeToken public token;



    uint8 public constant ECOSYSTEM_FUND = 1;

    uint8 public constant PUBLIC_OFFERING = 2;

    uint8 public constant PRIVATE_OFFERING = 3;

    uint8 public constant ADVISORS_REWARD = 4;

    uint8 public constant FOUNDATION_REWARD = 5;

    uint8 public constant LIQUIDITY_FUND = 6;



    /// @dev Pool address.

    mapping (uint8 => address) public poolAddress;

    /// @dev Pool total amount of tokens.

    mapping (uint8 => uint256) public stake;

    /// @dev Amount of remaining tokens to distribute for the pool.

    mapping (uint8 => uint256) public tokensLeft;

    /// @dev Pool cliff period (in seconds).

    mapping (uint8 => uint256) public cliff;

    /// @dev Total number of installments for the pool.

    mapping (uint8 => uint256) public numberOfInstallments;

    /// @dev Number of installments that were made.

    mapping (uint8 => uint256) public numberOfInstallmentsMade;

    /// @dev The value of one-time installment for the pool.

    mapping (uint8 => uint256) public installmentValue;

    /// @dev The value to transfer to the pool at cliff.

    mapping (uint8 => uint256) public valueAtCliff;

    /// @dev Boolean variable that contains whether the value for the pool at cliff was paid or not.

    mapping (uint8 => bool) public wasValueAtCliffPaid;

    /// @dev Boolean variable that contains whether all installments for the pool were made or not.

    mapping (uint8 => bool) public installmentsEnded;



    /// @dev The total token supply.

    uint256 constant public supply = 8537500 ether;



    /// @dev The timestamp of the distribution start.

    uint256 public distributionStartTimestamp;



    /// @dev The timestamp of pre-initialization.

    uint256 public preInitializationTimestamp;

    /// @dev Boolean variable that indicates whether the contract was pre-initialized.

    bool public isPreInitialized = false;

    /// @dev Boolean variable that indicates whether the contract was initialized.

    bool public isInitialized = false;



    /// @dev Checks that the contract is initialized.

    modifier initialized() {

        require(isInitialized, "not initialized");

        _;

    }



    /// @dev Checks that the installments for the given pool are started and are not finished already.

    /// @param _pool The index of the pool.

    modifier active(uint8 _pool) {

        require(

            // solium-disable-next-line security/no-block-members

            _now() >= distributionStartTimestamp.add(cliff[_pool]) && !installmentsEnded[_pool],

            "installments are not active for this pool"

        );

        _;

    }



    /// @dev Sets up constants and pools addresses that are used in distribution.

    /// @param _ecosystemFundAddress The address of the Ecosystem Fund.

    /// @param _publicOfferingAddress The address of the Public Offering.

    /// @param _privateOfferingAddress The address of the Private Offering contract.

    /// @param _advisorsRewardAddress The address of the Advisors Reward contract.

    /// @param _foundationAddress The address of the Foundation Reward.

    /// @param _liquidityFundAddress The address of the Liquidity Fund.

    constructor(

        address _ecosystemFundAddress,

        address _publicOfferingAddress,

        address _privateOfferingAddress,

        address _advisorsRewardAddress,

        address _foundationAddress,

        address _liquidityFundAddress

    ) public {

        // validate provided addresses

        require(

            _privateOfferingAddress.isContract() &&

            _advisorsRewardAddress.isContract(),

            "not a contract address"

        );

        _validateAddress(_ecosystemFundAddress);

        _validateAddress(_publicOfferingAddress);

        _validateAddress(_foundationAddress);

        _validateAddress(_liquidityFundAddress);

        poolAddress[ECOSYSTEM_FUND] = _ecosystemFundAddress;

        poolAddress[PUBLIC_OFFERING] = _publicOfferingAddress;

        poolAddress[PRIVATE_OFFERING] = _privateOfferingAddress;

        poolAddress[ADVISORS_REWARD] = _advisorsRewardAddress;

        poolAddress[FOUNDATION_REWARD] = _foundationAddress;

        poolAddress[LIQUIDITY_FUND] = _liquidityFundAddress;



        // initialize token amounts

        stake[ECOSYSTEM_FUND] = 4000000 ether;

        stake[PUBLIC_OFFERING] = 400000 ether;

        stake[PRIVATE_OFFERING] = IMultipleDistribution(poolAddress[PRIVATE_OFFERING]).poolStake();

        stake[ADVISORS_REWARD] = IMultipleDistribution(poolAddress[ADVISORS_REWARD]).poolStake();

        stake[FOUNDATION_REWARD] = 699049 ether;

        stake[LIQUIDITY_FUND] = 816500 ether;



        require(

            stake[ECOSYSTEM_FUND] // solium-disable-line operator-whitespace

                .add(stake[PUBLIC_OFFERING])

                .add(stake[PRIVATE_OFFERING])

                .add(stake[ADVISORS_REWARD])

                .add(stake[FOUNDATION_REWARD])

                .add(stake[LIQUIDITY_FUND])

            == supply,

            "wrong sum of pools stakes"

        );



        tokensLeft[ECOSYSTEM_FUND] = stake[ECOSYSTEM_FUND];

        tokensLeft[PUBLIC_OFFERING] = stake[PUBLIC_OFFERING];

        tokensLeft[PRIVATE_OFFERING] = stake[PRIVATE_OFFERING];

        tokensLeft[ADVISORS_REWARD] = stake[ADVISORS_REWARD];

        tokensLeft[FOUNDATION_REWARD] = stake[FOUNDATION_REWARD];

        tokensLeft[LIQUIDITY_FUND] = stake[LIQUIDITY_FUND];



        valueAtCliff[ECOSYSTEM_FUND] = stake[ECOSYSTEM_FUND].mul(20).div(100);       // 20%

        valueAtCliff[PRIVATE_OFFERING] = stake[PRIVATE_OFFERING].mul(10).div(100);   // 10%

        valueAtCliff[ADVISORS_REWARD] = stake[ADVISORS_REWARD].mul(20).div(100);     // 20%

        valueAtCliff[FOUNDATION_REWARD] = stake[FOUNDATION_REWARD].mul(20).div(100); // 20%



        cliff[ECOSYSTEM_FUND] = 336 days;

        cliff[PRIVATE_OFFERING] = 28 days;

        cliff[ADVISORS_REWARD] = 84 days;

        cliff[FOUNDATION_REWARD] = 84 days;



        numberOfInstallments[ECOSYSTEM_FUND] = 336; // days

        numberOfInstallments[PRIVATE_OFFERING] = 224; // days

        numberOfInstallments[ADVISORS_REWARD] = 252; // days

        numberOfInstallments[FOUNDATION_REWARD] = 252; // days



        installmentValue[ECOSYSTEM_FUND] = _calculateInstallmentValue(ECOSYSTEM_FUND);

        installmentValue[PRIVATE_OFFERING] = _calculateInstallmentValue(

            PRIVATE_OFFERING,

            stake[PRIVATE_OFFERING].mul(35).div(100) // 25% will be distributed at pre-initializing and 10% at cliff

        );

        installmentValue[ADVISORS_REWARD] = _calculateInstallmentValue(ADVISORS_REWARD);

        installmentValue[FOUNDATION_REWARD] = _calculateInstallmentValue(FOUNDATION_REWARD);

    }



    /// @dev Pre-initializes the contract after the token is created.

    /// Distributes tokens for Public Offering, Liquidity Fund, and part of Private Offering.

    /// @param _tokenAddress The address of the STAKE token contract.

    /// @param _initialStakeAmount The sum of initial stakes made on xDai chain before transitioning to POSDAO.

    /// This amount must be sent to address(0) because it is excess on Mainnet side.

    function preInitialize(address _tokenAddress, uint256 _initialStakeAmount) external onlyOwner {

        require(!isPreInitialized, "already pre-initialized");



        token = IERC677MultiBridgeToken(_tokenAddress);

        uint256 balance = token.balanceOf(address(this));

        require(balance == supply, "wrong contract balance");



        preInitializationTimestamp = _now(); // solium-disable-line security/no-block-members

        isPreInitialized = true;



        IMultipleDistribution(poolAddress[PRIVATE_OFFERING]).initialize(_tokenAddress);

        IMultipleDistribution(poolAddress[ADVISORS_REWARD]).initialize(_tokenAddress);

        uint256 privateOfferingPrerelease = stake[PRIVATE_OFFERING].mul(25).div(100); // 25%



        token.transferDistribution(poolAddress[PUBLIC_OFFERING], stake[PUBLIC_OFFERING]); // 100%

        token.transfer(poolAddress[PRIVATE_OFFERING], privateOfferingPrerelease);



        uint256 liquidityFundDistribution = stake[LIQUIDITY_FUND].sub(_initialStakeAmount);

        token.transferDistribution(poolAddress[LIQUIDITY_FUND], liquidityFundDistribution);

        if (_initialStakeAmount > 0) {

            token.transferDistribution(address(0), _initialStakeAmount);

        }



        tokensLeft[PUBLIC_OFFERING] = tokensLeft[PUBLIC_OFFERING].sub(stake[PUBLIC_OFFERING]);

        tokensLeft[PRIVATE_OFFERING] = tokensLeft[PRIVATE_OFFERING].sub(privateOfferingPrerelease);

        tokensLeft[LIQUIDITY_FUND] = tokensLeft[LIQUIDITY_FUND].sub(stake[LIQUIDITY_FUND]);



        emit PreInitialized(_tokenAddress, msg.sender);

        emit InstallmentMade(PUBLIC_OFFERING, stake[PUBLIC_OFFERING], msg.sender);

        emit InstallmentMade(PRIVATE_OFFERING, privateOfferingPrerelease, msg.sender);

        emit InstallmentMade(LIQUIDITY_FUND, liquidityFundDistribution, msg.sender);



        if (_initialStakeAmount > 0) {

            emit InstallmentMade(0, _initialStakeAmount, msg.sender);

        }

    }



    /// @dev Initializes token distribution.

    function initialize() external {

        require(isPreInitialized, "not pre-initialized");

        require(!isInitialized, "already initialized");



        if (_now().sub(preInitializationTimestamp) < 90 days) { // solium-disable-line security/no-block-members

            require(isOwner(), "for now only owner can call this method");

        }



        distributionStartTimestamp = _now(); // solium-disable-line security/no-block-members

        isInitialized = true;



        emit Initialized(msg.sender);

    }



    /// @dev Changes the address of the specified pool.

    /// @param _pool The index of the pool (only ECOSYSTEM_FUND or FOUNDATION_REWARD are allowed).

    /// @param _newAddress The new address for the change.

    function changePoolAddress(uint8 _pool, address _newAddress) external {

        require(_pool == ECOSYSTEM_FUND || _pool == FOUNDATION_REWARD, "wrong pool");

        require(msg.sender == poolAddress[_pool], "not authorized");

        _validateAddress(_newAddress);

        emit PoolAddressChanged(_pool, poolAddress[_pool], _newAddress);

        poolAddress[_pool] = _newAddress;

    }



    /// @dev Makes an installment for one of the following pools:

    /// Private Offering, Advisors Reward, Ecosystem Fund, Foundation Reward.

    /// @param _pool The index of the pool.

    function makeInstallment(uint8 _pool) public initialized active(_pool) {

        require(

            _pool == PRIVATE_OFFERING ||

            _pool == ADVISORS_REWARD ||

            _pool == ECOSYSTEM_FUND ||

            _pool == FOUNDATION_REWARD,

            "wrong pool"

        );

        uint256 value = 0;

        if (!wasValueAtCliffPaid[_pool]) {

            value = valueAtCliff[_pool];

            wasValueAtCliffPaid[_pool] = true;

        }

        uint256 availableNumberOfInstallments = _calculateNumberOfAvailableInstallments(_pool);

        value = value.add(installmentValue[_pool].mul(availableNumberOfInstallments));



        require(value > 0, "no installments available");



        uint256 remainder = _updatePoolData(_pool, value, availableNumberOfInstallments);

        value = value.add(remainder);



        if (_pool == PRIVATE_OFFERING || _pool == ADVISORS_REWARD) {

            token.transfer(poolAddress[_pool], value);

        } else {

            token.transferDistribution(poolAddress[_pool], value);

        }



        emit InstallmentMade(_pool, value, msg.sender);

    }



    /// @dev This method is called after the STAKE tokens are transferred to this contract.

    function onTokenTransfer(address, uint256, bytes memory) public pure returns (bool) {

        revert("sending tokens to this contract is not allowed");

    }



    /// @dev The removed implementation of the ownership renouncing.

    function renounceOwnership() public onlyOwner {

        revert("not implemented");

    }



    function _now() internal view returns (uint256) {

        return now; // solium-disable-line security/no-block-members

    }



    /// @dev Updates the given pool data after each installment:

    /// the remaining number of tokens,

    /// the number of made installments.

    /// If the last installment are done and the tokens remained

    /// then transfers them to the pool and marks that all installments for the given pool are made.

    /// @param _pool The index of the pool.

    /// @param _value Current installment value.

    /// @param _currentNumberOfInstallments Number of installment that are made.

    function _updatePoolData(

        uint8 _pool,

        uint256 _value,

        uint256 _currentNumberOfInstallments

    ) internal returns (uint256) {

        uint256 remainder = 0;

        tokensLeft[_pool] = tokensLeft[_pool].sub(_value);

        numberOfInstallmentsMade[_pool] = numberOfInstallmentsMade[_pool].add(_currentNumberOfInstallments);

        if (numberOfInstallmentsMade[_pool] >= numberOfInstallments[_pool]) {

            if (tokensLeft[_pool] > 0) {

                remainder = tokensLeft[_pool];

                tokensLeft[_pool] = 0;

            }

            _endInstallment(_pool);

        }

        return remainder;

    }



    /// @dev Marks that all installments for the given pool are made.

    /// @param _pool The index of the pool.

    function _endInstallment(uint8 _pool) internal {

        installmentsEnded[_pool] = true;

    }



    /// @dev Calculates the value of the installment for 1 day for the given pool.

    /// @param _pool The index of the pool.

    /// @param _valueAtCliff Custom value to distribute at cliff.

    function _calculateInstallmentValue(

        uint8 _pool,

        uint256 _valueAtCliff

    ) internal view returns (uint256) {

        return stake[_pool].sub(_valueAtCliff).div(numberOfInstallments[_pool]);

    }



    /// @dev Calculates the value of the installment for 1 day for the given pool.

    /// @param _pool The index of the pool.

    function _calculateInstallmentValue(uint8 _pool) internal view returns (uint256) {

        return _calculateInstallmentValue(_pool, valueAtCliff[_pool]);

    }



    /// @dev Calculates the number of available installments for the given pool.

    /// @param _pool The index of the pool.

    /// @return The number of available installments.

    function _calculateNumberOfAvailableInstallments(

        uint8 _pool

    ) internal view returns (

        uint256 availableNumberOfInstallments

    ) {

        uint256 paidDays = numberOfInstallmentsMade[_pool].mul(1 days);

        uint256 lastTimestamp = distributionStartTimestamp.add(cliff[_pool]).add(paidDays);

        // solium-disable-next-line security/no-block-members

        availableNumberOfInstallments = _now().sub(lastTimestamp).div(1 days);

        if (numberOfInstallmentsMade[_pool].add(availableNumberOfInstallments) > numberOfInstallments[_pool]) {

            availableNumberOfInstallments = numberOfInstallments[_pool].sub(numberOfInstallmentsMade[_pool]);

        }

    }



    /// @dev Checks for an empty address.

    function _validateAddress(address _address) internal pure {

        if (_address == address(0)) {

            revert("invalid address");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\EnumerableMap.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



/**

 * @dev Library for managing an enumerable variant of Solidity's

 * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]

 * type.

 *

 * Maps have the following properties:

 *

 * - Entries are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Entries are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableMap for EnumerableMap.UintToAddressMap;

 *

 *     // Declare a set state variable

 *     EnumerableMap.UintToAddressMap private myMap;

 * }

 * ```

 *

 * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are

 * supported.

 */

library EnumerableMap {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Map type with

    // bytes32 keys and values.

    // The Map implementation uses private functions, and user-facing

    // implementations (such as Uint256ToAddressMap) are just wrappers around

    // the underlying Map.

    // This means that we can only create new EnumerableMaps for types that fit

    // in bytes32.



    struct MapEntry {

        bytes32 _key;

        bytes32 _value;

    }



    struct Map {

        // Storage of map keys and values

        MapEntry[] _entries;



        // Position of the entry defined by a key in the `entries` array, plus 1

        // because index 0 means a key is not in the map.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Adds a key-value pair to a map, or updates the value for an existing

     * key. O(1).

     *

     * Returns true if the key was added to the map, that is if it was not

     * already present.

     */

    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {

        // We read and store the key's index to prevent multiple reads from the same storage slot

        uint256 keyIndex = map._indexes[key];



        if (keyIndex == 0) { // Equivalent to !contains(map, key)

            map._entries.push(MapEntry({ _key: key, _value: value }));

            // The entry is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            map._indexes[key] = map._entries.length;

            return true;

        } else {

            map._entries[keyIndex - 1]._value = value;

            return false;

        }

    }



    /**

     * @dev Removes a key-value pair from a map. O(1).

     *

     * Returns true if the key was removed from the map, that is if it was present.

     */

    function _remove(Map storage map, bytes32 key) private returns (bool) {

        // We read and store the key's index to prevent multiple reads from the same storage slot

        uint256 keyIndex = map._indexes[key];



        if (keyIndex != 0) { // Equivalent to contains(map, key)

            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one

            // in the array, and then remove the last entry (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = keyIndex - 1;

            uint256 lastIndex = map._entries.length - 1;



            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            MapEntry storage lastEntry = map._entries[lastIndex];



            // Move the last entry to the index where the entry to delete is

            map._entries[toDeleteIndex] = lastEntry;

            // Update the index for the moved entry

            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved entry was stored

            map._entries.pop();



            // Delete the index for the deleted slot

            delete map._indexes[key];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the key is in the map. O(1).

     */

    function _contains(Map storage map, bytes32 key) private view returns (bool) {

        return map._indexes[key] != 0;

    }



    /**

     * @dev Returns the number of key-value pairs in the map. O(1).

     */

    function _length(Map storage map) private view returns (uint256) {

        return map._entries.length;

    }



   /**

    * @dev Returns the key-value pair stored at position `index` in the map. O(1).

    *

    * Note that there are no guarantees on the ordering of entries inside the

    * array, and it may change when more entries are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {

        require(map._entries.length > index, "EnumerableMap: index out of bounds");



        MapEntry storage entry = map._entries[index];

        return (entry._key, entry._value);

    }



    /**

     * @dev Tries to returns the value associated with `key`.  O(1).

     * Does not revert if `key` is not in the map.

     */

    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {

        uint256 keyIndex = map._indexes[key];

        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)

        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based

    }



    /**

     * @dev Returns the value associated with `key`.  O(1).

     *

     * Requirements:

     *

     * - `key` must be in the map.

     */

    function _get(Map storage map, bytes32 key) private view returns (bytes32) {

        uint256 keyIndex = map._indexes[key];

        require(keyIndex != 0, "EnumerableMap: nonexistent key"); // Equivalent to contains(map, key)

        return map._entries[keyIndex - 1]._value; // All indexes are 1-based

    }



    /**

     * @dev Same as {_get}, with a custom error message when `key` is not in the map.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {_tryGet}.

     */

    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {

        uint256 keyIndex = map._indexes[key];

        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)

        return map._entries[keyIndex - 1]._value; // All indexes are 1-based

    }



    // UintToAddressMap



    struct UintToAddressMap {

        Map _inner;

    }



    /**

     * @dev Adds a key-value pair to a map, or updates the value for an existing

     * key. O(1).

     *

     * Returns true if the key was added to the map, that is if it was not

     * already present.

     */

    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {

        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the key was removed from the map, that is if it was present.

     */

    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {

        return _remove(map._inner, bytes32(key));

    }



    /**

     * @dev Returns true if the key is in the map. O(1).

     */

    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {

        return _contains(map._inner, bytes32(key));

    }



    /**

     * @dev Returns the number of elements in the map. O(1).

     */

    function length(UintToAddressMap storage map) internal view returns (uint256) {

        return _length(map._inner);

    }



   /**

    * @dev Returns the element stored at position `index` in the set. O(1).

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {

        (bytes32 key, bytes32 value) = _at(map._inner, index);

        return (uint256(key), address(uint160(uint256(value))));

    }



    /**

     * @dev Tries to returns the value associated with `key`.  O(1).

     * Does not revert if `key` is not in the map.

     *

     * _Available since v3.4._

     */

    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {

        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));

        return (success, address(uint160(uint256(value))));

    }



    /**

     * @dev Returns the value associated with `key`.  O(1).

     *

     * Requirements:

     *

     * - `key` must be in the map.

     */

    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {

        return address(uint160(uint256(_get(map._inner, bytes32(key)))));

    }



    /**

     * @dev Same as {get}, with a custom error message when `key` is not in the map.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryGet}.

     */

    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {

        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\EnumerableSet.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)

 * and `uint256` (`UintSet`) are supported.

 */

library EnumerableSet {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;



        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            bytes32 lastvalue = set._values[lastIndex];



            // Move the last value to the index where the value to delete is

            set._values[toDeleteIndex] = lastvalue;

            // Update the index for the moved value

            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    // Bytes32Set



    struct Bytes32Set {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {

        return _add(set._inner, value);

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {

        return _remove(set._inner, value);

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {

        return _contains(set._inner, value);

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(Bytes32Set storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {

        return _at(set._inner, index);

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(uint160(value))));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(uint160(value))));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(uint160(value))));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint160(uint256(_at(set._inner, index))));

    }





    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC1155.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



import "./IERC1155.sol";

import "./IERC1155MetadataURI.sol";

import "./IERC1155Receiver.sol";

import "../../utils/Context.sol";

import "../../introspection/ERC165.sol";

import "../../math/SafeMath.sol";

import "../../utils/Address.sol";



/**

 *

 * @dev Implementation of the basic standard multi-token.

 * See https://eips.ethereum.org/EIPS/eip-1155

 * Originally based on code by Enjin: https://github.com/enjin/erc-1155

 *

 * _Available since v3.1._

 */

contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {

    using SafeMath for uint256;

    using Address for address;



    // Mapping from token ID to account balances

    mapping (uint256 => mapping(address => uint256)) private _balances;



    // Mapping from account to operator approvals

    mapping (address => mapping(address => bool)) private _operatorApprovals;



    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json

    string private _uri;



    /*

     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e

     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4

     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465

     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a

     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6

     *

     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^

     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26

     */

    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;



    /*

     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c

     */

    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;



    /**

     * @dev See {_setURI}.

     */

    constructor (string memory uri_) {

        _setURI(uri_);



        // register the supported interfaces to conform to ERC1155 via ERC165

        _registerInterface(_INTERFACE_ID_ERC1155);



        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165

        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);

    }



    /**

     * @dev See {IERC1155MetadataURI-uri}.

     *

     * This implementation returns the same URI for *all* token types. It relies

     * on the token type ID substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * Clients calling this function must replace the `\{id\}` substring with the

     * actual token type ID.

     */

    function uri(uint256) external view virtual override returns (string memory) {

        return _uri;

    }



    /**

     * @dev See {IERC1155-balanceOf}.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {

        require(account != address(0), "ERC1155: balance query for the zero address");

        return _balances[id][account];

    }



    /**

     * @dev See {IERC1155-balanceOfBatch}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(

        address[] memory accounts,

        uint256[] memory ids

    )

        public

        view

        virtual

        override

        returns (uint256[] memory)

    {

        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");



        uint256[] memory batchBalances = new uint256[](accounts.length);



        for (uint256 i = 0; i < accounts.length; ++i) {

            batchBalances[i] = balanceOf(accounts[i], ids[i]);

        }



        return batchBalances;

    }



    /**

     * @dev See {IERC1155-setApprovalForAll}.

     */

    function setApprovalForAll(address operator, bool approved) public virtual override {

        require(_msgSender() != operator, "ERC1155: setting approval status for self");



        _operatorApprovals[_msgSender()][operator] = approved;

        emit ApprovalForAll(_msgSender(), operator, approved);

    }



    /**

     * @dev See {IERC1155-isApprovedForAll}.

     */

    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {

        return _operatorApprovals[account][operator];

    }



    /**

     * @dev See {IERC1155-safeTransferFrom}.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    )

        public

        virtual

        override

    {

        require(to != address(0), "ERC1155: transfer to the zero address");

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: caller is not owner nor approved"

        );



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);



        _balances[id][from] = _balances[id][from].sub(amount, "ERC1155: insufficient balance for transfer");

        _balances[id][to] = _balances[id][to].add(amount);



        emit TransferSingle(operator, from, to, id, amount);



        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);

    }



    /**

     * @dev See {IERC1155-safeBatchTransferFrom}.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    )

        public

        virtual

        override

    {

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        require(to != address(0), "ERC1155: transfer to the zero address");

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: transfer caller is not owner nor approved"

        );



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; ++i) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            _balances[id][from] = _balances[id][from].sub(

                amount,

                "ERC1155: insufficient balance for transfer"

            );

            _balances[id][to] = _balances[id][to].add(amount);

        }



        emit TransferBatch(operator, from, to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);

    }



    /**

     * @dev Sets a new URI for all token types, by relying on the token type ID

     * substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * By this mechanism, any occurrence of the `\{id\}` substring in either the

     * URI or any of the amounts in the JSON file at said URI will be replaced by

     * clients with the token type ID.

     *

     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be

     * interpreted by clients as

     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`

     * for token type ID 0x4cce0.

     *

     * See {uri}.

     *

     * Because these URIs cannot be meaningfully represented by the {URI} event,

     * this function emits no events.

     */

    function _setURI(string memory newuri) internal virtual {

        _uri = newuri;

    }



    /**

     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {

        require(account != address(0), "ERC1155: mint to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);



        _balances[id][account] = _balances[id][account].add(amount);

        emit TransferSingle(operator, address(0), account, id, amount);



        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {

        require(to != address(0), "ERC1155: mint to the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);



        for (uint i = 0; i < ids.length; i++) {

            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);

        }



        emit TransferBatch(operator, address(0), to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);

    }



    /**

     * @dev Destroys `amount` tokens of token type `id` from `account`

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens of token type `id`.

     */

    function _burn(address account, uint256 id, uint256 amount) internal virtual {

        require(account != address(0), "ERC1155: burn from the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");



        _balances[id][account] = _balances[id][account].sub(

            amount,

            "ERC1155: burn amount exceeds balance"

        );



        emit TransferSingle(operator, account, address(0), id, amount);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     */

    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {

        require(account != address(0), "ERC1155: burn from the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, account, address(0), ids, amounts, "");



        for (uint i = 0; i < ids.length; i++) {

            _balances[ids[i]][account] = _balances[ids[i]][account].sub(

                amounts[i],

                "ERC1155: burn amount exceeds balance"

            );

        }



        emit TransferBatch(operator, account, address(0), ids, amounts);

    }



    /**

     * @dev Hook that is called before any token transfer. This includes minting

     * and burning, as well as batched variants.

     *

     * The same hook is called on both single and batched variants. For single

     * transfers, the length of the `id` and `amount` arrays will be 1.

     *

     * Calling conditions (for each `id` and `amount` pair):

     *

     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * of token type `id` will be  transferred to `to`.

     * - When `from` is zero, `amount` tokens of token type `id` will be minted

     * for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`

     * will be burned.

     * - `from` and `to` are never both zero.

     * - `ids` and `amounts` have the same, non-zero length.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    )

        internal

        virtual

    { }



    function _doSafeTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    )

        private

    {

        if (to.isContract()) {

            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {

                if (response != IERC1155Receiver(to).onERC1155Received.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _doSafeBatchTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    )

        private

    {

        if (to.isContract()) {

            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {

                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {

        uint256[] memory array = new uint256[](1);

        array[0] = element;



        return array;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC1155BridgeToken.sol
File type: .sol
pragma solidity 0.7.5;



import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

import "../interfaces/IOwnable.sol";

import "../interfaces/IBurnableMintableERC1155Token.sol";



/**

 * @title ERC1155BridgeToken

 * @dev template token contract for bridged ERC1155 tokens.

 */

contract ERC1155BridgeToken is ERC1155, IBurnableMintableERC1155Token {

    string public name;

    string public symbol;



    // Optional mapping for token URIs

    mapping(uint256 => string) private tokenURIs;

    // Base URI

    string private baseURI;



    address public bridgeContract;



    bool private hasAlreadyMinted;



    constructor(

        string memory _name,

        string memory _symbol,

        address _bridgeContract

    ) ERC1155("") {

        name = _name;

        symbol = _symbol;

        bridgeContract = _bridgeContract;

    }



    /**

     * @dev Throws if sender is not a bridge contract.

     */

    modifier onlyBridge() {

        require(msg.sender == bridgeContract);

        _;

    }



    /**

     * @dev Throws if sender is not a bridge contract or bridge contract owner.

     */

    modifier onlyOwner() {

        require(msg.sender == bridgeContract || msg.sender == IOwnable(bridgeContract).owner());

        _;

    }



    /**

     * @dev Tells if this contract implements the interface defined by

     * `interfaceId`. See the corresponding EIP165.

     * @return true, if interface is implemented.

     */

    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {

        bytes4 INTERFACE_ID_ERC165 = 0x01ffc9a7;

        bytes4 INTERFACE_ID_ERC1155 = 0xd9b67a26;

        bytes4 INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;

        return

            interfaceId == INTERFACE_ID_ERC165 ||

            interfaceId == INTERFACE_ID_ERC1155 ||

            interfaceId == INTERFACE_ID_ERC1155_METADATA_URI;

    }



    /**

     * @dev Stub for preventing unneeded storage writes.

     * All supported interfaces are hardcoded in the supportsInterface function.

     */

    function _registerInterface(bytes4) internal override {}



    /**

     * @dev Mint a batch of new ERC1155 tokens.

     * Only bridge contract is authorized to mint tokens.

     * @param _to address of the newly created token owner.

     * @param _tokenIds array of token ids to mint.

     * @param _values array of corresponding mint amounts for each tokenId.

     */

    function mint(

        address _to,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) external override onlyBridge {

        if (_tokenIds.length == 1 && _values.length == 1) {

            _mint(_to, _tokenIds[0], _values[0], new bytes(0));

        } else {

            // Next few lines ensure that the first mint ever happened in his token contract will performed using TransferSingle event

            // Otherwise, NFT marketplaces have issues with indexing bridged token data.

            // On first mint ever (when hasAlreadyMinted is false), last token id from the list is minted using TransferSingle.

            // All over tokens from the list are minted using TransferBatch event.

            // All subsequent operations will always use TransferBatch for operations involving more than 1 token id.

            if (!hasAlreadyMinted) {

                require(_tokenIds.length > 1 && _tokenIds.length == _values.length);

                uint256 len = _tokenIds.length - 1;

                _mint(_to, _tokenIds[len], _values[len], new bytes(0));

                assembly {

                    mstore(_tokenIds, len) // _tokenIds.pop()

                    mstore(_values, len) // _values.pop()

                }

            }

            _mintBatch(_to, _tokenIds, _values, new bytes(0));

        }

        hasAlreadyMinted = true;

    }



    /**

     * @dev Burns a batch of ERC1155 tokens.

     * Only bridge contract is authorized to burn tokens.

     * @param _tokenIds array of token ids to burn.

     * @param _values array of corresponding burn amounts for each tokenId.

     */

    function burn(uint256[] memory _tokenIds, uint256[] memory _values) external override onlyBridge {

        _burnBatch(msg.sender, _tokenIds, _values);

    }



    /**

     * @dev Updates the bridge contract address.

     * Can be called by bridge owner after token contract was instantiated.

     * @param _bridgeContract address of the new bridge contract.

     */

    function setBridgeContract(address _bridgeContract) external onlyOwner {

        require(_bridgeContract != address(0));

        bridgeContract = _bridgeContract;

    }



    /**

     * @dev Sets the base URI for all tokens.

     * Can be called by bridge owner after token contract was instantiated.

     * @param _baseURI new base URI.

     */

    function setBaseURI(string calldata _baseURI) external onlyOwner {

        baseURI = _baseURI;

    }



    /**

     * @dev Sets the URI for the particular token.

     * Can be called by bridge owner after token bridging.

     * @param _tokenId URI for the bridged token metadata.

     * @param _tokenURI new token URI.

     */

    function setTokenURI(uint256 _tokenId, string calldata _tokenURI) external onlyOwner {

        tokenURIs[_tokenId] = _tokenURI;

    }



    /**

     * @dev Tells the metadata URI for the particular tokenId.

     * @param _tokenId unique token id for which to return metadata URI.

     * @return token metadata URI.

     */

    function uri(uint256 _tokenId) external view override returns (string memory) {

        string memory tokenURI = tokenURIs[_tokenId];

        string memory base = baseURI;



        // If there is no base URI, return the token URI.

        if (bytes(base).length == 0) {

            return tokenURI;

        }

        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).

        return string(abi.encodePacked(base, tokenURI));

    }



    /**

     * @dev Tells the current version of the ERC1155 token interfaces.

     */

    function getTokenInterfacesVersion()

        external

        pure

        returns (

            uint64 major,

            uint64 minor,

            uint64 patch

        )

    {

        return (1, 1, 0);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC1155Relayer.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../../interfaces/IERC1155TokenReceiver.sol";

import "./BaseRelayer.sol";



/**

 * @title ERC1155Relayer

 * @dev Functionality for bridging multiple ERC1155 tokens to the other side of the bridge.

 */

abstract contract ERC1155Relayer is IERC1155TokenReceiver, BaseRelayer {

    // max batch size, so that deployAndHandleBridgedNFT fits in 1.000.000 gas

    uint256 internal constant MAX_BATCH_BRIDGE_AND_DEPLOY_LIMIT = 14;

    // max batch size, so that handleBridgedNFT fits in 1.000.000 gas

    uint256 internal constant MAX_BATCH_BRIDGE_LIMIT = 19;



    /**

     * @dev ERC1155 transfer callback function.

     * @param _from address of token sender.

     * @param _tokenId id of the transferred token.

     * @param _value amount of received tokens.

     * @param _data additional transfer data, can be used for passing alternative receiver address.

     */

    function onERC1155Received(

        address,

        address _from,

        uint256 _tokenId,

        uint256 _value,

        bytes calldata _data

    ) external override returns (bytes4) {

        bridgeSpecificActionsOnTokenTransfer(

            msg.sender,

            _from,

            _chooseReceiver(_from, _data),

            _singletonArray(_tokenId),

            _singletonArray(_value)

        );

        return msg.sig;

    }



    /**

     * @dev ERC1155 transfer callback function.

     * @param _from address of token sender.

     * @param _tokenIds unique ids of the received tokens.

     * @param _values amounts of received tokens.

     * @param _data additional transfer data, can be used for passing alternative receiver address.

     */

    function onERC1155BatchReceived(

        address,

        address _from,

        uint256[] calldata _tokenIds,

        uint256[] calldata _values,

        bytes calldata _data

    ) external override returns (bytes4) {

        require(_tokenIds.length == _values.length);

        require(_tokenIds.length > 0);

        bridgeSpecificActionsOnTokenTransfer(msg.sender, _from, _chooseReceiver(_from, _data), _tokenIds, _values);

        return msg.sig;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC1155TokenProxy.sol
File type: .sol
pragma solidity 0.7.5;



import "@openzeppelin/contracts/utils/Address.sol";

import "../../../../upgradeability/Proxy.sol";

import "../../../../interfaces/IOwnable.sol";



/**

 * @title ERC1155TokenProxy

 * @dev Helps to reduces the size of the deployed bytecode for automatically created tokens, by using a proxy contract.

 */

contract ERC1155TokenProxy is Proxy {

    // storage layout is copied from ERC1155BridgeToken.sol

    mapping(bytes4 => bool) private _supportedInterfaces;



    // Mapping from token ID to account balances

    mapping(uint256 => mapping(address => uint256)) private _balances;



    // Mapping from account to operator approvals

    mapping(address => mapping(address => bool)) private _operatorApprovals;



    // not used, kept for correct storage layout representation

    string private _uri;



    string private name;

    string private symbol;

    mapping(uint256 => string) private _tokenURIs;

    string private _baseURI;

    address private bridgeContract;



    /**

     * @dev Creates an upgradeable token proxy for ERC1155BridgeToken.sol, initializes its eternalStorage.

     * @param _tokenImage address of the token image used for mirroring all functions.

     * @param _name token name.

     * @param _symbol token symbol.

     * @param _owner address of the owner for this contract.

     */

    constructor(

        address _tokenImage,

        string memory _name,

        string memory _symbol,

        address _owner

    ) {

        assembly {

            // EIP 1967

            // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)

            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _tokenImage)

        }

        name = _name;

        symbol = _symbol;

        bridgeContract = _owner; // _owner == HomeOmnibridgeNFT/ForeignOmnibridgeNFT mediator

    }



    /**

     * @dev Retrieves the implementation contract address, mirrored token image.

     * @return impl token image address.

     */

    function implementation() public view override returns (address impl) {

        assembly {

            impl := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)

        }

    }



    /**

     * @dev Updates the implementation contract address.

     * Only the bridge and bridge owner can call this method.

     * @param _implementation address of the new implementation.

     */

    function setImplementation(address _implementation) external {

        require(msg.sender == bridgeContract || msg.sender == IOwnable(bridgeContract).owner());

        require(_implementation != address(0));

        require(Address.isContract(_implementation));

        assembly {

            // EIP 1967

            // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)

            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _implementation)

        }

    }



    /**

     * @dev Tells the current version of the ERC1155 token proxy interfaces.

     */

    function getTokenProxyInterfacesVersion()

        external

        pure

        returns (

            uint64 major,

            uint64 minor,

            uint64 patch

        )

    {

        return (1, 0, 0);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



import "./IERC165.sol";



/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts may inherit from this and call {_registerInterface} to declare

 * their support of an interface.

 */

abstract contract ERC165 is IERC165 {

    /*

     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7

     */

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;



    /**

     * @dev Mapping of interface ids to whether or not it's supported.

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    constructor () {

        // Derived contracts need only register support for their own interfaces,

        // we register support for ERC165 itself here

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     *

     * Time complexity O(1), guaranteed to always use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev Registers the contract as an implementer of the interface defined by

     * `interfaceId`. Support of the actual ERC165 interface is automatic and

     * registering its interface id is not required.

     *

     * See {IERC165-supportsInterface}.

     *

     * Requirements:

     *

     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).

     */

    function _registerInterface(bytes4 interfaceId) internal virtual {

        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");

        _supportedInterfaces[interfaceId] = true;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC677MultiBridgeToken.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-04-14

*/



pragma solidity 0.5.10;



/**

 * @dev Collection of functions related to the address type,

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * This test is non-exhaustive, and there may be false-negatives: during the

     * execution of a contract's constructor, its address will be reported as

     * not containing a contract.

     *

     * > It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies in extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}





interface IDistribution {

    function supply() external view returns(uint256);

    function poolAddress(uint8) external view returns(address);

}







contract Sacrifice {

    constructor(address payable _recipient) public payable {

        selfdestruct(_recipient);

    }

}





interface IERC677MultiBridgeToken {

    function transfer(address _to, uint256 _value) external returns (bool);

    function transferDistribution(address _to, uint256 _value) external returns (bool);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);

    function balanceOf(address _account) external view returns (uint256);

}















/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be aplied to your functions to restrict their use to

 * the owner.

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * > Note: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}











/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see `ERC20Detailed`.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a `Transfer` event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through `transferFrom`. This is

     * zero by default.

     *

     * This value changes when `approve` or `transferFrom` are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * > Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an `Approval` event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a `Transfer` event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to `approve`. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}







/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, "SafeMath: division by zero");

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0, "SafeMath: modulo by zero");

        return a % b;

    }

}







/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves.



        // A Solidity high level call has three parts:

        //  1. The target address is checked to verify it contains contract code

        //  2. The call itself is made, and success asserted

        //  3. The return value is decoded, which in turn checks the size of the returned data.

        // solhint-disable-next-line max-line-length

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

















/**

 * @dev Implementation of the `IERC20` interface.

 *

 * This implementation was taken from

 * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.3.0/contracts/token/ERC20/ERC20.sol

 * This differs from the original one only in the definition for the `_balances`

 * mapping: we made it `internal` instead of `private` since we use the `_balances`

 * in the `ERC677BridgeToken` child contract to be able to transfer tokens to address(0)

 * (see its `_superTransfer` function). The original OpenZeppelin implementation

 * doesn't allow transferring to address(0).

 *

 * This implementation is agnostic to the way tokens are created. This means

 * that a supply mechanism has to be added in a derived contract using `_mint`.

 * For a generic mechanism see `ERC20Mintable`.

 *

 * *For a detailed writeup see our guide [How to implement supply

 * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*

 *

 * We have followed general OpenZeppelin guidelines: functions revert instead

 * of returning `false` on failure. This behavior is nonetheless conventional

 * and does not conflict with the expectations of ERC20 applications.

 *

 * Additionally, an `Approval` event is emitted on calls to `transferFrom`.

 * This allows applications to reconstruct the allowance for all accounts just

 * by listening to said events. Other implementations of the EIP may not emit

 * these events, as it isn't required by the specification.

 *

 * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`

 * functions have been added to mitigate the well-known issues around setting

 * allowances. See `IERC20.approve`.

 */

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) internal _balances; // CHANGED: not private to write a custom transfer method



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    /**

     * @dev See `IERC20.totalSupply`.

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See `IERC20.balanceOf`.

     */

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See `IERC20.transfer`.

     *

     * Requirements:

     *

     * - `recipient` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(msg.sender, recipient, amount);

        return true;

    }



    /**

     * @dev See `IERC20.allowance`.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See `IERC20.approve`.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    /**

     * @dev See `IERC20.transferFrom`.

     *

     * Emits an `Approval` event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of `ERC20`;

     *

     * Requirements:

     * - `sender` and `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `value`.

     * - the caller must have allowance for `sender`'s tokens of at least

     * `amount`.

     */

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));

        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to `approve` that can be used as a mitigation for

     * problems described in `IERC20.approve`.

     *

     * Emits an `Approval` event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to `approve` that can be used as a mitigation for

     * problems described in `IERC20.approve`.

     *

     * Emits an `Approval` event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    /**

     * @dev Moves tokens `amount` from `sender` to `recipient`.

     *

     * This is internal function is equivalent to `transfer`, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a `Transfer` event.

     *

     * Requirements:

     *

     * - `sender` cannot be the zero address.

     * - `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     */

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount);

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a `Transfer` event with `from` set to the zero address.

     *

     * Requirements

     *

     * - `to` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     /**

     * @dev Destoys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a `Transfer` event with `to` set to the zero address.

     *

     * Requirements

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 value) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.

     *

     * This is internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an `Approval` event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(address owner, address spender, uint256 value) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    /**

     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted

     * from the caller's allowance.

     *

     * See `_burn` and `_approve`.

     */

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));

    }

}











/**

 * @dev Optional functions from the ERC20 standard.

 */

contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    /**

     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of

     * these values are immutable: they can only be set once during

     * construction.

     */

    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    /**

     * @dev Returns the name of the token.

     */

    function name() public view returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5,05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei.

     *

     * > Note that this information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * `IERC20.balanceOf` and `IERC20.transfer`.

     */

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}







/**

 * @title ERC20Permittable

 * @dev This is ERC20 contract extended by the `permit` function (see EIP712).

 */

contract ERC20Permittable is ERC20, ERC20Detailed {



    string public constant version = "1";



    // EIP712 niceties

    bytes32 public DOMAIN_SEPARATOR;

    // bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)");

    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;



    mapping(address => uint256) public nonces;

    mapping(address => mapping(address => uint256)) public expirations;



    constructor(

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) ERC20Detailed(_name, _symbol, _decimals) public {

        DOMAIN_SEPARATOR = keccak256(abi.encode(

            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),

            keccak256(bytes(_name)),

            keccak256(bytes(version)),

            1, // Chain ID for Ethereum Mainnet

            address(this)

        ));

    }



    /// @dev transferFrom in this contract works in a slightly different form than the generic

    /// transferFrom function. This contract allows for "unlimited approval".

    /// Should the user approve an address for the maximum uint256 value,

    /// then that address will have unlimited approval until told otherwise.

    /// @param _sender The address of the sender.

    /// @param _recipient The address of the recipient.

    /// @param _amount The value to transfer.

    /// @return Success status.

    function transferFrom(address _sender, address _recipient, uint256 _amount) public returns (bool) {

        _transfer(_sender, _recipient, _amount);



        if (_sender != msg.sender) {

            uint256 allowedAmount = allowance(_sender, msg.sender);



            if (allowedAmount != uint256(-1)) {

                // If allowance is limited, adjust it.

                // In this case `transferFrom` works like the generic

                _approve(_sender, msg.sender, allowedAmount.sub(_amount));

            } else {

                // If allowance is unlimited by `permit`, `approve`, or `increaseAllowance`

                // function, don't adjust it. But the expiration date must be empty or in the future

                require(

                    expirations[_sender][msg.sender] == 0 || expirations[_sender][msg.sender] >= _now(),

                    "expiry is in the past"

                );

            }

        } else {

            // If `_sender` is `msg.sender`,

            // the function works just like `transfer()`

        }



        return true;

    }



    /// @dev An alias for `transfer` function.

    /// @param _to The address of the recipient.

    /// @param _amount The value to transfer.

    function push(address _to, uint256 _amount) public {

        transferFrom(msg.sender, _to, _amount);

    }



    /// @dev Makes a request to transfer the specified amount

    /// from the specified address to the caller's address.

    /// @param _from The address of the holder.

    /// @param _amount The value to transfer.

    function pull(address _from, uint256 _amount) public {

        transferFrom(_from, msg.sender, _amount);

    }



    /// @dev An alias for `transferFrom` function.

    /// @param _from The address of the sender.

    /// @param _to The address of the recipient.

    /// @param _amount The value to transfer.

    function move(address _from, address _to, uint256 _amount) public {

        transferFrom(_from, _to, _amount);

    }



    /// @dev Allows to spend holder's unlimited amount by the specified spender.

    /// The function can be called by anyone, but requires having allowance parameters

    /// signed by the holder according to EIP712.

    /// @param _holder The holder's address.

    /// @param _spender The spender's address.

    /// @param _nonce The nonce taken from `nonces(_holder)` public getter.

    /// @param _expiry The allowance expiration date (unix timestamp in UTC).

    /// Can be zero for no expiration. Forced to zero if `_allowed` is `false`.

    /// @param _allowed True to enable unlimited allowance for the spender by the holder. False to disable.

    /// @param _v A final byte of signature (ECDSA component).

    /// @param _r The first 32 bytes of signature (ECDSA component).

    /// @param _s The second 32 bytes of signature (ECDSA component).

    function permit(

        address _holder,

        address _spender,

        uint256 _nonce,

        uint256 _expiry,

        bool _allowed,

        uint8 _v,

        bytes32 _r,

        bytes32 _s

    ) external {

        require(_expiry == 0 || _now() <= _expiry, "invalid expiry");



        bytes32 digest = keccak256(abi.encodePacked(

            "\x19\x01",

            DOMAIN_SEPARATOR,

            keccak256(abi.encode(

                PERMIT_TYPEHASH,

                _holder,

                _spender,

                _nonce,

                _expiry,

                _allowed

            ))

        ));



        require(_holder == ecrecover(digest, _v, _r, _s), "invalid signature or parameters");

        require(_nonce == nonces[_holder]++, "invalid nonce");



        uint256 amount = _allowed ? uint256(-1) : 0;

        _approve(_holder, _spender, amount);



        expirations[_holder][_spender] = _allowed ? _expiry : 0;

    }



    function _now() internal view returns(uint256) {

        return now;

    }



}











// This is a base staking token ERC677 contract for Ethereum Mainnet side

// which is derived by the child ERC677MultiBridgeToken contract.

contract ERC677BridgeToken is Ownable, ERC20Permittable {

    using SafeERC20 for ERC20;

    using Address for address;



    ///  @dev Distribution contract address.

    address public distributionAddress;

    ///  @dev The PrivateOffering contract address.

    address public privateOfferingDistributionAddress;

    ///  @dev The AdvisorsReward contract address.

    address public advisorsRewardDistributionAddress;



    /// @dev Mint event.

    /// @param to To address.

    /// @param amount Minted value.

    event Mint(address indexed to, uint256 amount);



    /// @dev Modified Transfer event with custom data.

    /// @param from From address.

    /// @param to To address.

    /// @param value Transferred value.

    /// @param data Custom data to call after transfer.

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);



    /// @dev Emits if custom call after transfer fails.

    /// @param from From address.

    /// @param to To address.

    /// @param value Transferred value.

    event ContractFallbackCallFailed(address from, address to, uint256 value);



    /// @dev Checks that the recipient address is valid.

    /// @param _recipient Recipient address.

    modifier validRecipient(address _recipient) {

        require(_recipient != address(0) && _recipient != address(this), "not a valid recipient");

        _;

    }



    /// @dev Reverts if called by any account other than the bridge.

    modifier onlyBridge() {

        require(isBridge(msg.sender), "caller is not the bridge");

        _;

    }



    /// @dev Creates a token and mints the whole supply for the Distribution contract.

    /// @param _name Token name.

    /// @param _symbol Token symbol.

    /// @param _distributionAddress The address of the deployed Distribution contract.

    /// @param _privateOfferingDistributionAddress The address of the PrivateOffering contract.

    /// @param _advisorsRewardDistributionAddress The address of the AdvisorsReward contract.

    constructor(

        string memory _name,

        string memory _symbol,

        address _distributionAddress,

        address _privateOfferingDistributionAddress,

        address _advisorsRewardDistributionAddress

    ) ERC20Permittable(_name, _symbol, 18) public {

        require(

            _distributionAddress.isContract() &&

            _privateOfferingDistributionAddress.isContract() &&

            _advisorsRewardDistributionAddress.isContract(),

            "not a contract address"

        );

        uint256 supply = IDistribution(_distributionAddress).supply();

        require(supply > 0, "the supply must be more than 0");

        _mint(_distributionAddress, supply);

        distributionAddress = _distributionAddress;

        privateOfferingDistributionAddress = _privateOfferingDistributionAddress;

        advisorsRewardDistributionAddress = _advisorsRewardDistributionAddress;

        emit Mint(_distributionAddress, supply);

    }



    /// @dev Checks if given address is included into bridge contracts list.

    /// Implemented by a child contract.

    /// @param _address Bridge contract address.

    /// @return bool true, if given address is a known bridge contract.

    function isBridge(address _address) public view returns (bool);



    /// @dev Extends transfer method with callback.

    /// @param _to The address of the recipient.

    /// @param _value The value to transfer.

    /// @param _data Custom data.

    /// @return Success status.

    function transferAndCall(

        address _to,

        uint256 _value,

        bytes calldata _data

    ) external validRecipient(_to) returns (bool) {

        _superTransfer(_to, _value);

        emit Transfer(msg.sender, _to, _value, _data);



        if (_to.isContract()) {

            require(_contractFallback(msg.sender, _to, _value, _data), "contract call failed");

        }

        return true;

    }



    /// @dev Extends transfer method with event when the callback failed.

    /// @param _to The address of the recipient.

    /// @param _value The value to transfer.

    /// @return Success status.

    function transfer(address _to, uint256 _value) public returns (bool) {

        _superTransfer(_to, _value);

        _callAfterTransfer(msg.sender, _to, _value);

        return true;

    }



    /// @dev This is a copy of `transfer` function which can only be called by distribution contracts.

    /// Made to get rid of `onTokenTransfer` calling to save gas when distributing tokens.

    /// @param _to The address of the recipient.

    /// @param _value The value to transfer.

    /// @return Success status.

    function transferDistribution(address _to, uint256 _value) public returns (bool) {

        require(

            msg.sender == distributionAddress ||

            msg.sender == privateOfferingDistributionAddress ||

            msg.sender == advisorsRewardDistributionAddress,

            "wrong sender"

        );

        _superTransfer(_to, _value);

        return true;

    }



    /// @dev Extends transferFrom method with event when the callback failed.

    /// @param _from The address of the sender.

    /// @param _to The address of the recipient.

    /// @param _value The value to transfer.

    /// @return Success status.

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

        _superTransferFrom(_from, _to, _value);

        _callAfterTransfer(_from, _to, _value);

        return true;

    }



    /// @dev If someone sent eth/tokens to the contract mistakenly then the owner can send them back.

    /// @param _token The token address to transfer.

    /// @param _to The address of the recipient.

    function claimTokens(address _token, address payable _to) public onlyOwner validRecipient(_to) {

        if (_token == address(0)) {

            uint256 value = address(this).balance;

            if (!_to.send(value)) { // solium-disable-line security/no-send

                // We use the `Sacrifice` trick to be sure the coins can be 100% sent to the receiver.

                // Otherwise, if the receiver is a contract which has a revert in its fallback function,

                // the sending will fail.

                (new Sacrifice).value(value)(_to);

            }

        } else {

            ERC20 token = ERC20(_token);

            uint256 balance = token.balanceOf(address(this));

            token.safeTransfer(_to, balance);

        }

    }



    /// @dev Creates `amount` tokens and assigns them to `account`, increasing

    /// the total supply. Emits a `Transfer` event with `from` set to the zero address.

    /// Can only be called by a bridge contract which address is set with `addBridge`.

    /// @param _account The address to mint tokens for. Cannot be zero address.

    /// @param _amount The amount of tokens to mint.

    function mint(address _account, uint256 _amount) external onlyBridge returns(bool) {

        _mint(_account, _amount);

        emit Mint(_account, _amount);

        return true;

    }



    /// @dev The removed implementation of the ownership renouncing.

    function renounceOwnership() public onlyOwner {

        revert("not implemented");

    }



    /// @dev Calls transfer method and reverts if it fails.

    /// @param _to The address of the recipient.

    /// @param _value The value to transfer.

    function _superTransfer(address _to, uint256 _value) internal {

        bool success;

        if (

            msg.sender == distributionAddress ||

            msg.sender == privateOfferingDistributionAddress ||

            msg.sender == advisorsRewardDistributionAddress

        ) {

            // Allow sending tokens to `address(0)` by

            // Distribution, PrivateOffering, or AdvisorsReward contract

            _balances[msg.sender] = _balances[msg.sender].sub(_value);

            _balances[_to] = _balances[_to].add(_value);

            emit Transfer(msg.sender, _to, _value);

            success = true;

        } else {

            success = super.transfer(_to, _value);

        }

        require(success, "transfer failed");

    }



    /// @dev Calls transferFrom method and reverts if it fails.

    /// @param _from The address of the sender.

    /// @param _to The address of the recipient.

    /// @param _value The value to transfer.

    function _superTransferFrom(address _from, address _to, uint256 _value) internal {

        bool success = super.transferFrom(_from, _to, _value);

        require(success, "transfer failed");

    }



    /// @dev Emits an event when the callback failed.

    /// @param _from The address of the sender.

    /// @param _to The address of the recipient.

    /// @param _value The transferred value.

    function _callAfterTransfer(address _from, address _to, uint256 _value) internal {

        if (_to.isContract() && !_contractFallback(_from, _to, _value, new bytes(0))) {

            require(!isBridge(_to), "you can't transfer to bridge contract");

            require(_to != distributionAddress, "you can't transfer to Distribution contract");

            require(_to != privateOfferingDistributionAddress, "you can't transfer to PrivateOffering contract");

            require(_to != advisorsRewardDistributionAddress, "you can't transfer to AdvisorsReward contract");

            emit ContractFallbackCallFailed(_from, _to, _value);

        }

    }



    /// @dev Makes a callback after the transfer of tokens.

    /// @param _from The address of the sender.

    /// @param _to The address of the recipient.

    /// @param _value The transferred value.

    /// @param _data Custom data.

    /// @return Success status.

    function _contractFallback(

        address _from,

        address _to,

        uint256 _value,

        bytes memory _data

    ) private returns (bool) {

        string memory signature = "onTokenTransfer(address,uint256,bytes)";

        // solium-disable-next-line security/no-low-level-calls

        (bool success, ) = _to.call(abi.encodeWithSignature(signature, _from, _value, _data));

        return success;

    }

}









/**

 * @title ERC677MultiBridgeToken

 * @dev This contract extends ERC677BridgeToken to support several bridges simultaneously.

 */

contract ERC677MultiBridgeToken is IERC677MultiBridgeToken, ERC677BridgeToken {

    address public constant F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;

    uint256 internal constant MAX_BRIDGES = 50;

    mapping(address => address) public bridgePointers;

    uint256 public bridgeCount;



    event BridgeAdded(address indexed bridge);

    event BridgeRemoved(address indexed bridge);



    constructor(

        string memory _name,

        string memory _symbol,

        address _distributionAddress,

        address _privateOfferingDistributionAddress,

        address _advisorsRewardDistributionAddress

    ) public ERC677BridgeToken(

        _name,

        _symbol,

        _distributionAddress,

        _privateOfferingDistributionAddress,

        _advisorsRewardDistributionAddress

    ) {

        bridgePointers[F_ADDR] = F_ADDR; // empty bridge contracts list

    }



    /// @dev Adds one more bridge contract into the list.

    /// @param _bridge Bridge contract address.

    function addBridge(address _bridge) external onlyOwner {

        require(bridgeCount < MAX_BRIDGES, "can't add one more bridge due to a limit");

        require(_bridge.isContract(), "not a contract address");

        require(!isBridge(_bridge), "bridge already exists");



        address firstBridge = bridgePointers[F_ADDR];

        require(firstBridge != address(0), "first bridge is zero address");

        bridgePointers[F_ADDR] = _bridge;

        bridgePointers[_bridge] = firstBridge;

        bridgeCount = bridgeCount.add(1);



        emit BridgeAdded(_bridge);

    }



    /// @dev Removes one existing bridge contract from the list.

    /// @param _bridge Bridge contract address.

    function removeBridge(address _bridge) external onlyOwner {

        require(isBridge(_bridge), "bridge isn't existed");



        address nextBridge = bridgePointers[_bridge];

        address index = F_ADDR;

        address next = bridgePointers[index];

        require(next != address(0), "zero address found");



        while (next != _bridge) {

            index = next;

            next = bridgePointers[index];



            require(next != F_ADDR && next != address(0), "invalid address found");

        }



        bridgePointers[index] = nextBridge;

        delete bridgePointers[_bridge];

        bridgeCount = bridgeCount.sub(1);



        emit BridgeRemoved(_bridge);

    }



    /// @dev Returns all recorded bridge contract addresses.

    /// @return address[] Bridge contract addresses.

    function bridgeList() external view returns (address[] memory) {

        address[] memory list = new address[](bridgeCount);

        uint256 counter = 0;

        address nextBridge = bridgePointers[F_ADDR];

        require(nextBridge != address(0), "zero address found");



        while (nextBridge != F_ADDR) {

            list[counter] = nextBridge;

            nextBridge = bridgePointers[nextBridge];

            counter++;



            require(nextBridge != address(0), "zero address found");

        }



        return list;

    }



    /// @dev Checks if given address is included into bridge contracts list.

    /// @param _address Bridge contract address.

    /// @return bool true, if given address is a known bridge contract.

    function isBridge(address _address) public view returns (bool) {

        return _address != F_ADDR && bridgePointers[_address] != address(0);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC721.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



import "../../utils/Context.sol";

import "./IERC721.sol";

import "./IERC721Metadata.sol";

import "./IERC721Enumerable.sol";

import "./IERC721Receiver.sol";

import "../../introspection/ERC165.sol";

import "../../math/SafeMath.sol";

import "../../utils/Address.sol";

import "../../utils/EnumerableSet.sol";

import "../../utils/EnumerableMap.sol";

import "../../utils/Strings.sol";



/**

 * @title ERC721 Non-Fungible Token Standard basic implementation

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {

    using SafeMath for uint256;

    using Address for address;

    using EnumerableSet for EnumerableSet.UintSet;

    using EnumerableMap for EnumerableMap.UintToAddressMap;

    using Strings for uint256;



    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;



    // Mapping from holder address to their (enumerable) set of owned tokens

    mapping (address => EnumerableSet.UintSet) private _holderTokens;



    // Enumerable mapping from token ids to their owners

    EnumerableMap.UintToAddressMap private _tokenOwners;



    // Mapping from token ID to approved address

    mapping (uint256 => address) private _tokenApprovals;



    // Mapping from owner to operator approvals

    mapping (address => mapping (address => bool)) private _operatorApprovals;



    // Token name

    string private _name;



    // Token symbol

    string private _symbol;



    // Optional mapping for token URIs

    mapping (uint256 => string) private _tokenURIs;



    // Base URI

    string private _baseURI;



    /*

     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231

     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e

     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3

     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc

     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465

     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5

     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde

     *

     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^

     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd

     */

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;



    /*

     *     bytes4(keccak256('name()')) == 0x06fdde03

     *     bytes4(keccak256('symbol()')) == 0x95d89b41

     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd

     *

     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f

     */

    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;



    /*

     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd

     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59

     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7

     *

     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63

     */

    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;



    /**

     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.

     */

    constructor (string memory name_, string memory symbol_) {

        _name = name_;

        _symbol = symbol_;



        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721);

        _registerInterface(_INTERFACE_ID_ERC721_METADATA);

        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);

    }



    /**

     * @dev See {IERC721-balanceOf}.

     */

    function balanceOf(address owner) public view virtual override returns (uint256) {

        require(owner != address(0), "ERC721: balance query for the zero address");

        return _holderTokens[owner].length();

    }



    /**

     * @dev See {IERC721-ownerOf}.

     */

    function ownerOf(uint256 tokenId) public view virtual override returns (address) {

        return _tokenOwners.get(tokenId, "ERC721: owner query for nonexistent token");

    }



    /**

     * @dev See {IERC721Metadata-name}.

     */

    function name() public view virtual override returns (string memory) {

        return _name;

    }



    /**

     * @dev See {IERC721Metadata-symbol}.

     */

    function symbol() public view virtual override returns (string memory) {

        return _symbol;

    }



    /**

     * @dev See {IERC721Metadata-tokenURI}.

     */

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {

        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");



        string memory _tokenURI = _tokenURIs[tokenId];

        string memory base = baseURI();



        // If there is no base URI, return the token URI.

        if (bytes(base).length == 0) {

            return _tokenURI;

        }

        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).

        if (bytes(_tokenURI).length > 0) {

            return string(abi.encodePacked(base, _tokenURI));

        }

        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.

        return string(abi.encodePacked(base, tokenId.toString()));

    }



    /**

    * @dev Returns the base URI set via {_setBaseURI}. This will be

    * automatically added as a prefix in {tokenURI} to each token's URI, or

    * to the token ID if no specific URI is set for that token ID.

    */

    function baseURI() public view virtual returns (string memory) {

        return _baseURI;

    }



    /**

     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.

     */

    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {

        return _holderTokens[owner].at(index);

    }



    /**

     * @dev See {IERC721Enumerable-totalSupply}.

     */

    function totalSupply() public view virtual override returns (uint256) {

        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds

        return _tokenOwners.length();

    }



    /**

     * @dev See {IERC721Enumerable-tokenByIndex}.

     */

    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {

        (uint256 tokenId, ) = _tokenOwners.at(index);

        return tokenId;

    }



    /**

     * @dev See {IERC721-approve}.

     */

    function approve(address to, uint256 tokenId) public virtual override {

        address owner = ERC721.ownerOf(tokenId);

        require(to != owner, "ERC721: approval to current owner");



        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),

            "ERC721: approve caller is not owner nor approved for all"

        );



        _approve(to, tokenId);

    }



    /**

     * @dev See {IERC721-getApproved}.

     */

    function getApproved(uint256 tokenId) public view virtual override returns (address) {

        require(_exists(tokenId), "ERC721: approved query for nonexistent token");



        return _tokenApprovals[tokenId];

    }



    /**

     * @dev See {IERC721-setApprovalForAll}.

     */

    function setApprovalForAll(address operator, bool approved) public virtual override {

        require(operator != _msgSender(), "ERC721: approve to caller");



        _operatorApprovals[_msgSender()][operator] = approved;

        emit ApprovalForAll(_msgSender(), operator, approved);

    }



    /**

     * @dev See {IERC721-isApprovedForAll}.

     */

    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    /**

     * @dev See {IERC721-transferFrom}.

     */

    function transferFrom(address from, address to, uint256 tokenId) public virtual override {

        //solhint-disable-next-line max-line-length

        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");



        _transfer(from, to, tokenId);

    }



    /**

     * @dev See {IERC721-safeTransferFrom}.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {

        safeTransferFrom(from, to, tokenId, "");

    }



    /**

     * @dev See {IERC721-safeTransferFrom}.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {

        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        _safeTransfer(from, to, tokenId, _data);

    }



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * `_data` is additional data, it has no specified format and it is sent in call to `to`.

     *

     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.

     * implement alternative mechanisms to perform token transfer, such as signature-based.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {

        _transfer(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");

    }



    /**

     * @dev Returns whether `tokenId` exists.

     *

     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.

     *

     * Tokens start existing when they are minted (`_mint`),

     * and stop existing when they are burned (`_burn`).

     */

    function _exists(uint256 tokenId) internal view virtual returns (bool) {

        return _tokenOwners.contains(tokenId);

    }



    /**

     * @dev Returns whether `spender` is allowed to manage `tokenId`.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {

        require(_exists(tokenId), "ERC721: operator query for nonexistent token");

        address owner = ERC721.ownerOf(tokenId);

        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));

    }



    /**

     * @dev Safely mints `tokenId` and transfers it to `to`.

     *

     * Requirements:

     d*

     * - `tokenId` must not exist.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function _safeMint(address to, uint256 tokenId) internal virtual {

        _safeMint(to, tokenId, "");

    }



    /**

     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is

     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.

     */

    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {

        _mint(to, tokenId);

        require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");

    }



    /**

     * @dev Mints `tokenId` and transfers it to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible

     *

     * Requirements:

     *

     * - `tokenId` must not exist.

     * - `to` cannot be the zero address.

     *

     * Emits a {Transfer} event.

     */

    function _mint(address to, uint256 tokenId) internal virtual {

        require(to != address(0), "ERC721: mint to the zero address");

        require(!_exists(tokenId), "ERC721: token already minted");



        _beforeTokenTransfer(address(0), to, tokenId);



        _holderTokens[to].add(tokenId);



        _tokenOwners.set(tokenId, to);



        emit Transfer(address(0), to, tokenId);

    }



    /**

     * @dev Destroys `tokenId`.

     * The approval is cleared when the token is burned.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     *

     * Emits a {Transfer} event.

     */

    function _burn(uint256 tokenId) internal virtual {

        address owner = ERC721.ownerOf(tokenId); // internal owner



        _beforeTokenTransfer(owner, address(0), tokenId);



        // Clear approvals

        _approve(address(0), tokenId);



        // Clear metadata (if any)

        if (bytes(_tokenURIs[tokenId]).length != 0) {

            delete _tokenURIs[tokenId];

        }



        _holderTokens[owner].remove(tokenId);



        _tokenOwners.remove(tokenId);



        emit Transfer(owner, address(0), tokenId);

    }



    /**

     * @dev Transfers `tokenId` from `from` to `to`.

     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     *

     * Emits a {Transfer} event.

     */

    function _transfer(address from, address to, uint256 tokenId) internal virtual {

        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own"); // internal owner

        require(to != address(0), "ERC721: transfer to the zero address");



        _beforeTokenTransfer(from, to, tokenId);



        // Clear approvals from the previous owner

        _approve(address(0), tokenId);



        _holderTokens[from].remove(tokenId);

        _holderTokens[to].add(tokenId);



        _tokenOwners.set(tokenId, to);



        emit Transfer(from, to, tokenId);

    }



    /**

     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {

        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");

        _tokenURIs[tokenId] = _tokenURI;

    }



    /**

     * @dev Internal function to set the base URI for all token IDs. It is

     * automatically added as a prefix to the value returned in {tokenURI},

     * or to the token ID if {tokenURI} is empty.

     */

    function _setBaseURI(string memory baseURI_) internal virtual {

        _baseURI = baseURI_;

    }



    /**

     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.

     * The call is not executed if the target address is not a contract.

     *

     * @param from address representing the previous owner of the given token ID

     * @param to target address that will receive the tokens

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes optional data to send along with the call

     * @return bool whether the call correctly returned the expected magic value

     */

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)

        private returns (bool)

    {

        if (!to.isContract()) {

            return true;

        }

        bytes memory returndata = to.functionCall(abi.encodeWithSelector(

            IERC721Receiver(to).onERC721Received.selector,

            _msgSender(),

            from,

            tokenId,

            _data

        ), "ERC721: transfer to non ERC721Receiver implementer");

        bytes4 retval = abi.decode(returndata, (bytes4));

        return (retval == _ERC721_RECEIVED);

    }



    /**

     * @dev Approve `to` to operate on `tokenId`

     *

     * Emits an {Approval} event.

     */

    function _approve(address to, uint256 tokenId) internal virtual {

        _tokenApprovals[tokenId] = to;

        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner

    }



    /**

     * @dev Hook that is called before any token transfer. This includes minting

     * and burning.

     *

     * Calling conditions:

     *

     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be

     * transferred to `to`.

     * - When `from` is zero, `tokenId` will be minted for `to`.

     * - When `to` is zero, ``from``'s `tokenId` will be burned.

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC721BridgeToken.sol
File type: .sol
pragma solidity 0.7.5;



import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

import "../interfaces/IOwnable.sol";

import "../interfaces/IBurnableMintableERC721Token.sol";



/**

 * @title ERC721BridgeToken

 * @dev template token contract for bridged ERC721 tokens.

 */

contract ERC721BridgeToken is ERC721, IBurnableMintableERC721Token {

    address public bridgeContract;



    constructor(

        string memory _name,

        string memory _symbol,

        address _bridgeContract

    ) ERC721(_name, _symbol) {

        bridgeContract = _bridgeContract;

    }



    /**

     * @dev Throws if sender is not a bridge contract.

     */

    modifier onlyBridge() {

        require(msg.sender == bridgeContract);

        _;

    }



    /**

     * @dev Throws if sender is not a bridge contract or bridge contract owner.

     */

    modifier onlyOwner() {

        require(msg.sender == bridgeContract || msg.sender == IOwnable(bridgeContract).owner());

        _;

    }



    /**

     * @dev Tells if this contract implements the interface defined by

     * `interfaceId`. See the corresponding EIP165.

     * @return true, if interface is implemented.

     */

    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {

        bytes4 INTERFACE_ID_ERC165 = 0x01ffc9a7;

        bytes4 INTERFACE_ID_ERC721 = 0x80ac58cd;

        bytes4 INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;

        bytes4 INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;

        return

            interfaceId == INTERFACE_ID_ERC165 ||

            interfaceId == INTERFACE_ID_ERC721 ||

            interfaceId == INTERFACE_ID_ERC721_METADATA ||

            interfaceId == INTERFACE_ID_ERC721_ENUMERABLE;

    }



    /**

     * @dev Stub for preventing unneeded storage writes.

     * All supported interfaces are hardcoded in the supportsInterface function.

     */

    function _registerInterface(bytes4) internal override {}



    /**

     * @dev Mint new ERC721 token.

     * Only bridge contract is authorized to mint tokens.

     * @param _to address of the newly created token owner.

     * @param _tokenId unique identifier of the minted token.

     */

    function mint(address _to, uint256 _tokenId) external override onlyBridge {

        _safeMint(_to, _tokenId);

    }



    /**

     * @dev Burns some ERC721 token.

     * Only bridge contract is authorized to burn tokens.

     * @param _tokenId unique identifier of the burned token.

     */

    function burn(uint256 _tokenId) external override onlyBridge {

        _burn(_tokenId);

    }



    // hack to access private fields in ERC721 contract

    struct MetadataStorage {

        string name;

        string symbol;

    }



    /**

     * @dev Updated bridged token name/symbol parameters.

     * Only bridge owner or bridge itself can call this method.

     * @param _name new name parameter, will be saved as is, without additional suffixes like " from Mainnet".

     * @param _symbol new symbol parameter.

     */

    function setMetadata(string calldata _name, string calldata _symbol) external onlyOwner {

        require(bytes(_name).length > 0 && bytes(_symbol).length > 0);



        MetadataStorage storage metadata;

        assembly {

            metadata.slot := 6

        }

        metadata.name = _name;

        metadata.symbol = _symbol;

    }



    /**

     * @dev Sets the base URI for all tokens.

     * Can be called by bridge owner after token contract was instantiated.

     * @param _baseURI new base URI.

     */

    function setBaseURI(string calldata _baseURI) external onlyOwner {

        _setBaseURI(_baseURI);

    }



    /**

     * @dev Updates the bridge contract address.

     * Can be called by bridge owner after token contract was instantiated.

     * @param _bridgeContract address of the new bridge contract.

     */

    function setBridgeContract(address _bridgeContract) external onlyOwner {

        require(_bridgeContract != address(0));

        bridgeContract = _bridgeContract;

    }



    /**

     * @dev Sets the URI for the particular token.

     * Can be called by bridge owner after token bridging.

     * @param _tokenId URI for the bridged token metadata.

     * @param _tokenURI new token URI.

     */

    function setTokenURI(uint256 _tokenId, string calldata _tokenURI) external override onlyOwner {

        _setTokenURI(_tokenId, _tokenURI);

    }



    /**

     * @dev Tells the current version of the ERC721 token interfaces.

     */

    function getTokenInterfacesVersion()

        external

        pure

        returns (

            uint64 major,

            uint64 minor,

            uint64 patch

        )

    {

        return (1, 1, 0);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC721Relayer.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../../interfaces/IBurnableMintableERC721Token.sol";

import "../../../ReentrancyGuard.sol";

import "./BaseRelayer.sol";



/**

 * @title ERC721Relayer

 * @dev Functionality for bridging multiple ERC721 tokens to the other side of the bridge.

 */

abstract contract ERC721Relayer is BaseRelayer, ReentrancyGuard {

    /**

     * @dev ERC721 transfer callback function.

     * @param _from address of token sender.

     * @param _tokenId id of the transferred token.

     * @param _data additional transfer data, can be used for passing alternative receiver address.

     */

    function onERC721Received(

        address,

        address _from,

        uint256 _tokenId,

        bytes calldata _data

    ) external returns (bytes4) {

        if (!lock()) {

            bridgeSpecificActionsOnTokenTransfer(

                msg.sender,

                _from,

                _chooseReceiver(_from, _data),

                _singletonArray(_tokenId),

                new uint256[](0)

            );

        }

        return msg.sig;

    }



    /**

     * @dev Initiate the bridge operation for some token from msg.sender.

     * The user should first call Approve method of the ERC721 token.

     * @param token bridged token contract address.

     * @param _receiver address that will receive the token on the other network.

     * @param _tokenId id of the token to be transferred to the other network.

     */

    function relayToken(

        IERC721 token,

        address _receiver,

        uint256 _tokenId

    ) external {

        _relayToken(token, _receiver, _tokenId);

    }



    /**

     * @dev Initiate the bridge operation for some token from msg.sender to msg.sender on the other side.

     * The user should first call Approve method of the ERC721 token.

     * @param token bridged token contract address.

     * @param _tokenId id of token to be transferred to the other network.

     */

    function relayToken(IERC721 token, uint256 _tokenId) external {

        _relayToken(token, msg.sender, _tokenId);

    }



    /**

     * @dev Validates that the token amount is inside the limits, calls transferFrom to transfer the token to the contract

     * and invokes the method to burn/lock the token and unlock/mint the token on the other network.

     * The user should first call Approve method of the ERC721 token.

     * @param _token bridge token contract address.

     * @param _receiver address that will receive the token on the other network.

     * @param _tokenId id of the token to be transferred to the other network.

     */

    function _relayToken(

        IERC721 _token,

        address _receiver,

        uint256 _tokenId

    ) internal {

        // This lock is to prevent calling bridgeSpecificActionsOnTokenTransfer twice.

        // When transferFrom is called, after the transfer, the ERC721 token might call onERC721Received from this contract

        // which will call bridgeSpecificActionsOnTokenTransfer.

        require(!lock());



        setLock(true);

        _token.transferFrom(msg.sender, address(this), _tokenId);

        setLock(false);

        bridgeSpecificActionsOnTokenTransfer(

            address(_token),

            msg.sender,

            _receiver,

            _singletonArray(_tokenId),

            new uint256[](0)

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ERC721TokenProxy.sol
File type: .sol
pragma solidity 0.7.5;



import "@openzeppelin/contracts/utils/Address.sol";

import "../../../../upgradeability/Proxy.sol";

import "../../../../interfaces/IOwnable.sol";



/**

 * @title ERC721TokenProxy

 * @dev Helps to reduces the size of the deployed bytecode for automatically created tokens, by using a proxy contract.

 */

contract ERC721TokenProxy is Proxy {

    // storage layout is copied from ERC721BridgeToken.sol

    mapping(bytes4 => bool) private _supportedInterfaces;

    mapping(address => uint256) private _holderTokens;



    //EnumerableMap.UintToAddressMap private _tokenOwners;

    uint256[] private _tokenOwnersEntries;

    mapping(bytes32 => uint256) private _tokenOwnersIndexes;



    mapping(uint256 => address) private _tokenApprovals;

    mapping(address => mapping(address => bool)) private _operatorApprovals;

    string private name;

    string private symbol;

    mapping(uint256 => string) private _tokenURIs;

    string private _baseURI;

    address private bridgeContract;



    /**

     * @dev Creates an upgradeable token proxy for ERC721BridgeToken.sol, initializes its eternalStorage.

     * @param _tokenImage address of the token image used for mirroring all functions.

     * @param _name token name.

     * @param _symbol token symbol.

     * @param _owner address of the owner for this contract.

     */

    constructor(

        address _tokenImage,

        string memory _name,

        string memory _symbol,

        address _owner

    ) {

        assembly {

            // EIP 1967

            // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)

            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _tokenImage)

        }

        name = _name;

        symbol = _symbol;

        bridgeContract = _owner; // _owner == HomeOmnibridgeNFT/ForeignOmnibridgeNFT mediator

    }



    /**

     * @dev Retrieves the implementation contract address, mirrored token image.

     * @return impl token image address.

     */

    function implementation() public view override returns (address impl) {

        assembly {

            impl := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)

        }

    }



    /**

     * @dev Updates the implementation contract address.

     * Only the bridge and bridge owner can call this method.

     * @param _implementation address of the new implementation.

     */

    function setImplementation(address _implementation) external {

        require(msg.sender == bridgeContract || msg.sender == IOwnable(bridgeContract).owner());

        require(_implementation != address(0));

        require(Address.isContract(_implementation));

        assembly {

            // EIP 1967

            // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)

            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _implementation)

        }

    }



    /**

     * @dev Tells the current version of the ERC721 token proxy interfaces.

     */

    function getTokenProxyInterfacesVersion()

        external

        pure

        returns (

            uint64 major,

            uint64 minor,

            uint64 patch

        )

    {

        return (1, 0, 0);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\EternalStorage.sol
File type: .sol
pragma solidity 0.7.5;



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {

    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\EternalStorageProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2018-10-18

*/



pragma solidity 0.4.24;



// File: contracts/upgradeability/EternalStorage.sol



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {



    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;



}



// File: contracts/upgradeability/UpgradeabilityOwnerStorage.sol



/**

 * @title UpgradeabilityOwnerStorage

 * @dev This contract keeps track of the upgradeability owner

 */

contract UpgradeabilityOwnerStorage {

    // Owner of the contract

    address private _upgradeabilityOwner;



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function upgradeabilityOwner() public view returns (address) {

        return _upgradeabilityOwner;

    }



    /**

    * @dev Sets the address of the owner

    */

    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {

        _upgradeabilityOwner = newUpgradeabilityOwner;

    }

}



// File: contracts/upgradeability/Proxy.sol



/**

 * @title Proxy

 * @dev Gives the possibility to delegate any call to a foreign implementation.

 */

contract Proxy {



  /**

  * @dev Tells the address of the implementation where every call will be delegated.

  * @return address of the implementation to which it will be delegated

  */

    function implementation() public view returns (address);



  /**

  * @dev Fallback function allowing to perform a delegatecall to the given implementation.

  * This function will return whatever the implementation call returns

  */

    function () payable public {

        address _impl = implementation();

        require(_impl != address(0));

        assembly {

            /*

                0x40 is the "free memory slot", meaning a pointer to next slot of empty memory. mload(0x40)

                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty

                memory. It's needed because we're going to write the return data of delegatecall to the

                free memory slot.

            */

            let ptr := mload(0x40)

            /*

                `calldatacopy` is copy calldatasize bytes from calldata

                First argument is the destination to which data is copied(ptr)

                Second argument specifies the start position of the copied data.

                    Since calldata is sort of its own unique location in memory,

                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.

                    That's always going to be the zeroth byte of the function selector.

                Third argument, calldatasize, specifies how much data will be copied.

                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)

            */

            calldatacopy(ptr, 0, calldatasize)

            /*

                delegatecall params explained:

                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives

                    us the amount of gas still available to execution



                _impl: address of the contract to delegate to



                ptr: to pass copied data



                calldatasize: loads the size of `bytes memory data`, same as msg.data.length



                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,

                        these are set to 0, 0 so the output data will not be written to memory. The output

                        data will be read using `returndatasize` and `returdatacopy` instead.



                result: This will be 0 if the call fails and 1 if it succeeds

            */

            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)

            /*



            */

            /*

                ptr current points to the value stored at 0x40,

                because we assigned it like ptr := mload(0x40).

                Because we use 0x40 as a free memory pointer,

                we want to make sure that the next time we want to allocate memory,

                we aren't overwriting anything important.

                So, by adding ptr and returndatasize,

                we get a memory location beyond the end of the data we will be copying to ptr.

                We place this in at 0x40, and any reads from 0x40 will now read from free memory

            */

            mstore(0x40, add(ptr, returndatasize))

            /*

                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the

                    slot it will copy to, 0 means copy from the beginning of the return data, and size is

                    the amount of data to copy.

                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall

            */

            returndatacopy(ptr, 0, returndatasize)



            /*

                if `result` is 0, revert.

                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was

                copied to `ptr` from the delegatecall return data

            */

            switch result

            case 0 { revert(ptr, returndatasize) }

            default { return(ptr, returndatasize) }

        }

    }

}



// File: contracts/upgradeability/UpgradeabilityStorage.sol



/**

 * @title UpgradeabilityStorage

 * @dev This contract holds all the necessary state variables to support the upgrade functionality

 */

contract UpgradeabilityStorage {

    // Version name of the current implementation

    uint256 internal _version;



    // Address of the current implementation

    address internal _implementation;



    /**

    * @dev Tells the version name of the current implementation

    * @return string representing the name of the current version

    */

    function version() public view returns (uint256) {

        return _version;

    }



    /**

    * @dev Tells the address of the current implementation

    * @return address of the current implementation

    */

    function implementation() public view returns (address) {

        return _implementation;

    }

}



// File: contracts/upgradeability/UpgradeabilityProxy.sol



/**

 * @title UpgradeabilityProxy

 * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded

 */

contract UpgradeabilityProxy is Proxy, UpgradeabilityStorage {

    /**

    * @dev This event will be emitted every time the implementation gets upgraded

    * @param version representing the version name of the upgraded implementation

    * @param implementation representing the address of the upgraded implementation

    */

    event Upgraded(uint256 version, address indexed implementation);



    /**

    * @dev Upgrades the implementation address

    * @param version representing the version name of the new implementation to be set

    * @param implementation representing the address of the new implementation to be set

    */

    function _upgradeTo(uint256 version, address implementation) internal {

        require(_implementation != implementation);

        require(version > _version);

        _version = version;

        _implementation = implementation;

        emit Upgraded(version, implementation);

    }

}



// File: contracts/upgradeability/OwnedUpgradeabilityProxy.sol



/**

 * @title OwnedUpgradeabilityProxy

 * @dev This contract combines an upgradeability proxy with basic authorization control functionalities

 */

contract OwnedUpgradeabilityProxy is UpgradeabilityOwnerStorage, UpgradeabilityProxy {

  /**

  * @dev Event to show ownership has been transferred

  * @param previousOwner representing the address of the previous owner

  * @param newOwner representing the address of the new owner

  */

    event ProxyOwnershipTransferred(address previousOwner, address newOwner);



    /**

    * @dev the constructor sets the original owner of the contract to the sender account.

    */

    constructor() public {

        setUpgradeabilityOwner(msg.sender);

    }



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyProxyOwner() {

        require(msg.sender == proxyOwner());

        _;

    }



    /**

    * @dev Tells the address of the proxy owner

    * @return the address of the proxy owner

    */

    function proxyOwner() public view returns (address) {

        return upgradeabilityOwner();

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner The address to transfer ownership to.

    */

    function transferProxyOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0));

        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);

        setUpgradeabilityOwner(newOwner);

    }



    /**

    * @dev Allows the upgradeability owner to upgrade the current version of the proxy.

    * @param version representing the version name of the new implementation to be set.

    * @param implementation representing the address of the new implementation to be set.

    */

    function upgradeTo(uint256 version, address implementation) public onlyProxyOwner {

        _upgradeTo(version, implementation);

    }



    /**

    * @dev Allows the upgradeability owner to upgrade the current version of the proxy and call the new implementation

    * to initialize whatever is needed through a low level call.

    * @param version representing the version name of the new implementation to be set.

    * @param implementation representing the address of the new implementation to be set.

    * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function

    * signature of the implementation to be called with the needed payload

    */

    function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {

        upgradeTo(version, implementation);

        require(address(this).call.value(msg.value)(data));

    }

}



// File: contracts/upgradeability/EternalStorageProxy.sol



/**

 * @title EternalStorageProxy

 * @dev This proxy holds the storage of the token contract and delegates every call to the current implementation set.

 * Besides, it allows to upgrade the token's behaviour towards further implementations, and provides basic

 * authorization control functionalities

 */

contract EternalStorageProxy is OwnedUpgradeabilityProxy, EternalStorage {}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\FailedMessagesProcessor.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../BasicAMBMediator.sol";

import "./BridgeOperationsStorage.sol";



/**

 * @title FailedMessagesProcessor

 * @dev Functionality for fixing failed bridging operations.

 */

abstract contract FailedMessagesProcessor is BasicAMBMediator, BridgeOperationsStorage {

    event FailedMessageFixed(bytes32 indexed messageId, address token);



    /**

     * @dev Method to be called when a bridged message execution failed. It will generate a new message requesting to

     * fix/roll back the transferred assets on the other network.

     * It is important to specify parameters very carefully.

     * Please, take exact values from the TokensBridgingInitiated event. Otherwise, execution will revert.

     * @param _messageId id of the message which execution failed.

     * @param _token address of the bridged token on the other side of the bridge.

     * @param _sender address of the tokens sender on the other side.

     * @param _tokenIds ids of the sent tokens.

     * @param _values amounts of tokens sent.

     */

    function requestFailedMessageFix(

        bytes32 _messageId,

        address _token,

        address _sender,

        uint256[] calldata _tokenIds,

        uint256[] calldata _values

    ) external {

        require(_tokenIds.length > 0);

        require(_values.length == 0 || _tokenIds.length == _values.length);



        IAMB bridge = bridgeContract();

        require(!bridge.messageCallStatus(_messageId));

        require(bridge.failedMessageReceiver(_messageId) == address(this));

        require(bridge.failedMessageSender(_messageId) == mediatorContractOnOtherSide());



        bytes memory data =

            abi.encodeWithSelector(this.fixFailedMessage.selector, _messageId, _token, _sender, _tokenIds, _values);

        _passMessage(data, false);

    }



    /**

     * @dev Handles the request to fix transferred assets which bridged message execution failed on the other network.

     * Compares the reconstructed message checksum with the original one. Revert if message params were altered.

     * @param _messageId id of the message which execution failed on this side of the bridge.

     * @param _token address of the bridged token on this side of the bridge.

     * @param _sender address of the tokens sender on this side of the bridge.

     * @param _tokenIds ids of the sent tokens.

     * @param _values amounts of tokens sent.

     */

    function fixFailedMessage(

        bytes32 _messageId,

        address _token,

        address _sender,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) public onlyMediator {

        require(!messageFixed(_messageId));

        require(getMessageChecksum(_messageId) == _messageChecksum(_token, _sender, _tokenIds, _values));



        setMessageFixed(_messageId);

        executeActionOnFixedTokens(_token, _sender, _tokenIds, _values);

        emit FailedMessageFixed(_messageId, _token);

    }



    /**

     * @dev Tells if a message sent to the AMB bridge has been fixed.

     * @return bool indicating the status of the message.

     */

    function messageFixed(bytes32 _messageId) public view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("messageFixed", _messageId))];

    }



    /**

     * @dev Sets that the message sent to the AMB bridge has been fixed.

     * @param _messageId of the message sent to the bridge.

     */

    function setMessageFixed(bytes32 _messageId) internal {

        boolStorage[keccak256(abi.encodePacked("messageFixed", _messageId))] = true;

    }



    function executeActionOnFixedTokens(

        address _token,

        address _recipient,

        uint256[] memory _tokenIds,

        uint256[] memory _values

    ) internal virtual;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ForeignAMB.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-10-03

*/



// File: contracts/interfaces/IBridgeValidators.sol



pragma solidity 0.4.24;



interface IBridgeValidators {

    function isValidator(address _validator) external view returns (bool);

    function requiredSignatures() external view returns (uint256);

    function owner() external view returns (address);

}



// File: contracts/libraries/Message.sol



pragma solidity 0.4.24;





library Message {

    function addressArrayContains(address[] array, address value) internal pure returns (bool) {

        for (uint256 i = 0; i < array.length; i++) {

            if (array[i] == value) {

                return true;

            }

        }

        return false;

    }

    // layout of message :: bytes:

    // offset  0: 32 bytes :: uint256 - message length

    // offset 32: 20 bytes :: address - recipient address

    // offset 52: 32 bytes :: uint256 - value

    // offset 84: 32 bytes :: bytes32 - transaction hash

    // offset 116: 20 bytes :: address - contract address to prevent double spending



    // mload always reads 32 bytes.

    // so we can and have to start reading recipient at offset 20 instead of 32.

    // if we were to read at 32 the address would contain part of value and be corrupted.

    // when reading from offset 20 mload will read 12 bytes (most of them zeros) followed

    // by the 20 recipient address bytes and correctly convert it into an address.

    // this saves some storage/gas over the alternative solution

    // which is padding address to 32 bytes and reading recipient at offset 32.

    // for more details see discussion in:

    // https://github.com/paritytech/parity-bridge/issues/61

    function parseMessage(bytes message)

        internal

        pure

        returns (address recipient, uint256 amount, bytes32 txHash, address contractAddress)

    {

        require(isMessageValid(message));

        assembly {

            recipient := mload(add(message, 20))

            amount := mload(add(message, 52))

            txHash := mload(add(message, 84))

            contractAddress := mload(add(message, 104))

        }

    }



    function isMessageValid(bytes _msg) internal pure returns (bool) {

        return _msg.length == requiredMessageLength();

    }



    function requiredMessageLength() internal pure returns (uint256) {

        return 104;

    }



    function recoverAddressFromSignedMessage(bytes signature, bytes message, bool isAMBMessage)

        internal

        pure

        returns (address)

    {

        require(signature.length == 65);

        bytes32 r;

        bytes32 s;

        bytes1 v;



        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := mload(add(signature, 0x60))

        }

        require(uint8(v) == 27 || uint8(v) == 28);

        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0);



        return ecrecover(hashMessage(message, isAMBMessage), uint8(v), r, s);

    }



    function hashMessage(bytes message, bool isAMBMessage) internal pure returns (bytes32) {

        bytes memory prefix = "\x19Ethereum Signed Message:\n";

        if (isAMBMessage) {

            return keccak256(abi.encodePacked(prefix, uintToString(message.length), message));

        } else {

            string memory msgLength = "104";

            return keccak256(abi.encodePacked(prefix, msgLength, message));

        }

    }



    /**

    * @dev Validates provided signatures, only first requiredSignatures() number

    * of signatures are going to be validated, these signatures should be from different validators.

    * @param _message bytes message used to generate signatures

    * @param _signatures bytes blob with signatures to be validated.

    * First byte X is a number of signatures in a blob,

    * next X bytes are v components of signatures,

    * next 32 * X bytes are r components of signatures,

    * next 32 * X bytes are s components of signatures.

    * @param _validatorContract contract, which conforms to the IBridgeValidators interface,

    * where info about current validators and required signatures is stored.

    * @param isAMBMessage true if _message is an AMB message with arbitrary length.

    */

    function hasEnoughValidSignatures(

        bytes _message,

        bytes _signatures,

        IBridgeValidators _validatorContract,

        bool isAMBMessage

    ) internal view {

        require(isAMBMessage || isMessageValid(_message));

        uint256 requiredSignatures = _validatorContract.requiredSignatures();

        uint256 amount;

        assembly {

            amount := and(mload(add(_signatures, 1)), 0xff)

        }

        require(amount >= requiredSignatures);

        bytes32 hash = hashMessage(_message, isAMBMessage);

        address[] memory encounteredAddresses = new address[](requiredSignatures);



        for (uint256 i = 0; i < requiredSignatures; i++) {

            uint8 v;

            bytes32 r;

            bytes32 s;

            uint256 posr = 33 + amount + 32 * i;

            uint256 poss = posr + 32 * amount;

            assembly {

                v := mload(add(_signatures, add(2, i)))

                r := mload(add(_signatures, posr))

                s := mload(add(_signatures, poss))

            }



            address recoveredAddress = ecrecover(hash, v, r, s);

            require(_validatorContract.isValidator(recoveredAddress));

            require(!addressArrayContains(encounteredAddresses, recoveredAddress));

            encounteredAddresses[i] = recoveredAddress;

        }

    }



    function uintToString(uint256 i) internal pure returns (string) {

        if (i == 0) return "0";

        uint256 j = i;

        uint256 length;

        while (j != 0) {

            length++;

            j /= 10;

        }

        bytes memory bstr = new bytes(length);

        uint256 k = length - 1;

        while (i != 0) {

            bstr[k--] = bytes1(48 + (i % 10));

            i /= 10;

        }

        return string(bstr);

    }

}



// File: contracts/libraries/ArbitraryMessage.sol



pragma solidity 0.4.24;



library ArbitraryMessage {

    /**

    * @dev Unpacks data fields from AMB message

    * layout of message :: bytes:

    * offset  0              : 32 bytes :: uint256 - message length

    * offset 32              : 32 bytes :: bytes32 - messageId

    * offset 64              : 20 bytes :: address - sender address

    * offset 84              : 20 bytes :: address - executor contract

    * offset 104             : 4 bytes  :: uint32  - gasLimit

    * offset 108             : 1 bytes  :: uint8   - source chain id length (X)

    * offset 109             : 1 bytes  :: uint8   - destination chain id length (Y)

    * offset 110             : 1 bytes  :: uint8   - dataType

    * offset 111             : X bytes  :: bytes   - source chain id

    * offset 111 + X         : Y bytes  :: bytes   - destination chain id



    * NOTE: when message structure is changed, make sure that MESSAGE_PACKING_VERSION from VersionableAMB is updated as well

    * NOTE: assembly code uses calldatacopy, make sure that message is passed as the first argument in the calldata

    * @param _data encoded message

    */

    function unpackData(bytes _data)

        internal

        pure

        returns (

            bytes32 messageId,

            address sender,

            address executor,

            uint32 gasLimit,

            uint8 dataType,

            uint256[2] chainIds,

            bytes memory data

        )

    {

        // 32 (message id) + 20 (sender) + 20 (executor) + 4 (gasLimit) + 1 (source chain id length) + 1 (destination chain id length) + 1 (dataType)

        uint256 srcdataptr = 32 + 20 + 20 + 4 + 1 + 1 + 1;

        uint256 datasize;



        assembly {

            messageId := mload(add(_data, 32)) // 32 bytes

            sender := and(mload(add(_data, 52)), 0xffffffffffffffffffffffffffffffffffffffff) // 20 bytes



            // executor (20 bytes) + gasLimit (4 bytes) + srcChainIdLength (1 byte) + dstChainIdLength (1 bytes) + dataType (1 byte) + remainder (5 bytes)

            let blob := mload(add(_data, 84))



            // after bit shift left 12 bytes are zeros automatically

            executor := shr(96, blob)

            gasLimit := and(shr(64, blob), 0xffffffff)



            dataType := byte(26, blob)



            // load source chain id length

            let chainIdLength := byte(24, blob)



            // at this moment srcdataptr points to sourceChainId



            // mask for sourceChainId

            // e.g. length X -> (1 << (X * 8)) - 1

            let mask := sub(shl(shl(3, chainIdLength), 1), 1)



            // increase payload offset by length of source chain id

            srcdataptr := add(srcdataptr, chainIdLength)



            // write sourceChainId

            mstore(chainIds, and(mload(add(_data, srcdataptr)), mask))



            // at this moment srcdataptr points to destinationChainId



            // load destination chain id length

            chainIdLength := byte(25, blob)



            // mask for destinationChainId

            // e.g. length X -> (1 << (X * 8)) - 1

            mask := sub(shl(shl(3, chainIdLength), 1), 1)



            // increase payload offset by length of destination chain id

            srcdataptr := add(srcdataptr, chainIdLength)



            // write destinationChainId

            mstore(add(chainIds, 32), and(mload(add(_data, srcdataptr)), mask))



            // at this moment srcdataptr points to payload



            // datasize = message length - payload offset

            datasize := sub(mload(_data), srcdataptr)

        }



        data = new bytes(datasize);

        assembly {

            // 36 = 4 (selector) + 32 (bytes length header)

            srcdataptr := add(srcdataptr, 36)



            // calldataload(4) - offset of first bytes argument in the calldata

            calldatacopy(add(data, 32), add(calldataload(4), srcdataptr), datasize)

        }

    }

}



// File: contracts/interfaces/IUpgradeabilityOwnerStorage.sol



pragma solidity 0.4.24;



interface IUpgradeabilityOwnerStorage {

    function upgradeabilityOwner() external view returns (address);

}



// File: contracts/upgradeable_contracts/Upgradeable.sol



pragma solidity 0.4.24;





contract Upgradeable {

    // Avoid using onlyUpgradeabilityOwner name to prevent issues with implementation from proxy contract

    modifier onlyIfUpgradeabilityOwner() {

        require(msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner());

        /* solcov ignore next */

        _;

    }

}



// File: contracts/upgradeability/EternalStorage.sol



pragma solidity 0.4.24;



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {

    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;



}



// File: contracts/upgradeable_contracts/Initializable.sol



pragma solidity 0.4.24;





contract Initializable is EternalStorage {

    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked("isInitialized"))



    function setInitialize() internal {

        boolStorage[INITIALIZED] = true;

    }



    function isInitialized() public view returns (bool) {

        return boolStorage[INITIALIZED];

    }

}



// File: contracts/upgradeable_contracts/InitializableBridge.sol



pragma solidity 0.4.24;





contract InitializableBridge is Initializable {

    bytes32 internal constant DEPLOYED_AT_BLOCK = 0xb120ceec05576ad0c710bc6e85f1768535e27554458f05dcbb5c65b8c7a749b0; // keccak256(abi.encodePacked("deployedAtBlock"))



    function deployedAtBlock() external view returns (uint256) {

        return uintStorage[DEPLOYED_AT_BLOCK];

    }

}



// File: openzeppelin-solidity/contracts/AddressUtils.sol



pragma solidity ^0.4.24;





/**

 * Utility library of inline functions on addresses

 */

library AddressUtils {



  /**

   * Returns whether the target address is a contract

   * @dev This function will return false if invoked during the constructor of a contract,

   * as the code is not actually created until after the constructor finishes.

   * @param _addr address to check

   * @return whether the target address is a contract

   */

  function isContract(address _addr) internal view returns (bool) {

    uint256 size;

    // XXX Currently there is no better way to check if there is a contract in an address

    // than to check the size of the code at that address.

    // See https://ethereum.stackexchange.com/a/14016/36603

    // for more details about how this works.

    // TODO Check this again before the Serenity release, because all addresses will be

    // contracts then.

    // solium-disable-next-line security/no-inline-assembly

    assembly { size := extcodesize(_addr) }

    return size > 0;

  }



}



// File: contracts/upgradeable_contracts/ValidatorStorage.sol



pragma solidity 0.4.24;



contract ValidatorStorage {

    bytes32 internal constant VALIDATOR_CONTRACT = 0x5a74bb7e202fb8e4bf311841c7d64ec19df195fee77d7e7ae749b27921b6ddfe; // keccak256(abi.encodePacked("validatorContract"))

}



// File: contracts/upgradeable_contracts/Validatable.sol



pragma solidity 0.4.24;









contract Validatable is EternalStorage, ValidatorStorage {

    function validatorContract() public view returns (IBridgeValidators) {

        return IBridgeValidators(addressStorage[VALIDATOR_CONTRACT]);

    }



    modifier onlyValidator() {

        require(validatorContract().isValidator(msg.sender));

        /* solcov ignore next */

        _;

    }



    function requiredSignatures() public view returns (uint256) {

        return validatorContract().requiredSignatures();

    }



}



// File: contracts/upgradeable_contracts/Ownable.sol



pragma solidity 0.4.24;







/**

 * @title Ownable

 * @dev This contract has an owner address providing basic authorization control

 */

contract Ownable is EternalStorage {

    bytes4 internal constant UPGRADEABILITY_OWNER = 0x6fde8202; // upgradeabilityOwner()



    /**

    * @dev Event to show ownership has been transferred

    * @param previousOwner representing the address of the previous owner

    * @param newOwner representing the address of the new owner

    */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner());

        /* solcov ignore next */

        _;

    }



    /**

    * @dev Throws if called by any account other than contract itself or owner.

    */

    modifier onlyRelevantSender() {

        // proxy owner if used through proxy, address(0) otherwise

        require(

            !address(this).call(abi.encodeWithSelector(UPGRADEABILITY_OWNER)) || // covers usage without calling through storage proxy

                msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner() || // covers usage through regular proxy calls

                msg.sender == address(this) // covers calls through upgradeAndCall proxy method

        );

        /* solcov ignore next */

        _;

    }



    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked("owner"))



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function owner() public view returns (address) {

        return addressStorage[OWNER];

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner the address to transfer ownership to.

    */

    function transferOwnership(address newOwner) external onlyOwner {

        _setOwner(newOwner);

    }



    /**

    * @dev Sets a new owner address

    */

    function _setOwner(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner(), newOwner);

        addressStorage[OWNER] = newOwner;

    }

}



// File: contracts/upgradeable_contracts/Sacrifice.sol



pragma solidity 0.4.24;



contract Sacrifice {

    constructor(address _recipient) public payable {

        selfdestruct(_recipient);

    }

}



// File: contracts/libraries/Address.sol



pragma solidity 0.4.24;





/**

 * @title Address

 * @dev Helper methods for Address type.

 */

library Address {

    /**

    * @dev Try to send native tokens to the address. If it fails, it will force the transfer by creating a selfdestruct contract

    * @param _receiver address that will receive the native tokens

    * @param _value the amount of native tokens to send

    */

    function safeSendValue(address _receiver, uint256 _value) internal {

        if (!_receiver.send(_value)) {

            (new Sacrifice).value(_value)(_receiver);

        }

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.4.24;





/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (_a == 0) {

      return 0;

    }



    c = _a * _b;

    assert(c / _a == _b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {

    // assert(_b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = _a / _b;

    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold

    return _a / _b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {

    assert(_b <= _a);

    return _a - _b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    c = _a + _b;

    assert(c >= _a);

    return c;

  }

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol



pragma solidity ^0.4.24;





/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * See https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address _who) public view returns (uint256);

  function transfer(address _to, uint256 _value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.4.24;







/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

  function allowance(address _owner, address _spender)

    public view returns (uint256);



  function transferFrom(address _from, address _to, uint256 _value)

    public returns (bool);



  function approve(address _spender, uint256 _value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}



// File: contracts/interfaces/ERC677.sol



pragma solidity 0.4.24;





contract ERC677 is ERC20 {

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);



    function transferAndCall(address, uint256, bytes) external returns (bool);



    function increaseAllowance(address spender, uint256 addedValue) public returns (bool);

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool);

}



contract LegacyERC20 {

    function transfer(address _spender, uint256 _value) public; // returns (bool);

    function transferFrom(address _owner, address _spender, uint256 _value) public; // returns (bool);

}



// File: contracts/libraries/SafeERC20.sol



pragma solidity 0.4.24;







/**

 * @title SafeERC20

 * @dev Helper methods for safe token transfers.

 * Functions perform additional checks to be sure that token transfer really happened.

 */

library SafeERC20 {

    using SafeMath for uint256;



    /**

    * @dev Same as ERC20.transfer(address,uint256) but with extra consistency checks.

    * @param _token address of the token contract

    * @param _to address of the receiver

    * @param _value amount of tokens to send

    */

    function safeTransfer(address _token, address _to, uint256 _value) internal {

        LegacyERC20(_token).transfer(_to, _value);

        assembly {

            if returndatasize {

                returndatacopy(0, 0, 32)

                if iszero(mload(0)) {

                    revert(0, 0)

                }

            }

        }

    }



    /**

    * @dev Same as ERC20.transferFrom(address,address,uint256) but with extra consistency checks.

    * @param _token address of the token contract

    * @param _from address of the sender

    * @param _value amount of tokens to send

    */

    function safeTransferFrom(address _token, address _from, uint256 _value) internal {

        LegacyERC20(_token).transferFrom(_from, address(this), _value);

        assembly {

            if returndatasize {

                returndatacopy(0, 0, 32)

                if iszero(mload(0)) {

                    revert(0, 0)

                }

            }

        }

    }

}



// File: contracts/upgradeable_contracts/Claimable.sol



pragma solidity 0.4.24;







/**

 * @title Claimable

 * @dev Implementation of the claiming utils that can be useful for withdrawing accidentally sent tokens that are not used in bridge operations.

 */

contract Claimable {

    using SafeERC20 for address;



    /**

     * Throws if a given address is equal to address(0)

     */

    modifier validAddress(address _to) {

        require(_to != address(0));

        /* solcov ignore next */

        _;

    }



    /**

     * @dev Withdraws the erc20 tokens or native coins from this contract.

     * Caller should additionally check that the claimed token is not a part of bridge operations (i.e. that token != erc20token()).

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimValues(address _token, address _to) internal validAddress(_to) {

        if (_token == address(0)) {

            claimNativeCoins(_to);

        } else {

            claimErc20Tokens(_token, _to);

        }

    }



    /**

     * @dev Internal function for withdrawing all native coins from the contract.

     * @param _to address of the coins receiver.

     */

    function claimNativeCoins(address _to) internal {

        uint256 value = address(this).balance;

        Address.safeSendValue(_to, value);

    }



    /**

     * @dev Internal function for withdrawing all tokens of ssome particular ERC20 contract from this contract.

     * @param _token address of the claimed ERC20 token.

     * @param _to address of the tokens receiver.

     */

    function claimErc20Tokens(address _token, address _to) internal {

        ERC20Basic token = ERC20Basic(_token);

        uint256 balance = token.balanceOf(this);

        _token.safeTransfer(_to, balance);

    }

}



// File: contracts/upgradeable_contracts/VersionableBridge.sol



pragma solidity 0.4.24;



contract VersionableBridge {

    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {

        return (6, 1, 0);

    }



    /* solcov ignore next */

    function getBridgeMode() external pure returns (bytes4);

}



// File: contracts/upgradeable_contracts/DecimalShiftBridge.sol



pragma solidity 0.4.24;







contract DecimalShiftBridge is EternalStorage {

    using SafeMath for uint256;



    bytes32 internal constant DECIMAL_SHIFT = 0x1e8ecaafaddea96ed9ac6d2642dcdfe1bebe58a930b1085842d8fc122b371ee5; // keccak256(abi.encodePacked("decimalShift"))



    /**

    * @dev Internal function for setting the decimal shift for bridge operations.

    * Decimal shift can be positive, negative, or equal to zero.

    * It has the following meaning: N tokens in the foreign chain are equivalent to N * pow(10, shift) tokens on the home side.

    * @param _shift new value of decimal shift.

    */

    function _setDecimalShift(int256 _shift) internal {

        // since 1 wei * 10**77 > 2**255, it does not make any sense to use higher values

        require(_shift > -77 && _shift < 77);

        uintStorage[DECIMAL_SHIFT] = uint256(_shift);

    }



    /**

    * @dev Returns the value of foreign-to-home decimal shift.

    * @return decimal shift.

    */

    function decimalShift() public view returns (int256) {

        return int256(uintStorage[DECIMAL_SHIFT]);

    }



    /**

    * @dev Converts the amount of home tokens into the equivalent amount of foreign tokens.

    * @param _value amount of home tokens.

    * @return equivalent amount of foreign tokens.

    */

    function _unshiftValue(uint256 _value) internal view returns (uint256) {

        return _shiftUint(_value, -decimalShift());

    }



    /**

    * @dev Converts the amount of foreign tokens into the equivalent amount of home tokens.

    * @param _value amount of foreign tokens.

    * @return equivalent amount of home tokens.

    */

    function _shiftValue(uint256 _value) internal view returns (uint256) {

        return _shiftUint(_value, decimalShift());

    }



    /**

    * @dev Calculates _value * pow(10, _shift).

    * @param _value amount of tokens.

    * @param _shift decimal shift to apply.

    * @return shifted value.

    */

    function _shiftUint(uint256 _value, int256 _shift) private pure returns (uint256) {

        if (_shift == 0) {

            return _value;

        }

        if (_shift > 0) {

            return _value.mul(10**uint256(_shift));

        }

        return _value.div(10**uint256(-_shift));

    }

}



// File: contracts/upgradeable_contracts/BasicBridge.sol



pragma solidity 0.4.24;



















contract BasicBridge is

    InitializableBridge,

    Validatable,

    Ownable,

    Upgradeable,

    Claimable,

    VersionableBridge,

    DecimalShiftBridge

{

    event GasPriceChanged(uint256 gasPrice);

    event RequiredBlockConfirmationChanged(uint256 requiredBlockConfirmations);



    bytes32 internal constant GAS_PRICE = 0x55b3774520b5993024893d303890baa4e84b1244a43c60034d1ced2d3cf2b04b; // keccak256(abi.encodePacked("gasPrice"))

    bytes32 internal constant REQUIRED_BLOCK_CONFIRMATIONS = 0x916daedf6915000ff68ced2f0b6773fe6f2582237f92c3c95bb4d79407230071; // keccak256(abi.encodePacked("requiredBlockConfirmations"))



    /**

    * @dev Public setter for fallback gas price value. Only bridge owner can call this method.

    * @param _gasPrice new value for the gas price.

    */

    function setGasPrice(uint256 _gasPrice) external onlyOwner {

        _setGasPrice(_gasPrice);

    }



    function gasPrice() external view returns (uint256) {

        return uintStorage[GAS_PRICE];

    }



    function setRequiredBlockConfirmations(uint256 _blockConfirmations) external onlyOwner {

        _setRequiredBlockConfirmations(_blockConfirmations);

    }



    function _setRequiredBlockConfirmations(uint256 _blockConfirmations) internal {

        require(_blockConfirmations > 0);

        uintStorage[REQUIRED_BLOCK_CONFIRMATIONS] = _blockConfirmations;

        emit RequiredBlockConfirmationChanged(_blockConfirmations);

    }



    function requiredBlockConfirmations() external view returns (uint256) {

        return uintStorage[REQUIRED_BLOCK_CONFIRMATIONS];

    }



    /**

    * @dev Internal function for updating fallback gas price value.

    * @param _gasPrice new value for the gas price, zero gas price is allowed.

    */

    function _setGasPrice(uint256 _gasPrice) internal {

        uintStorage[GAS_PRICE] = _gasPrice;

        emit GasPriceChanged(_gasPrice);

    }

}



// File: contracts/upgradeable_contracts/arbitrary_message/VersionableAMB.sol



pragma solidity 0.4.24;





contract VersionableAMB is VersionableBridge {

    // message format version as a single 4-bytes number padded to 32-bytes

    // value, included into every outgoing relay request

    //

    // the message version should be updated every time when

    // - new field appears

    // - some field removed

    // - fields order is changed

    bytes32 internal constant MESSAGE_PACKING_VERSION = 0x00050000 << 224;



    /**

     * Returns currently used bridge version

     * @return (major, minor, patch) version triple

     */

    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {

        return (6, 2, 0);

    }

}



// File: contracts/upgradeable_contracts/arbitrary_message/BasicAMB.sol



pragma solidity 0.4.24;







contract BasicAMB is BasicBridge, VersionableAMB {

    bytes32 internal constant MAX_GAS_PER_TX = 0x2670ecc91ec356e32067fd27b36614132d727b84a1e03e08f412a4f2cf075974; // keccak256(abi.encodePacked("maxGasPerTx"))

    bytes32 internal constant NONCE = 0x7ab1577440dd7bedf920cb6de2f9fc6bf7ba98c78c85a3fa1f8311aac95e1759; // keccak256(abi.encodePacked("nonce"))

    bytes32 internal constant SOURCE_CHAIN_ID = 0x67d6f42a1ed69c62022f2d160ddc6f2f0acd37ad1db0c24f4702d7d3343a4add; // keccak256(abi.encodePacked("sourceChainId"))

    bytes32 internal constant SOURCE_CHAIN_ID_LENGTH = 0xe504ae1fd6471eea80f18b8532a61a9bb91fba4f5b837f80a1cfb6752350af44; // keccak256(abi.encodePacked("sourceChainIdLength"))

    bytes32 internal constant DESTINATION_CHAIN_ID = 0xbbd454018e72a3f6c02bbd785bacc49e46292744f3f6761276723823aa332320; // keccak256(abi.encodePacked("destinationChainId"))

    bytes32 internal constant DESTINATION_CHAIN_ID_LENGTH = 0xfb792ae4ad11102b93f26a51b3749c2b3667f8b561566a4806d4989692811594; // keccak256(abi.encodePacked("destinationChainIdLength"))

    bytes32 internal constant ALLOW_REENTRANT_REQUESTS = 0xffa3a5a0e192028fc343362a39c5688e5a60819a4dc5ab3ee70c25bc25b78dd6; // keccak256(abi.encodePacked("allowReentrantRequests"))



    /**

     * Initializes AMB contract

     * @param _sourceChainId chain id of a network where this contract is deployed

     * @param _destinationChainId chain id of a network where all outgoing messages are directed

     * @param _validatorContract address of the validators contract

     * @param _maxGasPerTx maximum amount of gas per one message execution

     * @param _gasPrice default gas price used by oracles for sending transactions in this network

     * @param _requiredBlockConfirmations number of block confirmations oracle will wait before processing passed messages

     * @param _owner address of new bridge owner

     */

    function initialize(

        uint256 _sourceChainId,

        uint256 _destinationChainId,

        address _validatorContract,

        uint256 _maxGasPerTx,

        uint256 _gasPrice,

        uint256 _requiredBlockConfirmations,

        address _owner

    ) external onlyRelevantSender returns (bool) {

        require(!isInitialized());

        require(AddressUtils.isContract(_validatorContract));



        _setChainIds(_sourceChainId, _destinationChainId);

        addressStorage[VALIDATOR_CONTRACT] = _validatorContract;

        uintStorage[DEPLOYED_AT_BLOCK] = block.number;

        uintStorage[MAX_GAS_PER_TX] = _maxGasPerTx;

        _setGasPrice(_gasPrice);

        _setRequiredBlockConfirmations(_requiredBlockConfirmations);

        _setOwner(_owner);

        setInitialize();



        return isInitialized();

    }



    function getBridgeMode() external pure returns (bytes4 _data) {

        return 0x2544fbb9; // bytes4(keccak256(abi.encodePacked("arbitrary-message-bridge-core")))

    }



    function maxGasPerTx() public view returns (uint256) {

        return uintStorage[MAX_GAS_PER_TX];

    }



    function setMaxGasPerTx(uint256 _maxGasPerTx) external onlyOwner {

        uintStorage[MAX_GAS_PER_TX] = _maxGasPerTx;

    }



    /**

     * Internal function for retrieving chain id for the source network

     * @return chain id for the current network

     */

    function sourceChainId() public view returns (uint256) {

        return uintStorage[SOURCE_CHAIN_ID];

    }



    /**

     * Internal function for retrieving chain id for the destination network

     * @return chain id for the destination network

     */

    function destinationChainId() public view returns (uint256) {

        return uintStorage[DESTINATION_CHAIN_ID];

    }



    /**

     * Updates chain ids of used networks

     * @param _sourceChainId chain id for current network

     * @param _destinationChainId chain id for opposite network

     */

    function setChainIds(uint256 _sourceChainId, uint256 _destinationChainId) external onlyOwner {

        _setChainIds(_sourceChainId, _destinationChainId);

    }



    /**

     * Sets the flag to allow passing new AMB requests in the opposite direction,

     * while other AMB message is being processed.

     * Only owner can call this method.

     * @param _enable true, if reentrant requests are allowed.

     */

    function setAllowReentrantRequests(bool _enable) external onlyOwner {

        boolStorage[ALLOW_REENTRANT_REQUESTS] = _enable;

    }



    /**

     * Tells if passing reentrant requests is allowed.

     * @return true, if reentrant requests are allowed.

     */

    function allowReentrantRequests() public view returns (bool) {

        return boolStorage[ALLOW_REENTRANT_REQUESTS];

    }



    /**

     * @dev Withdraws the erc20 tokens or native coins from this contract.

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimTokens(address _token, address _to) external onlyIfUpgradeabilityOwner {

        claimValues(_token, _to);

    }



    /**

     * Internal function for retrieving current nonce value

     * @return nonce value

     */

    function _nonce() internal view returns (uint64) {

        return uint64(uintStorage[NONCE]);

    }



    /**

     * Internal function for updating nonce value

     * @param _nonce new nonce value

     */

    function _setNonce(uint64 _nonce) internal {

        uintStorage[NONCE] = uint256(_nonce);

    }



    /**

     * Internal function for updating chain ids of used networks

     * @param _sourceChainId chain id for current network

     * @param _destinationChainId chain id for opposite network

     */

    function _setChainIds(uint256 _sourceChainId, uint256 _destinationChainId) internal {

        require(_sourceChainId > 0 && _destinationChainId > 0);

        require(_sourceChainId != _destinationChainId);



        // Length fields are needed further when encoding the message.

        // Chain ids are compressed, so that leading zero bytes are not preserved.

        // In order to save some gas during calls to MessageDelivery.c,

        // lengths of chain ids are precalculated and being saved in the storage.

        uint256 sourceChainIdLength = 0;

        uint256 destinationChainIdLength = 0;

        uint256 mask = 0xff;



        for (uint256 i = 1; sourceChainIdLength == 0 || destinationChainIdLength == 0; i++) {

            if (sourceChainIdLength == 0 && _sourceChainId & mask == _sourceChainId) {

                sourceChainIdLength = i;

            }

            if (destinationChainIdLength == 0 && _destinationChainId & mask == _destinationChainId) {

                destinationChainIdLength = i;

            }

            mask = (mask << 8) | 0xff;

        }



        uintStorage[SOURCE_CHAIN_ID] = _sourceChainId;

        uintStorage[SOURCE_CHAIN_ID_LENGTH] = sourceChainIdLength;

        uintStorage[DESTINATION_CHAIN_ID] = _destinationChainId;

        uintStorage[DESTINATION_CHAIN_ID_LENGTH] = destinationChainIdLength;

    }



    /**

     * Internal function for retrieving chain id length for the source network

     * @return chain id for the current network

     */

    function _sourceChainIdLength() internal view returns (uint256) {

        return uintStorage[SOURCE_CHAIN_ID_LENGTH];

    }



    /**

     * Internal function for retrieving chain id length for the destination network

     * @return chain id for the destination network

     */

    function _destinationChainIdLength() internal view returns (uint256) {

        return uintStorage[DESTINATION_CHAIN_ID_LENGTH];

    }



    /**

     * Internal function for validating version of the received message

     * @param _messageId id of the received message

     */

    function _isMessageVersionValid(bytes32 _messageId) internal returns (bool) {

        return

            _messageId & 0xffffffff00000000000000000000000000000000000000000000000000000000 == MESSAGE_PACKING_VERSION;

    }



    /**

     * Internal function for validating destination chain id of the received message

     * @param _chainId destination chain id of the received message

     */

    function _isDestinationChainIdValid(uint256 _chainId) internal returns (bool res) {

        return _chainId == sourceChainId();

    }

}



// File: contracts/libraries/Bytes.sol



pragma solidity 0.4.24;



/**

 * @title Bytes

 * @dev Helper methods to transform bytes to other solidity types.

 */

library Bytes {

    /**

    * @dev Converts bytes array to bytes32.

    * Truncates bytes array if its size is more than 32 bytes.

    * NOTE: This function does not perform any checks on the received parameter.

    * Make sure that the _bytes argument has a correct length, not less than 32 bytes.

    * A case when _bytes has length less than 32 will lead to the undefined behaviour,

    * since assembly will read data from memory that is not related to the _bytes argument.

    * @param _bytes to be converted to bytes32 type

    * @return bytes32 type of the firsts 32 bytes array in parameter.

    */

    function bytesToBytes32(bytes _bytes) internal pure returns (bytes32 result) {

        assembly {

            result := mload(add(_bytes, 32))

        }

    }



    /**

    * @dev Truncate bytes array if its size is more than 20 bytes.

    * NOTE: Similar to the bytesToBytes32 function, make sure that _bytes is not shorter than 20 bytes.

    * @param _bytes to be converted to address type

    * @return address included in the firsts 20 bytes of the bytes array in parameter.

    */

    function bytesToAddress(bytes _bytes) internal pure returns (address addr) {

        assembly {

            addr := mload(add(_bytes, 20))

        }

    }

}



// File: contracts/upgradeable_contracts/arbitrary_message/MessageProcessor.sol



pragma solidity 0.4.24;







contract MessageProcessor is EternalStorage {

    /**

    * @dev Returns a status of the message that came from the other side.

    * @param _messageId id of the message from the other side that triggered a call.

    * @return true if call executed successfully.

    */

    function messageCallStatus(bytes32 _messageId) external view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("messageCallStatus", _messageId))];

    }



    /**

    * @dev Sets a status of the message that came from the other side.

    * @param _messageId id of the message from the other side that triggered a call.

    * @param _status execution status, true if executed successfully.

    */

    function setMessageCallStatus(bytes32 _messageId, bool _status) internal {

        boolStorage[keccak256(abi.encodePacked("messageCallStatus", _messageId))] = _status;

    }



    /**

    * @dev Returns a data hash of the failed message that came from the other side.

    * NOTE: dataHash was used previously to identify outgoing message before AMB message id was introduced.

    * It is kept for backwards compatibility with old mediators contracts.

    * @param _messageId id of the message from the other side that triggered a call.

    * @return keccak256 hash of message data.

    */

    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32) {

        return bytes32(uintStorage[keccak256(abi.encodePacked("failedMessageDataHash", _messageId))]);

    }



    /**

    * @dev Sets a data hash of the failed message that came from the other side.

    * NOTE: dataHash was used previously to identify outgoing message before AMB message id was introduced.

    * It is kept for backwards compatibility with old mediators contracts.

    * @param _messageId id of the message from the other side that triggered a call.

    * @param data of the processed message.

    */

    function setFailedMessageDataHash(bytes32 _messageId, bytes data) internal {

        uintStorage[keccak256(abi.encodePacked("failedMessageDataHash", _messageId))] = uint256(keccak256(data));

    }



    /**

    * @dev Returns a receiver address of the failed message that came from the other side.

    * @param _messageId id of the message from the other side that triggered a call.

    * @return receiver address.

    */

    function failedMessageReceiver(bytes32 _messageId) external view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("failedMessageReceiver", _messageId))];

    }



    /**

    * @dev Sets a sender address of the failed message that came from the other side.

    * @param _messageId id of the message from the other side that triggered a call.

    * @param _receiver address of the receiver.

    */

    function setFailedMessageReceiver(bytes32 _messageId, address _receiver) internal {

        addressStorage[keccak256(abi.encodePacked("failedMessageReceiver", _messageId))] = _receiver;

    }



    /**

    * @dev Returns a sender address of the failed message that came from the other side.

    * @param _messageId id of the message from the other side that triggered a call.

    * @return sender address on the other side.

    */

    function failedMessageSender(bytes32 _messageId) external view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("failedMessageSender", _messageId))];

    }



    /**

    * @dev Sets a sender address of the failed message that came from the other side.

    * @param _messageId id of the message from the other side that triggered a call.

    * @param _sender address of the sender on the other side.

    */

    function setFailedMessageSender(bytes32 _messageId, address _sender) internal {

        addressStorage[keccak256(abi.encodePacked("failedMessageSender", _messageId))] = _sender;

    }



    /**

    * @dev Returns an address of the sender on the other side for the currently processed message.

    * Can be used by executors for getting other side caller address.

    * @return address of the sender on the other side.

    */

    function messageSender() external view returns (address sender) {

        assembly {

            // Even though this is not the same as addressStorage[keccak256(abi.encodePacked("messageSender"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            sender := sload(0x7b58b2a669d8e0992eae9eaef641092c0f686fd31070e7236865557fa1571b5b) // keccak256(abi.encodePacked("messageSender"))

        }

    }



    /**

    * @dev Sets an address of the sender on the other side for the currently processed message.

    * @param _sender address of the sender on the other side.

    */

    function setMessageSender(address _sender) internal {

        assembly {

            // Even though this is not the same as addressStorage[keccak256(abi.encodePacked("messageSender"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            sstore(0x7b58b2a669d8e0992eae9eaef641092c0f686fd31070e7236865557fa1571b5b, _sender) // keccak256(abi.encodePacked("messageSender"))

        }

    }



    /**

    * @dev Returns an id of the currently processed message.

    * @return id of the message that originated on the other side.

    */

    function messageId() public view returns (bytes32 id) {

        assembly {

            // Even though this is not the same as uintStorage[keccak256(abi.encodePacked("messageId"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            id := sload(0xe34bb2103dc34f2c144cc216c132d6ffb55dac57575c22e089161bbe65083304) // keccak256(abi.encodePacked("messageId"))

        }

    }



    /**

    * @dev Returns an id of the currently processed message.

    * NOTE: transactionHash was used previously to identify incoming message before AMB message id was introduced.

    * It is kept for backwards compatibility with old mediators contracts, although it doesn't return txHash anymore.

    * @return id of the message that originated on the other side.

    */

    function transactionHash() external view returns (bytes32) {

        return messageId();

    }



    /**

    * @dev Sets a message id of the currently processed message.

    * @param _messageId id of the message that originated on the other side.

    */

    function setMessageId(bytes32 _messageId) internal {

        assembly {

            // Even though this is not the same as uintStorage[keccak256(abi.encodePacked("messageId"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            sstore(0xe34bb2103dc34f2c144cc216c132d6ffb55dac57575c22e089161bbe65083304, _messageId) // keccak256(abi.encodePacked("messageId"))

        }

    }



    /**

    * @dev Returns an originating chain id of the currently processed message.

    * @return source chain id of the message that originated on the other side.

    */

    function messageSourceChainId() external view returns (uint256 id) {

        assembly {

            // Even though this is not the same as uintStorage[keccak256(abi.encodePacked("messageSourceChainId"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            id := sload(0x7f0fcd9e49860f055dd0c1682d635d309ecb5e3011654c716d9eb59a7ddec7d2) // keccak256(abi.encodePacked("messageSourceChainId"))

        }

    }



    /**

    * @dev Sets an originating chain id of the currently processed message.

    * @param _sourceChainId source chain id of the message that originated on the other side.

    */

    function setMessageSourceChainId(uint256 _sourceChainId) internal {

        assembly {

            // Even though this is not the same as uintStorage[keccak256(abi.encodePacked("messageSourceChainId"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            sstore(0x7f0fcd9e49860f055dd0c1682d635d309ecb5e3011654c716d9eb59a7ddec7d2, _sourceChainId) // keccak256(abi.encodePacked("messageSourceChainId"))

        }

    }



    /**

    * @dev Processes received message. Makes a call to the message executor,

    * sets dataHash, receive, sender variables for failed messages.

    * @param _sender sender address on the other side.

    * @param _executor address of an executor.

    * @param _messageId id of the processed message.

    * @param _gasLimit gas limit for a call to executor.

    * @param _sourceChainId source chain id is of the received message.

    * @param _data calldata for a call to executor.

    */

    function processMessage(

        address _sender,

        address _executor,

        bytes32 _messageId,

        uint256 _gasLimit,

        uint8, /* dataType */

        uint256 _sourceChainId,

        bytes memory _data

    ) internal {

        bool status = _passMessage(_sender, _executor, _data, _gasLimit, _messageId, _sourceChainId);



        setMessageCallStatus(_messageId, status);

        if (!status) {

            setFailedMessageDataHash(_messageId, _data);

            setFailedMessageReceiver(_messageId, _executor);

            setFailedMessageSender(_messageId, _sender);

        }

        emitEventOnMessageProcessed(_sender, _executor, _messageId, status);

    }



    /**

    * @dev Makes a call to the message executor.

    * @param _sender sender address on the other side.

    * @param _contract address of an executor contract.

    * @param _data calldata for a call to executor.

    * @param _gas gas limit for a call to executor. 2^32 - 1, if caller will pass all available gas for the execution.

    * @param _messageId id of the processed message.

    * @param _sourceChainId source chain id is of the received message.

    */

    function _passMessage(

        address _sender,

        address _contract,

        bytes _data,

        uint256 _gas,

        bytes32 _messageId,

        uint256 _sourceChainId

    ) internal returns (bool) {

        setMessageSender(_sender);

        setMessageId(_messageId);

        setMessageSourceChainId(_sourceChainId);



        // After EIP-150, max gas cost allowed to be passed to the internal call is equal to the 63/64 of total gas left.

        // In reality, min(gasLimit, 63/64 * gasleft()) will be used as the call gas limit.

        // Imagine a situation, when message requires 10000000 gas to be executed successfully.

        // Also suppose, that at this point, gasleft() is equal to 10158000, so the callee will receive ~ 10158000 * 63 / 64 = 9999300 gas.

        // That amount of gas is not enough, so the call will fail. At the same time,

        // even if the callee failed the bridge contract still has ~ 158000 gas to

        // finish its execution and it will be enough. The internal call fails but

        // only because the oracle provides incorrect gas limit for the transaction

        // This check is needed here in order to force contract to pass exactly the requested amount of gas.

        // Avoiding it may lead to the unwanted message failure in some extreme cases.

        require(_gas == 0xffffffff || (gasleft() * 63) / 64 > _gas);



        bool status = _contract.call.gas(_gas)(_data);

        _validateExecutionStatus(status);

        setMessageSender(address(0));

        setMessageId(bytes32(0));

        setMessageSourceChainId(0);

        return status;

    }



    /**

    * @dev Validates message execution status. In simplest case, does nothing.

    * @param _status message execution status.

    */

    function _validateExecutionStatus(bool _status) internal {

        (_status);

    }



    /* solcov ignore next */

    function emitEventOnMessageProcessed(address sender, address executor, bytes32 messageId, bool status) internal;

}



// File: contracts/upgradeable_contracts/arbitrary_message/MessageDelivery.sol



pragma solidity 0.4.24;













contract MessageDelivery is BasicAMB, MessageProcessor {

    using SafeMath for uint256;



    uint256 internal constant SEND_TO_ORACLE_DRIVEN_LANE = 0x00;

    // after EIP2929, call to warmed contract address costs 100 instead of 2600

    uint256 internal constant MIN_GAS_PER_CALL = 100;



    /**

    * @dev Requests message relay to the opposite network

    * @param _contract executor address on the other side

    * @param _data calldata passed to the executor on the other side

    * @param _gas gas limit used on the other network for executing a message

    */

    function requireToPassMessage(address _contract, bytes memory _data, uint256 _gas) public returns (bytes32) {

        return _sendMessage(_contract, _data, _gas, SEND_TO_ORACLE_DRIVEN_LANE);

    }



    /**

    * @dev Initiates sending of an AMB message to the opposite network

    * @param _contract executor address on the other side

    * @param _data calldata passed to the executor on the other side

    * @param _gas gas limit used on the other network for executing a message

    * @param _dataType AMB message dataType to be included as a part of the header

    */

    function _sendMessage(address _contract, bytes memory _data, uint256 _gas, uint256 _dataType)

        internal

        returns (bytes32)

    {

        // it is not allowed to pass messages while other messages are processed

        // if other is not explicitly configured

        require(messageId() == bytes32(0) || allowReentrantRequests());

        require(_gas >= MIN_GAS_PER_CALL && _gas <= maxGasPerTx());



        uint256 selector;

        assembly {

            selector := and(mload(add(_data, 4)), 0xffffffff)

        }

        // In order to prevent possible unauthorized ERC20 withdrawals, the following function signatures are prohibited:

        // * transfer(address,uint256)

        // * approve(address,uint256)

        // * transferFrom(address,address,uint256)

        // * approveAndCall(address,uint256,bytes)

        // * transferAndCall(address,uint256,bytes)

        // See https://medium.com/immunefi/xdai-stake-arbitrary-call-method-bug-postmortem-f80a90ac56e3 for more details

        require(

            selector != 0xa9059cbb &&

                selector != 0x095ea7b3 &&

                selector != 0x23b872dd &&

                selector != 0x4000aea0 &&

                selector != 0xcae9ca51

        );



        (bytes32 _messageId, bytes memory header) = _packHeader(_contract, _gas, _dataType);



        bytes memory eventData = abi.encodePacked(header, _data);



        emitEventOnMessageRequest(_messageId, eventData);

        return _messageId;

    }



    /**

    * @dev Packs message header into a single bytes blob

    * @param _contract executor address on the other side

    * @param _gas gas limit used on the other network for executing a message

    * @param _dataType AMB message dataType to be included as a part of the header

    */

    function _packHeader(address _contract, uint256 _gas, uint256 _dataType)

        internal

        view

        returns (bytes32 _messageId, bytes memory header)

    {

        uint256 srcChainId = sourceChainId();

        uint256 srcChainIdLength = _sourceChainIdLength();

        uint256 dstChainId = destinationChainId();

        uint256 dstChainIdLength = _destinationChainIdLength();



        _messageId = _getNewMessageId(srcChainId);



        // 79 = 4 + 20 + 8 + 20 + 20 + 4 + 1 + 1 + 1

        header = new bytes(79 + srcChainIdLength + dstChainIdLength);



        // In order to save the gas, the header is packed in the reverse order.

        // With such approach, it is possible to store right-aligned values without any additional bit shifts.

        assembly {

            let ptr := add(header, mload(header)) // points to the last word of header

            mstore(ptr, dstChainId)

            mstore(sub(ptr, dstChainIdLength), srcChainId)



            mstore(add(header, 79), _dataType)

            mstore(add(header, 78), dstChainIdLength)

            mstore(add(header, 77), srcChainIdLength)

            mstore(add(header, 76), _gas)

            mstore(add(header, 72), _contract)

            mstore(add(header, 52), caller)

            mstore(add(header, 32), _messageId)

        }

    }



    /**

     * @dev Generates a new messageId for the passed request/message.

     * Increments the nonce accordingly.

     * @param _srcChainId source chain id of the newly created message. Should be a chain id of the current network.

     * @return unique message id to use for the new request/message.

     */

    function _getNewMessageId(uint256 _srcChainId) internal returns (bytes32) {

        uint64 nonce = _nonce();

        _setNonce(nonce + 1);



        // Bridge id is recalculated every time again and again, since it is still cheaper than using SLOAD opcode (800 gas)

        bytes32 bridgeId = keccak256(abi.encodePacked(_srcChainId, address(this))) &

            0x00000000ffffffffffffffffffffffffffffffffffffffff0000000000000000;



        return MESSAGE_PACKING_VERSION | bridgeId | bytes32(nonce);

    }



    /* solcov ignore next */

    function emitEventOnMessageRequest(bytes32 messageId, bytes encodedData) internal;

}



// File: contracts/upgradeable_contracts/MessageRelay.sol



pragma solidity 0.4.24;





contract MessageRelay is EternalStorage {

    function relayedMessages(bytes32 _txHash) public view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("relayedMessages", _txHash))];

    }



    function setRelayedMessages(bytes32 _txHash, bool _status) internal {

        boolStorage[keccak256(abi.encodePacked("relayedMessages", _txHash))] = _status;

    }

}



// File: contracts/upgradeable_contracts/arbitrary_message/BasicForeignAMB.sol



pragma solidity 0.4.24;













contract BasicForeignAMB is BasicAMB, MessageRelay, MessageDelivery {

    /**

    * @dev Validates provided signatures and relays a given message

    * @param _data bytes to be relayed

    * @param _signatures bytes blob with signatures to be validated

    */

    function executeSignatures(bytes _data, bytes _signatures) public {

        _allowMessageExecution(_data, _signatures);



        bytes32 msgId;

        address sender;

        address executor;

        uint32 gasLimit;

        uint8 dataType;

        uint256[2] memory chainIds;

        bytes memory data;



        (msgId, sender, executor, gasLimit, dataType, chainIds, data) = ArbitraryMessage.unpackData(_data);



        _executeMessage(msgId, sender, executor, gasLimit, dataType, chainIds, data);

    }



    /**

    * @dev Validates provided signatures and relays a given message.

    * The message is not allowed to fail. The whole tx will be revered if message fails.

    * @param _data bytes to be relayed

    * @param _signatures bytes blob with signatures to be validated

    */

    function safeExecuteSignatures(bytes _data, bytes _signatures) external {

        executeSignatures(_data, _signatures);

    }



    /**

    * @dev Validates provided signatures and relays a given message. Allows to override the gas limit of the passed message.

    * Usually it makes sense to provide a higher amount of gas for the execution.

    * The message is not allowed to fail. The whole tx will be revered if message fails.

    * @param _data bytes to be relayed

    * @param _signatures bytes blob with signatures to be validated

    */

    function safeExecuteSignaturesWithGasLimit(bytes _data, bytes _signatures, uint32 _gas) public {

        _allowMessageExecution(_data, _signatures);



        bytes32 msgId;

        address sender;

        address executor;

        uint8 dataType;

        uint256[2] memory chainIds;

        bytes memory data;



        (msgId, sender, executor, , dataType, chainIds, data) = ArbitraryMessage.unpackData(_data);



        _executeMessage(msgId, sender, executor, _gas, dataType, chainIds, data);

    }



    /**

    * @dev Validates provided signatures and relays a given message. Passes all available gas for the execution.

    * The message is not allowed to fail. The whole tx will be revered if message fails.

    * @param _data bytes to be relayed

    * @param _signatures bytes blob with signatures to be validated

    */

    function safeExecuteSignaturesWithAutoGasLimit(bytes _data, bytes _signatures) external {

        safeExecuteSignaturesWithGasLimit(_data, _signatures, 0xffffffff);

    }



    /**

    * @dev Internal function for validating pre-execution requirements.

    * @param _data bytes to be relayed.

    * @param _signatures bytes blob with signatures to be validated.

    */

    function _allowMessageExecution(bytes _data, bytes _signatures) internal {

        // this checks prevents execution of other messages, while some other message is being processed

        // nested executeSignatures is considered to be unsafe,

        // since it allows to change/reset the AMB context variables (messageId, messageSender, messageSourceChainId)

        // while processing nested message

        require(messageId() == bytes32(0));



        Message.hasEnoughValidSignatures(_data, _signatures, validatorContract(), true);

    }



    /**

    * @dev Internal function for executing decoded message. Performs additional validation on the message fields.

    * @param msgId id of the processed message.

    * @param sender sender address on the other side.

    * @param executor address of an executor.

    * @param gasLimit gas limit for a call to executor.

    * @param dataType AMB message dataType to be included as a part of the header.

    * @param chainIds pair of source and destination chain ids.

    * @param data calldata for a call to executor.

    */

    function _executeMessage(

        bytes32 msgId,

        address sender,

        address executor,

        uint32 gasLimit,

        uint8 dataType,

        uint256[2] memory chainIds,

        bytes memory data

    ) internal {

        require(_isMessageVersionValid(msgId));

        require(_isDestinationChainIdValid(chainIds[1]));

        require(!relayedMessages(msgId));

        setRelayedMessages(msgId, true);

        processMessage(sender, executor, msgId, gasLimit, dataType, chainIds[0], data);

    }



    /**

    * @dev Validates message execution status. Reverts if message is was executed in safe mode and reverted.

    * @param _status message execution status.

    */

    function _validateExecutionStatus(bool _status) internal {

        require(_status || msg.sig == this.executeSignatures.selector);

    }



    /**

    * @dev Internal function for updating fallback gas price value.

    * @param _gasPrice new value for the gas price, zero gas price is not allowed.

    */

    function _setGasPrice(uint256 _gasPrice) internal {

        require(_gasPrice > 0);

        super._setGasPrice(_gasPrice);

    }

}



// File: contracts/upgradeable_contracts/arbitrary_message/ForeignAMB.sol



pragma solidity 0.4.24;





contract ForeignAMB is BasicForeignAMB {

    event UserRequestForAffirmation(bytes32 indexed messageId, bytes encodedData);

    event RelayedMessage(address indexed sender, address indexed executor, bytes32 indexed messageId, bool status);



    function emitEventOnMessageRequest(bytes32 messageId, bytes encodedData) internal {

        emit UserRequestForAffirmation(messageId, encodedData);

    }



    function emitEventOnMessageProcessed(address sender, address executor, bytes32 messageId, bool status) internal {

        emit RelayedMessage(sender, executor, messageId, status);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ForeignAMBErc677ToErc677.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-11-29

*/



// File: contracts/interfaces/IAMB.sol



pragma solidity 0.4.24;



interface IAMB {

    function messageSender() external view returns (address);

    function maxGasPerTx() external view returns (uint256);

    function transactionHash() external view returns (bytes32);

    function messageId() external view returns (bytes32);

    function messageSourceChainId() external view returns (bytes32);

    function messageCallStatus(bytes32 _messageId) external view returns (bool);

    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32);

    function failedMessageReceiver(bytes32 _messageId) external view returns (address);

    function failedMessageSender(bytes32 _messageId) external view returns (address);

    function requireToPassMessage(address _contract, bytes _data, uint256 _gas) external returns (bytes32);

    function requireToConfirmMessage(address _contract, bytes _data, uint256 _gas) external returns (bytes32);

    function requireToGetInformation(bytes32 _requestSelector, bytes _data) external returns (bytes32);

    function sourceChainId() external view returns (uint256);

    function destinationChainId() external view returns (uint256);

}



// File: contracts/upgradeability/EternalStorage.sol



pragma solidity 0.4.24;



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {

    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;



}



// File: contracts/interfaces/IUpgradeabilityOwnerStorage.sol



pragma solidity 0.4.24;



interface IUpgradeabilityOwnerStorage {

    function upgradeabilityOwner() external view returns (address);

}



// File: contracts/upgradeable_contracts/Ownable.sol



pragma solidity 0.4.24;







/**

 * @title Ownable

 * @dev This contract has an owner address providing basic authorization control

 */

contract Ownable is EternalStorage {

    bytes4 internal constant UPGRADEABILITY_OWNER = 0x6fde8202; // upgradeabilityOwner()



    /**

    * @dev Event to show ownership has been transferred

    * @param previousOwner representing the address of the previous owner

    * @param newOwner representing the address of the new owner

    */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner());

        /* solcov ignore next */

        _;

    }



    /**

    * @dev Throws if called by any account other than contract itself or owner.

    */

    modifier onlyRelevantSender() {

        // proxy owner if used through proxy, address(0) otherwise

        require(

            !address(this).call(abi.encodeWithSelector(UPGRADEABILITY_OWNER)) || // covers usage without calling through storage proxy

                msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner() || // covers usage through regular proxy calls

                msg.sender == address(this) // covers calls through upgradeAndCall proxy method

        );

        /* solcov ignore next */

        _;

    }



    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked("owner"))



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function owner() public view returns (address) {

        return addressStorage[OWNER];

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner the address to transfer ownership to.

    */

    function transferOwnership(address newOwner) external onlyOwner {

        _setOwner(newOwner);

    }



    /**

    * @dev Sets a new owner address

    */

    function _setOwner(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner(), newOwner);

        addressStorage[OWNER] = newOwner;

    }

}



// File: contracts/upgradeable_contracts/Initializable.sol



pragma solidity 0.4.24;





contract Initializable is EternalStorage {

    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked("isInitialized"))



    function setInitialize() internal {

        boolStorage[INITIALIZED] = true;

    }



    function isInitialized() public view returns (bool) {

        return boolStorage[INITIALIZED];

    }

}



// File: openzeppelin-solidity/contracts/AddressUtils.sol



pragma solidity ^0.4.24;





/**

 * Utility library of inline functions on addresses

 */

library AddressUtils {



  /**

   * Returns whether the target address is a contract

   * @dev This function will return false if invoked during the constructor of a contract,

   * as the code is not actually created until after the constructor finishes.

   * @param _addr address to check

   * @return whether the target address is a contract

   */

  function isContract(address _addr) internal view returns (bool) {

    uint256 size;

    // XXX Currently there is no better way to check if there is a contract in an address

    // than to check the size of the code at that address.

    // See https://ethereum.stackexchange.com/a/14016/36603

    // for more details about how this works.

    // TODO Check this again before the Serenity release, because all addresses will be

    // contracts then.

    // solium-disable-next-line security/no-inline-assembly

    assembly { size := extcodesize(_addr) }

    return size > 0;

  }



}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.4.24;





/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (_a == 0) {

      return 0;

    }



    c = _a * _b;

    assert(c / _a == _b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {

    // assert(_b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = _a / _b;

    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold

    return _a / _b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {

    assert(_b <= _a);

    return _a - _b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    c = _a + _b;

    assert(c >= _a);

    return c;

  }

}



// File: contracts/upgradeable_contracts/DecimalShiftBridge.sol



pragma solidity 0.4.24;







contract DecimalShiftBridge is EternalStorage {

    using SafeMath for uint256;



    bytes32 internal constant DECIMAL_SHIFT = 0x1e8ecaafaddea96ed9ac6d2642dcdfe1bebe58a930b1085842d8fc122b371ee5; // keccak256(abi.encodePacked("decimalShift"))



    /**

    * @dev Internal function for setting the decimal shift for bridge operations.

    * Decimal shift can be positive, negative, or equal to zero.

    * It has the following meaning: N tokens in the foreign chain are equivalent to N * pow(10, shift) tokens on the home side.

    * @param _shift new value of decimal shift.

    */

    function _setDecimalShift(int256 _shift) internal {

        // since 1 wei * 10**77 > 2**255, it does not make any sense to use higher values

        require(_shift > -77 && _shift < 77);

        uintStorage[DECIMAL_SHIFT] = uint256(_shift);

    }



    /**

    * @dev Returns the value of foreign-to-home decimal shift.

    * @return decimal shift.

    */

    function decimalShift() public view returns (int256) {

        return int256(uintStorage[DECIMAL_SHIFT]);

    }



    /**

    * @dev Converts the amount of home tokens into the equivalent amount of foreign tokens.

    * @param _value amount of home tokens.

    * @return equivalent amount of foreign tokens.

    */

    function _unshiftValue(uint256 _value) internal view returns (uint256) {

        return _shiftUint(_value, -decimalShift());

    }



    /**

    * @dev Converts the amount of foreign tokens into the equivalent amount of home tokens.

    * @param _value amount of foreign tokens.

    * @return equivalent amount of home tokens.

    */

    function _shiftValue(uint256 _value) internal view returns (uint256) {

        return _shiftUint(_value, decimalShift());

    }



    /**

    * @dev Calculates _value * pow(10, _shift).

    * @param _value amount of tokens.

    * @param _shift decimal shift to apply.

    * @return shifted value.

    */

    function _shiftUint(uint256 _value, int256 _shift) private pure returns (uint256) {

        if (_shift == 0) {

            return _value;

        }

        if (_shift > 0) {

            return _value.mul(10**uint256(_shift));

        }

        return _value.div(10**uint256(-_shift));

    }

}



// File: contracts/upgradeable_contracts/BasicTokenBridge.sol



pragma solidity 0.4.24;











contract BasicTokenBridge is EternalStorage, Ownable, DecimalShiftBridge {

    using SafeMath for uint256;



    event DailyLimitChanged(uint256 newLimit);

    event ExecutionDailyLimitChanged(uint256 newLimit);



    bytes32 internal constant MIN_PER_TX = 0xbbb088c505d18e049d114c7c91f11724e69c55ad6c5397e2b929e68b41fa05d1; // keccak256(abi.encodePacked("minPerTx"))

    bytes32 internal constant MAX_PER_TX = 0x0f8803acad17c63ee38bf2de71e1888bc7a079a6f73658e274b08018bea4e29c; // keccak256(abi.encodePacked("maxPerTx"))

    bytes32 internal constant DAILY_LIMIT = 0x4a6a899679f26b73530d8cf1001e83b6f7702e04b6fdb98f3c62dc7e47e041a5; // keccak256(abi.encodePacked("dailyLimit"))

    bytes32 internal constant EXECUTION_MAX_PER_TX = 0xc0ed44c192c86d1cc1ba51340b032c2766b4a2b0041031de13c46dd7104888d5; // keccak256(abi.encodePacked("executionMaxPerTx"))

    bytes32 internal constant EXECUTION_DAILY_LIMIT = 0x21dbcab260e413c20dc13c28b7db95e2b423d1135f42bb8b7d5214a92270d237; // keccak256(abi.encodePacked("executionDailyLimit"))



    function totalSpentPerDay(uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _day))];

    }



    function totalExecutedPerDay(uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _day))];

    }



    function dailyLimit() public view returns (uint256) {

        return uintStorage[DAILY_LIMIT];

    }



    function executionDailyLimit() public view returns (uint256) {

        return uintStorage[EXECUTION_DAILY_LIMIT];

    }



    function maxPerTx() public view returns (uint256) {

        return uintStorage[MAX_PER_TX];

    }



    function executionMaxPerTx() public view returns (uint256) {

        return uintStorage[EXECUTION_MAX_PER_TX];

    }



    function minPerTx() public view returns (uint256) {

        return uintStorage[MIN_PER_TX];

    }



    function withinLimit(uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalSpentPerDay(getCurrentDay()).add(_amount);

        return dailyLimit() >= nextLimit && _amount <= maxPerTx() && _amount >= minPerTx();

    }



    function withinExecutionLimit(uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalExecutedPerDay(getCurrentDay()).add(_amount);

        return executionDailyLimit() >= nextLimit && _amount <= executionMaxPerTx();

    }



    function getCurrentDay() public view returns (uint256) {

        return now / 1 days;

    }



    function addTotalSpentPerDay(uint256 _day, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _day))] = totalSpentPerDay(_day).add(_value);

    }



    function addTotalExecutedPerDay(uint256 _day, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _day))] = totalExecutedPerDay(_day).add(_value);

    }



    function setDailyLimit(uint256 _dailyLimit) external onlyOwner {

        require(_dailyLimit > maxPerTx() || _dailyLimit == 0);

        uintStorage[DAILY_LIMIT] = _dailyLimit;

        emit DailyLimitChanged(_dailyLimit);

    }



    function setExecutionDailyLimit(uint256 _dailyLimit) external onlyOwner {

        require(_dailyLimit > executionMaxPerTx() || _dailyLimit == 0);

        uintStorage[EXECUTION_DAILY_LIMIT] = _dailyLimit;

        emit ExecutionDailyLimitChanged(_dailyLimit);

    }



    function setExecutionMaxPerTx(uint256 _maxPerTx) external onlyOwner {

        require(_maxPerTx < executionDailyLimit());

        uintStorage[EXECUTION_MAX_PER_TX] = _maxPerTx;

    }



    function setMaxPerTx(uint256 _maxPerTx) external onlyOwner {

        require(_maxPerTx == 0 || (_maxPerTx > minPerTx() && _maxPerTx < dailyLimit()));

        uintStorage[MAX_PER_TX] = _maxPerTx;

    }



    function setMinPerTx(uint256 _minPerTx) external onlyOwner {

        require(_minPerTx > 0 && _minPerTx < dailyLimit() && _minPerTx < maxPerTx());

        uintStorage[MIN_PER_TX] = _minPerTx;

    }



    /**

    * @dev Retrieves maximum available bridge amount per one transaction taking into account maxPerTx() and dailyLimit() parameters.

    * @return minimum of maxPerTx parameter and remaining daily quota.

    */

    function maxAvailablePerTx() public view returns (uint256) {

        uint256 _maxPerTx = maxPerTx();

        uint256 _dailyLimit = dailyLimit();

        uint256 _spent = totalSpentPerDay(getCurrentDay());

        uint256 _remainingOutOfDaily = _dailyLimit > _spent ? _dailyLimit - _spent : 0;

        return _maxPerTx < _remainingOutOfDaily ? _maxPerTx : _remainingOutOfDaily;

    }



    function _setLimits(uint256[3] _limits) internal {

        require(

            _limits[2] > 0 && // minPerTx > 0

                _limits[1] > _limits[2] && // maxPerTx > minPerTx

                _limits[0] > _limits[1] // dailyLimit > maxPerTx

        );



        uintStorage[DAILY_LIMIT] = _limits[0];

        uintStorage[MAX_PER_TX] = _limits[1];

        uintStorage[MIN_PER_TX] = _limits[2];



        emit DailyLimitChanged(_limits[0]);

    }



    function _setExecutionLimits(uint256[2] _limits) internal {

        require(_limits[1] < _limits[0]); // foreignMaxPerTx < foreignDailyLimit



        uintStorage[EXECUTION_DAILY_LIMIT] = _limits[0];

        uintStorage[EXECUTION_MAX_PER_TX] = _limits[1];



        emit ExecutionDailyLimitChanged(_limits[0]);

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol



pragma solidity ^0.4.24;





/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * See https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address _who) public view returns (uint256);

  function transfer(address _to, uint256 _value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.4.24;







/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

  function allowance(address _owner, address _spender)

    public view returns (uint256);



  function transferFrom(address _from, address _to, uint256 _value)

    public returns (bool);



  function approve(address _spender, uint256 _value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}



// File: contracts/interfaces/ERC677.sol



pragma solidity 0.4.24;





contract ERC677 is ERC20 {

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);



    function transferAndCall(address, uint256, bytes) external returns (bool);



    function increaseAllowance(address spender, uint256 addedValue) public returns (bool);

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool);

}



contract LegacyERC20 {

    function transfer(address _spender, uint256 _value) public; // returns (bool);

    function transferFrom(address _owner, address _spender, uint256 _value) public; // returns (bool);

}



// File: contracts/interfaces/ERC677Receiver.sol



pragma solidity 0.4.24;



contract ERC677Receiver {

    function onTokenTransfer(address _from, uint256 _value, bytes _data) external returns (bool);

}



// File: contracts/upgradeable_contracts/ERC677Storage.sol



pragma solidity 0.4.24;



contract ERC677Storage {

    bytes32 internal constant ERC677_TOKEN = 0xa8b0ade3e2b734f043ce298aca4cc8d19d74270223f34531d0988b7d00cba21d; // keccak256(abi.encodePacked("erc677token"))

}



// File: contracts/libraries/Bytes.sol



pragma solidity 0.4.24;



/**

 * @title Bytes

 * @dev Helper methods to transform bytes to other solidity types.

 */

library Bytes {

    /**

    * @dev Converts bytes array to bytes32.

    * Truncates bytes array if its size is more than 32 bytes.

    * NOTE: This function does not perform any checks on the received parameter.

    * Make sure that the _bytes argument has a correct length, not less than 32 bytes.

    * A case when _bytes has length less than 32 will lead to the undefined behaviour,

    * since assembly will read data from memory that is not related to the _bytes argument.

    * @param _bytes to be converted to bytes32 type

    * @return bytes32 type of the firsts 32 bytes array in parameter.

    */

    function bytesToBytes32(bytes _bytes) internal pure returns (bytes32 result) {

        assembly {

            result := mload(add(_bytes, 32))

        }

    }



    /**

    * @dev Truncate bytes array if its size is more than 20 bytes.

    * NOTE: Similar to the bytesToBytes32 function, make sure that _bytes is not shorter than 20 bytes.

    * @param _bytes to be converted to address type

    * @return address included in the firsts 20 bytes of the bytes array in parameter.

    */

    function bytesToAddress(bytes _bytes) internal pure returns (address addr) {

        assembly {

            addr := mload(add(_bytes, 20))

        }

    }

}



// File: contracts/upgradeable_contracts/ChooseReceiverHelper.sol



pragma solidity 0.4.24;





contract ChooseReceiverHelper {

    /**

    * @dev Helper function for alternative receiver feature. Chooses the actual receiver out of sender and passed data.

    * @param _from address of tokens sender.

    * @param _data passed data in the transfer message.

    * @return address of the receiver on the other side.

    */

    function chooseReceiver(address _from, bytes _data) internal view returns (address recipient) {

        recipient = _from;

        if (_data.length > 0) {

            require(_data.length == 20);

            recipient = Bytes.bytesToAddress(_data);

            require(recipient != address(0));

            require(recipient != bridgeContractOnOtherSide());

        }

    }



    /* solcov ignore next */

    function bridgeContractOnOtherSide() internal view returns (address);

}



// File: contracts/upgradeable_contracts/BaseERC677Bridge.sol



pragma solidity 0.4.24;















contract BaseERC677Bridge is BasicTokenBridge, ERC677Receiver, ERC677Storage, ChooseReceiverHelper {

    function _erc677token() internal view returns (ERC677) {

        return ERC677(addressStorage[ERC677_TOKEN]);

    }



    function setErc677token(address _token) internal {

        require(AddressUtils.isContract(_token));

        addressStorage[ERC677_TOKEN] = _token;

    }



    function onTokenTransfer(address _from, uint256 _value, bytes _data) external returns (bool) {

        ERC677 token = _erc677token();

        require(msg.sender == address(token));

        require(withinLimit(_value));

        addTotalSpentPerDay(getCurrentDay(), _value);

        bridgeSpecificActionsOnTokenTransfer(token, _from, _value, _data);

        return true;

    }



    /* solcov ignore next */

    function bridgeSpecificActionsOnTokenTransfer(ERC677 _token, address _from, uint256 _value, bytes _data) internal;

}



// File: contracts/upgradeable_contracts/BaseOverdrawManagement.sol



pragma solidity 0.4.24;





/**

 * @title BaseOverdrawManagement

 * @dev This contract implements basic functionality for tracking execution bridge operations that are out of limits.

 */

contract BaseOverdrawManagement is EternalStorage {

    event MediatorAmountLimitExceeded(address recipient, uint256 value, bytes32 indexed messageId);

    event AmountLimitExceeded(address recipient, uint256 value, bytes32 indexed transactionHash, bytes32 messageId);

    event AssetAboveLimitsFixed(bytes32 indexed messageId, uint256 value, uint256 remaining);



    bytes32 internal constant OUT_OF_LIMIT_AMOUNT = 0x145286dc85799b6fb9fe322391ba2d95683077b2adf34dd576dedc437e537ba7; // keccak256(abi.encodePacked("outOfLimitAmount"))



    /**

     * @dev Total amount coins/tokens that were bridged from the other side and are out of execution limits.

     * @return total amount of all bridge operations above limits.

     */

    function outOfLimitAmount() public view returns (uint256) {

        return uintStorage[OUT_OF_LIMIT_AMOUNT];

    }



    /**

     * @dev Internal function for updating a total amount that is out of execution limits.

     * @param _value new value for the total amount of bridge operations above limits.

     */

    function setOutOfLimitAmount(uint256 _value) internal {

        uintStorage[OUT_OF_LIMIT_AMOUNT] = _value;

    }



    /**

     * @dev Internal function for retrieving information about out-of-limits bridge operation.

     * @param _messageId id of the message that cause above-limits error.

     * @return (address of the receiver, amount of coins/tokens in the bridge operation)

     */

    function txAboveLimits(bytes32 _messageId) internal view returns (address recipient, uint256 value) {

        recipient = addressStorage[keccak256(abi.encodePacked("txOutOfLimitRecipient", _messageId))];

        value = uintStorage[keccak256(abi.encodePacked("txOutOfLimitValue", _messageId))];

    }



    /**

     * @dev Internal function for updating information about tbe out-of-limits bridge operation.

     * @param _recipient receiver specified in the bridge operation.

     * @param _value amount of coins/tokens inside the bridge operation.

     * @param _messageId id of the message that cause above-limits error.

     */

    function setTxAboveLimits(address _recipient, uint256 _value, bytes32 _messageId) internal {

        addressStorage[keccak256(abi.encodePacked("txOutOfLimitRecipient", _messageId))] = _recipient;

        setTxAboveLimitsValue(_value, _messageId);

    }



    /**

     * @dev Internal function for updating information about the remaining value of out-of-limits bridge operation.

     * @param _value amount of coins/tokens inside the bridge operation.

     * @param _messageId id of the message that cause above-limits error.

     */

    function setTxAboveLimitsValue(uint256 _value, bytes32 _messageId) internal {

        uintStorage[keccak256(abi.encodePacked("txOutOfLimitValue", _messageId))] = _value;

    }



    /* solcov ignore next */

    function fixAssetsAboveLimits(bytes32 messageId, bool unlockOnForeign, uint256 valueToUnlock) external;

}



// File: contracts/upgradeable_contracts/ReentrancyGuard.sol



pragma solidity 0.4.24;



contract ReentrancyGuard {

    function lock() internal returns (bool res) {

        assembly {

            // Even though this is not the same as boolStorage[keccak256(abi.encodePacked("lock"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            res := sload(0x6168652c307c1e813ca11cfb3a601f1cf3b22452021a5052d8b05f1f1f8a3e92) // keccak256(abi.encodePacked("lock"))

        }

    }



    function setLock(bool _lock) internal {

        assembly {

            // Even though this is not the same as boolStorage[keccak256(abi.encodePacked("lock"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            sstore(0x6168652c307c1e813ca11cfb3a601f1cf3b22452021a5052d8b05f1f1f8a3e92, _lock) // keccak256(abi.encodePacked("lock"))

        }

    }

}



// File: contracts/upgradeable_contracts/Upgradeable.sol



pragma solidity 0.4.24;





contract Upgradeable {

    // Avoid using onlyUpgradeabilityOwner name to prevent issues with implementation from proxy contract

    modifier onlyIfUpgradeabilityOwner() {

        require(msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner());

        /* solcov ignore next */

        _;

    }

}



// File: contracts/upgradeable_contracts/Sacrifice.sol



pragma solidity 0.4.24;



contract Sacrifice {

    constructor(address _recipient) public payable {

        selfdestruct(_recipient);

    }

}



// File: contracts/libraries/Address.sol



pragma solidity 0.4.24;





/**

 * @title Address

 * @dev Helper methods for Address type.

 */

library Address {

    /**

    * @dev Try to send native tokens to the address. If it fails, it will force the transfer by creating a selfdestruct contract

    * @param _receiver address that will receive the native tokens

    * @param _value the amount of native tokens to send

    */

    function safeSendValue(address _receiver, uint256 _value) internal {

        if (!_receiver.send(_value)) {

            (new Sacrifice).value(_value)(_receiver);

        }

    }

}



// File: contracts/libraries/SafeERC20.sol



pragma solidity 0.4.24;







/**

 * @title SafeERC20

 * @dev Helper methods for safe token transfers.

 * Functions perform additional checks to be sure that token transfer really happened.

 */

library SafeERC20 {

    using SafeMath for uint256;



    /**

    * @dev Same as ERC20.transfer(address,uint256) but with extra consistency checks.

    * @param _token address of the token contract

    * @param _to address of the receiver

    * @param _value amount of tokens to send

    */

    function safeTransfer(address _token, address _to, uint256 _value) internal {

        LegacyERC20(_token).transfer(_to, _value);

        assembly {

            if returndatasize {

                returndatacopy(0, 0, 32)

                if iszero(mload(0)) {

                    revert(0, 0)

                }

            }

        }

    }



    /**

    * @dev Same as ERC20.transferFrom(address,address,uint256) but with extra consistency checks.

    * @param _token address of the token contract

    * @param _from address of the sender

    * @param _value amount of tokens to send

    */

    function safeTransferFrom(address _token, address _from, uint256 _value) internal {

        LegacyERC20(_token).transferFrom(_from, address(this), _value);

        assembly {

            if returndatasize {

                returndatacopy(0, 0, 32)

                if iszero(mload(0)) {

                    revert(0, 0)

                }

            }

        }

    }

}



// File: contracts/upgradeable_contracts/Claimable.sol



pragma solidity 0.4.24;







/**

 * @title Claimable

 * @dev Implementation of the claiming utils that can be useful for withdrawing accidentally sent tokens that are not used in bridge operations.

 */

contract Claimable {

    using SafeERC20 for address;



    /**

     * Throws if a given address is equal to address(0)

     */

    modifier validAddress(address _to) {

        require(_to != address(0));

        /* solcov ignore next */

        _;

    }



    /**

     * @dev Withdraws the erc20 tokens or native coins from this contract.

     * Caller should additionally check that the claimed token is not a part of bridge operations (i.e. that token != erc20token()).

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimValues(address _token, address _to) internal validAddress(_to) {

        if (_token == address(0)) {

            claimNativeCoins(_to);

        } else {

            claimErc20Tokens(_token, _to);

        }

    }



    /**

     * @dev Internal function for withdrawing all native coins from the contract.

     * @param _to address of the coins receiver.

     */

    function claimNativeCoins(address _to) internal {

        uint256 value = address(this).balance;

        Address.safeSendValue(_to, value);

    }



    /**

     * @dev Internal function for withdrawing all tokens of ssome particular ERC20 contract from this contract.

     * @param _token address of the claimed ERC20 token.

     * @param _to address of the tokens receiver.

     */

    function claimErc20Tokens(address _token, address _to) internal {

        ERC20Basic token = ERC20Basic(_token);

        uint256 balance = token.balanceOf(this);

        _token.safeTransfer(_to, balance);

    }

}



// File: contracts/upgradeable_contracts/VersionableBridge.sol



pragma solidity 0.4.24;



contract VersionableBridge {

    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {

        return (6, 1, 0);

    }



    /* solcov ignore next */

    function getBridgeMode() external pure returns (bytes4);

}



// File: contracts/upgradeable_contracts/BasicAMBMediator.sol



pragma solidity 0.4.24;











/**

* @title BasicAMBMediator

* @dev Basic storage and methods needed by mediators to interact with AMB bridge.

*/

contract BasicAMBMediator is Ownable {

    bytes32 internal constant BRIDGE_CONTRACT = 0x811bbb11e8899da471f0e69a3ed55090fc90215227fc5fb1cb0d6e962ea7b74f; // keccak256(abi.encodePacked("bridgeContract"))

    bytes32 internal constant MEDIATOR_CONTRACT = 0x98aa806e31e94a687a31c65769cb99670064dd7f5a87526da075c5fb4eab9880; // keccak256(abi.encodePacked("mediatorContract"))

    bytes32 internal constant REQUEST_GAS_LIMIT = 0x2dfd6c9f781bb6bbb5369c114e949b69ebb440ef3d4dd6b2836225eb1dc3a2be; // keccak256(abi.encodePacked("requestGasLimit"))



    /**

    * @dev Throws if caller on the other side is not an associated mediator.

    */

    modifier onlyMediator {

        require(msg.sender == address(bridgeContract()));

        require(messageSender() == mediatorContractOnOtherSide());

        _;

    }



    /**

    * @dev Sets the AMB bridge contract address. Only the owner can call this method.

    * @param _bridgeContract the address of the bridge contract.

    */

    function setBridgeContract(address _bridgeContract) external onlyOwner {

        _setBridgeContract(_bridgeContract);

    }



    /**

    * @dev Sets the mediator contract address from the other network. Only the owner can call this method.

    * @param _mediatorContract the address of the mediator contract.

    */

    function setMediatorContractOnOtherSide(address _mediatorContract) external onlyOwner {

        _setMediatorContractOnOtherSide(_mediatorContract);

    }



    /**

    * @dev Sets the gas limit to be used in the message execution by the AMB bridge on the other network.

    * This value can't exceed the parameter maxGasPerTx defined on the AMB bridge.

    * Only the owner can call this method.

    * @param _requestGasLimit the gas limit for the message execution.

    */

    function setRequestGasLimit(uint256 _requestGasLimit) external onlyOwner {

        _setRequestGasLimit(_requestGasLimit);

    }



    /**

    * @dev Get the AMB interface for the bridge contract address

    * @return AMB interface for the bridge contract address

    */

    function bridgeContract() public view returns (IAMB) {

        return IAMB(addressStorage[BRIDGE_CONTRACT]);

    }



    /**

    * @dev Tells the mediator contract address from the other network.

    * @return the address of the mediator contract.

    */

    function mediatorContractOnOtherSide() public view returns (address) {

        return addressStorage[MEDIATOR_CONTRACT];

    }



    /**

    * @dev Tells the gas limit to be used in the message execution by the AMB bridge on the other network.

    * @return the gas limit for the message execution.

    */

    function requestGasLimit() public view returns (uint256) {

        return uintStorage[REQUEST_GAS_LIMIT];

    }



    /**

    * @dev Stores a valid AMB bridge contract address.

    * @param _bridgeContract the address of the bridge contract.

    */

    function _setBridgeContract(address _bridgeContract) internal {

        require(AddressUtils.isContract(_bridgeContract));

        addressStorage[BRIDGE_CONTRACT] = _bridgeContract;

    }



    /**

    * @dev Stores the mediator contract address from the other network.

    * @param _mediatorContract the address of the mediator contract.

    */

    function _setMediatorContractOnOtherSide(address _mediatorContract) internal {

        addressStorage[MEDIATOR_CONTRACT] = _mediatorContract;

    }



    /**

    * @dev Stores the gas limit to be used in the message execution by the AMB bridge on the other network.

    * @param _requestGasLimit the gas limit for the message execution.

    */

    function _setRequestGasLimit(uint256 _requestGasLimit) internal {

        require(_requestGasLimit <= maxGasPerTx());

        uintStorage[REQUEST_GAS_LIMIT] = _requestGasLimit;

    }



    /**

    * @dev Tells the address that generated the message on the other network that is currently being executed by

    * the AMB bridge.

    * @return the address of the message sender.

    */

    function messageSender() internal view returns (address) {

        return bridgeContract().messageSender();

    }



    /**

    * @dev Tells the id of the message originated on the other network.

    * @return the id of the message originated on the other network.

    */

    function messageId() internal view returns (bytes32) {

        return bridgeContract().messageId();

    }



    /**

    * @dev Tells the maximum gas limit that a message can use on its execution by the AMB bridge on the other network.

    * @return the maximum gas limit value.

    */

    function maxGasPerTx() internal view returns (uint256) {

        return bridgeContract().maxGasPerTx();

    }

}



// File: contracts/upgradeable_contracts/TransferInfoStorage.sol



pragma solidity 0.4.24;





contract TransferInfoStorage is EternalStorage {

    /**

    * @dev Stores the value of a message sent to the AMB bridge.

    * @param _messageId of the message sent to the bridge.

    * @param _value amount of tokens bridged.

    */

    function setMessageValue(bytes32 _messageId, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("messageValue", _messageId))] = _value;

    }



    /**

    * @dev Tells the amount of tokens of a message sent to the AMB bridge.

    * @return value representing amount of tokens.

    */

    function messageValue(bytes32 _messageId) internal view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("messageValue", _messageId))];

    }



    /**

    * @dev Stores the receiver of a message sent to the AMB bridge.

    * @param _messageId of the message sent to the bridge.

    * @param _recipient receiver of the tokens bridged.

    */

    function setMessageRecipient(bytes32 _messageId, address _recipient) internal {

        addressStorage[keccak256(abi.encodePacked("messageRecipient", _messageId))] = _recipient;

    }



    /**

    * @dev Tells the receiver of a message sent to the AMB bridge.

    * @return address of the receiver.

    */

    function messageRecipient(bytes32 _messageId) internal view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("messageRecipient", _messageId))];

    }



    /**

    * @dev Sets that the message sent to the AMB bridge has been fixed.

    * @param _messageId of the message sent to the bridge.

    */

    function setMessageFixed(bytes32 _messageId) internal {

        boolStorage[keccak256(abi.encodePacked("messageFixed", _messageId))] = true;

    }



    /**

    * @dev Tells if a message sent to the AMB bridge has been fixed.

    * @return bool indicating the status of the message.

    */

    function messageFixed(bytes32 _messageId) public view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("messageFixed", _messageId))];

    }

}



// File: contracts/upgradeable_contracts/TokenBridgeMediator.sol



pragma solidity 0.4.24;









/**

* @title TokenBridgeMediator

* @dev Common mediator functionality to handle operations related to token bridge messages sent to AMB bridge.

*/

contract TokenBridgeMediator is BasicAMBMediator, BasicTokenBridge, TransferInfoStorage {

    event FailedMessageFixed(bytes32 indexed messageId, address recipient, uint256 value);

    event TokensBridgingInitiated(address indexed sender, uint256 value, bytes32 indexed messageId);

    event TokensBridged(address indexed recipient, uint256 value, bytes32 indexed messageId);



    /**

    * @dev Call AMB bridge to require the invocation of handleBridgedTokens method of the mediator on the other network.

    * Store information related to the bridged tokens in case the message execution fails on the other network

    * and the action needs to be fixed/rolled back.

    * @param _from address of sender, if bridge operation fails, tokens will be returned to this address

    * @param _receiver address of receiver on the other side, will eventually receive bridged tokens

    * @param _value bridged amount of tokens

    */

    function passMessage(address _from, address _receiver, uint256 _value) internal {

        bytes4 methodSelector = this.handleBridgedTokens.selector;

        bytes memory data = abi.encodeWithSelector(methodSelector, _receiver, _value);



        bytes32 _messageId = bridgeContract().requireToPassMessage(

            mediatorContractOnOtherSide(),

            data,

            requestGasLimit()

        );



        setMessageValue(_messageId, _value);

        setMessageRecipient(_messageId, _from);



        emit TokensBridgingInitiated(_from, _value, _messageId);

    }



    /**

    * @dev Handles the bridged tokens. Checks that the value is inside the execution limits and invokes the method

    * to execute the Mint or Unlock accordingly.

    * @param _recipient address that will receive the tokens

    * @param _value amount of tokens to be received

    */

    function handleBridgedTokens(address _recipient, uint256 _value) external onlyMediator {

        if (withinExecutionLimit(_value)) {

            addTotalExecutedPerDay(getCurrentDay(), _value);

            executeActionOnBridgedTokens(_recipient, _value);

        } else {

            executeActionOnBridgedTokensOutOfLimit(_recipient, _value);

        }

    }



    /**

    * @dev Method to be called when a bridged message execution failed. It will generate a new message requesting to

    * fix/roll back the transferred assets on the other network.

    * @param _messageId id of the message which execution failed.

    */

    function requestFailedMessageFix(bytes32 _messageId) external {

        require(!bridgeContract().messageCallStatus(_messageId));

        require(bridgeContract().failedMessageReceiver(_messageId) == address(this));

        require(bridgeContract().failedMessageSender(_messageId) == mediatorContractOnOtherSide());



        bytes4 methodSelector = this.fixFailedMessage.selector;

        bytes memory data = abi.encodeWithSelector(methodSelector, _messageId);

        bridgeContract().requireToPassMessage(mediatorContractOnOtherSide(), data, requestGasLimit());

    }



    /**

    * @dev Handles the request to fix transferred assets which bridged message execution failed on the other network.

    * It uses the information stored by passMessage method when the assets were initially transferred

    * @param _messageId id of the message which execution failed on the other network.

    */

    function fixFailedMessage(bytes32 _messageId) external onlyMediator {

        require(!messageFixed(_messageId));



        address recipient = messageRecipient(_messageId);

        uint256 value = messageValue(_messageId);

        setMessageFixed(_messageId);

        executeActionOnFixedTokens(recipient, value);

        emit FailedMessageFixed(_messageId, recipient, value);

    }



    /* solcov ignore next */

    function executeActionOnBridgedTokensOutOfLimit(address _recipient, uint256 _value) internal;



    /* solcov ignore next */

    function executeActionOnBridgedTokens(address _recipient, uint256 _value) internal;



    /* solcov ignore next */

    function executeActionOnFixedTokens(address _recipient, uint256 _value) internal;

}



// File: contracts/upgradeable_contracts/amb_erc677_to_erc677/BasicAMBErc677ToErc677.sol



pragma solidity 0.4.24;























/**

* @title BasicAMBErc677ToErc677

* @dev Common functionality for erc677-to-erc677 mediator intended to work on top of AMB bridge.

*/

contract BasicAMBErc677ToErc677 is

    Initializable,

    ReentrancyGuard,

    Upgradeable,

    Claimable,

    VersionableBridge,

    BaseOverdrawManagement,

    BaseERC677Bridge,

    TokenBridgeMediator

{

    function initialize(

        address _bridgeContract,

        address _mediatorContract,

        address _erc677token,

        uint256[3] _dailyLimitMaxPerTxMinPerTxArray, // [ 0 = _dailyLimit, 1 = _maxPerTx, 2 = _minPerTx ]

        uint256[2] _executionDailyLimitExecutionMaxPerTxArray, // [ 0 = _executionDailyLimit, 1 = _executionMaxPerTx ]

        uint256 _requestGasLimit,

        int256 _decimalShift,

        address _owner

    ) public onlyRelevantSender returns (bool) {

        require(!isInitialized());



        _setBridgeContract(_bridgeContract);

        _setMediatorContractOnOtherSide(_mediatorContract);

        setErc677token(_erc677token);

        _setLimits(_dailyLimitMaxPerTxMinPerTxArray);

        _setExecutionLimits(_executionDailyLimitExecutionMaxPerTxArray);

        _setRequestGasLimit(_requestGasLimit);

        _setDecimalShift(_decimalShift);

        _setOwner(_owner);

        setInitialize();



        return isInitialized();

    }



    /**

    * @dev Public getter for token contract.

    * @return address of the used token contract

    */

    function erc677token() public view returns (ERC677) {

        return _erc677token();

    }



    function bridgeContractOnOtherSide() internal view returns (address) {

        return mediatorContractOnOtherSide();

    }



    /**

    * @dev Initiates the bridge operation that will lock the amount of tokens transferred and mint the tokens on

    * the other network. The user should first call Approve method of the ERC677 token.

    * @param _receiver address that will receive the minted tokens on the other network.

    * @param _value amount of tokens to be transferred to the other network.

    */

    function relayTokens(address _receiver, uint256 _value) external {

        // This lock is to prevent calling passMessage twice if a ERC677 token is used.

        // When transferFrom is called, after the transfer, the ERC677 token will call onTokenTransfer from this contract

        // which will call passMessage.

        require(!lock());

        ERC677 token = erc677token();

        address to = address(this);

        require(withinLimit(_value));

        addTotalSpentPerDay(getCurrentDay(), _value);



        setLock(true);

        token.transferFrom(msg.sender, to, _value);

        setLock(false);

        bridgeSpecificActionsOnTokenTransfer(token, msg.sender, _value, abi.encodePacked(_receiver));

    }



    function onTokenTransfer(address _from, uint256 _value, bytes _data) external returns (bool) {

        ERC677 token = erc677token();

        require(msg.sender == address(token));

        if (!lock()) {

            require(withinLimit(_value));

            addTotalSpentPerDay(getCurrentDay(), _value);

        }

        bridgeSpecificActionsOnTokenTransfer(token, _from, _value, _data);

        return true;

    }



    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {

        return (1, 4, 0);

    }



    function getBridgeMode() external pure returns (bytes4 _data) {

        return 0x76595b56; // bytes4(keccak256(abi.encodePacked("erc-to-erc-amb")))

    }



    /**

    * @dev Execute the action to be performed when the bridge tokens are out of execution limits.

    * @param _recipient address intended to receive the tokens

    * @param _value amount of tokens to be received

    */

    function executeActionOnBridgedTokensOutOfLimit(address _recipient, uint256 _value) internal {

        bytes32 _messageId = messageId();

        address recipient;

        uint256 value;

        (recipient, value) = txAboveLimits(_messageId);

        require(recipient == address(0) && value == 0);

        setOutOfLimitAmount(outOfLimitAmount().add(_value));

        setTxAboveLimits(_recipient, _value, _messageId);

        emit MediatorAmountLimitExceeded(_recipient, _value, _messageId);

    }



    /**

    * @dev Fixes locked tokens, that were out of execution limits during the call to handleBridgedTokens

    * @param messageId reference for bridge operation that was out of execution limits

    * @param unlockOnOtherSide true if fixed tokens should be unlocked to the other side of the bridge

    * @param valueToUnlock unlocked amount of tokens, should be less than saved txAboveLimitsValue.

    * Should be less than maxPerTx(), if tokens need to be unlocked on the other side.

    */

    function fixAssetsAboveLimits(bytes32 messageId, bool unlockOnOtherSide, uint256 valueToUnlock)

        external

        onlyIfUpgradeabilityOwner

    {

        (address recipient, uint256 value) = txAboveLimits(messageId);

        require(recipient != address(0) && value > 0 && value >= valueToUnlock);

        setOutOfLimitAmount(outOfLimitAmount().sub(valueToUnlock));

        uint256 pendingValue = value.sub(valueToUnlock);

        setTxAboveLimitsValue(pendingValue, messageId);

        emit AssetAboveLimitsFixed(messageId, valueToUnlock, pendingValue);

        if (unlockOnOtherSide) {

            require(valueToUnlock <= maxPerTx());

            passMessage(recipient, recipient, valueToUnlock);

        }

    }

}



// File: contracts/upgradeable_contracts/MediatorBalanceStorage.sol



pragma solidity 0.4.24;





/**

 * @title MediatorBalanceStorage

 * @dev Storage helpers for the mediator balance tracking.

 */

contract MediatorBalanceStorage is EternalStorage {

    bytes32 internal constant MEDIATOR_BALANCE = 0x3db340e280667ee926fa8c51e8f9fcf88a0ff221a66d84d63b4778127d97d139; // keccak256(abi.encodePacked("mediatorBalance"))



    /**

     * @dev Tells the expected mediator balance.

     * @return the current expected mediator balance.

     */

    function mediatorBalance() public view returns (uint256) {

        return uintStorage[MEDIATOR_BALANCE];

    }



    /**

     * @dev Sets the expected mediator balance of the contract.

     * @param _balance the new expected mediator balance value.

     */

    function _setMediatorBalance(uint256 _balance) internal {

        uintStorage[MEDIATOR_BALANCE] = _balance;

    }

}



// File: contracts/upgradeable_contracts/amb_erc677_to_erc677/ForeignAMBErc677ToErc677.sol



pragma solidity 0.4.24;









/**

* @title ForeignAMBErc677ToErc677

* @dev Foreign side implementation for erc677-to-erc677 mediator intended to work on top of AMB bridge.

* It is designed to be used as an implementation contract of EternalStorageProxy contract.

*/

contract ForeignAMBErc677ToErc677 is BasicAMBErc677ToErc677, MediatorBalanceStorage {

    using SafeERC20 for ERC677;



    /**

     * @dev Executes action on the request to withdraw tokens relayed from the other network

     * @param _recipient address of tokens receiver

     * @param _value amount of bridged tokens

     */

    function executeActionOnBridgedTokens(address _recipient, uint256 _value) internal {

        uint256 value = _unshiftValue(_value);

        bytes32 _messageId = messageId();



        _setMediatorBalance(mediatorBalance().sub(value));

        erc677token().safeTransfer(_recipient, value);



        emit TokensBridged(_recipient, value, _messageId);

    }



    /**

    * @dev Initiates the bridge operation that will lock the amount of tokens transferred and mint the tokens on

    * the other network. The user should first call Approve method of the ERC677 token.

    * @param _receiver address that will receive the minted tokens on the other network.

    * @param _value amount of tokens to be transferred to the other network.

    */

    function relayTokens(address _receiver, uint256 _value) external {

        // This lock is to prevent calling passMessage twice if a ERC677 token is used.

        // When transferFrom is called, after the transfer, the ERC677 token will call onTokenTransfer from this contract

        // which will call passMessage.

        require(!lock());

        ERC677 token = erc677token();

        require(withinLimit(_value));

        addTotalSpentPerDay(getCurrentDay(), _value);



        setLock(true);

        token.safeTransferFrom(msg.sender, _value);

        setLock(false);

        bridgeSpecificActionsOnTokenTransfer(token, msg.sender, _value, abi.encodePacked(_receiver));

    }



    /**

     * @dev Allows to send to the other network the amount of locked tokens that can be forced into the contract

     * without the invocation of the required methods.

     * @param _receiver the address that will receive the tokens on the other network

     */

    function fixMediatorBalance(address _receiver) external onlyIfUpgradeabilityOwner validAddress(_receiver) {

        uint256 balance = _erc677token().balanceOf(address(this));

        uint256 expectedBalance = mediatorBalance();

        require(balance > expectedBalance);

        uint256 diff = balance - expectedBalance;

        uint256 available = maxAvailablePerTx();

        require(available > 0);

        if (diff > available) {

            diff = available;

        }

        addTotalSpentPerDay(getCurrentDay(), diff);

        _setMediatorBalance(expectedBalance.add(diff));

        passMessage(_receiver, _receiver, diff);

    }



    /**

     * @dev Executes action on deposit of bridged tokens

     * @param _from address of tokens sender

     * @param _value requsted amount of bridged tokens

     * @param _data alternative receiver, if specified

     */

    function bridgeSpecificActionsOnTokenTransfer(

        ERC677, /* _token */

        address _from,

        uint256 _value,

        bytes _data

    ) internal {

        if (!lock()) {

            _setMediatorBalance(mediatorBalance().add(_value));

            passMessage(_from, chooseReceiver(_from, _data), _value);

        }

    }



    /**

    * @dev Unlock back the amount of tokens that were bridged to the other network but failed.

    * @param _recipient address that will receive the tokens

    * @param _value amount of tokens to be received

    */

    function executeActionOnFixedTokens(address _recipient, uint256 _value) internal {

        _setMediatorBalance(mediatorBalance().sub(_value));

        erc677token().safeTransfer(_recipient, _value);

    }



    /**

    * @dev Allows to transfer any locked token on this contract that is not part of the bridge operations.

    * @param _token address of the token, if it is not provided, native tokens will be transferred.

    * @param _to address that will receive the locked tokens on this contract.

    */

    function claimTokens(address _token, address _to) external onlyIfUpgradeabilityOwner {

        require(_token != address(_erc677token()));

        claimValues(_token, _to);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ForeignBridge.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-11-03

*/



/**

 *Submitted for verification at Etherscan.io on 2019-01-07

*/



pragma solidity 0.4.24;



// File: contracts/ERC677Receiver.sol



contract ERC677Receiver {

    function onTokenTransfer(address _from, uint _value, bytes _data) external returns(bool);

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol



/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

    function totalSupply() public view returns (uint256);

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public view returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: contracts/ERC677.sol



contract ERC677 is ERC20 {

    event Transfer(address indexed from, address indexed to, uint value, bytes data);



    function transferAndCall(address, uint, bytes) external returns (bool);



}



// File: contracts/IBurnableMintableERC677Token.sol



contract IBurnableMintableERC677Token is ERC677 {

    function mint(address, uint256) public returns (bool);

    function burn(uint256 _value) public;

    function claimTokens(address _token, address _to) public;

}



// File: contracts/IBridgeValidators.sol



interface IBridgeValidators {

    function isValidator(address _validator) public view returns(bool);

    function requiredSignatures() public view returns(uint256);

    function owner() public view returns(address);

}



// File: contracts/libraries/Message.sol



library Message {

    // function uintToString(uint256 inputValue) internal pure returns (string) {

    //     // figure out the length of the resulting string

    //     uint256 length = 0;

    //     uint256 currentValue = inputValue;

    //     do {

    //         length++;

    //         currentValue /= 10;

    //     } while (currentValue != 0);

    //     // allocate enough memory

    //     bytes memory result = new bytes(length);

    //     // construct the string backwards

    //     uint256 i = length - 1;

    //     currentValue = inputValue;

    //     do {

    //         result[i--] = byte(48 + currentValue % 10);

    //         currentValue /= 10;

    //     } while (currentValue != 0);

    //     return string(result);

    // }



    function addressArrayContains(address[] array, address value) internal pure returns (bool) {

        for (uint256 i = 0; i < array.length; i++) {

            if (array[i] == value) {

                return true;

            }

        }

        return false;

    }

    // layout of message :: bytes:

    // offset  0: 32 bytes :: uint256 - message length

    // offset 32: 20 bytes :: address - recipient address

    // offset 52: 32 bytes :: uint256 - value

    // offset 84: 32 bytes :: bytes32 - transaction hash

    // offset 116: 32 bytes :: uint256 - home gas price



    // bytes 1 to 32 are 0 because message length is stored as little endian.

    // mload always reads 32 bytes.

    // so we can and have to start reading recipient at offset 20 instead of 32.

    // if we were to read at 32 the address would contain part of value and be corrupted.

    // when reading from offset 20 mload will read 12 zero bytes followed

    // by the 20 recipient address bytes and correctly convert it into an address.

    // this saves some storage/gas over the alternative solution

    // which is padding address to 32 bytes and reading recipient at offset 32.

    // for more details see discussion in:

    // https://github.com/paritytech/parity-bridge/issues/61

    function parseMessage(bytes message)

    internal

    pure

    returns(address recipient, uint256 amount, bytes32 txHash)

    {

        require(isMessageValid(message));

        assembly {

            recipient := and(mload(add(message, 20)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)

            amount := mload(add(message, 52))

            txHash := mload(add(message, 84))

        }

    }



    function isMessageValid(bytes _msg) internal pure returns(bool) {

        return _msg.length == 116;

    }



    function recoverAddressFromSignedMessage(bytes signature, bytes message) internal pure returns (address) {

        require(signature.length == 65);

        bytes32 r;

        bytes32 s;

        bytes1 v;

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := mload(add(signature, 0x60))

        }

        return ecrecover(hashMessage(message), uint8(v), r, s);

    }



    function hashMessage(bytes message) internal pure returns (bytes32) {

        bytes memory prefix = "\x19Ethereum Signed Message:\n";

        // message is always 116 length

        string memory msgLength = "116";

        return keccak256(prefix, msgLength, message);

    }



    function hasEnoughValidSignatures(

        bytes _message,

        uint8[] _vs,

        bytes32[] _rs,

        bytes32[] _ss,

        IBridgeValidators _validatorContract) internal view {

        require(isMessageValid(_message));

        uint256 requiredSignatures = _validatorContract.requiredSignatures();

        require(_vs.length >= requiredSignatures);

        bytes32 hash = hashMessage(_message);

        address[] memory encounteredAddresses = new address[](requiredSignatures);



        for (uint256 i = 0; i < requiredSignatures; i++) {

            address recoveredAddress = ecrecover(hash, _vs[i], _rs[i], _ss[i]);

            require(_validatorContract.isValidator(recoveredAddress));

            if (addressArrayContains(encounteredAddresses, recoveredAddress)) {

                revert();

            }

            encounteredAddresses[i] = recoveredAddress;

        }

    }

}



// File: contracts/libraries/SafeMath.sol



/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



    /**

    * @dev Multiplies two numbers, throws on overflow.

    */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        }

        uint256 c = a * b;

        assert(c / a == b);

        return c;

    }



    /**

    * @dev Integer division of two numbers, truncating the quotient.

    */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // assert(b > 0); // Solidity automatically throws when dividing by 0

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;

    }



    /**

    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

    */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        assert(b <= a);

        return a - b;

    }



    /**

    * @dev Adds two numbers, throws on overflow.

    */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        assert(c >= a);

        return c;

    }

}



// File: contracts/IOwnedUpgradeabilityProxy.sol



interface IOwnedUpgradeabilityProxy {

    function proxyOwner() public view returns (address);

}



// File: contracts/upgradeable_contracts/OwnedUpgradeability.sol



contract OwnedUpgradeability {



    function upgradeabilityAdmin() public view returns (address) {

        return IOwnedUpgradeabilityProxy(this).proxyOwner();

    }



    // Avoid using onlyProxyOwner name to prevent issues with implementation from proxy contract

    modifier onlyIfOwnerOfProxy() {

        require(msg.sender == upgradeabilityAdmin());

        _;

    }

}



// File: contracts/upgradeability/EternalStorage.sol



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {



    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;



}



// File: contracts/upgradeable_contracts/Ownable.sol



/**

 * @title Ownable

 * @dev This contract has an owner address providing basic authorization control

 */

contract Ownable is EternalStorage {

    /**

    * @dev Event to show ownership has been transferred

    * @param previousOwner representing the address of the previous owner

    * @param newOwner representing the address of the new owner

    */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner());

        _;

    }



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function owner() public view returns (address) {

        return addressStorage[keccak256("owner")];

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner the address to transfer ownership to.

    */

    function transferOwnership(address newOwner) public onlyOwner {

        require(newOwner != address(0));

        setOwner(newOwner);

    }



    /**

    * @dev Sets a new owner address

    */

    function setOwner(address newOwner) internal {

        emit OwnershipTransferred(owner(), newOwner);

        addressStorage[keccak256("owner")] = newOwner;

    }

}



// File: contracts/upgradeable_contracts/Validatable.sol



contract Validatable is EternalStorage {



    function validatorContract() public view returns(IBridgeValidators) {

        return IBridgeValidators(addressStorage[keccak256("validatorContract")]);

    }



    modifier onlyValidator() {

        require(validatorContract().isValidator(msg.sender));

        _;

    }

}



// File: contracts/upgradeable_contracts/U_BasicBridge.sol



contract BasicBridge is EternalStorage, Validatable, Ownable {

    event GasPriceChanged(uint256 gasPrice);

    event RequiredBlockConfirmationChanged(uint256 requiredBlockConfirmations);



    function setGasPrice(uint256 _gasPrice) public onlyOwner {

        require(_gasPrice > 0);

        uintStorage[keccak256("gasPrice")] = _gasPrice;

        emit GasPriceChanged(_gasPrice);

    }



    function gasPrice() public view returns(uint256) {

        return uintStorage[keccak256("gasPrice")];

    }



    function setRequiredBlockConfirmations(uint256 _blockConfirmations) public onlyOwner {

        require(_blockConfirmations > 0);

        uintStorage[keccak256("requiredBlockConfirmations")] = _blockConfirmations;

        emit RequiredBlockConfirmationChanged(_blockConfirmations);

    }



    function requiredBlockConfirmations() public view returns(uint256) {

        return uintStorage[keccak256("requiredBlockConfirmations")];

    }

}



// File: contracts/upgradeable_contracts/U_ForeignBridge.sol



contract ForeignBridge is ERC677Receiver, BasicBridge, OwnedUpgradeability {

    using SafeMath for uint256;

    /// triggered when relay of deposit from HomeBridge is complete

    event Deposit(address recipient, uint value, bytes32 transactionHash);



    /// Event created on money withdraw.

    event Withdraw(address recipient, uint256 value, uint256 homeGasPrice);



    /// Collected signatures which should be relayed to home chain.

    event CollectedSignatures(address authorityResponsibleForRelay, bytes32 messageHash);



    event GasConsumptionLimitsUpdated(uint256 gasLimitDepositRelay, uint256 gasLimitWithdrawConfirm);



    event SignedForDeposit(address indexed signer, bytes32 transactionHash);

    event SignedForWithdraw(address indexed signer, bytes32 messageHash);

    event DailyLimit(uint256 newLimit);

    event HomeDailyLimit(uint256 newLimit);



    function initialize(

        address _validatorContract,

        address _erc677token,

        uint256 _foreignDailyLimit,

        uint256 _maxPerTx,

        uint256 _minPerTx,

        uint256 _foreignGasPrice,

        uint256 _requiredBlockConfirmations

    ) public returns(bool) {

        require(!isInitialized());

        require(_validatorContract != address(0));

        require(_minPerTx > 0 && _maxPerTx > _minPerTx && _foreignDailyLimit > _maxPerTx);

        require(_foreignGasPrice > 0);

        addressStorage[keccak256("validatorContract")] = _validatorContract;

        setErc677token(_erc677token);

        uintStorage[keccak256("foreignDailyLimit")] = _foreignDailyLimit;

        uintStorage[keccak256("deployedAtBlock")] = block.number;

        uintStorage[keccak256("maxPerTx")] = _maxPerTx;

        uintStorage[keccak256("minPerTx")] = _minPerTx;

        uintStorage[keccak256("gasPrice")] = _foreignGasPrice;

        uintStorage[keccak256("requiredBlockConfirmations")] = _requiredBlockConfirmations;

        setInitialize(true);

        return isInitialized();

    }



    function upgradeFrom2To3() public {

        require(owner() == address(0));

        setOwner(validatorContract().owner());

    }



    function onTokenTransfer(address _from, uint256 _value, bytes /*_data*/) external returns(bool) {

        require(msg.sender == address(erc677token()));

        require(withinLimit(_value));

        setTotalSpentPerDay(getCurrentDay(), totalSpentPerDay(getCurrentDay()).add(_value));

        erc677token().burn(_value);

        emit Withdraw(_from, _value, gasPriceForCompensationAtHomeSide());

        return true;

    }



    function setMaxPerTx(uint256 _maxPerTx) external onlyOwner {

        require(_maxPerTx < foreignDailyLimit());

        uintStorage[keccak256("maxPerTx")] = _maxPerTx;

    }



    function setHomeMaxPerTx(uint256 _maxPerTx) external onlyOwner {

        require(_maxPerTx < homeDailyLimit());

        uintStorage[keccak256("homeMaxPerTx")] = _maxPerTx;

    }



    function setMinPerTx(uint256 _minPerTx) external onlyOwner {

        require(_minPerTx < foreignDailyLimit() && _minPerTx < maxPerTx());

        uintStorage[keccak256("minPerTx")] = _minPerTx;

    }



    function claimTokens(address _token, address _to) external onlyIfOwnerOfProxy {

        require(_to != address(0));

        if (_token == address(0)) {

            _to.transfer(address(this).balance);

            return;

        }



        ERC20Basic token = ERC20Basic(_token);

        uint256 balance = token.balanceOf(this);

        require(token.transfer(_to, balance));

    }



    function claimTokensFromErc677(address _token, address _to) external onlyIfOwnerOfProxy {

        erc677token().claimTokens(_token, _to);

    }



    function minPerTx() public view returns(uint256) {

        return uintStorage[keccak256("minPerTx")];

    }



    function maxPerTx() public view returns(uint256) {

        return uintStorage[keccak256("maxPerTx")];

    }



    function homeMaxPerTx() public view returns(uint256) {

        return uintStorage[keccak256("homeMaxPerTx")];

    }



    function totalSpentPerDay(uint256 _day) public view returns(uint256) {

        return uintStorage[keccak256("totalSpentPerDay", _day)];

    }



    function totalExecutedPerDay(uint256 _day) public view returns(uint256) {

        return uintStorage[keccak256("totalExecutedPerDay", _day)];

    }



    function deployedAtBlock() public view returns(uint256) {

        return uintStorage[keccak256("deployedAtBlock")];

    }



    function gasLimitDepositRelay() public view returns(uint256) {

        return uintStorage[keccak256("gasLimitDepositRelay")];

    }



    function gasLimitWithdrawConfirm() public view returns(uint256) {

        return uintStorage[keccak256("gasLimitWithdrawConfirm")];

    }



    function foreignDailyLimit() public view returns(uint256) {

        return uintStorage[keccak256("foreignDailyLimit")];

    }



    function homeDailyLimit() public view returns(uint256) {

        return uintStorage[keccak256("homeDailyLimit")];

    }



    function erc677token() public view returns(IBurnableMintableERC677Token) {

        return IBurnableMintableERC677Token(addressStorage[keccak256("erc677token")]);

    }



    function setGasLimits(uint256 _gasLimitDepositRelay, uint256 _gasLimitWithdrawConfirm) external onlyOwner {

        uintStorage[keccak256("gasLimitDepositRelay")] = _gasLimitDepositRelay;

        uintStorage[keccak256("gasLimitWithdrawConfirm")] = _gasLimitWithdrawConfirm;

        emit GasConsumptionLimitsUpdated(gasLimitDepositRelay(), gasLimitWithdrawConfirm());

    }



    function deposit(address recipient, uint256 value, bytes32 transactionHash) external onlyValidator {

        bytes32 hashMsg = keccak256(recipient, value, transactionHash);

        bytes32 hashSender = keccak256(msg.sender, hashMsg);

        require(withinHomeLimit(value));

        // Duplicated deposits

        require(!depositsSigned(hashSender));

        setDepositsSigned(hashSender, true);



        uint256 signed = numDepositsSigned(hashMsg);

        require(!isAlreadyProcessed(signed));

        // the check above assumes that the case when the value could be overflew will not happen in the addition operation below

        signed = signed + 1;



        setNumDepositsSigned(hashMsg, signed);



        emit SignedForDeposit(msg.sender, transactionHash);



        if (signed >= validatorContract().requiredSignatures()) {

            // If the bridge contract does not own enough tokens to transfer

            // it will couse funds lock on the home side of the bridge

            setTotalExecutedPerDay(getCurrentDay(), totalExecutedPerDay(getCurrentDay()).add(value));

            setNumDepositsSigned(hashMsg, markAsProcessed(signed));

            erc677token().mint(recipient, value);

            emit Deposit(recipient, value, transactionHash);

        }

    }



    /// Should be used as sync tool

    ///

    /// Message is a message that should be relayed to main chain once authorities sign it.

    ///

    /// for withdraw message contains:

    /// withdrawal recipient (bytes20)

    /// withdrawal value (uint)

    /// foreign transaction hash (bytes32) // to avoid transaction duplication

    function submitSignature(bytes signature, bytes message) external onlyValidator {

        // ensure that `signature` is really `message` signed by `msg.sender`

        require(Message.isMessageValid(message));

        require(msg.sender == Message.recoverAddressFromSignedMessage(signature, message));

        bytes32 hashMsg = keccak256(message);

        bytes32 hashSender = keccak256(msg.sender, hashMsg);



        uint256 signed = numMessagesSigned(hashMsg);

        require(!isAlreadyProcessed(signed));

        // the check above assumes that the case when the value could be overflew will not happen in the addition operation below

        signed = signed + 1;

        if (signed > 1) {

            // Duplicated signatures

            require(!messagesSigned(hashSender));

        } else {

            setMessages(hashMsg, message);

        }

        setMessagesSigned(hashSender, true);



        bytes32 signIdx = keccak256(hashMsg, (signed-1));

        setSignatures(signIdx, signature);



        setNumMessagesSigned(hashMsg, signed);



        emit SignedForWithdraw(msg.sender, hashMsg);

        if (signed >= validatorContract().requiredSignatures()) {

            setNumMessagesSigned(hashMsg, markAsProcessed(signed));

            emit CollectedSignatures(msg.sender, hashMsg);

        }

    }



    function gasPriceForCompensationAtHomeSide() public pure returns(uint256) {

        return 20000000000 wei;

    }



    function isAlreadyProcessed(uint256 _number) public pure returns(bool) {

        return _number & 2**255 == 2**255;

    }



    function signature(bytes32 _hash, uint256 _index) public view returns (bytes) {

        bytes32 signIdx = keccak256(_hash, _index);

        return signatures(signIdx);

    }



    /// Get message

    function message(bytes32 _hash) public view returns (bytes) {

        return messages(_hash);

    }



    function getCurrentDay() public view returns(uint256) {

        return now / 1 days;

    }



    function setForeignDailyLimit(uint256 _foreignDailyLimit) public onlyOwner {

        uintStorage[keccak256("foreignDailyLimit")] = _foreignDailyLimit;

        emit DailyLimit(_foreignDailyLimit);

    }



    function setHomeDailyLimit(uint256 _homeDailyLimit) external onlyOwner {

        uintStorage[keccak256("homeDailyLimit")] = _homeDailyLimit;

        emit HomeDailyLimit(_homeDailyLimit);

    }



    function withinLimit(uint256 _amount) public view returns(bool) {

        uint256 nextLimit = totalSpentPerDay(getCurrentDay()).add(_amount);

        return foreignDailyLimit() >= nextLimit && _amount <= maxPerTx() && _amount >= minPerTx();

    }



    function withinHomeLimit(uint256 _amount) public view returns(bool) {

        uint256 nextLimit = totalExecutedPerDay(getCurrentDay()).add(_amount);

        return homeDailyLimit() >= nextLimit && _amount <= homeMaxPerTx();

    }



    function isInitialized() public view returns(bool) {

        return boolStorage[keccak256("isInitialized")];

    }



    function messages(bytes32 _hash) private view returns(bytes) {

        return bytesStorage[keccak256("messages", _hash)];

    }



    function setMessages(bytes32 _hash, bytes _message) private {

        bytesStorage[keccak256("messages", _hash)] = _message;

    }



    function signatures(bytes32 _hash) private view returns(bytes) {

        return bytesStorage[keccak256("signatures", _hash)];

    }



    function setSignatures(bytes32 _hash, bytes _signature) private {

        bytesStorage[keccak256("signatures", _hash)] = _signature;

    }



    function messagesSigned(bytes32 _message) public view returns(bool) {

        return boolStorage[keccak256("messagesSigned", _message)];

    }



    function depositsSigned(bytes32 _deposit) public view returns(bool) {

        return boolStorage[keccak256("depositsSigned", _deposit)];

    }



    function markAsProcessed(uint256 _v) private pure returns(uint256) {

        return _v | 2 ** 255;

    }



    function numMessagesSigned(bytes32 _message) private view returns(uint256) {

        return uintStorage[keccak256("numMessagesSigned", _message)];

    }



    function numDepositsSigned(bytes32 _deposit) private view returns(uint256) {

        return uintStorage[keccak256("numDepositsSigned", _deposit)];

    }



    function setMessagesSigned(bytes32 _hash, bool _status) private {

        boolStorage[keccak256("messagesSigned", _hash)] = _status;

    }



    function setDepositsSigned(bytes32 _deposit, bool _status) private {

        boolStorage[keccak256("depositsSigned", _deposit)] = _status;

    }



    function setNumMessagesSigned(bytes32 _message, uint256 _number) private {

        uintStorage[keccak256("numMessagesSigned", _message)] = _number;

    }



    function setNumDepositsSigned(bytes32 _deposit, uint256 _number) private {

        uintStorage[keccak256("numDepositsSigned", _deposit)] = _number;

    }



    function setTotalSpentPerDay(uint256 _day, uint256 _value) private {

        uintStorage[keccak256("totalSpentPerDay", _day)] = _value;

    }



    function setTotalExecutedPerDay(uint256 _day, uint256 _value) private {

        uintStorage[keccak256("totalExecutedPerDay", _day)] = _value;

    }



    function setErc677token(address _token) private {

        require(_token != address(0));

        addressStorage[keccak256("erc677token")] = _token;

    }



    function setInitialize(bool _status) private {

        boolStorage[keccak256("isInitialized")] = _status;

    }



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ForeignBridgeErcToNative.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-12

*/



/**

 *Submitted for verification at Etherscan.io on 2020-04-16

*/



// File: contracts/upgradeability/EternalStorage.sol



pragma solidity 0.4.24;



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {

    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;



}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol



pragma solidity ^0.4.24;





/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * See https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address _who) public view returns (uint256);

  function transfer(address _to, uint256 _value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.4.24;







/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

  function allowance(address _owner, address _spender)

    public view returns (uint256);



  function transferFrom(address _from, address _to, uint256 _value)

    public returns (bool);



  function approve(address _spender, uint256 _value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}



// File: contracts/interfaces/IBridgeValidators.sol



pragma solidity 0.4.24;



interface IBridgeValidators {

    function isValidator(address _validator) external view returns (bool);

    function requiredSignatures() external view returns (uint256);

    function owner() external view returns (address);

}



// File: contracts/upgradeable_contracts/ValidatorStorage.sol



pragma solidity 0.4.24;



contract ValidatorStorage {

    bytes32 internal constant VALIDATOR_CONTRACT = 0x5a74bb7e202fb8e4bf311841c7d64ec19df195fee77d7e7ae749b27921b6ddfe; // keccak256(abi.encodePacked("validatorContract"))

}



// File: contracts/upgradeable_contracts/Validatable.sol



pragma solidity 0.4.24;









contract Validatable is EternalStorage, ValidatorStorage {

    function validatorContract() public view returns (IBridgeValidators) {

        return IBridgeValidators(addressStorage[VALIDATOR_CONTRACT]);

    }



    modifier onlyValidator() {

        require(validatorContract().isValidator(msg.sender));

        /* solcov ignore next */

        _;

    }



    function requiredSignatures() public view returns (uint256) {

        return validatorContract().requiredSignatures();

    }



}



// File: contracts/libraries/Message.sol



pragma solidity 0.4.24;





library Message {

    // function uintToString(uint256 inputValue) internal pure returns (string) {

    //     // figure out the length of the resulting string

    //     uint256 length = 0;

    //     uint256 currentValue = inputValue;

    //     do {

    //         length++;

    //         currentValue /= 10;

    //     } while (currentValue != 0);

    //     // allocate enough memory

    //     bytes memory result = new bytes(length);

    //     // construct the string backwards

    //     uint256 i = length - 1;

    //     currentValue = inputValue;

    //     do {

    //         result[i--] = byte(48 + currentValue % 10);

    //         currentValue /= 10;

    //     } while (currentValue != 0);

    //     return string(result);

    // }



    function addressArrayContains(address[] array, address value) internal pure returns (bool) {

        for (uint256 i = 0; i < array.length; i++) {

            if (array[i] == value) {

                return true;

            }

        }

        return false;

    }

    // layout of message :: bytes:

    // offset  0: 32 bytes :: uint256 - message length

    // offset 32: 20 bytes :: address - recipient address

    // offset 52: 32 bytes :: uint256 - value

    // offset 84: 32 bytes :: bytes32 - transaction hash

    // offset 104: 20 bytes :: address - contract address to prevent double spending



    // mload always reads 32 bytes.

    // so we can and have to start reading recipient at offset 20 instead of 32.

    // if we were to read at 32 the address would contain part of value and be corrupted.

    // when reading from offset 20 mload will read 12 bytes (most of them zeros) followed

    // by the 20 recipient address bytes and correctly convert it into an address.

    // this saves some storage/gas over the alternative solution

    // which is padding address to 32 bytes and reading recipient at offset 32.

    // for more details see discussion in:

    // https://github.com/paritytech/parity-bridge/issues/61

    function parseMessage(bytes message)

        internal

        pure

        returns (address recipient, uint256 amount, bytes32 txHash, address contractAddress)

    {

        require(isMessageValid(message));

        assembly {

            recipient := mload(add(message, 20))

            amount := mload(add(message, 52))

            txHash := mload(add(message, 84))

            contractAddress := mload(add(message, 104))

        }

    }



    function isMessageValid(bytes _msg) internal pure returns (bool) {

        return _msg.length == requiredMessageLength();

    }



    function requiredMessageLength() internal pure returns (uint256) {

        return 104;

    }



    function recoverAddressFromSignedMessage(bytes signature, bytes message, bool isAMBMessage)

        internal

        pure

        returns (address)

    {

        require(signature.length == 65);

        bytes32 r;

        bytes32 s;

        bytes1 v;



        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := mload(add(signature, 0x60))

        }

        return ecrecover(hashMessage(message, isAMBMessage), uint8(v), r, s);

    }



    function hashMessage(bytes message, bool isAMBMessage) internal pure returns (bytes32) {

        bytes memory prefix = "\x19Ethereum Signed Message:\n";

        if (isAMBMessage) {

            return keccak256(abi.encodePacked(prefix, uintToString(message.length), message));

        } else {

            string memory msgLength = "104";

            return keccak256(abi.encodePacked(prefix, msgLength, message));

        }

    }



    /**

    * @dev Validates provided signatures, only first requiredSignatures() number

    * of signatures are going to be validated, these signatures should be from different validators.

    * @param _message bytes message used to generate signatures

    * @param _signatures bytes blob with signatures to be validated.

    * First byte X is a number of signatures in a blob,

    * next X bytes are v components of signatures,

    * next 32 * X bytes are r components of signatures,

    * next 32 * X bytes are s components of signatures.

    * @param _validatorContract contract, which conforms to the IBridgeValidators interface,

    * where info about current validators and required signatures is stored.

    * @param isAMBMessage true if _message is an AMB message with arbitrary length.

    */

    function hasEnoughValidSignatures(

        bytes _message,

        bytes _signatures,

        IBridgeValidators _validatorContract,

        bool isAMBMessage

    ) internal view {

        require(isAMBMessage || isMessageValid(_message));

        uint256 requiredSignatures = _validatorContract.requiredSignatures();

        uint256 amount;

        assembly {

            amount := and(mload(add(_signatures, 1)), 0xff)

        }

        require(amount >= requiredSignatures);

        bytes32 hash = hashMessage(_message, isAMBMessage);

        address[] memory encounteredAddresses = new address[](requiredSignatures);



        for (uint256 i = 0; i < requiredSignatures; i++) {

            uint8 v;

            bytes32 r;

            bytes32 s;

            uint256 posr = 33 + amount + 32 * i;

            uint256 poss = posr + 32 * amount;

            assembly {

                v := mload(add(_signatures, add(2, i)))

                r := mload(add(_signatures, posr))

                s := mload(add(_signatures, poss))

            }



            address recoveredAddress = ecrecover(hash, v, r, s);

            require(_validatorContract.isValidator(recoveredAddress));

            require(!addressArrayContains(encounteredAddresses, recoveredAddress));

            encounteredAddresses[i] = recoveredAddress;

        }

    }



    function uintToString(uint256 i) internal pure returns (string) {

        if (i == 0) return "0";

        uint256 j = i;

        uint256 length;

        while (j != 0) {

            length++;

            j /= 10;

        }

        bytes memory bstr = new bytes(length);

        uint256 k = length - 1;

        while (i != 0) {

            bstr[k--] = bytes1(48 + (i % 10));

            i /= 10;

        }

        return string(bstr);

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.4.24;





/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (_a == 0) {

      return 0;

    }



    c = _a * _b;

    assert(c / _a == _b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {

    // assert(_b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = _a / _b;

    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold

    return _a / _b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {

    assert(_b <= _a);

    return _a - _b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    c = _a + _b;

    assert(c >= _a);

    return c;

  }

}



// File: contracts/interfaces/IUpgradeabilityOwnerStorage.sol



pragma solidity 0.4.24;



interface IUpgradeabilityOwnerStorage {

    function upgradeabilityOwner() external view returns (address);

}



// File: contracts/upgradeable_contracts/Ownable.sol



pragma solidity 0.4.24;







/**

 * @title Ownable

 * @dev This contract has an owner address providing basic authorization control

 */

contract Ownable is EternalStorage {

    bytes4 internal constant UPGRADEABILITY_OWNER = 0x6fde8202; // upgradeabilityOwner()



    /**

    * @dev Event to show ownership has been transferred

    * @param previousOwner representing the address of the previous owner

    * @param newOwner representing the address of the new owner

    */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner());

        /* solcov ignore next */

        _;

    }



    /**

    * @dev Throws if called by any account other than contract itself or owner.

    */

    modifier onlyRelevantSender() {

        // proxy owner if used through proxy, address(0) otherwise

        require(

            !address(this).call(abi.encodeWithSelector(UPGRADEABILITY_OWNER)) || // covers usage without calling through storage proxy

                msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner() || // covers usage through regular proxy calls

                msg.sender == address(this) // covers calls through upgradeAndCall proxy method

        );

        /* solcov ignore next */

        _;

    }



    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked("owner"))



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function owner() public view returns (address) {

        return addressStorage[OWNER];

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner the address to transfer ownership to.

    */

    function transferOwnership(address newOwner) external onlyOwner {

        require(newOwner != address(0));

        setOwner(newOwner);

    }



    /**

    * @dev Sets a new owner address

    */

    function setOwner(address newOwner) internal {

        emit OwnershipTransferred(owner(), newOwner);

        addressStorage[OWNER] = newOwner;

    }

}



// File: contracts/upgradeable_contracts/BasicTokenBridge.sol



pragma solidity 0.4.24;









contract BasicTokenBridge is EternalStorage, Ownable {

    using SafeMath for uint256;



    event DailyLimitChanged(uint256 newLimit);

    event ExecutionDailyLimitChanged(uint256 newLimit);



    bytes32 internal constant MIN_PER_TX = 0xbbb088c505d18e049d114c7c91f11724e69c55ad6c5397e2b929e68b41fa05d1; // keccak256(abi.encodePacked("minPerTx"))

    bytes32 internal constant MAX_PER_TX = 0x0f8803acad17c63ee38bf2de71e1888bc7a079a6f73658e274b08018bea4e29c; // keccak256(abi.encodePacked("maxPerTx"))

    bytes32 internal constant DAILY_LIMIT = 0x4a6a899679f26b73530d8cf1001e83b6f7702e04b6fdb98f3c62dc7e47e041a5; // keccak256(abi.encodePacked("dailyLimit"))

    bytes32 internal constant EXECUTION_MAX_PER_TX = 0xc0ed44c192c86d1cc1ba51340b032c2766b4a2b0041031de13c46dd7104888d5; // keccak256(abi.encodePacked("executionMaxPerTx"))

    bytes32 internal constant EXECUTION_DAILY_LIMIT = 0x21dbcab260e413c20dc13c28b7db95e2b423d1135f42bb8b7d5214a92270d237; // keccak256(abi.encodePacked("executionDailyLimit"))

    bytes32 internal constant DECIMAL_SHIFT = 0x1e8ecaafaddea96ed9ac6d2642dcdfe1bebe58a930b1085842d8fc122b371ee5; // keccak256(abi.encodePacked("decimalShift"))



    function totalSpentPerDay(uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _day))];

    }



    function totalExecutedPerDay(uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _day))];

    }



    function dailyLimit() public view returns (uint256) {

        return uintStorage[DAILY_LIMIT];

    }



    function executionDailyLimit() public view returns (uint256) {

        return uintStorage[EXECUTION_DAILY_LIMIT];

    }



    function maxPerTx() public view returns (uint256) {

        return uintStorage[MAX_PER_TX];

    }



    function executionMaxPerTx() public view returns (uint256) {

        return uintStorage[EXECUTION_MAX_PER_TX];

    }



    function minPerTx() public view returns (uint256) {

        return uintStorage[MIN_PER_TX];

    }



    function decimalShift() public view returns (uint256) {

        return uintStorage[DECIMAL_SHIFT];

    }



    function withinLimit(uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalSpentPerDay(getCurrentDay()).add(_amount);

        return dailyLimit() >= nextLimit && _amount <= maxPerTx() && _amount >= minPerTx();

    }



    function withinExecutionLimit(uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalExecutedPerDay(getCurrentDay()).add(_amount);

        return executionDailyLimit() >= nextLimit && _amount <= executionMaxPerTx();

    }



    function getCurrentDay() public view returns (uint256) {

        // solhint-disable-next-line not-rely-on-time

        return now / 1 days;

    }



    function setTotalSpentPerDay(uint256 _day, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _day))] = _value;

    }



    function setTotalExecutedPerDay(uint256 _day, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _day))] = _value;

    }



    function setDailyLimit(uint256 _dailyLimit) external onlyOwner {

        require(_dailyLimit > maxPerTx() || _dailyLimit == 0);

        uintStorage[DAILY_LIMIT] = _dailyLimit;

        emit DailyLimitChanged(_dailyLimit);

    }



    function setExecutionDailyLimit(uint256 _dailyLimit) external onlyOwner {

        require(_dailyLimit > executionMaxPerTx() || _dailyLimit == 0);

        uintStorage[EXECUTION_DAILY_LIMIT] = _dailyLimit;

        emit ExecutionDailyLimitChanged(_dailyLimit);

    }



    function setExecutionMaxPerTx(uint256 _maxPerTx) external onlyOwner {

        require(_maxPerTx < executionDailyLimit());

        uintStorage[EXECUTION_MAX_PER_TX] = _maxPerTx;

    }



    function setMaxPerTx(uint256 _maxPerTx) external onlyOwner {

        require(_maxPerTx == 0 || (_maxPerTx > minPerTx() && _maxPerTx < dailyLimit()));

        uintStorage[MAX_PER_TX] = _maxPerTx;

    }



    function setMinPerTx(uint256 _minPerTx) external onlyOwner {

        require(_minPerTx > 0 && _minPerTx < dailyLimit() && _minPerTx < maxPerTx());

        uintStorage[MIN_PER_TX] = _minPerTx;

    }

}



// File: contracts/upgradeable_contracts/MessageRelay.sol



pragma solidity 0.4.24;





contract MessageRelay is EternalStorage {

    function relayedMessages(bytes32 _txHash) public view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("relayedMessages", _txHash))];

    }



    function setRelayedMessages(bytes32 _txHash, bool _status) internal {

        boolStorage[keccak256(abi.encodePacked("relayedMessages", _txHash))] = _status;

    }

}



// File: contracts/upgradeable_contracts/Upgradeable.sol



pragma solidity 0.4.24;





contract Upgradeable {

    // Avoid using onlyUpgradeabilityOwner name to prevent issues with implementation from proxy contract

    modifier onlyIfUpgradeabilityOwner() {

        require(msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner());

        /* solcov ignore next */

        _;

    }

}



// File: contracts/upgradeable_contracts/Initializable.sol



pragma solidity 0.4.24;





contract Initializable is EternalStorage {

    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked("isInitialized"))



    function setInitialize() internal {

        boolStorage[INITIALIZED] = true;

    }



    function isInitialized() public view returns (bool) {

        return boolStorage[INITIALIZED];

    }

}



// File: contracts/upgradeable_contracts/InitializableBridge.sol



pragma solidity 0.4.24;





contract InitializableBridge is Initializable {

    bytes32 internal constant DEPLOYED_AT_BLOCK = 0xb120ceec05576ad0c710bc6e85f1768535e27554458f05dcbb5c65b8c7a749b0; // keccak256(abi.encodePacked("deployedAtBlock"))



    function deployedAtBlock() external view returns (uint256) {

        return uintStorage[DEPLOYED_AT_BLOCK];

    }

}



// File: openzeppelin-solidity/contracts/AddressUtils.sol



pragma solidity ^0.4.24;





/**

 * Utility library of inline functions on addresses

 */

library AddressUtils {



  /**

   * Returns whether the target address is a contract

   * @dev This function will return false if invoked during the constructor of a contract,

   * as the code is not actually created until after the constructor finishes.

   * @param _addr address to check

   * @return whether the target address is a contract

   */

  function isContract(address _addr) internal view returns (bool) {

    uint256 size;

    // XXX Currently there is no better way to check if there is a contract in an address

    // than to check the size of the code at that address.

    // See https://ethereum.stackexchange.com/a/14016/36603

    // for more details about how this works.

    // TODO Check this again before the Serenity release, because all addresses will be

    // contracts then.

    // solium-disable-next-line security/no-inline-assembly

    assembly { size := extcodesize(_addr) }

    return size > 0;

  }



}



// File: contracts/upgradeable_contracts/Sacrifice.sol



pragma solidity 0.4.24;



contract Sacrifice {

    constructor(address _recipient) public payable {

        selfdestruct(_recipient);

    }

}



// File: contracts/upgradeable_contracts/Claimable.sol



pragma solidity 0.4.24;







contract Claimable {

    bytes4 internal constant TRANSFER = 0xa9059cbb; // transfer(address,uint256)



    modifier validAddress(address _to) {

        require(_to != address(0));

        /* solcov ignore next */

        _;

    }



    function claimValues(address _token, address _to) internal {

        if (_token == address(0)) {

            claimNativeCoins(_to);

        } else {

            claimErc20Tokens(_token, _to);

        }

    }



    function claimNativeCoins(address _to) internal {

        uint256 value = address(this).balance;

        if (!_to.send(value)) {

            (new Sacrifice).value(value)(_to);

        }

    }



    function claimErc20Tokens(address _token, address _to) internal {

        ERC20Basic token = ERC20Basic(_token);

        uint256 balance = token.balanceOf(this);

        safeTransfer(_token, _to, balance);

    }



    function safeTransfer(address _token, address _to, uint256 _value) internal {

        bytes memory returnData;

        bool returnDataResult;

        bytes memory callData = abi.encodeWithSelector(TRANSFER, _to, _value);

        assembly {

            let result := call(gas, _token, 0x0, add(callData, 0x20), mload(callData), 0, 32)

            returnData := mload(0)

            returnDataResult := mload(0)



            switch result

                case 0 {

                    revert(0, 0)

                }

        }



        // Return data is optional

        if (returnData.length > 0) {

            require(returnDataResult);

        }

    }

}



// File: contracts/upgradeable_contracts/VersionableBridge.sol



pragma solidity 0.4.24;



contract VersionableBridge {

    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {

        return (3, 0, 0);

    }



    /* solcov ignore next */

    function getBridgeMode() external pure returns (bytes4);

}



// File: contracts/upgradeable_contracts/BasicBridge.sol



pragma solidity 0.4.24;

















contract BasicBridge is InitializableBridge, Validatable, Ownable, Upgradeable, Claimable, VersionableBridge {

    event GasPriceChanged(uint256 gasPrice);

    event RequiredBlockConfirmationChanged(uint256 requiredBlockConfirmations);



    bytes32 internal constant GAS_PRICE = 0x55b3774520b5993024893d303890baa4e84b1244a43c60034d1ced2d3cf2b04b; // keccak256(abi.encodePacked("gasPrice"))

    bytes32 internal constant REQUIRED_BLOCK_CONFIRMATIONS = 0x916daedf6915000ff68ced2f0b6773fe6f2582237f92c3c95bb4d79407230071; // keccak256(abi.encodePacked("requiredBlockConfirmations"))



    function setGasPrice(uint256 _gasPrice) external onlyOwner {

        require(_gasPrice > 0);

        uintStorage[GAS_PRICE] = _gasPrice;

        emit GasPriceChanged(_gasPrice);

    }



    function gasPrice() external view returns (uint256) {

        return uintStorage[GAS_PRICE];

    }



    function setRequiredBlockConfirmations(uint256 _blockConfirmations) external onlyOwner {

        require(_blockConfirmations > 0);

        uintStorage[REQUIRED_BLOCK_CONFIRMATIONS] = _blockConfirmations;

        emit RequiredBlockConfirmationChanged(_blockConfirmations);

    }



    function requiredBlockConfirmations() external view returns (uint256) {

        return uintStorage[REQUIRED_BLOCK_CONFIRMATIONS];

    }



    function claimTokens(address _token, address _to) public onlyIfUpgradeabilityOwner validAddress(_to) {

        claimValues(_token, _to);

    }

}



// File: contracts/upgradeable_contracts/BasicForeignBridge.sol



pragma solidity 0.4.24;





















contract BasicForeignBridge is EternalStorage, Validatable, BasicBridge, BasicTokenBridge, MessageRelay {

    /// triggered when relay of deposit from HomeBridge is complete

    event RelayedMessage(address recipient, uint256 value, bytes32 transactionHash);

    event UserRequestForAffirmation(address recipient, uint256 value);



    /**

    * @dev Validates provided signatures and relays a given message

    * @param message bytes to be relayed

    * @param signatures bytes blob with signatures to be validated

    */

    function executeSignatures(bytes message, bytes signatures) external {

        Message.hasEnoughValidSignatures(message, signatures, validatorContract(), false);



        address recipient;

        uint256 amount;

        bytes32 txHash;

        address contractAddress;

        (recipient, amount, txHash, contractAddress) = Message.parseMessage(message);

        if (withinExecutionLimit(amount)) {

            require(contractAddress == address(this));

            require(!relayedMessages(txHash));

            setRelayedMessages(txHash, true);

            require(onExecuteMessage(recipient, amount, txHash));

            emit RelayedMessage(recipient, amount, txHash);

        } else {

            onFailedMessage(recipient, amount, txHash);

        }

    }



    /* solcov ignore next */

    function onExecuteMessage(address, uint256, bytes32) internal returns (bool);



    /* solcov ignore next */

    function onFailedMessage(address, uint256, bytes32) internal;

}



// File: contracts/upgradeable_contracts/ERC20Bridge.sol



pragma solidity 0.4.24;









contract ERC20Bridge is BasicForeignBridge {

    bytes32 internal constant ERC20_TOKEN = 0x15d63b18dbc21bf4438b7972d80076747e1d93c4f87552fe498c90cbde51665e; // keccak256(abi.encodePacked("erc20token"))



    function erc20token() public view returns (ERC20) {

        return ERC20(addressStorage[ERC20_TOKEN]);

    }



    function setErc20token(address _token) internal {

        require(AddressUtils.isContract(_token));

        addressStorage[ERC20_TOKEN] = _token;

    }



    function _relayTokens(address _sender, address _receiver, uint256 _amount) internal {

        require(_receiver != address(0));

        require(_receiver != address(this));

        require(_amount > 0);

        require(withinLimit(_amount));

        setTotalSpentPerDay(getCurrentDay(), totalSpentPerDay(getCurrentDay()).add(_amount));



        erc20token().transferFrom(_sender, address(this), _amount);

        emit UserRequestForAffirmation(_receiver, _amount);

    }



    function relayTokens(address _from, address _receiver, uint256 _amount) external {

        require(_from == msg.sender || _from == _receiver);

        _relayTokens(_from, _receiver, _amount);

    }



    function relayTokens(address _receiver, uint256 _amount) external {

        _relayTokens(msg.sender, _receiver, _amount);

    }

}



// File: contracts/upgradeable_contracts/OtherSideBridgeStorage.sol



pragma solidity 0.4.24;





contract OtherSideBridgeStorage is EternalStorage {

    bytes32 internal constant BRIDGE_CONTRACT = 0x71483949fe7a14d16644d63320f24d10cf1d60abecc30cc677a340e82b699dd2; // keccak256(abi.encodePacked("bridgeOnOtherSide"))



    function _setBridgeContractOnOtherSide(address _bridgeContract) internal {

        addressStorage[BRIDGE_CONTRACT] = _bridgeContract;

    }



    function bridgeContractOnOtherSide() internal view returns (address) {

        return addressStorage[BRIDGE_CONTRACT];

    }

}



// File: contracts/interfaces/IScdMcdMigration.sol



pragma solidity 0.4.24;



interface IScdMcdMigration {

    function swapSaiToDai(uint256 wad) external;

    function daiJoin() external returns (address);

}



interface IDaiAdapter {

    function dai() public returns (address);

}



interface ISaiTop {

    function caged() public returns (uint256);

}



// File: contracts/interfaces/IPot.sol



pragma solidity 0.4.24;



interface IPot {

    function chi() external view returns (uint256);

    function rho() external view returns (uint256);

    function drip() external returns (uint256);

}



// File: contracts/interfaces/IChai.sol



pragma solidity 0.4.24;







interface IChai {

    function pot() external view returns (IPot);

    function daiToken() external view returns (ERC20);

    function balanceOf(address) external view returns (uint256);

    function dai(address) external view returns (uint256);

    function join(address, uint256) external;

    function draw(address, uint256) external;

    function exit(address, uint256) external;

    function transfer(address, uint256) external;

}



// File: contracts/interfaces/ERC677Receiver.sol



pragma solidity 0.4.24;



contract ERC677Receiver {

    function onTokenTransfer(address _from, uint256 _value, bytes _data) external returns (bool);

}



// File: contracts/upgradeable_contracts/TokenSwapper.sol



pragma solidity 0.4.24;



contract TokenSwapper {

    // emitted when two tokens is swapped (e. g. Sai to Dai, Chai to Dai)

    event TokensSwapped(address indexed from, address indexed to, uint256 value);

}



// File: contracts/upgradeable_contracts/ChaiConnector.sol



pragma solidity 0.4.24;















/**

* @title ChaiConnector

* @dev This logic allows to use Chai token (https://github.com/dapphub/chai)

*/

contract ChaiConnector is Ownable, ERC20Bridge, TokenSwapper {

    using SafeMath for uint256;



    // emitted when specified value of Chai tokens is transfered to interest receiver

    event PaidInterest(address to, uint256 value);



    bytes32 internal constant CHAI_TOKEN_ENABLED = 0x2ae87563606f93f71ad2adf4d62661ccdfb63f3f508f94700934d5877fb92278; // keccak256(abi.encodePacked("chaiTokenEnabled"))

    bytes32 internal constant INTEREST_RECEIVER = 0xd88509eb1a8da5d5a2fc7b9bad1c72874c9818c788e81d0bc46b29bfaa83adf6; // keccak256(abi.encodePacked("interestReceiver"))

    bytes32 internal constant INTEREST_COLLECTION_PERIOD = 0x68a6a652d193e5d6439c4309583048050a11a4cfb263a220f4cd798c61c3ad6e; // keccak256(abi.encodePacked("interestCollectionPeriod"))

    bytes32 internal constant LAST_TIME_INTEREST_PAID = 0xcabd46177a706f95f4bb3e2c2ba45ac4aa1eac9c545425a19c62ab6de4aeea26; // keccak256(abi.encodePacked("lastTimeInterestPaid"))

    bytes32 internal constant INVESTED_AMOUNT = 0xb6afb3323c9d7dc0e9dab5d34c3a1d1ae7739d2224c048d4ee7675d3c759dd1b; // keccak256(abi.encodePacked("investedAmount"))

    bytes32 internal constant MIN_DAI_TOKEN_BALANCE = 0xce70e1dac97909c26a87aa4ada3d490673a153b3a75b22ea3364c4c7df7c551f; // keccak256(abi.encodePacked("minDaiTokenBalance"))

    bytes4 internal constant ON_TOKEN_TRANSFER = 0xa4c0ed36; // onTokenTransfer(address,uint256,bytes)



    uint256 internal constant ONE = 10**27;



    /**

    * @dev Throws if chai token is not enabled

    */

    modifier chaiTokenEnabled {

        require(isChaiTokenEnabled());

        /* solcov ignore next */

        _;

    }



    /**

    * @dev Fixed point division

    * @return Ceiled value of x / y

    */

    function rdivup(uint256 x, uint256 y) internal pure returns (uint256) {

        return x.mul(ONE).add(y.sub(1)) / y;

    }



    /**

    * @return true, if chai token is enabled

    */

    function isChaiTokenEnabled() public view returns (bool) {

        return boolStorage[CHAI_TOKEN_ENABLED];

    }



    /**

    * @return Chai token contract address

    */

    function chaiToken() public view returns (IChai) {

        return IChai(0x06AF07097C9Eeb7fD685c692751D5C66dB49c215);

    }



    /**

    * @dev Initializes chai token

    */

    function initializeChaiToken() public onlyOwner {

        require(!isChaiTokenEnabled());

        require(address(chaiToken().daiToken()) == address(erc20token()));

        boolStorage[CHAI_TOKEN_ENABLED] = true;

        uintStorage[MIN_DAI_TOKEN_BALANCE] = 100 ether;

        uintStorage[INTEREST_COLLECTION_PERIOD] = 1 weeks;

    }



    /**

    * @dev Initializes chai token, with interestReceiver

    * @param _interestReceiver Receiver address

    */

    function initializeChaiToken(address _interestReceiver) external {

        require(_interestReceiver != address(0));

        // onlyOwner condition is checked inside this call, so it can be excluded from function definition

        initializeChaiToken();

        addressStorage[INTEREST_RECEIVER] = _interestReceiver;

    }



    /**

    * @dev Sets minimum DAI limit, needed for converting DAI into CHAI

    */

    function setMinDaiTokenBalance(uint256 _minBalance) external onlyOwner {

        uintStorage[MIN_DAI_TOKEN_BALANCE] = _minBalance;

    }



    /**

    * @dev Evaluates edge DAI token balance, which has an impact on the invest amounts

    * @return Value in DAI

    */

    function minDaiTokenBalance() public view returns (uint256) {

        return uintStorage[MIN_DAI_TOKEN_BALANCE];

    }



    /**

    * @dev Withdraws all invested tokens, pays remaining interest, removes chai token from contract storage

    */

    function removeChaiToken() external onlyOwner chaiTokenEnabled {

        _convertChaiToDai(investedAmountInDai());

        _payInterest();

        delete boolStorage[CHAI_TOKEN_ENABLED];

    }



    /**

     * @return Configured address of a receiver

     */

    function interestReceiver() public view returns (ERC677Receiver) {

        return ERC677Receiver(addressStorage[INTEREST_RECEIVER]);

    }



    /**

     * Updates interest receiver address

     * @param receiver New receiver address

     */

    function setInterestReceiver(address receiver) external onlyOwner {

        // the bridge account is not allowed to receive an interest by the following reason:

        // during the Chai to Dai convertion, the Dai is minted to the receiver account,

        // the Transfer(address(0), bridgeAddress, value) is emitted during this process,

        // something can go wrong in the oracle logic, so that it will process this event as a request to the bridge

        // Instead, the interest can be transfered to any other account, and then converted to Dai,

        // which won't be related to the oracle logic anymore

        require(receiver != address(this));



        addressStorage[INTEREST_RECEIVER] = receiver;

    }



    /**

     * @return Timestamp of last interest payment

     */

    function lastInterestPayment() public view returns (uint256) {

        return uintStorage[LAST_TIME_INTEREST_PAID];

    }



    /**

     * @return Configured minimum interest collection period

     */

    function interestCollectionPeriod() public view returns (uint256) {

        return uintStorage[INTEREST_COLLECTION_PERIOD];

    }



    /**

     * @dev Configures minimum interest collection period

     * @param period collection period

     */

    function setInterestCollectionPeriod(uint256 period) external onlyOwner {

        uintStorage[INTEREST_COLLECTION_PERIOD] = period;

    }



    /**

    * @dev Pays all available interest, in Dai tokens.

    * Upgradeability owner can call this method without time restrictions,

    * for others, the method can be called only once a specified period.

    */

    function payInterest() external chaiTokenEnabled {

        if (

            // solhint-disable-next-line not-rely-on-time

            lastInterestPayment() + interestCollectionPeriod() < now ||

            IUpgradeabilityOwnerStorage(this).upgradeabilityOwner() == msg.sender

        ) {

            _payInterest();

        }

    }



    /**

    * @dev Internal function for paying all available interest, in Dai tokens

    */

    function _payInterest() internal {

        address receiver = address(interestReceiver());

        require(receiver != address(0));



        // since investedAmountInChai() returns a ceiled value,

        // the value of chaiBalance() - investedAmountInChai() will be floored,

        // leading to excess remaining chai balance



        // solhint-disable-next-line not-rely-on-time

        uintStorage[LAST_TIME_INTEREST_PAID] = now;



        uint256 interest = chaiBalance().sub(investedAmountInChai());

        // interest is paid in Chai, paying interest directly in Dai can cause an unwanter Transfer event

        // see a comment in setInterestReceiver describing why we cannot pay interest to the bridge directly

        chaiToken().transfer(receiver, interest);



        receiver.call(abi.encodeWithSelector(ON_TOKEN_TRANSFER, address(this), interest, ""));



        // Additional constant to tolerate the DAI balance deposited to the Chai token is not needed here, since we allow to withdraw only extra part of chai balance,

        // which is not necessary to cover 100% dai balance.

        // It is guaranteed that the withdrawal of interest won't left the bridge balance uncovered.

        require(dsrBalance() >= investedAmountInDai());



        emit PaidInterest(receiver, interest);

    }



    /**

    * @dev Evaluates bridge balance for tokens, holded in DSR

    * @return Balance in dai, truncated

    */

    function dsrBalance() public view returns (uint256) {

        return chaiToken().dai(address(this));

    }



    /**

    * @dev Evaluates bridge balance in Chai tokens

    * @return Balance in chai, exact

    */

    function chaiBalance() public view returns (uint256) {

        return chaiToken().balanceOf(address(this));

    }



    /**

    * @dev Evaluates bridge balance in Dai tokens

    * @return Balance in Dai

    */

    function daiBalance() internal view returns (uint256) {

        return erc20token().balanceOf(address(this));

    }



    /**

    * @dev Evaluates exact current invested amount, in DAI

    * @return Value in DAI

    */

    function investedAmountInDai() public view returns (uint256) {

        return uintStorage[INVESTED_AMOUNT];

    }



    /**

    * @dev Updates current invested amount, in DAI

    * @return Value in DAI

    */

    function setInvestedAmountInDai(uint256 amount) internal {

        uintStorage[INVESTED_AMOUNT] = amount;

    }



    /**

    * @dev Evaluates amount of chai tokens that is sufficent to cover 100% of the invested DAI

    * @return Amount in chai, ceiled

    */

    function investedAmountInChai() internal returns (uint256) {

        IPot pot = chaiToken().pot();

        // solhint-disable-next-line not-rely-on-time

        uint256 chi = (now > pot.rho()) ? pot.drip() : pot.chi();

        return rdivup(investedAmountInDai(), chi);

    }



    /**

    * @dev Checks if DAI balance is high enough to be partially converted to Chai

    * Twice limit is used in order to decrease frequency of convertDaiToChai calls,

    * In case of high bridge utilization in DAI => xDAI direction,

    * convertDaiToChai() will be called as soon as DAI balance reaches 2 * limit,

    * limit DAI will be left as a buffer for future operations.

    * @return true if convertDaiToChai() call is needed to be performed by the oracle

    */

    function isDaiNeedsToBeInvested() public view returns (bool) {

        // chai token needs to be initialized, DAI balance should be at least twice greater than minDaiTokenBalance

        return isChaiTokenEnabled() && daiBalance() > 2 * minDaiTokenBalance();

    }



    /**

    * @dev Converts all DAI into Chai tokens, keeping minDaiTokenBalance() DAI as a buffer

    */

    function convertDaiToChai() public chaiTokenEnabled {

        // there is not need to consider overflow when performing a + operation,

        // since both values are controlled by the bridge and can't take extremely high values

        uint256 amount = daiBalance().sub(minDaiTokenBalance());



        require(amount > 0); // revert and save gas if there is nothing to convert



        uint256 newInvestedAmountInDai = investedAmountInDai() + amount;

        setInvestedAmountInDai(newInvestedAmountInDai);

        erc20token().approve(chaiToken(), amount);

        chaiToken().join(address(this), amount);



        // When evaluating the amount of DAI kept in Chai using dsrBalance(), there are some fixed point truncations.

        // The dependency between invested amount of DAI - value and returned value of dsrBalance() - res is the following:

        // res = floor(floor(value / K) * K)), where K is the fixed-point coefficient

        // from MakerDAO Pot contract (K = pot.chi() / 10**27).

        // This can lead up to losses of ceil(K) DAI in this balance evaluation.

        // The constant is needed here for making sure that everything works fine, and this error is small enough

        // The 10000 constant is considered to be small enough when decimals = 18, however,

        // it is not recommended to use it for smaller values of decimals, since it won't be negligible anymore

        require(dsrBalance() + 10000 >= newInvestedAmountInDai);



        emit TokensSwapped(erc20token(), chaiToken(), amount);

    }



    /**

    * @dev Redeems DAI from Chai, the total redeemed amount will be at least equal to specified amount

    * @param amount Amount of DAI to redeem

    */

    function _convertChaiToDai(uint256 amount) internal {

        if (amount == 0) return;



        uint256 invested = investedAmountInDai();

        uint256 initialDaiBalance = daiBalance();



        // onExecuteMessage can call a convert operation with argument greater than the current invested amount,

        // in this case bridge should withdraw all invested funds

        uint256 withdrawal = amount >= invested ? invested : amount;



        chaiToken().draw(address(this), withdrawal);

        uint256 redeemed = daiBalance() - initialDaiBalance;



        // Make sure that at least withdrawal amount was withdrawn

        require(redeemed >= withdrawal);



        uint256 newInvested = invested > redeemed ? invested - redeemed : 0;

        setInvestedAmountInDai(newInvested);



        // see comment in convertDaiToChai() for similar statement

        require(dsrBalance() + 10000 >= newInvested);



        emit TokensSwapped(chaiToken(), erc20token(), redeemed);

    }

}



// File: contracts/upgradeable_contracts/erc20_to_native/ForeignBridgeErcToNative.sol



pragma solidity 0.4.24;













contract ForeignBridgeErcToNative is BasicForeignBridge, ERC20Bridge, OtherSideBridgeStorage, ChaiConnector {

    bytes32 internal constant MIN_HDTOKEN_BALANCE = 0x48649cf195feb695632309f41e61252b09f537943654bde13eb7bb1bca06964e; // keccak256(abi.encodePacked("minHDTokenBalance"))

    bytes32 internal constant LOCKED_SAI_FIXED = 0xbeb8b2ece34b32b36c9cc00744143b61b2c23f93adcc3ce78d38937229423051; // keccak256(abi.encodePacked("lockedSaiFixed"))

    bytes4 internal constant SWAP_TOKENS = 0x73d00224; // swapTokens()



    function initialize(

        address _validatorContract,

        address _erc20token,

        uint256 _requiredBlockConfirmations,

        uint256 _gasPrice,

        uint256[] _dailyLimitMaxPerTxMinPerTxArray, // [ 0 = _dailyLimit, 1 = _maxPerTx, 2 = _minPerTx ]

        uint256[] _homeDailyLimitHomeMaxPerTxArray, //[ 0 = _homeDailyLimit, 1 = _homeMaxPerTx ]

        address _owner,

        uint256 _decimalShift,

        address _bridgeOnOtherSide

    ) external onlyRelevantSender returns (bool) {

        require(!isInitialized());

        require(AddressUtils.isContract(_validatorContract));

        require(_requiredBlockConfirmations != 0);

        require(_gasPrice > 0);

        require(

            _dailyLimitMaxPerTxMinPerTxArray[2] > 0 && // _minPerTx > 0

                _dailyLimitMaxPerTxMinPerTxArray[1] > _dailyLimitMaxPerTxMinPerTxArray[2] && // _maxPerTx > _minPerTx

                _dailyLimitMaxPerTxMinPerTxArray[0] > _dailyLimitMaxPerTxMinPerTxArray[1] // _dailyLimit > _maxPerTx

        );

        require(_homeDailyLimitHomeMaxPerTxArray[1] < _homeDailyLimitHomeMaxPerTxArray[0]); // _homeMaxPerTx < _homeDailyLimit

        require(_owner != address(0));

        require(_bridgeOnOtherSide != address(0));



        addressStorage[VALIDATOR_CONTRACT] = _validatorContract;

        setErc20token(_erc20token);

        uintStorage[DEPLOYED_AT_BLOCK] = block.number;

        uintStorage[REQUIRED_BLOCK_CONFIRMATIONS] = _requiredBlockConfirmations;

        uintStorage[GAS_PRICE] = _gasPrice;

        uintStorage[DAILY_LIMIT] = _dailyLimitMaxPerTxMinPerTxArray[0];

        uintStorage[MAX_PER_TX] = _dailyLimitMaxPerTxMinPerTxArray[1];

        uintStorage[MIN_PER_TX] = _dailyLimitMaxPerTxMinPerTxArray[2];

        uintStorage[EXECUTION_DAILY_LIMIT] = _homeDailyLimitHomeMaxPerTxArray[0];

        uintStorage[EXECUTION_MAX_PER_TX] = _homeDailyLimitHomeMaxPerTxArray[1];

        uintStorage[DECIMAL_SHIFT] = _decimalShift;

        setOwner(_owner);

        _setBridgeContractOnOtherSide(_bridgeOnOtherSide);

        setInitialize();



        emit RequiredBlockConfirmationChanged(_requiredBlockConfirmations);

        emit GasPriceChanged(_gasPrice);

        emit DailyLimitChanged(_dailyLimitMaxPerTxMinPerTxArray[0]);

        emit ExecutionDailyLimitChanged(_homeDailyLimitHomeMaxPerTxArray[0]);



        return isInitialized();

    }



    function getBridgeMode() external pure returns (bytes4 _data) {

        return 0x18762d46; // bytes4(keccak256(abi.encodePacked("erc-to-native-core")))

    }



    function fixLockedSai(address _receiver) external {

        require(msg.sender == address(this));

        require(!boolStorage[LOCKED_SAI_FIXED]);

        boolStorage[LOCKED_SAI_FIXED] = true;

        setInvestedAmountInDai(investedAmountInDai() + 49938645266079271041);

        claimValues(halfDuplexErc20token(), _receiver);

    }

    

    function claimTokens(address _token, address _to) public {

        require(_token != address(erc20token()));

        // Chai token is not claimable if investing into Chai is enabled

        require(_token != address(chaiToken()) || !isChaiTokenEnabled());

        if (_token == address(halfDuplexErc20token())) {

            // SCD is not claimable if the bridge accepts deposits of this token

            // solhint-disable-next-line not-rely-on-time

            require(!isTokenSwapAllowed(now));

        }

        super.claimTokens(_token, _to);

    }



    function onExecuteMessage(

        address _recipient,

        uint256 _amount,

        bytes32 /*_txHash*/

    ) internal returns (bool) {

        setTotalExecutedPerDay(getCurrentDay(), totalExecutedPerDay(getCurrentDay()).add(_amount));

        uint256 amount = _amount.div(10**decimalShift());



        uint256 currentBalance = tokenBalance(erc20token());



        // Convert part of Chai tokens back to DAI, if DAI balance is insufficient.

        // If Chai token is disabled, bridge will keep all funds directly in DAI token,

        // so it will have enough funds to cover any xDai => Dai transfer,

        // and currentBalance >= amount will always hold.

        if (currentBalance < amount) {

            _convertChaiToDai(amount.sub(currentBalance).add(minDaiTokenBalance()));

        }



        bool res = erc20token().transfer(_recipient, amount);



        if (tokenBalance(halfDuplexErc20token()) > 0) {

            address(this).call(abi.encodeWithSelector(SWAP_TOKENS));

        }



        return res;

    }



    function onFailedMessage(address, uint256, bytes32) internal {

        revert();

    }



    function saiTopContract() internal pure returns (ISaiTop) {

        return ISaiTop(0x9b0ccf7C8994E19F39b2B4CF708e0A7DF65fA8a3);

    }



    function isTokenSwapAllowed(

        uint256 /* _ts */

    ) public pure returns (bool) {

        return false;

    }



    function halfDuplexErc20token() public pure returns (ERC20) {

        return ERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);

    }



    function setMinHDTokenBalance(uint256 _minBalance) external onlyOwner {

        uintStorage[MIN_HDTOKEN_BALANCE] = _minBalance;

    }



    function minHDTokenBalance() public view returns (uint256) {

        return uintStorage[MIN_HDTOKEN_BALANCE];

    }



    function isHDTokenBalanceAboveMinBalance() public view returns (bool) {

        if (tokenBalance(halfDuplexErc20token()) > minHDTokenBalance()) {

            return true;

        }

        return false;

    }



    function tokenBalance(ERC20 _token) internal view returns (uint256) {

        return _token.balanceOf(address(this));

    }



    function migrationContract() internal pure returns (IScdMcdMigration) {

        return IScdMcdMigration(0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849);

    }



    function swapTokens() public {

        // solhint-disable-next-line not-rely-on-time

        require(isTokenSwapAllowed(now));



        IScdMcdMigration mcdMigrationContract = migrationContract();

        ERC20 hdToken = halfDuplexErc20token();

        ERC20 fdToken = erc20token();



        uint256 curHDTokenBalance = tokenBalance(hdToken);

        require(curHDTokenBalance > 0);



        uint256 curFDTokenBalance = tokenBalance(fdToken);



        require(hdToken.approve(mcdMigrationContract, curHDTokenBalance));

        mcdMigrationContract.swapSaiToDai(curHDTokenBalance);



        require(tokenBalance(fdToken).sub(curFDTokenBalance) == curHDTokenBalance);



        emit TokensSwapped(hdToken, fdToken, curHDTokenBalance);

    }



    function relayTokens(address _receiver, uint256 _amount) external {

        _relayTokens(msg.sender, _receiver, _amount, erc20token());

    }



    function relayTokens(address _sender, address _receiver, uint256 _amount) external {

        relayTokens(_sender, _receiver, _amount, erc20token());

    }



    function relayTokens(address _from, address _receiver, uint256 _amount, address _token) public {

        require(_from == msg.sender || _from == _receiver);

        _relayTokens(_from, _receiver, _amount, _token);

    }



    function relayTokens(address _receiver, uint256 _amount, address _token) external {

        _relayTokens(msg.sender, _receiver, _amount, _token);

    }



    function _relayTokens(address _sender, address _receiver, uint256 _amount, address _token) internal {

        require(_receiver != bridgeContractOnOtherSide());

        require(_receiver != address(0));

        require(_receiver != address(this));

        require(_amount > 0);

        require(withinLimit(_amount));



        ERC20 tokenToOperate = ERC20(_token);

        ERC20 hdToken = halfDuplexErc20token();

        ERC20 fdToken = erc20token();



        if (tokenToOperate == ERC20(0x0)) {

            tokenToOperate = fdToken;

        }



        require(tokenToOperate == fdToken || tokenToOperate == hdToken);



        setTotalSpentPerDay(getCurrentDay(), totalSpentPerDay(getCurrentDay()).add(_amount));



        tokenToOperate.transferFrom(_sender, address(this), _amount);

        emit UserRequestForAffirmation(_receiver, _amount);



        if (tokenToOperate == hdToken) {

            swapTokens();

        }

        if (isDaiNeedsToBeInvested()) {

            convertDaiToChai();

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ForeignMultiAMBErc20ToErc677.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-03-13

*/



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol



pragma solidity ^0.4.24;





/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * See https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address _who) public view returns (uint256);

  function transfer(address _to, uint256 _value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.4.24;







/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

  function allowance(address _owner, address _spender)

    public view returns (uint256);



  function transferFrom(address _from, address _to, uint256 _value)

    public returns (bool);



  function approve(address _spender, uint256 _value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}



// File: openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol



pragma solidity ^0.4.24;







/**

 * @title DetailedERC20 token

 * @dev The decimals are only for visualization purposes.

 * All the operations are done using the smallest and indivisible token unit,

 * just as on Ethereum all the operations are done in wei.

 */

contract DetailedERC20 is ERC20 {

  string public name;

  string public symbol;

  uint8 public decimals;



  constructor(string _name, string _symbol, uint8 _decimals) public {

    name = _name;

    symbol = _symbol;

    decimals = _decimals;

  }

}



// File: contracts/interfaces/IAMB.sol



pragma solidity 0.4.24;



interface IAMB {

    function messageSender() external view returns (address);

    function maxGasPerTx() external view returns (uint256);

    function transactionHash() external view returns (bytes32);

    function messageId() external view returns (bytes32);

    function messageSourceChainId() external view returns (bytes32);

    function messageCallStatus(bytes32 _messageId) external view returns (bool);

    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32);

    function failedMessageReceiver(bytes32 _messageId) external view returns (address);

    function failedMessageSender(bytes32 _messageId) external view returns (address);

    function requireToPassMessage(address _contract, bytes _data, uint256 _gas) external returns (bytes32);

    function requireToConfirmMessage(address _contract, bytes _data, uint256 _gas) external returns (bytes32);

    function sourceChainId() external view returns (uint256);

    function destinationChainId() external view returns (uint256);

}



// File: contracts/interfaces/ERC677.sol



pragma solidity 0.4.24;





contract ERC677 is ERC20 {

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);



    function transferAndCall(address, uint256, bytes) external returns (bool);



    function increaseAllowance(address spender, uint256 addedValue) public returns (bool);

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool);

}



contract LegacyERC20 {

    function transfer(address _spender, uint256 _value) public; // returns (bool);

    function transferFrom(address _owner, address _spender, uint256 _value) public; // returns (bool);

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.4.24;





/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (_a == 0) {

      return 0;

    }



    c = _a * _b;

    assert(c / _a == _b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {

    // assert(_b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = _a / _b;

    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold

    return _a / _b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {

    assert(_b <= _a);

    return _a - _b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    c = _a + _b;

    assert(c >= _a);

    return c;

  }

}



// File: contracts/upgradeability/EternalStorage.sol



pragma solidity 0.4.24;



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {

    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;



}



// File: contracts/interfaces/IUpgradeabilityOwnerStorage.sol



pragma solidity 0.4.24;



interface IUpgradeabilityOwnerStorage {

    function upgradeabilityOwner() external view returns (address);

}



// File: contracts/upgradeable_contracts/Ownable.sol



pragma solidity 0.4.24;







/**

 * @title Ownable

 * @dev This contract has an owner address providing basic authorization control

 */

contract Ownable is EternalStorage {

    bytes4 internal constant UPGRADEABILITY_OWNER = 0x6fde8202; // upgradeabilityOwner()



    /**

    * @dev Event to show ownership has been transferred

    * @param previousOwner representing the address of the previous owner

    * @param newOwner representing the address of the new owner

    */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner());

        /* solcov ignore next */

        _;

    }



    /**

    * @dev Throws if called by any account other than contract itself or owner.

    */

    modifier onlyRelevantSender() {

        // proxy owner if used through proxy, address(0) otherwise

        require(

            !address(this).call(abi.encodeWithSelector(UPGRADEABILITY_OWNER)) || // covers usage without calling through storage proxy

                msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner() || // covers usage through regular proxy calls

                msg.sender == address(this) // covers calls through upgradeAndCall proxy method

        );

        /* solcov ignore next */

        _;

    }



    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked("owner"))



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function owner() public view returns (address) {

        return addressStorage[OWNER];

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner the address to transfer ownership to.

    */

    function transferOwnership(address newOwner) external onlyOwner {

        _setOwner(newOwner);

    }



    /**

    * @dev Sets a new owner address

    */

    function _setOwner(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner(), newOwner);

        addressStorage[OWNER] = newOwner;

    }

}



// File: contracts/upgradeable_contracts/multi_amb_erc20_to_erc677/BasicMultiTokenBridge.sol



pragma solidity 0.4.24;









contract BasicMultiTokenBridge is EternalStorage, Ownable {

    using SafeMath for uint256;



    // token == 0x00..00 represents default limits (assuming decimals == 18) for all newly created tokens

    event DailyLimitChanged(address indexed token, uint256 newLimit);

    event ExecutionDailyLimitChanged(address indexed token, uint256 newLimit);



    /**

    * @dev Checks if specified token was already bridged at least once.

    * @param _token address of the token contract.

    * @return true, if token address is address(0) or token was already bridged.

    */

    function isTokenRegistered(address _token) public view returns (bool) {

        return minPerTx(_token) > 0;

    }



    /**

    * @dev Retrieves the total spent amount for particular token during specific day.

    * @param _token address of the token contract.

    * @param _day day number for which spent amount if requested.

    * @return amount of tokens sent through the bridge to the other side.

    */

    function totalSpentPerDay(address _token, uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _token, _day))];

    }



    /**

    * @dev Retrieves the total executed amount for particular token during specific day.

    * @param _token address of the token contract.

    * @param _day day number for which spent amount if requested.

    * @return amount of tokens received from the bridge from the other side.

    */

    function totalExecutedPerDay(address _token, uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _token, _day))];

    }



    /**

    * @dev Retrieves current daily limit for a particular token contract.

    * @param _token address of the token contract.

    * @return daily limit on tokens that can be sent through the bridge per day.

    */

    function dailyLimit(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("dailyLimit", _token))];

    }



    /**

    * @dev Retrieves current execution daily limit for a particular token contract.

    * @param _token address of the token contract.

    * @return daily limit on tokens that can be received from the bridge on the other side per day.

    */

    function executionDailyLimit(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("executionDailyLimit", _token))];

    }



    /**

    * @dev Retrieves current maximum amount of tokens per one transfer for a particular token contract.

    * @param _token address of the token contract.

    * @return maximum amount on tokens that can be sent through the bridge in one transfer.

    */

    function maxPerTx(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("maxPerTx", _token))];

    }



    /**

    * @dev Retrieves current maximum execution amount of tokens per one transfer for a particular token contract.

    * @param _token address of the token contract.

    * @return maximum amount on tokens that can received from the bridge on the other side in one transaction.

    */

    function executionMaxPerTx(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("executionMaxPerTx", _token))];

    }



    /**

    * @dev Retrieves current minimum amount of tokens per one transfer for a particular token contract.

    * @param _token address of the token contract.

    * @return minimum amount on tokens that can be sent through the bridge in one transfer.

    */

    function minPerTx(address _token) public view returns (uint256) {

        uint256 limit = uintStorage[keccak256(abi.encodePacked("minPerTx", _token))];

        if (_token == address(0)) {

            return limit;

        }

        return limit > 0 ? 1 : 0;

    }



    /**

    * @dev Checks that bridged amount of tokens conforms to the configured limits.

    * @param _token address of the token contract.

    * @param _amount amount of bridge tokens.

    * @return true, if specified amount can be bridged.

    */

    function withinLimit(address _token, uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalSpentPerDay(_token, getCurrentDay()).add(_amount);

        return

            dailyLimit(address(0)) > 0 &&

                dailyLimit(_token) >= nextLimit &&

                _amount <= maxPerTx(_token) &&

                _amount >= minPerTx(_token);

    }



    /**

    * @dev Checks that bridged amount of tokens conforms to the configured execution limits.

    * @param _token address of the token contract.

    * @param _amount amount of bridge tokens.

    * @return true, if specified amount can be processed and executed.

    */

    function withinExecutionLimit(address _token, uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalExecutedPerDay(_token, getCurrentDay()).add(_amount);

        return

            executionDailyLimit(address(0)) > 0 &&

                executionDailyLimit(_token) >= nextLimit &&

                _amount <= executionMaxPerTx(_token);

    }



    /**

    * @dev Returns current day number.

    * @return day number.

    */

    function getCurrentDay() public view returns (uint256) {

        // solhint-disable-next-line not-rely-on-time

        return now / 1 days;

    }



    /**

    * @dev Updates daily limit for the particular token. Only owner can call this method.

    * @param _token address of the token contract, or address(0) for configuring the efault limit.

    * @param _dailyLimit daily allowed amount of bridged tokens, should be greater than maxPerTx.

    * 0 value is also allowed, will stop the bridge operations in outgoing direction.

    */

    function setDailyLimit(address _token, uint256 _dailyLimit) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_dailyLimit > maxPerTx(_token) || _dailyLimit == 0);

        uintStorage[keccak256(abi.encodePacked("dailyLimit", _token))] = _dailyLimit;

        emit DailyLimitChanged(_token, _dailyLimit);

    }



    /**

    * @dev Updates execution daily limit for the particular token. Only owner can call this method.

    * @param _token address of the token contract, or address(0) for configuring the default limit.

    * @param _dailyLimit daily allowed amount of executed tokens, should be greater than executionMaxPerTx.

    * 0 value is also allowed, will stop the bridge operations in incoming direction.

    */

    function setExecutionDailyLimit(address _token, uint256 _dailyLimit) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_dailyLimit > executionMaxPerTx(_token) || _dailyLimit == 0);

        uintStorage[keccak256(abi.encodePacked("executionDailyLimit", _token))] = _dailyLimit;

        emit ExecutionDailyLimitChanged(_token, _dailyLimit);

    }



    /**

    * @dev Updates execution maximum per transaction for the particular token. Only owner can call this method.

    * @param _token address of the token contract, or address(0) for configuring the default limit.

    * @param _maxPerTx maximum amount of executed tokens per one transaction, should be less than executionDailyLimit.

    * 0 value is also allowed, will stop the bridge operations in incoming direction.

    */

    function setExecutionMaxPerTx(address _token, uint256 _maxPerTx) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_maxPerTx == 0 || (_maxPerTx > 0 && _maxPerTx < executionDailyLimit(_token)));

        uintStorage[keccak256(abi.encodePacked("executionMaxPerTx", _token))] = _maxPerTx;

    }



    /**

    * @dev Updates maximum per transaction for the particular token. Only owner can call this method.

    * @param _token address of the token contract, or address(0) for configuring the default limit.

    * @param _maxPerTx maximum amount of tokens per one transaction, should be less than dailyLimit, greater than minPerTx.

    * 0 value is also allowed, will stop the bridge operations in outgoing direction.

    */

    function setMaxPerTx(address _token, uint256 _maxPerTx) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_maxPerTx == 0 || (_maxPerTx > minPerTx(_token) && _maxPerTx < dailyLimit(_token)));

        uintStorage[keccak256(abi.encodePacked("maxPerTx", _token))] = _maxPerTx;

    }



    /**

    * @dev Updates minumum per transaction for the particular token. Only owner can call this method.

    * @param _token address of the token contract, or address(0) for configuring the default limit.

    * @param _minPerTx minumum amount of tokens per one transaction, should be less than maxPerTx and dailyLimit.

    */

    function setMinPerTx(address _token, uint256 _minPerTx) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_minPerTx > 0 && _minPerTx < dailyLimit(_token) && _minPerTx < maxPerTx(_token));

        uintStorage[keccak256(abi.encodePacked("minPerTx", _token))] = _minPerTx;

    }



    /**

    * @dev Retrieves maximum available bridge amount per one transaction taking into account maxPerTx() and dailyLimit() parameters.

    * @param _token address of the token contract, or address(0) for the default limit.

    * @return minimum of maxPerTx parameter and remaining daily quota.

    */

    function maxAvailablePerTx(address _token) public view returns (uint256) {

        uint256 _maxPerTx = maxPerTx(_token);

        uint256 _dailyLimit = dailyLimit(_token);

        uint256 _spent = totalSpentPerDay(_token, getCurrentDay());

        uint256 _remainingOutOfDaily = _dailyLimit > _spent ? _dailyLimit - _spent : 0;

        return _maxPerTx < _remainingOutOfDaily ? _maxPerTx : _remainingOutOfDaily;

    }



    /**

    * @dev Internal function for adding spent amount for some token.

    * @param _token address of the token contract.

    * @param _day day number, when tokens are processed.

    * @param _value amount of bridge tokens.

    */

    function addTotalSpentPerDay(address _token, uint256 _day, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _token, _day))] = totalSpentPerDay(_token, _day).add(

            _value

        );

    }



    /**

    * @dev Internal function for adding execcuted amount for some token.

    * @param _token address of the token contract.

    * @param _day day number, when tokens are processed.

    * @param _value amount of bridge tokens.

    */

    function addTotalExecutedPerDay(address _token, uint256 _day, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _token, _day))] = totalExecutedPerDay(

            _token,

            _day

        )

            .add(_value);

    }



    /**

    * @dev Internal function for initializing limits for some token.

    * @param _token address of the token contract.

    * @param _limits [ 0 = dailyLimit, 1 = maxPerTx, 2 = minPerTx ].

    */

    function _setLimits(address _token, uint256[3] _limits) internal {

        require(

            _limits[2] > 0 && // minPerTx > 0

                _limits[1] > _limits[2] && // maxPerTx > minPerTx

                _limits[0] > _limits[1] // dailyLimit > maxPerTx

        );



        uintStorage[keccak256(abi.encodePacked("dailyLimit", _token))] = _limits[0];

        uintStorage[keccak256(abi.encodePacked("maxPerTx", _token))] = _limits[1];

        uintStorage[keccak256(abi.encodePacked("minPerTx", _token))] = _limits[2];



        emit DailyLimitChanged(_token, _limits[0]);

    }



    /**

    * @dev Internal function for initializing execution limits for some token.

    * @param _token address of the token contract.

    * @param _limits [ 0 = executionDailyLimit, 1 = executionMaxPerTx ].

    */

    function _setExecutionLimits(address _token, uint256[2] _limits) internal {

        require(_limits[1] < _limits[0]); // foreignMaxPerTx < foreignDailyLimit



        uintStorage[keccak256(abi.encodePacked("executionDailyLimit", _token))] = _limits[0];

        uintStorage[keccak256(abi.encodePacked("executionMaxPerTx", _token))] = _limits[1];



        emit ExecutionDailyLimitChanged(_token, _limits[0]);

    }



    /**

    * @dev Internal function for initializing limits for some token relative to its decimals parameter.

    * @param _token address of the token contract.

    * @param _decimals token decimals parameter.

    */

    function _initializeTokenBridgeLimits(address _token, uint256 _decimals) internal {

        uint256 factor;

        if (_decimals < 18) {

            factor = 10**(18 - _decimals);



            uint256 _minPerTx = minPerTx(address(0)).div(factor);

            uint256 _maxPerTx = maxPerTx(address(0)).div(factor);

            uint256 _dailyLimit = dailyLimit(address(0)).div(factor);

            uint256 _executionMaxPerTx = executionMaxPerTx(address(0)).div(factor);

            uint256 _executionDailyLimit = executionDailyLimit(address(0)).div(factor);



            // such situation can happen when calculated limits relative to the token decimals are too low

            // e.g. minPerTx(address(0)) == 10 ** 14, _decimals == 3. _minPerTx happens to be 0, which is not allowed.

            // in this case, limits are raised to the default values

            if (_minPerTx == 0) {

                // Numbers 1, 100, 10000 are chosen in a semi-random way,

                // so that any token with small decimals can still be bridged in some amounts.

                // It is possible to override limits for the particular token later if needed.

                _minPerTx = 1;

                if (_maxPerTx <= _minPerTx) {

                    _maxPerTx = 100;

                    _executionMaxPerTx = 100;

                    if (_dailyLimit <= _maxPerTx || _executionDailyLimit <= _executionMaxPerTx) {

                        _dailyLimit = 10000;

                        _executionDailyLimit = 10000;

                    }

                }

            }

            _setLimits(_token, [_dailyLimit, _maxPerTx, _minPerTx]);

            _setExecutionLimits(_token, [_executionDailyLimit, _executionMaxPerTx]);

        } else {

            factor = 10**(_decimals - 18);

            _setLimits(

                _token,

                [dailyLimit(address(0)).mul(factor), maxPerTx(address(0)).mul(factor), minPerTx(address(0)).mul(factor)]

            );

            _setExecutionLimits(

                _token,

                [executionDailyLimit(address(0)).mul(factor), executionMaxPerTx(address(0)).mul(factor)]

            );

        }

    }

}



// File: contracts/libraries/Bytes.sol



pragma solidity 0.4.24;



/**

 * @title Bytes

 * @dev Helper methods to transform bytes to other solidity types.

 */

library Bytes {

    /**

    * @dev Converts bytes array to bytes32.

    * Truncates bytes array if its size is more than 32 bytes.

    * NOTE: This function does not perform any checks on the received parameter.

    * Make sure that the _bytes argument has a correct length, not less than 32 bytes.

    * A case when _bytes has length less than 32 will lead to the undefined behaviour,

    * since assembly will read data from memory that is not related to the _bytes argument.

    * @param _bytes to be converted to bytes32 type

    * @return bytes32 type of the firsts 32 bytes array in parameter.

    */

    function bytesToBytes32(bytes _bytes) internal pure returns (bytes32 result) {

        assembly {

            result := mload(add(_bytes, 32))

        }

    }



    /**

    * @dev Truncate bytes array if its size is more than 20 bytes.

    * NOTE: Similar to the bytesToBytes32 function, make sure that _bytes is not shorter than 20 bytes.

    * @param _bytes to be converted to address type

    * @return address included in the firsts 20 bytes of the bytes array in parameter.

    */

    function bytesToAddress(bytes _bytes) internal pure returns (address addr) {

        assembly {

            addr := mload(add(_bytes, 20))

        }

    }

}



// File: openzeppelin-solidity/contracts/AddressUtils.sol



pragma solidity ^0.4.24;





/**

 * Utility library of inline functions on addresses

 */

library AddressUtils {



  /**

   * Returns whether the target address is a contract

   * @dev This function will return false if invoked during the constructor of a contract,

   * as the code is not actually created until after the constructor finishes.

   * @param _addr address to check

   * @return whether the target address is a contract

   */

  function isContract(address _addr) internal view returns (bool) {

    uint256 size;

    // XXX Currently there is no better way to check if there is a contract in an address

    // than to check the size of the code at that address.

    // See https://ethereum.stackexchange.com/a/14016/36603

    // for more details about how this works.

    // TODO Check this again before the Serenity release, because all addresses will be

    // contracts then.

    // solium-disable-next-line security/no-inline-assembly

    assembly { size := extcodesize(_addr) }

    return size > 0;

  }



}



// File: contracts/upgradeable_contracts/BasicAMBMediator.sol



pragma solidity 0.4.24;











/**

* @title BasicAMBMediator

* @dev Basic storage and methods needed by mediators to interact with AMB bridge.

*/

contract BasicAMBMediator is Ownable {

    bytes32 internal constant BRIDGE_CONTRACT = 0x811bbb11e8899da471f0e69a3ed55090fc90215227fc5fb1cb0d6e962ea7b74f; // keccak256(abi.encodePacked("bridgeContract"))

    bytes32 internal constant MEDIATOR_CONTRACT = 0x98aa806e31e94a687a31c65769cb99670064dd7f5a87526da075c5fb4eab9880; // keccak256(abi.encodePacked("mediatorContract"))

    bytes32 internal constant REQUEST_GAS_LIMIT = 0x2dfd6c9f781bb6bbb5369c114e949b69ebb440ef3d4dd6b2836225eb1dc3a2be; // keccak256(abi.encodePacked("requestGasLimit"))



    /**

    * @dev Throws if caller on the other side is not an associated mediator.

    */

    modifier onlyMediator {

        require(msg.sender == address(bridgeContract()));

        require(messageSender() == mediatorContractOnOtherSide());

        _;

    }



    /**

    * @dev Sets the AMB bridge contract address. Only the owner can call this method.

    * @param _bridgeContract the address of the bridge contract.

    */

    function setBridgeContract(address _bridgeContract) external onlyOwner {

        _setBridgeContract(_bridgeContract);

    }



    /**

    * @dev Sets the mediator contract address from the other network. Only the owner can call this method.

    * @param _mediatorContract the address of the mediator contract.

    */

    function setMediatorContractOnOtherSide(address _mediatorContract) external onlyOwner {

        _setMediatorContractOnOtherSide(_mediatorContract);

    }



    /**

    * @dev Sets the gas limit to be used in the message execution by the AMB bridge on the other network.

    * This value can't exceed the parameter maxGasPerTx defined on the AMB bridge.

    * Only the owner can call this method.

    * @param _requestGasLimit the gas limit for the message execution.

    */

    function setRequestGasLimit(uint256 _requestGasLimit) external onlyOwner {

        _setRequestGasLimit(_requestGasLimit);

    }



    /**

    * @dev Get the AMB interface for the bridge contract address

    * @return AMB interface for the bridge contract address

    */

    function bridgeContract() public view returns (IAMB) {

        return IAMB(addressStorage[BRIDGE_CONTRACT]);

    }



    /**

    * @dev Tells the mediator contract address from the other network.

    * @return the address of the mediator contract.

    */

    function mediatorContractOnOtherSide() public view returns (address) {

        return addressStorage[MEDIATOR_CONTRACT];

    }



    /**

    * @dev Tells the gas limit to be used in the message execution by the AMB bridge on the other network.

    * @return the gas limit for the message execution.

    */

    function requestGasLimit() public view returns (uint256) {

        return uintStorage[REQUEST_GAS_LIMIT];

    }



    /**

    * @dev Stores a valid AMB bridge contract address.

    * @param _bridgeContract the address of the bridge contract.

    */

    function _setBridgeContract(address _bridgeContract) internal {

        require(AddressUtils.isContract(_bridgeContract));

        addressStorage[BRIDGE_CONTRACT] = _bridgeContract;

    }



    /**

    * @dev Stores the mediator contract address from the other network.

    * @param _mediatorContract the address of the mediator contract.

    */

    function _setMediatorContractOnOtherSide(address _mediatorContract) internal {

        addressStorage[MEDIATOR_CONTRACT] = _mediatorContract;

    }



    /**

    * @dev Stores the gas limit to be used in the message execution by the AMB bridge on the other network.

    * @param _requestGasLimit the gas limit for the message execution.

    */

    function _setRequestGasLimit(uint256 _requestGasLimit) internal {

        require(_requestGasLimit <= maxGasPerTx());

        uintStorage[REQUEST_GAS_LIMIT] = _requestGasLimit;

    }



    /**

    * @dev Tells the address that generated the message on the other network that is currently being executed by

    * the AMB bridge.

    * @return the address of the message sender.

    */

    function messageSender() internal view returns (address) {

        return bridgeContract().messageSender();

    }



    /**

    * @dev Tells the id of the message originated on the other network.

    * @return the id of the message originated on the other network.

    */

    function messageId() internal view returns (bytes32) {

        return bridgeContract().messageId();

    }



    /**

    * @dev Tells the maximum gas limit that a message can use on its execution by the AMB bridge on the other network.

    * @return the maximum gas limit value.

    */

    function maxGasPerTx() internal view returns (uint256) {

        return bridgeContract().maxGasPerTx();

    }

}



// File: contracts/upgradeable_contracts/ChooseReceiverHelper.sol



pragma solidity 0.4.24;





contract ChooseReceiverHelper {

    /**

    * @dev Helper function for alternative receiver feature. Chooses the actual receiver out of sender and passed data.

    * @param _from address of tokens sender.

    * @param _data passed data in the transfer message.

    * @return address of the receiver on the other side.

    */

    function chooseReceiver(address _from, bytes _data) internal view returns (address recipient) {

        recipient = _from;

        if (_data.length > 0) {

            require(_data.length == 20);

            recipient = Bytes.bytesToAddress(_data);

            require(recipient != address(0));

            require(recipient != bridgeContractOnOtherSide());

        }

    }



    /* solcov ignore next */

    function bridgeContractOnOtherSide() internal view returns (address);

}



// File: contracts/upgradeable_contracts/TransferInfoStorage.sol



pragma solidity 0.4.24;





contract TransferInfoStorage is EternalStorage {

    /**

    * @dev Stores the value of a message sent to the AMB bridge.

    * @param _messageId of the message sent to the bridge.

    * @param _value amount of tokens bridged.

    */

    function setMessageValue(bytes32 _messageId, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("messageValue", _messageId))] = _value;

    }



    /**

    * @dev Tells the amount of tokens of a message sent to the AMB bridge.

    * @return value representing amount of tokens.

    */

    function messageValue(bytes32 _messageId) internal view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("messageValue", _messageId))];

    }



    /**

    * @dev Stores the receiver of a message sent to the AMB bridge.

    * @param _messageId of the message sent to the bridge.

    * @param _recipient receiver of the tokens bridged.

    */

    function setMessageRecipient(bytes32 _messageId, address _recipient) internal {

        addressStorage[keccak256(abi.encodePacked("messageRecipient", _messageId))] = _recipient;

    }



    /**

    * @dev Tells the receiver of a message sent to the AMB bridge.

    * @return address of the receiver.

    */

    function messageRecipient(bytes32 _messageId) internal view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("messageRecipient", _messageId))];

    }



    /**

    * @dev Sets that the message sent to the AMB bridge has been fixed.

    * @param _messageId of the message sent to the bridge.

    */

    function setMessageFixed(bytes32 _messageId) internal {

        boolStorage[keccak256(abi.encodePacked("messageFixed", _messageId))] = true;

    }



    /**

    * @dev Tells if a message sent to the AMB bridge has been fixed.

    * @return bool indicating the status of the message.

    */

    function messageFixed(bytes32 _messageId) public view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("messageFixed", _messageId))];

    }

}



// File: contracts/upgradeable_contracts/multi_amb_erc20_to_erc677/MultiTokenBridgeMediator.sol



pragma solidity 0.4.24;













/**

* @title MultiTokenBridgeMediator

* @dev Common mediator functionality to handle operations related to multi-token bridge messages sent to AMB bridge.

*/

contract MultiTokenBridgeMediator is

    BasicAMBMediator,

    BasicMultiTokenBridge,

    TransferInfoStorage,

    ChooseReceiverHelper

{

    event FailedMessageFixed(bytes32 indexed messageId, address token, address recipient, uint256 value);

    event TokensBridgingInitiated(

        address indexed token,

        address indexed sender,

        uint256 value,

        bytes32 indexed messageId

    );

    event TokensBridged(address indexed token, address indexed recipient, uint256 value, bytes32 indexed messageId);



    /**

    * @dev Stores the bridged token of a message sent to the AMB bridge.

    * @param _messageId of the message sent to the bridge.

    * @param _token bridged token address.

    */

    function setMessageToken(bytes32 _messageId, address _token) internal {

        addressStorage[keccak256(abi.encodePacked("messageToken", _messageId))] = _token;

    }



    /**

    * @dev Tells the bridged token address of a message sent to the AMB bridge.

    * @return address of a token contract.

    */

    function messageToken(bytes32 _messageId) internal view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("messageToken", _messageId))];

    }



    /**

    * @dev Handles the bridged tokens. Checks that the value is inside the execution limits and invokes the method

    * to execute the Mint or Unlock accordingly.

    * @param _token bridged ERC20/ERC677 token

    * @param _recipient address that will receive the tokens

    * @param _value amount of tokens to be received

    */

    function _handleBridgedTokens(ERC677 _token, address _recipient, uint256 _value) internal {

        if (withinExecutionLimit(_token, _value)) {

            addTotalExecutedPerDay(_token, getCurrentDay(), _value);

            executeActionOnBridgedTokens(_token, _recipient, _value);

        } else {

            executeActionOnBridgedTokensOutOfLimit(_token, _recipient, _value);

        }

    }



    /**

    * @dev Method to be called when a bridged message execution failed. It will generate a new message requesting to

    * fix/roll back the transferred assets on the other network.

    * @param _messageId id of the message which execution failed.

    */

    function requestFailedMessageFix(bytes32 _messageId) external {

        require(!bridgeContract().messageCallStatus(_messageId));

        require(bridgeContract().failedMessageReceiver(_messageId) == address(this));

        require(bridgeContract().failedMessageSender(_messageId) == mediatorContractOnOtherSide());



        bytes4 methodSelector = this.fixFailedMessage.selector;

        bytes memory data = abi.encodeWithSelector(methodSelector, _messageId);

        bridgeContract().requireToPassMessage(mediatorContractOnOtherSide(), data, requestGasLimit());

    }



    /**

    * @dev Handles the request to fix transferred assets which bridged message execution failed on the other network.

    * It uses the information stored by passMessage method when the assets were initially transferred

    * @param _messageId id of the message which execution failed on the other network.

    */

    function fixFailedMessage(bytes32 _messageId) public onlyMediator {

        require(!messageFixed(_messageId));



        address token = messageToken(_messageId);

        address recipient = messageRecipient(_messageId);

        uint256 value = messageValue(_messageId);

        setMessageFixed(_messageId);

        executeActionOnFixedTokens(token, recipient, value);

        emit FailedMessageFixed(_messageId, token, recipient, value);

    }



    /**

    * @dev Execute the action to be performed when the bridge tokens are out of execution limits.

    */

    function executeActionOnBridgedTokensOutOfLimit(address, address, uint256) internal {

        revert();

    }



    /* solcov ignore next */

    function executeActionOnBridgedTokens(address _token, address _recipient, uint256 _value) internal;



    /* solcov ignore next */

    function executeActionOnFixedTokens(address _token, address _recipient, uint256 _value) internal;

}



// File: contracts/upgradeable_contracts/Initializable.sol



pragma solidity 0.4.24;





contract Initializable is EternalStorage {

    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked("isInitialized"))



    function setInitialize() internal {

        boolStorage[INITIALIZED] = true;

    }



    function isInitialized() public view returns (bool) {

        return boolStorage[INITIALIZED];

    }

}



// File: contracts/upgradeable_contracts/ReentrancyGuard.sol



pragma solidity 0.4.24;



contract ReentrancyGuard {

    function lock() internal returns (bool res) {

        assembly {

            // Even though this is not the same as boolStorage[keccak256(abi.encodePacked("lock"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            res := sload(0x6168652c307c1e813ca11cfb3a601f1cf3b22452021a5052d8b05f1f1f8a3e92) // keccak256(abi.encodePacked("lock"))

        }

    }



    function setLock(bool _lock) internal {

        assembly {

            // Even though this is not the same as boolStorage[keccak256(abi.encodePacked("lock"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            sstore(0x6168652c307c1e813ca11cfb3a601f1cf3b22452021a5052d8b05f1f1f8a3e92, _lock) // keccak256(abi.encodePacked("lock"))

        }

    }

}



// File: contracts/upgradeable_contracts/Upgradeable.sol



pragma solidity 0.4.24;





contract Upgradeable {

    // Avoid using onlyUpgradeabilityOwner name to prevent issues with implementation from proxy contract

    modifier onlyIfUpgradeabilityOwner() {

        require(msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner());

        /* solcov ignore next */

        _;

    }

}



// File: contracts/upgradeable_contracts/Sacrifice.sol



pragma solidity 0.4.24;



contract Sacrifice {

    constructor(address _recipient) public payable {

        selfdestruct(_recipient);

    }

}



// File: contracts/libraries/Address.sol



pragma solidity 0.4.24;





/**

 * @title Address

 * @dev Helper methods for Address type.

 */

library Address {

    /**

    * @dev Try to send native tokens to the address. If it fails, it will force the transfer by creating a selfdestruct contract

    * @param _receiver address that will receive the native tokens

    * @param _value the amount of native tokens to send

    */

    function safeSendValue(address _receiver, uint256 _value) internal {

        if (!_receiver.send(_value)) {

            (new Sacrifice).value(_value)(_receiver);

        }

    }

}



// File: contracts/libraries/SafeERC20.sol



pragma solidity 0.4.24;







/**

 * @title SafeERC20

 * @dev Helper methods for safe token transfers.

 * Functions perform additional checks to be sure that token transfer really happened.

 */

library SafeERC20 {

    using SafeMath for uint256;



    /**

    * @dev Same as ERC20.transfer(address,uint256) but with extra consistency checks.

    * @param _token address of the token contract

    * @param _to address of the receiver

    * @param _value amount of tokens to send

    */

    function safeTransfer(address _token, address _to, uint256 _value) internal {

        LegacyERC20(_token).transfer(_to, _value);

        assembly {

            if returndatasize {

                returndatacopy(0, 0, 32)

                if iszero(mload(0)) {

                    revert(0, 0)

                }

            }

        }

    }



    /**

    * @dev Same as ERC20.transferFrom(address,address,uint256) but with extra consistency checks.

    * @param _token address of the token contract

    * @param _from address of the sender

    * @param _value amount of tokens to send

    */

    function safeTransferFrom(address _token, address _from, uint256 _value) internal {

        LegacyERC20(_token).transferFrom(_from, address(this), _value);

        assembly {

            if returndatasize {

                returndatacopy(0, 0, 32)

                if iszero(mload(0)) {

                    revert(0, 0)

                }

            }

        }

    }

}



// File: contracts/upgradeable_contracts/Claimable.sol



pragma solidity 0.4.24;







/**

 * @title Claimable

 * @dev Implementation of the claiming utils that can be useful for withdrawing accidentally sent tokens that are not used in bridge operations.

 */

contract Claimable {

    using SafeERC20 for address;



    /**

     * Throws if a given address is equal to address(0)

     */

    modifier validAddress(address _to) {

        require(_to != address(0));

        /* solcov ignore next */

        _;

    }



    /**

     * @dev Withdraws the erc20 tokens or native coins from this contract.

     * Caller should additionally check that the claimed token is not a part of bridge operations (i.e. that token != erc20token()).

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimValues(address _token, address _to) internal validAddress(_to) {

        if (_token == address(0)) {

            claimNativeCoins(_to);

        } else {

            claimErc20Tokens(_token, _to);

        }

    }



    /**

     * @dev Internal function for withdrawing all native coins from the contract.

     * @param _to address of the coins receiver.

     */

    function claimNativeCoins(address _to) internal {

        uint256 value = address(this).balance;

        Address.safeSendValue(_to, value);

    }



    /**

     * @dev Internal function for withdrawing all tokens of ssome particular ERC20 contract from this contract.

     * @param _token address of the claimed ERC20 token.

     * @param _to address of the tokens receiver.

     */

    function claimErc20Tokens(address _token, address _to) internal {

        ERC20Basic token = ERC20Basic(_token);

        uint256 balance = token.balanceOf(this);

        _token.safeTransfer(_to, balance);

    }

}



// File: contracts/upgradeable_contracts/VersionableBridge.sol



pragma solidity 0.4.24;



contract VersionableBridge {

    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {

        return (5, 2, 0);

    }



    /* solcov ignore next */

    function getBridgeMode() external pure returns (bytes4);

}



// File: contracts/upgradeable_contracts/multi_amb_erc20_to_erc677/BasicMultiAMBErc20ToErc677.sol



pragma solidity 0.4.24;



















/**

* @title BasicMultiAMBErc20ToErc677

* @dev Common functionality for multi-erc20-to-erc677 mediator intended to work on top of AMB bridge.

*/

contract BasicMultiAMBErc20ToErc677 is

    Initializable,

    ReentrancyGuard,

    Upgradeable,

    Claimable,

    VersionableBridge,

    MultiTokenBridgeMediator

{

    /**

    * @dev Tells the address of the mediator contract on the other side, used by chooseReceiver method

    * to avoid sending the native tokens to that address.

    * @return address of the mediator contract con the other side

    */

    function bridgeContractOnOtherSide() internal view returns (address) {

        return mediatorContractOnOtherSide();

    }



    /**

    * @dev Initiate the bridge operation for some amount of tokens from msg.sender.

    * The user should first call Approve method of the ERC677 token.

    * @param token bridged token contract address.

    * @param _receiver address that will receive the native tokens on the other network.

    * @param _value amount of tokens to be transferred to the other network.

    */

    function relayTokens(ERC677 token, address _receiver, uint256 _value) external {

        _relayTokens(token, _receiver, _value);

    }



    /**

    * @dev Initiate the bridge operation for some amount of tokens from msg.sender to msg.sender on the other side.

    * The user should first call Approve method of the ERC677 token.

    * @param token bridged token contract address.

    * @param _value amount of tokens to be transferred to the other network.

    */

    function relayTokens(ERC677 token, uint256 _value) external {

        _relayTokens(token, msg.sender, _value);

    }



    /**

    * @dev Tells the bridge interface version that this contract supports.

    * @return major value of the version

    * @return minor value of the version

    * @return patch value of the version

    */

    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {

        return (1, 4, 0);

    }



    /**

    * @dev Tells the bridge mode that this contract supports.

    * @return _data 4 bytes representing the bridge mode

    */

    function getBridgeMode() external pure returns (bytes4 _data) {

        return 0xb1516c26; // bytes4(keccak256(abi.encodePacked("multi-erc-to-erc-amb")))

    }



    /**

    * @dev Claims stucked tokens. Only unsupported tokens can be claimed.

    * When dealing with already supported tokens, fixMediatorBalance can be used instead.

    * @param _token address of claimed token, address(0) for native

    * @param _to address of tokens receiver

    */

    function claimTokens(address _token, address _to) external onlyIfUpgradeabilityOwner {

        // Only unregistered tokens and native coins are allowed to be claimed with the use of this function

        require(_token == address(0) || !isTokenRegistered(_token));

        claimValues(_token, _to);

    }



    /* solcov ignore next */

    function onTokenTransfer(address _from, uint256 _value, bytes _data) public returns (bool);



    /* solcov ignore next */

    function _relayTokens(ERC677 token, address _receiver, uint256 _value) internal;



    /* solcov ignore next */

    function bridgeSpecificActionsOnTokenTransfer(ERC677 _token, address _from, address _receiver, uint256 _value)

        internal;

}



// File: contracts/upgradeability/Proxy.sol



pragma solidity 0.4.24;



/**

 * @title Proxy

 * @dev Gives the possibility to delegate any call to a foreign implementation.

 */

contract Proxy {

    /**

    * @dev Tells the address of the implementation where every call will be delegated.

    * @return address of the implementation to which it will be delegated

    */

    /* solcov ignore next */

    function implementation() public view returns (address);



    /**

    * @dev Fallback function allowing to perform a delegatecall to the given implementation.

    * This function will return whatever the implementation call returns

    */

    function() public payable {

        // solhint-disable-previous-line no-complex-fallback

        address _impl = implementation();

        require(_impl != address(0));

        assembly {

            /*

                0x40 is the "free memory slot", meaning a pointer to next slot of empty memory. mload(0x40)

                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty

                memory. It's needed because we're going to write the return data of delegatecall to the

                free memory slot.

            */

            let ptr := mload(0x40)

            /*

                `calldatacopy` is copy calldatasize bytes from calldata

                First argument is the destination to which data is copied(ptr)

                Second argument specifies the start position of the copied data.

                    Since calldata is sort of its own unique location in memory,

                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.

                    That's always going to be the zeroth byte of the function selector.

                Third argument, calldatasize, specifies how much data will be copied.

                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)

            */

            calldatacopy(ptr, 0, calldatasize)

            /*

                delegatecall params explained:

                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives

                    us the amount of gas still available to execution



                _impl: address of the contract to delegate to



                ptr: to pass copied data



                calldatasize: loads the size of `bytes memory data`, same as msg.data.length



                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,

                        these are set to 0, 0 so the output data will not be written to memory. The output

                        data will be read using `returndatasize` and `returdatacopy` instead.



                result: This will be 0 if the call fails and 1 if it succeeds

            */

            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)

            /*



            */

            /*

                ptr current points to the value stored at 0x40,

                because we assigned it like ptr := mload(0x40).

                Because we use 0x40 as a free memory pointer,

                we want to make sure that the next time we want to allocate memory,

                we aren't overwriting anything important.

                So, by adding ptr and returndatasize,

                we get a memory location beyond the end of the data we will be copying to ptr.

                We place this in at 0x40, and any reads from 0x40 will now read from free memory

            */

            mstore(0x40, add(ptr, returndatasize))

            /*

                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the

                    slot it will copy to, 0 means copy from the beginning of the return data, and size is

                    the amount of data to copy.

                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall

            */

            returndatacopy(ptr, 0, returndatasize)



            /*

                if `result` is 0, revert.

                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was

                copied to `ptr` from the delegatecall return data

            */

            switch result

                case 0 {

                    revert(ptr, returndatasize)

                }

                default {

                    return(ptr, returndatasize)

                }

        }

    }

}



// File: contracts/upgradeable_contracts/multi_amb_erc20_to_erc677/TokenProxy.sol



pragma solidity 0.4.24;





interface IPermittableTokenVersion {

    function version() external pure returns (string);

}



/**

* @title TokenProxy

* @dev Helps to reduces the size of the deployed bytecode for automatically created tokens, by using a proxy contract.

*/

contract TokenProxy is Proxy {

    // storage layout is copied from PermittableToken.sol

    string internal name;

    string internal symbol;

    uint8 internal decimals;

    mapping(address => uint256) internal balances;

    uint256 internal totalSupply;

    mapping(address => mapping(address => uint256)) internal allowed;

    address internal owner;

    bool internal mintingFinished;

    address internal bridgeContractAddr;

    // string public constant version = "1";

    bytes32 internal DOMAIN_SEPARATOR;

    // bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;

    mapping(address => uint256) internal nonces;

    mapping(address => mapping(address => uint256)) internal expirations;



    /**

    * @dev Creates a non-upgradeable token proxy for PermitableToken.sol, initializes its eternalStorage.

    * @param _tokenImage address of the token image used for mirroring all functions.

    * @param _name token name.

    * @param _symbol token symbol.

    * @param _decimals token decimals.

    * @param _chainId chain id for current network.

    */

    constructor(address _tokenImage, string memory _name, string memory _symbol, uint8 _decimals, uint256 _chainId)

        public

    {

        string memory version = IPermittableTokenVersion(_tokenImage).version();



        assembly {

            // EIP 1967

            // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)

            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _tokenImage)

        }

        name = _name;

        symbol = _symbol;

        decimals = _decimals;

        owner = msg.sender; // msg.sender == HomeMultiAMBErc20ToErc677 mediator

        bridgeContractAddr = msg.sender;

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),

                keccak256(bytes(_name)),

                keccak256(bytes(version)),

                _chainId,

                address(this)

            )

        );

    }



    /**

    * @dev Retrieves the implementation contract address, mirrored token image.

    * @return token image address.

    */

    function implementation() public view returns (address impl) {

        assembly {

            impl := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)

        }

    }

}



// File: contracts/upgradeable_contracts/BaseRewardAddressList.sol



pragma solidity 0.4.24;







/**

* @title BaseRewardAddressList

* @dev Implements the logic to store, add and remove reward account addresses. Works as a linked list.

*/

contract BaseRewardAddressList is EternalStorage {

    using SafeMath for uint256;



    address public constant F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;

    uint256 internal constant MAX_REWARD_ADDRESSES = 50;

    bytes32 internal constant REWARD_ADDRESS_COUNT = 0xabc77c82721ced73eef2645facebe8c30249e6ac372cce6eb9d1fed31bd6648f; // keccak256(abi.encodePacked("rewardAddressCount"))



    event RewardAddressAdded(address indexed addr);

    event RewardAddressRemoved(address indexed addr);



    /**

    * @dev Retrieves all registered reward accounts.

    * @return address list of the registered reward receivers.

    */

    function rewardAddressList() external view returns (address[]) {

        address[] memory list = new address[](rewardAddressCount());

        uint256 counter = 0;

        address nextAddr = getNextRewardAddress(F_ADDR);



        while (nextAddr != F_ADDR) {

            require(nextAddr != address(0));



            list[counter] = nextAddr;

            nextAddr = getNextRewardAddress(nextAddr);

            counter++;

        }



        return list;

    }



    /**

    * @dev Retrieves amount of registered reward accounts.

    * @return length of reward addresses list.

    */

    function rewardAddressCount() public view returns (uint256) {

        return uintStorage[REWARD_ADDRESS_COUNT];

    }



    /**

    * @dev Checks if specified address is included into the registered rewards receivers list.

    * @param _addr address to verify.

    * @return true, if specified address is associated with one of the registered reward accounts.

    */

    function isRewardAddress(address _addr) public view returns (bool) {

        return _addr != F_ADDR && getNextRewardAddress(_addr) != address(0);

    }



    /**

    * @dev Retrieves next reward address in the linked list, or F_ADDR if given address is the last one.

    * @param _address address of some reward account.

    * @return address of the next reward receiver.

    */

    function getNextRewardAddress(address _address) public view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("rewardAddressList", _address))];

    }



    /**

    * @dev Internal function for adding a new reward address to the linked list.

    * @param _addr new reward account.

    */

    function _addRewardAddress(address _addr) internal {

        require(_addr != address(0) && _addr != F_ADDR);

        require(!isRewardAddress(_addr));



        address nextAddr = getNextRewardAddress(F_ADDR);



        require(nextAddr != address(0));



        _setNextRewardAddress(_addr, nextAddr);

        _setNextRewardAddress(F_ADDR, _addr);

        _setRewardAddressCount(rewardAddressCount().add(1));

    }



    /**

    * @dev Internal function for removing existing reward address from the linked list.

    * @param _addr old reward account which should be removed.

    */

    function _removeRewardAddress(address _addr) internal {

        require(isRewardAddress(_addr));

        address nextAddr = getNextRewardAddress(_addr);

        address index = F_ADDR;

        address next = getNextRewardAddress(index);



        while (next != _addr) {

            require(next != address(0));

            index = next;

            next = getNextRewardAddress(index);

            require(next != F_ADDR);

        }



        _setNextRewardAddress(index, nextAddr);

        delete addressStorage[keccak256(abi.encodePacked("rewardAddressList", _addr))];

        _setRewardAddressCount(rewardAddressCount().sub(1));

    }



    /**

    * @dev Internal function for initializing linked list with the array of the initial reward addresses.

    * @param _rewardAddresses initial reward addresses list, should be non-empty.

    */

    function _setRewardAddressList(address[] _rewardAddresses) internal {

        require(_rewardAddresses.length > 0);



        _setNextRewardAddress(F_ADDR, _rewardAddresses[0]);



        for (uint256 i = 0; i < _rewardAddresses.length; i++) {

            require(_rewardAddresses[i] != address(0) && _rewardAddresses[i] != F_ADDR);

            require(!isRewardAddress(_rewardAddresses[i]));



            if (i == _rewardAddresses.length - 1) {

                _setNextRewardAddress(_rewardAddresses[i], F_ADDR);

            } else {

                _setNextRewardAddress(_rewardAddresses[i], _rewardAddresses[i + 1]);

            }



            emit RewardAddressAdded(_rewardAddresses[i]);

        }



        _setRewardAddressCount(_rewardAddresses.length);

    }



    /**

    * @dev Internal function for updating the length of the reward accounts list.

    * @param _rewardAddressCount new linked list length.

    */

    function _setRewardAddressCount(uint256 _rewardAddressCount) internal {

        require(_rewardAddressCount <= MAX_REWARD_ADDRESSES);

        uintStorage[REWARD_ADDRESS_COUNT] = _rewardAddressCount;

    }



    /**

    * @dev Internal function for updating the pointer to the next reward receiver.

    * @param _prevAddr address of some reward receiver.

    * @param _addr address of the next receiver to which _prevAddr should point to.

    */

    function _setNextRewardAddress(address _prevAddr, address _addr) internal {

        addressStorage[keccak256(abi.encodePacked("rewardAddressList", _prevAddr))] = _addr;

    }

}



// File: contracts/interfaces/IBurnableMintableERC677Token.sol



pragma solidity 0.4.24;





contract IBurnableMintableERC677Token is ERC677 {

    function mint(address _to, uint256 _amount) public returns (bool);

    function burn(uint256 _value) public;

    function claimTokens(address _token, address _to) external;

}



// File: contracts/upgradeable_contracts/multi_amb_erc20_to_erc677/HomeFeeManagerMultiAMBErc20ToErc677.sol



pragma solidity 0.4.24;













/**

* @title HomeFeeManagerMultiAMBErc20ToErc677

* @dev Implements the logic to distribute fees from the multi erc20 to erc677 mediator contract operations.

* The fees are distributed in the form of native tokens to the list of reward accounts.

*/

contract HomeFeeManagerMultiAMBErc20ToErc677 is BaseRewardAddressList, Ownable, BasicMultiTokenBridge {

    using SafeMath for uint256;



    event FeeUpdated(bytes32 feeType, address indexed token, uint256 fee);

    event FeeDistributed(uint256 fee, address indexed token, bytes32 indexed messageId);



    // This is not a real fee value but a relative value used to calculate the fee percentage

    uint256 internal constant MAX_FEE = 1 ether;

    bytes32 public constant HOME_TO_FOREIGN_FEE = 0x741ede137d0537e88e0ea0ff25b1f22d837903dbbee8980b4a06e8523247ee26; // keccak256(abi.encodePacked("homeToForeignFee"))

    bytes32 public constant FOREIGN_TO_HOME_FEE = 0x03be2b2875cb41e0e77355e802a16769bb8dfcf825061cde185c73bf94f12625; // keccak256(abi.encodePacked("foreignToHomeFee"))



    /**

    * @dev Throws if given fee percentage is >= 100%.

    */

    modifier validFee(uint256 _fee) {

        require(_fee < MAX_FEE);

        /* solcov ignore next */

        _;

    }



    /**

    * @dev Throws if given fee type is unknown.

    */

    modifier validFeeType(bytes32 _feeType) {

        require(_feeType == HOME_TO_FOREIGN_FEE || _feeType == FOREIGN_TO_HOME_FEE);

        /* solcov ignore next */

        _;

    }



    /**

    * @dev Adds a new reward address to the list, which will receive fees collected from the bridge operations.

    * Only the owner can call this method.

    * @param _addr new reward account.

    */

    function addRewardAddress(address _addr) external onlyOwner {

        _addRewardAddress(_addr);

    }



    /**

    * @dev Removes a reward address from the rewards list.

    * Only the owner can call this method.

    * @param _addr old reward account, that should be removed.

    */

    function removeRewardAddress(address _addr) external onlyOwner {

        _removeRewardAddress(_addr);

    }



    /**

    * @dev Updates the value for the particular fee type.

    * Only the owner can call this method.

    * @param _feeType type of the updated fee, can be one of [HOME_TO_FOREIGN_FEE, FOREIGN_TO_HOME_FEE].

    * @param _token address of the token contract for which fee should apply, 0x00..00 describes the initial fee for newly created tokens.

    * @param _fee new fee value, in percentage (1 ether == 10**18 == 100%).

    */

    function setFee(bytes32 _feeType, address _token, uint256 _fee) external onlyOwner {

        _setFee(_feeType, _token, _fee);

    }



    /**

    * @dev Retrieves the value for the particular fee type.

    * @param _feeType type of the updated fee, can be one of [HOME_TO_FOREIGN_FEE, FOREIGN_TO_HOME_FEE].

    * @param _token address of the token contract for which fee should apply, 0x00..00 describes the initial fee for newly created tokens.

    * @return fee value associated with the requested fee type.

    */

    function getFee(bytes32 _feeType, address _token) public view validFeeType(_feeType) returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked(_feeType, _token))];

    }



    /**

    * @dev Calculates the amount of fee to pay for the value of the particular fee type.

    * @param _feeType type of the updated fee, can be one of [HOME_TO_FOREIGN_FEE, FOREIGN_TO_HOME_FEE].

    * @param _token address of the token contract for which fee should apply, 0x00..00 describes the initial fee for newly created tokens.

    * @param _value bridged value, for which fee should be evaluated.

    * @return amount of fee to be subtracted from the transferred value.

    */

    function calculateFee(bytes32 _feeType, address _token, uint256 _value) public view returns (uint256) {

        uint256 _fee = getFee(_feeType, _token);

        return _value.mul(_fee).div(MAX_FEE);

    }



    /**

    * @dev Internal function for updating the fee value for the given fee type.

    * @param _feeType type of the updated fee, can be one of [HOME_TO_FOREIGN_FEE, FOREIGN_TO_HOME_FEE].

    * @param _token address of the token contract for which fee should apply, 0x00..00 describes the initial fee for newly created tokens.

    * @param _fee new fee value, in percentage (1 ether == 10**18 == 100%).

    */

    function _setFee(bytes32 _feeType, address _token, uint256 _fee) internal validFeeType(_feeType) validFee(_fee) {

        require(isTokenRegistered(_token));

        uintStorage[keccak256(abi.encodePacked(_feeType, _token))] = _fee;

        emit FeeUpdated(_feeType, _token, _fee);

    }



    /**

    * @dev Calculates a random number based on the block number.

    * @param _count the max value for the random number.

    * @return a number between 0 and _count.

    */

    function random(uint256 _count) internal view returns (uint256) {

        return uint256(blockhash(block.number.sub(1))) % _count;

    }



    /**

    * @dev Calculates and distributes the amount of fee proportionally between registered reward addresses.

    * @param _feeType type of the updated fee, can be one of [HOME_TO_FOREIGN_FEE, FOREIGN_TO_HOME_FEE].

    * @param _token address of the token contract for which fee should apply, 0x00..00 describes the initial fee for newly created tokens.

    * @param _value bridged value, for which fee should be evaluated.

    * @return total amount of fee subtracted from the transferred value and distributed between the reward accounts.

    */

    function _distributeFee(bytes32 _feeType, address _token, uint256 _value) internal returns (uint256) {

        uint256 numOfAccounts = rewardAddressCount();

        uint256 _fee = calculateFee(_feeType, _token, _value);

        if (numOfAccounts == 0 || _fee == 0) {

            return 0;

        }

        uint256 feePerAccount = _fee.div(numOfAccounts);

        uint256 randomAccountIndex;

        uint256 diff = _fee.sub(feePerAccount.mul(numOfAccounts));

        if (diff > 0) {

            randomAccountIndex = random(numOfAccounts);

        }



        address nextAddr = getNextRewardAddress(F_ADDR);

        require(nextAddr != F_ADDR && nextAddr != address(0));



        uint256 i = 0;

        while (nextAddr != F_ADDR) {

            uint256 feeToDistribute = feePerAccount;

            if (diff > 0 && randomAccountIndex == i) {

                feeToDistribute = feeToDistribute.add(diff);

            }



            if (_feeType == HOME_TO_FOREIGN_FEE) {

                ERC677(_token).transfer(nextAddr, feeToDistribute);

            } else {

                IBurnableMintableERC677Token(_token).mint(nextAddr, feeToDistribute);

            }



            nextAddr = getNextRewardAddress(nextAddr);

            require(nextAddr != address(0));

            i = i + 1;

        }

        return _fee;

    }

}



// File: contracts/upgradeable_contracts/multi_amb_erc20_to_erc677/MultiTokenForwardingRules.sol



pragma solidity 0.4.24;





/**

 * @title MultiTokenForwardingRules

 * @dev Multi token mediator functionality for managing destination AMB lanes permissions.

 */

contract MultiTokenForwardingRules is Ownable {

    address internal constant ANY_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;



    event ForwardingRuleUpdated(address token, address sender, address receiver, int256 lane);



    /**

     * @dev Tells the destination lane for a particular bridge operation by checking several wildcard forwarding rules.

     * @param _token address of the token contract on the foreign side of the bridge.

     * @param _sender address of the tokens sender on the home side of the bridge.

     * @param _receiver address of the tokens receiver on the foreign side of the bridge.

     * @return destination lane identifier, where the message should be forwarded to.

     *  1 - oracle-driven-lane should be used.

     *  0 - default behaviour should be applied.

     * -1 - manual lane should be used.

     */

    function destinationLane(address _token, address _sender, address _receiver) public view returns (int256) {

        int256 defaultLane = forwardingRule(_token, ANY_ADDRESS, ANY_ADDRESS); // specific token for all senders and receivers

        int256 lane;

        if (defaultLane < 0) {

            lane = forwardingRule(_token, _sender, ANY_ADDRESS); // specific token for specific sender

            if (lane != 0) return lane;

            lane = forwardingRule(_token, ANY_ADDRESS, _receiver); // specific token for specific receiver

            if (lane != 0) return lane;

            return defaultLane;

        }

        lane = forwardingRule(ANY_ADDRESS, _sender, ANY_ADDRESS); // all tokens for specific sender

        if (lane != 0) return lane;

        return forwardingRule(ANY_ADDRESS, ANY_ADDRESS, _receiver); // all tokens for specific receiver

    }



    /**

     * Updates the forwarding rule for bridging specific token.

     * Only owner can call this method.

     * @param _token address of the token contract on the foreign side.

     * @param _enable true, if bridge operations for a given token should be forwarded to the manual lane.

     */

    function setTokenForwardingRule(address _token, bool _enable) external {

        require(_token != ANY_ADDRESS);

        _setForwardingRule(_token, ANY_ADDRESS, ANY_ADDRESS, _enable ? int256(-1) : int256(0));

    }



    /**

     * Allows a particular address to send bridge requests to the oracle-driven lane for a particular token.

     * Only owner can call this method.

     * @param _token address of the token contract on the foreign side.

     * @param _sender address of the tokens sender on the home side of the bridge.

     * @param _enable true, if bridge operations for a given token and sender should be forwarded to the oracle-driven lane.

     */

    function setSenderExceptionForTokenForwardingRule(address _token, address _sender, bool _enable) external {

        require(_token != ANY_ADDRESS);

        require(_sender != ANY_ADDRESS);

        _setForwardingRule(_token, _sender, ANY_ADDRESS, _enable ? int256(1) : int256(0));

    }



    /**

     * Allows a particular address to receive bridged tokens from the oracle-driven lane for a particular token.

     * Only owner can call this method.

     * @param _token address of the token contract on the foreign side.

     * @param _receiver address of the tokens receiver on the foreign side of the bridge.

     * @param _enable true, if bridge operations for a given token and receiver should be forwarded to the oracle-driven lane.

     */

    function setReceiverExceptionForTokenForwardingRule(address _token, address _receiver, bool _enable) external {

        require(_token != ANY_ADDRESS);

        require(_receiver != ANY_ADDRESS);

        _setForwardingRule(_token, ANY_ADDRESS, _receiver, _enable ? int256(1) : int256(0));

    }



    /**

     * Updates the forwarding rule for the specific sender.

     * Only owner can call this method.

     * @param _sender address of the tokens sender on the home side.

     * @param _enable true, if all bridge operations from a given sender should be forwarded to the manual lane.

     */

    function setSenderForwardingRule(address _sender, bool _enable) external {

        require(_sender != ANY_ADDRESS);

        _setForwardingRule(ANY_ADDRESS, _sender, ANY_ADDRESS, _enable ? int256(-1) : int256(0));

    }



    /**

     * Updates the forwarding rule for the specific receiver.

     * Only owner can call this method.

     * @param _receiver address of the tokens receiver on the foreign side.

     * @param _enable true, if all bridge operations to a given receiver should be forwarded to the manual lane.

     */

    function setReceiverForwardingRule(address _receiver, bool _enable) external {

        require(_receiver != ANY_ADDRESS);

        _setForwardingRule(ANY_ADDRESS, ANY_ADDRESS, _receiver, _enable ? int256(-1) : int256(0));

    }



    /**

     * @dev Tells forwarding rule set up for a particular bridge operation.

     * @param _token address of the token contract on the foreign side of the bridge.

     * @param _sender address of the tokens sender on the home side of the bridge.

     * @param _receiver address of the tokens receiver on the foreign side of the bridge.

     * @return preferred destination lane for the particular bridge operation.

     */

    function forwardingRule(address _token, address _sender, address _receiver) public view returns (int256) {

        return intStorage[keccak256(abi.encodePacked("forwardTo", _token, _sender, _receiver))];

    }



    /**

     * @dev Internal function for updating the preferred destination lane for the specific wildcard pattern.

     * Only owner can call this method.

     * Examples:

     *   _setForwardingRule(tokenA, ANY_ADDRESS, ANY_ADDRESS, -1) - forward all operations on tokenA to the manual lane

     *   _setForwardingRule(tokenA, Alice, ANY_ADDRESS, 1) - allow Alice to use the oracle-driven lane for bridging tokenA

     *   _setForwardingRule(tokenA, ANY_ADDRESS, Bob, 1) - forward all tokenA bridge operations, where Bob is the receiver, to the oracle-driven lane

     *   _setForwardingRule(ANY_ADDRESS, Mallory, ANY_ADDRESS, -1) - forward all bridge operations from Mallory to the manual lane

     * @param _token address of the token contract on the foreign side of the bridge.

     * @param _sender address of the tokens sender on the home side of the bridge.

     * @param _receiver address of the tokens receiver on the foreign side of the bridge.

     * @param _lane preferred destination lane for the particular sender.

     *  1 - forward to the oracle-driven lane.

     *  0 - behaviour is unset, proceed by checking other less-specific rules.

     * -1 - manual lane should be used.

     */

    function _setForwardingRule(address _token, address _sender, address _receiver, int256 _lane) internal onlyOwner {

        intStorage[keccak256(abi.encodePacked("forwardTo", _token, _sender, _receiver))] = _lane;



        emit ForwardingRuleUpdated(_token, _sender, _receiver, _lane);

    }

}



// File: contracts/upgradeable_contracts/multi_amb_erc20_to_erc677/HomeMultiAMBErc20ToErc677.sol



pragma solidity 0.4.24;













/**

* @title HomeMultiAMBErc20ToErc677

* @dev Home side implementation for multi-erc20-to-erc677 mediator intended to work on top of AMB bridge.

* It is designed to be used as an implementation contract of EternalStorageProxy contract.

*/

contract HomeMultiAMBErc20ToErc677 is

    BasicMultiAMBErc20ToErc677,

    HomeFeeManagerMultiAMBErc20ToErc677,

    MultiTokenForwardingRules

{

    bytes32 internal constant TOKEN_IMAGE_CONTRACT = 0x20b8ca26cc94f39fab299954184cf3a9bd04f69543e4f454fab299f015b8130f; // keccak256(abi.encodePacked("tokenImageContract"))



    event NewTokenRegistered(address indexed foreignToken, address indexed homeToken);



    /**

    * @dev Stores the initial parameters of the mediator.

    * @param _bridgeContract the address of the AMB bridge contract.

    * @param _mediatorContract the address of the mediator contract on the other network.

    * @param _dailyLimitMaxPerTxMinPerTxArray array with limit values for the assets to be bridged to the other network.

    *   [ 0 = dailyLimit, 1 = maxPerTx, 2 = minPerTx ]

    * @param _executionDailyLimitExecutionMaxPerTxArray array with limit values for the assets bridged from the other network.

    *   [ 0 = executionDailyLimit, 1 = executionMaxPerTx ]

    * @param _requestGasLimit the gas limit for the message execution.

    * @param _owner address of the owner of the mediator contract.

    * @param _tokenImage address of the PermittableToken contract that will be used for deploying of new tokens.

    * @param _rewardAddresses list of reward addresses, between whom fees will be distributed.

    * @param _fees array with initial fees for both bridge directions.

    *   [ 0 = homeToForeignFee, 1 = foreignToHomeFee ]

    */

    function initialize(

        address _bridgeContract,

        address _mediatorContract,

        uint256[3] _dailyLimitMaxPerTxMinPerTxArray, // [ 0 = _dailyLimit, 1 = _maxPerTx, 2 = _minPerTx ]

        uint256[2] _executionDailyLimitExecutionMaxPerTxArray, // [ 0 = _executionDailyLimit, 1 = _executionMaxPerTx ]

        uint256 _requestGasLimit,

        address _owner,

        address _tokenImage,

        address[] _rewardAddresses,

        uint256[2] _fees // [ 0 = homeToForeignFee, 1 = foreignToHomeFee ]

    ) external onlyRelevantSender returns (bool) {

        require(!isInitialized());



        _setBridgeContract(_bridgeContract);

        _setMediatorContractOnOtherSide(_mediatorContract);

        _setLimits(address(0), _dailyLimitMaxPerTxMinPerTxArray);

        _setExecutionLimits(address(0), _executionDailyLimitExecutionMaxPerTxArray);

        _setRequestGasLimit(_requestGasLimit);

        _setOwner(_owner);

        _setTokenImage(_tokenImage);

        if (_rewardAddresses.length > 0) {

            _setRewardAddressList(_rewardAddresses);

        }

        _setFee(HOME_TO_FOREIGN_FEE, address(0), _fees[0]);

        _setFee(FOREIGN_TO_HOME_FEE, address(0), _fees[1]);



        setInitialize();



        return isInitialized();

    }



    /**

    * @dev Updates an address of the token image contract used for proxifying newly created tokens.

    * @param _tokenImage address of PermittableToken contract.

    */

    function setTokenImage(address _tokenImage) external onlyOwner {

        _setTokenImage(_tokenImage);

    }



    /**

    * @dev Retrieves address of the token image contract.

    * @return address of block reward contract.

    */

    function tokenImage() public view returns (address) {

        return addressStorage[TOKEN_IMAGE_CONTRACT];

    }



    /**

    * @dev Handles the bridged tokens for the first time, includes deployment of new TokenProxy contract.

    * Checks that the value is inside the execution limits and invokes the method

    * to execute the Mint or Unlock accordingly.

    * @param _token address of the bridged ERC20/ERC677 token on the foreign side.

    * @param _name name of the bridged token, "x" will be appended, if empty, symbol will be used instead.

    * @param _symbol symbol of the bridged token, "x" will be appended, if empty, name will be used instead.

    * @param _decimals decimals of the bridge foreign token.

    * @param _recipient address that will receive the tokens.

    * @param _value amount of tokens to be received.

    */

    function deployAndHandleBridgedTokens(

        address _token,

        string _name,

        string _symbol,

        uint8 _decimals,

        address _recipient,

        uint256 _value

    ) external onlyMediator {

        string memory name = _name;

        string memory symbol = _symbol;

        require(bytes(name).length > 0 || bytes(symbol).length > 0);

        if (bytes(name).length == 0) {

            name = symbol;

        } else if (bytes(symbol).length == 0) {

            symbol = name;

        }

        name = string(abi.encodePacked(name, " on xDai"));

        address homeToken = new TokenProxy(tokenImage(), name, symbol, _decimals, bridgeContract().sourceChainId());

        _setTokenAddressPair(_token, homeToken);

        _initializeTokenBridgeLimits(homeToken, _decimals);

        _setFee(HOME_TO_FOREIGN_FEE, homeToken, getFee(HOME_TO_FOREIGN_FEE, address(0)));

        _setFee(FOREIGN_TO_HOME_FEE, homeToken, getFee(FOREIGN_TO_HOME_FEE, address(0)));

        _handleBridgedTokens(ERC677(homeToken), _recipient, _value);



        emit NewTokenRegistered(_token, homeToken);

    }



    /**

    * @dev Handles the bridged tokens. Checks that the value is inside the execution limits and invokes the method

    * to execute the Mint or Unlock accordingly.

    * @param _token bridged ERC20 token.

    * @param _recipient address that will receive the tokens.

    * @param _value amount of tokens to be received.

    */

    function handleBridgedTokens(ERC677 _token, address _recipient, uint256 _value) external onlyMediator {

        ERC677 homeToken = ERC677(homeTokenAddress(_token));

        require(isTokenRegistered(homeToken));

        _handleBridgedTokens(homeToken, _recipient, _value);

    }



    /**

    * @dev ERC677 transfer callback function.

    * @param _from address of tokens sender.

    * @param _value amount of transferred tokens.

    * @param _data additional transfer data, can be used for passing alternative receiver address.

    */

    function onTokenTransfer(address _from, uint256 _value, bytes _data) public returns (bool) {

        // if onTokenTransfer is called as a part of call to _relayTokens, this callback does nothing

        if (!lock()) {

            ERC677 token = ERC677(msg.sender);

            // if msg.sender if not a valid token contract, this check will fail, since limits are zeros

            // so the following check is not needed

            // require(isTokenRegistered(token));

            require(withinLimit(token, _value));

            addTotalSpentPerDay(token, getCurrentDay(), _value);

            bridgeSpecificActionsOnTokenTransfer(token, _from, chooseReceiver(_from, _data), _value);

        }

        return true;

    }



    /**

    * @dev Validates that the token amount is inside the limits, calls transferFrom to transfer the tokens to the contract

    * and invokes the method to burn/lock the tokens and unlock/mint the tokens on the other network.

    * The user should first call Approve method of the ERC677 token.

    * @param token bridge token contract address.

    * @param _receiver address that will receive the native tokens on the other network.

    * @param _value amount of tokens to be transferred to the other network.

    */

    function _relayTokens(ERC677 token, address _receiver, uint256 _value) internal {

        // This lock is to prevent calling passMessage twice if a ERC677 token is used.

        // When transferFrom is called, after the transfer, the ERC677 token will call onTokenTransfer from this contract

        // which will call passMessage.

        require(!lock());

        address to = address(this);

        // if msg.sender if not a valid token contract, this check will fail, since limits are zeros

        // so the following check is not needed

        // require(isTokenRegistered(token));

        require(withinLimit(token, _value));

        addTotalSpentPerDay(token, getCurrentDay(), _value);



        setLock(true);

        token.transferFrom(msg.sender, to, _value);

        setLock(false);

        bridgeSpecificActionsOnTokenTransfer(token, msg.sender, _receiver, _value);

    }



    /**

     * @dev Executes action on the request to deposit tokens relayed from the other network

     * @param _recipient address of tokens receiver

     * @param _value amount of bridged tokens

     */

    function executeActionOnBridgedTokens(address _token, address _recipient, uint256 _value) internal {

        bytes32 _messageId = messageId();

        uint256 valueToMint = _value;

        uint256 fee = _distributeFee(FOREIGN_TO_HOME_FEE, _token, valueToMint);

        if (fee > 0) {

            emit FeeDistributed(fee, _token, _messageId);

            valueToMint = valueToMint.sub(fee);

        }

        IBurnableMintableERC677Token(_token).mint(_recipient, valueToMint);

        emit TokensBridged(_token, _recipient, valueToMint, _messageId);

    }



    /**

    * @dev Mints back the amount of tokens that were bridged to the other network but failed.

    * @param _token address that bridged token contract.

    * @param _recipient address that will receive the tokens.

    * @param _value amount of tokens to be received.

    */

    function executeActionOnFixedTokens(address _token, address _recipient, uint256 _value) internal {

        IBurnableMintableERC677Token(_token).mint(_recipient, _value);

    }



    /**

    * @dev Retrieves address of the home bridged token contract associated with a specific foreign token contract.

    * @param _foreignToken address of the created home token contract.

    * @return address of the home token contract.

    */

    function homeTokenAddress(address _foreignToken) public view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("homeTokenAddress", _foreignToken))];

    }



    /**

    * @dev Retrieves address of the foreign bridged token contract associated with a specific home token contract.

    * @param _homeToken address of the created home token contract.

    * @return address of the foreign token contract.

    */

    function foreignTokenAddress(address _homeToken) public view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("foreignTokenAddress", _homeToken))];

    }



    /**

    * @dev Internal function for updating an address of the token image contract.

    * @param _foreignToken address of bridged foreign token contract.

    * @param _foreignToken address of created home token contract.

    */

    function _setTokenAddressPair(address _foreignToken, address _homeToken) internal {

        addressStorage[keccak256(abi.encodePacked("homeTokenAddress", _foreignToken))] = _homeToken;

        addressStorage[keccak256(abi.encodePacked("foreignTokenAddress", _homeToken))] = _foreignToken;

    }



    /**

    * @dev Internal function for updating an address of the token image contract.

    * @param _tokenImage address of deployed PermittableToken contract.

    */

    function _setTokenImage(address _tokenImage) internal {

        require(AddressUtils.isContract(_tokenImage));

        addressStorage[TOKEN_IMAGE_CONTRACT] = _tokenImage;

    }



    /**

     * @dev Executes action on withdrawal of bridged tokens

     * @param _token address of token contract

     * @param _from address of tokens sender

     * @param _receiver address of tokens receiver on the other side

     * @param _value requested amount of bridged tokens

     */

    function bridgeSpecificActionsOnTokenTransfer(ERC677 _token, address _from, address _receiver, uint256 _value)

        internal

    {

        uint256 valueToBridge = _value;

        uint256 fee = 0;

        // Next line disables fee collection in case sender is one of the reward addresses.

        // It is needed to allow a 100% withdrawal of tokens from the home side.

        // If fees are not disabled for reward receivers, small fraction of tokens will always

        // be redistributed between the same set of reward addresses, which is not the desired behaviour.

        if (!isRewardAddress(_from)) {

            fee = _distributeFee(HOME_TO_FOREIGN_FEE, _token, valueToBridge);

            valueToBridge = valueToBridge.sub(fee);

        }

        IBurnableMintableERC677Token(_token).burn(valueToBridge);

        bytes32 _messageId = passMessage(_token, _from, _receiver, valueToBridge);

        if (fee > 0) {

            emit FeeDistributed(fee, _token, _messageId);

        }

    }



    /**

    * @dev Call AMB bridge to require the invocation of handleBridgedTokens method of the mediator on the other network.

    * Store information related to the bridged tokens in case the message execution fails on the other network

    * and the action needs to be fixed/rolled back.

    * @param _token bridged ERC20 token

    * @param _from address of sender, if bridge operation fails, tokens will be returned to this address

    * @param _receiver address of receiver on the other side, will eventually receive bridged tokens

    * @param _value bridged amount of tokens

    * @return id of the created and passed message

    */

    function passMessage(ERC677 _token, address _from, address _receiver, uint256 _value) internal returns (bytes32) {

        bytes4 methodSelector = this.handleBridgedTokens.selector;

        address foreignToken = foreignTokenAddress(_token);

        bytes memory data = abi.encodeWithSelector(methodSelector, foreignToken, _receiver, _value);



        address executor = mediatorContractOnOtherSide();

        uint256 gasLimit = requestGasLimit();

        IAMB bridge = bridgeContract();



        // Address of the foreign token is used here for determining lane permissions.

        // Such decision makes it possible to set rules for tokens that are not bridged yet.

        bytes32 _messageId = destinationLane(foreignToken, _from, _receiver) >= 0

            ? bridge.requireToPassMessage(executor, data, gasLimit)

            : bridge.requireToConfirmMessage(executor, data, gasLimit);



        setMessageToken(_messageId, _token);

        setMessageValue(_messageId, _value);

        setMessageRecipient(_messageId, _from);



        emit TokensBridgingInitiated(_token, _from, _value, _messageId);



        return _messageId;

    }

}



// File: contracts/libraries/TokenReader.sol



pragma solidity 0.4.24;



/**

 * @title TokenReader

 * @dev Helper methods for reading name/symbol/decimals parameters from ERC20 token contracts.

 */

library TokenReader {

    /**

    * @dev Reads the name property of the provided token.

    * Either name() or NAME() method is used.

    * Both, string and bytes32 types are supported.

    * @param _token address of the token contract.

    * @return token name as a string or an empty string if none of the methods succeeded.

    */

    function readName(address _token) internal view returns (string) {

        uint256 ptr;

        uint256 size;

        assembly {

            ptr := mload(0x40)

            mstore(ptr, 0x06fdde0300000000000000000000000000000000000000000000000000000000) // name()

            if iszero(staticcall(gas, _token, ptr, 4, ptr, 32)) {

                mstore(ptr, 0xa3f4df7e00000000000000000000000000000000000000000000000000000000) // NAME()

                staticcall(gas, _token, ptr, 4, ptr, 32)

                pop

            }



            mstore(0x40, add(ptr, returndatasize))



            switch gt(returndatasize, 32)

                case 1 {

                    returndatacopy(mload(0x40), 32, 32) // string length

                    size := mload(mload(0x40))

                }

                default {

                    size := returndatasize // 32 or 0

                }

        }

        string memory res = new string(size);

        assembly {

            if gt(returndatasize, 32) {

                // load as string

                returndatacopy(add(res, 32), 64, size)

                jump(exit)

            }

            /* solhint-disable */

            if gt(returndatasize, 0) {

                let i := 0

                ptr := mload(ptr) // load bytes32 value

                mstore(add(res, 32), ptr) // save value in result string



                for { } gt(ptr, 0) { i := add(i, 1) } { // until string is empty

                    ptr := shl(8, ptr) // shift left by one symbol

                }

                mstore(res, i) // save result string length

            }

            exit:

            /* solhint-enable */

        }

        return res;

    }



    /**

    * @dev Reads the symbol property of the provided token.

    * Either symbol() or SYMBOL() method is used.

    * Both, string and bytes32 types are supported.

    * @param _token address of the token contract.

    * @return token symbol as a string or an empty string if none of the methods succeeded.

    */

    function readSymbol(address _token) internal view returns (string) {

        uint256 ptr;

        uint256 size;

        assembly {

            ptr := mload(0x40)

            mstore(ptr, 0x95d89b4100000000000000000000000000000000000000000000000000000000) // symbol()

            if iszero(staticcall(gas, _token, ptr, 4, ptr, 32)) {

                mstore(ptr, 0xf76f8d7800000000000000000000000000000000000000000000000000000000) // SYMBOL()

                staticcall(gas, _token, ptr, 4, ptr, 32)

                pop

            }



            mstore(0x40, add(ptr, returndatasize))



            switch gt(returndatasize, 32)

                case 1 {

                    returndatacopy(mload(0x40), 32, 32) // string length

                    size := mload(mload(0x40))

                }

                default {

                    size := returndatasize // 32 or 0

                }

        }

        string memory res = new string(size);

        assembly {

            if gt(returndatasize, 32) {

                // load as string

                returndatacopy(add(res, 32), 64, size)

                jump(exit)

            }

            /* solhint-disable */

            if gt(returndatasize, 0) {

                let i := 0

                ptr := mload(ptr) // load bytes32 value

                mstore(add(res, 32), ptr) // save value in result string



                for { } gt(ptr, 0) { i := add(i, 1) } { // until string is empty

                    ptr := shl(8, ptr) // shift left by one symbol

                }

                mstore(res, i) // save result string length

            }

            exit:

            /* solhint-enable */

        }

        return res;

    }



    /**

    * @dev Reads the decimals property of the provided token.

    * Either decimals() or DECIMALS() method is used.

    * @param _token address of the token contract.

    * @return token decimals or 0 if none of the methods succeeded.

    */

    function readDecimals(address _token) internal view returns (uint256) {

        uint256 decimals;

        assembly {

            let ptr := mload(0x40)

            mstore(0x40, add(ptr, 32))

            mstore(ptr, 0x313ce56700000000000000000000000000000000000000000000000000000000) // decimals()

            if iszero(staticcall(gas, _token, ptr, 4, ptr, 32)) {

                mstore(ptr, 0x2e0f262500000000000000000000000000000000000000000000000000000000) // DECIMALS()

                if iszero(staticcall(gas, _token, ptr, 4, ptr, 32)) {

                    mstore(ptr, 0)

                }

            }

            decimals := mload(ptr)

        }

        return decimals;

    }

}



// File: contracts/upgradeable_contracts/multi_amb_erc20_to_erc677/ForeignMultiAMBErc20ToErc677.sol



pragma solidity 0.4.24;













/**

 * @title ForeignMultiAMBErc20ToErc677

 * @dev Foreign side implementation for multi-erc20-to-erc677 mediator intended to work on top of AMB bridge.

 * It is designed to be used as an implementation contract of EternalStorageProxy contract.

 */

contract ForeignMultiAMBErc20ToErc677 is BasicMultiAMBErc20ToErc677 {

    using SafeERC20 for address;

    using SafeERC20 for ERC677;



    /**

    * @dev Stores the initial parameters of the mediator.

    * @param _bridgeContract the address of the AMB bridge contract.

    * @param _mediatorContract the address of the mediator contract on the other network.

    * @param _dailyLimitMaxPerTxMinPerTxArray array with limit values for the assets to be bridged to the other network.

    *   [ 0 = dailyLimit, 1 = maxPerTx, 2 = minPerTx ]

    * @param _executionDailyLimitExecutionMaxPerTxArray array with limit values for the assets bridged from the other network.

    *   [ 0 = executionDailyLimit, 1 = executionMaxPerTx ]

    * @param _requestGasLimit the gas limit for the message execution.

    * @param _owner address of the owner of the mediator contract.

    */

    function initialize(

        address _bridgeContract,

        address _mediatorContract,

        uint256[3] _dailyLimitMaxPerTxMinPerTxArray, // [ 0 = _dailyLimit, 1 = _maxPerTx, 2 = _minPerTx ]

        uint256[2] _executionDailyLimitExecutionMaxPerTxArray, // [ 0 = _executionDailyLimit, 1 = _executionMaxPerTx ]

        uint256 _requestGasLimit,

        address _owner

    ) external onlyRelevantSender returns (bool) {

        require(!isInitialized());



        _setBridgeContract(_bridgeContract);

        _setMediatorContractOnOtherSide(_mediatorContract);

        _setLimits(address(0), _dailyLimitMaxPerTxMinPerTxArray);

        _setExecutionLimits(address(0), _executionDailyLimitExecutionMaxPerTxArray);

        _setRequestGasLimit(_requestGasLimit);

        _setOwner(_owner);



        setInitialize();



        return isInitialized();

    }



    /**

     * @dev Executes action on the request to withdraw tokens relayed from the other network

     * @param _token address of the token contract

     * @param _recipient address of tokens receiver

     * @param _value amount of bridged tokens

     */

    function executeActionOnBridgedTokens(address _token, address _recipient, uint256 _value) internal {

        bytes32 _messageId = messageId();

        _releaseTokens(_token, _recipient, _value);

        emit TokensBridged(_token, _recipient, _value, _messageId);

    }



    /**

    * @dev ERC677 transfer callback function.

    * @param _from address of tokens sender.

    * @param _value amount of transferred tokens.

    * @param _data additional transfer data, can be used for passing alternative receiver address.

    */

    function onTokenTransfer(address _from, uint256 _value, bytes _data) public returns (bool) {

        if (!lock()) {

            ERC677 token = ERC677(msg.sender);

            bridgeSpecificActionsOnTokenTransfer(token, _from, chooseReceiver(_from, _data), _value);

        }

        return true;

    }



    /**

    * @dev Handles the bridged tokens. Checks that the value is inside the execution limits and invokes the method

    * to execute the Mint or Unlock accordingly.

    * @param _token bridged ERC20 token.

    * @param _recipient address that will receive the tokens.

    * @param _value amount of tokens to be received.

    */

    function handleBridgedTokens(ERC677 _token, address _recipient, uint256 _value) external onlyMediator {

        require(isTokenRegistered(_token));

        _handleBridgedTokens(_token, _recipient, _value);

    }



    /**

    * @dev Validates that the token amount is inside the limits, calls transferFrom to transfer the tokens to the contract

    * and invokes the method to burn/lock the tokens and unlock/mint the tokens on the other network.

    * The user should first call Approve method of the ERC677 token.

    * @param token bridge token contract address.

    * @param _receiver address that will receive the native tokens on the other network.

    * @param _value amount of tokens to be transferred to the other network.

    */

    function _relayTokens(ERC677 token, address _receiver, uint256 _value) internal {

        // This lock is to prevent calling passMessage twice if a ERC677 token is used.

        // When transferFrom is called, after the transfer, the ERC677 token will call onTokenTransfer from this contract

        // which will call passMessage.

        require(!lock());



        uint256 balanceBefore = token.balanceOf(address(this));

        setLock(true);

        token.safeTransferFrom(msg.sender, _value);

        setLock(false);

        uint256 balanceDiff = token.balanceOf(address(this)).sub(balanceBefore);

        require(balanceDiff <= _value);

        bridgeSpecificActionsOnTokenTransfer(token, msg.sender, _receiver, balanceDiff);

    }



    /**

     * @dev Executes action on deposit of bridged tokens

     * @param _token address of the token contract

     * @param _from address of tokens sender

     * @param _receiver address of tokens receiver on the other side

     * @param _value requested amount of bridged tokens

     */

    function bridgeSpecificActionsOnTokenTransfer(ERC677 _token, address _from, address _receiver, uint256 _value)

        internal

    {

        bool isKnownToken = isTokenRegistered(_token);

        if (!isKnownToken) {

            string memory name = TokenReader.readName(_token);

            string memory symbol = TokenReader.readSymbol(_token);

            uint8 decimals = uint8(TokenReader.readDecimals(_token));



            require(bytes(name).length > 0 || bytes(symbol).length > 0);



            _initializeTokenBridgeLimits(_token, decimals);

        }



        require(withinLimit(_token, _value));

        addTotalSpentPerDay(_token, getCurrentDay(), _value);



        bytes memory data;



        if (isKnownToken) {

            data = abi.encodeWithSelector(this.handleBridgedTokens.selector, _token, _receiver, _value);

        } else {

            data = abi.encodeWithSelector(

                HomeMultiAMBErc20ToErc677(this).deployAndHandleBridgedTokens.selector,

                _token,

                name,

                symbol,

                decimals,

                _receiver,

                _value

            );

        }



        _setMediatorBalance(_token, mediatorBalance(_token).add(_value));



        bytes32 _messageId = bridgeContract().requireToPassMessage(

            mediatorContractOnOtherSide(),

            data,

            requestGasLimit()

        );



        setMessageToken(_messageId, _token);

        setMessageValue(_messageId, _value);

        setMessageRecipient(_messageId, _from);



        if (!isKnownToken) {

            _setTokenRegistrationMessageId(_token, _messageId);

        }



        emit TokensBridgingInitiated(_token, _from, _value, _messageId);

    }



    /**

    * @dev Handles the request to fix transferred assets which bridged message execution failed on the other network.

    * It uses the information stored by passMessage method when the assets were initially transferred

    * @param _messageId id of the message which execution failed on the other network.

    */

    function fixFailedMessage(bytes32 _messageId) public {

        super.fixFailedMessage(_messageId);

        address token = messageToken(_messageId);

        if (_messageId == tokenRegistrationMessageId(token)) {

            delete uintStorage[keccak256(abi.encodePacked("dailyLimit", token))];

            delete uintStorage[keccak256(abi.encodePacked("maxPerTx", token))];

            delete uintStorage[keccak256(abi.encodePacked("minPerTx", token))];

            delete uintStorage[keccak256(abi.encodePacked("executionDailyLimit", token))];

            delete uintStorage[keccak256(abi.encodePacked("executionMaxPerTx", token))];

            _setTokenRegistrationMessageId(token, bytes32(0));

        }

    }



    /**

    * @dev Unlock back the amount of tokens that were bridged to the other network but failed.

    * @param _token address that bridged token contract.

    * @param _recipient address that will receive the tokens.

    * @param _value amount of tokens to be received.

    */

    function executeActionOnFixedTokens(address _token, address _recipient, uint256 _value) internal {

        _releaseTokens(_token, _recipient, _value);

    }



    /**

    * @dev Allows to send to the other network the amount of locked tokens that can be forced into the contract

    * without the invocation of the required methods. (e. g. regular transfer without a call to onTokenTransfer)

    * @param _token address of the token contract.

    * @param _receiver the address that will receive the tokens on the other network.

    */

    function fixMediatorBalance(address _token, address _receiver)

        external

        onlyIfUpgradeabilityOwner

        validAddress(_receiver)

    {

        require(isTokenRegistered(_token));

        uint256 balance = ERC677(_token).balanceOf(address(this));

        uint256 expectedBalance = mediatorBalance(_token);

        require(balance > expectedBalance);

        uint256 diff = balance - expectedBalance;

        uint256 available = maxAvailablePerTx(_token);

        require(available > 0);

        if (diff > available) {

            diff = available;

        }

        addTotalSpentPerDay(_token, getCurrentDay(), diff);

        _setMediatorBalance(_token, expectedBalance.add(diff));



        bytes memory data = abi.encodeWithSelector(this.handleBridgedTokens.selector, _token, _receiver, diff);



        bytes32 _messageId = bridgeContract().requireToPassMessage(

            mediatorContractOnOtherSide(),

            data,

            requestGasLimit()

        );



        setMessageToken(_messageId, _token);

        setMessageValue(_messageId, diff);

        setMessageRecipient(_messageId, _receiver);

    }



    /**

    * @dev Tells the expected token balance of the contract.

    * @param _token address of token contract.

    * @return the current tracked token balance of the contract.

    */

    function mediatorBalance(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("mediatorBalance", _token))];

    }



    /**

    * @dev Returns message id where specified token was first seen and deploy on the other side was requested.

    * @param _token address of token contract.

    * @return message id of the send message.

    */

    function tokenRegistrationMessageId(address _token) public view returns (bytes32) {

        return bytes32(uintStorage[keccak256(abi.encodePacked("tokenRegistrationMessageId", _token))]);

    }



    /**

    * @dev Updates expected token balance of the contract.

    * @param _token address of token contract.

    * @param _balance the new token balance of the contract.

    */

    function _setMediatorBalance(address _token, uint256 _balance) internal {

        uintStorage[keccak256(abi.encodePacked("mediatorBalance", _token))] = _balance;

    }



    /**

    * @dev Updates message id where specified token was first seen and deploy on the other side was requested.

    * @param _token address of token contract.

    * @param _messageId message id of the send message.

    */

    function _setTokenRegistrationMessageId(address _token, bytes32 _messageId) internal {

        uintStorage[keccak256(abi.encodePacked("tokenRegistrationMessageId", _token))] = uint256(_messageId);

    }



    /**

     * Internal function for unlocking some amount of tokens.

     * In case of bridging STAKE token, the insufficient amount of tokens can be additionally minted.

     */

    function _releaseTokens(address _token, address _recipient, uint256 _value) internal {

        // It is necessary to use mediatorBalance(STAKE) instead of STAKE.balanceOf(this) to disallow user

        // withdraw mistakenly locked funds (via regular transfer()) instead of minting new tokens.

        // It should be possible to process mistakenly locked funds by calling fixMediatorBalance.

        uint256 balance = mediatorBalance(_token);



        // STAKE total supply on xDai can be higher than the native STAKE supply on Mainnet

        // Omnibridge is allowed to mint extra native STAKE tokens.

        if (_token == address(0x0Ae055097C6d159879521C384F1D2123D1f195e6) && balance < _value) {

            // if all locked tokens were already withdrawn, mint new tokens directly to receiver

            // mediatorBalance(STAKE) remains 0 in this case.

            if (balance == 0) {

                IBurnableMintableERC677Token(_token).mint(_recipient, _value);

                return;

            }



            // otherwise, mint insufficient tokens to the contract

            IBurnableMintableERC677Token(_token).mint(address(this), _value - balance);

            balance = _value;

        }

        _token.safeTransfer(_recipient, _value);

        _setMediatorBalance(_token, balance.sub(_value));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ForeignNFTOmnibridge.sol
File type: .sol
pragma solidity 0.7.5;

// solhint-disable-next-line compiler-version

pragma abicoder v2;



import "./BasicNFTOmnibridge.sol";

import "./components/common/GasLimitManager.sol";



/**

 * @title ForeignNFTOmnibridge

 * @dev Foreign side implementation for multi-token ERC721 mediator intended to work on top of AMB bridge.

 * It is designed to be used as an implementation contract of EternalStorageProxy contract.

 */

contract ForeignNFTOmnibridge is BasicNFTOmnibridge, GasLimitManager {

    constructor(string memory _suffix) BasicNFTOmnibridge(_suffix) {}



    /**

     * @dev Stores the initial parameters of the mediator.

     * @param _bridgeContract the address of the AMB bridge contract.

     * @param _mediatorContract the address of the mediator contract on the other network.

     * @param _requestGasLimit the gas limit for the message execution.

     * @param _owner address of the owner of the mediator contract.

     * @param _imageERC721 address of the ERC721 token image.

     * @param _imageERC1155 address of the ERC1155 token image.

     */

    function initialize(

        address _bridgeContract,

        address _mediatorContract,

        uint256 _requestGasLimit,

        address _owner,

        address _imageERC721,

        address _imageERC1155

    ) external onlyRelevantSender returns (bool) {

        require(!isInitialized());



        _setBridgeContract(_bridgeContract);

        _setMediatorContractOnOtherSide(_mediatorContract);

        _setRequestGasLimit(_requestGasLimit);

        _setOwner(_owner);

        _setTokenImageERC721(_imageERC721);

        _setTokenImageERC1155(_imageERC1155);



        setInitialize();



        return isInitialized();

    }



    /**

     * @dev Internal function for sending an AMB message to the mediator on the other side.

     * @param _data data to be sent to the other side of the bridge.

     * @param _useOracleLane always true, not used on this side of the bridge.

     * @return id of the sent message.

     */

    function _passMessage(bytes memory _data, bool _useOracleLane) internal override returns (bytes32) {

        (_useOracleLane);



        return bridgeContract().requireToPassMessage(mediatorContractOnOtherSide(), _data, requestGasLimit());

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ForeignOmnibridge.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-05-16

*/



// File: @openzeppelin/contracts/math/SafeMath.sol





pragma solidity ^0.7.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: contracts/upgradeability/EternalStorage.sol



pragma solidity 0.7.5;



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {

    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;

}



// File: contracts/upgradeable_contracts/Initializable.sol



pragma solidity 0.7.5;





contract Initializable is EternalStorage {

    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked("isInitialized"))



    function setInitialize() internal {

        boolStorage[INITIALIZED] = true;

    }



    function isInitialized() public view returns (bool) {

        return boolStorage[INITIALIZED];

    }

}



// File: contracts/interfaces/IUpgradeabilityOwnerStorage.sol



pragma solidity 0.7.5;



interface IUpgradeabilityOwnerStorage {

    function upgradeabilityOwner() external view returns (address);

}



// File: contracts/upgradeable_contracts/Upgradeable.sol



pragma solidity 0.7.5;





contract Upgradeable {

    // Avoid using onlyUpgradeabilityOwner name to prevent issues with implementation from proxy contract

    modifier onlyIfUpgradeabilityOwner() {

        require(msg.sender == IUpgradeabilityOwnerStorage(address(this)).upgradeabilityOwner());

        _;

    }

}



// File: @openzeppelin/contracts/token/ERC20/IERC20.sol





pragma solidity ^0.7.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: @openzeppelin/contracts/utils/Address.sol





pragma solidity ^0.7.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol





pragma solidity ^0.7.0;









/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



// File: contracts/upgradeable_contracts/Sacrifice.sol



pragma solidity 0.7.5;



contract Sacrifice {

    constructor(address payable _recipient) payable {

        selfdestruct(_recipient);

    }

}



// File: contracts/libraries/AddressHelper.sol



pragma solidity 0.7.5;





/**

 * @title AddressHelper

 * @dev Helper methods for Address type.

 */

library AddressHelper {

    /**

     * @dev Try to send native tokens to the address. If it fails, it will force the transfer by creating a selfdestruct contract

     * @param _receiver address that will receive the native tokens

     * @param _value the amount of native tokens to send

     */

    function safeSendValue(address payable _receiver, uint256 _value) internal {

        if (!(_receiver).send(_value)) {

            new Sacrifice{ value: _value }(_receiver);

        }

    }

}



// File: contracts/upgradeable_contracts/Claimable.sol



pragma solidity 0.7.5;







/**

 * @title Claimable

 * @dev Implementation of the claiming utils that can be useful for withdrawing accidentally sent tokens that are not used in bridge operations.

 */

contract Claimable {

    using SafeERC20 for IERC20;



    /**

     * Throws if a given address is equal to address(0)

     */

    modifier validAddress(address _to) {

        require(_to != address(0));

        _;

    }



    /**

     * @dev Withdraws the erc20 tokens or native coins from this contract.

     * Caller should additionally check that the claimed token is not a part of bridge operations (i.e. that token != erc20token()).

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimValues(address _token, address _to) internal validAddress(_to) {

        if (_token == address(0)) {

            claimNativeCoins(_to);

        } else {

            claimErc20Tokens(_token, _to);

        }

    }



    /**

     * @dev Internal function for withdrawing all native coins from the contract.

     * @param _to address of the coins receiver.

     */

    function claimNativeCoins(address _to) internal {

        uint256 value = address(this).balance;

        AddressHelper.safeSendValue(payable(_to), value);

    }



    /**

     * @dev Internal function for withdrawing all tokens of some particular ERC20 contract from this contract.

     * @param _token address of the claimed ERC20 token.

     * @param _to address of the tokens receiver.

     */

    function claimErc20Tokens(address _token, address _to) internal {

        IERC20 token = IERC20(_token);

        uint256 balance = token.balanceOf(address(this));

        token.safeTransfer(_to, balance);

    }

}



// File: contracts/upgradeable_contracts/components/bridged/BridgedTokensRegistry.sol



pragma solidity 0.7.5;





/**

 * @title BridgedTokensRegistry

 * @dev Functionality for keeping track of registered bridged token pairs.

 */

contract BridgedTokensRegistry is EternalStorage {

    event NewTokenRegistered(address indexed nativeToken, address indexed bridgedToken);



    /**

     * @dev Retrieves address of the bridged token contract associated with a specific native token contract on the other side.

     * @param _nativeToken address of the native token contract on the other side.

     * @return address of the deployed bridged token contract.

     */

    function bridgedTokenAddress(address _nativeToken) public view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("homeTokenAddress", _nativeToken))];

    }



    /**

     * @dev Retrieves address of the native token contract associated with a specific bridged token contract.

     * @param _bridgedToken address of the created bridged token contract on this side.

     * @return address of the native token contract on the other side of the bridge.

     */

    function nativeTokenAddress(address _bridgedToken) public view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("foreignTokenAddress", _bridgedToken))];

    }



    /**

     * @dev Internal function for updating a pair of addresses for the bridged token.

     * @param _nativeToken address of the native token contract on the other side.

     * @param _bridgedToken address of the created bridged token contract on this side.

     */

    function _setTokenAddressPair(address _nativeToken, address _bridgedToken) internal {

        addressStorage[keccak256(abi.encodePacked("homeTokenAddress", _nativeToken))] = _bridgedToken;

        addressStorage[keccak256(abi.encodePacked("foreignTokenAddress", _bridgedToken))] = _nativeToken;



        emit NewTokenRegistered(_nativeToken, _bridgedToken);

    }

}



// File: contracts/upgradeable_contracts/components/native/NativeTokensRegistry.sol



pragma solidity 0.7.5;





/**

 * @title NativeTokensRegistry

 * @dev Functionality for keeping track of registered native tokens.

 */

contract NativeTokensRegistry is EternalStorage {

    /**

     * @dev Checks if for a given native token, the deployment of its bridged alternative was already acknowledged.

     * @param _token address of native token contract.

     * @return true, if bridged token was already deployed.

     */

    function isBridgedTokenDeployAcknowledged(address _token) public view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("ackDeploy", _token))];

    }



    /**

     * @dev Acknowledges the deployment of bridged token contract on the other side.

     * @param _token address of native token contract.

     */

    function _ackBridgedTokenDeploy(address _token) internal {

        if (!boolStorage[keccak256(abi.encodePacked("ackDeploy", _token))]) {

            boolStorage[keccak256(abi.encodePacked("ackDeploy", _token))] = true;

        }

    }

}



// File: contracts/upgradeable_contracts/components/native/MediatorBalanceStorage.sol



pragma solidity 0.7.5;







/**

 * @title MediatorBalanceStorage

 * @dev Functionality for storing expected mediator balance for native tokens.

 */

contract MediatorBalanceStorage is EternalStorage {

    /**

     * @dev Tells the expected token balance of the contract.

     * @param _token address of token contract.

     * @return the current tracked token balance of the contract.

     */

    function mediatorBalance(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("mediatorBalance", _token))];

    }



    /**

     * @dev Updates expected token balance of the contract.

     * @param _token address of token contract.

     * @param _balance the new token balance of the contract.

     */

    function _setMediatorBalance(address _token, uint256 _balance) internal {

        uintStorage[keccak256(abi.encodePacked("mediatorBalance", _token))] = _balance;

    }

}



// File: contracts/interfaces/IERC677.sol



pragma solidity 0.7.5;





interface IERC677 is IERC20 {

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);



    function transferAndCall(

        address to,

        uint256 value,

        bytes calldata data

    ) external returns (bool);



    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);



    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

}



// File: contracts/libraries/Bytes.sol



pragma solidity 0.7.5;



/**

 * @title Bytes

 * @dev Helper methods to transform bytes to other solidity types.

 */

library Bytes {

    /**

     * @dev Truncate bytes array if its size is more than 20 bytes.

     * NOTE: This function does not perform any checks on the received parameter.

     * Make sure that the _bytes argument has a correct length, not less than 20 bytes.

     * A case when _bytes has length less than 20 will lead to the undefined behaviour,

     * since assembly will read data from memory that is not related to the _bytes argument.

     * @param _bytes to be converted to address type

     * @return addr address included in the firsts 20 bytes of the bytes array in parameter.

     */

    function bytesToAddress(bytes memory _bytes) internal pure returns (address addr) {

        assembly {

            addr := mload(add(_bytes, 20))

        }

    }

}



// File: contracts/upgradeable_contracts/ReentrancyGuard.sol



pragma solidity 0.7.5;



contract ReentrancyGuard {

    function lock() internal view returns (bool res) {

        assembly {

            // Even though this is not the same as boolStorage[keccak256(abi.encodePacked("lock"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            res := sload(0x6168652c307c1e813ca11cfb3a601f1cf3b22452021a5052d8b05f1f1f8a3e92) // keccak256(abi.encodePacked("lock"))

        }

    }



    function setLock(bool _lock) internal {

        assembly {

            // Even though this is not the same as boolStorage[keccak256(abi.encodePacked("lock"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            sstore(0x6168652c307c1e813ca11cfb3a601f1cf3b22452021a5052d8b05f1f1f8a3e92, _lock) // keccak256(abi.encodePacked("lock"))

        }

    }

}



// File: contracts/upgradeable_contracts/Ownable.sol



pragma solidity 0.7.5;







/**

 * @title Ownable

 * @dev This contract has an owner address providing basic authorization control

 */

contract Ownable is EternalStorage {

    bytes4 internal constant UPGRADEABILITY_OWNER = 0x6fde8202; // upgradeabilityOwner()



    /**

     * @dev Event to show ownership has been transferred

     * @param previousOwner representing the address of the previous owner

     * @param newOwner representing the address of the new owner

     */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        _onlyOwner();

        _;

    }



    /**

     * @dev Internal function for reducing onlyOwner modifier bytecode overhead.

     */

    function _onlyOwner() internal view {

        require(msg.sender == owner());

    }



    /**

     * @dev Throws if called through proxy by any account other than contract itself or an upgradeability owner.

     */

    modifier onlyRelevantSender() {

        (bool isProxy, bytes memory returnData) =

            address(this).staticcall(abi.encodeWithSelector(UPGRADEABILITY_OWNER));

        require(

            !isProxy || // covers usage without calling through storage proxy

                (returnData.length == 32 && msg.sender == abi.decode(returnData, (address))) || // covers usage through regular proxy calls

                msg.sender == address(this) // covers calls through upgradeAndCall proxy method

        );

        _;

    }



    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked("owner"))



    /**

     * @dev Tells the address of the owner

     * @return the address of the owner

     */

    function owner() public view returns (address) {

        return addressStorage[OWNER];

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner the address to transfer ownership to.

     */

    function transferOwnership(address newOwner) external onlyOwner {

        _setOwner(newOwner);

    }



    /**

     * @dev Sets a new owner address

     */

    function _setOwner(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner(), newOwner);

        addressStorage[OWNER] = newOwner;

    }

}



// File: contracts/interfaces/IAMB.sol



pragma solidity 0.7.5;



interface IAMB {

    event UserRequestForAffirmation(bytes32 indexed messageId, bytes encodedData);

    event UserRequestForSignature(bytes32 indexed messageId, bytes encodedData);

    event AffirmationCompleted(

        address indexed sender,

        address indexed executor,

        bytes32 indexed messageId,

        bool status

    );

    event RelayedMessage(address indexed sender, address indexed executor, bytes32 indexed messageId, bool status);



    function messageSender() external view returns (address);



    function maxGasPerTx() external view returns (uint256);



    function transactionHash() external view returns (bytes32);



    function messageId() external view returns (bytes32);



    function messageSourceChainId() external view returns (bytes32);



    function messageCallStatus(bytes32 _messageId) external view returns (bool);



    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32);



    function failedMessageReceiver(bytes32 _messageId) external view returns (address);



    function failedMessageSender(bytes32 _messageId) external view returns (address);



    function requireToPassMessage(

        address _contract,

        bytes calldata _data,

        uint256 _gas

    ) external returns (bytes32);



    function requireToConfirmMessage(

        address _contract,

        bytes calldata _data,

        uint256 _gas

    ) external returns (bytes32);



    function sourceChainId() external view returns (uint256);



    function destinationChainId() external view returns (uint256);

}



// File: contracts/upgradeable_contracts/BasicAMBMediator.sol



pragma solidity 0.7.5;









/**

 * @title BasicAMBMediator

 * @dev Basic storage and methods needed by mediators to interact with AMB bridge.

 */

abstract contract BasicAMBMediator is Ownable {

    bytes32 internal constant BRIDGE_CONTRACT = 0x811bbb11e8899da471f0e69a3ed55090fc90215227fc5fb1cb0d6e962ea7b74f; // keccak256(abi.encodePacked("bridgeContract"))

    bytes32 internal constant MEDIATOR_CONTRACT = 0x98aa806e31e94a687a31c65769cb99670064dd7f5a87526da075c5fb4eab9880; // keccak256(abi.encodePacked("mediatorContract"))



    /**

     * @dev Throws if caller on the other side is not an associated mediator.

     */

    modifier onlyMediator {

        _onlyMediator();

        _;

    }



    /**

     * @dev Internal function for reducing onlyMediator modifier bytecode overhead.

     */

    function _onlyMediator() internal view {

        IAMB bridge = bridgeContract();

        require(msg.sender == address(bridge));

        require(bridge.messageSender() == mediatorContractOnOtherSide());

    }



    /**

     * @dev Sets the AMB bridge contract address. Only the owner can call this method.

     * @param _bridgeContract the address of the bridge contract.

     */

    function setBridgeContract(address _bridgeContract) external onlyOwner {

        _setBridgeContract(_bridgeContract);

    }



    /**

     * @dev Sets the mediator contract address from the other network. Only the owner can call this method.

     * @param _mediatorContract the address of the mediator contract.

     */

    function setMediatorContractOnOtherSide(address _mediatorContract) external onlyOwner {

        _setMediatorContractOnOtherSide(_mediatorContract);

    }



    /**

     * @dev Get the AMB interface for the bridge contract address

     * @return AMB interface for the bridge contract address

     */

    function bridgeContract() public view returns (IAMB) {

        return IAMB(addressStorage[BRIDGE_CONTRACT]);

    }



    /**

     * @dev Tells the mediator contract address from the other network.

     * @return the address of the mediator contract.

     */

    function mediatorContractOnOtherSide() public view virtual returns (address) {

        return addressStorage[MEDIATOR_CONTRACT];

    }



    /**

     * @dev Stores a valid AMB bridge contract address.

     * @param _bridgeContract the address of the bridge contract.

     */

    function _setBridgeContract(address _bridgeContract) internal {

        require(Address.isContract(_bridgeContract));

        addressStorage[BRIDGE_CONTRACT] = _bridgeContract;

    }



    /**

     * @dev Stores the mediator contract address from the other network.

     * @param _mediatorContract the address of the mediator contract.

     */

    function _setMediatorContractOnOtherSide(address _mediatorContract) internal {

        addressStorage[MEDIATOR_CONTRACT] = _mediatorContract;

    }



    /**

     * @dev Tells the id of the message originated on the other network.

     * @return the id of the message originated on the other network.

     */

    function messageId() internal view returns (bytes32) {

        return bridgeContract().messageId();

    }



    /**

     * @dev Tells the maximum gas limit that a message can use on its execution by the AMB bridge on the other network.

     * @return the maximum gas limit value.

     */

    function maxGasPerTx() internal view returns (uint256) {

        return bridgeContract().maxGasPerTx();

    }



    function _passMessage(bytes memory _data, bool _useOracleLane) internal virtual returns (bytes32);

}



// File: contracts/upgradeable_contracts/components/common/TokensRelayer.sol



pragma solidity 0.7.5;















/**

 * @title TokensRelayer

 * @dev Functionality for bridging multiple tokens to the other side of the bridge.

 */

abstract contract TokensRelayer is BasicAMBMediator, ReentrancyGuard {

    using SafeMath for uint256;

    using SafeERC20 for IERC677;



    /**

     * @dev ERC677 transfer callback function.

     * @param _from address of tokens sender.

     * @param _value amount of transferred tokens.

     * @param _data additional transfer data, can be used for passing alternative receiver address.

     */

    function onTokenTransfer(

        address _from,

        uint256 _value,

        bytes memory _data

    ) external returns (bool) {

        if (!lock()) {

            bytes memory data = new bytes(0);

            address receiver = _from;

            if (_data.length >= 20) {

                receiver = Bytes.bytesToAddress(_data);

                if (_data.length > 20) {

                    assembly {

                        let size := sub(mload(_data), 20)

                        data := add(_data, 20)

                        mstore(data, size)

                    }

                }

            }

            bridgeSpecificActionsOnTokenTransfer(msg.sender, _from, receiver, _value, data);

        }

        return true;

    }



    /**

     * @dev Initiate the bridge operation for some amount of tokens from msg.sender.

     * The user should first call Approve method of the ERC677 token.

     * @param token bridged token contract address.

     * @param _receiver address that will receive the native tokens on the other network.

     * @param _value amount of tokens to be transferred to the other network.

     */

    function relayTokens(

        IERC677 token,

        address _receiver,

        uint256 _value

    ) external {

        _relayTokens(token, _receiver, _value, new bytes(0));

    }



    /**

     * @dev Initiate the bridge operation for some amount of tokens from msg.sender to msg.sender on the other side.

     * The user should first call Approve method of the ERC677 token.

     * @param token bridged token contract address.

     * @param _value amount of tokens to be transferred to the other network.

     */

    function relayTokens(IERC677 token, uint256 _value) external {

        _relayTokens(token, msg.sender, _value, new bytes(0));

    }



    /**

     * @dev Initiate the bridge operation for some amount of tokens from msg.sender.

     * The user should first call Approve method of the ERC677 token.

     * @param token bridged token contract address.

     * @param _receiver address that will receive the native tokens on the other network.

     * @param _value amount of tokens to be transferred to the other network.

     * @param _data additional transfer data to be used on the other side.

     */

    function relayTokensAndCall(

        IERC677 token,

        address _receiver,

        uint256 _value,

        bytes memory _data

    ) external {

        _relayTokens(token, _receiver, _value, _data);

    }



    /**

     * @dev Validates that the token amount is inside the limits, calls transferFrom to transfer the tokens to the contract

     * and invokes the method to burn/lock the tokens and unlock/mint the tokens on the other network.

     * The user should first call Approve method of the ERC677 token.

     * @param token bridge token contract address.

     * @param _receiver address that will receive the native tokens on the other network.

     * @param _value amount of tokens to be transferred to the other network.

     * @param _data additional transfer data to be used on the other side.

     */

    function _relayTokens(

        IERC677 token,

        address _receiver,

        uint256 _value,

        bytes memory _data

    ) internal {

        // This lock is to prevent calling passMessage twice if a ERC677 token is used.

        // When transferFrom is called, after the transfer, the ERC677 token will call onTokenTransfer from this contract

        // which will call passMessage.

        require(!lock());



        uint256 balanceBefore = token.balanceOf(address(this));

        setLock(true);

        token.safeTransferFrom(msg.sender, address(this), _value);

        setLock(false);

        uint256 balanceDiff = token.balanceOf(address(this)).sub(balanceBefore);

        require(balanceDiff <= _value);

        bridgeSpecificActionsOnTokenTransfer(address(token), msg.sender, _receiver, balanceDiff, _data);

    }



    function bridgeSpecificActionsOnTokenTransfer(

        address _token,

        address _from,

        address _receiver,

        uint256 _value,

        bytes memory _data

    ) internal virtual;

}



// File: contracts/upgradeable_contracts/VersionableBridge.sol



pragma solidity 0.7.5;



interface VersionableBridge {

    function getBridgeInterfacesVersion()

        external

        pure

        returns (

            uint64 major,

            uint64 minor,

            uint64 patch

        );



    function getBridgeMode() external pure returns (bytes4);

}



// File: contracts/upgradeable_contracts/components/common/OmnibridgeInfo.sol



pragma solidity 0.7.5;





/**

 * @title OmnibridgeInfo

 * @dev Functionality for versioning Omnibridge mediator.

 */

contract OmnibridgeInfo is VersionableBridge {

    event TokensBridgingInitiated(

        address indexed token,

        address indexed sender,

        uint256 value,

        bytes32 indexed messageId

    );

    event TokensBridged(address indexed token, address indexed recipient, uint256 value, bytes32 indexed messageId);



    /**

     * @dev Tells the bridge interface version that this contract supports.

     * @return major value of the version

     * @return minor value of the version

     * @return patch value of the version

     */

    function getBridgeInterfacesVersion()

        external

        pure

        override

        returns (

            uint64 major,

            uint64 minor,

            uint64 patch

        )

    {

        // The patch version increased by 1 to reflect difference from

        // the original contract: minting of STAKE token is disabled

        return (3, 0, 1);

    }



    /**

     * @dev Tells the bridge mode that this contract supports.

     * @return _data 4 bytes representing the bridge mode

     */

    function getBridgeMode() external pure override returns (bytes4 _data) {

        return 0xb1516c26; // bytes4(keccak256(abi.encodePacked("multi-erc-to-erc-amb")))

    }

}



// File: contracts/upgradeable_contracts/components/common/TokensBridgeLimits.sol



pragma solidity 0.7.5;









/**

 * @title TokensBridgeLimits

 * @dev Functionality for keeping track of bridging limits for multiple tokens.

 */

contract TokensBridgeLimits is EternalStorage, Ownable {

    using SafeMath for uint256;



    // token == 0x00..00 represents default limits (assuming decimals == 18) for all newly created tokens

    event DailyLimitChanged(address indexed token, uint256 newLimit);

    event ExecutionDailyLimitChanged(address indexed token, uint256 newLimit);



    /**

     * @dev Checks if specified token was already bridged at least once.

     * @param _token address of the token contract.

     * @return true, if token address is address(0) or token was already bridged.

     */

    function isTokenRegistered(address _token) public view returns (bool) {

        return minPerTx(_token) > 0;

    }



    /**

     * @dev Retrieves the total spent amount for particular token during specific day.

     * @param _token address of the token contract.

     * @param _day day number for which spent amount if requested.

     * @return amount of tokens sent through the bridge to the other side.

     */

    function totalSpentPerDay(address _token, uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _token, _day))];

    }



    /**

     * @dev Retrieves the total executed amount for particular token during specific day.

     * @param _token address of the token contract.

     * @param _day day number for which spent amount if requested.

     * @return amount of tokens received from the bridge from the other side.

     */

    function totalExecutedPerDay(address _token, uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _token, _day))];

    }



    /**

     * @dev Retrieves current daily limit for a particular token contract.

     * @param _token address of the token contract.

     * @return daily limit on tokens that can be sent through the bridge per day.

     */

    function dailyLimit(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("dailyLimit", _token))];

    }



    /**

     * @dev Retrieves current execution daily limit for a particular token contract.

     * @param _token address of the token contract.

     * @return daily limit on tokens that can be received from the bridge on the other side per day.

     */

    function executionDailyLimit(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("executionDailyLimit", _token))];

    }



    /**

     * @dev Retrieves current maximum amount of tokens per one transfer for a particular token contract.

     * @param _token address of the token contract.

     * @return maximum amount on tokens that can be sent through the bridge in one transfer.

     */

    function maxPerTx(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("maxPerTx", _token))];

    }



    /**

     * @dev Retrieves current maximum execution amount of tokens per one transfer for a particular token contract.

     * @param _token address of the token contract.

     * @return maximum amount on tokens that can received from the bridge on the other side in one transaction.

     */

    function executionMaxPerTx(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("executionMaxPerTx", _token))];

    }



    /**

     * @dev Retrieves current minimum amount of tokens per one transfer for a particular token contract.

     * @param _token address of the token contract.

     * @return minimum amount on tokens that can be sent through the bridge in one transfer.

     */

    function minPerTx(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("minPerTx", _token))];

    }



    /**

     * @dev Checks that bridged amount of tokens conforms to the configured limits.

     * @param _token address of the token contract.

     * @param _amount amount of bridge tokens.

     * @return true, if specified amount can be bridged.

     */

    function withinLimit(address _token, uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalSpentPerDay(_token, getCurrentDay()).add(_amount);

        return

            dailyLimit(address(0)) > 0 &&

            dailyLimit(_token) >= nextLimit &&

            _amount <= maxPerTx(_token) &&

            _amount >= minPerTx(_token);

    }



    /**

     * @dev Checks that bridged amount of tokens conforms to the configured execution limits.

     * @param _token address of the token contract.

     * @param _amount amount of bridge tokens.

     * @return true, if specified amount can be processed and executed.

     */

    function withinExecutionLimit(address _token, uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalExecutedPerDay(_token, getCurrentDay()).add(_amount);

        return

            executionDailyLimit(address(0)) > 0 &&

            executionDailyLimit(_token) >= nextLimit &&

            _amount <= executionMaxPerTx(_token);

    }



    /**

     * @dev Returns current day number.

     * @return day number.

     */

    function getCurrentDay() public view returns (uint256) {

        // solhint-disable-next-line not-rely-on-time

        return block.timestamp / 1 days;

    }



    /**

     * @dev Updates daily limit for the particular token. Only owner can call this method.

     * @param _token address of the token contract, or address(0) for configuring the efault limit.

     * @param _dailyLimit daily allowed amount of bridged tokens, should be greater than maxPerTx.

     * 0 value is also allowed, will stop the bridge operations in outgoing direction.

     */

    function setDailyLimit(address _token, uint256 _dailyLimit) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_dailyLimit > maxPerTx(_token) || _dailyLimit == 0);

        uintStorage[keccak256(abi.encodePacked("dailyLimit", _token))] = _dailyLimit;

        emit DailyLimitChanged(_token, _dailyLimit);

    }



    /**

     * @dev Updates execution daily limit for the particular token. Only owner can call this method.

     * @param _token address of the token contract, or address(0) for configuring the default limit.

     * @param _dailyLimit daily allowed amount of executed tokens, should be greater than executionMaxPerTx.

     * 0 value is also allowed, will stop the bridge operations in incoming direction.

     */

    function setExecutionDailyLimit(address _token, uint256 _dailyLimit) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_dailyLimit > executionMaxPerTx(_token) || _dailyLimit == 0);

        uintStorage[keccak256(abi.encodePacked("executionDailyLimit", _token))] = _dailyLimit;

        emit ExecutionDailyLimitChanged(_token, _dailyLimit);

    }



    /**

     * @dev Updates execution maximum per transaction for the particular token. Only owner can call this method.

     * @param _token address of the token contract, or address(0) for configuring the default limit.

     * @param _maxPerTx maximum amount of executed tokens per one transaction, should be less than executionDailyLimit.

     * 0 value is also allowed, will stop the bridge operations in incoming direction.

     */

    function setExecutionMaxPerTx(address _token, uint256 _maxPerTx) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_maxPerTx == 0 || (_maxPerTx > 0 && _maxPerTx < executionDailyLimit(_token)));

        uintStorage[keccak256(abi.encodePacked("executionMaxPerTx", _token))] = _maxPerTx;

    }



    /**

     * @dev Updates maximum per transaction for the particular token. Only owner can call this method.

     * @param _token address of the token contract, or address(0) for configuring the default limit.

     * @param _maxPerTx maximum amount of tokens per one transaction, should be less than dailyLimit, greater than minPerTx.

     * 0 value is also allowed, will stop the bridge operations in outgoing direction.

     */

    function setMaxPerTx(address _token, uint256 _maxPerTx) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_maxPerTx == 0 || (_maxPerTx > minPerTx(_token) && _maxPerTx < dailyLimit(_token)));

        uintStorage[keccak256(abi.encodePacked("maxPerTx", _token))] = _maxPerTx;

    }



    /**

     * @dev Updates minimum per transaction for the particular token. Only owner can call this method.

     * @param _token address of the token contract, or address(0) for configuring the default limit.

     * @param _minPerTx minimum amount of tokens per one transaction, should be less than maxPerTx and dailyLimit.

     */

    function setMinPerTx(address _token, uint256 _minPerTx) external onlyOwner {

        require(isTokenRegistered(_token));

        require(_minPerTx > 0 && _minPerTx < dailyLimit(_token) && _minPerTx < maxPerTx(_token));

        uintStorage[keccak256(abi.encodePacked("minPerTx", _token))] = _minPerTx;

    }



    /**

     * @dev Retrieves maximum available bridge amount per one transaction taking into account maxPerTx() and dailyLimit() parameters.

     * @param _token address of the token contract, or address(0) for the default limit.

     * @return minimum of maxPerTx parameter and remaining daily quota.

     */

    function maxAvailablePerTx(address _token) public view returns (uint256) {

        uint256 _maxPerTx = maxPerTx(_token);

        uint256 _dailyLimit = dailyLimit(_token);

        uint256 _spent = totalSpentPerDay(_token, getCurrentDay());

        uint256 _remainingOutOfDaily = _dailyLimit > _spent ? _dailyLimit - _spent : 0;

        return _maxPerTx < _remainingOutOfDaily ? _maxPerTx : _remainingOutOfDaily;

    }



    /**

     * @dev Internal function for adding spent amount for some token.

     * @param _token address of the token contract.

     * @param _day day number, when tokens are processed.

     * @param _value amount of bridge tokens.

     */

    function addTotalSpentPerDay(

        address _token,

        uint256 _day,

        uint256 _value

    ) internal {

        uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _token, _day))] = totalSpentPerDay(_token, _day).add(

            _value

        );

    }



    /**

     * @dev Internal function for adding executed amount for some token.

     * @param _token address of the token contract.

     * @param _day day number, when tokens are processed.

     * @param _value amount of bridge tokens.

     */

    function addTotalExecutedPerDay(

        address _token,

        uint256 _day,

        uint256 _value

    ) internal {

        uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _token, _day))] = totalExecutedPerDay(

            _token,

            _day

        )

            .add(_value);

    }



    /**

     * @dev Internal function for initializing limits for some token.

     * @param _token address of the token contract.

     * @param _limits [ 0 = dailyLimit, 1 = maxPerTx, 2 = minPerTx ].

     */

    function _setLimits(address _token, uint256[3] memory _limits) internal {

        require(

            _limits[2] > 0 && // minPerTx > 0

                _limits[1] > _limits[2] && // maxPerTx > minPerTx

                _limits[0] > _limits[1] // dailyLimit > maxPerTx

        );



        uintStorage[keccak256(abi.encodePacked("dailyLimit", _token))] = _limits[0];

        uintStorage[keccak256(abi.encodePacked("maxPerTx", _token))] = _limits[1];

        uintStorage[keccak256(abi.encodePacked("minPerTx", _token))] = _limits[2];



        emit DailyLimitChanged(_token, _limits[0]);

    }



    /**

     * @dev Internal function for initializing execution limits for some token.

     * @param _token address of the token contract.

     * @param _limits [ 0 = executionDailyLimit, 1 = executionMaxPerTx ].

     */

    function _setExecutionLimits(address _token, uint256[2] memory _limits) internal {

        require(_limits[1] < _limits[0]); // foreignMaxPerTx < foreignDailyLimit



        uintStorage[keccak256(abi.encodePacked("executionDailyLimit", _token))] = _limits[0];

        uintStorage[keccak256(abi.encodePacked("executionMaxPerTx", _token))] = _limits[1];



        emit ExecutionDailyLimitChanged(_token, _limits[0]);

    }



    /**

     * @dev Internal function for initializing limits for some token relative to its decimals parameter.

     * @param _token address of the token contract.

     * @param _decimals token decimals parameter.

     */

    function _initializeTokenBridgeLimits(address _token, uint256 _decimals) internal {

        uint256 factor;

        if (_decimals < 18) {

            factor = 10**(18 - _decimals);



            uint256 _minPerTx = minPerTx(address(0)).div(factor);

            uint256 _maxPerTx = maxPerTx(address(0)).div(factor);

            uint256 _dailyLimit = dailyLimit(address(0)).div(factor);

            uint256 _executionMaxPerTx = executionMaxPerTx(address(0)).div(factor);

            uint256 _executionDailyLimit = executionDailyLimit(address(0)).div(factor);



            // such situation can happen when calculated limits relative to the token decimals are too low

            // e.g. minPerTx(address(0)) == 10 ** 14, _decimals == 3. _minPerTx happens to be 0, which is not allowed.

            // in this case, limits are raised to the default values

            if (_minPerTx == 0) {

                // Numbers 1, 100, 10000 are chosen in a semi-random way,

                // so that any token with small decimals can still be bridged in some amounts.

                // It is possible to override limits for the particular token later if needed.

                _minPerTx = 1;

                if (_maxPerTx <= _minPerTx) {

                    _maxPerTx = 100;

                    _executionMaxPerTx = 100;

                    if (_dailyLimit <= _maxPerTx || _executionDailyLimit <= _executionMaxPerTx) {

                        _dailyLimit = 10000;

                        _executionDailyLimit = 10000;

                    }

                }

            }

            _setLimits(_token, [_dailyLimit, _maxPerTx, _minPerTx]);

            _setExecutionLimits(_token, [_executionDailyLimit, _executionMaxPerTx]);

        } else {

            factor = 10**(_decimals - 18);

            _setLimits(

                _token,

                [dailyLimit(address(0)).mul(factor), maxPerTx(address(0)).mul(factor), minPerTx(address(0)).mul(factor)]

            );

            _setExecutionLimits(

                _token,

                [executionDailyLimit(address(0)).mul(factor), executionMaxPerTx(address(0)).mul(factor)]

            );

        }

    }

}



// File: contracts/upgradeable_contracts/components/common/BridgeOperationsStorage.sol



pragma solidity 0.7.5;





/**

 * @title BridgeOperationsStorage

 * @dev Functionality for storing processed bridged operations.

 */

abstract contract BridgeOperationsStorage is EternalStorage {

    /**

     * @dev Stores the bridged token of a message sent to the AMB bridge.

     * @param _messageId of the message sent to the bridge.

     * @param _token bridged token address.

     */

    function setMessageToken(bytes32 _messageId, address _token) internal {

        addressStorage[keccak256(abi.encodePacked("messageToken", _messageId))] = _token;

    }



    /**

     * @dev Tells the bridged token address of a message sent to the AMB bridge.

     * @return address of a token contract.

     */

    function messageToken(bytes32 _messageId) internal view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("messageToken", _messageId))];

    }



    /**

     * @dev Stores the value of a message sent to the AMB bridge.

     * @param _messageId of the message sent to the bridge.

     * @param _value amount of tokens bridged.

     */

    function setMessageValue(bytes32 _messageId, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("messageValue", _messageId))] = _value;

    }



    /**

     * @dev Tells the amount of tokens of a message sent to the AMB bridge.

     * @return value representing amount of tokens.

     */

    function messageValue(bytes32 _messageId) internal view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("messageValue", _messageId))];

    }



    /**

     * @dev Stores the receiver of a message sent to the AMB bridge.

     * @param _messageId of the message sent to the bridge.

     * @param _recipient receiver of the tokens bridged.

     */

    function setMessageRecipient(bytes32 _messageId, address _recipient) internal {

        addressStorage[keccak256(abi.encodePacked("messageRecipient", _messageId))] = _recipient;

    }



    /**

     * @dev Tells the receiver of a message sent to the AMB bridge.

     * @return address of the receiver.

     */

    function messageRecipient(bytes32 _messageId) internal view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("messageRecipient", _messageId))];

    }

}



// File: contracts/upgradeable_contracts/components/common/FailedMessagesProcessor.sol



pragma solidity 0.7.5;







/**

 * @title FailedMessagesProcessor

 * @dev Functionality for fixing failed bridging operations.

 */

abstract contract FailedMessagesProcessor is BasicAMBMediator, BridgeOperationsStorage {

    event FailedMessageFixed(bytes32 indexed messageId, address token, address recipient, uint256 value);



    /**

     * @dev Method to be called when a bridged message execution failed. It will generate a new message requesting to

     * fix/roll back the transferred assets on the other network.

     * @param _messageId id of the message which execution failed.

     */

    function requestFailedMessageFix(bytes32 _messageId) external {

        IAMB bridge = bridgeContract();

        require(!bridge.messageCallStatus(_messageId));

        require(bridge.failedMessageReceiver(_messageId) == address(this));

        require(bridge.failedMessageSender(_messageId) == mediatorContractOnOtherSide());



        bytes4 methodSelector = this.fixFailedMessage.selector;

        bytes memory data = abi.encodeWithSelector(methodSelector, _messageId);

        _passMessage(data, true);

    }



    /**

     * @dev Handles the request to fix transferred assets which bridged message execution failed on the other network.

     * It uses the information stored by passMessage method when the assets were initially transferred

     * @param _messageId id of the message which execution failed on the other network.

     */

    function fixFailedMessage(bytes32 _messageId) public onlyMediator {

        require(!messageFixed(_messageId));



        address token = messageToken(_messageId);

        address recipient = messageRecipient(_messageId);

        uint256 value = messageValue(_messageId);

        setMessageFixed(_messageId);

        executeActionOnFixedTokens(token, recipient, value);

        emit FailedMessageFixed(_messageId, token, recipient, value);

    }



    /**

     * @dev Tells if a message sent to the AMB bridge has been fixed.

     * @return bool indicating the status of the message.

     */

    function messageFixed(bytes32 _messageId) public view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("messageFixed", _messageId))];

    }



    /**

     * @dev Sets that the message sent to the AMB bridge has been fixed.

     * @param _messageId of the message sent to the bridge.

     */

    function setMessageFixed(bytes32 _messageId) internal {

        boolStorage[keccak256(abi.encodePacked("messageFixed", _messageId))] = true;

    }



    function executeActionOnFixedTokens(

        address _token,

        address _recipient,

        uint256 _value

    ) internal virtual;

}



// File: contracts/upgradeability/Proxy.sol



pragma solidity 0.7.5;



/**

 * @title Proxy

 * @dev Gives the possibility to delegate any call to a foreign implementation.

 */

abstract contract Proxy {

    /**

     * @dev Tells the address of the implementation where every call will be delegated.

     * @return address of the implementation to which it will be delegated

     */

    function implementation() public view virtual returns (address);



    /**

     * @dev Fallback function allowing to perform a delegatecall to the given implementation.

     * This function will return whatever the implementation call returns

     */

    fallback() external payable {

        // solhint-disable-previous-line no-complex-fallback

        address _impl = implementation();

        require(_impl != address(0));

        assembly {

            /*

                0x40 is the "free memory slot", meaning a pointer to next slot of empty memory. mload(0x40)

                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty

                memory. It's needed because we're going to write the return data of delegatecall to the

                free memory slot.

            */

            let ptr := mload(0x40)

            /*

                `calldatacopy` is copy calldatasize bytes from calldata

                First argument is the destination to which data is copied(ptr)

                Second argument specifies the start position of the copied data.

                    Since calldata is sort of its own unique location in memory,

                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.

                    That's always going to be the zeroth byte of the function selector.

                Third argument, calldatasize, specifies how much data will be copied.

                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)

            */

            calldatacopy(ptr, 0, calldatasize())

            /*

                delegatecall params explained:

                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives

                    us the amount of gas still available to execution



                _impl: address of the contract to delegate to



                ptr: to pass copied data



                calldatasize: loads the size of `bytes memory data`, same as msg.data.length



                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,

                        these are set to 0, 0 so the output data will not be written to memory. The output

                        data will be read using `returndatasize` and `returdatacopy` instead.



                result: This will be 0 if the call fails and 1 if it succeeds

            */

            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)

            /*



            */

            /*

                ptr current points to the value stored at 0x40,

                because we assigned it like ptr := mload(0x40).

                Because we use 0x40 as a free memory pointer,

                we want to make sure that the next time we want to allocate memory,

                we aren't overwriting anything important.

                So, by adding ptr and returndatasize,

                we get a memory location beyond the end of the data we will be copying to ptr.

                We place this in at 0x40, and any reads from 0x40 will now read from free memory

            */

            mstore(0x40, add(ptr, returndatasize()))

            /*

                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the

                    slot it will copy to, 0 means copy from the beginning of the return data, and size is

                    the amount of data to copy.

                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall

            */

            returndatacopy(ptr, 0, returndatasize())



            /*

                if `result` is 0, revert.

                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was

                copied to `ptr` from the delegatecall return data

            */

            switch result

                case 0 {

                    revert(ptr, returndatasize())

                }

                default {

                    return(ptr, returndatasize())

                }

        }

    }

}



// File: contracts/upgradeable_contracts/modules/factory/TokenProxy.sol



pragma solidity 0.7.5;





interface IPermittableTokenVersion {

    function version() external pure returns (string memory);

}



/**

 * @title TokenProxy

 * @dev Helps to reduces the size of the deployed bytecode for automatically created tokens, by using a proxy contract.

 */

contract TokenProxy is Proxy {

    // storage layout is copied from PermittableToken.sol

    string internal name;

    string internal symbol;

    uint8 internal decimals;

    mapping(address => uint256) internal balances;

    uint256 internal totalSupply;

    mapping(address => mapping(address => uint256)) internal allowed;

    address internal owner;

    bool internal mintingFinished;

    address internal bridgeContractAddr;

    // string public constant version = "1";

    bytes32 internal DOMAIN_SEPARATOR;

    // bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;

    mapping(address => uint256) internal nonces;

    mapping(address => mapping(address => uint256)) internal expirations;



    /**

     * @dev Creates a non-upgradeable token proxy for PermitableToken.sol, initializes its eternalStorage.

     * @param _tokenImage address of the token image used for mirroring all functions.

     * @param _name token name.

     * @param _symbol token symbol.

     * @param _decimals token decimals.

     * @param _chainId chain id for current network.

     * @param _owner address of the owner for this contract.

     */

    constructor(

        address _tokenImage,

        string memory _name,

        string memory _symbol,

        uint8 _decimals,

        uint256 _chainId,

        address _owner

    ) {

        string memory version = IPermittableTokenVersion(_tokenImage).version();



        assembly {

            // EIP 1967

            // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)

            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _tokenImage)

        }

        name = _name;

        symbol = _symbol;

        decimals = _decimals;

        owner = _owner; // _owner == HomeOmnibridge/ForeignOmnibridge mediator

        bridgeContractAddr = _owner;

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),

                keccak256(bytes(_name)),

                keccak256(bytes(version)),

                _chainId,

                address(this)

            )

        );

    }



    /**

     * @dev Retrieves the implementation contract address, mirrored token image.

     * @return impl token image address.

     */

    function implementation() public view override returns (address impl) {

        assembly {

            impl := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)

        }

    }

}



// File: contracts/upgradeable_contracts/modules/OwnableModule.sol



pragma solidity 0.7.5;





/**

 * @title OwnableModule

 * @dev Common functionality for multi-token extension non-upgradeable module.

 */

contract OwnableModule {

    address public owner;



    /**

     * @dev Initializes this contract.

     * @param _owner address of the owner that is allowed to perform additional actions on the particular module.

     */

    constructor(address _owner) {

        owner = _owner;

    }



    /**

     * @dev Throws if sender is not the owner of this contract.

     */

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    /**

     * @dev Changes the owner of this contract.

     * @param _newOwner address of the new owner.

     */

    function transferOwnership(address _newOwner) external onlyOwner {

        owner = _newOwner;

    }

}



// File: contracts/upgradeable_contracts/modules/factory/TokenFactory.sol



pragma solidity 0.7.5;







/**

 * @title TokenFactory

 * @dev Factory contract for deployment of new TokenProxy contracts.

 */

contract TokenFactory is OwnableModule {

    address public tokenImage;



    /**

     * @dev Initializes this contract

     * @param _owner of this factory contract.

     * @param _tokenImage address of the token image contract that should be used for creation of new tokens.

     */

    constructor(address _owner, address _tokenImage) OwnableModule(_owner) {

        tokenImage = _tokenImage;

    }



    /**

     * @dev Updates the address of the used token image contract.

     * Only owner can call this method.

     * @param _tokenImage address of the new token image used for further deployments.

     */

    function setTokenImage(address _tokenImage) external onlyOwner {

        require(Address.isContract(_tokenImage));

        tokenImage = _tokenImage;

    }



    /**

     * @dev Deploys a new TokenProxy contract, using saved token image contract as a template.

     * @param _name deployed token name.

     * @param _symbol deployed token symbol.

     * @param _decimals deployed token decimals.

     * @param _chainId chain id of the current environment.

     * @return address of a newly created contract.

     */

    function deploy(

        string calldata _name,

        string calldata _symbol,

        uint8 _decimals,

        uint256 _chainId

    ) external returns (address) {

        return address(new TokenProxy(tokenImage, _name, _symbol, _decimals, _chainId, msg.sender));

    }

}



// File: contracts/upgradeable_contracts/modules/factory/TokenFactoryConnector.sol



pragma solidity 0.7.5;









/**

 * @title TokenFactoryConnector

 * @dev Connectivity functionality for working with TokenFactory contract.

 */

contract TokenFactoryConnector is Ownable {

    bytes32 internal constant TOKEN_FACTORY_CONTRACT =

        0x269c5905f777ee6391c7a361d17039a7d62f52ba9fffeb98c5ade342705731a3; // keccak256(abi.encodePacked("tokenFactoryContract"))



    /**

     * @dev Updates an address of the used TokenFactory contract used for creating new tokens.

     * @param _tokenFactory address of TokenFactory contract.

     */

    function setTokenFactory(address _tokenFactory) external onlyOwner {

        _setTokenFactory(_tokenFactory);

    }



    /**

     * @dev Retrieves an address of the token factory contract.

     * @return address of the TokenFactory contract.

     */

    function tokenFactory() public view returns (TokenFactory) {

        return TokenFactory(addressStorage[TOKEN_FACTORY_CONTRACT]);

    }



    /**

     * @dev Internal function for updating an address of the token factory contract.

     * @param _tokenFactory address of the deployed TokenFactory contract.

     */

    function _setTokenFactory(address _tokenFactory) internal {

        require(Address.isContract(_tokenFactory));

        addressStorage[TOKEN_FACTORY_CONTRACT] = _tokenFactory;

    }

}



// File: contracts/interfaces/IBurnableMintableERC677Token.sol



pragma solidity 0.7.5;





interface IBurnableMintableERC677Token is IERC677 {

    function mint(address _to, uint256 _amount) external returns (bool);



    function burn(uint256 _value) external;



    function claimTokens(address _token, address _to) external;

}



// File: contracts/interfaces/IERC20Metadata.sol



pragma solidity 0.7.5;



interface IERC20Metadata {

    function name() external view returns (string memory);



    function symbol() external view returns (string memory);



    function decimals() external view returns (uint8);

}



// File: contracts/interfaces/IERC20Receiver.sol



pragma solidity 0.7.5;



interface IERC20Receiver {

    function onTokenBridged(

        address token,

        uint256 value,

        bytes calldata data

    ) external;

}



// File: contracts/libraries/TokenReader.sol



pragma solidity 0.7.5;



// solhint-disable

interface ITokenDetails {

    function name() external view;

    function NAME() external view;

    function symbol() external view;

    function SYMBOL() external view;

    function decimals() external view;

    function DECIMALS() external view;

}

// solhint-enable



/**

 * @title TokenReader

 * @dev Helper methods for reading name/symbol/decimals parameters from ERC20 token contracts.

 */

library TokenReader {

    /**

     * @dev Reads the name property of the provided token.

     * Either name() or NAME() method is used.

     * Both, string and bytes32 types are supported.

     * @param _token address of the token contract.

     * @return token name as a string or an empty string if none of the methods succeeded.

     */

    function readName(address _token) internal view returns (string memory) {

        (bool status, bytes memory data) = _token.staticcall(abi.encodeWithSelector(ITokenDetails.name.selector));

        if (!status) {

            (status, data) = _token.staticcall(abi.encodeWithSelector(ITokenDetails.NAME.selector));

            if (!status) {

                return "";

            }

        }

        return _convertToString(data);

    }



    /**

     * @dev Reads the symbol property of the provided token.

     * Either symbol() or SYMBOL() method is used.

     * Both, string and bytes32 types are supported.

     * @param _token address of the token contract.

     * @return token symbol as a string or an empty string if none of the methods succeeded.

     */

    function readSymbol(address _token) internal view returns (string memory) {

        (bool status, bytes memory data) = _token.staticcall(abi.encodeWithSelector(ITokenDetails.symbol.selector));

        if (!status) {

            (status, data) = _token.staticcall(abi.encodeWithSelector(ITokenDetails.SYMBOL.selector));

            if (!status) {

                return "";

            }

        }

        return _convertToString(data);

    }



    /**

     * @dev Reads the decimals property of the provided token.

     * Either decimals() or DECIMALS() method is used.

     * @param _token address of the token contract.

     * @return token decimals or 0 if none of the methods succeeded.

     */

    function readDecimals(address _token) internal view returns (uint8) {

        (bool status, bytes memory data) = _token.staticcall(abi.encodeWithSelector(ITokenDetails.decimals.selector));

        if (!status) {

            (status, data) = _token.staticcall(abi.encodeWithSelector(ITokenDetails.DECIMALS.selector));

            if (!status) {

                return 0;

            }

        }

        return abi.decode(data, (uint8));

    }



    /**

     * @dev Internal function for converting returned value of name()/symbol() from bytes32/string to string.

     * @param returnData data returned by the token contract.

     * @return string with value obtained from returnData.

     */

    function _convertToString(bytes memory returnData) private pure returns (string memory) {

        if (returnData.length > 32) {

            return abi.decode(returnData, (string));

        } else if (returnData.length == 32) {

            bytes32 data = abi.decode(returnData, (bytes32));

            string memory res = new string(32);

            assembly {

                let len := 0

                mstore(add(res, 32), data) // save value in result string



                // solhint-disable

                for { } gt(data, 0) { len := add(len, 1) } { // until string is empty

                    data := shl(8, data) // shift left by one symbol

                }

                // solhint-enable

                mstore(res, len) // save result string length

            }

            return res;

        } else {

            return "";

        }

    }

}



// File: contracts/libraries/SafeMint.sol



pragma solidity 0.7.5;





/**

 * @title SafeMint

 * @dev Wrapper around the mint() function in all mintable tokens that verifies the return value.

 */

library SafeMint {

    /**

     * @dev Wrapper around IBurnableMintableERC677Token.mint() that verifies that output value is true.

     * @param _token token contract.

     * @param _to address of the tokens receiver.

     * @param _value amount of tokens to mint.

     */

    function safeMint(

        IBurnableMintableERC677Token _token,

        address _to,

        uint256 _value

    ) internal {

        require(_token.mint(_to, _value));

    }

}



// File: contracts/upgradeable_contracts/BasicOmnibridge.sol



pragma solidity 0.7.5;





































/**

 * @title BasicOmnibridge

 * @dev Common functionality for multi-token mediator intended to work on top of AMB bridge.

 */

abstract contract BasicOmnibridge is

    Initializable,

    Upgradeable,

    Claimable,

    OmnibridgeInfo,

    TokensRelayer,

    FailedMessagesProcessor,

    BridgedTokensRegistry,

    NativeTokensRegistry,

    MediatorBalanceStorage,

    TokenFactoryConnector,

    TokensBridgeLimits

{

    using SafeERC20 for IERC677;

    using SafeMint for IBurnableMintableERC677Token;

    using SafeMath for uint256;



    // Workaround for storing variable up-to-32 bytes suffix

    uint256 private immutable SUFFIX_SIZE;

    bytes32 private immutable SUFFIX;



    // Since contract is intended to be deployed under EternalStorageProxy, only constant and immutable variables can be set here

    constructor(string memory _suffix) {

        require(bytes(_suffix).length <= 32);

        bytes32 suffix;

        assembly {

            suffix := mload(add(_suffix, 32))

        }

        SUFFIX = suffix;

        SUFFIX_SIZE = bytes(_suffix).length;

    }



    /**

     * @dev Handles the bridged tokens for the first time, includes deployment of new TokenProxy contract.

     * Checks that the value is inside the execution limits and invokes the Mint or Unlock accordingly.

     * @param _token address of the native ERC20/ERC677 token on the other side.

     * @param _name name of the native token, name suffix will be appended, if empty, symbol will be used instead.

     * @param _symbol symbol of the bridged token, if empty, name will be used instead.

     * @param _decimals decimals of the bridge foreign token.

     * @param _recipient address that will receive the tokens.

     * @param _value amount of tokens to be received.

     */

    function deployAndHandleBridgedTokens(

        address _token,

        string calldata _name,

        string calldata _symbol,

        uint8 _decimals,

        address _recipient,

        uint256 _value

    ) external onlyMediator {

        address bridgedToken = _getBridgedTokenOrDeploy(_token, _name, _symbol, _decimals);



        _handleTokens(bridgedToken, false, _recipient, _value);

    }



    /**

     * @dev Handles the bridged tokens for the first time, includes deployment of new TokenProxy contract.

     * Executes a callback on the receiver.

     * Checks that the value is inside the execution limits and invokes the Mint accordingly.

     * @param _token address of the native ERC20/ERC677 token on the other side.

     * @param _name name of the native token, name suffix will be appended, if empty, symbol will be used instead.

     * @param _symbol symbol of the bridged token, if empty, name will be used instead.

     * @param _decimals decimals of the bridge foreign token.

     * @param _recipient address that will receive the tokens.

     * @param _value amount of tokens to be received.

     * @param _data additional data passed from the other chain.

     */

    function deployAndHandleBridgedTokensAndCall(

        address _token,

        string calldata _name,

        string calldata _symbol,

        uint8 _decimals,

        address _recipient,

        uint256 _value,

        bytes calldata _data

    ) external onlyMediator {

        address bridgedToken = _getBridgedTokenOrDeploy(_token, _name, _symbol, _decimals);



        _handleTokens(bridgedToken, false, _recipient, _value);



        _receiverCallback(_recipient, bridgedToken, _value, _data);

    }



    /**

     * @dev Handles the bridged tokens for the already registered token pair.

     * Checks that the value is inside the execution limits and invokes the Mint accordingly.

     * @param _token address of the native ERC20/ERC677 token on the other side.

     * @param _recipient address that will receive the tokens.

     * @param _value amount of tokens to be received.

     */

    function handleBridgedTokens(

        address _token,

        address _recipient,

        uint256 _value

    ) external onlyMediator {

        address token = bridgedTokenAddress(_token);



        require(isTokenRegistered(token));



        _handleTokens(token, false, _recipient, _value);

    }



    /**

     * @dev Handles the bridged tokens for the already registered token pair.

     * Checks that the value is inside the execution limits and invokes the Unlock accordingly.

     * Executes a callback on the receiver.

     * @param _token address of the native ERC20/ERC677 token on the other side.

     * @param _recipient address that will receive the tokens.

     * @param _value amount of tokens to be received.

     * @param _data additional transfer data passed from the other side.

     */

    function handleBridgedTokensAndCall(

        address _token,

        address _recipient,

        uint256 _value,

        bytes memory _data

    ) external onlyMediator {

        address token = bridgedTokenAddress(_token);



        require(isTokenRegistered(token));



        _handleTokens(token, false, _recipient, _value);



        _receiverCallback(_recipient, token, _value, _data);

    }



    /**

     * @dev Handles the bridged tokens that are native to this chain.

     * Checks that the value is inside the execution limits and invokes the Unlock accordingly.

     * @param _token native ERC20 token.

     * @param _recipient address that will receive the tokens.

     * @param _value amount of tokens to be received.

     */

    function handleNativeTokens(

        address _token,

        address _recipient,

        uint256 _value

    ) external onlyMediator {

        _ackBridgedTokenDeploy(_token);



        _handleTokens(_token, true, _recipient, _value);

    }



    /**

     * @dev Handles the bridged tokens that are native to this chain.

     * Checks that the value is inside the execution limits and invokes the Unlock accordingly.

     * Executes a callback on the receiver.

     * @param _token native ERC20 token.

     * @param _recipient address that will receive the tokens.

     * @param _value amount of tokens to be received.

     * @param _data additional transfer data passed from the other side.

     */

    function handleNativeTokensAndCall(

        address _token,

        address _recipient,

        uint256 _value,

        bytes memory _data

    ) external onlyMediator {

        _ackBridgedTokenDeploy(_token);



        _handleTokens(_token, true, _recipient, _value);



        _receiverCallback(_recipient, _token, _value, _data);

    }



    /**

     * @dev Checks if a given token is a bridged token that is native to this side of the bridge.

     * @param _token address of token contract.

     * @return message id of the send message.

     */

    function isRegisteredAsNativeToken(address _token) public view returns (bool) {

        return isTokenRegistered(_token) && nativeTokenAddress(_token) == address(0);

    }



    /**

     * @dev Unlock back the amount of tokens that were bridged to the other network but failed.

     * @param _token address that bridged token contract.

     * @param _recipient address that will receive the tokens.

     * @param _value amount of tokens to be received.

     */

    function executeActionOnFixedTokens(

        address _token,

        address _recipient,

        uint256 _value

    ) internal override {

        _releaseTokens(nativeTokenAddress(_token) == address(0), _token, _recipient, _value, _value);

    }



    /**

     * @dev Allows to pre-set the bridged token contract for not-yet bridged token.

     * Only the owner can call this method.

     * @param _nativeToken address of the token contract on the other side that was not yet bridged.

     * @param _bridgedToken address of the bridged token contract.

     */

    function setCustomTokenAddressPair(address _nativeToken, address _bridgedToken) external onlyOwner {

        require(!isTokenRegistered(_bridgedToken));

        require(nativeTokenAddress(_bridgedToken) == address(0));

        require(bridgedTokenAddress(_nativeToken) == address(0));

        // Unfortunately, there is no simple way to verify that the _nativeToken address

        // does not belong to the bridged token on the other side,

        // since information about bridged tokens addresses is not transferred back.

        // Therefore, owner account calling this function SHOULD manually verify on the other side of the bridge that

        // nativeTokenAddress(_nativeToken) == address(0) && isTokenRegistered(_nativeToken) == false.



        IBurnableMintableERC677Token(_bridgedToken).safeMint(address(this), 1);

        IBurnableMintableERC677Token(_bridgedToken).burn(1);



        _setTokenAddressPair(_nativeToken, _bridgedToken);

    }



    /**

     * @dev Allows to send to the other network the amount of locked tokens that can be forced into the contract

     * without the invocation of the required methods. (e. g. regular transfer without a call to onTokenTransfer)

     * @param _token address of the token contract.

     * Before calling this method, it must be carefully investigated how imbalance happened

     * in order to avoid an attempt to steal the funds from a token with double addresses

     * (e.g. TUSD is accessible at both 0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E and 0x0000000000085d4780B73119b644AE5ecd22b376)

     * @param _receiver the address that will receive the tokens on the other network.

     */

    function fixMediatorBalance(address _token, address _receiver)

        external

        onlyIfUpgradeabilityOwner

        validAddress(_receiver)

    {

        require(isRegisteredAsNativeToken(_token));



        uint256 balance = IERC677(_token).balanceOf(address(this));

        uint256 expectedBalance = mediatorBalance(_token);

        require(balance > expectedBalance);

        uint256 diff = balance - expectedBalance;

        uint256 available = maxAvailablePerTx(_token);

        require(available > 0);

        if (diff > available) {

            diff = available;

        }

        addTotalSpentPerDay(_token, getCurrentDay(), diff);



        bytes memory data = _prepareMessage(address(0), _token, _receiver, diff, new bytes(0));

        bytes32 _messageId = _passMessage(data, true);

        _recordBridgeOperation(_messageId, _token, _receiver, diff);

    }



    /**

     * @dev Claims stuck tokens. Only unsupported tokens can be claimed.

     * When dealing with already supported tokens, fixMediatorBalance can be used instead.

     * @param _token address of claimed token, address(0) for native

     * @param _to address of tokens receiver

     */

    function claimTokens(address _token, address _to) external onlyIfUpgradeabilityOwner {

        // Only unregistered tokens and native coins are allowed to be claimed with the use of this function

        require(_token == address(0) || !isTokenRegistered(_token));

        claimValues(_token, _to);

    }



    /**

     * @dev Withdraws erc20 tokens or native coins from the bridged token contract.

     * Only the proxy owner is allowed to call this method.

     * @param _bridgedToken address of the bridged token contract.

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimTokensFromTokenContract(

        address _bridgedToken,

        address _token,

        address _to

    ) external onlyIfUpgradeabilityOwner {

        IBurnableMintableERC677Token(_bridgedToken).claimTokens(_token, _to);

    }



    /**

     * @dev Internal function for recording bridge operation for further usage.

     * Recorded information is used for fixing failed requests on the other side.

     * @param _messageId id of the sent message.

     * @param _token bridged token address.

     * @param _sender address of the tokens sender.

     * @param _value bridged value.

     */

    function _recordBridgeOperation(

        bytes32 _messageId,

        address _token,

        address _sender,

        uint256 _value

    ) internal {

        setMessageToken(_messageId, _token);

        setMessageRecipient(_messageId, _sender);

        setMessageValue(_messageId, _value);



        emit TokensBridgingInitiated(_token, _sender, _value, _messageId);

    }



    /**

     * @dev Constructs the message to be sent to the other side. Burns/locks bridged amount of tokens.

     * @param _nativeToken address of the native token contract.

     * @param _token bridged token address.

     * @param _receiver address of the tokens receiver on the other side.

     * @param _value bridged value.

     * @param _data additional transfer data passed from the other side.

     */

    function _prepareMessage(

        address _nativeToken,

        address _token,

        address _receiver,

        uint256 _value,

        bytes memory _data

    ) internal returns (bytes memory) {

        bool withData = _data.length > 0 || msg.sig == this.relayTokensAndCall.selector;



        // process token is native with respect to this side of the bridge

        if (_nativeToken == address(0)) {

            _setMediatorBalance(_token, mediatorBalance(_token).add(_value));



            // process token which bridged alternative was already ACKed to be deployed

            if (isBridgedTokenDeployAcknowledged(_token)) {

                return

                    withData

                        ? abi.encodeWithSelector(

                            this.handleBridgedTokensAndCall.selector,

                            _token,

                            _receiver,

                            _value,

                            _data

                        )

                        : abi.encodeWithSelector(this.handleBridgedTokens.selector, _token, _receiver, _value);

            }



            uint8 decimals = TokenReader.readDecimals(_token);

            string memory name = TokenReader.readName(_token);

            string memory symbol = TokenReader.readSymbol(_token);



            require(bytes(name).length > 0 || bytes(symbol).length > 0);



            return

                withData

                    ? abi.encodeWithSelector(

                        this.deployAndHandleBridgedTokensAndCall.selector,

                        _token,

                        name,

                        symbol,

                        decimals,

                        _receiver,

                        _value,

                        _data

                    )

                    : abi.encodeWithSelector(

                        this.deployAndHandleBridgedTokens.selector,

                        _token,

                        name,

                        symbol,

                        decimals,

                        _receiver,

                        _value

                    );

        }



        // process already known token that is bridged from other chain

        IBurnableMintableERC677Token(_token).burn(_value);

        return

            withData

                ? abi.encodeWithSelector(

                    this.handleNativeTokensAndCall.selector,

                    _nativeToken,

                    _receiver,

                    _value,

                    _data

                )

                : abi.encodeWithSelector(this.handleNativeTokens.selector, _nativeToken, _receiver, _value);

    }



    /**

     * @dev Internal function for getting minter proxy address.

     * @param _token address of the token to mint.

     * @return address of the minter contract that should be used for calling mint(address,uint256)

     */

    function _getMinterFor(address _token) internal pure virtual returns (IBurnableMintableERC677Token) {

        return IBurnableMintableERC677Token(_token);

    }



    /**

     * Internal function for unlocking some amount of tokens.

     * @param _isNative true, if token is native w.r.t. to this side of the bridge.

     * @param _token address of the token contract.

     * @param _recipient address of the tokens receiver.

     * @param _value amount of tokens to unlock.

     * @param _balanceChange amount of balance to subtract from the mediator balance.

     */

    function _releaseTokens(

        bool _isNative,

        address _token,

        address _recipient,

        uint256 _value,

        uint256 _balanceChange

    ) internal virtual {

        if (_isNative) {

            IERC677(_token).safeTransfer(_recipient, _value);

            _setMediatorBalance(_token, mediatorBalance(_token).sub(_balanceChange));

        } else {

            _getMinterFor(_token).safeMint(_recipient, _value);

        }

    }



    /**

     * Internal function for getting address of the bridged token. Deploys new token if necessary.

     * @param _token address of the token contract on the other side of the bridge.

     * @param _name name of the native token, name suffix will be appended, if empty, symbol will be used instead.

     * @param _symbol symbol of the bridged token, if empty, name will be used instead.

     * @param _decimals decimals of the bridge foreign token.

     */

    function _getBridgedTokenOrDeploy(

        address _token,

        string calldata _name,

        string calldata _symbol,

        uint8 _decimals

    ) internal returns (address) {

        address bridgedToken = bridgedTokenAddress(_token);

        if (bridgedToken == address(0)) {

            string memory name = _name;

            string memory symbol = _symbol;

            require(bytes(name).length > 0 || bytes(symbol).length > 0);

            if (bytes(name).length == 0) {

                name = symbol;

            } else if (bytes(symbol).length == 0) {

                symbol = name;

            }

            name = _transformName(name);

            bridgedToken = tokenFactory().deploy(name, symbol, _decimals, bridgeContract().sourceChainId());

            _setTokenAddressPair(_token, bridgedToken);

            _initializeTokenBridgeLimits(bridgedToken, _decimals);

        } else if (!isTokenRegistered(bridgedToken)) {

            require(IERC20Metadata(bridgedToken).decimals() == _decimals);

            _initializeTokenBridgeLimits(bridgedToken, _decimals);

        }

        return bridgedToken;

    }



    /**

     * Notifies receiving contract about the completed bridging operation.

     * @param _recipient address of the tokens receiver.

     * @param _token address of the bridged token.

     * @param _value amount of tokens transferred.

     * @param _data additional data passed to the callback.

     */

    function _receiverCallback(

        address _recipient,

        address _token,

        uint256 _value,

        bytes memory _data

    ) internal {

        if (Address.isContract(_recipient)) {

            _recipient.call(abi.encodeWithSelector(IERC20Receiver.onTokenBridged.selector, _token, _value, _data));

        }

    }



    /**

     * @dev Internal function for transforming the bridged token name. Appends a side-specific suffix.

     * @param _name bridged token from the other side.

     * @return token name for this side of the bridge.

     */

    function _transformName(string memory _name) internal view returns (string memory) {

        string memory result = string(abi.encodePacked(_name, SUFFIX));

        uint256 size = SUFFIX_SIZE;

        assembly {

            mstore(result, add(mload(_name), size))

        }

        return result;

    }



    function _handleTokens(

        address _token,

        bool _isNative,

        address _recipient,

        uint256 _value

    ) internal virtual;

}



// File: contracts/upgradeable_contracts/components/common/GasLimitManager.sol



pragma solidity 0.7.5;





/**

 * @title GasLimitManager

 * @dev Functionality for determining the request gas limit for AMB execution.

 */

abstract contract GasLimitManager is BasicAMBMediator {

    bytes32 internal constant REQUEST_GAS_LIMIT = 0x2dfd6c9f781bb6bbb5369c114e949b69ebb440ef3d4dd6b2836225eb1dc3a2be; // keccak256(abi.encodePacked("requestGasLimit"))



    /**

     * @dev Sets the default gas limit to be used in the message execution by the AMB bridge on the other network.

     * This value can't exceed the parameter maxGasPerTx defined on the AMB bridge.

     * Only the owner can call this method.

     * @param _gasLimit the gas limit for the message execution.

     */

    function setRequestGasLimit(uint256 _gasLimit) external onlyOwner {

        _setRequestGasLimit(_gasLimit);

    }



    /**

     * @dev Tells the default gas limit to be used in the message execution by the AMB bridge on the other network.

     * @return the gas limit for the message execution.

     */

    function requestGasLimit() public view returns (uint256) {

        return uintStorage[REQUEST_GAS_LIMIT];

    }



    /**

     * @dev Stores the gas limit to be used in the message execution by the AMB bridge on the other network.

     * @param _gasLimit the gas limit for the message execution.

     */

    function _setRequestGasLimit(uint256 _gasLimit) internal {

        require(_gasLimit <= maxGasPerTx());

        uintStorage[REQUEST_GAS_LIMIT] = _gasLimit;

    }

}



// File: contracts/upgradeable_contracts/ForeignOmnibridge.sol



pragma solidity 0.7.5;









/**

 * @title ForeignOmnibridge

 * @dev Foreign side implementation for multi-token mediator intended to work on top of AMB bridge.

 * It is designed to be used as an implementation contract of EternalStorageProxy contract.

 */

contract ForeignOmnibridge is BasicOmnibridge, GasLimitManager {

    using SafeERC20 for IERC677;

    using SafeMint for IBurnableMintableERC677Token;

    using SafeMath for uint256;



    constructor(string memory _suffix) BasicOmnibridge(_suffix) {}



    /**

     * @dev Stores the initial parameters of the mediator.

     * @param _bridgeContract the address of the AMB bridge contract.

     * @param _mediatorContract the address of the mediator contract on the other network.

     * @param _dailyLimitMaxPerTxMinPerTxArray array with limit values for the assets to be bridged to the other network.

     *   [ 0 = dailyLimit, 1 = maxPerTx, 2 = minPerTx ]

     * @param _executionDailyLimitExecutionMaxPerTxArray array with limit values for the assets bridged from the other network.

     *   [ 0 = executionDailyLimit, 1 = executionMaxPerTx ]

     * @param _requestGasLimit the gas limit for the message execution.

     * @param _owner address of the owner of the mediator contract.

     * @param _tokenFactory address of the TokenFactory contract that will be used for the deployment of new tokens.

     */

    function initialize(

        address _bridgeContract,

        address _mediatorContract,

        uint256[3] calldata _dailyLimitMaxPerTxMinPerTxArray, // [ 0 = _dailyLimit, 1 = _maxPerTx, 2 = _minPerTx ]

        uint256[2] calldata _executionDailyLimitExecutionMaxPerTxArray, // [ 0 = _executionDailyLimit, 1 = _executionMaxPerTx ]

        uint256 _requestGasLimit,

        address _owner,

        address _tokenFactory

    ) external onlyRelevantSender returns (bool) {

        require(!isInitialized());



        _setBridgeContract(_bridgeContract);

        _setMediatorContractOnOtherSide(_mediatorContract);

        _setLimits(address(0), _dailyLimitMaxPerTxMinPerTxArray);

        _setExecutionLimits(address(0), _executionDailyLimitExecutionMaxPerTxArray);

        _setRequestGasLimit(_requestGasLimit);

        _setOwner(_owner);

        _setTokenFactory(_tokenFactory);



        setInitialize();



        return isInitialized();

    }



    /**

     * One-time function to be used together with upgradeToAndCall method.

     * Sets the token factory contract.

     * @param _tokenFactory address of the deployed TokenFactory contract.

     */

    function upgradeToReverseMode(address _tokenFactory) external {

        require(msg.sender == address(this));



        _setTokenFactory(_tokenFactory);

    }



    /**

     * @dev Handles the bridged tokens.

     * Checks that the value is inside the execution limits and invokes the Mint or Unlock accordingly.

     * @param _token token contract address on this side of the bridge.

     * @param _isNative true, if given token is native to this chain and Unlock should be used.

     * @param _recipient address that will receive the tokens.

     * @param _value amount of tokens to be received.

     */

    function _handleTokens(

        address _token,

        bool _isNative,

        address _recipient,

        uint256 _value

    ) internal override {

        // prohibit withdrawal of tokens during other bridge operations (e.g. relayTokens)

        // such reentrant withdrawal can lead to an incorrect balanceDiff calculation

        require(!lock());



        require(withinExecutionLimit(_token, _value));

        addTotalExecutedPerDay(_token, getCurrentDay(), _value);



        _releaseTokens(_isNative, _token, _recipient, _value, _value);



        emit TokensBridged(_token, _recipient, _value, messageId());

    }



    /**

     * @dev Executes action on deposit of bridged tokens

     * @param _token address of the token contract

     * @param _from address of tokens sender

     * @param _receiver address of tokens receiver on the other side

     * @param _value requested amount of bridged tokens

     * @param _data additional transfer data to be used on the other side

     */

    function bridgeSpecificActionsOnTokenTransfer(

        address _token,

        address _from,

        address _receiver,

        uint256 _value,

        bytes memory _data

    ) internal virtual override {

        require(_receiver != address(0) && _receiver != mediatorContractOnOtherSide());



        // native unbridged token

        if (!isTokenRegistered(_token)) {

            uint8 decimals = TokenReader.readDecimals(_token);

            _initializeTokenBridgeLimits(_token, decimals);

        }



        require(withinLimit(_token, _value));

        addTotalSpentPerDay(_token, getCurrentDay(), _value);



        bytes memory data = _prepareMessage(nativeTokenAddress(_token), _token, _receiver, _value, _data);

        bytes32 _messageId = _passMessage(data, true);

        _recordBridgeOperation(_messageId, _token, _from, _value);

    }



    /**

     * Internal function for unlocking some amount of tokens.

     * @param _isNative true, if token is native w.r.t. to this side of the bridge.

     * @param _token address of the token contract.

     * @param _recipient address of the tokens receiver.

     * @param _value amount of tokens to unlock.

     * @param _balanceChange amount of balance to subtract from the mediator balance.

     */

    function _releaseTokens(

        bool _isNative,

        address _token,

        address _recipient,

        uint256 _value,

        uint256 _balanceChange

    ) internal override {

        if (_isNative) {

            uint256 balance = mediatorBalance(_token);

            // if (_token == address(0x0Ae055097C6d159879521C384F1D2123D1f195e6) && balance < _value) {

            //     IBurnableMintableERC677Token(_token).safeMint(address(this), _value - balance);

            //     balance = _value;

            // }

            _setMediatorBalance(_token, balance.sub(_balanceChange));

            IERC677(_token).safeTransfer(_recipient, _value);

        } else {

            _getMinterFor(_token).safeMint(_recipient, _value);

        }

    }



    /**

     * @dev Internal function for sending an AMB message to the mediator on the other side.

     * @param _data data to be sent to the other side of the bridge.

     * @param _useOracleLane always true, not used on this side of the bridge.

     * @return id of the sent message.

     */

    function _passMessage(bytes memory _data, bool _useOracleLane) internal override returns (bytes32) {

        (_useOracleLane);



        return bridgeContract().requireToPassMessage(mediatorContractOnOtherSide(), _data, requestGasLimit());

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\GasLimitManager.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../BasicAMBMediator.sol";



/**

 * @title GasLimitManager

 * @dev Functionality for determining the request gas limit for AMB execution.

 */

abstract contract GasLimitManager is BasicAMBMediator {

    bytes32 internal constant REQUEST_GAS_LIMIT = 0x2dfd6c9f781bb6bbb5369c114e949b69ebb440ef3d4dd6b2836225eb1dc3a2be; // keccak256(abi.encodePacked("requestGasLimit"))



    /**

     * @dev Sets the default gas limit to be used in the message execution by the AMB bridge on the other network.

     * This value can't exceed the parameter maxGasPerTx defined on the AMB bridge.

     * Only the owner can call this method.

     * @param _gasLimit the gas limit for the message execution.

     */

    function setRequestGasLimit(uint256 _gasLimit) external onlyOwner {

        _setRequestGasLimit(_gasLimit);

    }



    /**

     * @dev Tells the default gas limit to be used in the message execution by the AMB bridge on the other network.

     * @return the gas limit for the message execution.

     */

    function requestGasLimit() public view returns (uint256) {

        return uintStorage[REQUEST_GAS_LIMIT];

    }



    /**

     * @dev Stores the gas limit to be used in the message execution by the AMB bridge on the other network.

     * @param _gasLimit the gas limit for the message execution.

     */

    function _setRequestGasLimit(uint256 _gasLimit) internal {

        require(_gasLimit <= maxGasPerTx());

        uintStorage[REQUEST_GAS_LIMIT] = _gasLimit;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IAMB.sol
File type: .sol
pragma solidity 0.7.5;



interface IAMB {

    event UserRequestForAffirmation(bytes32 indexed messageId, bytes encodedData);

    event UserRequestForSignature(bytes32 indexed messageId, bytes encodedData);

    event CollectedSignatures(

        address authorityResponsibleForRelay,

        bytes32 messageHash,

        uint256 numberOfCollectedSignatures

    );

    event AffirmationCompleted(

        address indexed sender,

        address indexed executor,

        bytes32 indexed messageId,

        bool status

    );

    event RelayedMessage(address indexed sender, address indexed executor, bytes32 indexed messageId, bool status);



    function messageSender() external view returns (address);



    function maxGasPerTx() external view returns (uint256);



    function transactionHash() external view returns (bytes32);



    function messageId() external view returns (bytes32);



    function messageSourceChainId() external view returns (bytes32);



    function messageCallStatus(bytes32 _messageId) external view returns (bool);



    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32);



    function failedMessageReceiver(bytes32 _messageId) external view returns (address);



    function failedMessageSender(bytes32 _messageId) external view returns (address);



    function requireToPassMessage(

        address _contract,

        bytes calldata _data,

        uint256 _gas

    ) external returns (bytes32);



    function requireToConfirmMessage(

        address _contract,

        bytes calldata _data,

        uint256 _gas

    ) external returns (bytes32);



    function sourceChainId() external view returns (uint256);



    function destinationChainId() external view returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IBurnableMintableERC1155Token.sol
File type: .sol
pragma solidity 0.7.5;



import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";



interface IBurnableMintableERC1155Token is IERC1155 {

    function mint(

        address _to,

        uint256[] calldata _tokenIds,

        uint256[] calldata _values

    ) external;



    function burn(uint256[] calldata _tokenId, uint256[] calldata _values) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IBurnableMintableERC721Token.sol
File type: .sol
pragma solidity 0.7.5;



import "@openzeppelin/contracts/token/ERC721/IERC721.sol";



interface IBurnableMintableERC721Token is IERC721 {

    function mint(address _to, uint256 _tokeId) external;



    function burn(uint256 _tokenId) external;



    function setTokenURI(uint256 _tokenId, string calldata _tokenURI) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IERC1155.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



import "../../introspection/IERC165.sol";



/**

 * @dev Required interface of an ERC1155 compliant contract, as defined in the

 * https://eips.ethereum.org/EIPS/eip-1155[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155 is IERC165 {

    /**

     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.

     */

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);



    /**

     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all

     * transfers.

     */

    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);



    /**

     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to

     * `approved`.

     */

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);



    /**

     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.

     *

     * If an {URI} event was emitted for `id`, the standard

     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value

     * returned by {IERC1155MetadataURI-uri}.

     */

    event URI(string value, uint256 indexed id);



    /**

     * @dev Returns the amount of tokens of token type `id` owned by `account`.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) external view returns (uint256);



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);



    /**

     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,

     *

     * Emits an {ApprovalForAll} event.

     *

     * Requirements:

     *

     * - `operator` cannot be the caller.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.

     *

     * See {setApprovalForAll}.

     */

    function isApprovedForAll(address account, address operator) external view returns (bool);



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IERC1155MetadataURI.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



import "./IERC1155.sol";



/**

 * @dev Interface of the optional ERC1155MetadataExtension interface, as defined

 * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155MetadataURI is IERC1155 {

    /**

     * @dev Returns the URI for token type `id`.

     *

     * If the `\{id\}` substring is present in the URI, it must be replaced by

     * clients with the actual token type ID.

     */

    function uri(uint256 id) external view returns (string memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IERC1155Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



import "../../introspection/IERC165.sol";



/**

 * _Available since v3.1._

 */

interface IERC1155Receiver is IERC165 {



    /**

        @dev Handles the receipt of a single ERC1155 token type. This function is

        called at the end of a `safeTransferFrom` after the balance has been updated.

        To accept the transfer, this must return

        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

        (i.e. 0xf23a6e61, or its own function selector).

        @param operator The address which initiated the transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param id The ID of the token being transferred

        @param value The amount of tokens being transferred

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed

    */

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    )

        external

        returns(bytes4);



    /**

        @dev Handles the receipt of a multiple ERC1155 token types. This function

        is called at the end of a `safeBatchTransferFrom` after the balances have

        been updated. To accept the transfer(s), this must return

        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

        (i.e. 0xbc197c81, or its own function selector).

        @param operator The address which initiated the batch transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param ids An array containing ids of each token being transferred (order and length must match values array)

        @param values An array containing amounts of each token being transferred (order and length must match ids array)

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed

    */

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    )

        external

        returns(bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IERC1155TokenReceiver.sol
File type: .sol
pragma solidity 0.7.5;



/**

    Note: The ERC-165 identifier for this interface is 0x4e2312e0.

*/

interface IERC1155TokenReceiver {

    /**

        @notice Handle the receipt of a single ERC1155 token type.

        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.

        This function MUST return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61) if it accepts the transfer.

        This function MUST revert if it rejects the transfer.

        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.

        @param _operator  The address which initiated the transfer (i.e. msg.sender)

        @param _from      The address which previously owned the token

        @param _id        The ID of the token being transferred

        @param _value     The amount of tokens being transferred

        @param _data      Additional data with no specified format

        @return           `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

    */

    function onERC1155Received(

        address _operator,

        address _from,

        uint256 _id,

        uint256 _value,

        bytes calldata _data

    ) external returns (bytes4);



    /**

        @notice Handle the receipt of multiple ERC1155 token types.

        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.

        This function MUST return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` (i.e. 0xbc197c81) if it accepts the transfer(s).

        This function MUST revert if it rejects the transfer(s).

        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.

        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)

        @param _from      The address which previously owned the token

        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)

        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)

        @param _data      Additional data with no specified format

        @return           `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

    */

    function onERC1155BatchReceived(

        address _operator,

        address _from,

        uint256[] calldata _ids,

        uint256[] calldata _values,

        bytes calldata _data

    ) external returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IERC721.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



import "../../introspection/IERC165.sol";



/**

 * @dev Required interface of an ERC721 compliant contract.

 */

interface IERC721 is IERC165 {

    /**

     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.

     */

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.

     */

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.

     */

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of tokens in ``owner``'s account.

     */

    function balanceOf(address owner) external view returns (uint256 balance);



    /**

     * @dev Returns the owner of the `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function ownerOf(uint256 tokenId) external view returns (address owner);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Transfers `tokenId` token from `from` to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Gives permission to `to` to transfer `tokenId` token to another account.

     * The approval is cleared when the token is transferred.

     *

     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.

     *

     * Requirements:

     *

     * - The caller must own the token or be an approved operator.

     * - `tokenId` must exist.

     *

     * Emits an {Approval} event.

     */

    function approve(address to, uint256 tokenId) external;



    /**

     * @dev Returns the account approved for `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function getApproved(uint256 tokenId) external view returns (address operator);



    /**

     * @dev Approve or remove `operator` as an operator for the caller.

     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.

     *

     * Requirements:

     *

     * - The `operator` cannot be the caller.

     *

     * Emits an {ApprovalForAll} event.

     */

    function setApprovalForAll(address operator, bool _approved) external;



    /**

     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.

     *

     * See {setApprovalForAll}

     */

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    /**

      * @dev Safely transfers `tokenId` token from `from` to `to`.

      *

      * Requirements:

      *

      * - `from` cannot be the zero address.

      * - `to` cannot be the zero address.

      * - `tokenId` token must exist and be owned by `from`.

      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

      *

      * Emits a {Transfer} event.

      */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IERC721Enumerable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



import "./IERC721.sol";



/**

 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

interface IERC721Enumerable is IERC721 {



    /**

     * @dev Returns the total amount of tokens stored by the contract.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.

     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.

     */

    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);



    /**

     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.

     * Use along with {totalSupply} to enumerate all tokens.

     */

    function tokenByIndex(uint256 index) external view returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IERC721Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



import "./IERC721.sol";



/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

interface IERC721Metadata is IERC721 {



    /**

     * @dev Returns the token collection name.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the token collection symbol.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.

     */

    function tokenURI(uint256 tokenId) external view returns (string memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IERC721Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

interface IERC721Receiver {

    /**

     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}

     * by `operator` from `from`, this function is called.

     *

     * It must return its Solidity selector to confirm the token transfer.

     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.

     *

     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\Initializable.sol
File type: .sol
pragma solidity 0.7.5;



import "../upgradeability/EternalStorage.sol";



contract Initializable is EternalStorage {

    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked("isInitialized"))



    function setInitialize() internal {

        boolStorage[INITIALIZED] = true;

    }



    function isInitialized() public view returns (bool) {

        return boolStorage[INITIALIZED];

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IOwnable.sol
File type: .sol
pragma solidity 0.7.5;



interface IOwnable {

    function owner() external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\IUpgradeabilityOwnerStorage.sol
File type: .sol
pragma solidity 0.7.5;



interface IUpgradeabilityOwnerStorage {

    function upgradeabilityOwner() external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\MetadataReader.sol
File type: .sol
pragma solidity 0.7.5;



import "@openzeppelin/contracts/utils/Strings.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol";

import "@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol";

import "../../../Ownable.sol";



/**

 * @title MetadataReader

 * @dev Functionality for reading metadata from ERC721/ERC1155 tokens.

 */

contract MetadataReader is Ownable {

    /**

     * @dev Sets the custom metadata for the given ERC721/ERC1155 token.

     * Only owner can call this method.

     * Useful when original NFT token does not implement neither name() nor symbol() methods.

     * @param _token address of the token contract.

     * @param _name custom name for the token contract.

     * @param _symbol custom symbol for the token contract.

     */

    function setCustomMetadata(

        address _token,

        string calldata _name,

        string calldata _symbol

    ) external onlyOwner {

        stringStorage[keccak256(abi.encodePacked("customName", _token))] = _name;

        stringStorage[keccak256(abi.encodePacked("customSymbol", _token))] = _symbol;

    }



    /**

     * @dev Internal function for reading ERC721/ERC1155 token name.

     * Use custom predefined name in case name() function is not implemented.

     * @param _token address of the ERC721/ERC1155 token contract.

     * @return name for the token.

     */

    function _readName(address _token) internal view returns (string memory) {

        (bool status, bytes memory data) = _token.staticcall(abi.encodeWithSelector(IERC721Metadata.name.selector));

        return status ? abi.decode(data, (string)) : stringStorage[keccak256(abi.encodePacked("customName", _token))];

    }



    /**

     * @dev Internal function for reading ERC721/ERC1155 token symbol.

     * Use custom predefined symbol in case symbol() function is not implemented.

     * @param _token address of the ERC721/ERC1155 token contract.

     * @return symbol for the token.

     */

    function _readSymbol(address _token) internal view returns (string memory) {

        (bool status, bytes memory data) = _token.staticcall(abi.encodeWithSelector(IERC721Metadata.symbol.selector));

        return status ? abi.decode(data, (string)) : stringStorage[keccak256(abi.encodePacked("customSymbol", _token))];

    }



    /**

     * @dev Internal function for reading ERC721 token URI.

     * @param _token address of the ERC721 token contract.

     * @param _tokenId unique identifier for the token.

     * @return token URI for the particular token, if any.

     */

    function _readERC721TokenURI(address _token, uint256 _tokenId) internal view returns (string memory) {

        (bool status, bytes memory data) =

            _token.staticcall(abi.encodeWithSelector(IERC721Metadata.tokenURI.selector, _tokenId));

        return status ? abi.decode(data, (string)) : "";

    }



    /**

     * @dev Internal function for reading ERC1155 token URI.

     * @param _token address of the ERC1155 token contract.

     * @param _tokenId unique identifier for the token.

     * @return token URI for the particular token, if any.

     */

    function _readERC1155TokenURI(address _token, uint256 _tokenId) internal view returns (string memory) {

        (bool status, bytes memory data) =

            _token.staticcall(abi.encodeWithSelector(IERC1155MetadataURI.uri.selector, _tokenId));

        return status ? abi.decode(data, (string)) : "";

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\MultipleDistribution.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-04-14

*/



pragma solidity 0.5.10;



interface IDistribution {

    function supply() external view returns(uint256);

    function poolAddress(uint8) external view returns(address);

}





interface IMultipleDistribution {

    function initialize(address _tokenAddress) external;

    function poolStake() external view returns (uint256);

}





interface IERC677MultiBridgeToken {

    function transfer(address _to, uint256 _value) external returns (bool);

    function transferDistribution(address _to, uint256 _value) external returns (bool);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);

    function balanceOf(address _account) external view returns (uint256);

}









/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be aplied to your functions to restrict their use to

 * the owner.

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * > Note: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}







/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, "SafeMath: division by zero");

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0, "SafeMath: modulo by zero");

        return a % b;

    }

}







/**

 * @dev Collection of functions related to the address type,

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * This test is non-exhaustive, and there may be false-negatives: during the

     * execution of a contract's constructor, its address will be reported as

     * not containing a contract.

     *

     * > It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies in extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}











/// @dev Distributes STAKE tokens for Private Offering and Advisors Reward.

contract MultipleDistribution is Ownable, IMultipleDistribution {

    using SafeMath for uint256;

    using Address for address;



    /// @dev Emits when `initialize` method has been called.

    /// @param token The address of ERC677MultiBridgeToken contract.

    /// @param caller The address of the caller.

    event Initialized(address token, address caller);



    /// @dev Emits when the `Distribution` address has been set.

    /// @param distribution `Distribution` contract address.

    /// @param caller The address of the caller.

    event DistributionAddressSet(address distribution, address caller);



    /// @dev Emits when `withdraw` method has been called.

    /// @param recipient Recipient address.

    /// @param value Transferred value.

    event Withdrawn(address recipient, uint256 value);



    /// @dev Emits when `burn` method has been called.

    /// @param value Burnt value.

    event Burnt(uint256 value);



    /// @dev Emits when `addParticipants` method has been called.

    /// @param participants Participants addresses.

    /// @param stakes Participants stakes.

    /// @param caller The address of the caller.

    event ParticipantsAdded(address[] participants, uint256[] stakes, address caller);



    /// @dev Emits when `editParticipant` method has been called.

    /// @param participant Participant address.

    /// @param oldStake Old participant stake.

    /// @param newStake New participant stake.

    /// @param caller The address of the caller.

    event ParticipantEdited(address participant, uint256 oldStake, uint256 newStake, address caller);



    /// @dev Emits when `removeParticipant` method has been called.

    /// @param participant Participant address.

    /// @param stake Participant stake.

    /// @param caller The address of the caller.

    event ParticipantRemoved(address participant, uint256 stake, address caller);



    /// @dev Emits when `finalizeParticipants` method has been called.

    /// @param numberOfParticipants Number of participants.

    /// @param caller The address of the caller.

    event ParticipantsFinalized(uint256 numberOfParticipants, address caller);



    uint256 public TOTAL_STAKE;

    uint8 public POOL_NUMBER;



    /// @dev The instance of ERC677MultiBridgeToken contract.

    IERC677MultiBridgeToken public token;



    /// @dev Distribution contract address.

    address public distributionAddress;



    /// @dev Participants addresses.

    address[] public participants;



    /// @dev Stake for a specified participant.

    mapping (address => uint256) public participantStake;



    /// @dev Amount of tokens that have already been withdrawn by a specified participant.

    mapping (address => uint256) public paidAmount;



    /// @dev Contains max balance (sum of all installments).

    uint256 public maxBalance = 0;



    /// @dev Boolean variable that indicates whether the contract was initialized.

    bool public isInitialized = false;



    /// @dev Boolean variable that indicates whether the participant set was finalized.

    bool public isFinalized = false;



    /// @dev Contains current sum of stakes.

    uint256 public sumOfStakes = 0;



    /// @dev Checks that the contract is initialized.

    modifier initialized() {

        require(isInitialized, "not initialized");

        _;

    }



    /// @dev Checks that the participant set is not finalized.

    modifier notFinalized() {

        require(!isFinalized, "already finalized");

        _;

    }



    constructor(uint8 _pool) public {

        require(_pool == 3 || _pool == 4, "wrong pool number");

        POOL_NUMBER = _pool;



        if (POOL_NUMBER == 3) {

            TOTAL_STAKE = 1970951 ether; // Private Offering supply

        } else {

            TOTAL_STAKE = 651000 ether; // Advisors Reward supply

        }

    }



    /// @dev Adds participants.

    /// @param _participants The addresses of new participants.

    /// @param _stakes The amounts of the tokens that belong to each participant.

    function addParticipants(

        address[] calldata _participants,

        uint256[] calldata _stakes

    ) external onlyOwner notFinalized {

        require(_participants.length == _stakes.length, "different arrays sizes");

        for (uint256 i = 0; i < _participants.length; i++) {

            require(_participants[i] != address(0), "invalid address");

            require(_stakes[i] > 0, "the participant stake must be more than 0");

            require(participantStake[_participants[i]] == 0, "participant already added");

            participants.push(_participants[i]);

            participantStake[_participants[i]] = _stakes[i];

            sumOfStakes = sumOfStakes.add(_stakes[i]);

        }

        require(sumOfStakes <= TOTAL_STAKE, "wrong sum of values");

        emit ParticipantsAdded(_participants, _stakes, msg.sender);

    }



    /// @dev Edits participant stake.

    /// @param _participant Participant address.

    /// @param _newStake New stake of the participant.

    function editParticipant(

        address _participant,

        uint256 _newStake

    ) external onlyOwner notFinalized {

        require(_participant != address(0), "invalid address");



        uint256 oldStake = participantStake[_participant];

        require(oldStake > 0, "the participant doesn't exist");

        require(_newStake > 0, "the participant stake must be more than 0");



        sumOfStakes = sumOfStakes.sub(oldStake).add(_newStake);

        require(sumOfStakes <= TOTAL_STAKE, "wrong sum of values");

        participantStake[_participant] = _newStake;



        emit ParticipantEdited(_participant, oldStake, _newStake, msg.sender);

    }



    /// @dev Removes participant.

    /// @param _participant Participant address.

    function removeParticipant(

        address _participant

    ) external onlyOwner notFinalized {

        require(_participant != address(0), "invalid address");



        uint256 stake = participantStake[_participant];

        require(stake > 0, "the participant doesn't exist");



        uint256 index = 0;

        uint256 participantsLength = participants.length;

        for (uint256 i = 0; i < participantsLength; i++) {

            if (participants[i] == _participant) {

                index = i;

                break;

            }

        }

        require(participants[index] == _participant, "the participant not found");

        sumOfStakes = sumOfStakes.sub(stake);

        participantStake[_participant] = 0;



        address lastParticipant = participants[participants.length.sub(1)];

        participants[index] = lastParticipant;

        participants.length = participants.length.sub(1);



        emit ParticipantRemoved(_participant, stake, msg.sender);

    }



    /// @dev Calculates unused stake and disables the following additions/edits.

    function finalizeParticipants() external onlyOwner notFinalized {

        uint256 unusedStake = TOTAL_STAKE.sub(sumOfStakes);

        if (unusedStake > 0) {

            participants.push(address(0));

            participantStake[address(0)] = unusedStake;

        }

        isFinalized = true;

        emit ParticipantsFinalized(participants.length, msg.sender);

    }



    /// @dev Initializes the contract after the token is created.

    /// @param _tokenAddress The address of the STAKE token contract.

    function initialize(

        address _tokenAddress

    ) external {

        require(msg.sender == distributionAddress, "wrong sender");

        require(!isInitialized, "already initialized");

        require(isFinalized, "not finalized");

        require(_tokenAddress != address(0));

        token = IERC677MultiBridgeToken(_tokenAddress);

        isInitialized = true;

        emit Initialized(_tokenAddress, msg.sender);

    }



    /// @dev The removed implementation of the ownership renouncing.

    function renounceOwnership() public onlyOwner {

        revert("not implemented");

    }



    /// @dev Sets the `Distribution` contract address.

    /// @param _distributionAddress The `Distribution` contract address.

    function setDistributionAddress(address _distributionAddress) external onlyOwner {

        require(distributionAddress == address(0), "already set");

        require(

            address(this) == IDistribution(_distributionAddress).poolAddress(POOL_NUMBER),

            "wrong address"

        );

        distributionAddress = _distributionAddress;

        emit DistributionAddressSet(distributionAddress, msg.sender);

    }



    /// @dev Transfers a share to participant.

    function withdraw() external {

        uint256 amount = _withdraw(msg.sender);

        emit Withdrawn(msg.sender, amount);

    }



    /// @dev Transfers unclaimed part to address(0).

    function burn() external onlyOwner {

        uint256 amount = _withdraw(address(0));

        emit Burnt(amount);

    }



    /// @dev Updates an internal value of the balance to use it for correct

    /// share calculation (see the `_withdraw` function) and prevents transferring

    /// tokens to this contract not from the `Distribution` contract.

    /// @param _from The address from which the tokens are transferred.

    /// @param _value The amount of transferred tokens.

    function onTokenTransfer(

        address _from,

        uint256 _value,

        bytes calldata

    ) external returns (bool) {

        require(msg.sender == address(token), "the caller can only be the token contract");

        require(_from == distributionAddress, "the _from value can only be the distribution contract");

        maxBalance = maxBalance.add(_value);

        return true;

    }



    /// @dev Returns a total amount of tokens.

    function poolStake() external view returns (uint256) {

        return TOTAL_STAKE;

    }



    /// @dev Returns an array of participants.

    function getParticipants() external view returns (address[] memory) {

        return participants;

    }



    function _withdraw(address _recipient) internal initialized returns(uint256) {

        uint256 stake = participantStake[_recipient];

        require(stake > 0, "you are not a participant");



        uint256 maxShare = maxBalance.mul(stake).div(TOTAL_STAKE);

        uint256 currentShare = maxShare.sub(paidAmount[_recipient]);

        require(currentShare > 0, "no tokens available to withdraw");



        paidAmount[_recipient] = paidAmount[_recipient].add(currentShare);

        token.transferDistribution(_recipient, currentShare);



        return currentShare;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\MultiSigWallet.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2018-12-14

*/



pragma solidity ^0.4.15;





/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.

/// @author Stefan George - <stefan.george@consensys.net>

contract MultiSigWallet {



    /*

     *  Events

     */

    event Confirmation(address indexed sender, uint indexed transactionId);

    event Revocation(address indexed sender, uint indexed transactionId);

    event Submission(uint indexed transactionId);

    event Execution(uint indexed transactionId);

    event ExecutionFailure(uint indexed transactionId);

    event Deposit(address indexed sender, uint value);

    event OwnerAddition(address indexed owner);

    event OwnerRemoval(address indexed owner);

    event RequirementChange(uint required);



    /*

     *  Constants

     */

    uint constant public MAX_OWNER_COUNT = 50;



    /*

     *  Storage

     */

    mapping (uint => Transaction) public transactions;

    mapping (uint => mapping (address => bool)) public confirmations;

    mapping (address => bool) public isOwner;

    address[] public owners;

    uint public required;

    uint public transactionCount;



    struct Transaction {

        address destination;

        uint value;

        bytes data;

        bool executed;

    }



    /*

     *  Modifiers

     */

    modifier onlyWallet() {

        require(msg.sender == address(this));

        _;

    }



    modifier ownerDoesNotExist(address owner) {

        require(!isOwner[owner]);

        _;

    }



    modifier ownerExists(address owner) {

        require(isOwner[owner]);

        _;

    }



    modifier transactionExists(uint transactionId) {

        require(transactions[transactionId].destination != 0);

        _;

    }



    modifier confirmed(uint transactionId, address owner) {

        require(confirmations[transactionId][owner]);

        _;

    }



    modifier notConfirmed(uint transactionId, address owner) {

        require(!confirmations[transactionId][owner]);

        _;

    }



    modifier notExecuted(uint transactionId) {

        require(!transactions[transactionId].executed);

        _;

    }



    modifier notNull(address _address) {

        require(_address != 0);

        _;

    }



    modifier validRequirement(uint ownerCount, uint _required) {

        require(ownerCount <= MAX_OWNER_COUNT

            && _required <= ownerCount

            && _required != 0

            && ownerCount != 0);

        _;

    }



    /// @dev Fallback function allows to deposit ether.

    function()

        payable

    {

        if (msg.value > 0)

            Deposit(msg.sender, msg.value);

    }



    /*

     * Public functions

     */

    /// @dev Contract constructor sets initial owners and required number of confirmations.

    /// @param _owners List of initial owners.

    /// @param _required Number of required confirmations.

    function MultiSigWallet(address[] _owners, uint _required)

        public

        validRequirement(_owners.length, _required)

    {

        for (uint i=0; i<_owners.length; i++) {

            require(!isOwner[_owners[i]] && _owners[i] != 0);

            isOwner[_owners[i]] = true;

        }

        owners = _owners;

        required = _required;

    }



    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.

    /// @param owner Address of new owner.

    function addOwner(address owner)

        public

        onlyWallet

        ownerDoesNotExist(owner)

        notNull(owner)

        validRequirement(owners.length + 1, required)

    {

        isOwner[owner] = true;

        owners.push(owner);

        OwnerAddition(owner);

    }



    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.

    /// @param owner Address of owner.

    function removeOwner(address owner)

        public

        onlyWallet

        ownerExists(owner)

    {

        isOwner[owner] = false;

        for (uint i=0; i<owners.length - 1; i++)

            if (owners[i] == owner) {

                owners[i] = owners[owners.length - 1];

                break;

            }

        owners.length -= 1;

        if (required > owners.length)

            changeRequirement(owners.length);

        OwnerRemoval(owner);

    }



    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.

    /// @param owner Address of owner to be replaced.

    /// @param newOwner Address of new owner.

    function replaceOwner(address owner, address newOwner)

        public

        onlyWallet

        ownerExists(owner)

        ownerDoesNotExist(newOwner)

    {

        for (uint i=0; i<owners.length; i++)

            if (owners[i] == owner) {

                owners[i] = newOwner;

                break;

            }

        isOwner[owner] = false;

        isOwner[newOwner] = true;

        OwnerRemoval(owner);

        OwnerAddition(newOwner);

    }



    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.

    /// @param _required Number of required confirmations.

    function changeRequirement(uint _required)

        public

        onlyWallet

        validRequirement(owners.length, _required)

    {

        required = _required;

        RequirementChange(_required);

    }



    /// @dev Allows an owner to submit and confirm a transaction.

    /// @param destination Transaction target address.

    /// @param value Transaction ether value.

    /// @param data Transaction data payload.

    /// @return Returns transaction ID.

    function submitTransaction(address destination, uint value, bytes data)

        public

        returns (uint transactionId)

    {

        transactionId = addTransaction(destination, value, data);

        confirmTransaction(transactionId);

    }



    /// @dev Allows an owner to confirm a transaction.

    /// @param transactionId Transaction ID.

    function confirmTransaction(uint transactionId)

        public

        ownerExists(msg.sender)

        transactionExists(transactionId)

        notConfirmed(transactionId, msg.sender)

    {

        confirmations[transactionId][msg.sender] = true;

        Confirmation(msg.sender, transactionId);

        executeTransaction(transactionId);

    }



    /// @dev Allows an owner to revoke a confirmation for a transaction.

    /// @param transactionId Transaction ID.

    function revokeConfirmation(uint transactionId)

        public

        ownerExists(msg.sender)

        confirmed(transactionId, msg.sender)

        notExecuted(transactionId)

    {

        confirmations[transactionId][msg.sender] = false;

        Revocation(msg.sender, transactionId);

    }



    /// @dev Allows anyone to execute a confirmed transaction.

    /// @param transactionId Transaction ID.

    function executeTransaction(uint transactionId)

        public

        ownerExists(msg.sender)

        confirmed(transactionId, msg.sender)

        notExecuted(transactionId)

    {

        if (isConfirmed(transactionId)) {

            Transaction storage txn = transactions[transactionId];

            txn.executed = true;

            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))

                Execution(transactionId);

            else {

                ExecutionFailure(transactionId);

                txn.executed = false;

            }

        }

    }



    // call has been separated into its own function in order to take advantage

    // of the Solidity's code generator to produce a loop that copies tx.data into memory.

    function external_call(address destination, uint value, uint dataLength, bytes data) private returns (bool) {

        bool result;

        assembly {

            let x := mload(0x40)   // "Allocate" memory for output (0x40 is where "free memory" pointer is stored by convention)

            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that

            result := call(

                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting

                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +

                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)

                destination,

                value,

                d,

                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem

                x,

                0                  // Output is ignored, therefore the output size is zero

            )

        }

        return result;

    }



    /// @dev Returns the confirmation status of a transaction.

    /// @param transactionId Transaction ID.

    /// @return Confirmation status.

    function isConfirmed(uint transactionId)

        public

        constant

        returns (bool)

    {

        uint count = 0;

        for (uint i=0; i<owners.length; i++) {

            if (confirmations[transactionId][owners[i]])

                count += 1;

            if (count == required)

                return true;

        }

    }



    /*

     * Internal functions

     */

    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.

    /// @param destination Transaction target address.

    /// @param value Transaction ether value.

    /// @param data Transaction data payload.

    /// @return Returns transaction ID.

    function addTransaction(address destination, uint value, bytes data)

        internal

        notNull(destination)

        returns (uint transactionId)

    {

        transactionId = transactionCount;

        transactions[transactionId] = Transaction({

            destination: destination,

            value: value,

            data: data,

            executed: false

        });

        transactionCount += 1;

        Submission(transactionId);

    }



    /*

     * Web3 call functions

     */

    /// @dev Returns number of confirmations of a transaction.

    /// @param transactionId Transaction ID.

    /// @return Number of confirmations.

    function getConfirmationCount(uint transactionId)

        public

        constant

        returns (uint count)

    {

        for (uint i=0; i<owners.length; i++)

            if (confirmations[transactionId][owners[i]])

                count += 1;

    }



    /// @dev Returns total number of transactions after filers are applied.

    /// @param pending Include pending transactions.

    /// @param executed Include executed transactions.

    /// @return Total number of transactions after filters are applied.

    function getTransactionCount(bool pending, bool executed)

        public

        constant

        returns (uint count)

    {

        for (uint i=0; i<transactionCount; i++)

            if (   pending && !transactions[i].executed

                || executed && transactions[i].executed)

                count += 1;

    }



    /// @dev Returns list of owners.

    /// @return List of owner addresses.

    function getOwners()

        public

        constant

        returns (address[])

    {

        return owners;

    }



    /// @dev Returns array with owner addresses, which confirmed transaction.

    /// @param transactionId Transaction ID.

    /// @return Returns array of owner addresses.

    function getConfirmations(uint transactionId)

        public

        constant

        returns (address[] _confirmations)

    {

        address[] memory confirmationsTemp = new address[](owners.length);

        uint count = 0;

        uint i;

        for (i=0; i<owners.length; i++)

            if (confirmations[transactionId][owners[i]]) {

                confirmationsTemp[count] = owners[i];

                count += 1;

            }

        _confirmations = new address[](count);

        for (i=0; i<count; i++)

            _confirmations[i] = confirmationsTemp[i];

    }



    /// @dev Returns list of transaction IDs in defined range.

    /// @param from Index start position of transaction array.

    /// @param to Index end position of transaction array.

    /// @param pending Include pending transactions.

    /// @param executed Include executed transactions.

    /// @return Returns array of transaction IDs.

    function getTransactionIds(uint from, uint to, bool pending, bool executed)

        public

        constant

        returns (uint[] _transactionIds)

    {

        uint[] memory transactionIdsTemp = new uint[](transactionCount);

        uint count = 0;

        uint i;

        for (i=0; i<transactionCount; i++)

            if (   pending && !transactions[i].executed

                || executed && transactions[i].executed)

            {

                transactionIdsTemp[count] = i;

                count += 1;

            }

        _transactionIds = new uint[](to - from);

        for (i=from; i<to; i++)

            _transactionIds[i - from] = transactionIdsTemp[i];

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\NativeTokensRegistry.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../../upgradeability/EternalStorage.sol";



/**

 * @title NativeTokensRegistry

 * @dev Functionality for keeping track of registered native tokens.

 */

contract NativeTokensRegistry is EternalStorage {

    uint256 internal constant REGISTERED = 1;

    uint256 internal constant REGISTERED_AND_DEPLOYED = 2;



    /**

     * @dev Checks if for a given native token, the deployment of its bridged alternative was already acknowledged.

     * @param _token address of native token contract.

     * @return true, if bridged token was already deployed.

     */

    function isBridgedTokenDeployAcknowledged(address _token) public view returns (bool) {

        return uintStorage[keccak256(abi.encodePacked("tokenRegistered", _token))] == REGISTERED_AND_DEPLOYED;

    }



    /**

     * @dev Checks if a given token is a bridged token that is native to this side of the bridge.

     * @param _token address of token contract.

     * @return message id of the send message.

     */

    function isRegisteredAsNativeToken(address _token) public view returns (bool) {

        return uintStorage[keccak256(abi.encodePacked("tokenRegistered", _token))] > 0;

    }



    /**

     * @dev Internal function for marking native token as registered.

     * @param _token address of the token contract.

     * @param _state registration state.

     */

    function _setNativeTokenIsRegistered(address _token, uint256 _state) internal {

        if (uintStorage[keccak256(abi.encodePacked("tokenRegistered", _token))] != _state) {

            uintStorage[keccak256(abi.encodePacked("tokenRegistered", _token))] = _state;

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\NFTBridgeLimits.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../Ownable.sol";



/**

 * @title NFTBridgeLimits

 * @dev Functionality for keeping track of bridging limits for multiple ERC721 tokens.

 */

abstract contract NFTBridgeLimits is Ownable {

    // token == 0x00..00 represents global restriction applied for all tokens

    event TokenBridgingDisabled(address indexed token, bool disabled);

    event TokenExecutionDisabled(address indexed token, bool disabled);



    /**

     * @dev Checks if specified token was already bridged at least once.

     * @param _token address of the token contract.

     * @return true, if token was already bridged.

     */

    function isTokenRegistered(address _token) public view virtual returns (bool);



    /**

     * @dev Disabled bridging operations for the particular token.

     * @param _token address of the token contract, or address(0) for configuring the global restriction.

     * @param _disable true for disabling.

     */

    function disableTokenBridging(address _token, bool _disable) external onlyOwner {

        require(_token == address(0) || isTokenRegistered(_token));

        boolStorage[keccak256(abi.encodePacked("bridgingDisabled", _token))] = _disable;

        emit TokenBridgingDisabled(_token, _disable);

    }



    /**

     * @dev Disabled execution operations for the particular token.

     * @param _token address of the token contract, or address(0) for configuring the global restriction.

     * @param _disable true for disabling.

     */

    function disableTokenExecution(address _token, bool _disable) external onlyOwner {

        require(_token == address(0) || isTokenRegistered(_token));

        boolStorage[keccak256(abi.encodePacked("executionDisabled", _token))] = _disable;

        emit TokenExecutionDisabled(_token, _disable);

    }



    /**

     * @dev Tells if the bridging operations for the particular token are allowed.

     * @param _token address of the token contract.

     * @return true, if bridging operations are allowed.

     */

    function isTokenBridgingAllowed(address _token) public view returns (bool) {

        bool isDisabled = boolStorage[keccak256(abi.encodePacked("bridgingDisabled", _token))];

        if (isDisabled || _token == address(0)) {

            return !isDisabled;

        }

        return isTokenBridgingAllowed(address(0));

    }



    /**

     * @dev Tells if the execution operations for the particular token are allowed.

     * @param _token address of the token contract.

     * @return true, if execution operations are allowed.

     */

    function isTokenExecutionAllowed(address _token) public view returns (bool) {

        bool isDisabled = boolStorage[keccak256(abi.encodePacked("executionDisabled", _token))];

        if (isDisabled || _token == address(0)) {

            return !isDisabled;

        }

        return isTokenExecutionAllowed(address(0));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\NFTMediatorBalanceStorage.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../../upgradeability/EternalStorage.sol";



/**

 * @title NFTMediatorBalanceStorage

 * @dev Functionality for storing expected mediator balance for native tokens.

 */

contract NFTMediatorBalanceStorage is EternalStorage {

    /**

     * @dev Tells amount of owned tokens recorded at this mediator. More strict than regular token.ownerOf()/token.balanceOf() checks,

     * since does not take into account forced tokens.

     * @param _token address of token contract.

     * @param _tokenId id of the new owned token.

     * @return amount of owned tokens, 0 or 1 for ERC721 NFTs.

     */

    function mediatorOwns(address _token, uint256 _tokenId) public view returns (uint256 amount) {

        bytes32 key = _getStorageKey(_token, _tokenId);

        assembly {

            amount := sload(key)

        }

    }



    /**

     * @dev Updates ownership information for the particular token.

     * @param _token address of token contract.

     * @param _tokenId id of the new owned token.

     * @param _value amount of owned tokens, 0 or 1 for ERC721 NFTs.

     */

    function _setMediatorOwns(

        address _token,

        uint256 _tokenId,

        uint256 _value

    ) internal {

        bytes32 key = _getStorageKey(_token, _tokenId);

        assembly {

            sstore(key, _value)

        }

    }



    function _getStorageKey(address _token, uint256 _tokenId) private pure returns (bytes32) {

        // same as boolStorage[keccak256(abi.encodePacked("mediatorOwns", _token, _tokenId))]

        return keccak256(abi.encodePacked(keccak256(abi.encodePacked("mediatorOwns", _token, _tokenId)), uint256(4)));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\NFTOmnibridgeInfo.sol
File type: .sol
pragma solidity 0.7.5;



import "../../../VersionableBridge.sol";



/**

 * @title NFTOmnibridgeInfo

 * @dev Functionality for versioning NFTOmnibridge mediator.

 */

contract NFTOmnibridgeInfo is VersionableBridge {

    event TokensBridgingInitiated(

        address indexed token,

        address indexed sender,

        uint256[] tokenIds,

        uint256[] values,

        bytes32 indexed messageId

    );

    event TokensBridged(

        address indexed token,

        address indexed recipient,

        uint256[] tokenIds,

        uint256[] values,

        bytes32 indexed messageId

    );



    /**

     * @dev Tells the bridge interface version that this contract supports.

     * @return major value of the version

     * @return minor value of the version

     * @return patch value of the version

     */

    function getBridgeInterfacesVersion()

        external

        pure

        override

        returns (

            uint64 major,

            uint64 minor,

            uint64 patch

        )

    {

        return (3, 1, 0);

    }



    /**

     * @dev Tells the bridge mode that this contract supports.

     * @return _data 4 bytes representing the bridge mode

     */

    function getBridgeMode() external pure override returns (bytes4 _data) {

        return 0xca7fc3dc; // bytes4(keccak256(abi.encodePacked("multi-nft-to-nft-amb")))

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\Ownable.sol
File type: .sol
pragma solidity 0.7.5;



import "../upgradeability/EternalStorage.sol";

import "../interfaces/IUpgradeabilityOwnerStorage.sol";



/**

 * @title Ownable

 * @dev This contract has an owner address providing basic authorization control

 */

contract Ownable is EternalStorage {

    bytes4 internal constant UPGRADEABILITY_OWNER = 0x6fde8202; // upgradeabilityOwner()



    /**

     * @dev Event to show ownership has been transferred

     * @param previousOwner representing the address of the previous owner

     * @param newOwner representing the address of the new owner

     */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(msg.sender == owner());

        _;

    }



    /**

     * @dev Throws if called through proxy by any account other than contract itself or an upgradeability owner.

     */

    modifier onlyRelevantSender() {

        (bool isProxy, bytes memory returnData) =

            address(this).staticcall(abi.encodeWithSelector(UPGRADEABILITY_OWNER));

        require(

            !isProxy || // covers usage without calling through storage proxy

                (returnData.length == 32 && msg.sender == abi.decode(returnData, (address))) || // covers usage through regular proxy calls

                msg.sender == address(this) // covers calls through upgradeAndCall proxy method

        );

        _;

    }



    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked("owner"))



    /**

     * @dev Tells the address of the owner

     * @return the address of the owner

     */

    function owner() public view returns (address) {

        return addressStorage[OWNER];

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner the address to transfer ownership to.

     */

    function transferOwnership(address newOwner) external onlyOwner {

        _setOwner(newOwner);

    }



    /**

     * @dev Sets a new owner address

     */

    function _setOwner(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner(), newOwner);

        addressStorage[OWNER] = newOwner;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\Proxy.sol
File type: .sol
pragma solidity 0.7.5;



/**

 * @title Proxy

 * @dev Gives the possibility to delegate any call to a foreign implementation.

 */

abstract contract Proxy {

    /**

     * @dev Tells the address of the implementation where every call will be delegated.

     * @return address of the implementation to which it will be delegated

     */

    function implementation() public view virtual returns (address);



    /**

     * @dev Fallback function allowing to perform a delegatecall to the given implementation.

     * This function will return whatever the implementation call returns

     */

    fallback() external payable {

        // solhint-disable-previous-line no-complex-fallback

        address _impl = implementation();

        require(_impl != address(0));

        assembly {

            /*

                0x40 is the "free memory slot", meaning a pointer to next slot of empty memory. mload(0x40)

                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty

                memory. It's needed because we're going to write the return data of delegatecall to the

                free memory slot.

            */

            let ptr := mload(0x40)

            /*

                `calldatacopy` is copy calldatasize bytes from calldata

                First argument is the destination to which data is copied(ptr)

                Second argument specifies the start position of the copied data.

                    Since calldata is sort of its own unique location in memory,

                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.

                    That's always going to be the zeroth byte of the function selector.

                Third argument, calldatasize, specifies how much data will be copied.

                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)

            */

            calldatacopy(ptr, 0, calldatasize())

            /*

                delegatecall params explained:

                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives

                    us the amount of gas still available to execution



                _impl: address of the contract to delegate to



                ptr: to pass copied data



                calldatasize: loads the size of `bytes memory data`, same as msg.data.length



                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,

                        these are set to 0, 0 so the output data will not be written to memory. The output

                        data will be read using `returndatasize` and `returdatacopy` instead.



                result: This will be 0 if the call fails and 1 if it succeeds

            */

            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)

            /*



            */

            /*

                ptr current points to the value stored at 0x40,

                because we assigned it like ptr := mload(0x40).

                Because we use 0x40 as a free memory pointer,

                we want to make sure that the next time we want to allocate memory,

                we aren't overwriting anything important.

                So, by adding ptr and returndatasize,

                we get a memory location beyond the end of the data we will be copying to ptr.

                We place this in at 0x40, and any reads from 0x40 will now read from free memory

            */

            mstore(0x40, add(ptr, returndatasize()))

            /*

                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the

                    slot it will copy to, 0 means copy from the beginning of the return data, and size is

                    the amount of data to copy.

                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall

            */

            returndatacopy(ptr, 0, returndatasize())



            /*

                if `result` is 0, revert.

                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was

                copied to `ptr` from the delegatecall return data

            */

            switch result

                case 0 {

                    revert(ptr, returndatasize())

                }

                default {

                    return(ptr, returndatasize())

                }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\ReentrancyGuard.sol
File type: .sol
pragma solidity 0.7.5;



contract ReentrancyGuard {

    function lock() internal view returns (bool res) {

        assembly {

            // Even though this is not the same as boolStorage[keccak256(abi.encodePacked("lock"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            res := sload(0x6168652c307c1e813ca11cfb3a601f1cf3b22452021a5052d8b05f1f1f8a3e92) // keccak256(abi.encodePacked("lock"))

        }

    }



    function setLock(bool _lock) internal {

        assembly {

            // Even though this is not the same as boolStorage[keccak256(abi.encodePacked("lock"))],

            // since solidity mapping introduces another level of addressing, such slot change is safe

            // for temporary variables which are cleared at the end of the call execution.

            sstore(0x6168652c307c1e813ca11cfb3a601f1cf3b22452021a5052d8b05f1f1f8a3e92, _lock) // keccak256(abi.encodePacked("lock"))

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\SafeMath.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        uint256 c = a + b;

        if (c < a) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the substraction of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b > a) return (false, 0);

        return (true, a - b);

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) return (true, 0);

        uint256 c = a * b;

        if (c / a != b) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the division of two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a / b);

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a % b);

    }



    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");

        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        return a - b;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) return 0;

        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");

        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: division by zero");

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: modulo by zero");

        return a % b;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {trySub}.

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        return a - b;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryDiv}.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting with custom message when dividing by zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryMod}.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a % b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\Strings.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.7.0;



/**

 * @dev String operations.

 */

library Strings {

    /**

     * @dev Converts a `uint256` to its ASCII `string` representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        uint256 index = digits - 1;

        temp = value;

        while (temp != 0) {

            buffer[index--] = bytes1(uint8(48 + temp % 10));

            temp /= 10;

        }

        return string(buffer);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\TokenImageStorage.sol
File type: .sol
pragma solidity 0.7.5;



import "@openzeppelin/contracts/utils/Address.sol";

import "../../../Ownable.sol";



/**

 * @title TokenImageStorage

 * @dev Storage functionality for working with ERC721/ERC1155 image contract.

 */

contract TokenImageStorage is Ownable {

    bytes32 internal constant ERC721_TOKEN_IMAGE_CONTRACT =

        0x20b8ca26cc94f39fab299954184cf3a9bd04f69543e4f454fab299f015b8130f; // keccak256(abi.encodePacked("tokenImageContract"))

    bytes32 internal constant ERC1155_TOKEN_IMAGE_CONTRACT =

        0x02e1d283efd236e8b97cefe072f0c863fa2db9f9ba42b0eca53ab31c49067a67; // keccak256(abi.encodePacked("erc1155tokenImageContract"))



    /**

     * @dev Updates address of the used ERC721 token image.

     * Only owner can call this method.

     * @param _image address of the new token image.

     */

    function setTokenImageERC721(address _image) external onlyOwner {

        _setTokenImageERC721(_image);

    }



    /**

     * @dev Updates address of the used ERC1155 token image.

     * Only owner can call this method.

     * @param _image address of the new token image.

     */

    function setTokenImageERC1155(address _image) external onlyOwner {

        _setTokenImageERC1155(_image);

    }



    /**

     * @dev Tells the address of the used ERC721 token image.

     * @return address of the used token image.

     */

    function tokenImageERC721() public view returns (address) {

        return addressStorage[ERC721_TOKEN_IMAGE_CONTRACT];

    }



    /**

     * @dev Tells the address of the used ERC1155 token image.

     * @return address of the used token image.

     */

    function tokenImageERC1155() public view returns (address) {

        return addressStorage[ERC1155_TOKEN_IMAGE_CONTRACT];

    }



    /**

     * @dev Internal function for updating address of the used ERC721 token image.

     * @param _image address of the new token image.

     */

    function _setTokenImageERC721(address _image) internal {

        require(Address.isContract(_image));

        addressStorage[ERC721_TOKEN_IMAGE_CONTRACT] = _image;

    }



    /**

     * @dev Internal function for updating address of the used ERC1155 token image.

     * @param _image address of the new token image.

     */

    function _setTokenImageERC1155(address _image) internal {

        require(Address.isContract(_image));

        addressStorage[ERC1155_TOKEN_IMAGE_CONTRACT] = _image;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\Upgradeable.sol
File type: .sol
pragma solidity 0.7.5;



import "../interfaces/IUpgradeabilityOwnerStorage.sol";



contract Upgradeable {

    // Avoid using onlyUpgradeabilityOwner name to prevent issues with implementation from proxy contract

    modifier onlyIfUpgradeabilityOwner() {

        require(msg.sender == IUpgradeabilityOwnerStorage(address(this)).upgradeabilityOwner());

        _;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\VersionableBridge.sol
File type: .sol
pragma solidity 0.7.5;



interface VersionableBridge {

    function getBridgeInterfacesVersion()

        external

        pure

        returns (

            uint64 major,

            uint64 minor,

            uint64 patch

        );



    function getBridgeMode() external pure returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\WETHOmnibridgeRouter.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-10-16

*/



// File: contracts/interfaces/IOmnibridge.sol



pragma solidity 0.7.5;



interface IOmnibridge {

    function relayTokens(

        address _token,

        address _receiver,

        uint256 _value

    ) external;



    function relayTokensAndCall(

        address token,

        address _receiver,

        uint256 _value,

        bytes memory _data

    ) external;

}



// File: contracts/interfaces/IWETH.sol



pragma solidity 0.7.5;



interface IWETH {

    function deposit() external payable;



    function withdraw(uint256 _value) external;



    function approve(address _to, uint256 _value) external;

}



// File: contracts/upgradeable_contracts/Sacrifice.sol



pragma solidity 0.7.5;



contract Sacrifice {

    constructor(address payable _recipient) payable {

        selfdestruct(_recipient);

    }

}



// File: contracts/libraries/AddressHelper.sol



pragma solidity 0.7.5;





/**

 * @title AddressHelper

 * @dev Helper methods for Address type.

 */

library AddressHelper {

    /**

     * @dev Try to send native tokens to the address. If it fails, it will force the transfer by creating a selfdestruct contract

     * @param _receiver address that will receive the native tokens

     * @param _value the amount of native tokens to send

     */

    function safeSendValue(address payable _receiver, uint256 _value) internal {

        if (!(_receiver).send(_value)) {

            new Sacrifice{ value: _value }(_receiver);

        }

    }

}



// File: contracts/libraries/Bytes.sol



pragma solidity 0.7.5;



/**

 * @title Bytes

 * @dev Helper methods to transform bytes to other solidity types.

 */

library Bytes {

    /**

     * @dev Truncate bytes array if its size is more than 20 bytes.

     * NOTE: This function does not perform any checks on the received parameter.

     * Make sure that the _bytes argument has a correct length, not less than 20 bytes.

     * A case when _bytes has length less than 20 will lead to the undefined behaviour,

     * since assembly will read data from memory that is not related to the _bytes argument.

     * @param _bytes to be converted to address type

     * @return addr address included in the firsts 20 bytes of the bytes array in parameter.

     */

    function bytesToAddress(bytes memory _bytes) internal pure returns (address addr) {

        assembly {

            addr := mload(add(_bytes, 20))

        }

    }

}



// File: @openzeppelin/contracts/utils/Address.sol





pragma solidity ^0.7.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: contracts/upgradeable_contracts/modules/OwnableModule.sol



pragma solidity 0.7.5;





/**

 * @title OwnableModule

 * @dev Common functionality for multi-token extension non-upgradeable module.

 */

contract OwnableModule {

    address public owner;



    /**

     * @dev Initializes this contract.

     * @param _owner address of the owner that is allowed to perform additional actions on the particular module.

     */

    constructor(address _owner) {

        owner = _owner;

    }



    /**

     * @dev Throws if sender is not the owner of this contract.

     */

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    /**

     * @dev Changes the owner of this contract.

     * @param _newOwner address of the new owner.

     */

    function transferOwnership(address _newOwner) external onlyOwner {

        owner = _newOwner;

    }

}



// File: @openzeppelin/contracts/token/ERC20/IERC20.sol





pragma solidity ^0.7.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: @openzeppelin/contracts/math/SafeMath.sol





pragma solidity ^0.7.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol





pragma solidity ^0.7.0;









/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



// File: contracts/upgradeable_contracts/Claimable.sol



pragma solidity 0.7.5;







/**

 * @title Claimable

 * @dev Implementation of the claiming utils that can be useful for withdrawing accidentally sent tokens that are not used in bridge operations.

 */

contract Claimable {

    using SafeERC20 for IERC20;



    /**

     * Throws if a given address is equal to address(0)

     */

    modifier validAddress(address _to) {

        require(_to != address(0));

        _;

    }



    /**

     * @dev Withdraws the erc20 tokens or native coins from this contract.

     * Caller should additionally check that the claimed token is not a part of bridge operations (i.e. that token != erc20token()).

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimValues(address _token, address _to) internal validAddress(_to) {

        if (_token == address(0)) {

            claimNativeCoins(_to);

        } else {

            claimErc20Tokens(_token, _to);

        }

    }



    /**

     * @dev Internal function for withdrawing all native coins from the contract.

     * @param _to address of the coins receiver.

     */

    function claimNativeCoins(address _to) internal {

        uint256 value = address(this).balance;

        AddressHelper.safeSendValue(payable(_to), value);

    }



    /**

     * @dev Internal function for withdrawing all tokens of some particular ERC20 contract from this contract.

     * @param _token address of the claimed ERC20 token.

     * @param _to address of the tokens receiver.

     */

    function claimErc20Tokens(address _token, address _to) internal {

        IERC20 token = IERC20(_token);

        uint256 balance = token.balanceOf(address(this));

        token.safeTransfer(_to, balance);

    }

}



// File: contracts/helpers/WETHOmnibridgeRouter.sol



pragma solidity 0.7.5;















/**

 * @title WETHOmnibridgeRouter

 * @dev Omnibridge extension for processing native and wrapped native assets.

 * Intended to work with WETH/WBNB/WXDAI tokens, see:

 *   https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2

 *   https://bscscan.com/address/0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c

 *   https://blockscout.com/poa/xdai/address/0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d

 */

contract WETHOmnibridgeRouter is OwnableModule, Claimable {

    IOmnibridge public immutable bridge;

    IWETH public immutable WETH;



    /**

     * @dev Initializes this contract.

     * @param _bridge address of the HomeOmnibridge/ForeignOmnibridge contract.

     * @param _weth address of the WETH token used for wrapping/unwrapping native coins (e.g. WETH/WBNB/WXDAI).

     * @param _owner address of the contract owner.

     */

    constructor(

        IOmnibridge _bridge,

        IWETH _weth,

        address _owner

    ) OwnableModule(_owner) {

        bridge = _bridge;

        WETH = _weth;

        _weth.approve(address(_bridge), uint256(-1));

    }



    /**

     * @dev Wraps native assets and relays wrapped ERC20 tokens to the other chain.

     * Call msg.sender will receive assets on the other side of the bridge.

     */

    function wrapAndRelayTokens() external payable {

        wrapAndRelayTokens(msg.sender);

    }



    /**

     * @dev Wraps native assets and relays wrapped ERC20 tokens to the other chain.

     * @param _receiver bridged assets receiver on the other side of the bridge.

     */

    function wrapAndRelayTokens(address _receiver) public payable {

        WETH.deposit{ value: msg.value }();

        bridge.relayTokens(address(WETH), _receiver, msg.value);

    }



    /**

     * @dev Wraps native assets and relays wrapped ERC20 tokens to the other chain.

     * It also calls receiver on other side with the _data provided.

     * @param _receiver bridged assets receiver on the other side of the bridge.

     * @param _data data for the call of receiver on other side.

     */

    function wrapAndRelayTokens(address _receiver, bytes memory _data) public payable {

        WETH.deposit{ value: msg.value }();

        bridge.relayTokensAndCall(address(WETH), _receiver, msg.value, _data);

    }



    /**

     * @dev Bridged callback function used for unwrapping received tokens.

     * Can only be called by the associated Omnibridge contract.

     * @param _token bridged token contract address, should be WETH.

     * @param _value amount of bridged/received tokens.

     * @param _data extra data passed alongside with relayTokensAndCall on the other side of the bridge.

     * Should contain coins receiver address.

     */

    function onTokenBridged(

        address _token,

        uint256 _value,

        bytes memory _data

    ) external {

        require(_token == address(WETH));

        require(msg.sender == address(bridge));

        require(_data.length == 20);



        WETH.withdraw(_value);



        AddressHelper.safeSendValue(payable(Bytes.bytesToAddress(_data)), _value);

    }



    /**

     * @dev Claims stuck coins/tokens.

     * Only contract owner can call this method.

     * @param _token address of claimed token contract, address(0) for native coins.

     * @param _to address of tokens receiver

     */

    function claimTokens(address _token, address _to) external onlyOwner {

        claimValues(_token, _to);

    }



    /**

     * @dev Ether receive function.

     * Should be only called from the WETH contract when withdrawing native coins. Will revert otherwise.

     */

    receive() external payable {

        require(msg.sender == address(WETH));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\xDai Bridge\contracts\XDaiForeignBridge.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-10-05

*/



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol



pragma solidity ^0.4.24;





/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * See https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address _who) public view returns (uint256);

  function transfer(address _to, uint256 _value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.4.24;







/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

  function allowance(address _owner, address _spender)

    public view returns (uint256);



  function transferFrom(address _from, address _to, uint256 _value)

    public returns (bool);



  function approve(address _spender, uint256 _value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}



// File: openzeppelin-solidity/contracts/AddressUtils.sol



pragma solidity ^0.4.24;





/**

 * Utility library of inline functions on addresses

 */

library AddressUtils {



  /**

   * Returns whether the target address is a contract

   * @dev This function will return false if invoked during the constructor of a contract,

   * as the code is not actually created until after the constructor finishes.

   * @param _addr address to check

   * @return whether the target address is a contract

   */

  function isContract(address _addr) internal view returns (bool) {

    uint256 size;

    // XXX Currently there is no better way to check if there is a contract in an address

    // than to check the size of the code at that address.

    // See https://ethereum.stackexchange.com/a/14016/36603

    // for more details about how this works.

    // TODO Check this again before the Serenity release, because all addresses will be

    // contracts then.

    // solium-disable-next-line security/no-inline-assembly

    assembly { size := extcodesize(_addr) }

    return size > 0;

  }



}



// File: contracts/upgradeability/EternalStorage.sol



pragma solidity 0.4.24;



/**

 * @title EternalStorage

 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.

 */

contract EternalStorage {

    mapping(bytes32 => uint256) internal uintStorage;

    mapping(bytes32 => string) internal stringStorage;

    mapping(bytes32 => address) internal addressStorage;

    mapping(bytes32 => bytes) internal bytesStorage;

    mapping(bytes32 => bool) internal boolStorage;

    mapping(bytes32 => int256) internal intStorage;



}



// File: contracts/interfaces/IBridgeValidators.sol



pragma solidity 0.4.24;



interface IBridgeValidators {

    function isValidator(address _validator) external view returns (bool);

    function requiredSignatures() external view returns (uint256);

    function owner() external view returns (address);

}



// File: contracts/upgradeable_contracts/ValidatorStorage.sol



pragma solidity 0.4.24;



contract ValidatorStorage {

    bytes32 internal constant VALIDATOR_CONTRACT = 0x5a74bb7e202fb8e4bf311841c7d64ec19df195fee77d7e7ae749b27921b6ddfe; // keccak256(abi.encodePacked("validatorContract"))

}



// File: contracts/upgradeable_contracts/Validatable.sol



pragma solidity 0.4.24;









contract Validatable is EternalStorage, ValidatorStorage {

    function validatorContract() public view returns (IBridgeValidators) {

        return IBridgeValidators(addressStorage[VALIDATOR_CONTRACT]);

    }



    modifier onlyValidator() {

        require(validatorContract().isValidator(msg.sender));

        /* solcov ignore next */

        _;

    }



    function requiredSignatures() public view returns (uint256) {

        return validatorContract().requiredSignatures();

    }



}



// File: contracts/libraries/Message.sol



pragma solidity 0.4.24;





library Message {

    function addressArrayContains(address[] array, address value) internal pure returns (bool) {

        for (uint256 i = 0; i < array.length; i++) {

            if (array[i] == value) {

                return true;

            }

        }

        return false;

    }

    // layout of message :: bytes:

    // offset  0: 32 bytes :: uint256 - message length

    // offset 32: 20 bytes :: address - recipient address

    // offset 52: 32 bytes :: uint256 - value

    // offset 84: 32 bytes :: bytes32 - transaction hash

    // offset 116: 20 bytes :: address - contract address to prevent double spending



    // mload always reads 32 bytes.

    // so we can and have to start reading recipient at offset 20 instead of 32.

    // if we were to read at 32 the address would contain part of value and be corrupted.

    // when reading from offset 20 mload will read 12 bytes (most of them zeros) followed

    // by the 20 recipient address bytes and correctly convert it into an address.

    // this saves some storage/gas over the alternative solution

    // which is padding address to 32 bytes and reading recipient at offset 32.

    // for more details see discussion in:

    // https://github.com/paritytech/parity-bridge/issues/61

    function parseMessage(bytes message)

        internal

        pure

        returns (address recipient, uint256 amount, bytes32 txHash, address contractAddress)

    {

        require(isMessageValid(message));

        assembly {

            recipient := mload(add(message, 20))

            amount := mload(add(message, 52))

            txHash := mload(add(message, 84))

            contractAddress := mload(add(message, 104))

        }

    }



    function isMessageValid(bytes _msg) internal pure returns (bool) {

        return _msg.length == requiredMessageLength();

    }



    function requiredMessageLength() internal pure returns (uint256) {

        return 104;

    }



    function recoverAddressFromSignedMessage(bytes signature, bytes message, bool isAMBMessage)

        internal

        pure

        returns (address)

    {

        require(signature.length == 65);

        bytes32 r;

        bytes32 s;

        bytes1 v;



        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := mload(add(signature, 0x60))

        }

        require(uint8(v) == 27 || uint8(v) == 28);

        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0);



        return ecrecover(hashMessage(message, isAMBMessage), uint8(v), r, s);

    }



    function hashMessage(bytes message, bool isAMBMessage) internal pure returns (bytes32) {

        bytes memory prefix = "\x19Ethereum Signed Message:\n";

        if (isAMBMessage) {

            return keccak256(abi.encodePacked(prefix, uintToString(message.length), message));

        } else {

            string memory msgLength = "104";

            return keccak256(abi.encodePacked(prefix, msgLength, message));

        }

    }



    /**

    * @dev Validates provided signatures, only first requiredSignatures() number

    * of signatures are going to be validated, these signatures should be from different validators.

    * @param _message bytes message used to generate signatures

    * @param _signatures bytes blob with signatures to be validated.

    * First byte X is a number of signatures in a blob,

    * next X bytes are v components of signatures,

    * next 32 * X bytes are r components of signatures,

    * next 32 * X bytes are s components of signatures.

    * @param _validatorContract contract, which conforms to the IBridgeValidators interface,

    * where info about current validators and required signatures is stored.

    * @param isAMBMessage true if _message is an AMB message with arbitrary length.

    */

    function hasEnoughValidSignatures(

        bytes _message,

        bytes _signatures,

        IBridgeValidators _validatorContract,

        bool isAMBMessage

    ) internal view {

        require(isAMBMessage || isMessageValid(_message));

        uint256 requiredSignatures = _validatorContract.requiredSignatures();

        uint256 amount;

        assembly {

            amount := and(mload(add(_signatures, 1)), 0xff)

        }

        require(amount >= requiredSignatures);

        bytes32 hash = hashMessage(_message, isAMBMessage);

        address[] memory encounteredAddresses = new address[](requiredSignatures);



        for (uint256 i = 0; i < requiredSignatures; i++) {

            uint8 v;

            bytes32 r;

            bytes32 s;

            uint256 posr = 33 + amount + 32 * i;

            uint256 poss = posr + 32 * amount;

            assembly {

                v := mload(add(_signatures, add(2, i)))

                r := mload(add(_signatures, posr))

                s := mload(add(_signatures, poss))

            }



            address recoveredAddress = ecrecover(hash, v, r, s);

            require(_validatorContract.isValidator(recoveredAddress));

            require(!addressArrayContains(encounteredAddresses, recoveredAddress));

            encounteredAddresses[i] = recoveredAddress;

        }

    }



    function uintToString(uint256 i) internal pure returns (string) {

        if (i == 0) return "0";

        uint256 j = i;

        uint256 length;

        while (j != 0) {

            length++;

            j /= 10;

        }

        bytes memory bstr = new bytes(length);

        uint256 k = length - 1;

        while (i != 0) {

            bstr[k--] = bytes1(48 + (i % 10));

            i /= 10;

        }

        return string(bstr);

    }

}



// File: contracts/upgradeable_contracts/MessageRelay.sol



pragma solidity 0.4.24;





contract MessageRelay is EternalStorage {

    function relayedMessages(bytes32 _txHash) public view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("relayedMessages", _txHash))];

    }



    function setRelayedMessages(bytes32 _txHash, bool _status) internal {

        boolStorage[keccak256(abi.encodePacked("relayedMessages", _txHash))] = _status;

    }

}



// File: contracts/interfaces/IUpgradeabilityOwnerStorage.sol



pragma solidity 0.4.24;



interface IUpgradeabilityOwnerStorage {

    function upgradeabilityOwner() external view returns (address);

}



// File: contracts/upgradeable_contracts/Upgradeable.sol



pragma solidity 0.4.24;





contract Upgradeable {

    // Avoid using onlyUpgradeabilityOwner name to prevent issues with implementation from proxy contract

    modifier onlyIfUpgradeabilityOwner() {

        require(msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner());

        /* solcov ignore next */

        _;

    }

}



// File: contracts/upgradeable_contracts/Initializable.sol



pragma solidity 0.4.24;





contract Initializable is EternalStorage {

    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked("isInitialized"))



    function setInitialize() internal {

        boolStorage[INITIALIZED] = true;

    }



    function isInitialized() public view returns (bool) {

        return boolStorage[INITIALIZED];

    }

}



// File: contracts/upgradeable_contracts/InitializableBridge.sol



pragma solidity 0.4.24;





contract InitializableBridge is Initializable {

    bytes32 internal constant DEPLOYED_AT_BLOCK = 0xb120ceec05576ad0c710bc6e85f1768535e27554458f05dcbb5c65b8c7a749b0; // keccak256(abi.encodePacked("deployedAtBlock"))



    function deployedAtBlock() external view returns (uint256) {

        return uintStorage[DEPLOYED_AT_BLOCK];

    }

}



// File: contracts/upgradeable_contracts/Ownable.sol



pragma solidity 0.4.24;







/**

 * @title Ownable

 * @dev This contract has an owner address providing basic authorization control

 */

contract Ownable is EternalStorage {

    bytes4 internal constant UPGRADEABILITY_OWNER = 0x6fde8202; // upgradeabilityOwner()



    /**

    * @dev Event to show ownership has been transferred

    * @param previousOwner representing the address of the previous owner

    * @param newOwner representing the address of the new owner

    */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner());

        /* solcov ignore next */

        _;

    }



    /**

    * @dev Throws if called by any account other than contract itself or owner.

    */

    modifier onlyRelevantSender() {

        // proxy owner if used through proxy, address(0) otherwise

        require(

            !address(this).call(abi.encodeWithSelector(UPGRADEABILITY_OWNER)) || // covers usage without calling through storage proxy

                msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner() || // covers usage through regular proxy calls

                msg.sender == address(this) // covers calls through upgradeAndCall proxy method

        );

        /* solcov ignore next */

        _;

    }



    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked("owner"))



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function owner() public view returns (address) {

        return addressStorage[OWNER];

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner the address to transfer ownership to.

    */

    function transferOwnership(address newOwner) external onlyOwner {

        _setOwner(newOwner);

    }



    /**

    * @dev Sets a new owner address

    */

    function _setOwner(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner(), newOwner);

        addressStorage[OWNER] = newOwner;

    }

}



// File: contracts/upgradeable_contracts/Sacrifice.sol



pragma solidity 0.4.24;



contract Sacrifice {

    constructor(address _recipient) public payable {

        selfdestruct(_recipient);

    }

}



// File: contracts/libraries/Address.sol



pragma solidity 0.4.24;





/**

 * @title Address

 * @dev Helper methods for Address type.

 */

library Address {

    /**

    * @dev Try to send native tokens to the address. If it fails, it will force the transfer by creating a selfdestruct contract

    * @param _receiver address that will receive the native tokens

    * @param _value the amount of native tokens to send

    */

    function safeSendValue(address _receiver, uint256 _value) internal {

        if (!_receiver.send(_value)) {

            (new Sacrifice).value(_value)(_receiver);

        }

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.4.24;





/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (_a == 0) {

      return 0;

    }



    c = _a * _b;

    assert(c / _a == _b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {

    // assert(_b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = _a / _b;

    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold

    return _a / _b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {

    assert(_b <= _a);

    return _a - _b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    c = _a + _b;

    assert(c >= _a);

    return c;

  }

}



// File: contracts/interfaces/ERC677.sol



pragma solidity 0.4.24;





contract ERC677 is ERC20 {

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);



    function transferAndCall(address, uint256, bytes) external returns (bool);



    function increaseAllowance(address spender, uint256 addedValue) public returns (bool);

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool);

}



contract LegacyERC20 {

    function transfer(address _spender, uint256 _value) public; // returns (bool);

    function transferFrom(address _owner, address _spender, uint256 _value) public; // returns (bool);

}



// File: contracts/libraries/SafeERC20.sol



pragma solidity 0.4.24;







/**

 * @title SafeERC20

 * @dev Helper methods for safe token transfers.

 * Functions perform additional checks to be sure that token transfer really happened.

 */

library SafeERC20 {

    using SafeMath for uint256;



    /**

    * @dev Same as ERC20.transfer(address,uint256) but with extra consistency checks.

    * @param _token address of the token contract

    * @param _to address of the receiver

    * @param _value amount of tokens to send

    */

    function safeTransfer(address _token, address _to, uint256 _value) internal {

        LegacyERC20(_token).transfer(_to, _value);

        assembly {

            if returndatasize {

                returndatacopy(0, 0, 32)

                if iszero(mload(0)) {

                    revert(0, 0)

                }

            }

        }

    }



    /**

    * @dev Same as ERC20.transferFrom(address,address,uint256) but with extra consistency checks.

    * @param _token address of the token contract

    * @param _from address of the sender

    * @param _value amount of tokens to send

    */

    function safeTransferFrom(address _token, address _from, uint256 _value) internal {

        LegacyERC20(_token).transferFrom(_from, address(this), _value);

        assembly {

            if returndatasize {

                returndatacopy(0, 0, 32)

                if iszero(mload(0)) {

                    revert(0, 0)

                }

            }

        }

    }

}



// File: contracts/upgradeable_contracts/Claimable.sol



pragma solidity 0.4.24;







/**

 * @title Claimable

 * @dev Implementation of the claiming utils that can be useful for withdrawing accidentally sent tokens that are not used in bridge operations.

 */

contract Claimable {

    using SafeERC20 for address;



    /**

     * Throws if a given address is equal to address(0)

     */

    modifier validAddress(address _to) {

        require(_to != address(0));

        /* solcov ignore next */

        _;

    }



    /**

     * @dev Withdraws the erc20 tokens or native coins from this contract.

     * Caller should additionally check that the claimed token is not a part of bridge operations (i.e. that token != erc20token()).

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimValues(address _token, address _to) internal validAddress(_to) {

        if (_token == address(0)) {

            claimNativeCoins(_to);

        } else {

            claimErc20Tokens(_token, _to);

        }

    }



    /**

     * @dev Internal function for withdrawing all native coins from the contract.

     * @param _to address of the coins receiver.

     */

    function claimNativeCoins(address _to) internal {

        uint256 value = address(this).balance;

        Address.safeSendValue(_to, value);

    }



    /**

     * @dev Internal function for withdrawing all tokens of ssome particular ERC20 contract from this contract.

     * @param _token address of the claimed ERC20 token.

     * @param _to address of the tokens receiver.

     */

    function claimErc20Tokens(address _token, address _to) internal {

        ERC20Basic token = ERC20Basic(_token);

        uint256 balance = token.balanceOf(this);

        _token.safeTransfer(_to, balance);

    }

}



// File: contracts/upgradeable_contracts/VersionableBridge.sol



pragma solidity 0.4.24;



contract VersionableBridge {

    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {

        return (6, 1, 0);

    }



    /* solcov ignore next */

    function getBridgeMode() external pure returns (bytes4);

}



// File: contracts/upgradeable_contracts/DecimalShiftBridge.sol



pragma solidity 0.4.24;







contract DecimalShiftBridge is EternalStorage {

    using SafeMath for uint256;



    bytes32 internal constant DECIMAL_SHIFT = 0x1e8ecaafaddea96ed9ac6d2642dcdfe1bebe58a930b1085842d8fc122b371ee5; // keccak256(abi.encodePacked("decimalShift"))



    /**

    * @dev Internal function for setting the decimal shift for bridge operations.

    * Decimal shift can be positive, negative, or equal to zero.

    * It has the following meaning: N tokens in the foreign chain are equivalent to N * pow(10, shift) tokens on the home side.

    * @param _shift new value of decimal shift.

    */

    function _setDecimalShift(int256 _shift) internal {

        // since 1 wei * 10**77 > 2**255, it does not make any sense to use higher values

        require(_shift > -77 && _shift < 77);

        uintStorage[DECIMAL_SHIFT] = uint256(_shift);

    }



    /**

    * @dev Returns the value of foreign-to-home decimal shift.

    * @return decimal shift.

    */

    function decimalShift() public view returns (int256) {

        return int256(uintStorage[DECIMAL_SHIFT]);

    }



    /**

    * @dev Converts the amount of home tokens into the equivalent amount of foreign tokens.

    * @param _value amount of home tokens.

    * @return equivalent amount of foreign tokens.

    */

    function _unshiftValue(uint256 _value) internal view returns (uint256) {

        return _shiftUint(_value, -decimalShift());

    }



    /**

    * @dev Converts the amount of foreign tokens into the equivalent amount of home tokens.

    * @param _value amount of foreign tokens.

    * @return equivalent amount of home tokens.

    */

    function _shiftValue(uint256 _value) internal view returns (uint256) {

        return _shiftUint(_value, decimalShift());

    }



    /**

    * @dev Calculates _value * pow(10, _shift).

    * @param _value amount of tokens.

    * @param _shift decimal shift to apply.

    * @return shifted value.

    */

    function _shiftUint(uint256 _value, int256 _shift) private pure returns (uint256) {

        if (_shift == 0) {

            return _value;

        }

        if (_shift > 0) {

            return _value.mul(10**uint256(_shift));

        }

        return _value.div(10**uint256(-_shift));

    }

}



// File: contracts/upgradeable_contracts/BasicBridge.sol



pragma solidity 0.4.24;



















contract BasicBridge is

    InitializableBridge,

    Validatable,

    Ownable,

    Upgradeable,

    Claimable,

    VersionableBridge,

    DecimalShiftBridge

{

    event GasPriceChanged(uint256 gasPrice);

    event RequiredBlockConfirmationChanged(uint256 requiredBlockConfirmations);



    bytes32 internal constant GAS_PRICE = 0x55b3774520b5993024893d303890baa4e84b1244a43c60034d1ced2d3cf2b04b; // keccak256(abi.encodePacked("gasPrice"))

    bytes32 internal constant REQUIRED_BLOCK_CONFIRMATIONS = 0x916daedf6915000ff68ced2f0b6773fe6f2582237f92c3c95bb4d79407230071; // keccak256(abi.encodePacked("requiredBlockConfirmations"))



    /**

    * @dev Public setter for fallback gas price value. Only bridge owner can call this method.

    * @param _gasPrice new value for the gas price.

    */

    function setGasPrice(uint256 _gasPrice) external onlyOwner {

        _setGasPrice(_gasPrice);

    }



    function gasPrice() external view returns (uint256) {

        return uintStorage[GAS_PRICE];

    }



    function setRequiredBlockConfirmations(uint256 _blockConfirmations) external onlyOwner {

        _setRequiredBlockConfirmations(_blockConfirmations);

    }



    function _setRequiredBlockConfirmations(uint256 _blockConfirmations) internal {

        require(_blockConfirmations > 0);

        uintStorage[REQUIRED_BLOCK_CONFIRMATIONS] = _blockConfirmations;

        emit RequiredBlockConfirmationChanged(_blockConfirmations);

    }



    function requiredBlockConfirmations() external view returns (uint256) {

        return uintStorage[REQUIRED_BLOCK_CONFIRMATIONS];

    }



    /**

    * @dev Internal function for updating fallback gas price value.

    * @param _gasPrice new value for the gas price, zero gas price is allowed.

    */

    function _setGasPrice(uint256 _gasPrice) internal {

        uintStorage[GAS_PRICE] = _gasPrice;

        emit GasPriceChanged(_gasPrice);

    }

}



// File: contracts/upgradeable_contracts/BasicTokenBridge.sol



pragma solidity 0.4.24;











contract BasicTokenBridge is EternalStorage, Ownable, DecimalShiftBridge {

    using SafeMath for uint256;



    event DailyLimitChanged(uint256 newLimit);

    event ExecutionDailyLimitChanged(uint256 newLimit);



    bytes32 internal constant MIN_PER_TX = 0xbbb088c505d18e049d114c7c91f11724e69c55ad6c5397e2b929e68b41fa05d1; // keccak256(abi.encodePacked("minPerTx"))

    bytes32 internal constant MAX_PER_TX = 0x0f8803acad17c63ee38bf2de71e1888bc7a079a6f73658e274b08018bea4e29c; // keccak256(abi.encodePacked("maxPerTx"))

    bytes32 internal constant DAILY_LIMIT = 0x4a6a899679f26b73530d8cf1001e83b6f7702e04b6fdb98f3c62dc7e47e041a5; // keccak256(abi.encodePacked("dailyLimit"))

    bytes32 internal constant EXECUTION_MAX_PER_TX = 0xc0ed44c192c86d1cc1ba51340b032c2766b4a2b0041031de13c46dd7104888d5; // keccak256(abi.encodePacked("executionMaxPerTx"))

    bytes32 internal constant EXECUTION_DAILY_LIMIT = 0x21dbcab260e413c20dc13c28b7db95e2b423d1135f42bb8b7d5214a92270d237; // keccak256(abi.encodePacked("executionDailyLimit"))



    function totalSpentPerDay(uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _day))];

    }



    function totalExecutedPerDay(uint256 _day) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _day))];

    }



    function dailyLimit() public view returns (uint256) {

        return uintStorage[DAILY_LIMIT];

    }



    function executionDailyLimit() public view returns (uint256) {

        return uintStorage[EXECUTION_DAILY_LIMIT];

    }



    function maxPerTx() public view returns (uint256) {

        return uintStorage[MAX_PER_TX];

    }



    function executionMaxPerTx() public view returns (uint256) {

        return uintStorage[EXECUTION_MAX_PER_TX];

    }



    function minPerTx() public view returns (uint256) {

        return uintStorage[MIN_PER_TX];

    }



    function withinLimit(uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalSpentPerDay(getCurrentDay()).add(_amount);

        return dailyLimit() >= nextLimit && _amount <= maxPerTx() && _amount >= minPerTx();

    }



    function withinExecutionLimit(uint256 _amount) public view returns (bool) {

        uint256 nextLimit = totalExecutedPerDay(getCurrentDay()).add(_amount);

        return executionDailyLimit() >= nextLimit && _amount <= executionMaxPerTx();

    }



    function getCurrentDay() public view returns (uint256) {

        return now / 1 days;

    }



    function addTotalSpentPerDay(uint256 _day, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("totalSpentPerDay", _day))] = totalSpentPerDay(_day).add(_value);

    }



    function addTotalExecutedPerDay(uint256 _day, uint256 _value) internal {

        uintStorage[keccak256(abi.encodePacked("totalExecutedPerDay", _day))] = totalExecutedPerDay(_day).add(_value);

    }



    function setDailyLimit(uint256 _dailyLimit) external onlyOwner {

        require(_dailyLimit > maxPerTx() || _dailyLimit == 0);

        uintStorage[DAILY_LIMIT] = _dailyLimit;

        emit DailyLimitChanged(_dailyLimit);

    }



    function setExecutionDailyLimit(uint256 _dailyLimit) external onlyOwner {

        require(_dailyLimit > executionMaxPerTx() || _dailyLimit == 0);

        uintStorage[EXECUTION_DAILY_LIMIT] = _dailyLimit;

        emit ExecutionDailyLimitChanged(_dailyLimit);

    }



    function setExecutionMaxPerTx(uint256 _maxPerTx) external onlyOwner {

        require(_maxPerTx < executionDailyLimit());

        uintStorage[EXECUTION_MAX_PER_TX] = _maxPerTx;

    }



    function setMaxPerTx(uint256 _maxPerTx) external onlyOwner {

        require(_maxPerTx == 0 || (_maxPerTx > minPerTx() && _maxPerTx < dailyLimit()));

        uintStorage[MAX_PER_TX] = _maxPerTx;

    }



    function setMinPerTx(uint256 _minPerTx) external onlyOwner {

        require(_minPerTx > 0 && _minPerTx < dailyLimit() && _minPerTx < maxPerTx());

        uintStorage[MIN_PER_TX] = _minPerTx;

    }



    /**

    * @dev Retrieves maximum available bridge amount per one transaction taking into account maxPerTx() and dailyLimit() parameters.

    * @return minimum of maxPerTx parameter and remaining daily quota.

    */

    function maxAvailablePerTx() public view returns (uint256) {

        uint256 _maxPerTx = maxPerTx();

        uint256 _dailyLimit = dailyLimit();

        uint256 _spent = totalSpentPerDay(getCurrentDay());

        uint256 _remainingOutOfDaily = _dailyLimit > _spent ? _dailyLimit - _spent : 0;

        return _maxPerTx < _remainingOutOfDaily ? _maxPerTx : _remainingOutOfDaily;

    }



    function _setLimits(uint256[3] _limits) internal {

        require(

            _limits[2] > 0 && // minPerTx > 0

                _limits[1] > _limits[2] && // maxPerTx > minPerTx

                _limits[0] > _limits[1] // dailyLimit > maxPerTx

        );



        uintStorage[DAILY_LIMIT] = _limits[0];

        uintStorage[MAX_PER_TX] = _limits[1];

        uintStorage[MIN_PER_TX] = _limits[2];



        emit DailyLimitChanged(_limits[0]);

    }



    function _setExecutionLimits(uint256[2] _limits) internal {

        require(_limits[1] < _limits[0]); // foreignMaxPerTx < foreignDailyLimit



        uintStorage[EXECUTION_DAILY_LIMIT] = _limits[0];

        uintStorage[EXECUTION_MAX_PER_TX] = _limits[1];



        emit ExecutionDailyLimitChanged(_limits[0]);

    }

}



// File: contracts/upgradeable_contracts/BasicForeignBridge.sol



pragma solidity 0.4.24;



















contract BasicForeignBridge is EternalStorage, Validatable, BasicBridge, BasicTokenBridge, MessageRelay {

    /// triggered when relay of deposit from HomeBridge is complete

    event RelayedMessage(address recipient, uint256 value, bytes32 transactionHash);

    event UserRequestForAffirmation(address recipient, uint256 value);



    /**

    * @dev Validates provided signatures and relays a given message

    * @param message bytes to be relayed

    * @param signatures bytes blob with signatures to be validated

    */

    function executeSignatures(bytes message, bytes signatures) external {

        Message.hasEnoughValidSignatures(message, signatures, validatorContract(), false);



        address recipient;

        uint256 amount;

        bytes32 txHash;

        address contractAddress;

        (recipient, amount, txHash, contractAddress) = Message.parseMessage(message);

        if (withinExecutionLimit(amount)) {

            require(contractAddress == address(this));

            require(!relayedMessages(txHash));

            setRelayedMessages(txHash, true);

            require(onExecuteMessage(recipient, amount, txHash));

            emit RelayedMessage(recipient, amount, txHash);

        } else {

            onFailedMessage(recipient, amount, txHash);

        }

    }



    /**

    * @dev Internal function for updating fallback gas price value.

    * @param _gasPrice new value for the gas price, zero gas price is not allowed.

    */

    function _setGasPrice(uint256 _gasPrice) internal {

        require(_gasPrice > 0);

        super._setGasPrice(_gasPrice);

    }



    /* solcov ignore next */

    function onExecuteMessage(address, uint256, bytes32) internal returns (bool);



    /* solcov ignore next */

    function onFailedMessage(address, uint256, bytes32) internal;

}



// File: contracts/upgradeable_contracts/ERC20Bridge.sol



pragma solidity 0.4.24;









contract ERC20Bridge is BasicForeignBridge {

    bytes32 internal constant ERC20_TOKEN = 0x15d63b18dbc21bf4438b7972d80076747e1d93c4f87552fe498c90cbde51665e; // keccak256(abi.encodePacked("erc20token"))



    function erc20token() public view returns (ERC20) {

        return ERC20(addressStorage[ERC20_TOKEN]);

    }



    function setErc20token(address _token) internal {

        require(AddressUtils.isContract(_token));

        addressStorage[ERC20_TOKEN] = _token;

    }



    function relayTokens(address _receiver, uint256 _amount) external {

        require(_receiver != address(0));

        require(_receiver != address(this));

        require(_amount > 0);

        require(withinLimit(_amount));

        addTotalSpentPerDay(getCurrentDay(), _amount);



        erc20token().transferFrom(msg.sender, address(this), _amount);

        emit UserRequestForAffirmation(_receiver, _amount);

    }

}



// File: contracts/upgradeable_contracts/OtherSideBridgeStorage.sol



pragma solidity 0.4.24;





contract OtherSideBridgeStorage is EternalStorage {

    bytes32 internal constant BRIDGE_CONTRACT = 0x71483949fe7a14d16644d63320f24d10cf1d60abecc30cc677a340e82b699dd2; // keccak256(abi.encodePacked("bridgeOnOtherSide"))



    function _setBridgeContractOnOtherSide(address _bridgeContract) internal {

        require(_bridgeContract != address(0));

        addressStorage[BRIDGE_CONTRACT] = _bridgeContract;

    }



    function bridgeContractOnOtherSide() internal view returns (address) {

        return addressStorage[BRIDGE_CONTRACT];

    }

}



// File: contracts/upgradeable_contracts/erc20_to_native/ForeignBridgeErcToNative.sol



pragma solidity 0.4.24;







contract ForeignBridgeErcToNative is ERC20Bridge, OtherSideBridgeStorage {

    function initialize(

        address _validatorContract,

        address _erc20token,

        uint256 _requiredBlockConfirmations,

        uint256 _gasPrice,

        uint256[3] _dailyLimitMaxPerTxMinPerTxArray, // [ 0 = _dailyLimit, 1 = _maxPerTx, 2 = _minPerTx ]

        uint256[2] _homeDailyLimitHomeMaxPerTxArray, //[ 0 = _homeDailyLimit, 1 = _homeMaxPerTx ]

        address _owner,

        int256 _decimalShift,

        address _bridgeOnOtherSide

    ) external onlyRelevantSender returns (bool) {

        require(!isInitialized());

        require(AddressUtils.isContract(_validatorContract));



        addressStorage[VALIDATOR_CONTRACT] = _validatorContract;

        setErc20token(_erc20token);

        uintStorage[DEPLOYED_AT_BLOCK] = block.number;

        _setRequiredBlockConfirmations(_requiredBlockConfirmations);

        _setGasPrice(_gasPrice);

        _setLimits(_dailyLimitMaxPerTxMinPerTxArray);

        _setExecutionLimits(_homeDailyLimitHomeMaxPerTxArray);

        _setDecimalShift(_decimalShift);

        _setOwner(_owner);

        _setBridgeContractOnOtherSide(_bridgeOnOtherSide);

        setInitialize();



        return isInitialized();

    }



    function getBridgeMode() external pure returns (bytes4 _data) {

        return 0x18762d46; // bytes4(keccak256(abi.encodePacked("erc-to-native-core")))

    }



    /**

     * @dev Withdraws the erc20 tokens or native coins from this contract.

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimTokens(address _token, address _to) external onlyIfUpgradeabilityOwner {

        // Since bridged tokens are locked at this contract, it is not allowed to claim them with the use of claimTokens function

        require(_token != address(erc20token()));

        claimValues(_token, _to);

    }



    function onExecuteMessage(

        address _recipient,

        uint256 _amount,

        bytes32 /*_txHash*/

    ) internal returns (bool) {

        addTotalExecutedPerDay(getCurrentDay(), _amount);

        return erc20token().transfer(_recipient, _unshiftValue(_amount));

    }



    function onFailedMessage(address, uint256, bytes32) internal {

        revert();

    }



    function relayTokens(address _receiver, uint256 _amount) external {

        require(_receiver != bridgeContractOnOtherSide());

        require(_receiver != address(0));

        require(_receiver != address(this));

        require(_amount > 0);

        require(withinLimit(_amount));



        addTotalSpentPerDay(getCurrentDay(), _amount);



        erc20token().transferFrom(msg.sender, address(this), _amount);

        emit UserRequestForAffirmation(_receiver, _amount);

    }

}



// File: contracts/interfaces/IInterestReceiver.sol



pragma solidity 0.4.24;



interface IInterestReceiver {

    function onInterestReceived(address _token) external;

}



// File: contracts/upgradeable_contracts/erc20_to_native/InterestConnector.sol



pragma solidity 0.4.24;









/**

 * @title InterestConnector

 * @dev This contract gives an abstract way of receiving interest on locked tokens.

 */

contract InterestConnector is Ownable, ERC20Bridge {

    event PaidInterest(address indexed token, address to, uint256 value);



    /**

     * @dev Throws if interest is bearing not enabled.

     * @param token address, for which interest should be enabled.

     */

    modifier interestEnabled(address token) {

        require(isInterestEnabled(token));

        /* solcov ignore next */

        _;

    }



    /**

     * @dev Ensures that caller is an EOA.

     * Functions with such modifier cannot be called from other contract (as well as from GSN-like approaches)

     */

    modifier onlyEOA {

        // solhint-disable-next-line avoid-tx-origin

        require(msg.sender == tx.origin);

        /* solcov ignore next */

        _;

    }



    /**

     * @dev Tells if interest earning was enabled for particular token.

     * @return true, if interest bearing  is enabled.

     */

    function isInterestEnabled(address _token) public view returns (bool) {

        return boolStorage[keccak256(abi.encodePacked("interestEnabled", _token))];

    }



    /**

     * @dev Initializes interest receiving functionality.

     * Only owner can call this method.

     * @param _token address of the token for interest earning.

     * @param _minCashThreshold minimum amount of underlying tokens that are not invested.

     * @param _minInterestPaid minimum amount of interest that can be paid in a single call.

     */

    function initializeInterest(

        address _token,

        uint256 _minCashThreshold,

        uint256 _minInterestPaid,

        address _interestReceiver

    ) external onlyOwner {

        require(_isInterestSupported(_token));

        require(!isInterestEnabled(_token));



        _setInterestEnabled(_token, true);

        _setMinCashThreshold(_token, _minCashThreshold);

        _setMinInterestPaid(_token, _minInterestPaid);

        _setInterestReceiver(_token, _interestReceiver);

    }



    /**

     * @dev Sets minimum amount of tokens that cannot be invested.

     * Only owner can call this method.

     * @param _token address of the token contract.

     * @param _minCashThreshold minimum amount of underlying tokens that are not invested.

     */

    function setMinCashThreshold(address _token, uint256 _minCashThreshold) external onlyOwner {

        _setMinCashThreshold(_token, _minCashThreshold);

    }



    /**

     * @dev Tells minimum amount of tokens that are not being invested.

     * @param _token address of the invested token contract.

     * @return amount of tokens.

     */

    function minCashThreshold(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("minCashThreshold", _token))];

    }



    /**

     * @dev Sets lower limit for the paid interest amount.

     * Only owner can call this method.

     * @param _token address of the token contract.

     * @param _minInterestPaid minimum amount of interest paid in a single call.

     */

    function setMinInterestPaid(address _token, uint256 _minInterestPaid) external onlyOwner {

        _setMinInterestPaid(_token, _minInterestPaid);

    }



    /**

     * @dev Tells minimum amount of paid interest in a single call.

     * @param _token address of the invested token contract.

     * @return paid interest minimum limit.

     */

    function minInterestPaid(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("minInterestPaid", _token))];

    }



    /**

     * @dev Internal function that disables interest for locked funds.

     * Only owner can call this method.

     * @param _token of token to disable interest for.

     */

    function disableInterest(address _token) external onlyOwner {

        _withdraw(_token, uint256(-1));

        _setInterestEnabled(_token, false);

    }



    /**

     * @dev Tells configured address of the interest receiver.

     * @param _token address of the invested token contract.

     * @return address of the interest receiver.

     */

    function interestReceiver(address _token) public view returns (address) {

        return addressStorage[keccak256(abi.encodePacked("interestReceiver", _token))];

    }



    /**

     * Updates the interest receiver address.

     * Only owner can call this method.

     * @param _token address of the invested token contract.

     * @param _receiver new receiver address.

     */

    function setInterestReceiver(address _token, address _receiver) external onlyOwner {

        _setInterestReceiver(_token, _receiver);

    }



    /**

     * @dev Pays collected interest for the specific underlying token.

     * Requires interest for the given token to be enabled.

     * @param _token address of the token contract.

     */

    function payInterest(address _token) external onlyEOA interestEnabled(_token) {

        uint256 interest = interestAmount(_token);

        require(interest >= minInterestPaid(_token));



        uint256 redeemed = _safeWithdrawTokens(_token, interest);

        _transferInterest(_token, redeemed);

    }



    /**

     * @dev Tells the amount of underlying tokens that are currently invested.

     * @param _token address of the token contract.

     * @return amount of underlying tokens.

     */

    function investedAmount(address _token) public view returns (uint256) {

        return uintStorage[keccak256(abi.encodePacked("investedAmount", _token))];

    }



    /**

     * @dev Invests all excess tokens.

     * Requires interest for the given token to be enabled.

     * @param _token address of the token contract considered.

     */

    function invest(address _token) public interestEnabled(_token) {

        uint256 balance = _selfBalance(_token);

        uint256 minCash = minCashThreshold(_token);



        require(balance > minCash);

        uint256 amount = balance - minCash;



        _setInvestedAmount(_token, investedAmount(_token).add(amount));



        _invest(_token, amount);

    }



    /**

     * @dev Internal function for transferring interest.

     * Calls a callback on the receiver, if it is a contract.

     * @param _token address of the underlying token contract.

     * @param _amount amount of collected tokens that should be sent.

     */

    function _transferInterest(address _token, uint256 _amount) internal {

        address receiver = interestReceiver(_token);

        require(receiver != address(0));



        ERC20(_token).transfer(receiver, _amount);



        if (AddressUtils.isContract(receiver)) {

            IInterestReceiver(receiver).onInterestReceived(_token);

        }



        emit PaidInterest(_token, receiver, _amount);

    }



    /**

     * @dev Internal function for setting interest enabled flag for some token.

     * @param _token address of the token contract.

     * @param _enabled true to enable interest earning, false to disable.

     */

    function _setInterestEnabled(address _token, bool _enabled) internal {

        boolStorage[keccak256(abi.encodePacked("interestEnabled", _token))] = _enabled;

    }



    /**

     * @dev Internal function for setting the amount of underlying tokens that are currently invested.

     * @param _token address of the token contract.

     * @param _amount new amount of invested tokens.

     */

    function _setInvestedAmount(address _token, uint256 _amount) internal {

        uintStorage[keccak256(abi.encodePacked("investedAmount", _token))] = _amount;

    }



    /**

     * @dev Internal function for withdrawing some amount of the invested tokens.

     * Reverts if given amount cannot be withdrawn.

     * @param _token address of the token contract withdrawn.

     * @param _amount amount of requested tokens to be withdrawn.

     */

    function _withdraw(address _token, uint256 _amount) internal {

        if (_amount == 0) return;



        uint256 invested = investedAmount(_token);

        uint256 withdrawal = _amount > invested ? invested : _amount;

        uint256 redeemed = _safeWithdrawTokens(_token, withdrawal);



        _setInvestedAmount(_token, invested > redeemed ? invested - redeemed : 0);

    }



    /**

     * @dev Internal function for safe withdrawal of invested tokens.

     * Reverts if given amount cannot be withdrawn.

     * Additionally verifies that at least _amount of tokens were withdrawn.

     * @param _token address of the token contract withdrawn.

     * @param _amount amount of requested tokens to be withdrawn.

     */

    function _safeWithdrawTokens(address _token, uint256 _amount) private returns (uint256) {

        uint256 balance = _selfBalance(_token);



        _withdrawTokens(_token, _amount);



        uint256 redeemed = _selfBalance(_token) - balance;



        require(redeemed >= _amount);



        return redeemed;

    }



    /**

     * @dev Internal function for setting minimum amount of tokens that cannot be invested.

     * @param _token address of the token contract.

     * @param _minCashThreshold minimum amount of underlying tokens that are not invested.

     */

    function _setMinCashThreshold(address _token, uint256 _minCashThreshold) internal {

        uintStorage[keccak256(abi.encodePacked("minCashThreshold", _token))] = _minCashThreshold;

    }



    /**

     * @dev Internal function for setting lower limit for paid interest amount.

     * @param _token address of the token contract.

     * @param _minInterestPaid minimum amount of interest paid in a single call.

     */

    function _setMinInterestPaid(address _token, uint256 _minInterestPaid) internal {

        uintStorage[keccak256(abi.encodePacked("minInterestPaid", _token))] = _minInterestPaid;

    }



    /**

     * @dev Internal function for setting interest receiver address.

     * @param _token address of the invested token contract.

     * @param _receiver address of the interest receiver.

     */

    function _setInterestReceiver(address _token, address _receiver) internal {

        require(_receiver != address(this));

        addressStorage[keccak256(abi.encodePacked("interestReceiver", _token))] = _receiver;

    }



    /**

     * @dev Tells this contract balance of some specific token contract

     * @param _token address of the token contract.

     * @return contract balance.

     */

    function _selfBalance(address _token) internal view returns (uint256) {

        return ERC20(_token).balanceOf(address(this));

    }



    function _isInterestSupported(address _token) internal pure returns (bool);



    function _invest(address _token, uint256 _amount) internal;



    function _withdrawTokens(address _token, uint256 _amount) internal;



    function interestAmount(address _token) public view returns (uint256);

}



// File: contracts/interfaces/ICToken.sol



pragma solidity 0.4.24;



interface ICToken {

    function mint(uint256 mintAmount) external returns (uint256);

    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function balanceOfUnderlying(address account) external view returns (uint256);

    function borrow(uint256 borrowAmount) external returns (uint256);

    function repayBorrow(uint256 borrowAmount) external returns (uint256);

}



// File: contracts/interfaces/IComptroller.sol



pragma solidity 0.4.24;



interface IComptroller {

    function claimComp(address[] holders, address[] cTokens, bool borrowers, bool suppliers) external;

}



// File: contracts/upgradeable_contracts/erc20_to_native/CompoundConnector.sol



pragma solidity 0.4.24;









/**

 * @title CompoundConnector

 * @dev This contract allows to partially invest locked Dai tokens into Compound protocol.

 */

contract CompoundConnector is InterestConnector {

    uint256 internal constant SUCCESS = 0;



    /**

     * @dev Tells the address of the DAI token in the Ethereum Mainnet.

     */

    function daiToken() public pure returns (ERC20) {

        return ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);

    }



    /**

     * @dev Tells the address of the cDAI token in the Ethereum Mainnet.

     */

    function cDaiToken() public pure returns (ICToken) {

        return ICToken(0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643);

    }



    /**

     * @dev Tells the address of the Comptroller contract in the Ethereum Mainnet.

     */

    function comptroller() public pure returns (IComptroller) {

        return IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);

    }



    /**

     * @dev Tells the address of the COMP token in the Ethereum Mainnet.

     */

    function compToken() public pure returns (ERC20) {

        return ERC20(0xc00e94Cb662C3520282E6f5717214004A7f26888);

    }



    /**

     * @dev Tells the current earned interest amount.

     * @param _token address of the underlying token contract.

     * @return total amount of interest that can be withdrawn now.

     */

    function interestAmount(address _token) public view returns (uint256) {

        uint256 underlyingBalance = cDaiToken().balanceOfUnderlying(address(this));

        // 1 DAI is reserved for possible truncation/round errors

        uint256 invested = investedAmount(_token) + 1 ether;

        return underlyingBalance > invested ? underlyingBalance - invested : 0;

    }



    /**

     * @dev Tells if interest earning is supported for the specific token contract.

     * @param _token address of the token contract.

     * @return true, if interest earning is supported.

     */

    function _isInterestSupported(address _token) internal pure returns (bool) {

        return _token == address(daiToken());

    }



    /**

     * @dev Invests the given amount of tokens to the Compound protocol.

     * Converts _amount of TOKENs into X cTOKENs.

     * @param _token address of the token contract.

     * @param _amount amount of tokens to invest.

     */

    function _invest(address _token, uint256 _amount) internal {

        (_token);

        daiToken().approve(address(cDaiToken()), _amount);

        require(cDaiToken().mint(_amount) == SUCCESS);

    }



    /**

     * @dev Withdraws at least the given amount of tokens from the Compound protocol.

     * Converts X cTOKENs into _amount of TOKENs.

     * @param _token address of the token contract.

     * @param _amount minimal amount of tokens to withdraw.

     */

    function _withdrawTokens(address _token, uint256 _amount) internal {

        (_token);

        require(cDaiToken().redeemUnderlying(_amount) == SUCCESS);

    }



    /**

     * @dev Claims Comp token and transfers it to the associated interest receiver.

     */

    function claimCompAndPay() external onlyEOA {

        address[] memory holders = new address[](1);

        holders[0] = address(this);

        address[] memory markets = new address[](1);

        markets[0] = address(cDaiToken());

        comptroller().claimComp(holders, markets, false, true);



        address comp = address(compToken());

        uint256 interest = _selfBalance(comp);

        require(interest >= minInterestPaid(comp));

        _transferInterest(comp, interest);

    }

}



// File: contracts/gsn/interfaces/IRelayRecipient.sol



// SPDX-License-Identifier:MIT

pragma solidity 0.4.24;



/**

 * a contract must implement this interface in order to support relayed transaction.

 * It is better to inherit the BaseRelayRecipient as its implementation.

 */

contract IRelayRecipient {

    /**

     * return if the forwarder is trusted to forward relayed transactions to us.

     * the forwarder is required to verify the sender's signature, and verify

     * the call is not a replay.

     */

    function isTrustedForwarder(address forwarder) public view returns (bool);



    /**

     * return the sender of this call.

     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes

     * of the msg.data.

     * otherwise, return `msg.sender`

     * should be used in the contract anywhere instead of msg.sender

     */

    function _msgSender() internal view returns (address);



    /**

     * return the msg.data of this call.

     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes

     * of the msg.data - so this method will strip those 20 bytes off.

     * otherwise, return `msg.data`

     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly

     * signing or hashing the

     */

    function _msgData() internal view returns (bytes memory);



    function versionRecipient() external view returns (string memory);

}



// File: contracts/gsn/BaseRelayRecipient.sol



// SPDX-License-Identifier:MIT

// solhint-disable no-inline-assembly

pragma solidity 0.4.24;





/**

 * A base contract to be inherited by any contract that want to receive relayed transactions

 * A subclass must use "_msgSender()" instead of "msg.sender"

 */

contract BaseRelayRecipient is IRelayRecipient {

    /**

     * return the sender of this call.

     * if the call came through our trusted forwarder, return the original sender.

     * otherwise, return `msg.sender`.

     * should be used in the contract anywhere instead of msg.sender

     */

    function _msgSender() internal view returns (address ret) {

        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {

            // At this point we know that the sender is a trusted forwarder,

            // so we trust that the last bytes of msg.data are the verified sender address.

            // extract sender address from the end of msg.data

            assembly {

                ret := shr(96, calldataload(sub(calldatasize, 20)))

            }

        } else {

            return msg.sender;

        }

    }



    /**

     * return the msg.data of this call.

     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes

     * of the msg.data - so this method will strip those 20 bytes off.

     * otherwise, return `msg.data`

     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly

     * signing or hashing the

     */

    function _msgData() internal view returns (bytes memory ret) {

        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {

            // At this point we know that the sender is a trusted forwarder,

            // we copy the msg.data , except the last 20 bytes (and update the total length)

            assembly {

                let ptr := mload(0x40)

                // copy only size-20 bytes

                let size := sub(calldatasize, 20)

                // structure RLP data as <offset> <length> <bytes>

                mstore(ptr, 0x20)

                mstore(add(ptr, 32), size)

                calldatacopy(add(ptr, 64), 0, size)

                return(ptr, add(size, 64))

            }

        } else {

            return msg.data;

        }

    }

}



// File: contracts/gsn/interfaces/IKnowForwarderAddress.sol



// SPDX-License-Identifier:MIT

pragma solidity 0.4.24;



interface IKnowForwarderAddress {

    /**

     * return the forwarder we trust to forward relayed transactions to us.

     * the forwarder is required to verify the sender's signature, and verify

     * the call is not a replay.

     */

    function getTrustedForwarder() external view returns (address);

}



// File: contracts/upgradeable_contracts/GSNForeignERC20Bridge.sol



pragma solidity 0.4.24;











contract GSNForeignERC20Bridge is BasicForeignBridge, ERC20Bridge, BaseRelayRecipient, IKnowForwarderAddress {

    bytes32 internal constant PAYMASTER = 0xfefcc139ed357999ed60c6a013947328d52e7d9751e93fd0274a2bfae5cbcb12; // keccak256(abi.encodePacked("paymaster"))

    bytes32 internal constant TRUSTED_FORWARDER = 0x222cb212229f0f9bcd249029717af6845ea3d3a84f22b54e5744ac25ef224c92; // keccak256(abi.encodePacked("trustedForwarder"))



    function versionRecipient() external view returns (string memory) {

        return "1.0.1";

    }



    function getTrustedForwarder() external view returns (address) {

        return addressStorage[TRUSTED_FORWARDER];

    }



    function setTrustedForwarder(address _trustedForwarder) public onlyOwner {

        addressStorage[TRUSTED_FORWARDER] = _trustedForwarder;

    }



    function isTrustedForwarder(address forwarder) public view returns (bool) {

        return forwarder == addressStorage[TRUSTED_FORWARDER];

    }



    function setPayMaster(address _paymaster) public onlyOwner {

        addressStorage[PAYMASTER] = _paymaster;

    }



    /**

    * @param message same as in `executeSignatures`

    * @param signatures same as in `executeSignatures`

    * @param maxTokensFee maximum amount of foreign tokens that user allows to take

    * as a commission

    */

    function executeSignaturesGSN(bytes message, bytes signatures, uint256 maxTokensFee) external {

        // Allow only forwarder calls

        require(isTrustedForwarder(msg.sender), "invalid forwarder");

        Message.hasEnoughValidSignatures(message, signatures, validatorContract(), false);



        address recipient;

        uint256 amount;

        bytes32 txHash;

        address contractAddress;

        (recipient, amount, txHash, contractAddress) = Message.parseMessage(message);

        if (withinExecutionLimit(amount)) {

            require(maxTokensFee <= amount);

            require(contractAddress == address(this));

            require(!relayedMessages(txHash));

            setRelayedMessages(txHash, true);

            require(onExecuteMessageGSN(recipient, amount, maxTokensFee));

            emit RelayedMessage(recipient, amount, txHash);

        } else {

            onFailedMessage(recipient, amount, txHash);

        }

    }



    function onExecuteMessageGSN(address recipient, uint256 amount, uint256 fee) internal returns (bool) {

        addTotalExecutedPerDay(getCurrentDay(), amount);

        // Send maxTokensFee to paymaster

        ERC20 token = erc20token();

        bool first = token.transfer(addressStorage[PAYMASTER], fee);

        bool second = token.transfer(recipient, amount - fee);



        return first && second;

    }

}



// File: contracts/upgradeable_contracts/erc20_to_native/XDaiForeignBridge.sol



pragma solidity 0.4.24;









contract XDaiForeignBridge is ForeignBridgeErcToNative, CompoundConnector, GSNForeignERC20Bridge {

    function initialize(

        address _validatorContract,

        address _erc20token,

        uint256 _requiredBlockConfirmations,

        uint256 _gasPrice,

        uint256[3] _dailyLimitMaxPerTxMinPerTxArray, // [ 0 = _dailyLimit, 1 = _maxPerTx, 2 = _minPerTx ]

        uint256[2] _homeDailyLimitHomeMaxPerTxArray, //[ 0 = _homeDailyLimit, 1 = _homeMaxPerTx ]

        address _owner,

        int256 _decimalShift,

        address _bridgeOnOtherSide

    ) external onlyRelevantSender returns (bool) {

        require(!isInitialized());

        require(AddressUtils.isContract(_validatorContract));

        require(_erc20token == address(daiToken()));

        require(_decimalShift == 0);



        addressStorage[VALIDATOR_CONTRACT] = _validatorContract;

        uintStorage[DEPLOYED_AT_BLOCK] = block.number;

        _setRequiredBlockConfirmations(_requiredBlockConfirmations);

        _setGasPrice(_gasPrice);

        _setLimits(_dailyLimitMaxPerTxMinPerTxArray);

        _setExecutionLimits(_homeDailyLimitHomeMaxPerTxArray);

        _setOwner(_owner);

        _setBridgeContractOnOtherSide(_bridgeOnOtherSide);

        setInitialize();



        return isInitialized();

    }



    function erc20token() public view returns (ERC20) {

        return daiToken();

    }



    // selector 6a641d80

    function migrateTo_6_1_0(address _interestReceiver) external {

        bytes32 upgradeStorage = 0x6a641d806674d4ce5e98c8fdab48e66c563660255f099d81d45fa2fe8ed9cc1d; // keccak256(abi.encodePacked('migrateTo_6_1_0(address)'))

        require(!boolStorage[upgradeStorage]);



        address dai = address(daiToken());

        address comp = address(compToken());

        _setInterestEnabled(dai, true);

        _setMinCashThreshold(dai, 1000000 ether);

        _setMinInterestPaid(dai, 1000 ether);

        _setInterestReceiver(dai, _interestReceiver);



        _setMinInterestPaid(comp, 1 ether);

        _setInterestReceiver(comp, _interestReceiver);



        invest(dai);



        boolStorage[upgradeStorage] = true;

    }



    function investDai() external {

        invest(address(daiToken()));

    }



    /**

     * @dev Withdraws the erc20 tokens or native coins from this contract.

     * @param _token address of the claimed token or address(0) for native coins.

     * @param _to address of the tokens/coins receiver.

     */

    function claimTokens(address _token, address _to) external onlyIfUpgradeabilityOwner {

        // Since bridged tokens are locked at this contract, it is not allowed to claim them with the use of claimTokens function

        address bridgedToken = address(daiToken());

        require(_token != address(bridgedToken));

        require(_token != address(cDaiToken()) || !isInterestEnabled(bridgedToken));

        require(_token != address(compToken()) || !isInterestEnabled(bridgedToken));

        claimValues(_token, _to);

    }



    function onExecuteMessage(

        address _recipient,

        uint256 _amount,

        bytes32 /*_txHash*/

    ) internal returns (bool) {

        addTotalExecutedPerDay(getCurrentDay(), _amount);



        ERC20 token = daiToken();

        ensureEnoughTokens(token, _amount);



        return token.transfer(_recipient, _amount);

    }



    function onExecuteMessageGSN(address recipient, uint256 amount, uint256 fee) internal returns (bool) {

        ensureEnoughTokens(daiToken(), amount);



        return super.onExecuteMessageGSN(recipient, amount, fee);

    }



    function ensureEnoughTokens(ERC20 token, uint256 amount) internal {

        uint256 currentBalance = token.balanceOf(address(this));



        if (currentBalance < amount) {

            uint256 withdrawAmount = (amount - currentBalance).add(minCashThreshold(address(token)));

            _withdraw(address(token), withdrawAmount);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------

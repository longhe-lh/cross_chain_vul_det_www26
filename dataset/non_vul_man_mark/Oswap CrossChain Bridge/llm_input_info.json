{
    "src_chain": {
        "NewOrder1": [],
        "RequestCancelOrder2": [],
        "RequestAmendOrder3": []
    },
    "rel_chain": {
        "Execute": [
            {
                "execute": "function execute(bytes[] calldata signatures, bytes32[] calldata params, uint256 nonce) external {\n require(params.length > 0, \"Invalid params length\");\n emit Execute(params);\n function executeHash(...) {...}\nbytes32 hash = executeHash(params, nonce);\n trollRegistry.verifySignatures(msg.sender, signatures, hash, nonce);\n bytes32 name = params[0];\n if (params.length == 1) {\n if (name == \"shutdown\") {\n trollRegistry.shutdownByVoting();\n return;\n } else if (name == \"resume\") {\n trollRegistry.resume();\n return;\n }\n } else {\n bytes32 param1 = params[1];\n if (params.length == 2) {\n if (name == \"upgradeConfigStore\") {\n configStore.upgrade(OSWAP_ConfigStore(address(bytes20(param1))));\n return;\n } else if (name == \"upgradeTrollRegistry\") {\n trollRegistry.upgrade(address(bytes20(param1)));\n return;\n }\n } else {\n bytes32 param2 = params[2];\n if (params.length == 3) {\n if (name == \"setConfig\") {\n configStore.setConfig(param1, param2);\n return;\n } else if (name == \"setConfigAddress\") {\n configStore.setConfigAddress(param1, param2);\n return;\n } else if (name == \"setVotingExecutor\") {\n trollRegistry.setVotingExecutor(address(bytes20(param1)), uint256(param2)!=0);\n return;\n }\n } else {\n bytes32 param3 = params[3];\n if (params.length == 4) {\n if (name == \"setConfig2\") {\n configStore.setConfig2(param1, param2, param3);\n return;\n }\n }\n }\n }\n }\n revert(\"Invalid parameters\");\n }"
            }
        ]
    },
    "det_chain": {
        "Swap1": [
            {
                "swap": "function swap(\n bytes[] calldata signatures,\n address _owner,\n uint256 _orderId,\n uint256 amendment,\n uint256 protocolFee,\n address[] calldata pair,\n Order calldata order\n ) external override nonReentrant whenNotPaused returns (uint256 amount) {\n bytes32 orderId = hashOrder(_owner, order.peerChain, _orderId);\n amount = order.inAmount;\n \n require(swapOrderStatus[orderId] == OrderStatus.NotSpecified,\"BridgeVault: Order already processed\");\n require(trollRegistry.isSuperTroll(msg.sender, true), \"not a super troll\");\n function lastKnownBalance(...) {...}\nrequire(lastKnownBalance() >= amount, \"BridgeVault: insufficient balance\");\n address router;\n uint256 price;\n {\n uint256 fee;\n address govTokenOracle;\n address assetTokenOracle;\n uint256 baseFee;\n uint256 transactionFee; \n IOSWAP_SwapPolicy swapPolicy;\n (swapPolicy, router, govTokenOracle, assetTokenOracle, baseFee, transactionFee) = configStore.getBridgeParams(asset);\n if (address(swapPolicy) != address(0)) {\n require(swapPolicy.allowToSwap(order), \"swap policy not met\");\n }\n transactionFee = amount * transactionFee / 1e18;\n fee = transactionFee + baseFee + protocolFee;\n require(amount > fee, \"Input amount too small\");\n imbalance -= toInt256(amount);\n lpAssetBalance += transactionFee;\n protocolFeeBalance += baseFee + protocolFee;\n price = assetPriceAgainstGovToken(govTokenOracle, assetTokenOracle);\n amount = amount - fee;\n }\n (uint256[] memory signers, ) = _verifyStakedValue(signatures, hashSwapParams(orderId, amendment, order, protocolFee, pair), amount * 1e18 / price);\n swapOrderStatus[orderId] = OrderStatus.Executed;\n if (pair.length == 0) {\n require(address(asset) == order.outToken, \"Invalid token\");\n require(amount >= order.minOutAmount, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n IERC20(order.outToken).safeTransfer(order.to, amount);\n } else {\n asset.safeIncreaseAllowance(address(router), amount);\n uint[] memory amounts;\n if (order.outToken == address(0)) {\n (, amounts) = IOSWAP_HybridRouter2(router).swapExactTokensForETH(amount, order.minOutAmount, pair, order.to, order.expire, \"0x00\");\n } else {\n address[] memory paths;\n (paths, amounts) = IOSWAP_HybridRouter2(router).swapExactTokensForTokens(amount, order.minOutAmount, pair, address(asset), order.to, order.expire, \"0x00\");\n require(paths[paths.length-1] == order.outToken,\"BridgeVault: Token out not match\");\n }\n amount = amounts[amounts.length-1];\n }\n emit Swap(_orderId, msg.sender, signers, _owner, amendment, order, amount, imbalance, lpAssetBalance, protocolFeeBalance);\n }"
            },
            {
                "_verifyStakedValue": "function _verifyStakedValue(address msgSender, bytes[] calldata signatures, bytes32 paramsHash) internal returns (uint256 superTrollCount, uint totalStake, uint256[] memory signers) {\n require(!usedNonce[paramsHash], \"nonce used\");\n usedNonce[paramsHash] = true;\n uint256 generalTrollCount;\n {\n uint256 length = signatures.length;\n signers = new uint256[](length);\n address lastSigningTroll;\n for (uint256 i = 0; i < length; ++i) {\n address troll = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", paramsHash)).recover(signatures[i]);\n require(troll != address(0), \"Invalid signer\");\n uint256 trollProfileIndex = trollRegistry.trollProfileInv(troll);\n if (trollProfileIndex > 0 && troll > lastSigningTroll) {\n signers[i] = trollProfileIndex;\n if (trollRegistry.isSuperTroll(troll, true)) {\n superTrollCount++;\n } else if (trollRegistry.isGeneralTroll(troll, true)) {\n generalTrollCount++;\n }\n totalStake += trollStakesBalances[trollProfileIndex];\n lastSigningTroll = troll;\n }\n }\n }\n (uint256 generalTrollMinCount, uint256 superTrollMinCount, uint256 transactionsGap) = configStore.getSignatureVerificationParams();\n require(generalTrollCount >= generalTrollMinCount, \"OSWAP_BridgeVault: Mininum general troll count not met\");\n require(superTrollCount >= superTrollMinCount, \"OSWAP_BridgeVault: Mininum super troll count not met\");\n \n uint256 _transactionsCount = (++transactionsCount);\n require((lastTrollTxCount[msgSender] + transactionsGap < _transactionsCount) || (_transactionsCount <= transactionsGap), \"too soon\");\n lastTrollTxCount[msgSender] = _transactionsCount;\n }"
            }
        ],
        "VoidOrder2": [
            {
                "voidOrder": "function voidOrder(bytes[] calldata signatures, bytes32 orderId) external override {\n require(swapOrderStatus[orderId] == OrderStatus.NotSpecified,\"BridgeVault: Order already processed\");\n (uint256[] memory signers, ) = _verifyStakedValue(signatures, hashVoidOrderParams(orderId), 0);\n swapOrderStatus[orderId] = OrderStatus.Cancelled;\n emit VoidOrder(orderId, msg.sender, signers);\n }"
            },
            {
                "_verifyStakedValue": "function _verifyStakedValue(address msgSender, bytes[] calldata signatures, bytes32 paramsHash) internal returns (uint256 superTrollCount, uint totalStake, uint256[] memory signers) {\n require(!usedNonce[paramsHash], \"nonce used\");\n usedNonce[paramsHash] = true;\n uint256 generalTrollCount;\n {\n uint256 length = signatures.length;\n signers = new uint256[](length);\n address lastSigningTroll;\n for (uint256 i = 0; i < length; ++i) {\n address troll = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", paramsHash)).recover(signatures[i]);\n require(troll != address(0), \"Invalid signer\");\n uint256 trollProfileIndex = trollRegistry.trollProfileInv(troll);\n if (trollProfileIndex > 0 && troll > lastSigningTroll) {\n signers[i] = trollProfileIndex;\n if (trollRegistry.isSuperTroll(troll, true)) {\n superTrollCount++;\n } else if (trollRegistry.isGeneralTroll(troll, true)) {\n generalTrollCount++;\n }\n totalStake += trollStakesBalances[trollProfileIndex];\n lastSigningTroll = troll;\n }\n }\n }\n (uint256 generalTrollMinCount, uint256 superTrollMinCount, uint256 transactionsGap) = configStore.getSignatureVerificationParams();\n require(generalTrollCount >= generalTrollMinCount, \"OSWAP_BridgeVault: Mininum general troll count not met\");\n require(superTrollCount >= superTrollMinCount, \"OSWAP_BridgeVault: Mininum super troll count not met\");\n \n uint256 _transactionsCount = (++transactionsCount);\n require((lastTrollTxCount[msgSender] + transactionsGap < _transactionsCount) || (_transactionsCount <= transactionsGap), \"too soon\");\n lastTrollTxCount[msgSender] = _transactionsCount;\n }"
            }
        ],
        "OrderCanceled3": [
            {
                "cancelOrder": "function cancelOrder(bytes[] calldata signatures, uint256 orderId, bool canceledByOrderOwner, uint256 protocolFee) external override whenNotPaused {\n Order storage order = orders[orderId];\n require(orderStatus[orderId] == OrderStatus.Pending || orderStatus[orderId] == OrderStatus.RequestAmend, \"BridgeVault: cancel not requested\");\n (,,address govTokenOracle, address assetTokenOracle, uint256 baseFee,) = configStore.getBridgeParams(asset);\n uint256 price = assetPriceAgainstGovToken(govTokenOracle, assetTokenOracle);\n (uint256[] memory signers, ) = _verifyStakedValue(signatures, hashCancelOrderParams(orderId, canceledByOrderOwner, protocolFee), order.inAmount * 1e18 / price);\n uint256 refundAmount = orders[orderId].inAmount;\n \n uint256 fee;\n if (canceledByOrderOwner) {\n fee = baseFee + protocolFee;\n refundAmount -= fee;\n imbalance -= toInt256(fee);\n protocolFeeBalance += fee;\n }\n orderRefunds[orderId] = refundAmount;\n orderStatus[orderId] = OrderStatus.RefundApproved;\n emit OrderCanceled(orderId, msg.sender, signers, canceledByOrderOwner, imbalance, protocolFeeBalance);\n }"
            },
            {
                "_verifyStakedValue": "function _verifyStakedValue(address msgSender, bytes[] calldata signatures, bytes32 paramsHash) internal returns (uint256 superTrollCount, uint totalStake, uint256[] memory signers) {\n require(!usedNonce[paramsHash], \"nonce used\");\n usedNonce[paramsHash] = true;\n uint256 generalTrollCount;\n {\n uint256 length = signatures.length;\n signers = new uint256[](length);\n address lastSigningTroll;\n for (uint256 i = 0; i < length; ++i) {\n address troll = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", paramsHash)).recover(signatures[i]);\n require(troll != address(0), \"Invalid signer\");\n uint256 trollProfileIndex = trollRegistry.trollProfileInv(troll);\n if (trollProfileIndex > 0 && troll > lastSigningTroll) {\n signers[i] = trollProfileIndex;\n if (trollRegistry.isSuperTroll(troll, true)) {\n superTrollCount++;\n } else if (trollRegistry.isGeneralTroll(troll, true)) {\n generalTrollCount++;\n }\n totalStake += trollStakesBalances[trollProfileIndex];\n lastSigningTroll = troll;\n }\n }\n }\n (uint256 generalTrollMinCount, uint256 superTrollMinCount, uint256 transactionsGap) = configStore.getSignatureVerificationParams();\n require(generalTrollCount >= generalTrollMinCount, \"OSWAP_BridgeVault: Mininum general troll count not met\");\n require(superTrollCount >= superTrollMinCount, \"OSWAP_BridgeVault: Mininum super troll count not met\");\n \n uint256 _transactionsCount = (++transactionsCount);\n require((lastTrollTxCount[msgSender] + transactionsGap < _transactionsCount) || (_transactionsCount <= transactionsGap), \"too soon\");\n lastTrollTxCount[msgSender] = _transactionsCount;\n }"
            }
        ]
    }
}
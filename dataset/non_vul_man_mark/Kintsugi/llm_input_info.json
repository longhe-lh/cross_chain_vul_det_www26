{
    "src_chain": {
        "CollectionMinted1": [
            {
                "purchaseFor": "function purchaseFor(\n bytes32 collectionId,\n address recipient\n ) public payable {\n require(!_msgSender().isContract(), \"cannot purchase from contract\");\n\n require(\n msg.value >= collections[collectionId].priceInWei,\n \"insufficient funds sent to purchase\"\n );\n\n Collection memory collection = getCollection(collectionId);\n\n bool allowedToMint = false;\n\n if (collection.useAllowList && collection.allowList.length > 0) {\n for (uint i = 0; i < collection.allowList.length; i++) {\n if (_msgSender() == collection.allowList[i]) {\n allowedToMint = true;\n\n break;\n }\n }\n } else {\n allowedToMint = true;\n }\n\n function mint(...) {...}\nrequire(allowedToMint, \"mint not approved\");\n\n mint(collectionId, _msgSender(), recipient);\n\n require(ownerAddresses.length > 0, \"no owner addresses\");\n\n require(\n ownerSplits.length == ownerAddresses.length,\n \"invalid owner splits\"\n );\n\n require(collection.creatorAddresses.length > 0, \"no creator addresses\");\n\n require(\n collection.creatorSplits.length ==\n collection.creatorAddresses.length,\n \"invalid creator splits\"\n );\n\n distributeFunds(collection);\n }"
            },
            {
                "mint": "function mint(\n bytes32 collectionId,\n address minter,\n address recipient\n ) internal {\n Collection memory collection = getCollection(collectionId);\n\n require(collections[collectionId].seed != 0, \"seed not set\");\n\n require(collection.active, \"collection inactive\");\n\n require(\n collection.minted + 1 <= collection.mintedMax,\n \"minted max tokens\"\n );\n\n require(\n collection.mintedMaxPerOwner == 0 ||\n ownerMints[collectionId][minter] < collection.mintedMaxPerOwner,\n \"minter exceeds max mints\"\n );\n\n uint256 nextTokenId = lastTokenId + 1;\n\n int32 seed = int32(\n int(\n uint(\n keccak256(\n abi.encodePacked(\n collection.seed,\n block.number,\n _msgSender(),\n recipient,\n nextTokenId\n )\n )\n )\n )\n );\n\n lastTokenId = nextTokenId;\n\n collectionTokens[collectionId].push(lastTokenId);\n\n tokenCollection[lastTokenId] = collectionId;\n\n collectionSeeds[collectionId].push(seed);\n\n tokenSeed[lastTokenId] = seed;\n\n collections[collectionId].minted = collection.minted + 1;\n\n ownerMints[collectionId][recipient] =\n ownerMints[collectionId][recipient] +\n 1;\n\n _safeMint(recipient, nextTokenId);\n\n emit CollectionMinted(\n collectionId,\n nextTokenId,\n recipient,\n collection.minted,\n collection.priceInWei,\n seed\n );\n\n if (collection.pauseAt > 0) {\n if (lastTokenId >= collection.pauseAt) _pause();\n }\n }"
            },
            {
                "_safeMint": "function _safeMint(address to, uint256 tokenId) internal virtual {\n _safeMint(to, tokenId, \"\");\n }"
            },
            {
                "_mint": "function _mint(address to, uint256 tokenId) internal virtual {\n require(to != address(0), \"ERC721: mint to the zero address\");\n\n function _exists(...) {...}\nrequire(!_exists(tokenId), \"ERC721: token already minted\");\n\n _beforeTokenTransfer(address(0), to, tokenId);\n\n _balances[to] += 1;\n\n _owners[tokenId] = to;\n\n emit Transfer(address(0), to, tokenId);\n }"
            }
        ]
    },
    "rel_chain": {
        "render": [
            {
                "render": "function render(\n IRenderer.RenderArgs memory args\n ) external view override returns (IRenderer.RenderArgs memory results) {\n require(msg.sender == _owner || msg.sender == _executor, \"denied\");\n\n require(args.index != -1, \"rendering is finished\");\n\n require(\n args.index >= 0 && args.index < 64,\n \"index must be in range 0-63\"\n );\n\n require(\n args.stage >= 0 && args.stage < 104,\n \"stage must be in range 0-103\"\n );\n\n require(args.seed != 0, \"seed not specified\");\n\n RandomV1.PRNG memory prng = RandomV1.buildSeedTable(args.seed);\n\n HatchLayer.HatchParameters memory hatch;\n\n {\n HatchLayer.HatchParameters memory h = HatchLayer.getParameters(\n prng\n );\n\n hatch = h;\n\n prng = h.prng;\n }\n\n WatercolorLayer.WatercolorParameters memory watercolors;\n\n {\n WatercolorLayer.WatercolorParameters memory w = WatercolorLayer\n .getParameters(prng);\n\n watercolors = w;\n\n prng = w.prng;\n }\n\n KintsugiLayer.KintsugiParameters memory kintsugi;\n\n {\n (\n KintsugiLayer.KintsugiParameters memory k,\n RandomV1.PRNG memory p\n ) = KintsugiLayer.getParameters(prng, args.seed);\n\n kintsugi = k;\n\n prng = p;\n }\n\n if (args.stage == 0) {\n return background_stage(args);\n } else if (args.stage == 1) {\n return hatch_stage(hatch, prng, args);\n } else if (args.stage > 1 && args.stage < 103) {\n return watercolor_stage(watercolors, args.prng, args);\n } else if (args.stage == 103) {\n return kintsugi_stage(kintsugi, args);\n } else {\n revert(\"invalid render arguments\");\n }\n }"
            },
            {
                "background": "function background(\n uint32[16384] memory result,\n uint32 color,\n TypesV1.Chunk2D memory chunk\n ) internal pure {\n for (uint256 x = 0; x < chunk.chunkWidth; x++) {\n for (uint256 y = 0; y < chunk.chunkHeight; y++) {\n GraphicsV1.setPixel(\n result,\n chunk.chunkWidth,\n int256(x),\n int256(y),\n color\n );\n }\n }\n }"
            },
            {
                "hatch_stage": "function hatch_stage(\n HatchLayer.HatchParameters memory hatch,\n RandomV1.PRNG memory prng,\n RenderArgs memory args\n ) private pure returns (IRenderer.RenderArgs memory results) {\n require(hatch.opacity > 0, \"opacity not set\");\n\n require(hatch.spacing > 0, \"spacing not set\");\n\n require(hatch.color > 0, \"color not set\");\n\n uint32[16384] memory buffer = HatchDraw.draw(\n HatchDraw.Draw(\n args.buffer,\n hatch,\n TypesV1.Chunk2D(\n uint16(args.index),\n 1024,\n 1024,\n 128,\n 128,\n (uint16(args.index) % 8) * 128,\n (uint16(args.index) / 8) * 128\n )\n )\n );\n\n return\n IRenderer.RenderArgs(\n args.index,\n args.stage + 1,\n args.seed,\n buffer,\n prng\n );\n }"
            },
            {
                "line": "function line(\n uint32[16384] memory result,\n GeometryV1.Line2D memory f\n ) internal pure {\n int256 x0 = f.v0.x;\n\n int256 x1 = f.v1.x;\n\n int256 y0 = f.v0.y;\n\n int256 y1 = f.v1.y;\n\n int256 dx = MathV1.abs(x1 - x0);\n\n int256 dy = MathV1.abs(y1 - y0);\n\n int256 err = (dx > dy ? dx : -dy) / 2;\n\n int256 e2;\n\n for (;;) {\n if (\n x0 <= int32(f.chunk.startX) + int16(f.chunk.chunkWidth) - 1 &&\n x0 >= int32(f.chunk.startX) &&\n y0 <= int32(f.chunk.startY) + int16(f.chunk.chunkHeight) - 1 &&\n y0 >= int32(f.chunk.startY)\n ) {\n GraphicsV1.setPixel(\n result,\n f.chunk.chunkWidth,\n x0 - int32(f.chunk.startX),\n y0 - int32(f.chunk.startY),\n f.color\n );\n }\n\n if (x0 == x1 && y0 == y1) break;\n\n e2 = err;\n\n if (e2 > -dx) {\n err -= dy;\n\n x0 += x0 < x1 ? int8(1) : -1;\n }\n\n if (e2 < dy) {\n err += dx;\n\n y0 += y0 < y1 ? int8(1) : -1;\n }\n }\n }"
            },
            {
                "watercolor_stage": "function watercolor_stage(\n WatercolorLayer.WatercolorParameters memory watercolors,\n RandomV1.PRNG memory prng,\n IRenderer.RenderArgs memory args\n ) private pure returns (IRenderer.RenderArgs memory results) {\n require(watercolors.stackCount > 0, \"stackCount not set\");\n\n require(watercolors.stackColors.length > 0, \"stackColors not set\");\n\n WatercolorLayer.StackList memory stackList;\n\n {\n WatercolorLayer.StackList memory s = WatercolorLayer.buildStackList(\n prng,\n watercolors\n );\n\n stackList = s;\n\n prng = s.prng;\n }\n\n uint32[16384] memory buffer = WatercolorDraw.draw(\n WatercolorDraw.Draw(\n args.buffer,\n watercolors,\n stackList,\n TypesV1.Chunk2D(\n uint16(args.index),\n 1024,\n 1024,\n 128,\n 128,\n (uint16(args.index) % 8) * 128,\n (uint16(args.index) / 8) * 128\n )\n )\n );\n\n return\n IRenderer.RenderArgs(\n args.index,\n args.stage + 1,\n args.seed,\n buffer,\n prng\n );\n }"
            },
            {
                "buildStackList": "function buildStackList(\n RandomV1.PRNG memory prng,\n WatercolorParameters memory p\n ) external pure returns (StackList memory stackList) {\n require(p.stackCount > 0 && p.stackCount < 5, \"invalid stack count\");\n\n for (uint8 i = 0; i < p.stackCount; i++) {\n (\n TypesV1.Point2D[MAX_POLYGONS] memory stack,\n uint32 vertexCount\n ) = createPolyStack(\n CreatePolyStack(p.r[i], p.basePoly[i], p.basePolyCount[i]),\n prng\n );\n\n if (i == 0) {\n stackList.stack1 = stack;\n\n stackList.stack1Count = vertexCount;\n } else if (i == 1) {\n stackList.stack2 = stack;\n\n stackList.stack2Count = vertexCount;\n } else if (i == 2) {\n stackList.stack3 = stack;\n\n stackList.stack3Count = vertexCount;\n } else if (i == 3) {\n stackList.stack4 = stack;\n\n stackList.stack4Count = vertexCount;\n }\n }\n\n stackList.prng = prng;\n }"
            },
            {
                "createPolyStack": "function createPolyStack(\n CreatePolyStack memory f,\n RandomV1.PRNG memory prng\n )\n private\n pure\n returns (TypesV1.Point2D[MAX_POLYGONS] memory stack, uint32 vertexCount)\n {\n int32 variance = RandomV1.next(\n prng,\n int32(Fix64V1.div(f.r, 10 * Fix64V1.ONE) >> 32),\n int32(Fix64V1.div(f.r, 4 * Fix64V1.ONE) >> 32)\n );\n\n (TypesV1.Point2D[MAX_POLYGONS] memory poly, uint32 polyCount) = deform(\n prng,\n f.basePoly,\n f.basePolyCount,\n 5, \n variance, \n 4 * Fix64V1.ONE \n );\n\n require(polyCount == MAX_POLYGONS, \"invalid algorithm\");\n\n stack = poly;\n\n vertexCount = polyCount;\n }"
            },
            {
                "deform": "function deform(\n RandomV1.PRNG memory prng,\n TypesV1.Point2D[MAX_POLYGONS] memory points,\n uint32 pointCount,\n int32 depth,\n int32 variance,\n int64 vdiv\n )\n private\n pure\n returns (\n TypesV1.Point2D[MAX_POLYGONS] memory newPoints,\n uint32 newPointCount\n )\n {\n if (pointCount < 2) {\n return (newPoints, 0);\n }\n\n newPointCount = 0;\n\n for (uint32 i = 0; i < pointCount; i++) {\n int32 sx1 = int32(points[i].x);\n\n int32 sy1 = int32(points[i].y);\n\n int32 sx2 = int32(points[(i + 1) % pointCount].x);\n\n int32 sy2 = int32(points[(i + 1) % pointCount].y);\n\n newPoints[newPointCount++] = TypesV1.Point2D(sx1, sy1);\n\n newPointCount = subdivide(\n Subdivide(\n depth,\n variance * Fix64V1.ONE,\n vdiv,\n newPoints,\n newPointCount,\n sx1 * Fix64V1.ONE,\n sy1 * Fix64V1.ONE,\n sx2 * Fix64V1.ONE,\n sy2 * Fix64V1.ONE\n ),\n prng\n );\n }\n\n return (newPoints, newPointCount);\n }"
            },
            {
                "subdivide_midpoint": "function subdivide_midpoint(\n Subdivide memory f,\n RandomV1.PRNG memory prng,\n int64 t1,\n int64 t2\n ) private pure returns (int64) {\n int64 mid = Fix64V1.div(Fix64V1.add(t1, t2), Fix64V1.TWO);\n\n int64 g = RandomV1.nextGaussian(prng);\n\n int64 n = Fix64V1.add(mid, Fix64V1.mul(g, f.variance));\n\n return n;\n }"
            },
            {
                "kintsugi_stage": "function kintsugi_stage(\n KintsugiLayer.KintsugiParameters memory kintsugi,\n IRenderer.RenderArgs memory args\n ) private pure returns (IRenderer.RenderArgs memory results) {\n require(kintsugi.layers > 0, \"layers not set\");\n\n int64[4096] memory noiseTable = NoiseV1.buildNoiseTable(args.seed);\n\n uint32[16384] memory buffer = KintsugiDraw.draw(\n KintsugiDraw.Draw(\n args.buffer,\n kintsugi,\n noiseTable,\n TypesV1.Chunk2D(\n uint16(args.index),\n 1024,\n 1024,\n 128,\n 128,\n (uint16(args.index) % 8) * 128,\n (uint16(args.index) / 8) * 128\n )\n )\n );\n\n return\n IRenderer.RenderArgs(\n args.index == 63 ? -1 : args.index + 1,\n 0,\n args.seed,\n buffer,\n args.prng\n );\n }"
            },
            {
                "draw": "function draw(\n Draw memory f\n ) external pure returns (uint32[16384] memory buffer) {\n f.p.iteration = 0;\n\n f.p.frame = 0;\n\n while (f.p.frame < FRAME_COUNT) {\n f.p.frame++;\n\n if (f.p.iteration >= f.p.layers) {\n break;\n }\n\n bool dead = true;\n\n {\n for (uint256 i = 0; i < f.p.layers; i++) {\n ParticleSetV1.ParticleSet2D memory particleSet = f\n .p\n .particleSets[i];\n\n update(\n f.noiseTable,\n particleSet,\n PARTICLE_COUNT,\n f.chunk.width,\n f.chunk.height\n );\n\n if (!particleSet.dead) {\n dead = false;\n }\n\n draw(particleSet, PARTICLE_COUNT, f.result, f.chunk);\n }\n }\n\n if (dead) {\n f.p.iteration++;\n }\n }\n\n return f.result;\n }"
            },
            {
                "update": "function update(\n int64[NOISE_TABLE_SIZE] memory noiseTable,\n Particle2D memory p,\n uint256 width,\n uint256 height\n ) internal pure {\n p.frames++;\n\n if (p.frames >= p._lifetime) {\n p.dead = true;\n\n return;\n }\n\n p.force = forceAt(noiseTable, p, p.x, p.y);\n\n if (\n p.x >= int256(width) + int256(width) / 2 ||\n p.x < -int256(width) / 2 ||\n p.y >= int256(height) + int256(height) / 2 ||\n p.y < -int256(height) / 2\n ) {\n p.dead = true;\n\n return;\n }\n\n p.px = p.x;\n\n p.py = p.y;\n\n p.x += int64(p.force.x);\n\n p.y += int64(p.force.y);\n }"
            },
            {
                "step": "function step(\n ParticleV1.Particle2D memory p,\n uint32[16384] memory result,\n TypesV1.Chunk2D memory chunk\n ) internal pure {\n if (p.frames < 40) {\n return;\n }\n\n uint32 dark = GraphicsV1.setOpacity(0xFFF4BB29, 10);\n\n TypesV1.Point2D memory v0 = TypesV1.Point2D(int32(p.x), int32(p.y));\n\n TypesV1.Point2D memory v1 = TypesV1.Point2D(int32(p.px), int32(p.py));\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y - 2),\n TypesV1.Point2D(v1.x, v1.y - 2),\n dark,\n chunk\n )\n );\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y + 2),\n TypesV1.Point2D(v1.x, v1.y + 2),\n dark,\n chunk\n )\n );\n\n uint32 bright = GraphicsV1.setOpacity(0xFFD5B983, 10);\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y - 1),\n TypesV1.Point2D(v1.x, v1.y - 1),\n bright,\n chunk\n )\n );\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y),\n TypesV1.Point2D(v1.x, v1.y),\n bright,\n chunk\n )\n );\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y + 1),\n TypesV1.Point2D(v1.x, v1.y + 1),\n bright,\n chunk\n )\n );\n }"
            }
        ]
    },
    "det_chain": {
        "CollectionMinted1": [
            {
                "purchaseFor": "function purchaseFor(\n bytes32 collectionId,\n address recipient\n ) public payable {\n require(!_msgSender().isContract(), \"cannot purchase from contract\");\n\n require(\n msg.value >= collections[collectionId].priceInWei,\n \"insufficient funds sent to purchase\"\n );\n\n Collection memory collection = getCollection(collectionId);\n\n bool allowedToMint = false;\n\n if (collection.useAllowList && collection.allowList.length > 0) {\n for (uint i = 0; i < collection.allowList.length; i++) {\n if (_msgSender() == collection.allowList[i]) {\n allowedToMint = true;\n\n break;\n }\n }\n } else {\n allowedToMint = true;\n }\n\n require(allowedToMint, \"mint not approved\");\n\n mint(collectionId, _msgSender(), recipient);\n\n require(ownerAddresses.length > 0, \"no owner addresses\");\n\n require(\n ownerSplits.length == ownerAddresses.length,\n \"invalid owner splits\"\n );\n\n require(collection.creatorAddresses.length > 0, \"no creator addresses\");\n\n require(\n collection.creatorSplits.length ==\n collection.creatorAddresses.length,\n \"invalid creator splits\"\n );\n\n distributeFunds(collection);\n }"
            },
            {
                "mint": "function mint(\n bytes32 collectionId,\n address minter,\n address recipient\n ) internal {\n Collection memory collection = getCollection(collectionId);\n\n require(collections[collectionId].seed != 0, \"seed not set\");\n\n require(collection.active, \"collection inactive\");\n\n require(\n collection.minted + 1 <= collection.mintedMax,\n \"minted max tokens\"\n );\n\n require(\n collection.mintedMaxPerOwner == 0 ||\n ownerMints[collectionId][minter] < collection.mintedMaxPerOwner,\n \"minter exceeds max mints\"\n );\n\n uint256 nextTokenId = lastTokenId + 1;\n\n int32 seed = int32(\n int(\n uint(\n keccak256(\n abi.encodePacked(\n collection.seed,\n block.number,\n _msgSender(),\n recipient,\n nextTokenId\n )\n )\n )\n )\n );\n\n lastTokenId = nextTokenId;\n\n collectionTokens[collectionId].push(lastTokenId);\n\n tokenCollection[lastTokenId] = collectionId;\n\n collectionSeeds[collectionId].push(seed);\n\n tokenSeed[lastTokenId] = seed;\n\n collections[collectionId].minted = collection.minted + 1;\n\n ownerMints[collectionId][recipient] =\n ownerMints[collectionId][recipient] +\n 1;\n\n _safeMint(recipient, nextTokenId);\n\n emit CollectionMinted(\n collectionId,\n nextTokenId,\n recipient,\n collection.minted,\n collection.priceInWei,\n seed\n );\n\n if (collection.pauseAt > 0) {\n if (lastTokenId >= collection.pauseAt) _pause();\n }\n }"
            },
            {
                "_safeMint": "function _safeMint(address to, uint256 tokenId) internal virtual {\n _safeMint(to, tokenId, \"\");\n }"
            },
            {
                "_mint": "function _mint(address to, uint256 tokenId) internal virtual {\n require(to != address(0), \"ERC721: mint to the zero address\");\n\n require(!_exists(tokenId), \"ERC721: token already minted\");\n\n _beforeTokenTransfer(address(0), to, tokenId);\n\n _balances[to] += 1;\n\n _owners[tokenId] = to;\n\n emit Transfer(address(0), to, tokenId);\n }"
            }
        ]
    }
}
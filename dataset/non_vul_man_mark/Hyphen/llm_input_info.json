{
    "src_chain": {
        "Deposit1": [
            {
                "_depositErc20": "function _depositErc20(\n address sender,\n uint256 toChainId,\n address tokenAddress,\n address receiver,\n uint256 amount\n ) internal returns (uint256) {\n require(\n toChainId != block.chainid,\n \"To chain must be different than current chain\"\n );\n require(tokenAddress != NATIVE, \"wrong function\");\n TokenConfig memory config = tokenManager.getDepositConfig(\n toChainId,\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Deposit amount not in Cap limit\"\n );\n require(receiver != address(0), \"Receiver address cannot be 0\");\n require(amount != 0, \"Amount cannot be 0\");\n uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n if (rewardAmount != 0) {\n incentivePool[tokenAddress] =\n incentivePool[tokenAddress] -\n rewardAmount;\n }\n liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n SafeERC20Upgradeable.safeTransferFrom(\n IERC20Upgradeable(tokenAddress),\n sender,\n address(this),\n amount\n );\n return rewardAmount;\n }"
            }
        ],
        "DepositAndSwap2": [
            {
                "depositAndSwapErc20": "function depositAndSwapErc20(\n address tokenAddress,\n address receiver,\n uint256 toChainId,\n uint256 amount,\n string calldata tag,\n SwapRequest[] calldata swapRequest\n ) external tokenChecks(tokenAddress) whenNotPaused nonReentrant {\n uint256 totalPercentage = 0;\n {\n uint256 swapArrayLength = swapRequest.length;\n unchecked {\n for (uint256 index = 0; index < swapArrayLength; ++index) {\n totalPercentage += swapRequest[index].percentage;\n }\n }\n }\n require(\n totalPercentage <= 100 * BASE_DIVISOR,\n \"Total percentage cannot be > 100\"\n );\n address sender = _msgSender();\n uint256 rewardAmount = _depositErc20(\n sender,\n toChainId,\n tokenAddress,\n receiver,\n amount\n );\n \n emit DepositAndSwap(\n sender,\n tokenAddress,\n receiver,\n toChainId,\n amount + rewardAmount,\n rewardAmount,\n tag,\n swapRequest\n );\n }"
            },
            {
                "_depositErc20": "function _depositErc20(\n address sender,\n uint256 toChainId,\n address tokenAddress,\n address receiver,\n uint256 amount\n ) internal returns (uint256) {\n require(\n toChainId != block.chainid,\n \"To chain must be different than current chain\"\n );\n require(tokenAddress != NATIVE, \"wrong function\");\n TokenConfig memory config = tokenManager.getDepositConfig(\n toChainId,\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Deposit amount not in Cap limit\"\n );\n require(receiver != address(0), \"Receiver address cannot be 0\");\n require(amount != 0, \"Amount cannot be 0\");\n uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n if (rewardAmount != 0) {\n incentivePool[tokenAddress] =\n incentivePool[tokenAddress] -\n rewardAmount;\n }\n liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n SafeERC20Upgradeable.safeTransferFrom(\n IERC20Upgradeable(tokenAddress),\n sender,\n address(this),\n amount\n );\n return rewardAmount;\n }"
            }
        ]
    },
    "rel_chain": {
        "depositErc20": [
            {
                "depositErc20": "function depositErc20( address tokenAddress, address receiver, uint256 amount, uint256 toChainId ) public tokenChecks(tokenAddress) whenNotPaused {\n require(tokensInfo[tokenAddress].minCap <= amount && tokensInfo[tokenAddress].maxCap >= amount, \"Deposit amount should be within allowed Cap limits\");\n require(receiver != address(0), \"Receiver address cannot be 0\");\n require(amount != 0, \"Amount cannot be 0\");\n address payable sender = _msgSender();\n SafeERC20.safeTransferFrom(IERC20(tokenAddress), sender, address(this),amount);\n emit Deposit(sender, tokenAddress, receiver, toChainId, amount);\n }"
            }
        ],
        "depositNative": [
            {
                "depositNative": "function depositNative(\n address receiver,\n uint256 toChainId,\n string calldata tag\n ) external payable whenNotPaused nonReentrant {\n uint256 rewardAmount = _depositNative(receiver, toChainId);\n emit Deposit(\n _msgSender(),\n NATIVE,\n receiver,\n toChainId,\n msg.value + rewardAmount,\n rewardAmount,\n tag\n );\n }"
            }
        ],
        "sendFundsToUser": [
            {
                "sendFundsToUser": "function sendFundsToUser(\n address tokenAddress,\n uint256 amount,\n address payable receiver,\n bytes calldata depositHash,\n uint256 tokenGasPrice,\n uint256 fromChainId\n ) external nonReentrant onlyExecutor whenNotPaused {\n uint256 initialGas = gasleft();\n TokenConfig memory config = tokenManager.getTransferConfig(\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Withdraw amount not in Cap limit\"\n );\n require(receiver != address(0), \"Bad receiver address\");\n (bytes32 hashSendTransaction, bool status) = checkHashStatus(\n tokenAddress,\n amount,\n receiver,\n depositHash\n );\n require(!status, \"Already Processed\");\n processedHash[hashSendTransaction] = true;\n \n uint256[4] memory transferDetails = getAmountToTransfer(\n initialGas,\n tokenAddress,\n amount,\n tokenGasPrice\n );\n liquidityProviders.decreaseCurrentLiquidity(\n tokenAddress,\n transferDetails[0]\n );\n if (tokenAddress == NATIVE) {\n (bool success, ) = receiver.call{value: transferDetails[0]}(\"\");\n require(success, \"Native Transfer Failed\");\n } else {\n SafeERC20Upgradeable.safeTransfer(\n IERC20Upgradeable(tokenAddress),\n receiver,\n transferDetails[0]\n );\n }\n emit AssetSent(\n tokenAddress,\n amount,\n transferDetails[0],\n receiver,\n depositHash,\n fromChainId,\n transferDetails[1],\n transferDetails[2],\n transferDetails[3]\n );\n }"
            },
            {
                "getAmountToTransfer": "function getAmountToTransfer(\n uint256 initialGas,\n address tokenAddress,\n uint256 amount,\n uint256 tokenGasPrice\n ) internal returns (uint256[4] memory) {\n TokenInfo memory tokenInfo = tokenManager.getTokensInfo(tokenAddress);\n uint256 transferFeePerc = _getTransferFee(\n tokenAddress,\n amount,\n tokenInfo\n );\n uint256 lpFee;\n if (transferFeePerc > tokenInfo.equilibriumFee) {\n \n lpFee = (amount * tokenInfo.equilibriumFee) / BASE_DIVISOR;\n unchecked {\n incentivePool[tokenAddress] +=\n (amount * (transferFeePerc - tokenInfo.equilibriumFee)) /\n BASE_DIVISOR;\n }\n } else {\n lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n }\n uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n liquidityProviders.addLPFee(tokenAddress, lpFee);\n uint256 totalGasUsed = initialGas +\n tokenInfo.transferOverhead +\n baseGas -\n gasleft();\n uint256 gasFee = totalGasUsed * tokenGasPrice;\n gasFeeAccumulatedByToken[tokenAddress] += gasFee;\n gasFeeAccumulated[tokenAddress][_msgSender()] += gasFee;\n uint256 amountToTransfer = amount - (transferFeeAmount + gasFee);\n return [amountToTransfer, lpFee, transferFeeAmount, gasFee];\n }"
            }
        ],
        "swapAndSendFundsToUser": [
            {
                "swapAndSendFundsToUser": "function swapAndSendFundsToUser(\n address tokenAddress,\n uint256 amount,\n address payable receiver,\n bytes calldata depositHash,\n uint256 nativeTokenPriceInTransferredToken,\n uint256 tokenGasBaseFee,\n uint256 fromChainId,\n uint256 swapGasOverhead,\n SwapRequest[] calldata swapRequests,\n string memory swapAdaptor\n ) external nonReentrant onlyExecutor whenNotPaused {\n require(swapRequests.length > 0, \"Wrong method call\");\n require(\n swapAdaptorMap[swapAdaptor] != address(0),\n \"Swap adaptor not found\"\n );\n uint256[4]\n memory transferDetails = _calculateAmountAndDecreaseAvailableLiquidity(\n tokenAddress,\n amount,\n receiver,\n depositHash,\n nativeTokenPriceInTransferredToken,\n tokenGasBaseFee\n );\n if (tokenAddress == NATIVE) {\n (bool success, ) = swapAdaptorMap[swapAdaptor].call{\n value: transferDetails[0]\n }(\"\");\n require(success, \"Native Transfer to Adaptor Failed\");\n ISwapAdaptor(swapAdaptorMap[swapAdaptor]).swapNative(\n transferDetails[0],\n receiver,\n swapRequests\n );\n } else {\n {\n uint256 gasBeforeApproval = gasleft();\n SafeERC20Upgradeable.safeApprove(\n IERC20Upgradeable(tokenAddress),\n address(swapAdaptorMap[swapAdaptor]),\n 0\n );\n SafeERC20Upgradeable.safeApprove(\n IERC20Upgradeable(tokenAddress),\n address(swapAdaptorMap[swapAdaptor]),\n transferDetails[0]\n );\n swapGasOverhead += (gasBeforeApproval - gasleft());\n }\n {\n uint256 swapGasFee = calculateGasFee(\n tokenAddress,\n nativeTokenPriceInTransferredToken,\n swapGasOverhead,\n 0,\n _msgSender()\n );\n transferDetails[0] -= swapGasFee; \n transferDetails[3] += swapGasFee; \n }\n ISwapAdaptor(swapAdaptorMap[swapAdaptor]).swap(\n tokenAddress,\n transferDetails[0],\n receiver,\n swapRequests\n );\n }\n emit AssetSent(\n tokenAddress,\n amount,\n transferDetails[0],\n receiver,\n depositHash,\n fromChainId,\n transferDetails[1],\n transferDetails[2],\n transferDetails[3]\n );\n }"
            },
            {
                "_calculateAmountAndDecreaseAvailableLiquidity": "function _calculateAmountAndDecreaseAvailableLiquidity(\n address tokenAddress,\n uint256 amount,\n address payable receiver,\n bytes calldata depositHash,\n uint256 nativeTokenPriceInTransferredToken,\n uint256 tokenGasBaseFee\n ) internal returns (uint256[4] memory) {\n uint256 initialGas = gasleft();\n TokenConfig memory config = tokenManager.getTransferConfig(\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Withdraw amount not in Cap limit\"\n );\n require(receiver != address(0), \"Bad receiver address\");\n (bytes32 hashSendTransaction, bool status) = checkHashStatus(\n tokenAddress,\n amount,\n receiver,\n depositHash\n );\n require(!status, \"Already Processed\");\n processedHash[hashSendTransaction] = true;\n \n uint256[4] memory transferDetails = getAmountToTransferV2(\n initialGas,\n tokenAddress,\n amount,\n nativeTokenPriceInTransferredToken,\n tokenGasBaseFee\n );\n liquidityProviders.decreaseCurrentLiquidity(\n tokenAddress,\n transferDetails[0]\n );\n return transferDetails;\n }"
            },
            {
                "getAmountToTransferV2": "function getAmountToTransferV2(\n uint256 initialGas,\n address tokenAddress,\n uint256 amount,\n uint256 nativeTokenPriceInTransferredToken,\n uint256 tokenGasBaseFee\n ) internal returns (uint256[4] memory) {\n TokenInfo memory tokenInfo = tokenManager.getTokensInfo(tokenAddress);\n uint256 transferFeePerc = _getTransferFee(\n tokenAddress,\n amount,\n tokenInfo\n );\n uint256 lpFee;\n if (transferFeePerc > tokenInfo.equilibriumFee) {\n \n lpFee = (amount * tokenInfo.equilibriumFee) / BASE_DIVISOR;\n unchecked {\n incentivePool[tokenAddress] +=\n (amount * (transferFeePerc - tokenInfo.equilibriumFee)) /\n BASE_DIVISOR;\n }\n } else {\n lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n }\n uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n liquidityProviders.addLPFee(tokenAddress, lpFee);\n uint256 totalGasUsed = initialGas +\n tokenInfo.transferOverhead +\n baseGas -\n gasleft();\n uint256 gasFee = calculateGasFee(\n tokenAddress,\n nativeTokenPriceInTransferredToken,\n totalGasUsed,\n tokenGasBaseFee,\n _msgSender()\n );\n require(\n transferFeeAmount + gasFee <= amount,\n \"Insufficient funds to cover transfer fee\"\n );\n unchecked {\n uint256 amountToTransfer = amount - (transferFeeAmount + gasFee);\n return [amountToTransfer, lpFee, transferFeeAmount, gasFee];\n }\n }"
            }
        ]
    },
    "det_chain": {
        "AssetSent1": [],
        "DepositAndSwap2": []
    }
}
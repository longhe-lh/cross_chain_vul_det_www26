Folder Structure
--------------------------------------------------
contracts/
    BoringERC20.sol
    CommonEclipse.sol
    CommonEclipseAmara.sol
    CommonEclipseAmaraV2.sol
    CommonEclipseV2.sol
    ComplexRewarderPerSec.sol
    ComplexRewarderPerSecV2.sol
    ComplexRewarderPerSecV3.sol
    ComplexRewarderPerSecV4.sol
    EIP712Base.sol
    EIP712MetaTransaction.sol
    Forwarder.sol
    GasSwap.sol
    IBoringERC20.sol
    ICommonEclipse.sol
    ICommonEclipseAmara.sol
    ICommonEclipseAmaraV2.sol
    ICommonEclipseV2.sol
    IComplexRewarder.sol
    IERC20.sol
    IForwarder.sol
    IRewarder.sol
    ISmartRouter.sol
    ISolarCallee.sol
    ISolarDistributorV2.sol
    ISolarERC20.sol
    ISolarFactory.sol
    ISolarPair.sol
    ISolarRouter.sol
    ISolarRouter01.sol
    ISolarRouter02.sol
    IToken.sol
    IWETH.sol
    Math.sol
    MockERC20.sol
    MockRouter.sol
    Multicall2.sol
    NFTClaim.sol
    RewarderBroken.sol
    SafeMath.sol
    SimpleRewarderPerSec.sol
    SolarBeamToken.sol
    SolarBurner.sol
    SolarDistributor.sol
    SolarDistributorV2.sol
    SolarERC20.sol
    SolarFactory.sol
    SolarFeeColector.sol
    SolarLibrary.sol
    SolarLocker.sol
    SolarPair.sol
    SolarRouter02.sol
    SolarVault.sol
    Timelock.sol
    TokenFarm.sol
    TransferHelper.sol
    UQ112x112.sol
    VestedSolarBeamToken.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\BoringERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



// solhint-disable avoid-low-level-calls

import "./IBoringERC20.sol";



library BoringERC20 {

    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()

    bytes4 private constant SIG_NAME = 0x06fdde03; // name()

    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()

    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)

    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)



    function returnDataToString(bytes memory data)

        internal

        pure

        returns (string memory)

    {

        if (data.length >= 64) {

            return abi.decode(data, (string));

        } else if (data.length == 32) {

            uint8 i = 0;

            while (i < 32 && data[i] != 0) {

                i++;

            }

            bytes memory bytesArray = new bytes(i);

            for (i = 0; i < 32 && data[i] != 0; i++) {

                bytesArray[i] = data[i];

            }

            return string(bytesArray);

        } else {

            return "???";

        }

    }



    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.

    /// @param token The address of the ERC-20 token contract.

    /// @return (string) Token symbol.

    function safeSymbol(IBoringERC20 token)

        internal

        view

        returns (string memory)

    {

        (bool success, bytes memory data) = address(token).staticcall(

            abi.encodeWithSelector(SIG_SYMBOL)

        );

        return success ? returnDataToString(data) : "???";

    }



    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.

    /// @param token The address of the ERC-20 token contract.

    /// @return (string) Token name.

    function safeName(IBoringERC20 token)

        internal

        view

        returns (string memory)

    {

        (bool success, bytes memory data) = address(token).staticcall(

            abi.encodeWithSelector(SIG_NAME)

        );

        return success ? returnDataToString(data) : "???";

    }



    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.

    /// @param token The address of the ERC-20 token contract.

    /// @return (uint8) Token decimals.

    function safeDecimals(IBoringERC20 token) internal view returns (uint8) {

        (bool success, bytes memory data) = address(token).staticcall(

            abi.encodeWithSelector(SIG_DECIMALS)

        );

        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;

    }



    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.

    /// Reverts on a failed transfer.

    /// @param token The address of the ERC-20 token.

    /// @param to Transfer tokens to.

    /// @param amount The token amount.

    function safeTransfer(

        IBoringERC20 token,

        address to,

        uint256 amount

    ) internal {

        (bool success, bytes memory data) = address(token).call(

            abi.encodeWithSelector(SIG_TRANSFER, to, amount)

        );

        require(

            success && (data.length == 0 || abi.decode(data, (bool))),

            "BoringERC20: Transfer failed"

        );

    }



    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.

    /// Reverts on a failed transfer.

    /// @param token The address of the ERC-20 token.

    /// @param from Transfer tokens from.

    /// @param to Transfer tokens to.

    /// @param amount The token amount.

    function safeTransferFrom(

        IBoringERC20 token,

        address from,

        address to,

        uint256 amount

    ) internal {

        (bool success, bytes memory data) = address(token).call(

            abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount)

        );

        require(

            success && (data.length == 0 || abi.decode(data, (bool))),

            "BoringERC20: TransferFrom failed"

        );

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\CommonEclipse.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "../farm/SolarVault.sol";

import "./ICommonEclipse.sol";



contract CommonEclipse is ICommonEclipse, ReentrancyGuard, Ownable {

  using SafeERC20 for IERC20;



    /*///////////////////////////////////////////////////////////////

                                STORAGE

    //////////////////////////////////////////////////////////////*/



    IERC20 public lpToken;

    IERC20 public offeringToken;



    SolarVault public vault;



    uint8 public constant HARVEST_PERIODS = 4; // number of periods to split offering token to vest.



    uint8 public constant NUMBER_VAULT_POOLS = 3; // number of solar vault pools to check for stake.



    uint8 public constant NUMBER_THRESHOLDS = 3; // number of solar staked threshold for multipliers per pool.



    uint256[HARVEST_PERIODS] public harvestReleaseBlocks;

    uint256[HARVEST_PERIODS] public harvestReleasePercent;



    uint256 public startBlock;



    uint256 public endBlock;



    uint256 public eligibilityThreshold; // minimum solar staked to be eligible.



    bool public claimEnabled = false; // flag to enable harvests after liquidity is added.



    /**

     * @dev The struct stores the each pools base multiplier, and additional

     * multipliers based on meeting staked threshold requirements.

     */

    struct Multipliers {

        uint16[NUMBER_THRESHOLDS] poolThresholds;

        uint8[NUMBER_VAULT_POOLS] poolBaseMult;

        uint8[NUMBER_THRESHOLDS][NUMBER_VAULT_POOLS] poolMultipliers;

    }



    struct UserInfo {

        uint256 amount; // How many tokens the user has provided for pool

        uint256 allocPoints; // Used to weight user allocation based on amount locked in solar vaults

        bool[HARVEST_PERIODS] claimed; // Whether the user has claimed (default: false) for pool

        bool isRefunded; // Wheter the user has been refunded or not.

    }



    struct PoolInfo {

        uint256 raisingAmount; // amount of tokens raised for the pool (in LP tokens)

        uint256 offeringAmount; // amount of tokens offered for the pool (in offeringTokens)

        uint256 baseLimitInLP; // base limit of tokens per eligible user (if 0, it is ignored)

        bool hasTax; // if a pool is to be taxed on overflow or not

        uint256 totalAmountPool; // total amount pool deposited (in LP tokens)

        uint256 sumTaxesOverflow; // total taxes collected (starts at 0, increases with each harvest if overflow)

        uint256 totalAllocPoints;

    }



    uint8 public constant numberPools = 2; // max number of pools that are to be created.



    mapping(address => mapping(uint8 => UserInfo)) public userInfo;



    PoolInfo[numberPools] public poolInfo;



    Multipliers private _multiplierInfo;



    /*///////////////////////////////////////////////////////////////

                                EVENTS

    //////////////////////////////////////////////////////////////*/

    event Deposit(address indexed user, uint256 amount, uint256 indexed pid);

    event Withdraw(address indexed user, uint256 amount, uint256 indexed pid);

    event Harvest(address indexed user, uint256 offeringAmount, uint256 excessAmount, uint8 indexed pid);

    event NewStartAndEndBlocks(uint256 startBlock, uint256 endBlock);

    event PoolParametersSet(uint256 raisingAmount, uint256 offeringAmount, uint8 pid);

    event MultiplierParametersSet(

        uint16[NUMBER_THRESHOLDS] poolStakedThresholds,

        uint8[NUMBER_VAULT_POOLS] poolBaseMultiplier,

        uint8[NUMBER_THRESHOLDS][NUMBER_VAULT_POOLS] poolStakedMultipliers

        );

    event AdminWithdraw(uint256 amountLP, uint256 amountOfferingToken);

    event AdminTokenRecovery(address token, uint256 amount);

    event ClaimEnabled();



    /*///////////////////////////////////////////////////////////////

                               MODIFIERS

    //////////////////////////////////////////////////////////////*/

    /**

     * @notice It checks if the current block is within the sale period.

     */

    modifier onlyWhenActive() {

        require(

            block.number >= startBlock && block.number < endBlock,

            "Sale not active"

        );

        _;

    }

    /**

     * @notice It checks if sale ended and claim is enabled

     */

    modifier onlyFinished() {

        require(block.number >= endBlock && claimEnabled, "sale not finished");

        _;

    }

    /*///////////////////////////////////////////////////////////////

                              CONSTRUCTOR

    //////////////////////////////////////////////////////////////*/



    constructor(

        IERC20 _lpToken,

        IERC20 _offeringToken,

        uint256 _startBlock,

        uint256 _endBlock,

        uint256 _vestingBlockOffset, // Number of Blocks to offset for each harvest period

        uint256 _eligibilityThreshold, // (1e18)

        address _solarVault,

        uint256[] memory _harvestReleasePercent,

        bytes memory _multipliers

    ){

        require(_lpToken.totalSupply() >= 0);

        require(_offeringToken.totalSupply() >= 0);

        require(_lpToken != _offeringToken, "Tokens must be different");

        require(_harvestReleasePercent.length == HARVEST_PERIODS, "harvest schedule must match");



        uint256 totalPercent = 0;

        for (uint256 i = 0; i < _harvestReleasePercent.length; i++) {

            totalPercent += _harvestReleasePercent[i];

        }



        require(totalPercent == 10000, "harvest percent must total 10000");



        lpToken = _lpToken;

        offeringToken = _offeringToken;

        startBlock = _startBlock;

        endBlock = _endBlock;

        eligibilityThreshold = _eligibilityThreshold;

        vault = SolarVault(_solarVault);



        _setMultipliers(_multipliers);



        for (uint256 i = 0; i < HARVEST_PERIODS; i++) {

            harvestReleaseBlocks[i] = endBlock + (_vestingBlockOffset * i);

            harvestReleasePercent[i] = _harvestReleasePercent[i];

        }

    }



    function setOfferingToken(IERC20 _offeringToken) public onlyOwner {

        require(block.number < startBlock, "sale is already active");        

        require(_offeringToken.totalSupply() >= 0);

        offeringToken = _offeringToken;

    }



    /*///////////////////////////////////////////////////////////////

                            POOL MANAGEMENT

    //////////////////////////////////////////////////////////////*/

    /**

     * @notice It sets the threshold of solar staked to be eligible to participate.

     * @param _eligibilityThreshold: Number of solar staked to be eligibile. (1e18)

     */

    function setEligibilityThreshold(uint256 _eligibilityThreshold) public override onlyOwner {

        require(block.number < startBlock, "sale is already active");

        eligibilityThreshold = _eligibilityThreshold;

    }

    /**

     * @notice It sets the multiplier matrix.

     * @param _multipliers: abi encoded arrays

     */

    function setMultipliers(bytes memory _multipliers) public override onlyOwner {

        require(block.number < startBlock, "sale is already active");

        _setMultipliers(_multipliers);

    }

    /**

     * @notice Private helper to set multiplier matrix.

     */

    function _setMultipliers(bytes memory _multipliers) private {

        (

            uint16[] memory thresholds,

            uint8[] memory base,

            uint8[][] memory mults



            ) = abi.decode(_multipliers,(

                uint16[],

                uint8[],

                uint8[][]

            ));

        require(

            base.length == NUMBER_VAULT_POOLS && mults.length == NUMBER_VAULT_POOLS,

            "bad vault pool length"

        );

        require(thresholds.length == NUMBER_THRESHOLDS ,"bad threshold length");



        for (uint8 i = 0; i < NUMBER_THRESHOLDS; i++) {

            _multiplierInfo.poolThresholds[i] =  thresholds[i];

        }



        for (uint8 i = 0; i < NUMBER_VAULT_POOLS; i++){

            _multiplierInfo.poolBaseMult[i] = base[i];

            require(mults[i].length == NUMBER_THRESHOLDS, "bad threshold length");

            for ( uint8 j = 0; j < NUMBER_THRESHOLDS; j++) {

               _multiplierInfo.poolMultipliers[i][j] =  mults[i][j];

            }

        }



        emit MultiplierParametersSet(

            _multiplierInfo.poolThresholds,

            _multiplierInfo.poolBaseMult,

            _multiplierInfo.poolMultipliers

        );

    }



    /**

     * @notice It creates a pool.

     * @dev If _baseLimitInLP is set to zero, the allocation will be weighted by allocation points. (see below)

     * @param _raisingAmount: amount of LP token the pool aims to raise (1e18)

     * @param _offeringAmount: amount of IDO tokens the pool is offering (1e18)

     * @param _baseLimitInLP: base limit of tokens per eligible user (if 0, it is ignored) (1e18)

     * @param _hasTax: true if a pool is to be taxed on overflow

     * @param _pid: pool identification number

     */

    function setPool(

        uint256 _raisingAmount,

        uint256 _offeringAmount,

        uint256 _baseLimitInLP,

        bool _hasTax,

        uint8 _pid

    ) external override onlyOwner{

        require(block.number < startBlock, "sale is already active");

        require(_pid < numberPools, "pool does not exist");



        poolInfo[_pid].raisingAmount = _raisingAmount;

        poolInfo[_pid].offeringAmount = _offeringAmount;

        poolInfo[_pid].baseLimitInLP = _baseLimitInLP;

        poolInfo[_pid].hasTax = _hasTax;



        emit PoolParametersSet(_offeringAmount, _raisingAmount, _pid);

    }

    /**

     * @notice It sets the start and end blocks of the sale.

     */

    function updateStartAndEndBlocks(uint256 _startBlock, uint256 _endBlock) external override onlyOwner {

        require(block.number < startBlock, "sale is already active");

        require(_startBlock < _endBlock, "new startBlock must be lower than new endBlock");

        require(block.number < _startBlock, "New startBlock must be higher than current block");



        startBlock = _startBlock;

        endBlock = _endBlock;



        emit NewStartAndEndBlocks(_startBlock, _endBlock);

    }

    /**

     * @notice It allows the owner to withdraw LPtokens and Offering tokens after the sale

     * @dev can only withdraw after the sale is finished

     * @param _lpAmount: amount of LP token to withdraw

     * @param _offerAmount: amount of IDO tokens to withdraw

     */

    function finalWithdraw(uint256 _lpAmount, uint256 _offerAmount) external override onlyOwner {

        require(block.number > endBlock, "sale has not finished");

        require(_lpAmount <= lpToken.balanceOf(address(this)), "Not enough LP tokens");

        require(_offerAmount <= offeringToken.balanceOf(address(this)), "Not enough offering tokens");



        if (_lpAmount > 0) {

            lpToken.safeTransfer(address(msg.sender), _lpAmount);

        }



        if (_offerAmount > 0) {

            offeringToken.safeTransfer(address(msg.sender), _offerAmount);

        }



        emit AdminWithdraw(_lpAmount, _offerAmount);

    }

    /**

     * @notice It allows the owner to withdraw ERC20 tokens

     * @dev cannot withdraw LP tokens or Offering tokens

     * @param _tokenAddress: address of ERC20 token to withdraw

     * @param _amount: amount to withdraw

     */

    function sweep(address _tokenAddress, uint256 _amount) external onlyOwner {

        require(

            _tokenAddress != address(lpToken) && _tokenAddress != address(offeringToken),

            "Cannot be LP or Offering token"

        );

        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _amount);



        emit AdminTokenRecovery(_tokenAddress, _amount);

    }



    /*///////////////////////////////////////////////////////////////

                            DEPOSIT LOGIC

    //////////////////////////////////////////////////////////////*/

    /**

     * @notice It lets users deposit into a pool for a share of offering tokens

     * @dev cannot withdraw LP tokens or Offering tokens

     * @param _amount: amount of LP tokens to deposit

     * @param _pid: pool to depoist in

     */

    function depositPool(uint256 _amount, uint8 _pid) external override onlyWhenActive nonReentrant {

        UserInfo storage user = userInfo[msg.sender][_pid];



        require(_pid < numberPools, "pool does not exist");



        require(

            poolInfo[_pid].offeringAmount > 0 && poolInfo[_pid].raisingAmount > 0,

            "Pool not set"

        );



        for (uint8 i = 0; i < numberPools; i++) {

          if (i != _pid) {

            require(userInfo[msg.sender][i].amount == 0, "already commited in another pool");

          }

        }



        for (uint256 i=0; i<NUMBER_VAULT_POOLS; i++) {

            vault.deposit(i,0);

        }

        (bool success) = getUserEligibility(address(msg.sender));

        require(success, "user not eligible");



        lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);



        user.amount += _amount;



        if (poolInfo[_pid].baseLimitInLP > 0) {

            (uint16 multiplier) = getUserMultiplier(msg.sender);

            require(

                user.amount <= (poolInfo[_pid].baseLimitInLP * uint256(multiplier)), "New amount above user limit"

            );

        } else {

            (uint16 multiplier) = getUserMultiplier(msg.sender);

            poolInfo[_pid].totalAllocPoints -= userInfo[msg.sender][_pid].allocPoints;

            userInfo[msg.sender][_pid].allocPoints = user.amount * uint256(multiplier);

            poolInfo[_pid].totalAllocPoints += userInfo[msg.sender][_pid].allocPoints;

        }

        poolInfo[_pid].totalAmountPool += _amount;



        emit Deposit(msg.sender,_amount,_pid);



    }





    function getUserEligibility(address _user) public view returns(bool) {

        uint256 amount;



        for (uint256 i=0; i<NUMBER_VAULT_POOLS; i++) {

            (amount,,,,) = vault.userInfo(i,_user);

            if(amount >= eligibilityThreshold) {

                return true;

            }

        }

        return false;

    }

    

    function getUserMultiplier(address _user) public view returns(uint16) {

        uint16 userMult;

        uint16 mult;

        uint256 amount;

        for (uint8 i=0; i<NUMBER_VAULT_POOLS; i++) {

            (amount,,,,) = vault.userInfo(i,_user);

            for (uint8 j=0; j<NUMBER_THRESHOLDS; j++) {

                mult = uint16(_multiplierInfo.poolBaseMult[i]) * uint16(_multiplierInfo.poolMultipliers[i][j]);

                if(amount >= uint256(_multiplierInfo.poolThresholds[j])*1e18) {

                    if(mult > userMult) {

                        userMult = mult;

                    }

                }

            }

        }

        return (userMult);

    }



    /*///////////////////////////////////////////////////////////////

                            WITHDRAW LOGIC

    //////////////////////////////////////////////////////////////*/

    function withdrawPool(uint256 _amount, uint8 _pid)

        external

        override

        nonReentrant

        onlyWhenActive

    {

        UserInfo storage user = userInfo[msg.sender][_pid];

        require(_pid < numberPools, "pool does not exist");

        require(

            poolInfo[_pid].offeringAmount > 0 &&

                poolInfo[_pid].raisingAmount > 0,

            "pool not set"

        );



        require(

            _amount > 0 && user.amount > 0 && user.amount >= _amount,

            "withdraw: amount higher than user balance"

        );



        user.amount -= _amount;

        poolInfo[_pid].totalAmountPool -= _amount;



        if (poolInfo[_pid].baseLimitInLP == 0) {

            (uint16 multiplier) = getUserMultiplier(msg.sender);

            poolInfo[_pid].totalAllocPoints -= userInfo[msg.sender][_pid].allocPoints;

            userInfo[msg.sender][_pid].allocPoints = user.amount * uint256(multiplier);

            poolInfo[_pid].totalAllocPoints += userInfo[msg.sender][_pid].allocPoints;

        }



        lpToken.safeTransfer(address(msg.sender), _amount);



        emit Withdraw(msg.sender, _amount, _pid);

    }



    /*///////////////////////////////////////////////////////////////

                            HARVEST LOGIC

    //////////////////////////////////////////////////////////////*/

    function harvestPool(uint8 _pid, uint8 _harvestPeriod) external override nonReentrant onlyFinished {

        require(_pid < numberPools, "pool does not exist");

        require(_harvestPeriod < HARVEST_PERIODS, "harvest period out of range");

        require(block.number > harvestReleaseBlocks[_harvestPeriod], "not harvest time");

        require(userInfo[msg.sender][_pid].amount > 0, "did not participate");

        require(!userInfo[msg.sender][_pid].claimed[_harvestPeriod], "harvest for period already claimed");



        userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;



        uint256 offeringTokenAmount;

        uint256 refundingTokenAmount;

        uint256 userTaxOverflow;

        (offeringTokenAmount, refundingTokenAmount, userTaxOverflow) = _calcOfferingAndRefundingAmounts(

            msg.sender,

            _pid

        );

        if (userTaxOverflow > 0 && !userInfo[msg.sender][_pid].isRefunded) {

            poolInfo[_pid].sumTaxesOverflow += userTaxOverflow;

        }

        if (refundingTokenAmount > 0 && !userInfo[msg.sender][_pid].isRefunded) {

            userInfo[msg.sender][_pid].isRefunded = true;

            lpToken.safeTransfer(address(msg.sender), refundingTokenAmount);

        }



        uint256 offeringTokenAmountPerPeriod;

        if (offeringTokenAmount > 0) {

            offeringTokenAmountPerPeriod = offeringTokenAmount * harvestReleasePercent[_harvestPeriod] / 1e4;

            offeringToken.safeTransfer(address(msg.sender), offeringTokenAmountPerPeriod);

        }

        userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;



        emit Harvest(msg.sender, offeringTokenAmountPerPeriod, refundingTokenAmount,_pid);





    }



    function _calcOfferingAndRefundingAmounts(address _user, uint8 _pid)

        internal

        view

        returns (

            uint256,

            uint256,

            uint256

        )

    {

        uint256 userOfferingAmount;

        uint256 userRefundingAmount;

        uint256 taxAmount;



        if (poolInfo[_pid].totalAmountPool > poolInfo[_pid].raisingAmount) {



            uint256 allocation = _getUserAllocation(_user,_pid);



            userOfferingAmount = poolInfo[_pid].offeringAmount * allocation / 1e12;



            uint256 payAmount = poolInfo[_pid].raisingAmount * userInfo[_user][_pid].amount * 1e18 / poolInfo[_pid].totalAmountPool  / 1e18;



            userRefundingAmount = userInfo[_user][_pid].amount - payAmount;

            if (poolInfo[_pid].hasTax) {

                uint256 taxOverflow =

                    _calculateTaxOverflow(

                        poolInfo[_pid].totalAmountPool,

                        poolInfo[_pid].raisingAmount

                    );

                taxAmount = userRefundingAmount * taxOverflow / 1e12;



                userRefundingAmount -= taxAmount;

            }

        } else {

            userRefundingAmount = 0;

            taxAmount = 0;

            if (poolInfo[_pid].baseLimitInLP > 0) {

                userOfferingAmount = userInfo[_user][_pid].amount * poolInfo[_pid].offeringAmount / poolInfo[_pid].raisingAmount;

            } else {

                userOfferingAmount = poolInfo[_pid].offeringAmount * _getUserAllocation(_user,_pid) / 1e12;

            }

        }

        return (userOfferingAmount, userRefundingAmount, taxAmount);

    }

    /**

     * @notice It returns the user allocation for pool

     * @dev (1e8) 10,000,000 means 0.1 (10%) / 1 means 0.000000001 (0.0000001%) / 100,000,000 means 1 (100%)

     * @param _user: user address

     * @param _pid: pool id

     * @return it returns the user's share of pool

     */

    function _getUserAllocation(address _user, uint8 _pid) view internal  returns (uint256) {

        if (poolInfo[_pid].totalAmountPool > 0) {

            if(poolInfo[_pid].baseLimitInLP > 0) {

                return userInfo[_user][_pid].amount * 1e18 / poolInfo[_pid].totalAmountPool / 1e6;

            } else {

                return userInfo[_user][_pid].allocPoints * 1e18 / poolInfo[_pid].totalAllocPoints / 1e6;

            }

        } else {

            return 0;

        }

    }



    /**

     * @notice It calculates the tax overflow given the raisingAmountPool and the totalAmountPool.

     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)

     * @return It returns the tax percentage

     */

    function _calculateTaxOverflow(uint256 _totalAmountPool, uint256 _raisingAmountPool)

        internal

        pure

        returns (uint256)

    {

        uint256 ratioOverflow = _totalAmountPool / _raisingAmountPool;



        if (ratioOverflow >= 500) {

            return 2000000000; // 0.2%

        } else if (ratioOverflow >= 250) {

            return 2500000000; // 0.25%

        } else if (ratioOverflow >= 100) {

            return 3000000000; // 0.3%

        } else if (ratioOverflow >= 50) {

            return 5000000000; // 0.5%

        } else {

            return 10000000000; // 1%

        }

    }



    /*///////////////////////////////////////////////////////////////

                            PUBLIC GETTERS

    //////////////////////////////////////////////////////////////*/

    function hasHarvested(address _user, uint8 _pid, uint8 _harvestPeriod) public view returns (bool) {

        return userInfo[_user][_pid].claimed[_harvestPeriod];

    }



    /**

     * @notice It returns the tax overflow rate calculated for a pool

     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)

     * @param _pid: poolId

     * @return It returns the tax percentage

     */

    function viewPoolTaxRateOverflow(uint256 _pid) external view override returns (uint256) {

        if (!poolInfo[_pid].hasTax) {

            return 0;

        } else {

            return

                _calculateTaxOverflow(poolInfo[_pid].totalAmountPool, poolInfo[_pid].raisingAmount);

        }

    }



    /**

     * @notice External view function to see user allocations for both pools

     * @param _user: user address

     * @param _pids[]: array of pids

     * @return

     */

    function viewUserAllocationPools(address _user, uint8[] calldata _pids)

        external

        view

        override

        returns (uint256[] memory)

    {

        uint256[] memory allocationPools = new uint256[](_pids.length);

        for (uint8 i = 0; i < _pids.length; i++) {

            allocationPools[i] = _getUserAllocation(_user, _pids[i]);

        }

        return allocationPools;

    }



    /**

     * @notice External view function to see user offering and refunding amounts for both pools

     * @param _user: user address

     * @param _pids: array of pids

     */

    function viewUserOfferingAndRefundingAmountsForPools(address _user, uint8[] calldata _pids)

        external

        view

        override

        returns (uint256[3][] memory)

    {

        uint256[3][] memory amountPools = new uint256[3][](_pids.length);



        for (uint8 i = 0; i < _pids.length; i++) {

            uint256 userOfferingAmountPool;

            uint256 userRefundingAmountPool;

            uint256 userTaxAmountPool;



            if (poolInfo[_pids[i]].raisingAmount > 0) {

                (

                    userOfferingAmountPool,

                    userRefundingAmountPool,

                    userTaxAmountPool

                ) = _calcOfferingAndRefundingAmounts(_user, _pids[i]);

            }



            amountPools[i] = [userOfferingAmountPool, userRefundingAmountPool, userTaxAmountPool];

        }

        return amountPools;

    }



    function viewMultipliers()

        public

        view

        returns(

            uint16[] memory,

            uint8[] memory,

            uint8[][] memory

        )

    {

        uint16[] memory _poolThresholds = new uint16[](_multiplierInfo.poolThresholds.length);

        for (uint16 i = 0; i < _multiplierInfo.poolThresholds.length ;i++) {

            _poolThresholds[i] = _multiplierInfo.poolThresholds[i];

        }



        uint8[] memory _poolBaseMult = new uint8[](_multiplierInfo.poolBaseMult.length);

        for (uint8 i = 0; i < _multiplierInfo.poolBaseMult.length ;i++) {

            _poolBaseMult[i] = _multiplierInfo.poolBaseMult[i];

        }



        uint8[][] memory _poolMultipliers = new uint8[][](_multiplierInfo.poolMultipliers.length);

        for (uint8 i = 0; i < _multiplierInfo.poolMultipliers.length;i++) {

            _poolMultipliers[i] = new uint8[](_multiplierInfo.poolMultipliers[i].length);

            for (uint8 j = 0;j < _multiplierInfo.poolMultipliers[i].length;j++) {

                _poolMultipliers[i][j] = _multiplierInfo.poolMultipliers[i][j];

            }

        }



        return(

            _poolThresholds,

            _poolBaseMult,

            _poolMultipliers

        );

    }



    function enableClaim() external override onlyOwner {

        require(block.number >= endBlock, "sale still active");

        require(!claimEnabled, "claim is already enabled");



        claimEnabled = true;



        emit ClaimEnabled();

    }



}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\CommonEclipseAmara.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;

pragma solidity ^0.8.7;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "./ICommonEclipseAmara.sol";



contract CommonEclipseAmara is ReentrancyGuard, Ownable {

    using SafeERC20 for IERC20;



    /*///////////////////////////////////////////////////////////////

                                STORAGE

    //////////////////////////////////////////////////////////////*/



    ICommonEclipseAmara eclipseV2;

    IERC20 offeringToken;

    uint256 public exchangeRate;



    uint8 public constant HARVEST_PERIODS = 6; // number of periods to split offering token to vest.



    struct UserInfo {

        uint256 amount; // How many tokens the user has provided for pool

        uint256 allocPoints; // Used to weight user allocation based on amount locked in solar vaults

        bool[HARVEST_PERIODS] claimed; // Whether the user has claimed (default: false) for pool

        bool isRefunded; // Wheter the user has been refunded or not.

    }



    mapping(address => mapping(uint8 => UserInfo)) public userInfo;



    event Harvest(

        address indexed user,

        uint256 offeringAmount,

        uint8 indexed pid

    );



    constructor(

        ICommonEclipseAmara _eclipseV2,

        IERC20 _offeringToken,

        uint256 _exchangeRate

    ) {

        require(_offeringToken.totalSupply() > 0);

        require(

            _isContract(address(_offeringToken)),

            "_offeringToken is not a contract address"

        );

        require(

            _isContract(address(_eclipseV2)),

            "_eclipseV2 is not a contract address"

        );



        eclipseV2 = _eclipseV2;

        offeringToken = _offeringToken;

        exchangeRate = _exchangeRate;

    }



    /**

     * This method relies on extcodesize, which returns 0 for contracts in construction,

     * since the code is only stored at the end of the constructor execution.

     */

    function _isContract(address account) internal view returns (bool) {

        uint256 size;

        assembly {

            size := extcodesize(account)

        } // solhint-disable-next-line no-inline-assembly

        return size > 0;

    }



    /*///////////////////////////////////////////////////////////////

                            HARVEST LOGIC

    //////////////////////////////////////////////////////////////*/

    function harvestPool(uint8 _pid, uint8 _harvestPeriod)

        external

        nonReentrant

    {

        require(_pid < 2, "invalid pid");

        require(

            _harvestPeriod < HARVEST_PERIODS,

            "harvest period out of range"

        );



        require(

            block.timestamp >

                eclipseV2.harvestReleaseTimestamps(_harvestPeriod),

            "not harvest time"

        );



        require(

            !userInfo[msg.sender][_pid].claimed[_harvestPeriod],

            "harvest for period already claimed"

        );



        // uint256 offeringTokenAmount;

        uint8[] memory _pids = new uint8[](1);

        _pids[0] = _pid;



        uint256[3][] memory amountPools = eclipseV2

            .viewUserOfferingAndRefundingAmountsForPools(msg.sender, _pids);



        uint256 offeringTokenAmount = amountPools[0][0];



        uint256 offeringTokenAmountPerPeriod;



        require(offeringTokenAmount > 0, "did not participate");



        userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;



        if (offeringTokenAmount > 0) {

            offeringTokenAmountPerPeriod =

                (offeringTokenAmount *

                    eclipseV2.harvestReleasePercent(_harvestPeriod)) /

                1e4;



            offeringTokenAmountPerPeriod =

                offeringTokenAmountPerPeriod *

                exchangeRate;



            offeringToken.safeTransfer(

                address(msg.sender),

                offeringTokenAmountPerPeriod

            );

        }



        userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;



        emit Harvest(msg.sender, offeringTokenAmountPerPeriod, _pid);

    }



    function hasHarvested(

        address _user,

        uint8 _pid,

        uint8 _harvestPeriod

    ) public view returns (bool) {

        return userInfo[_user][_pid].claimed[_harvestPeriod];

    }



    function emergencyWithdraw(uint256 _offerAmount) external onlyOwner {

        require(

            _offerAmount <= offeringToken.balanceOf(address(this)),

            "Not enough offering tokens"

        );



        if (_offerAmount > 0) {

            offeringToken.safeTransfer(address(msg.sender), _offerAmount);

        }

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\CommonEclipseAmaraV2.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;

pragma solidity ^0.8.7;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "./ICommonEclipseAmaraV2.sol";

import "../v2/CommonEclipseV2.sol";



contract CommonEclipseAmaraV2 is ReentrancyGuard, Ownable {

    using SafeERC20 for IERC20;



    /*///////////////////////////////////////////////////////////////

                                STORAGE

    //////////////////////////////////////////////////////////////*/



    CommonEclipseV2 eclipseV2;

    CommonEclipseV2 amaraV2;

    IERC20 offeringToken;

    uint256 public exchangeRate;



    uint8 public constant HARVEST_PERIODS = 6; // number of periods to split offering token to vest.



    struct UserInfo {

        uint256 amount; // How many tokens the user has provided for pool

        uint256 allocPoints; // Used to weight user allocation based on amount locked in solar vaults

        bool[HARVEST_PERIODS] claimed; // Whether the user has claimed (default: false) for pool

        bool isRefunded; // Wheter the user has been refunded or not.

    }



    mapping(address => mapping(uint8 => UserInfo)) public _userInfo;



    event Harvest(

        address indexed user,

        uint256 offeringAmount,

        uint8 indexed pid

    );



    constructor(

        CommonEclipseV2 _eclipseV2,

        CommonEclipseV2 _amaraV2,

        IERC20 _offeringToken,

        uint256 _exchangeRate

    ) {

        require(_offeringToken.totalSupply() > 0);

        require(

            _isContract(address(_offeringToken)),

            "_offeringToken is not a contract address"

        );

        require(

            _isContract(address(_eclipseV2)),

            "_eclipseV2 is not a contract address"

        );

        require(

            _isContract(address(_amaraV2)),

            "_amaraV2 is not a contract address"

        );

        amaraV2 = _amaraV2;

        eclipseV2 = _eclipseV2;

        offeringToken = _offeringToken;

        exchangeRate = _exchangeRate;

    }



    /**

     * This method relies on extcodesize, which returns 0 for contracts in construction,

     * since the code is only stored at the end of the constructor execution.

     */

    function _isContract(address account) internal view returns (bool) {

        uint256 size;

        assembly {

            size := extcodesize(account)

        } // solhint-disable-next-line no-inline-assembly

        return size > 0;

    }



    function calculateAmountToClaim(

        address _user,

        uint8 _pid,

        uint8 _harvestPeriod

    ) public view returns (uint256 result) {

        uint8[] memory _pids = new uint8[](1);

        _pids[0] = _pid;



        uint256[3][] memory amountPools = eclipseV2

            .viewUserOfferingAndRefundingAmountsForPools(_user, _pids);



        uint256 offeringTokenAmount = amountPools[0][0];



        uint256 offeringTokenAmountPerPeriod = 0;

        result = 0;



        if (offeringTokenAmount > 0) {

            if (_pid == 0) {

                //BASIC

                if (!amaraV2.hasHarvested(_user, _pid, _harvestPeriod)) {

                    result =

                        ((offeringTokenAmount *

                            eclipseV2.harvestReleasePercent(_harvestPeriod)) /

                            1e4) *

                        exchangeRate;

                }

            } else {

                (uint256 amount, , ) = eclipseV2.userInfo(_user, _pid);



                (

                    uint256 raisingAmount,

                    uint256 offeringAmount,

                    ,

                    ,

                    ,

                    ,



                ) = eclipseV2.poolInfo(_pid);



                uint256 refundAmount = amountPools[0][1];



                /* TOTAL TOKENS */

                uint256 correctOfferingAmount = ((amount - refundAmount) *

                    offeringAmount) / raisingAmount;



                uint256 correctOfferingAmountPerPeriod = ((correctOfferingAmount *

                        eclipseV2.harvestReleasePercent(_harvestPeriod)) /

                        1e4) * exchangeRate;



                if (amaraV2.hasHarvested(_user, _pid, _harvestPeriod)) {

                    /* AMOUNT ALREADY PAID */

                    offeringTokenAmountPerPeriod =

                        ((offeringTokenAmount *

                            eclipseV2.harvestReleasePercent(_harvestPeriod)) /

                            1e4) *

                        exchangeRate;

                }



                if (

                    offeringTokenAmountPerPeriod >

                    correctOfferingAmountPerPeriod

                ) {

                    result = 0;

                } else {

                    result =

                        correctOfferingAmountPerPeriod -

                        offeringTokenAmountPerPeriod;

                }

            }

        }

    }



    /*///////////////////////////////////////////////////////////////

                            HARVEST LOGIC

    //////////////////////////////////////////////////////////////*/

    function harvestPool(uint8 _pid, uint8 _harvestPeriod)

        external

        nonReentrant

    {

        require(

            _harvestPeriod < HARVEST_PERIODS,

            "harvest period out of range"

        );



        require(

            block.timestamp >

                eclipseV2.harvestReleaseTimestamps(_harvestPeriod),

            "not harvest time"

        );



        require(

            !_userInfo[msg.sender][_pid].claimed[_harvestPeriod],

            "harvest for period already claimed"

        );



        uint256 userAmount = calculateAmountToClaim(

            msg.sender,

            _pid,

            _harvestPeriod

        );



        require(userAmount > 0, "no tokens to claim");



        _userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;



        offeringToken.safeTransfer(address(msg.sender), userAmount);



        _userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;



        emit Harvest(msg.sender, userAmount, _pid);

    }



    function hasHarvested(

        address _user,

        uint8 _pid,

        uint8 _harvestPeriod

    ) public view returns (bool) {

        uint256 userAmount = calculateAmountToClaim(

            _user,

            _pid,

            _harvestPeriod

        );



        return

            _userInfo[_user][_pid].claimed[_harvestPeriod] || userAmount == 0;

    }



    function emergencyWithdraw(uint256 _offerAmount) external onlyOwner {

        require(

            _offerAmount <= offeringToken.balanceOf(address(this)),

            "Not enough offering tokens"

        );



        if (_offerAmount > 0) {

            offeringToken.safeTransfer(address(msg.sender), _offerAmount);

        }

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\CommonEclipseV2.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "../../farm/SolarVault.sol";

import "../../solar/VestedSolarBeamToken.sol";

import "./ICommonEclipseV2.sol";



contract CommonEclipseV2 is ICommonEclipseV2, ReentrancyGuard, Ownable {

  using SafeERC20 for IERC20;



    /*///////////////////////////////////////////////////////////////

                                STORAGE

    //////////////////////////////////////////////////////////////*/



    IERC20 lpToken;

    IERC20 offeringToken;



    SolarVault public vault;



    IVestedSolarBeamToken public vesolar;



    uint8 public constant HARVEST_PERIODS = 6; // number of periods to split offering token to vest.



    uint8 public constant NUMBER_VAULT_POOLS = 3; // number of solar vault pools to check for stake.



    uint8 public constant NUMBER_THRESHOLDS = 3; // number of solar staked threshold for multipliers per pool.



    uint256[HARVEST_PERIODS] public harvestReleaseTimestamps;

    uint256[HARVEST_PERIODS] public harvestReleasePercent;



    uint256 public startTimestamp;



    uint256 public endTimestamp;



    uint256 public eligibilityThreshold; // minimum solar staked to be eligible.



    bool public claimEnabled = false; // flag to enable harvests after liquidity is added.



    /**

     * @dev The struct stores the each pools base multiplier, and additional

     * multipliers based on meeting staked threshold requirements.

     */

    struct Multipliers {

        uint16[NUMBER_THRESHOLDS] poolThresholds;

        uint8[NUMBER_VAULT_POOLS] poolBaseMult;

        uint8[NUMBER_THRESHOLDS][NUMBER_VAULT_POOLS] poolMultipliers;

    }



    struct UserInfo {

        uint256 amount; // How many tokens the user has provided for pool

        uint256 allocPoints; // Used to weight user allocation based on amount locked in solar vaults

        bool[HARVEST_PERIODS] claimed; // Whether the user has claimed (default: false) for pool

        bool isRefunded; // Wheter the user has been refunded or not.

    }



    struct PoolInfo {

        uint256 raisingAmount; // amount of tokens raised for the pool (in LP tokens)

        uint256 offeringAmount; // amount of tokens offered for the pool (in offeringTokens)

        uint256 baseLimitInLP; // base limit of tokens per eligible user (if 0, it is ignored)

        bool hasTax; // if a pool is to be taxed on overflow or not

        uint256 totalAmountPool; // total amount pool deposited (in LP tokens)

        uint256 sumTaxesOverflow; // total taxes collected (starts at 0, increases with each harvest if overflow)

        uint256 totalAllocPoints;

    }



    uint8 public constant numberPools = 2; // max number of pools that are to be created.



    mapping(address => mapping(uint8 => UserInfo)) public userInfo;



    PoolInfo[numberPools] public poolInfo;



    Multipliers private _multiplierInfo;



    /*///////////////////////////////////////////////////////////////

                                EVENTS

    //////////////////////////////////////////////////////////////*/

    event Deposit(address indexed user, uint256 amount, uint256 indexed pid);

    event Withdraw(address indexed user, uint256 amount, uint256 indexed pid);

    event Harvest(address indexed user, uint256 offeringAmount, uint256 excessAmount, uint8 indexed pid);

    event NewStartAndEndBlocks(uint256 startTimestamp, uint256 endTimestamp);

    event PoolParametersSet(uint256 raisingAmount, uint256 offeringAmount, uint8 pid);

    event MultiplierParametersSet(

        uint16[NUMBER_THRESHOLDS] poolStakedThresholds,

        uint8[NUMBER_VAULT_POOLS] poolBaseMultiplier,

        uint8[NUMBER_THRESHOLDS][NUMBER_VAULT_POOLS] poolStakedMultipliers

        );

    event EmergencyWithdraw(uint256 amountLP, uint256 amountOfferingToken);

    event FinalWithdraw(WITHDRAW_TYPE _type, uint256 amountLP, uint8 indexed pid);

    event AdminTokenRecovery(address token, uint256 amount);

    event ClaimEnabled();



    /*///////////////////////////////////////////////////////////////

                               MODIFIERS

    //////////////////////////////////////////////////////////////*/

    /**

     * @notice It checks if the current block is within the sale period.

     */

    modifier onlyWhenActive() {

        require(

            block.timestamp >= startTimestamp && block.timestamp < endTimestamp,

            "Sale not active"

        );

        _;

    }

    /**

     * @notice It checks if sale ended and claim is enabled

     */

    modifier onlyFinished() {

        require(block.timestamp >= endTimestamp && claimEnabled, "sale not finished");

        _;

    }

    /*///////////////////////////////////////////////////////////////

                              CONSTRUCTOR

    //////////////////////////////////////////////////////////////*/



    constructor(

        IERC20 _lpToken,

        uint256 _startTimestamp,

        uint256 _endTimestamp,

        uint256 _eligibilityThreshold, // (1e18)

        address _solarVault,

        address _vesolar,

        uint256[] memory _harvestReleasePercent,

        uint256[] memory _harvestReleaseTimestamps,

        bytes memory _multipliers

    ){

        require(_lpToken.totalSupply() > 0);

        lpToken = _lpToken;

        startTimestamp = _startTimestamp;

        endTimestamp = _endTimestamp;

        eligibilityThreshold = _eligibilityThreshold;

        vault = SolarVault(_solarVault);

        vesolar = IVestedSolarBeamToken(_vesolar);



        _setMultipliers(_multipliers);



        _setHarvest(HARVEST_TYPE.TIMESTAMP, _harvestReleaseTimestamps );

        _setHarvest(HARVEST_TYPE.PERCENT, _harvestReleasePercent );



    }



    function setOfferingToken(IERC20 _offeringToken) external onlyOwner {        

        require(_offeringToken.totalSupply() > 0);

        require(lpToken != _offeringToken, "Tokens must be different");

        offeringToken = _offeringToken;

    }



    /*///////////////////////////////////////////////////////////////

                            POOL MANAGEMENT

    //////////////////////////////////////////////////////////////*/



   /**

     * @notice It sets either the Timestamps for harvest or Percentages for harvest.

     * @param _type Enum, 0 for setting timestamp, 1 for setting percent

     * @param _input Array length of HARVEST_PERIODS for either timestamp or percentages

     */

    function setHarvest(HARVEST_TYPE _type, uint256[] memory _input) external onlyOwner {

        require( _input.length == HARVEST_PERIODS, "bad _input length");

        _setHarvest(_type, _input);

    }

   

    function _setHarvest(HARVEST_TYPE _type, uint256[] memory _input) internal {

        if ( _type == HARVEST_TYPE.TIMESTAMP ) {

            for (uint256 i = 0; i < HARVEST_PERIODS; i++) {

                harvestReleaseTimestamps[i] = _input[i];

            }

        } else if ( _type == HARVEST_TYPE.PERCENT ) {

            uint256 totalPercent;

            for (uint256 i = 0; i < HARVEST_PERIODS; i++) {

                harvestReleasePercent[i] = _input[i];

                totalPercent += _input[i];

            }

            require(totalPercent == 10000, "harvest percent must total 10000");

        }

    }

    /**

     * @notice It sets the threshold of solar staked to be eligible to participate.

     * @param _eligibilityThreshold: Number of solar staked to be eligibile. (1e18)

     */

    function setEligibilityThreshold(uint256 _eligibilityThreshold) public override onlyOwner {

        require(block.timestamp < startTimestamp, "sale is already active");

        eligibilityThreshold = _eligibilityThreshold;

    }

    /**

     * @notice It sets the multiplier matrix.

     * @param _multipliers: abi encoded arrays

     */

    function setMultipliers(bytes memory _multipliers) public override onlyOwner {

        require(block.timestamp < startTimestamp, "sale is already active");

        _setMultipliers(_multipliers);

    }

    /**

     * @notice Private helper to set multiplier matrix.

     */

    function _setMultipliers(bytes memory _multipliers) private {

        (

            uint16[] memory thresholds,

            uint8[] memory base,

            uint8[][] memory mults



            ) = abi.decode(_multipliers,(

                uint16[],

                uint8[],

                uint8[][]

            ));

        require(

            base.length == NUMBER_VAULT_POOLS && mults.length == NUMBER_VAULT_POOLS,

            "bad vault pool length"

        );

        require(thresholds.length == NUMBER_THRESHOLDS ,"bad threshold length");



        for (uint8 i = 0; i < NUMBER_THRESHOLDS; i++) {

            _multiplierInfo.poolThresholds[i] =  thresholds[i];

        }



        for (uint8 i = 0; i < NUMBER_VAULT_POOLS; i++){

            _multiplierInfo.poolBaseMult[i] = base[i];

            require(mults[i].length == NUMBER_THRESHOLDS, "bad threshold length");

            for ( uint8 j = 0; j < NUMBER_THRESHOLDS; j++) {

               _multiplierInfo.poolMultipliers[i][j] =  mults[i][j];

            }

        }



        emit MultiplierParametersSet(

            _multiplierInfo.poolThresholds,

            _multiplierInfo.poolBaseMult,

            _multiplierInfo.poolMultipliers

        );

    }



    /**

     * @notice It creates a pool.

     * @dev If _baseLimitInLP is set to zero, the allocation will be weighted by allocation points. (see below)

     * @param _raisingAmount: amount of LP token the pool aims to raise (1e18)

     * @param _offeringAmount: amount of IDO tokens the pool is offering (1e18)

     * @param _baseLimitInLP: base limit of tokens per eligible user (if 0, it is ignored) (1e18)

     * @param _hasTax: true if a pool is to be taxed on overflow

     * @param _pid: pool identification number

     */

    function setPool(

        uint256 _raisingAmount,

        uint256 _offeringAmount,

        uint256 _baseLimitInLP,

        bool _hasTax,

        uint8 _pid

    ) external override onlyOwner{

        require(block.timestamp < startTimestamp, "sale is already active");

        require(_pid < numberPools, "pool does not exist");



        poolInfo[_pid].raisingAmount = _raisingAmount;

        poolInfo[_pid].offeringAmount = _offeringAmount;

        poolInfo[_pid].baseLimitInLP = _baseLimitInLP;

        poolInfo[_pid].hasTax = _hasTax;



        emit PoolParametersSet(_offeringAmount, _raisingAmount, _pid);

    }

    /**

     * @notice It sets the start and end blocks of the sale.

     */

    function updateStartAndEndBlocks(uint256 _startTimestamp, uint256 _endTimestamp) external override onlyOwner {

        require(block.timestamp < startTimestamp, "sale is already active");

        require(_startTimestamp < _endTimestamp, "new startTimestamp must be lower than new endTimestamp");

        require(block.timestamp < _startTimestamp, "New startTimestamp must be higher than current block");



        startTimestamp = _startTimestamp;

        endTimestamp = _endTimestamp;



        emit NewStartAndEndBlocks(_startTimestamp, _endTimestamp);

    }

    /**

     * @notice It withdraws raisingAmount + taxes for a pool

     * @dev can only withdraw after the sale is finished

     * @param _type: withdraw type

     * @param _pid: pool id

     */

    function finalWithdraw(WITHDRAW_TYPE _type, uint8 _pid) external override onlyOwner {

        require(block.timestamp > endTimestamp, "sale has not finished");

        uint256 amount;

        if ( _type == WITHDRAW_TYPE.RAISING ) {

          amount = poolInfo[_pid].raisingAmount;

            lpToken.safeTransfer(address(msg.sender), amount);

        } else if ( _type == WITHDRAW_TYPE.TAX ) {

            // adjusting down by 1e2 due to sumTaxesOverflow precision being inaccurate

            amount = poolInfo[_pid].sumTaxesOverflow - 1e2;

            lpToken.safeTransfer(address(msg.sender), amount);

            poolInfo[_pid].sumTaxesOverflow = 0;

        }



        emit FinalWithdraw(_type, amount, _pid);

    }

    

    /**

     * @notice It allows the owner to withdraw LPtokens and Offering tokens, emergency only

     * @dev can only withdraw after the sale is finished

     * @param _lpAmount: amount of LP token to withdraw

     * @param _offerAmount: amount of IDO tokens to withdraw

     */

    function emergencyWithdraw(uint256 _lpAmount, uint256 _offerAmount) external onlyOwner {

        require(block.timestamp > endTimestamp, "sale has not finished");

        require(_lpAmount <= lpToken.balanceOf(address(this)), "Not enough LP tokens");

        require(_offerAmount <= offeringToken.balanceOf(address(this)), "Not enough offering tokens");



        if (_lpAmount > 0) {

            lpToken.safeTransfer(address(msg.sender), _lpAmount);

        }



        if (_offerAmount > 0) {

            offeringToken.safeTransfer(address(msg.sender), _offerAmount);

        }



        emit EmergencyWithdraw(_lpAmount, _offerAmount);

    }





    /**

     * @notice It allows the owner to withdraw ERC20 tokens

     * @dev cannot withdraw LP tokens or offering tokens

     * @param _tokenAddress: address of ERC20 token to withdraw

     * @param _amount: amount to withdraw

     */

    function sweep(address _tokenAddress, uint256 _amount) external onlyOwner {

        require(

            _tokenAddress != address(lpToken) && _tokenAddress != address(offeringToken),

            "Cannot be LP or Offering token"

        );

        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _amount);



        emit AdminTokenRecovery(_tokenAddress, _amount);

    }



    /*///////////////////////////////////////////////////////////////

                            DEPOSIT LOGIC

    //////////////////////////////////////////////////////////////*/

    /**

     * @notice It lets users deposit into a pool for a share of offering tokens

     * @dev cannot withdraw LP tokens or Offering tokens

     * @param _amount: amount of LP tokens to deposit

     * @param _pid: pool to depoist in

     */

    function depositPool(uint256 _amount, uint8 _pid) external override onlyWhenActive nonReentrant {

        UserInfo storage user = userInfo[msg.sender][_pid];



        require(_pid < numberPools, "pool does not exist");



        require(

            poolInfo[_pid].offeringAmount > 0 && poolInfo[_pid].raisingAmount > 0,

            "Pool not set"

        );



        for (uint8 i = 0; i < numberPools; i++) {

          if (i != _pid) {

            require(userInfo[msg.sender][i].amount == 0, "already commited in another pool");

          }

        }



        (bool success) = _getEligibility(msg.sender);

        require(success, "user not eligible");



        uint256 beforeDeposit = lpToken.balanceOf(address(this));

        lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);

        uint256 afterDeposit = lpToken.balanceOf(address(this));

        

        _amount = afterDeposit - beforeDeposit;



        user.amount += _amount;



        if (poolInfo[_pid].baseLimitInLP > 0) {

            (uint16 multiplier) = getUserMultiplier(msg.sender);

            require(

                user.amount <= (poolInfo[_pid].baseLimitInLP * uint256(multiplier)), "New amount above user limit"

            );

        } else {

            (uint16 multiplier) = getUserMultiplier(msg.sender);

            poolInfo[_pid].totalAllocPoints -= userInfo[msg.sender][_pid].allocPoints;

            userInfo[msg.sender][_pid].allocPoints = user.amount * uint256(multiplier);

            poolInfo[_pid].totalAllocPoints += userInfo[msg.sender][_pid].allocPoints;

        }

        poolInfo[_pid].totalAmountPool += _amount;



        emit Deposit(msg.sender,_amount,_pid);



    }



    function getUserEligibility(address _user) public view returns(bool) {

        return _getEligibility(_user);

    }



    function _getEligibility(address _user) internal view returns(bool) {

        uint256 amount;



        //veSOLAR support

        uint256 vesolarAmount = vesolar.userLockedAmount(_user);

        if (vesolarAmount >= eligibilityThreshold) {

            return true;

        }       

        //veSOLAR support



        for (uint256 i=0; i<NUMBER_VAULT_POOLS; i++) {

            (amount,,,,) = vault.userInfo(i,_user);

            if (amount >= eligibilityThreshold) {

                return true;

            }            

        }



        return false;

    }



    function getUserMultiplier(address _user) public view returns(uint16) {

        uint16 userMult;

        uint16 mult;

        uint256 amount;



        //veSOLAR support

        uint256 vesolarAmount = vesolar.userLockedAmount(_user);        

        uint256 vesolarLockedUntil = vesolar.userLockedUntil(_user);

        uint256 daysLeft = (vesolarLockedUntil - block.timestamp) / (60*60*24);        



        for (uint8 i=0; i<NUMBER_VAULT_POOLS; i++) {

            uint256 _veAmount = (i == 0 || i == 1 && daysLeft >= 7 || i == 2 && daysLeft >= 30) ? vesolarAmount : 0;

            for (uint8 j=0; j<NUMBER_THRESHOLDS; j++) {

                mult = uint16(_multiplierInfo.poolBaseMult[i]) * uint16(_multiplierInfo.poolMultipliers[i][j]);

                if(_veAmount >= uint256(_multiplierInfo.poolThresholds[j])*1e18) {

                    if(mult > userMult) {

                        userMult = mult;

                    }

                }

            }

        }

        //veSOLAR support



        for (uint8 i=0; i<NUMBER_VAULT_POOLS; i++) {

            (amount,,,,) = vault.userInfo(i,_user);    

            for (uint8 j=0; j<NUMBER_THRESHOLDS; j++) {

                mult = uint16(_multiplierInfo.poolBaseMult[i]) * uint16(_multiplierInfo.poolMultipliers[i][j]);

                if(amount >= uint256(_multiplierInfo.poolThresholds[j])*1e18) {

                    if(mult > userMult) {

                        userMult = mult;

                    }

                }

            }

        }

        return (userMult);

    }



    /*///////////////////////////////////////////////////////////////

                            WITHDRAW LOGIC

    //////////////////////////////////////////////////////////////*/

    function withdrawPool(uint256 _amount, uint8 _pid)

        external

        override

        nonReentrant

        onlyWhenActive

    {

        UserInfo storage user = userInfo[msg.sender][_pid];

        require(_pid < numberPools, "pool does not exist");

        require(

            poolInfo[_pid].offeringAmount > 0 &&

                poolInfo[_pid].raisingAmount > 0,

            "pool not set"

        );



        require(

            _amount > 0 && user.amount > 0 && user.amount >= _amount,

            "withdraw: amount higher than user balance"

        );



        user.amount -= _amount;

        poolInfo[_pid].totalAmountPool -= _amount;



        if (poolInfo[_pid].baseLimitInLP == 0) {

            (uint16 multiplier) = getUserMultiplier(msg.sender);

            poolInfo[_pid].totalAllocPoints -= userInfo[msg.sender][_pid].allocPoints;

            userInfo[msg.sender][_pid].allocPoints = user.amount * uint256(multiplier);

            poolInfo[_pid].totalAllocPoints += userInfo[msg.sender][_pid].allocPoints;

        }



        lpToken.safeTransfer(address(msg.sender), _amount);



        emit Withdraw(msg.sender, _amount, _pid);

    }



    /*///////////////////////////////////////////////////////////////

                            HARVEST LOGIC

    //////////////////////////////////////////////////////////////*/

    function userHasRefund(uint8 _pid, address _user) external view returns(bool) {

        if (_pid < numberPools && userInfo[_user][_pid].amount > 0){

            uint256 refundingTokenAmount;



            (, refundingTokenAmount,) = _calcOfferingAndRefundingAmounts(

                _user,

                _pid

            );



            if (refundingTokenAmount > 0) {

                return true;

            }

        }      

        return false;

    }



    /*///////////////////////////////////////////////////////////////

                            HARVEST LOGIC

    //////////////////////////////////////////////////////////////*/

    function claimRefund(uint8 _pid) external nonReentrant onlyFinished {

        require(_pid < numberPools, "pool does not exist");

        require(userInfo[msg.sender][_pid].amount > 0, "did not participate");

        require(!userInfo[msg.sender][_pid].isRefunded, "already refunded");



        userInfo[msg.sender][_pid].isRefunded = true;



        uint256 refundingTokenAmount;

        uint256 userTaxOverflow;



        (, refundingTokenAmount, userTaxOverflow) = _calcOfferingAndRefundingAmounts(

            msg.sender,

            _pid

        );



        if (userTaxOverflow > 0) {

            poolInfo[_pid].sumTaxesOverflow += userTaxOverflow;

        }

        

        if (refundingTokenAmount > 0) {

            lpToken.safeTransfer(address(msg.sender), refundingTokenAmount);

        }

    }



    /*///////////////////////////////////////////////////////////////

                            HARVEST LOGIC

    //////////////////////////////////////////////////////////////*/

    function harvestPool(uint8 _pid, uint8 _harvestPeriod) external override nonReentrant onlyFinished {

        require(_pid < numberPools, "pool does not exist");

        require(_harvestPeriod < HARVEST_PERIODS, "harvest period out of range");

        require(block.timestamp > harvestReleaseTimestamps[_harvestPeriod], "not harvest time");

        require(userInfo[msg.sender][_pid].amount > 0, "did not participate");

        require(!userInfo[msg.sender][_pid].claimed[_harvestPeriod], "harvest for period already claimed");



        userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;



        uint256 offeringTokenAmount;

        uint256 refundingTokenAmount;

        uint256 userTaxOverflow;

        (offeringTokenAmount, refundingTokenAmount, userTaxOverflow) = _calcOfferingAndRefundingAmounts(

            msg.sender,

            _pid

        );

        if (userTaxOverflow > 0 && !userInfo[msg.sender][_pid].isRefunded) {

            poolInfo[_pid].sumTaxesOverflow += userTaxOverflow;

        }

        if (refundingTokenAmount > 0 && !userInfo[msg.sender][_pid].isRefunded) {

            userInfo[msg.sender][_pid].isRefunded = true;

            lpToken.safeTransfer(address(msg.sender), refundingTokenAmount);

        }



        uint256 offeringTokenAmountPerPeriod;

        if (offeringTokenAmount > 0) {

            offeringTokenAmountPerPeriod = offeringTokenAmount * harvestReleasePercent[_harvestPeriod] / 1e4;

            offeringToken.safeTransfer(address(msg.sender), offeringTokenAmountPerPeriod);

        }

        userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;



        emit Harvest(msg.sender, offeringTokenAmountPerPeriod, refundingTokenAmount,_pid);





    }



    function _calcOfferingAndRefundingAmounts(address _user, uint8 _pid)

        internal

        view

        returns (

            uint256,

            uint256,

            uint256

        )

    {

        uint256 userOfferingAmount;

        uint256 userRefundingAmount;

        uint256 taxAmount;



        if (poolInfo[_pid].totalAmountPool > poolInfo[_pid].raisingAmount) {



            uint256 allocation = _getUserAllocation(_user,_pid);



            userOfferingAmount = poolInfo[_pid].offeringAmount * allocation / 1e12;



            uint256 payAmount = poolInfo[_pid].raisingAmount * userInfo[_user][_pid].amount * 1e18 / poolInfo[_pid].totalAmountPool  / 1e18;



            userRefundingAmount = userInfo[_user][_pid].amount - payAmount;

            if (poolInfo[_pid].hasTax) {

                uint256 taxOverflow =

                    _calculateTaxOverflow(

                        poolInfo[_pid].totalAmountPool,

                        poolInfo[_pid].raisingAmount

                    );

                taxAmount = userRefundingAmount * taxOverflow / 1e12;



                userRefundingAmount -= taxAmount;

            }

        } else {

            userRefundingAmount = 0;

            taxAmount = 0;

            if (poolInfo[_pid].baseLimitInLP > 0) {

                userOfferingAmount = userInfo[_user][_pid].amount * poolInfo[_pid].offeringAmount / poolInfo[_pid].raisingAmount;

            } else {

                userOfferingAmount = poolInfo[_pid].offeringAmount * _getUserAllocation(_user,_pid) / 1e12;

            }

        }

        return (userOfferingAmount, userRefundingAmount, taxAmount);

    }

    /**

     * @notice It returns the user allocation for pool

     * @dev (1e8) 10,000,000 means 0.1 (10%) / 1 means 0.000000001 (0.0000001%) / 100,000,000 means 1 (100%)

     * @param _user: user address

     * @param _pid: pool id

     * @return it returns the user's share of pool

     */

    function _getUserAllocation(address _user, uint8 _pid) view internal  returns (uint256) {

        if (poolInfo[_pid].totalAmountPool > 0) {

            if(poolInfo[_pid].baseLimitInLP > 0) {

                return userInfo[_user][_pid].amount * 1e18 / poolInfo[_pid].totalAmountPool / 1e6;

            } else {

                return userInfo[_user][_pid].allocPoints * 1e18 / poolInfo[_pid].totalAllocPoints / 1e6;

            }

        } else {

            return 0;

        }

    }



    /**

     * @notice It calculates the tax overflow given the raisingAmountPool and the totalAmountPool.

     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)

     * @return It returns the tax percentage

     */

    function _calculateTaxOverflow(uint256 _totalAmountPool, uint256 _raisingAmountPool)

        internal

        pure

        returns (uint256)

    {

        uint256 ratioOverflow = _totalAmountPool / _raisingAmountPool;



        if (ratioOverflow >= 500) {

            return 2000000000; // 0.2%

        } else if (ratioOverflow >= 250) {

            return 2500000000; // 0.25%

        } else if (ratioOverflow >= 100) {

            return 3000000000; // 0.3%

        } else if (ratioOverflow >= 50) {

            return 5000000000; // 0.5%

        } else {

            return 10000000000; // 1%

        }

    }



    /*///////////////////////////////////////////////////////////////

                            PUBLIC GETTERS

    //////////////////////////////////////////////////////////////*/

    function hasHarvested(address _user, uint8 _pid, uint8 _harvestPeriod) public view returns (bool) {

        return userInfo[_user][_pid].claimed[_harvestPeriod];

    }



    /**

     * @notice It returns the tax overflow rate calculated for a pool

     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)

     * @param _pid: poolId

     * @return It returns the tax percentage

     */

    function viewPoolTaxRateOverflow(uint256 _pid) external view override returns (uint256) {

        if (!poolInfo[_pid].hasTax) {

            return 0;

        } else {

            return

                _calculateTaxOverflow(poolInfo[_pid].totalAmountPool, poolInfo[_pid].raisingAmount);

        }

    }



    /**

     * @notice External view function to see user allocations for both pools

     * @param _user: user address

     * @param _pids[]: array of pids

     * @return

     */

    function viewUserAllocationPools(address _user, uint8[] calldata _pids)

        external

        view

        override

        returns (uint256[] memory)

    {

        uint256[] memory allocationPools = new uint256[](_pids.length);

        for (uint8 i = 0; i < _pids.length; i++) {

            allocationPools[i] = _getUserAllocation(_user, _pids[i]);

        }

        return allocationPools;

    }



    /**

     * @notice External view function to see user offering and refunding amounts for both pools

     * @param _user: user address

     * @param _pids: array of pids

     */

    function viewUserOfferingAndRefundingAmountsForPools(address _user, uint8[] calldata _pids)

        external

        view

        override

        returns (uint256[3][] memory)

    {

        uint256[3][] memory amountPools = new uint256[3][](_pids.length);



        for (uint8 i = 0; i < _pids.length; i++) {

            uint256 userOfferingAmountPool;

            uint256 userRefundingAmountPool;

            uint256 userTaxAmountPool;



            if (poolInfo[_pids[i]].raisingAmount > 0) {

                (

                    userOfferingAmountPool,

                    userRefundingAmountPool,

                    userTaxAmountPool

                ) = _calcOfferingAndRefundingAmounts(_user, _pids[i]);

            }



            amountPools[i] = [userOfferingAmountPool, userRefundingAmountPool, userTaxAmountPool];

        }

        return amountPools;

    }



    function viewMultipliers()

        public

        view

        returns(

            uint16[] memory,

            uint8[] memory,

            uint8[][] memory

        )

    {

        uint16[] memory _poolThresholds = new uint16[](_multiplierInfo.poolThresholds.length);

        for (uint16 i = 0; i < _multiplierInfo.poolThresholds.length ;i++) {

            _poolThresholds[i] = _multiplierInfo.poolThresholds[i];

        }



        uint8[] memory _poolBaseMult = new uint8[](_multiplierInfo.poolBaseMult.length);

        for (uint8 i = 0; i < _multiplierInfo.poolBaseMult.length ;i++) {

            _poolBaseMult[i] = _multiplierInfo.poolBaseMult[i];

        }



        uint8[][] memory _poolMultipliers = new uint8[][](_multiplierInfo.poolMultipliers.length);

        for (uint8 i = 0; i < _multiplierInfo.poolMultipliers.length;i++) {

            _poolMultipliers[i] = new uint8[](_multiplierInfo.poolMultipliers[i].length);

            for (uint8 j = 0;j < _multiplierInfo.poolMultipliers[i].length;j++) {

                _poolMultipliers[i][j] = _multiplierInfo.poolMultipliers[i][j];

            }

        }



        return(

            _poolThresholds,

            _poolBaseMult,

            _poolMultipliers

        );

    }



    function enableClaim() external override onlyOwner {

        require(block.timestamp >= endTimestamp, "sale still active");

        require(!claimEnabled, "claim is already enabled");



        claimEnabled = true;



        emit ClaimEnabled();

    }



}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ComplexRewarderPerSec.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

pragma experimental ABIEncoderV2;



import "@openzeppelin/contracts/utils/Address.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "./IComplexRewarder.sol";

import "../ISolarDistributorV2.sol";

import "../libraries/BoringERC20.sol";



/**

 * This is a sample contract to be used in the SolarDistributorV2 contract for partners to reward

 * stakers with their native token alongside SOLAR.

 *

 * It assumes no minting rights, so requires a set amount of YOUR_TOKEN to be transferred to this contract prior.

 * E.g. say you've allocated 100,000 XYZ to the SOLAR-XYZ farm over 30 days. Then you would need to transfer

 * 100,000 XYZ and set the block reward accordingly so it's fully distributed after 30 days.

 */

contract ComplexRewarderPerSec is IComplexRewarder, Ownable, ReentrancyGuard {

    using BoringERC20 for IBoringERC20;



    IBoringERC20 public immutable override rewardToken;

    ISolarDistributorV2 public immutable distributorV2;

    bool public immutable isNative;



    /// @notice Info of each distributorV2 user.

    /// `amount` LP token amount the user has provided.

    /// `rewardDebt` The amount of YOUR_TOKEN entitled to the user.

    struct UserInfo {

        uint256 amount;

        uint256 rewardDebt;

    }



    /// @notice Info of each distributorV2 poolInfo.

    /// `accTokenPerShare` Amount of YOUR_TOKEN each LP token is worth.

    /// `lastRewardTimestamp` The last timestamp YOUR_TOKEN was rewarded to the poolInfo.

    /// `allocPoint` The amount of allocation points assigned to the pool.

    struct PoolInfo {

        uint256 accTokenPerShare;

        uint256 lastRewardTimestamp;

        uint256 allocPoint;

    }



    /// @notice Info of each pool.

    mapping(uint256 => PoolInfo) public poolInfo;



    uint256[] public poolIds;



    /// @notice Info of each user that stakes LP tokens.

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    /// @dev Total allocation points. Must be the sum of all allocation points in all pools.

    uint256 public totalAllocPoint = 0;



    uint256 public tokenPerSec;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;



    event OnReward(address indexed user, uint256 amount);

    event RewardRateUpdated(uint256 oldRate, uint256 newRate);

    event AddPool(uint256 indexed pid, uint256 allocPoint);

    event SetPool(uint256 indexed pid, uint256 allocPoint);

    event UpdatePool(

        uint256 indexed pid,

        uint256 lastRewardTimestamp,

        uint256 lpSupply,

        uint256 accTokenPerShare

    );



    modifier onlyDistributorV2() {

        require(

            msg.sender == address(distributorV2),

            "onlyDistributorV2: only SolarDistributorV2 can call this function"

        );

        _;

    }



    constructor(

        IBoringERC20 _rewardToken,

        uint256 _tokenPerSec,

        ISolarDistributorV2 _distributorV2,

        bool _isNative

    ) {

        require(

            Address.isContract(address(_rewardToken)),

            "constructor: reward token must be a valid contract"

        );

        require(

            Address.isContract(address(_distributorV2)),

            "constructor: SolarDistributorV2 must be a valid contract"

        );

        rewardToken = _rewardToken;

        tokenPerSec = _tokenPerSec;

        distributorV2 = _distributorV2;

        isNative = _isNative;

    }



    /// @notice Add a new pool. Can only be called by the owner.

    /// @param _pid pool id on DistributorV2

    /// @param _allocPoint allocation of the new pool.

    function add(uint256 _pid, uint256 _allocPoint) public onlyOwner {

        require(poolInfo[_pid].lastRewardTimestamp == 0, "pool already exists");

        totalAllocPoint += _allocPoint;



        poolInfo[_pid] = PoolInfo({

            allocPoint: _allocPoint,

            lastRewardTimestamp: block.timestamp,

            accTokenPerShare: 0

        });

        poolIds.push(_pid);

        emit AddPool(_pid, _allocPoint);

    }



    /// @notice Update the given pool's allocation point and `IRewarder` contract. Can only be called by the owner.

    /// @param _pid The index of the pool. See `poolInfo`.

    /// @param _allocPoint New AP of the pool.

    function set(uint256 _pid, uint256 _allocPoint) public onlyOwner {

        totalAllocPoint =

            totalAllocPoint -

            poolInfo[_pid].allocPoint +

            _allocPoint;

        poolInfo[_pid].allocPoint = _allocPoint;

        emit SetPool(_pid, _allocPoint);

    }



    /// @notice Sets the distribution reward rate. This will also update the poolInfo.

    /// @param _tokenPerSec The number of tokens to distribute per second

    function setRewardRate(uint256 _tokenPerSec) external onlyOwner {

        massUpdatePools();

        emit RewardRateUpdated(tokenPerSec, _tokenPerSec);

        tokenPerSec = _tokenPerSec;

    }



    /// @notice Update reward variables of the given pool.

    /// @param pid The index of the pool. See `poolInfo`.

    /// @return pool Returns the pool that was updated.

    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {

        pool = poolInfo[pid];



        if (block.timestamp > pool.lastRewardTimestamp) {

            uint256 lpSupply = distributorV2.poolTotalLp(pid);



            if (lpSupply > 0) {

                uint256 timeElapsed = block.timestamp -

                    pool.lastRewardTimestamp;

                uint256 tokenReward = (timeElapsed *

                    tokenPerSec *

                    pool.allocPoint) / totalAllocPoint;

                pool.accTokenPerShare += ((tokenReward * ACC_TOKEN_PRECISION) /

                    lpSupply);

            }



            pool.lastRewardTimestamp = block.timestamp;

            poolInfo[pid] = pool;

            emit UpdatePool(

                pid,

                pool.lastRewardTimestamp,

                lpSupply,

                pool.accTokenPerShare

            );

        }

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function massUpdatePools() public {

        uint256 length = poolIds.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            updatePool(poolIds[pid]);

        }

    }



    /// @notice internal function to see balance of reward token.

    function _balance() internal view returns (uint256) {

        if (isNative) {

            return address(this).balance;

        } else {

            return rewardToken.balanceOf(address(this));

        }

    }



    /// @notice Function called by SolarDistributorV2 whenever staker claims SOLAR harvest. Allows staker to also receive a 2nd reward token.

    /// @param _user Address of user

    /// @param _lpAmount Number of LP tokens the user has

    function onSolarReward(

        uint256 _pid,

        address _user,

        uint256 _lpAmount

    ) external override onlyDistributorV2 nonReentrant {

        PoolInfo memory pool = updatePool(_pid);

        UserInfo storage user = userInfo[_pid][_user];

        uint256 pending;

        uint256 rewardBalance = _balance();

        if (user.amount > 0) {

            pending = (((user.amount * pool.accTokenPerShare) /

                ACC_TOKEN_PRECISION) - user.rewardDebt);



            if (isNative) {

                if (pending > rewardBalance) {

                    (bool success, ) = _user.call{value: rewardBalance}("");

                    require(success, "Transfer failed");

                } else {

                    (bool success, ) = _user.call{value: pending}("");

                    require(success, "Transfer failed");

                }

            } else {

                if (pending > rewardBalance) {

                    rewardToken.safeTransfer(_user, rewardBalance);

                } else {

                    rewardToken.safeTransfer(_user, pending);

                }

            }

        }

        user.amount = _lpAmount;

        user.rewardDebt =

            (user.amount * pool.accTokenPerShare) /

            ACC_TOKEN_PRECISION;



        emit OnReward(_user, pending);

    }



    /// @notice View function to see pending tokens

    /// @param _pid pool id.

    /// @param _user Address of user.

    /// @return pending reward for a given user.

    function pendingTokens(uint256 _pid, address _user)

        external

        view

        override

        returns (uint256 pending)

    {

        PoolInfo memory pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_user];



        uint256 accTokenPerShare = pool.accTokenPerShare;

        uint256 lpSupply = distributorV2.poolTotalLp(_pid);



        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {

            uint256 timeElapsed = block.timestamp - pool.lastRewardTimestamp;

            uint256 tokenReward = (timeElapsed *

                tokenPerSec *

                pool.allocPoint) / totalAllocPoint;

            accTokenPerShare += (tokenReward * ACC_TOKEN_PRECISION) / lpSupply;

        }



        pending = (((user.amount * accTokenPerShare) / ACC_TOKEN_PRECISION) -

            user.rewardDebt);

    }



    /// @notice In case rewarder is stopped before emissions finished, this function allows

    /// withdrawal of remaining tokens.

    function emergencyWithdraw() public onlyOwner {

        if (isNative) {

            (bool success, ) = msg.sender.call{value: address(this).balance}(

                ""

            );

            require(success, "Transfer failed");

        } else {

            rewardToken.safeTransfer(

                address(msg.sender),

                rewardToken.balanceOf(address(this))

            );

        }

    }



    /// @notice View function to see pool rewards per sec

    function poolRewardsPerSec(uint256 _pid)

        external

        view

        override

        returns (uint256)

    {

        PoolInfo storage pool = poolInfo[_pid];

        return (pool.allocPoint * tokenPerSec) / totalAllocPoint;

    }



    /// @notice View function to see balance of reward token.

    function balance() external view returns (uint256) {

        return _balance();

    }



    /// @notice payable function needed to receive MOVR

    receive() external payable {}

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ComplexRewarderPerSecV2.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

pragma experimental ABIEncoderV2;



import "@openzeppelin/contracts/utils/Address.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "./IComplexRewarder.sol";

import "../ISolarDistributorV2.sol";

import "../libraries/BoringERC20.sol";



/**

 * This is a sample contract to be used in the SolarDistributorV2 contract for partners to reward

 * stakers with their native token alongside SOLAR.

 *

 * It assumes no minting rights, so requires a set amount of YOUR_TOKEN to be transferred to this contract prior.

 * E.g. say you've allocated 100,000 XYZ to the SOLAR-XYZ farm over 30 days. Then you would need to transfer

 * 100,000 XYZ and set the block reward accordingly so it's fully distributed after 30 days.

 */

contract ComplexRewarderPerSecV2 is IComplexRewarder, Ownable, ReentrancyGuard {

    using BoringERC20 for IBoringERC20;



    IBoringERC20 public immutable override rewardToken;

    ISolarDistributorV2 public immutable distributorV2;

    bool public immutable isNative;



    /// @notice Info of each distributorV2 user.

    /// `amount` LP token amount the user has provided.

    /// `rewardDebt` The amount of REWARD entitled to the user.

    struct UserInfo {

        uint256 amount;

        uint256 rewardDebt;

    }



    /// @notice Info of each distributorV2 poolInfo.

    /// `accTokenPerShare` Amount of REWARD each LP token is worth.

    /// `startTimestamp` The start timestamp of rewards.

    /// `lastRewardTimestamp` The last timestamp REWARD was rewarded to the poolInfo.

    /// `allocPoint` The amount of allocation points assigned to the pool.

    /// `totalRewards` The amount of rewards added to the pool.

    struct PoolInfo {

        uint256 accTokenPerShare;

        uint256 startTimestamp;

        uint256 lastRewardTimestamp;

        uint256 allocPoint;

        uint256 totalRewards;

    }



    /// @notice Reward info

    /// `startTimestamp` The start timestamp of rewards

    /// `endTimestamp` The end timestamp of rewards

    /// `rewardPerSec` The amount of rewards per second

    struct RewardInfo {

        uint256 startTimestamp;

        uint256 endTimestamp;

        uint256 rewardPerSec;

    }



    /// @notice Info of each pool.

    mapping(uint256 => PoolInfo) public poolInfo;



    /// @dev this is mostly used for extending reward period

    /// @notice Reward info is a set of {endTimestamp, rewardPerSec}

    /// indexed by pool id

    mapping(uint256 => RewardInfo[]) public poolRewardInfo;



    uint256[] public poolIds;



    /// @notice Info of each user that stakes LP tokens.

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    /// @dev Total allocation points. Must be the sum of all allocation points in all pools.

    uint256 public totalAllocPoint = 0;



    /// @notice limit length of reward info

    /// how many phases are allowed

    uint256 public immutable rewardInfoLimit = 52; //1y



    // The precision factor

    uint256 private immutable ACC_TOKEN_PRECISION;



    event OnReward(address indexed user, uint256 amount);

    event RewardRateUpdated(uint256 oldRate, uint256 newRate);

    event AddPool(uint256 indexed pid, uint256 allocPoint);

    event SetPool(uint256 indexed pid, uint256 allocPoint);

    event UpdatePool(

        uint256 indexed pid,

        uint256 lastRewardTimestamp,

        uint256 lpSupply,

        uint256 accTokenPerShare

    );



    event AddRewardInfo(

        uint256 indexed pid,

        uint256 indexed phase,

        uint256 endTimestamp,

        uint256 rewardPerSec

    );



    modifier onlyDistributorV2() {

        require(

            msg.sender == address(distributorV2),

            "onlyDistributorV2: only DistributorV2 can call this function"

        );

        _;

    }



    constructor(

        IBoringERC20 _rewardToken,

        ISolarDistributorV2 _distributorV2,

        bool _isNative

    ) {

        require(

            Address.isContract(address(_rewardToken)),

            "constructor: reward token must be a valid contract"

        );

        require(

            Address.isContract(address(_distributorV2)),

            "constructor: SolarDistributorV2 must be a valid contract"

        );

        rewardToken = _rewardToken;

        distributorV2 = _distributorV2;

        isNative = _isNative;



        uint256 decimalsRewardToken = uint256(

            _isNative ? 18 : _rewardToken.safeDecimals()

        );

        require(

            decimalsRewardToken < 30,

            "constructor: reward token decimals must be inferior to 30"

        );



        ACC_TOKEN_PRECISION = uint256(

            10**(uint256(30) - (decimalsRewardToken))

        );

    }



    /// @notice Add a new pool. Can only be called by the owner.

    /// @param _pid pool id on DistributorV2

    /// @param _allocPoint allocation of the new pool.

    function add(

        uint256 _pid,

        uint256 _allocPoint,

        uint256 _startTimestamp

    ) public onlyOwner {

        require(poolInfo[_pid].lastRewardTimestamp == 0, "pool already exists");

        totalAllocPoint += _allocPoint;



        poolInfo[_pid] = PoolInfo({

            allocPoint: _allocPoint,

            startTimestamp: _startTimestamp,

            lastRewardTimestamp: _startTimestamp,

            accTokenPerShare: 0,

            totalRewards: 0

        });



        poolIds.push(_pid);

        emit AddPool(_pid, _allocPoint);

    }



    /// @notice if the new reward info is added, the reward & its end timestamp will be extended by the newly pushed reward info.

    function addRewardInfo(

        uint256 _pid,

        uint256 _endTimestamp,

        uint256 _rewardPerSec

    ) external payable onlyOwner {

        RewardInfo[] storage rewardInfo = poolRewardInfo[_pid];

        PoolInfo storage pool = poolInfo[_pid];

        require(

            rewardInfo.length < rewardInfoLimit,

            "add reward info: reward info length exceeds the limit"

        );

        require(

            rewardInfo.length == 0 ||

                rewardInfo[rewardInfo.length - 1].endTimestamp >=

                block.timestamp,

            "add reward info: reward period ended"

        );

        require(

            rewardInfo.length == 0 ||

                rewardInfo[rewardInfo.length - 1].endTimestamp < _endTimestamp,

            "add reward info: bad new endTimestamp"

        );



        uint256 startTimestamp = rewardInfo.length == 0

            ? pool.startTimestamp

            : rewardInfo[rewardInfo.length - 1].endTimestamp;



        uint256 timeRange = _endTimestamp - startTimestamp;

        uint256 totalRewards = timeRange * _rewardPerSec;



        if (!isNative) {

            rewardToken.safeTransferFrom(

                msg.sender,

                address(this),

                totalRewards

            );

        } else {

            require(

                msg.value == totalRewards,

                "add reward info: not enough funds to transfer"

            );

        }



        pool.totalRewards += totalRewards;



        rewardInfo.push(

            RewardInfo({

                startTimestamp: startTimestamp,

                endTimestamp: _endTimestamp,

                rewardPerSec: _rewardPerSec

            })

        );



        emit AddRewardInfo(

            _pid,

            rewardInfo.length - 1,

            _endTimestamp,

            _rewardPerSec

        );

    }



    function _endTimestampOf(uint256 _pid, uint256 _timestamp)

        internal

        view

        returns (uint256)

    {

        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];

        uint256 len = rewardInfo.length;

        if (len == 0) {

            return 0;

        }

        for (uint256 i = 0; i < len; ++i) {

            if (_timestamp <= rewardInfo[i].endTimestamp)

                return rewardInfo[i].endTimestamp;

        }



        /// @dev when couldn't find any reward info, it means that _timestamp exceed endTimestamp

        /// so return the latest reward info.

        return rewardInfo[len - 1].endTimestamp;

    }



    /// @notice this will return end timestamp based on the current block timestamp.

    function currentEndTimestamp(uint256 _pid) external view returns (uint256) {

        return _endTimestampOf(_pid, block.timestamp);

    }



    /// @notice Return reward multiplier over the given _from to _to timestamp.

    function _getTimeElapsed(

        uint256 _from,

        uint256 _to,

        uint256 _endTimestamp

    ) public pure returns (uint256) {

        if ((_from >= _endTimestamp) || (_from > _to)) {

            return 0;

        }

        if (_to <= _endTimestamp) {

            return _to - _from;

        }

        return _endTimestamp - _from;

    }



    /// @notice Update reward variables of the given pool.

    /// @param _pid The index of the pool. See `poolInfo`.

    /// @return pool Returns the pool that was updated.

    function updatePool(uint256 _pid)

        external

        nonReentrant

        returns (PoolInfo memory pool)

    {

        return _updatePool(_pid);

    }



    /// @notice Update reward variables of the given pool.

    /// @param pid The index of the pool. See `poolInfo`.

    /// @return pool Returns the pool that was updated.

    function _updatePool(uint256 pid) public returns (PoolInfo memory pool) {

        pool = poolInfo[pid];

        RewardInfo[] memory rewardInfo = poolRewardInfo[pid];



        if (block.timestamp <= pool.lastRewardTimestamp) {

            return pool;

        }



        uint256 lpSupply = distributorV2.poolTotalLp(pid);



        if (lpSupply == 0) {

            // if there is no total supply, return and use the pool's start timestamp as the last reward timestamp

            // so that ALL reward will be distributed.

            // however, if the first deposit is out of reward period, last reward timestamp will be its timestamp

            // in order to keep the multiplier = 0

            if (block.timestamp > _endTimestampOf(pid, block.timestamp)) {

                pool.lastRewardTimestamp = block.timestamp;

                emit UpdatePool(

                    pid,

                    pool.lastRewardTimestamp,

                    lpSupply,

                    pool.accTokenPerShare

                );

            }



            return pool;

        }



        /// @dev for each reward info

        for (uint256 i = 0; i < rewardInfo.length; ++i) {

            // @dev get multiplier based on current timestamp and rewardInfo's end timestamp

            // multiplier will be a range of either (current timestamp - pool.timestamp)

            // or (reward info's endtimestamp - pool.timestamp) or 0

            uint256 timeElapsed = _getTimeElapsed(

                pool.lastRewardTimestamp,

                block.timestamp,

                rewardInfo[i].endTimestamp

            );

            if (timeElapsed == 0) continue;



            // @dev if currentTimestamp exceed end timestamp, use end timestamp as the last reward timestamp

            // so that for the next iteration, previous endTimestamp will be used as the last reward timestamp

            if (block.timestamp > rewardInfo[i].endTimestamp) {

                pool.lastRewardTimestamp = rewardInfo[i].endTimestamp;

            } else {

                pool.lastRewardTimestamp = block.timestamp;

            }



            uint256 tokenReward = (timeElapsed *

                rewardInfo[i].rewardPerSec *

                pool.allocPoint) / totalAllocPoint;



            pool.accTokenPerShare += ((tokenReward * ACC_TOKEN_PRECISION) /

                lpSupply);

        }



        poolInfo[pid] = pool;



        emit UpdatePool(

            pid,

            pool.lastRewardTimestamp,

            lpSupply,

            pool.accTokenPerShare

        );



        return pool;

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function massUpdatePools() public nonReentrant {

        _massUpdatePools();

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function _massUpdatePools() internal {

        uint256 length = poolIds.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            _updatePool(poolIds[pid]);

        }

    }



    /// @notice Function called by SolarDistributorV2 whenever staker claims SOLAR harvest. Allows staker to also receive a 2nd reward token.

    /// @param _user Address of user

    /// @param _amount Number of LP tokens the user has

    function onSolarReward(

        uint256 _pid,

        address _user,

        uint256 _amount

    ) external override onlyDistributorV2 nonReentrant {

        PoolInfo memory pool = _updatePool(_pid);

        UserInfo storage user = userInfo[_pid][_user];



        uint256 pending = 0;

        uint256 rewardBalance = 0;



        if (isNative) {

            rewardBalance = address(this).balance;

        } else {

            rewardBalance = rewardToken.balanceOf(address(this));

        }



        if (user.amount > 0) {

            pending = (((user.amount * pool.accTokenPerShare) /

                ACC_TOKEN_PRECISION) - user.rewardDebt);



            if (pending > 0) {

                if (isNative) {

                    if (pending > rewardBalance) {

                        (bool success, ) = _user.call{value: rewardBalance}("");

                        require(success, "Transfer failed");

                    } else {

                        (bool success, ) = _user.call{value: pending}("");

                        require(success, "Transfer failed");

                    }

                } else {

                    if (pending > rewardBalance) {

                        rewardToken.safeTransfer(_user, rewardBalance);

                    } else {

                        rewardToken.safeTransfer(_user, pending);

                    }

                }

            }

        }



        user.amount = _amount;



        user.rewardDebt =

            (user.amount * pool.accTokenPerShare) /

            ACC_TOKEN_PRECISION;



        emit OnReward(_user, pending);

    }



    /// @notice View function to see pending Reward on frontend.

    function pendingTokens(uint256 _pid, address _user)

        external

        view

        override

        returns (uint256)

    {

        return

            _pendingTokens(

                _pid,

                userInfo[_pid][_user].amount,

                userInfo[_pid][_user].rewardDebt

            );

    }



    function _pendingTokens(

        uint256 _pid,

        uint256 _amount,

        uint256 _rewardDebt

    ) internal view returns (uint256 pending) {

        PoolInfo memory pool = poolInfo[_pid];

        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];



        uint256 accTokenPerShare = pool.accTokenPerShare;

        uint256 lpSupply = distributorV2.poolTotalLp(_pid);



        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {

            uint256 cursor = pool.lastRewardTimestamp;



            for (uint256 i = 0; i < rewardInfo.length; ++i) {

                uint256 timeElapsed = _getTimeElapsed(

                    cursor,

                    block.timestamp,

                    rewardInfo[i].endTimestamp

                );

                if (timeElapsed == 0) continue;

                cursor = rewardInfo[i].endTimestamp;



                uint256 tokenReward = (timeElapsed *

                    rewardInfo[i].rewardPerSec *

                    pool.allocPoint) / totalAllocPoint;



                accTokenPerShare +=

                    (tokenReward * ACC_TOKEN_PRECISION) /

                    lpSupply;

            }

        }



        pending = (((_amount * accTokenPerShare) / ACC_TOKEN_PRECISION) -

            _rewardDebt);

    }



    function _rewardPerSecOf(uint256 _pid, uint256 _blockTimestamp)

        internal

        view

        returns (uint256)

    {

        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];

        PoolInfo storage pool = poolInfo[_pid];

        uint256 len = rewardInfo.length;

        if (len == 0) {

            return 0;

        }

        for (uint256 i = 0; i < len; ++i) {

            if (_blockTimestamp <= rewardInfo[i].endTimestamp)

                return

                    (rewardInfo[i].rewardPerSec * pool.allocPoint) /

                    totalAllocPoint;

        }

        /// @dev when couldn't find any reward info, it means that timestamp exceed endblock

        /// so return 0

        return 0;

    }



    /// @notice View function to see pool rewards per sec

    function poolRewardsPerSec(uint256 _pid)

        external

        view

        override

        returns (uint256)

    {

        return _rewardPerSecOf(_pid, block.timestamp);

    }



    /// @notice Withdraw reward. EMERGENCY ONLY.

    function emergencyRewardWithdraw(

        uint256 _pid,

        uint256 _amount,

        address _beneficiary

    ) external onlyOwner nonReentrant {

        PoolInfo storage pool = poolInfo[_pid];

        uint256 lpSupply = distributorV2.poolTotalLp(_pid);



        uint256 currentStakingPendingReward = _pendingTokens(_pid, lpSupply, 0);



        require(

            currentStakingPendingReward + _amount <= pool.totalRewards,

            "emergency reward withdraw: not enough reward token"

        );

        pool.totalRewards -= _amount;



        if (!isNative) {

            rewardToken.safeTransfer(_beneficiary, _amount);

        } else {

            (bool sent, ) = _beneficiary.call{value: _amount}("");

            require(sent, "emergency reward withdraw: failed to send");

        }

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ComplexRewarderPerSecV3.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

pragma experimental ABIEncoderV2;



import "@openzeppelin/contracts/utils/Address.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "./IComplexRewarder.sol";

import "../ISolarDistributorV2.sol";

import "../libraries/BoringERC20.sol";



/**

 * This is a sample contract to be used in the SolarDistributorV2 contract for partners to reward

 * stakers with their native token alongside SOLAR.

 *

 * It assumes no minting rights, so requires a set amount of YOUR_TOKEN to be transferred to this contract prior.

 * E.g. say you've allocated 100,000 XYZ to the SOLAR-XYZ farm over 30 days. Then you would need to transfer

 * 100,000 XYZ and set the block reward accordingly so it's fully distributed after 30 days.

 */

contract ComplexRewarderPerSecV3 is IComplexRewarder, Ownable, ReentrancyGuard {

    using BoringERC20 for IBoringERC20;



    IBoringERC20 public immutable override rewardToken;

    ISolarDistributorV2 public immutable distributorV2;

    bool public immutable isNative;



    /// @notice Info of each distributorV2 user.

    /// `amount` LP token amount the user has provided.

    /// `rewardDebt` The amount of REWARD entitled to the user.

    struct UserInfo {

        uint256 amount;

        uint256 rewardDebt;

    }



    /// @notice Info of each distributorV2 poolInfo.

    /// `accTokenPerShare` Amount of REWARD each LP token is worth.

    /// `startTimestamp` The start timestamp of rewards.

    /// `lastRewardTimestamp` The last timestamp REWARD was rewarded to the poolInfo.

    /// `allocPoint` The amount of allocation points assigned to the pool.

    /// `totalRewards` The amount of rewards added to the pool.

    struct PoolInfo {

        uint256 accTokenPerShare;

        uint256 startTimestamp;

        uint256 lastRewardTimestamp;

        uint256 totalRewards;

    }



    /// @notice Reward info

    /// `startTimestamp` The start timestamp of rewards

    /// `endTimestamp` The end timestamp of rewards

    /// `rewardPerSec` The amount of rewards per second

    struct RewardInfo {

        uint256 startTimestamp;

        uint256 endTimestamp;

        uint256 rewardPerSec;

    }



    /// @notice Info of each pool.

    mapping(uint256 => PoolInfo) public poolInfo;



    /// @dev this is mostly used for extending reward period

    /// @notice Reward info is a set of {endTimestamp, rewardPerSec}

    /// indexed by pool id

    mapping(uint256 => RewardInfo[]) public poolRewardInfo;



    uint256[] public poolIds;



    /// @notice Info of each user that stakes LP tokens.

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    /// @notice limit length of reward info

    /// how many phases are allowed

    uint256 public immutable rewardInfoLimit = 52; //1y



    // The precision factor

    uint256 private immutable ACC_TOKEN_PRECISION;



    event OnReward(address indexed user, uint256 amount);

    event RewardRateUpdated(uint256 oldRate, uint256 newRate);

    event AddPool(uint256 indexed pid);

    event UpdatePool(

        uint256 indexed pid,

        uint256 lastRewardTimestamp,

        uint256 lpSupply,

        uint256 accTokenPerShare

    );



    event AddRewardInfo(

        uint256 indexed pid,

        uint256 indexed phase,

        uint256 endTimestamp,

        uint256 rewardPerSec

    );



    modifier onlyDistributorV2() {

        require(

            msg.sender == address(distributorV2),

            "onlyDistributorV2: only DistributorV2 can call this function"

        );

        _;

    }



    constructor(

        IBoringERC20 _rewardToken,

        ISolarDistributorV2 _distributorV2,

        bool _isNative

    ) {

        require(

            Address.isContract(address(_rewardToken)),

            "constructor: reward token must be a valid contract"

        );

        require(

            Address.isContract(address(_distributorV2)),

            "constructor: SolarDistributorV2 must be a valid contract"

        );

        rewardToken = _rewardToken;

        distributorV2 = _distributorV2;

        isNative = _isNative;



        uint256 decimalsRewardToken = uint256(

            _isNative ? 18 : _rewardToken.safeDecimals()

        );

        require(

            decimalsRewardToken < 30,

            "constructor: reward token decimals must be inferior to 30"

        );



        ACC_TOKEN_PRECISION = uint256(

            10**(uint256(30) - (decimalsRewardToken))

        );

    }



    /// @notice Add a new pool. Can only be called by the owner.

    /// @param _pid pool id on DistributorV2

    function add(uint256 _pid, uint256 _startTimestamp) public onlyOwner {

        require(poolInfo[_pid].lastRewardTimestamp == 0, "pool already exists");



        poolInfo[_pid] = PoolInfo({

            startTimestamp: _startTimestamp,

            lastRewardTimestamp: _startTimestamp,

            accTokenPerShare: 0,

            totalRewards: 0

        });



        poolIds.push(_pid);

        emit AddPool(_pid);

    }



    /// @notice if the new reward info is added, the reward & its end timestamp will be extended by the newly pushed reward info.

    function addRewardInfo(

        uint256 _pid,

        uint256 _endTimestamp,

        uint256 _rewardPerSec

    ) external payable onlyOwner {

        RewardInfo[] storage rewardInfo = poolRewardInfo[_pid];

        PoolInfo storage pool = poolInfo[_pid];

        require(

            rewardInfo.length < rewardInfoLimit,

            "add reward info: reward info length exceeds the limit"

        );

        require(

            rewardInfo.length == 0 ||

                rewardInfo[rewardInfo.length - 1].endTimestamp >=

                block.timestamp,

            "add reward info: reward period ended"

        );

        require(

            rewardInfo.length == 0 ||

                rewardInfo[rewardInfo.length - 1].endTimestamp < _endTimestamp,

            "add reward info: bad new endTimestamp"

        );



        uint256 startTimestamp = rewardInfo.length == 0

            ? pool.startTimestamp

            : rewardInfo[rewardInfo.length - 1].endTimestamp;



        uint256 timeRange = _endTimestamp - startTimestamp;

        uint256 totalRewards = timeRange * _rewardPerSec;



        if (!isNative) {

            rewardToken.safeTransferFrom(

                msg.sender,

                address(this),

                totalRewards

            );

        } else {

            require(

                msg.value == totalRewards,

                "add reward info: not enough funds to transfer"

            );

        }



        pool.totalRewards += totalRewards;



        rewardInfo.push(

            RewardInfo({

                startTimestamp: startTimestamp,

                endTimestamp: _endTimestamp,

                rewardPerSec: _rewardPerSec

            })

        );



        emit AddRewardInfo(

            _pid,

            rewardInfo.length - 1,

            _endTimestamp,

            _rewardPerSec

        );

    }



    function _endTimestampOf(uint256 _pid, uint256 _timestamp)

        internal

        view

        returns (uint256)

    {

        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];

        uint256 len = rewardInfo.length;

        if (len == 0) {

            return 0;

        }

        for (uint256 i = 0; i < len; ++i) {

            if (_timestamp <= rewardInfo[i].endTimestamp)

                return rewardInfo[i].endTimestamp;

        }



        /// @dev when couldn't find any reward info, it means that _timestamp exceed endTimestamp

        /// so return the latest reward info.

        return rewardInfo[len - 1].endTimestamp;

    }



    /// @notice this will return end timestamp based on the current block timestamp.

    function currentEndTimestamp(uint256 _pid) external view returns (uint256) {

        return _endTimestampOf(_pid, block.timestamp);

    }



    /// @notice Return reward multiplier over the given _from to _to timestamp.

    function _getTimeElapsed(

        uint256 _from,

        uint256 _to,

        uint256 _endTimestamp

    ) public pure returns (uint256) {

        if ((_from >= _endTimestamp) || (_from > _to)) {

            return 0;

        }

        if (_to <= _endTimestamp) {

            return _to - _from;

        }

        return _endTimestamp - _from;

    }



    /// @notice Update reward variables of the given pool.

    /// @param _pid The index of the pool. See `poolInfo`.

    /// @return pool Returns the pool that was updated.

    function updatePool(uint256 _pid)

        external

        nonReentrant

        returns (PoolInfo memory pool)

    {

        return _updatePool(_pid);

    }



    /// @notice Update reward variables of the given pool.

    /// @param pid The index of the pool. See `poolInfo`.

    /// @return pool Returns the pool that was updated.

    function _updatePool(uint256 pid) public returns (PoolInfo memory pool) {

        pool = poolInfo[pid];

        RewardInfo[] memory rewardInfo = poolRewardInfo[pid];



        if (block.timestamp <= pool.lastRewardTimestamp) {

            return pool;

        }



        uint256 lpSupply = distributorV2.poolTotalLp(pid);



        if (lpSupply == 0) {

            // if there is no total supply, return and use the pool's start timestamp as the last reward timestamp

            // so that ALL reward will be distributed.

            // however, if the first deposit is out of reward period, last reward timestamp will be its timestamp

            // in order to keep the multiplier = 0

            if (block.timestamp > _endTimestampOf(pid, block.timestamp)) {

                pool.lastRewardTimestamp = block.timestamp;

                emit UpdatePool(

                    pid,

                    pool.lastRewardTimestamp,

                    lpSupply,

                    pool.accTokenPerShare

                );

            }



            return pool;

        }



        /// @dev for each reward info

        for (uint256 i = 0; i < rewardInfo.length; ++i) {

            // @dev get multiplier based on current timestamp and rewardInfo's end timestamp

            // multiplier will be a range of either (current timestamp - pool.timestamp)

            // or (reward info's endtimestamp - pool.timestamp) or 0

            uint256 timeElapsed = _getTimeElapsed(

                pool.lastRewardTimestamp,

                block.timestamp,

                rewardInfo[i].endTimestamp

            );

            if (timeElapsed == 0) continue;



            // @dev if currentTimestamp exceed end timestamp, use end timestamp as the last reward timestamp

            // so that for the next iteration, previous endTimestamp will be used as the last reward timestamp

            if (block.timestamp > rewardInfo[i].endTimestamp) {

                pool.lastRewardTimestamp = rewardInfo[i].endTimestamp;

            } else {

                pool.lastRewardTimestamp = block.timestamp;

            }



            uint256 tokenReward = (timeElapsed * rewardInfo[i].rewardPerSec);



            pool.accTokenPerShare += ((tokenReward * ACC_TOKEN_PRECISION) /

                lpSupply);

        }



        poolInfo[pid] = pool;



        emit UpdatePool(

            pid,

            pool.lastRewardTimestamp,

            lpSupply,

            pool.accTokenPerShare

        );



        return pool;

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function massUpdatePools() public nonReentrant {

        _massUpdatePools();

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function _massUpdatePools() internal {

        uint256 length = poolIds.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            _updatePool(poolIds[pid]);

        }

    }



    /// @notice Function called by SolarDistributorV2 whenever staker claims SOLAR harvest. Allows staker to also receive a 2nd reward token.

    /// @param _user Address of user

    /// @param _amount Number of LP tokens the user has

    function onSolarReward(

        uint256 _pid,

        address _user,

        uint256 _amount

    ) external override onlyDistributorV2 nonReentrant {

        PoolInfo memory pool = _updatePool(_pid);

        UserInfo storage user = userInfo[_pid][_user];



        uint256 pending = 0;

        uint256 rewardBalance = 0;



        if (isNative) {

            rewardBalance = address(this).balance;

        } else {

            rewardBalance = rewardToken.balanceOf(address(this));

        }



        if (user.amount > 0) {

            pending = (((user.amount * pool.accTokenPerShare) /

                ACC_TOKEN_PRECISION) - user.rewardDebt);



            if (pending > 0) {

                if (isNative) {

                    if (pending > rewardBalance) {

                        (bool success, ) = _user.call{value: rewardBalance}("");

                        require(success, "Transfer failed");

                    } else {

                        (bool success, ) = _user.call{value: pending}("");

                        require(success, "Transfer failed");

                    }

                } else {

                    if (pending > rewardBalance) {

                        rewardToken.safeTransfer(_user, rewardBalance);

                    } else {

                        rewardToken.safeTransfer(_user, pending);

                    }

                }

            }

        }



        user.amount = _amount;



        user.rewardDebt =

            (user.amount * pool.accTokenPerShare) /

            ACC_TOKEN_PRECISION;



        emit OnReward(_user, pending);

    }



    /// @notice View function to see pending Reward on frontend.

    function pendingTokens(uint256 _pid, address _user)

        external

        view

        override

        returns (uint256)

    {

        return

            _pendingTokens(

                _pid,

                userInfo[_pid][_user].amount,

                userInfo[_pid][_user].rewardDebt

            );

    }



    function _pendingTokens(

        uint256 _pid,

        uint256 _amount,

        uint256 _rewardDebt

    ) internal view returns (uint256 pending) {

        PoolInfo memory pool = poolInfo[_pid];

        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];



        uint256 accTokenPerShare = pool.accTokenPerShare;

        uint256 lpSupply = distributorV2.poolTotalLp(_pid);



        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {

            uint256 cursor = pool.lastRewardTimestamp;



            for (uint256 i = 0; i < rewardInfo.length; ++i) {

                uint256 timeElapsed = _getTimeElapsed(

                    cursor,

                    block.timestamp,

                    rewardInfo[i].endTimestamp

                );

                if (timeElapsed == 0) continue;

                cursor = rewardInfo[i].endTimestamp;



                uint256 tokenReward = (timeElapsed *

                    rewardInfo[i].rewardPerSec);



                accTokenPerShare +=

                    (tokenReward * ACC_TOKEN_PRECISION) /

                    lpSupply;

            }

        }



        pending = (((_amount * accTokenPerShare) / ACC_TOKEN_PRECISION) -

            _rewardDebt);

    }



    function _rewardPerSecOf(uint256 _pid, uint256 _blockTimestamp)

        internal

        view

        returns (uint256)

    {

        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];

        PoolInfo storage pool = poolInfo[_pid];

        uint256 len = rewardInfo.length;

        if (len == 0) {

            return 0;

        }

        if (pool.startTimestamp > _blockTimestamp) {

            return 0;

        }        

        for (uint256 i = 0; i < len; ++i) {

            if (_blockTimestamp <= rewardInfo[i].endTimestamp)

                return rewardInfo[i].rewardPerSec;

        }

        /// @dev when couldn't find any reward info, it means that timestamp exceed endblock

        /// so return 0

        return 0;

    }



    /// @notice View function to see pool rewards per sec

    function poolRewardsPerSec(uint256 _pid)

        external

        view

        override

        returns (uint256)

    {

        return _rewardPerSecOf(_pid, block.timestamp);

    }



    /// @notice Withdraw reward. EMERGENCY ONLY.

    function emergencyRewardWithdraw(

        uint256 _pid,

        uint256 _amount,

        address _beneficiary

    ) external onlyOwner nonReentrant {

        PoolInfo storage pool = poolInfo[_pid];

        uint256 lpSupply = distributorV2.poolTotalLp(_pid);



        uint256 currentStakingPendingReward = _pendingTokens(_pid, lpSupply, 0);



        require(

            currentStakingPendingReward + _amount <= pool.totalRewards,

            "emergency reward withdraw: not enough reward token"

        );

        pool.totalRewards -= _amount;



        if (!isNative) {

            rewardToken.safeTransfer(_beneficiary, _amount);

        } else {

            (bool sent, ) = _beneficiary.call{value: _amount}("");

            require(sent, "emergency reward withdraw: failed to send");

        }

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ComplexRewarderPerSecV4.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

pragma experimental ABIEncoderV2;



import "@openzeppelin/contracts/utils/Address.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "./IComplexRewarder.sol";

import "../ISolarDistributorV2.sol";

import "../libraries/BoringERC20.sol";



/**

 * This is a sample contract to be used in the SolarDistributorV2 contract for partners to reward

 * stakers with their native token alongside SOLAR.

 *

 * It assumes no minting rights, so requires a set amount of YOUR_TOKEN to be transferred to this contract prior.

 * E.g. say you've allocated 100,000 XYZ to the SOLAR-XYZ farm over 30 days. Then you would need to transfer

 * 100,000 XYZ and set the block reward accordingly so it's fully distributed after 30 days.

 */

contract ComplexRewarderPerSecV4 is IComplexRewarder, Ownable, ReentrancyGuard {

    using BoringERC20 for IBoringERC20;



    IBoringERC20 public immutable override rewardToken;

    ISolarDistributorV2 public immutable distributorV2;

    bool public immutable isNative;



    /// @notice Info of each distributorV2 user.

    /// `amount` LP token amount the user has provided.

    /// `rewardDebt` The amount of REWARD entitled to the user.

    struct UserInfo {

        uint256 amount;

        uint256 rewardDebt;

    }



    /// @notice Info of each distributorV2 poolInfo.

    /// `accTokenPerShare` Amount of REWARD each LP token is worth.

    /// `startTimestamp` The start timestamp of rewards.

    /// `lastRewardTimestamp` The last timestamp REWARD was rewarded to the poolInfo.

    /// `allocPoint` The amount of allocation points assigned to the pool.

    /// `totalRewards` The amount of rewards added to the pool.

    struct PoolInfo {

        uint256 accTokenPerShare;

        uint256 startTimestamp;

        uint256 lastRewardTimestamp;

        uint256 totalRewards;

    }



    /// @notice Reward info

    /// `startTimestamp` The start timestamp of rewards

    /// `endTimestamp` The end timestamp of rewards

    /// `rewardPerSec` The amount of rewards per second

    struct RewardInfo {

        uint256 startTimestamp;

        uint256 endTimestamp;

        uint256 rewardPerSec;

    }



    /// @notice Info of each pool.

    mapping(uint256 => PoolInfo) public poolInfo;



    /// @dev this is mostly used for extending reward period

    /// @notice Reward info is a set of {endTimestamp, rewardPerSec}

    /// indexed by pool id

    mapping(uint256 => RewardInfo[]) public poolRewardInfo;



    uint256[] public poolIds;



    /// @notice Info of each user that stakes LP tokens.

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    /// @notice limit length of reward info

    /// how many phases are allowed

    uint256 public immutable rewardInfoLimit = 52; //1y



    // The precision factor

    uint256 private immutable ACC_TOKEN_PRECISION;



    event OnReward(address indexed user, uint256 amount);

    event RewardRateUpdated(uint256 oldRate, uint256 newRate);

    event AddPool(uint256 indexed pid);

    event UpdatePool(

        uint256 indexed pid,

        uint256 lastRewardTimestamp,

        uint256 lpSupply,

        uint256 accTokenPerShare

    );



    event AddRewardInfo(

        uint256 indexed pid,

        uint256 indexed phase,

        uint256 endTimestamp,

        uint256 rewardPerSec

    );



    modifier onlyDistributorV2() {

        require(

            msg.sender == address(distributorV2),

            "onlyDistributorV2: only DistributorV2 can call this function"

        );

        _;

    }



    constructor(

        IBoringERC20 _rewardToken,

        ISolarDistributorV2 _distributorV2,

        bool _isNative

    ) {

        require(

            Address.isContract(address(_rewardToken)),

            "constructor: reward token must be a valid contract"

        );

        require(

            Address.isContract(address(_distributorV2)),

            "constructor: SolarDistributorV2 must be a valid contract"

        );

        rewardToken = _rewardToken;

        distributorV2 = _distributorV2;

        isNative = _isNative;



        uint256 decimalsRewardToken = uint256(

            _isNative ? 18 : _rewardToken.safeDecimals()

        );

        require(

            decimalsRewardToken < 30,

            "constructor: reward token decimals must be inferior to 30"

        );



        ACC_TOKEN_PRECISION = uint256(

            10**(uint256(30) - (decimalsRewardToken))

        );

    }



    /// @notice Add a new pool. Can only be called by the owner.

    /// @param _pid pool id on DistributorV2

    function add(uint256 _pid, uint256 _startTimestamp) public onlyOwner {

        require(poolInfo[_pid].lastRewardTimestamp == 0, "pool already exists");



        poolInfo[_pid] = PoolInfo({

            startTimestamp: _startTimestamp,

            lastRewardTimestamp: _startTimestamp,

            accTokenPerShare: 0,

            totalRewards: 0

        });



        poolIds.push(_pid);

        emit AddPool(_pid);

    }



    /// @notice if the new reward info is added, the reward & its end timestamp will be extended by the newly pushed reward info.

    function addRewardInfo(

        uint256 _pid,

        uint256 _endTimestamp,

        uint256 _rewardPerSec

    ) external payable onlyOwner {

        RewardInfo[] storage rewardInfo = poolRewardInfo[_pid];

        PoolInfo storage pool = poolInfo[_pid];

        require(

            rewardInfo.length < rewardInfoLimit,

            "add reward info: reward info length exceeds the limit"

        );

        require(

            rewardInfo.length == 0 ||

                rewardInfo[rewardInfo.length - 1].endTimestamp >=

                block.timestamp,

            "add reward info: reward period ended"

        );

        require(

            rewardInfo.length == 0 ||

                rewardInfo[rewardInfo.length - 1].endTimestamp < _endTimestamp,

            "add reward info: bad new endTimestamp"

        );



        uint256 startTimestamp = rewardInfo.length == 0

            ? pool.startTimestamp

            : rewardInfo[rewardInfo.length - 1].endTimestamp;



        uint256 timeRange = _endTimestamp - startTimestamp;

        uint256 totalRewards = timeRange * _rewardPerSec;



        if (!isNative) {

            rewardToken.safeTransferFrom(

                msg.sender,

                address(this),

                totalRewards

            );

        } else {

            require(

                msg.value == totalRewards,

                "add reward info: not enough funds to transfer"

            );

        }



        pool.totalRewards += totalRewards;



        rewardInfo.push(

            RewardInfo({

                startTimestamp: startTimestamp,

                endTimestamp: _endTimestamp,

                rewardPerSec: _rewardPerSec

            })

        );



        emit AddRewardInfo(

            _pid,

            rewardInfo.length - 1,

            _endTimestamp,

            _rewardPerSec

        );

    }



    function _endTimestampOf(uint256 _pid, uint256 _timestamp)

        internal

        view

        returns (uint256)

    {

        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];

        uint256 len = rewardInfo.length;

        if (len == 0) {

            return 0;

        }

        for (uint256 i = 0; i < len; ++i) {

            if (_timestamp <= rewardInfo[i].endTimestamp)

                return rewardInfo[i].endTimestamp;

        }



        /// @dev when couldn't find any reward info, it means that _timestamp exceed endTimestamp

        /// so return the latest reward info.

        return rewardInfo[len - 1].endTimestamp;

    }



    /// @notice this will return end timestamp based on the current block timestamp.

    function currentEndTimestamp(uint256 _pid) external view returns (uint256) {

        return _endTimestampOf(_pid, block.timestamp);

    }



    /// @notice Return reward multiplier over the given _from to _to timestamp.

    function _getTimeElapsed(

        uint256 _from,

        uint256 _to,

        uint256 _endTimestamp

    ) public pure returns (uint256) {

        if ((_from >= _endTimestamp) || (_from > _to)) {

            return 0;

        }

        if (_to <= _endTimestamp) {

            return _to - _from;

        }

        return _endTimestamp - _from;

    }



    /// @notice Update reward variables of the given pool.

    /// @param _pid The index of the pool. See `poolInfo`.

    /// @return pool Returns the pool that was updated.

    function updatePool(uint256 _pid)

        external

        nonReentrant

        returns (PoolInfo memory pool)

    {

        return _updatePool(_pid);

    }



    /// @notice Update reward variables of the given pool.

    /// @param pid The index of the pool. See `poolInfo`.

    /// @return pool Returns the pool that was updated.

    function _updatePool(uint256 pid) public returns (PoolInfo memory pool) {

        pool = poolInfo[pid];

        RewardInfo[] memory rewardInfo = poolRewardInfo[pid];



        if (block.timestamp <= pool.lastRewardTimestamp) {

            return pool;

        }



        uint256 lpSupply = distributorV2.poolTotalLp(pid);



        if (lpSupply == 0) {

            // if there is no total supply, return and use the pool's start timestamp as the last reward timestamp

            // so that ALL reward will be distributed.

            // however, if the first deposit is out of reward period, last reward timestamp will be its timestamp

            // in order to keep the multiplier = 0

            if (block.timestamp > _endTimestampOf(pid, block.timestamp)) {

                pool.lastRewardTimestamp = block.timestamp;

                emit UpdatePool(

                    pid,

                    pool.lastRewardTimestamp,

                    lpSupply,

                    pool.accTokenPerShare

                );

            }



            return pool;

        }



        /// @dev for each reward info

        for (uint256 i = 0; i < rewardInfo.length; ++i) {

            // @dev get multiplier based on current timestamp and rewardInfo's end timestamp

            // multiplier will be a range of either (current timestamp - pool.timestamp)

            // or (reward info's endtimestamp - pool.timestamp) or 0

            uint256 timeElapsed = _getTimeElapsed(

                pool.lastRewardTimestamp,

                block.timestamp,

                rewardInfo[i].endTimestamp

            );

            if (timeElapsed == 0) continue;



            // @dev if currentTimestamp exceed end timestamp, use end timestamp as the last reward timestamp

            // so that for the next iteration, previous endTimestamp will be used as the last reward timestamp

            if (block.timestamp > rewardInfo[i].endTimestamp) {

                pool.lastRewardTimestamp = rewardInfo[i].endTimestamp;

            } else {

                pool.lastRewardTimestamp = block.timestamp;

            }



            uint256 tokenReward = (timeElapsed * rewardInfo[i].rewardPerSec);



            pool.accTokenPerShare += ((tokenReward * ACC_TOKEN_PRECISION) /

                lpSupply);

        }



        poolInfo[pid] = pool;



        emit UpdatePool(

            pid,

            pool.lastRewardTimestamp,

            lpSupply,

            pool.accTokenPerShare

        );



        return pool;

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function massUpdatePools() public nonReentrant {

        _massUpdatePools();

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function _massUpdatePools() internal {

        uint256 length = poolIds.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            _updatePool(poolIds[pid]);

        }

    }



    /// @notice Function called by SolarDistributorV2 whenever staker claims SOLAR harvest. Allows staker to also receive a 2nd reward token.

    /// @param _user Address of user

    /// @param _amount Number of LP tokens the user has

    function onSolarReward(

        uint256 _pid,

        address _user,

        uint256 _amount

    ) external override onlyDistributorV2 nonReentrant {

        PoolInfo memory pool = _updatePool(_pid);

        UserInfo storage user = userInfo[_pid][_user];



        uint256 pending = 0;

        uint256 rewardBalance = 0;



        if (isNative) {

            rewardBalance = address(this).balance;

        } else {

            rewardBalance = rewardToken.balanceOf(address(this));

        }



        if (user.amount > 0) {

            pending = (((user.amount * pool.accTokenPerShare) /

                ACC_TOKEN_PRECISION) - user.rewardDebt);



            if (pending > 0) {

                if (isNative) {

                    if (pending > rewardBalance) {

                        (bool success, ) = _user.call{value: rewardBalance}("");

                        require(success, "Transfer failed");

                    } else {

                        (bool success, ) = _user.call{value: pending}("");

                        require(success, "Transfer failed");

                    }

                } else {

                    if (pending > rewardBalance) {

                        rewardToken.safeTransfer(_user, rewardBalance);

                    } else {

                        rewardToken.safeTransfer(_user, pending);

                    }

                }

            }

        }



        user.amount = _amount;



        user.rewardDebt =

            (user.amount * pool.accTokenPerShare) /

            ACC_TOKEN_PRECISION;



        emit OnReward(_user, pending);

    }



    /// @notice View function to see pending Reward on frontend.

    function pendingTokens(uint256 _pid, address _user)

        external

        view

        override

        returns (uint256)

    {

        return

            _pendingTokens(

                _pid,

                userInfo[_pid][_user].amount,

                userInfo[_pid][_user].rewardDebt

            );

    }



    function _pendingTokens(

        uint256 _pid,

        uint256 _amount,

        uint256 _rewardDebt

    ) internal view returns (uint256 pending) {

        PoolInfo memory pool = poolInfo[_pid];

        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];



        uint256 accTokenPerShare = pool.accTokenPerShare;

        uint256 lpSupply = distributorV2.poolTotalLp(_pid);



        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {

            uint256 cursor = pool.lastRewardTimestamp;



            for (uint256 i = 0; i < rewardInfo.length; ++i) {

                uint256 timeElapsed = _getTimeElapsed(

                    cursor,

                    block.timestamp,

                    rewardInfo[i].endTimestamp

                );

                if (timeElapsed == 0) continue;

                cursor = rewardInfo[i].endTimestamp;



                uint256 tokenReward = (timeElapsed *

                    rewardInfo[i].rewardPerSec);



                accTokenPerShare +=

                    (tokenReward * ACC_TOKEN_PRECISION) /

                    lpSupply;

            }

        }



        pending = (((_amount * accTokenPerShare) / ACC_TOKEN_PRECISION) -

            _rewardDebt);

    }



    function _rewardPerSecOf(uint256 _pid, uint256 _blockTimestamp)

        internal

        view

        returns (uint256)

    {

        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];

        PoolInfo storage pool = poolInfo[_pid];

        uint256 len = rewardInfo.length;

        if (len == 0) {

            return 0;

        }

        if (pool.startTimestamp > _blockTimestamp) {

            return 0;

        }        

        for (uint256 i = 0; i < len; ++i) {

            if (_blockTimestamp <= rewardInfo[i].endTimestamp)

                return rewardInfo[i].rewardPerSec;

        }

        /// @dev when couldn't find any reward info, it means that timestamp exceed endblock

        /// so return 0

        return 0;

    }



    /// @notice View function to see pool rewards per sec

    function poolRewardsPerSec(uint256 _pid)

        external

        view

        override

        returns (uint256)

    {

        return _rewardPerSecOf(_pid, block.timestamp);

    }



    /// @notice Withdraw reward. EMERGENCY ONLY.

    function emergencyRewardWithdraw(

        uint256 _pid,

        uint256 _amount,

        address _beneficiary

    ) external onlyOwner nonReentrant {

        PoolInfo storage pool = poolInfo[_pid];

        uint256 lpSupply = distributorV2.poolTotalLp(_pid);



        uint256 currentStakingPendingReward = _pendingTokens(_pid, lpSupply, 0);



        require(

            currentStakingPendingReward + _amount <= pool.totalRewards,

            "emergency reward withdraw: not enough reward token"

        );

        pool.totalRewards -= _amount;



        if (!isNative) {

            rewardToken.safeTransfer(_beneficiary, _amount);

        } else {

            (bool sent, ) = _beneficiary.call{value: _amount}("");

            require(sent, "emergency reward withdraw: failed to send");

        }

    }



    /// @notice Withdraw reward. EMERGENCY ONLY.

    function emergencyWithdraw(

        uint256 _amount,

        address _beneficiary

    ) external onlyOwner nonReentrant {



        if (!isNative) {

            rewardToken.safeTransfer(_beneficiary, _amount);

        } else {

            (bool sent, ) = _beneficiary.call{value: _amount}("");

            require(sent, "emergency withdraw: failed to send");

        }

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\EIP712Base.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



contract EIP712Base {

    struct EIP712Domain {

        string name;

        string version;

        address verifyingContract;

        bytes32 salt;

    }



    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =

        keccak256(

            bytes(

                "EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)"

            )

        );



    bytes32 internal domainSeparator;



    constructor(string memory name, string memory version) {

        domainSeparator = keccak256(

            abi.encode(

                EIP712_DOMAIN_TYPEHASH,

                keccak256(bytes(name)),

                keccak256(bytes(version)),

                address(this),

                bytes32(getChainID())

            )

        );

    }



    function getChainID() internal view returns (uint256 id) {

        assembly {

            id := chainid()

        }

    }



    function getDomainSeparator() private view returns (bytes32) {

        return domainSeparator;

    }



    /**

     * Accept message hash and returns hash message in EIP712 compatible form

     * So that it can be used to recover signer from signature signed using EIP712 formatted data

     * https://eips.ethereum.org/EIPS/eip-712

     * "\\x19" makes the encoding deterministic

     * "\\x01" is the version byte to make it compatible to EIP-191

     */

    function toTypedMessageHash(bytes32 messageHash)

        internal

        view

        returns (bytes32)

    {

        return

            keccak256(

                abi.encodePacked("\x19\x01", getDomainSeparator(), messageHash)

            );

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\EIP712MetaTransaction.sol
File type: .sol
//SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



import "./EIP712Base.sol";



contract EIP712MetaTransaction is EIP712Base {

    bytes32 private constant META_TRANSACTION_TYPEHASH =

        keccak256(

            bytes(

                "MetaTransaction(uint256 nonce,address from,bytes functionSignature)"

            )

        );



    event MetaTransactionExecuted(

        address userAddress,

        address payable relayerAddress,

        bytes functionSignature

    );

    mapping(address => uint256) private nonces;



    /*

     * Meta transaction structure.

     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas

     * He should call the desired function directly in that case.

     */

    struct MetaTransaction {

        uint256 nonce;

        address from;

        bytes functionSignature;

    }



    constructor(string memory name, string memory version)

        EIP712Base(name, version)

    {}



    function convertBytesToBytes4(bytes memory inBytes)

        internal

        pure

        returns (bytes4 outBytes4)

    {

        if (inBytes.length == 0) {

            return 0x0;

        }



        assembly {

            outBytes4 := mload(add(inBytes, 32))

        }

    }



    function executeMetaTransaction(

        address userAddress,

        bytes memory functionSignature,

        bytes32 sigR,

        bytes32 sigS,

        uint8 sigV

    ) public payable returns (bytes memory) {

        bytes4 destinationFunctionSig = convertBytesToBytes4(functionSignature);

        require(

            destinationFunctionSig != msg.sig,

            "functionSignature can not be of executeMetaTransaction method"

        );

        MetaTransaction memory metaTx = MetaTransaction({

            nonce: nonces[userAddress],

            from: userAddress,

            functionSignature: functionSignature

        });

        require(

            verify(userAddress, metaTx, sigR, sigS, sigV),

            "Signer and signature do not match"

        );

        nonces[userAddress] += 1;

        // Append userAddress at the end to extract it from calling context

        (bool success, bytes memory returnData) = address(this).call(

            abi.encodePacked(functionSignature, userAddress)

        );



        require(success, "Function call not successful");

        emit MetaTransactionExecuted(

            userAddress,

            payable(msg.sender),

            functionSignature

        );

        return returnData;

    }



    function hashMetaTransaction(MetaTransaction memory metaTx)

        internal

        pure

        returns (bytes32)

    {

        return

            keccak256(

                abi.encode(

                    META_TRANSACTION_TYPEHASH,

                    metaTx.nonce,

                    metaTx.from,

                    keccak256(metaTx.functionSignature)

                )

            );

    }



    function getNonce(address user) external view returns (uint256 nonce) {

        nonce = nonces[user];

    }



    function verify(

        address user,

        MetaTransaction memory metaTx,

        bytes32 sigR,

        bytes32 sigS,

        uint8 sigV

    ) internal view returns (bool) {

        address signer = ecrecover(

            toTypedMessageHash(hashMetaTransaction(metaTx)),

            sigV,

            sigR,

            sigS

        );

        require(signer != address(0), "Invalid signature");

        return signer == user;

    }



    function msgSender() internal view returns (address sender) {

        if (msg.sender == address(this)) {

            bytes memory array = msg.data;

            uint256 index = msg.data.length;

            assembly {

                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.

                sender := and(

                    mload(add(array, index)),

                    0xffffffffffffffffffffffffffffffffffffffff

                )

            }

        } else {

            sender = msg.sender;

        }

        return sender;

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\Forwarder.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.2;

pragma abicoder v2;



import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

import "./IForwarder.sol";



contract Forwarder is IForwarder {

    using ECDSA for bytes32;



    string public constant GENERIC_PARAMS = "address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data,uint256 validUntil";



    string public constant EIP712_DOMAIN_TYPE = "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)";



    mapping(bytes32 => bool) public typeHashes;

    mapping(bytes32 => bool) public domains;



    // Nonces of senders, used to prevent replay attacks

    mapping(address => uint256) private nonces;



    // solhint-disable-next-line no-empty-blocks

    receive() external payable {}



    function getNonce(address from)

    public view override

    returns (uint256) {

        return nonces[from];

    }



    constructor() {     

        string memory requestType = string(abi.encodePacked("ForwardRequest(", GENERIC_PARAMS, ")"));

        registerRequestTypeInternal(requestType);

    }



    function verify(

        ForwardRequest calldata req,

        bytes32 domainSeparator,

        bytes32 requestTypeHash,

        bytes calldata suffixData,

        bytes calldata sig)

    external override view {



        _verifyNonce(req);

        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);

    }



    function execute(

        ForwardRequest calldata req,

        bytes32 domainSeparator,

        bytes32 requestTypeHash,

        bytes calldata suffixData,

        bytes calldata sig

    )

    external payable

    override

    returns (bool success, bytes memory ret) {

        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);

        _verifyAndUpdateNonce(req);



        require(req.validUntil == 0 || req.validUntil > block.number, "FWD: request expired");



        uint gasForTransfer = 0;

        if ( req.value != 0 ) {

            gasForTransfer = 40000; //buffer in case we need to move eth after the transaction.

        }

        bytes memory callData = abi.encodePacked(req.data, req.from);

        require(gasleft()*63/64 >= req.gas + gasForTransfer, "FWD: insufficient gas");

        // solhint-disable-next-line avoid-low-level-calls

        (success,ret) = req.to.call{gas : req.gas, value : req.value}(callData);

        if ( req.value != 0 && address(this).balance>0 ) {

            // can't fail: req.from signed (off-chain) the request, so it must be an EOA...

            payable(req.from).transfer(address(this).balance);

        }



        return (success,ret);

    }





    function _verifyNonce(ForwardRequest calldata req) internal view {

        require(nonces[req.from] == req.nonce, "FWD: nonce mismatch");

    }



    function _verifyAndUpdateNonce(ForwardRequest calldata req) internal {

        require(nonces[req.from]++ == req.nonce, "FWD: nonce mismatch");

    }



    function registerRequestType(string calldata typeName, string calldata typeSuffix) external override {



        for (uint i = 0; i < bytes(typeName).length; i++) {

            bytes1 c = bytes(typeName)[i];

            require(c != "(" && c != ")", "FWD: invalid typename");

        }



        string memory requestType = string(abi.encodePacked(typeName, "(", GENERIC_PARAMS, ",", typeSuffix));

        registerRequestTypeInternal(requestType);

    }



    function registerDomainSeparator(string calldata name, string calldata version) external override {

        uint256 chainId;

        /* solhint-disable-next-line no-inline-assembly */

        assembly { chainId := chainid() }



        bytes memory domainValue = abi.encode(

            keccak256(bytes(EIP712_DOMAIN_TYPE)),

            keccak256(bytes(name)),

            keccak256(bytes(version)),

            chainId,

            address(this));



        bytes32 domainHash = keccak256(domainValue);



        domains[domainHash] = true;

        emit DomainRegistered(domainHash, domainValue);

    }



    function registerRequestTypeInternal(string memory requestType) internal {



        bytes32 requestTypehash = keccak256(bytes(requestType));

        typeHashes[requestTypehash] = true;

        emit RequestTypeRegistered(requestTypehash, requestType);

    }



    function _verifySig(

        ForwardRequest calldata req,

        bytes32 domainSeparator,

        bytes32 requestTypeHash,

        bytes calldata suffixData,

        bytes calldata sig)

    internal

    view

    {

        require(domains[domainSeparator], "FWD: unregistered domain sep.");

        require(typeHashes[requestTypeHash], "FWD: unregistered typehash");

        bytes32 digest = keccak256(abi.encodePacked(

                "\x19\x01", domainSeparator,

                keccak256(_getEncoded(req, requestTypeHash, suffixData))

            ));

        require(digest.recover(sig) == req.from, "FWD: signature mismatch");

    }



    function _getEncoded(

        ForwardRequest calldata req,

        bytes32 requestTypeHash,

        bytes calldata suffixData

    )

    public

    pure

    returns (

        bytes memory

    ) {

        // we use encodePacked since we append suffixData as-is, not as dynamic param.

        // still, we must make sure all first params are encoded as abi.encode()

        // would encode them - as 256-bit-wide params.

        return abi.encodePacked(

            requestTypeHash,

            uint256(uint160(req.from)),

            uint256(uint160(req.to)),

            req.value,

            req.gas,

            req.nonce,

            keccak256(req.data),

            req.validUntil,

            suffixData

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\GasSwap.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/utils/Address.sol";

import "./EIP712MetaTransaction.sol";

import "./ISolarRouter.sol";

import "./IToken.sol";



contract GasSwap is Ownable, EIP712MetaTransaction("GasSwap", "2") {

    address public immutable WMOVR = 0x98878B06940aE243284CA214f92Bb71a2b032B8A;



    struct Transformation {

        uint32 _uint32;

        bytes _bytes;

    }



    ISolarRouter public solarRouter;

    address public feeAddress;

    uint256 public feePercent = 100; //1%



    mapping(address => bool) public tokenWhitelist;



    constructor(address router) {

        solarRouter = ISolarRouter(router);

    }



    receive() external payable {

        require(Address.isContract(msgSender()), "REVERT_EOA_DEPOSIT");

    }



    function whitelistToken(address tokenAddress, bool whitelisted)

        external

        onlyOwner

    {

        require(Address.isContract(tokenAddress), "NO_CONTRACT_AT_ADDRESS");

        tokenWhitelist[tokenAddress] = whitelisted;

    }



    function changeFeePercent(uint256 newFeePercent) external onlyOwner {

        require(feePercent >= 0 && feePercent < 10000, "INVALID_FEE_PERCENT");

        feePercent = newFeePercent;

    }



    function changeFeeAddress(address newFeeAddress) external onlyOwner {

        feeAddress = newFeeAddress;

    }



    function changeRouter(address newTarget) external onlyOwner {

        require(Address.isContract(newTarget), "NO_CONTRACT_AT_ADDRESS");

        solarRouter = ISolarRouter(newTarget);

    }



    function withdrawToken(IToken token, uint256 amount) external onlyOwner {

        token.transfer(msg.sender, amount);

    }



    // Transfer ETH held by this contract to the sender/owner.

    function withdrawETH(uint256 amount) external onlyOwner {

        payable(msg.sender).transfer(amount);

    }



    // Swaps ERC20->MOVR tokens

    function swap(bytes calldata swapCallData) external returns (uint256) {

        (

            uint256 amountIn,

            uint256 amountOutMin,

            address[] memory path,

            ,

            uint256 deadline,

            uint8 v,

            bytes32 r,

            bytes32 s

        ) = abi.decode(

                swapCallData,

                (

                    uint256,

                    uint256,

                    address[],

                    address,

                    uint256,

                    uint8,

                    bytes32,

                    bytes32

                )

            );



        require(path[path.length - 1] == WMOVR, "INVALID_OUTPUT_TOKEN");



        require(tokenWhitelist[path[0]] == true, "INVALID_INPUT_TOKEN");



        IToken sellToken = IToken(path[0]);



        sellToken.permit(

            msgSender(),

            address(this),

            amountIn,

            deadline,

            v,

            r,

            s

        );



        sellToken.transferFrom(msgSender(), address(this), amountIn);



        uint256 beforeSwapBalance = address(this).balance;



        sellToken.approve(address(solarRouter), amountIn);



        solarRouter.swapExactTokensForETH(

            amountIn,

            amountOutMin,

            path,

            address(this),

            deadline

        );



        uint256 tradeBalance = address(this).balance - beforeSwapBalance;

        uint256 amount = ((tradeBalance * 10000) -

            (tradeBalance * feePercent)) / 10000;

        uint256 fee = tradeBalance - amount;



        if (feeAddress != address(0)) {

            payable(feeAddress).transfer(fee);

        }

        payable(msgSender()).transfer(amount);

        return amount;

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\IBoringERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



interface IBoringERC20 {

    function mint(address to, uint256 amount) external;



    function totalSupply() external view returns (uint256);



    function balanceOf(address account) external view returns (uint256);



    function allowance(address owner, address spender)

        external

        view

        returns (uint256);



    function approve(address spender, uint256 amount) external returns (bool);



    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );



    /// @notice EIP 2612

    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ICommonEclipse.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



/** @title ICommonEclipse

 * @notice It is an interface for CommonEclipse.sol

 */

abstract contract ICommonEclipse {

    /**

     * @notice It sets parameters for pool

     * @param _offeringAmountPool: offering amount (in tokens)

     * @param _raisingAmountPool: raising amount (in LP tokens)

     * @param _baseLimitInLP: base limit per user (in LP tokens)

     * @param _hasTax: if the pool has a tax

     * @param _pid: poolId

     * @dev This function is only callable by owner.

     */

    function setPool(

        uint256 _offeringAmountPool,

        uint256 _raisingAmountPool,

        uint256 _baseLimitInLP,

        bool _hasTax,

        uint8 _pid

    ) external virtual;



    /**

     * @notice It allows users to deposit LP tokens to pool

     * @param _amount: the number of LP token used (18 decimals)

     * @param _pid: pool id

     */

    function depositPool(uint256 _amount, uint8 _pid) external virtual;



    /**

     * @notice It allows users to harvest from pool

     * @param _pid: pool id

     * @param _harvestPeriod: chosen harvest period to claim

     */

    function harvestPool(uint8 _pid, uint8 _harvestPeriod) external virtual;



    /**

     * @notice It allows owner to update start and end blocks of the sale

     * @param _startBlock: block number sale starts

     * @param _endBlock: block number sale ends

     */

    function updateStartAndEndBlocks(uint256 _startBlock, uint256 _endBlock)

        external

        virtual;



    /**

     * @notice It allows owner to set the multiplier information

     * @param _multipliers: encoded multipliers for zero, seven and thirty day vaults

     * @dev encoded args are (uint8,uint8,uint8,uint8[2][3],uint8[2][3],uint8[2][3])

     * (0 decimals)

     */

    function setMultipliers(bytes memory _multipliers) public virtual;



    /**

     * @notice It allows owner to set the threshold for eligibility

     * @param _eligibilityThreshold: amount of solar staked in vaults to be eligibile

     */

    function setEligibilityThreshold(uint256 _eligibilityThreshold)

        public

        virtual;



    /**

     * @notice It allows the admin to withdraw funds

     * @param _lpAmount: the number of LP token to withdraw (18 decimals)

     * @param _offerAmount: the number of offering amount to withdraw

     * @dev This function is only callable by owner.

     */

    function finalWithdraw(uint256 _lpAmount, uint256 _offerAmount)

        external

        virtual;



    /**

     * @notice It returns the tax overflow rate calculated for a pool

     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)

     * @param _pid: poolId

     * @return It returns the tax percentage

     */

    function viewPoolTaxRateOverflow(uint256 _pid)

        external

        virtual

        returns (uint256);



    /**

     * @notice External view function to see user allocations for both pools

     * @param _user: user address

     * @param _pids[]: array of pids

     */

    function viewUserAllocationPools(address _user, uint8[] calldata _pids)

        external

        virtual

        returns (uint256[] memory);



    /**

     * @notice External view function to see user offering and refunding amounts for both pools

     * @param _user: user address

     * @param _pids: array of pids

     */

    function viewUserOfferingAndRefundingAmountsForPools(

        address _user,

        uint8[] calldata _pids

    ) external virtual returns (uint256[3][] memory);



    /**

     * @notice It allows users to withdraw LP tokens to pool

     * @param _amount: the number of LP token used (18 decimals)

     * @param _pid: pool id

     */

    function withdrawPool(uint256 _amount, uint8 _pid) external virtual;



    /**

     * @notice It allows the admin to end sale and start claim

     * @dev This function is only callable by owner.

     */

    function enableClaim() external virtual;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ICommonEclipseAmara.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



/** @title ICommonEclipse

 * @notice It is an interface for CommonEclipse.sol

 */

abstract contract ICommonEclipseAmara {

    enum WITHDRAW_TYPE {

        RAISING,

        TAX

    }



    enum HARVEST_TYPE {

        TIMESTAMP,

        PERCENT

    }



    /**

     * @notice It sets parameters for pool

     * @param _offeringAmountPool: offering amount (in tokens)

     * @param _raisingAmountPool: raising amount (in LP tokens)

     * @param _baseLimitInLP: base limit per user (in LP tokens)

     * @param _hasTax: if the pool has a tax

     * @param _pid: poolId

     * @dev This function is only callable by owner.

     */

    function setPool(

        uint256 _offeringAmountPool,

        uint256 _raisingAmountPool,

        uint256 _baseLimitInLP,

        bool _hasTax,

        uint8 _pid

    ) external virtual;



    /**

     * @notice It allows users to deposit LP tokens to pool

     * @param _amount: the number of LP token used (18 decimals)

     * @param _pid: pool id

     */

    function depositPool(uint256 _amount, uint8 _pid) external virtual;



    /**

     * @notice It allows users to harvest from pool

     * @param _pid: pool id

     * @param _harvestPeriod: chosen harvest period to claim

     */

    function harvestPool(uint8 _pid, uint8 _harvestPeriod) external virtual;



    /**

     * @notice It allows owner to update start and end blocks of the sale

     * @param _startBlock: block number sale starts

     * @param _endBlock: block number sale ends

     */

    function updateStartAndEndBlocks(uint256 _startBlock, uint256 _endBlock)

        external

        virtual;



    /**

     * @notice It allows owner to set the multiplier information

     * @param _multipliers: encoded multipliers for zero, seven and thirty day vaults

     * @dev encoded args are (uint8,uint8,uint8,uint8[2][3],uint8[2][3],uint8[2][3])

     * (0 decimals)

     */

    function setMultipliers(bytes memory _multipliers) public virtual;



    /**

     * @notice It allows owner to set the threshold for eligibility

     * @param _eligibilityThreshold: amount of solar staked in vaults to be eligibile

     */

    function setEligibilityThreshold(uint256 _eligibilityThreshold)

        public

        virtual;



    /**

     * @notice It withdraws raisingAmount + taxes for a pool

     * @dev can only withdraw after the sale is finished

     * @param _type: withdraw type

     * @param _pid: pool id

     */

    function finalWithdraw(WITHDRAW_TYPE _type, uint8 _pid) external virtual;



    /**

     * @notice It returns the tax overflow rate calculated for a pool

     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)

     * @param _pid: poolId

     * @return It returns the tax percentage

     */

    function viewPoolTaxRateOverflow(uint256 _pid)

        external

        virtual

        returns (uint256);



    /**

     * @notice External view function to see user allocations for both pools

     * @param _user: user address

     * @param _pids[]: array of pids

     */

    function viewUserAllocationPools(address _user, uint8[] calldata _pids)

        external

        virtual

        returns (uint256[] memory);



    /**

     * @notice External view function to see user offering and refunding amounts for both pools

     * @param _user: user address

     * @param _pids: array of pids

     */

    function viewUserOfferingAndRefundingAmountsForPools(

        address _user,

        uint8[] calldata _pids

    ) external view virtual returns (uint256[3][] memory);



    /**

     * @notice It allows users to withdraw LP tokens to pool

     * @param _amount: the number of LP token used (18 decimals)

     * @param _pid: pool id

     */

    function withdrawPool(uint256 _amount, uint8 _pid) external virtual;



    /**

     * @notice It allows the admin to end sale and start claim

     * @dev This function is only callable by owner.

     */

    function enableClaim() external virtual;



    function harvestReleasePercent(uint256)

        external

        view

        virtual

        returns (uint256);



    function harvestReleaseTimestamps(uint256)

        external

        view

        virtual

        returns (uint256);



    function harvestReleaseBlocks(uint256)

        external

        view

        virtual

        returns (uint256);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ICommonEclipseAmaraV2.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



/** @title ICommonEclipse

 * @notice It is an interface for CommonEclipse.sol

 */

abstract contract ICommonEclipseAmaraV2 {

    enum WITHDRAW_TYPE {

        RAISING,

        TAX

    }



    enum HARVEST_TYPE {

        TIMESTAMP,

        PERCENT

    }



    /**

     * @notice External view function to see user offering and refunding amounts for both pools

     * @param _user: user address

     * @param _pids: array of pids

     */

    function viewUserOfferingAndRefundingAmountsForPools(

        address _user,

        uint8[] calldata _pids

    ) external view virtual returns (uint256[3][] memory);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ICommonEclipseV2.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



/** @title ICommonEclipse

 * @notice It is an interface for CommonEclipse.sol

 */

abstract contract ICommonEclipseV2 {

    enum WITHDRAW_TYPE {

        RAISING,

        TAX

    }



    enum HARVEST_TYPE {

        TIMESTAMP,

        PERCENT

    }



    /**

     * @notice It sets parameters for pool

     * @param _offeringAmountPool: offering amount (in tokens)

     * @param _raisingAmountPool: raising amount (in LP tokens)

     * @param _baseLimitInLP: base limit per user (in LP tokens)

     * @param _hasTax: if the pool has a tax

     * @param _pid: poolId

     * @dev This function is only callable by owner.

     */

    function setPool(

        uint256 _offeringAmountPool,

        uint256 _raisingAmountPool,

        uint256 _baseLimitInLP,

        bool _hasTax,

        uint8 _pid

    ) external virtual;



    /**

     * @notice It allows users to deposit LP tokens to pool

     * @param _amount: the number of LP token used (18 decimals)

     * @param _pid: pool id

     */

    function depositPool(uint256 _amount, uint8 _pid) external virtual;



    /**

     * @notice It allows users to harvest from pool

     * @param _pid: pool id

     * @param _harvestPeriod: chosen harvest period to claim

     */

    function harvestPool(uint8 _pid, uint8 _harvestPeriod) external virtual;



    /**

     * @notice It allows owner to update start and end blocks of the sale

     * @param _startBlock: block number sale starts

     * @param _endBlock: block number sale ends

     */

    function updateStartAndEndBlocks(uint256 _startBlock, uint256 _endBlock)

        external

        virtual;



    /**

     * @notice It allows owner to set the multiplier information

     * @param _multipliers: encoded multipliers for zero, seven and thirty day vaults

     * @dev encoded args are (uint8,uint8,uint8,uint8[2][3],uint8[2][3],uint8[2][3])

     * (0 decimals)

     */

    function setMultipliers(bytes memory _multipliers) public virtual;



    /**

     * @notice It allows owner to set the threshold for eligibility

     * @param _eligibilityThreshold: amount of solar staked in vaults to be eligibile

     */

    function setEligibilityThreshold(uint256 _eligibilityThreshold)

        public

        virtual;



    /**

     * @notice It withdraws raisingAmount + taxes for a pool

     * @dev can only withdraw after the sale is finished

     * @param _type: withdraw type

     * @param _pid: pool id

     */

    function finalWithdraw(WITHDRAW_TYPE _type, uint8 _pid) external virtual;



    /**

     * @notice It returns the tax overflow rate calculated for a pool

     * @dev 100,000,000,000 means 0.1 (10%) / 1 means 0.0000000000001 (0.0000001%) / 1,000,000,000,000 means 1 (100%)

     * @param _pid: poolId

     * @return It returns the tax percentage

     */

    function viewPoolTaxRateOverflow(uint256 _pid)

        external

        virtual

        returns (uint256);



    /**

     * @notice External view function to see user allocations for both pools

     * @param _user: user address

     * @param _pids[]: array of pids

     */

    function viewUserAllocationPools(address _user, uint8[] calldata _pids)

        external

        virtual

        returns (uint256[] memory);



    /**

     * @notice External view function to see user offering and refunding amounts for both pools

     * @param _user: user address

     * @param _pids: array of pids

     */

    function viewUserOfferingAndRefundingAmountsForPools(

        address _user,

        uint8[] calldata _pids

    ) external virtual returns (uint256[3][] memory);



    /**

     * @notice It allows users to withdraw LP tokens to pool

     * @param _amount: the number of LP token used (18 decimals)

     * @param _pid: pool id

     */

    function withdrawPool(uint256 _amount, uint8 _pid) external virtual;



    /**

     * @notice It allows the admin to end sale and start claim

     * @dev This function is only callable by owner.

     */

    function enableClaim() external virtual;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\IComplexRewarder.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



import "../libraries/IBoringERC20.sol";



interface IComplexRewarder {

    function onSolarReward(

        uint256 pid,

        address user,

        uint256 newLpAmount

    ) external;



    function pendingTokens(uint256 pid, address user)

        external

        view

        returns (uint256 pending);



    function rewardToken() external view returns (IBoringERC20);



    function poolRewardsPerSec(uint256 pid) external view returns (uint256);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



interface IERC20Solar {

    event Approval(address indexed owner, address indexed spender, uint value);

    event Transfer(address indexed from, address indexed to, uint value);



    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint);

    function balanceOf(address owner) external view returns (uint);

    function allowance(address owner, address spender) external view returns (uint);



    function approve(address spender, uint value) external returns (bool);

    function transfer(address to, uint value) external returns (bool);

    function transferFrom(address from, address to, uint value) external returns (bool);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\IForwarder.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.2;

pragma abicoder v2;



interface IForwarder {



    struct ForwardRequest {

        address from;

        address to;

        uint256 value;

        uint256 gas;

        uint256 nonce;

        bytes data;

        uint256 validUntil;

    }



    event DomainRegistered(bytes32 indexed domainSeparator, bytes domainValue);



    event RequestTypeRegistered(bytes32 indexed typeHash, string typeStr);



    function getNonce(address from)

    external view

    returns(uint256);



    /**

     * verify the transaction would execute.

     * validate the signature and the nonce of the request.

     * revert if either signature or nonce are incorrect.

     * also revert if domainSeparator or requestTypeHash are not registered.

     */

    function verify(

        ForwardRequest calldata forwardRequest,

        bytes32 domainSeparator,

        bytes32 requestTypeHash,

        bytes calldata suffixData,

        bytes calldata signature

    ) external view;



    /**

     * execute a transaction

     * @param forwardRequest - all transaction parameters

     * @param domainSeparator - domain used when signing this request

     * @param requestTypeHash - request type used when signing this request.

     * @param suffixData - the extension data used when signing this request.

     * @param signature - signature to validate.

     *

     * the transaction is verified, and then executed.

     * the success and ret of "call" are returned.

     * This method would revert only verification errors. target errors

     * are reported using the returned "success" and ret string

     */

    function execute(

        ForwardRequest calldata forwardRequest,

        bytes32 domainSeparator,

        bytes32 requestTypeHash,

        bytes calldata suffixData,

        bytes calldata signature

    )

    external payable

    returns (bool success, bytes memory ret);



    /**

     * Register a new Request typehash.

     * @param typeName - the name of the request type.

     * @param typeSuffix - any extra data after the generic params.

     *  (must add at least one param. The generic ForwardRequest type is always registered by the constructor)

     */

    function registerRequestType(string calldata typeName, string calldata typeSuffix) external;



    /**

     * Register a new domain separator.

     * The domain separator must have the following fields: name,version,chainId, verifyingContract.

     * the chainId is the current network's chainId, and the verifyingContract is this forwarder.

     * This method is given the domain name and version to create and register the domain separator value.

     * @param name the domain's display name

     * @param version the domain/protocol version

     */

    function registerDomainSeparator(string calldata name, string calldata version) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\IRewarder.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "../libraries/IBoringERC20.sol";



interface IRewarder {

    function onSolarReward(address user, uint256 newLpAmount) external;



    function pendingTokens(address user)

        external

        view

        returns (uint256 pending);



    function rewardToken() external view returns (IBoringERC20);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ISmartRouter.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.2;



interface ISmartRouter {

    enum InputType {

        AMOUNT_IN,

        AMOUNT_OUT

    }



    struct FormattedOffer {

        uint256[] amounts;

        address[] adapters;

        address[] path;

        string[] tokens;

    }



    struct Trade {

        uint256[] amounts;

        address[] path;

        address[] adapters;

    }



    function findBestPath(

        uint256 _amount,

        address _tokenIn,

        address _tokenOut,

        uint256 _maxSteps,

        InputType _inputType

    ) external view returns (FormattedOffer memory);



    function swapNoSplit(

        Trade memory _trade,

        address _to,

        uint256 _fee

    ) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ISolarCallee.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



interface ISolarCallee {

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ISolarDistributorV2.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



interface ISolarDistributorV2 {

    function totalAllocPoint() external view returns (uint256);



    function deposit(uint256 _pid, uint256 _amount) external;



    function poolLength() external view returns (uint256);



    function poolTotalLp(uint256 pid) external view returns (uint256);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ISolarERC20.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.2;



interface ISolarERC20 {

    event Approval(address indexed owner, address indexed spender, uint value);

    event Transfer(address indexed from, address indexed to, uint value);



    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint);

    function balanceOf(address owner) external view returns (uint);

    function allowance(address owner, address spender) external view returns (uint);



    function approve(address spender, uint value) external returns (bool);

    function transfer(address to, uint value) external returns (bool);

    function transferFrom(address from, address to, uint value) external returns (bool);



    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint);



    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ISolarFactory.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.2;



interface ISolarFactory {

    event PairCreated(address indexed token0, address indexed token1, address pair, uint);



    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function migrator() external view returns (address);

    function auro() external view returns (address);



    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint) external view returns (address pair);

    function allPairsLength() external view returns (uint);



    function createPair(address tokenA, address tokenB) external returns (address pair);



    function setFeeTo(address) external;

    function setFeeToSetter(address) external;

    function setMigrator(address) external;

    function setAuroAddress(address) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ISolarPair.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.2;



interface ISolarPair {

    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );

    event Transfer(address indexed from, address indexed to, uint256 value);



    function name() external pure returns (string memory);



    function symbol() external pure returns (string memory);



    function decimals() external pure returns (uint8);



    function totalSupply() external view returns (uint256);



    function balanceOf(address owner) external view returns (uint256);



    function allowance(address owner, address spender)

        external

        view

        returns (uint256);



    function approve(address spender, uint256 value) external returns (bool);



    function transfer(address to, uint256 value) external returns (bool);



    function transferFrom(

        address from,

        address to,

        uint256 value

    ) external returns (bool);



    function DOMAIN_SEPARATOR() external view returns (bytes32);



    function PERMIT_TYPEHASH() external pure returns (bytes32);



    function nonces(address owner) external view returns (uint256);



    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external;



    event Mint(address indexed sender, uint256 amount0, uint256 amount1);

    event Burn(

        address indexed sender,

        uint256 amount0,

        uint256 amount1,

        address indexed to

    );

    event Swap(

        address indexed sender,

        uint256 amount0In,

        uint256 amount1In,

        uint256 amount0Out,

        uint256 amount1Out,

        address indexed to

    );

    event Sync(uint112 reserve0, uint112 reserve1);



    function MINIMUM_LIQUIDITY() external pure returns (uint256);



    function factory() external view returns (address);



    function token0() external view returns (address);



    function token1() external view returns (address);



    function getReserves()

        external

        view

        returns (

            uint112 reserve0,

            uint112 reserve1,

            uint32 blockTimestampLast

        );



    function price0CumulativeLast() external view returns (uint256);



    function price1CumulativeLast() external view returns (uint256);



    function kLast() external view returns (uint256);



    function mint(address to) external returns (uint256 liquidity);



    function burn(address to)

        external

        returns (uint256 amount0, uint256 amount1);



    function swap(

        uint256 amount0Out,

        uint256 amount1Out,

        address to,

        bytes calldata data

    ) external;



    function skim(address to) external;



    function sync() external;



    function initialize(address, address) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ISolarRouter.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



interface ISolarRouter {

    function factory() external pure returns (address);



    function WETH() external pure returns (address);



    function addLiquidity(

        address tokenA,

        address tokenB,

        uint256 amountADesired,

        uint256 amountBDesired,

        uint256 amountAMin,

        uint256 amountBMin,

        address to,

        uint256 deadline

    )

        external

        returns (

            uint256 amountA,

            uint256 amountB,

            uint256 liquidity

        );



    function addLiquidityETH(

        address token,

        uint256 amountTokenDesired,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline

    )

        external

        payable

        returns (

            uint256 amountToken,

            uint256 amountETH,

            uint256 liquidity

        );



    function removeLiquidity(

        address tokenA,

        address tokenB,

        uint256 liquidity,

        uint256 amountAMin,

        uint256 amountBMin,

        address to,

        uint256 deadline

    ) external returns (uint256 amountA, uint256 amountB);



    function removeLiquidityETH(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline

    ) external returns (uint256 amountToken, uint256 amountETH);



    function removeLiquidityWithPermit(

        address tokenA,

        address tokenB,

        uint256 liquidity,

        uint256 amountAMin,

        uint256 amountBMin,

        address to,

        uint256 deadline,

        bool approveMax,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external returns (uint256 amountA, uint256 amountB);



    function removeLiquidityETHWithPermit(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline,

        bool approveMax,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external returns (uint256 amountToken, uint256 amountETH);



    function swapExactTokensForTokens(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external returns (uint256[] memory amounts);



    function swapTokensForExactTokens(

        uint256 amountOut,

        uint256 amountInMax,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external returns (uint256[] memory amounts);



    function swapExactETHForTokens(

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external payable returns (uint256[] memory amounts);



    function swapTokensForExactETH(

        uint256 amountOut,

        uint256 amountInMax,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external returns (uint256[] memory amounts);



    function swapExactTokensForETH(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external returns (uint256[] memory amounts);



    function swapETHForExactTokens(

        uint256 amountOut,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external payable returns (uint256[] memory amounts);



    function quote(

        uint256 amountA,

        uint256 reserveA,

        uint256 reserveB

    ) external pure returns (uint256 amountB);



    function getAmountOut(

        uint256 amountIn,

        uint256 reserveIn,

        uint256 reserveOut,

        uint256 fee

    ) external pure returns (uint256 amountOut);



    function getAmountIn(

        uint256 amountOut,

        uint256 reserveIn,

        uint256 reserveOut,

        uint256 fee

    ) external pure returns (uint256 amountIn);



    function getAmountsOut(

        uint256 amountIn,

        address[] calldata path,

        uint256 fee

    ) external view returns (uint256[] memory amounts);



    function getAmountsIn(

        uint256 amountOut,

        address[] calldata path,

        uint256 fee

    ) external view returns (uint256[] memory amounts);



    function removeLiquidityETHSupportingFeeOnTransferTokens(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline

    ) external returns (uint256 amountETH);



    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline,

        bool approveMax,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external returns (uint256 amountETH);



    function swapExactTokensForTokensSupportingFeeOnTransferTokens(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external;



    function swapExactETHForTokensSupportingFeeOnTransferTokens(

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external payable;



    function swapExactTokensForETHSupportingFeeOnTransferTokens(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ISolarRouter01.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.2;



interface ISolarRouter01 {

    function factory() external pure returns (address);

    function WETH() external pure returns (address);



    function addLiquidity(

        address tokenA,

        address tokenB,

        uint amountADesired,

        uint amountBDesired,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline

    ) external returns (uint amountA, uint amountB, uint liquidity);

    function addLiquidityETH(

        address token,

        uint amountTokenDesired,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidity(

        address tokenA,

        address tokenB,

        uint liquidity,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline

    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETH(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external returns (uint amountToken, uint amountETH);

    function removeLiquidityWithPermit(

        address tokenA,

        address tokenB,

        uint liquidity,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline,

        bool approveMax, uint8 v, bytes32 r, bytes32 s

    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETHWithPermit(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline,

        bool approveMax, uint8 v, bytes32 r, bytes32 s

    ) external returns (uint amountToken, uint amountETH);

    function swapExactTokensForTokens(

        uint amountIn,

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(

        uint amountOut,

        uint amountInMax,

        address[] calldata path,

        address to,

        uint deadline

    ) external returns (uint[] memory amounts);

    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)

        external

        payable

        returns (uint[] memory amounts);

    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)

        external

        returns (uint[] memory amounts);

    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)

        external

        returns (uint[] memory amounts);

    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)

        external

        payable

        returns (uint[] memory amounts);



    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);

    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);

    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\ISolarRouter02.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.2;

import "./ISolarRouter01.sol";



interface ISolarRouter02 is ISolarRouter01 {

    function removeLiquidityETHSupportingFeeOnTransferTokens(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline

    ) external returns (uint256 amountETH);



    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline,

        bool approveMax,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external returns (uint256 amountETH);



    function swapExactTokensForTokensSupportingFeeOnTransferTokens(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external;



    function swapExactETHForTokensSupportingFeeOnTransferTokens(

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external payable;



    function swapExactTokensForETHSupportingFeeOnTransferTokens(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\IToken.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol";



interface IToken is IERC20, IERC20Permit {}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\IWETH.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



interface IWETH {

    function deposit() external payable;



    function transfer(address to, uint256 value) external returns (bool);



    function withdraw(uint256) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\Math.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



// a library for performing various math operations



library Math {

    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {

        z = x < y ? x : y;

    }



    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)

    function sqrt(uint256 y) internal pure returns (uint256 z) {

        if (y > 3) {

            z = y;

            uint256 x = y / 2 + 1;

            while (x < z) {

                z = x;

                x = (y / x + x) / 2;

            }

        } else if (y != 0) {

            z = 1;

        }

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\MockERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";



contract MockERC20 is ERC20, ERC20Permit {

    using SafeERC20 for IERC20;



    constructor(

        string memory name,

        string memory symbol,

        uint256 totalSupply

    ) ERC20(name, symbol) ERC20Permit(name) {

        _mint(msg.sender, totalSupply);

    }



    function mint(address _who, uint256 _amount) public {

        _mint(_who, _amount);

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\MockRouter.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



import "hardhat/console.sol";



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/utils/Address.sol";

import "./EIP712MetaTransaction.sol";

import "./ISolarRouter.sol";

import "./IToken.sol";



contract MockRouter {

    function swapExactTokensForETH(

        uint256,

        uint256,

        address[] calldata,

        address,

        uint256

    ) external virtual returns (uint256[] memory amounts) {

        amounts = new uint256[](1);

        amounts[0] = 0;

        return amounts;

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\Multicall2.sol
File type: .sol
//SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.5.0;

pragma experimental ABIEncoderV2;



/// @title Multicall2 - Aggregate results from multiple read-only function calls

/// @author Michael Elliot <mike@makerdao.com>

/// @author Joshua Levine <joshua@makerdao.com>

/// @author Nick Johnson <arachnid@notdot.net>



contract Multicall2 {

    struct Call {

        address target;

        bytes callData;

    }

    struct Result {

        bool success;

        bytes returnData;

    }



    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {

        blockNumber = block.number;

        returnData = new bytes[](calls.length);

        for(uint256 i = 0; i < calls.length; i++) {

            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);

            require(success, "Multicall aggregate: call failed");

            returnData[i] = ret;

        }

    }

    function blockAndAggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {

        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);

    }

    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {

        blockHash = blockhash(blockNumber);

    }

    function getBlockNumber() public view returns (uint256 blockNumber) {

        blockNumber = block.number;

    }

    function getCurrentBlockCoinbase() public view returns (address coinbase) {

        coinbase = block.coinbase;

    }

    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {

        difficulty = block.difficulty;

    }

    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {

        gaslimit = block.gaslimit;

    }

    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {

        timestamp = block.timestamp;

    }

    function getEthBalance(address addr) public view returns (uint256 balance) {

        balance = addr.balance;

    }

    function getLastBlockHash() public view returns (bytes32 blockHash) {

        blockHash = blockhash(block.number - 1);

    }

    function tryAggregate(bool requireSuccess, Call[] memory calls) public returns (Result[] memory returnData) {

        returnData = new Result[](calls.length);

        for(uint256 i = 0; i < calls.length; i++) {

            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);



            if (requireSuccess) {

                require(success, "Multicall2 aggregate: call failed");

            }



            returnData[i] = Result(success, ret);

        }

    }

    function tryBlockAndAggregate(bool requireSuccess, Call[] memory calls) public returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {

        blockNumber = block.number;

        blockHash = blockhash(block.number);

        returnData = tryAggregate(requireSuccess, calls);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\NFTClaim.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";



library Errors {

    string constant C1 =

        "whitelist::whitelist length must be equal as amount length";

}



contract NFTClaim is Ownable, ReentrancyGuard {

    // Info of each user for each pool.

    struct UserInfo {

        bool claimed;

        uint256 amount;

    }



    // Info of each pool.

    struct CampaignInfo {

        IERC721 nft;

    }



    // userInfo[_campaignId][_who]

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    // mapping to keep track of nft rewards for sweep function

    mapping(address => bool) public nft;



    // CampainInfo[_campaignId];

    CampaignInfo[] public campaignInfo;



    event AddCampaignInfo(uint256 indexed campaignID, IERC721 nft);

    event Whitelist(

        uint256 indexed campaignID,

        address indexed user,

        uint256 indexed amount

    );

    event Claim(address indexed user, uint256 indexed campaignID);

    event AdminRecovery(address indexed nftAddress, uint256 amount);



    function addCampaignInfo(IERC721 _nft) external onlyOwner {

        campaignInfo.push(CampaignInfo({nft: _nft}));

        nft[address(_nft)] = true;

        emit AddCampaignInfo(campaignInfo.length - 1, _nft);

    }



    function campaignInfoLen() external view returns (uint256) {

        return campaignInfo.length;

    }



    function whitelist(

        uint256 _campaignID,

        address[] calldata _whitelist,

        uint256[] calldata _amount

    ) external onlyOwner {

        require(_whitelist.length == _amount.length, Errors.C1);



        for (uint256 i = 0; i < _whitelist.length; i++) {

            UserInfo storage user = userInfo[_campaignID][_whitelist[i]];

            user.amount = _amount[i];

            user.claimed = false;

            emit Whitelist(_campaignID, _whitelist[i], _amount[i]);

        }

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\RewarderBroken.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

import "./IRewarder.sol";

import "../libraries/BoringERC20.sol";



contract RewarderBroken is IRewarder {

    IBoringERC20 public override rewardToken;



    function onSolarReward(address, uint256) external pure override {

        revert();

    }



    function pendingTokens(address) external pure override returns (uint256) {

        revert();

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SafeMath.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)



library SafeMathSolar {

    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {

        require((z = x + y) >= x, "ds-math-add-overflow");

    }



    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {

        require((z = x - y) <= x, "ds-math-sub-underflow");

    }



    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {

        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SimpleRewarderPerSec.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;

pragma experimental ABIEncoderV2;



import "@openzeppelin/contracts/utils/Address.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "./IRewarder.sol";

import "../ISolarDistributorV2.sol";

import "../libraries/BoringERC20.sol";



/**

 * This is a sample contract to be used in the SolarDistributorV2 contract for partners to reward

 * stakers with their native token alongside SOLAR.

 *

 * It assumes no minting rights, so requires a set amount of YOUR_TOKEN to be transferred to this contract prior.

 * E.g. say you've allocated 100,000 XYZ to the SOLAR-XYZ farm over 30 days. Then you would need to transfer

 * 100,000 XYZ and set the block reward accordingly so it's fully distributed after 30 days.

 */

contract SimpleRewarderPerSec is IRewarder, Ownable, ReentrancyGuard {

    using BoringERC20 for IBoringERC20;



    IBoringERC20 public immutable override rewardToken;

    uint256 public immutable pid;

    bool public immutable isNative;

    ISolarDistributorV2 public immutable distributorV2;



    /// @notice Info of each distributorV2 user.

    /// `amount` LP token amount the user has provided.

    /// `rewardDebt` The amount of YOUR_TOKEN entitled to the user.

    struct UserInfo {

        uint256 amount;

        uint256 rewardDebt;

    }



    /// @notice Info of each distributorV2 poolInfo.

    /// `accTokenPerShare` Amount of YOUR_TOKEN each LP token is worth.

    /// `lastRewardTimestamp` The last timestamp YOUR_TOKEN was rewarded to the poolInfo.

    struct PoolInfo {

        uint256 accTokenPerShare;

        uint256 lastRewardTimestamp;

    }



    /// @notice Info of the poolInfo.

    PoolInfo public poolInfo;

    /// @notice Info of each user that stakes LP tokens.

    mapping(address => UserInfo) public userInfo;



    uint256 public tokenPerSec;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;



    event OnReward(address indexed user, uint256 amount);

    event RewardRateUpdated(uint256 oldRate, uint256 newRate);



    modifier onlyDistributorV2() {

        require(

            msg.sender == address(distributorV2),

            "onlyDistributorV2: only SolarDistributorV2 can call this function"

        );

        _;

    }



    constructor(

        IBoringERC20 _rewardToken,

        uint256 _tokenPerSec,

        ISolarDistributorV2 _distributorV2,

        uint256 _pid,

        bool _isNative

    ) {

        require(

            Address.isContract(address(_rewardToken)),

            "constructor: reward token must be a valid contract"

        );

        require(

            Address.isContract(address(_distributorV2)),

            "constructor: SolarDistributorV2 must be a valid contract"

        );

        rewardToken = _rewardToken;

        pid = _pid;

        tokenPerSec = _tokenPerSec;

        distributorV2 = _distributorV2;

        isNative = _isNative;

        poolInfo = PoolInfo({

            lastRewardTimestamp: block.timestamp,

            accTokenPerShare: 0

        });

    }



    /// @notice Update reward variables of the given poolInfo.

    /// @return pool Returns the pool that was updated.

    function updatePool() public returns (PoolInfo memory pool) {

        pool = poolInfo;



        if (block.timestamp > pool.lastRewardTimestamp) {

            uint256 lpSupply = distributorV2.poolTotalLp(pid);



            if (lpSupply > 0) {

                uint256 timeElapsed = block.timestamp -

                    pool.lastRewardTimestamp;

                uint256 tokenReward = timeElapsed * tokenPerSec;

                pool.accTokenPerShare += ((tokenReward * ACC_TOKEN_PRECISION) /

                    lpSupply);

            }



            pool.lastRewardTimestamp = block.timestamp;

            poolInfo = pool;

        }

    }



    /// @notice Sets the distribution reward rate. This will also update the poolInfo.

    /// @param _tokenPerSec The number of tokens to distribute per second

    function setRewardRate(uint256 _tokenPerSec) external onlyOwner {

        updatePool();



        emit RewardRateUpdated(tokenPerSec, _tokenPerSec);



        tokenPerSec = _tokenPerSec;

    }



    /// @notice internal function to see balance of reward token.

    function _balance() internal view returns (uint256) {

        if (isNative) {

            return address(this).balance;

        } else {

            return rewardToken.balanceOf(address(this));

        }

    }



    /// @notice Function called by SolarDistributorV2 whenever staker claims SOLAR harvest. Allows staker to also receive a 2nd reward token.

    /// @param _user Address of user

    /// @param _lpAmount Number of LP tokens the user has

    function onSolarReward(address _user, uint256 _lpAmount)

        external

        override

        onlyDistributorV2

        nonReentrant

    {

        updatePool();

        PoolInfo memory pool = poolInfo;

        UserInfo storage user = userInfo[_user];

        uint256 pending;

        uint256 rewardBalance = _balance();

        if (user.amount > 0) {

            pending = (((user.amount * pool.accTokenPerShare) /

                ACC_TOKEN_PRECISION) - user.rewardDebt);



            if (isNative) {

                if (pending > rewardBalance) {

                    (bool success, ) = _user.call{value: rewardBalance}("");

                    require(success, "Transfer failed");

                } else {

                    (bool success, ) = _user.call{value: pending}("");

                    require(success, "Transfer failed");

                }

            } else {

                if (pending > rewardBalance) {

                    rewardToken.safeTransfer(_user, rewardBalance);

                } else {

                    rewardToken.safeTransfer(_user, pending);

                }

            }

        }

        user.amount = _lpAmount;

        user.rewardDebt =

            (user.amount * pool.accTokenPerShare) /

            ACC_TOKEN_PRECISION;



        emit OnReward(_user, pending);

    }



    /// @notice View function to see pending tokens

    /// @param _user Address of user.

    /// @return pending reward for a given user.

    function pendingTokens(address _user)

        external

        view

        override

        returns (uint256 pending)

    {

        PoolInfo memory pool = poolInfo;

        UserInfo storage user = userInfo[_user];



        uint256 accTokenPerShare = pool.accTokenPerShare;

        uint256 lpSupply = distributorV2.poolTotalLp(pid);



        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {

            uint256 timeElapsed = block.timestamp - pool.lastRewardTimestamp;

            uint256 tokenReward = timeElapsed * tokenPerSec;

            accTokenPerShare += (tokenReward * ACC_TOKEN_PRECISION) / lpSupply;

        }



        pending = (((user.amount * accTokenPerShare) / ACC_TOKEN_PRECISION) -

            user.rewardDebt);

    }



    /// @notice In case rewarder is stopped before emissions finished, this function allows

    /// withdrawal of remaining tokens.

    function emergencyWithdraw() public onlyOwner {

        if (isNative) {

            (bool success, ) = msg.sender.call{value: address(this).balance}(

                ""

            );

            require(success, "Transfer failed");

        } else {

            rewardToken.safeTransfer(

                address(msg.sender),

                rewardToken.balanceOf(address(this))

            );

        }

    }



    /// @notice View function to see balance of reward token.

    function balance() external view returns (uint256) {

        return _balance();

    }



    /// @notice payable function needed to receive MOVR

    receive() external payable {}

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarBeamToken.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";

import "@openzeppelin/contracts/security/Pausable.sol";

import "@openzeppelin/contracts/access/AccessControl.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "@openzeppelin/contracts/metatx/ERC2771Context.sol";



contract SolarBeamToken is ERC20, ERC20Permit, Pausable, AccessControl {

    using SafeERC20 for IERC20;

    using SafeMath for uint256;



    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    bytes32 public constant RESCUER_ROLE = keccak256("RESCUER_ROLE");

    bytes32 public constant TAKE_FEE_ROLE = keccak256("TAKE_FEE_ROLE");

    bytes32 public constant ROUTER_ROLE = keccak256("ROUTER_ROLE");



    uint256 private _maxSupply = 1000000000 * 10**decimals(); // 1 billion tokens is maximum supply

    uint256 private _initialSupply = 100000 * 10**decimals(); // 100,000 tokens is the initial supply



    address private _trustedForwarder;



    // Control support for EIP-2771 Meta Transactions

    bool public metaTxnsEnabled = false;



    event TokensRescued(address indexed sender, address indexed token, uint256 value);

    event MetaTxnsEnabled(address indexed caller);

    event MetaTxnsDisabled(address indexed caller);



    constructor(address trustedForwarder) ERC20("SolarBeam Token", "SOLAR") ERC20Permit("SolarBeam Token") {

        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(PAUSER_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());

        _setupRole(RESCUER_ROLE, _msgSender());



        _trustedForwarder = trustedForwarder;



        _mint(_msgSender(), _initialSupply);

    }



    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {

        return forwarder == _trustedForwarder;

    }



    function _msgSender() internal view override returns (address sender) {

        if (isTrustedForwarder(msg.sender)) {

            // The assembly code is more direct than the Solidity version using `abi.decode`.

            assembly {

                sender := shr(96, calldataload(sub(calldatasize(), 20)))

            }

        } else {

            return super._msgSender();

        }

    }



    function _msgData() internal view override returns (bytes calldata) {

        if (isTrustedForwarder(msg.sender)) {

            return msg.data[:msg.data.length - 20];

        } else {

            return super._msgData();

        }

    }



    /**

     * @dev Returns the maximum amount of tokens that can be minted.

     */

    function maxSupply() public view returns (uint256) {

        return _maxSupply;

    }



    function pause() public onlyRole(PAUSER_ROLE) {

        _pause();

    }



    function unpause() public onlyRole(PAUSER_ROLE) {

        _unpause();

    }



    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {

        require(totalSupply() + amount <= _maxSupply, "ERC20: cannot mint more tokens, cap exceeded");

        _mint(to, amount);

    }



    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal override whenNotPaused {

        super._beforeTokenTransfer(from, to, amount);

    }



    function rescueTokens(IERC20 token, uint256 value) external onlyRole(RESCUER_ROLE) {

        token.transfer(_msgSender(), value);



        emit TokensRescued(_msgSender(), address(token), value);

    }



    // Enable support for meta transactions

    function enableMetaTxns() public onlyRole(DEFAULT_ADMIN_ROLE) {

        require(!metaTxnsEnabled, "Meta transactions are already enabled");



        metaTxnsEnabled = true;

        emit MetaTxnsEnabled(_msgSender());

    }



    // Disable support for meta transactions

    function disableMetaTxns() public onlyRole(DEFAULT_ADMIN_ROLE) {

        require(metaTxnsEnabled, "Meta transactions are already disabled");



        metaTxnsEnabled = false;

        emit MetaTxnsDisabled(_msgSender());

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarBurner.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



import "./interfaces/ISolarERC20.sol";

import "./interfaces/ISolarPair.sol";

import "./interfaces/ISolarFactory.sol";



contract SolarBurner is Ownable {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    ISolarFactory public immutable factory;

    address public immutable burner;

    address private immutable solar;

    address private immutable wmovr;



    mapping(address => address) internal _bridges;



    event LogBridgeSet(address indexed token, address indexed bridge);



    event LogConvert(

        address indexed server,

        address indexed token0,

        address indexed token1,

        uint256 amount0,

        uint256 amount1,

        uint256 amountSOLAR

    );



    constructor(

        address _factory,

        address _burner,

        address _solar,

        address _wmovr

    ) {

        factory = ISolarFactory(_factory);

        burner = _burner;

        solar = _solar;

        wmovr = _wmovr;

    }



    function bridgeFor(address token) public view returns (address bridge) {

        bridge = _bridges[token];

        if (bridge == address(0)) {

            bridge = wmovr;

        }

    }



    function setBridge(address token, address bridge) external onlyOwner {

        // Checks

        require(

            token != solar && token != wmovr && token != bridge,

            "SolarBurner: Invalid bridge"

        );



        // Effects

        _bridges[token] = bridge;

        emit LogBridgeSet(token, bridge);

    }



    // It's not a fool proof solution, but it prevents flash loans, so here it's ok to use tx.origin

    modifier onlyEOA() {

        // Try to make flash-loan exploit harder to do by only allowing externally owned addresses.

        require(msg.sender == tx.origin, "SolarBurner: must use EOA");

        _;

    }



    // _convert is separate to save gas by only checking the 'onlyEOA' modifier once in case of convertMultiple

    function convert(address token0, address token1) external onlyEOA {

        _convert(token0, token1);

    }



    function convertMultiple(

        address[] calldata token0,

        address[] calldata token1

    ) external onlyEOA {

        uint256 len = token0.length;

        for (uint256 i = 0; i < len; i++) {

            _convert(token0[i], token1[i]);

        }

    }



    function _convert(address token0, address token1) internal {

        ISolarPair pair = ISolarPair(factory.getPair(token0, token1));

        require(address(pair) != address(0), "SolarBurner: Invalid pair");

        IERC20(address(pair)).safeTransfer(

            address(pair),

            pair.balanceOf(address(this))

        );

        (uint256 amount0, uint256 amount1) = pair.burn(address(this));

        if (token0 != pair.token0()) {

            (amount0, amount1) = (amount1, amount0);

        }

        emit LogConvert(

            msg.sender,

            token0,

            token1,

            amount0,

            amount1,

            _convertStep(token0, token1, amount0, amount1)

        );

    }



    // All safeTransfer, _swap, _toSOLAR, _convertStep: X1 - X5: OK

    function _convertStep(

        address token0,

        address token1,

        uint256 amount0,

        uint256 amount1

    ) internal returns (uint256 solarOut) {

        if (token0 == token1) {

            uint256 amount = amount0.add(amount1);

            if (token0 == solar) {

                IERC20(solar).safeTransfer(burner, amount);

                solarOut = amount;

            } else if (token0 == wmovr) {

                solarOut = _toSOLAR(wmovr, amount);

            } else {

                address bridge = bridgeFor(token0);

                amount = _swap(token0, bridge, amount, address(this));

                solarOut = _convertStep(bridge, bridge, amount, 0);

            }

        } else if (token0 == solar) {

            IERC20(solar).safeTransfer(burner, amount0);

            solarOut = _toSOLAR(token1, amount1).add(amount0);

        } else if (token1 == solar) {

            // eg. USDC - SOLAR

            IERC20(solar).safeTransfer(burner, amount1);

            solarOut = _toSOLAR(token0, amount0).add(amount1);

        } else if (token0 == wmovr) {

            // eg. ETH - USDC

            solarOut = _toSOLAR(

                wmovr,

                _swap(token1, wmovr, amount1, address(this)).add(amount0)

            );

        } else if (token1 == wmovr) {

            // eg. USDC - MOVR

            solarOut = _toSOLAR(

                wmovr,

                _swap(token0, wmovr, amount0, address(this)).add(amount1)

            );

        } else {

            // eg. MIM - USDC

            address bridge0 = bridgeFor(token0);

            address bridge1 = bridgeFor(token1);

            if (bridge0 == token1) {

                // eg. MIM - USDC - and bridgeFor(MIM) = USDC

                solarOut = _convertStep(

                    bridge0,

                    token1,

                    _swap(token0, bridge0, amount0, address(this)),

                    amount1

                );

            } else if (bridge1 == token0) {

                // eg. WBTC - WETH - and bridgeFor(WETH) = WBTC

                solarOut = _convertStep(

                    token0,

                    bridge1,

                    amount0,

                    _swap(token1, bridge1, amount1, address(this))

                );

            } else {

                solarOut = _convertStep(

                    bridge0,

                    bridge1, // eg. USDC - WETH - and bridgeFor(WETH) = WBTC

                    _swap(token0, bridge0, amount0, address(this)),

                    _swap(token1, bridge1, amount1, address(this))

                );

            }

        }

    }



    function _swap(

        address fromToken,

        address toToken,

        uint256 amountIn,

        address to

    ) internal returns (uint256 amountOut) {

        ISolarPair pair = ISolarPair(factory.getPair(fromToken, toToken));

        require(address(pair) != address(0), "SolarBurner: Cannot convert");



        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();

        uint256 amountInWithFee = amountIn.mul(997);

        if (fromToken == pair.token0()) {

            amountOut =

                amountInWithFee.mul(reserve1) /

                reserve0.mul(1000).add(amountInWithFee);

            IERC20(fromToken).safeTransfer(address(pair), amountIn);

            pair.swap(0, amountOut, to, new bytes(0));

        } else {

            amountOut =

                amountInWithFee.mul(reserve0) /

                reserve1.mul(1000).add(amountInWithFee);

            IERC20(fromToken).safeTransfer(address(pair), amountIn);

            pair.swap(amountOut, 0, to, new bytes(0));

        }

    }



    function _toSOLAR(address token, uint256 amountIn)

        internal

        returns (uint256 amountOut)

    {

        amountOut = _swap(token, solar, amountIn, burner);

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarDistributor.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./ISolarERC20.sol";



contract SolarDistributor is Ownable, ReentrancyGuard {

    // remember to change for mainnet deploy

    address constant _trustedForwarder =

        0x0D0b4862F5FfA3A47D04DDf0351356d20C830460; //TRUSTED FORWARDER



    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    // Info of each user.

    struct UserInfo {

        uint256 amount; // How many LP tokens the user has provided.

        uint256 rewardDebt; // Reward debt. See explanation below.

        uint256 rewardLockedUp; // Reward locked up.

        uint256 nextHarvestUntil; // When can the user harvest again.

    }



    // Info of each pool.

    struct PoolInfo {

        IERC20 lpToken; // Address of LP token contract.

        uint256 allocPoint; // How many allocation points assigned to this pool. Solar to distribute per block.

        uint256 lastRewardBlock; // Last block number that Solar distribution occurs.

        uint256 accSolarPerShare; // Accumulated Solar per share, times 1e12. See below.

        uint16 depositFeeBP; // Deposit fee in basis points

        uint256 harvestInterval; // Harvest interval in seconds

        uint256 totalLp; // Total token in Pool

    }



    ISolarERC20 public solar;



    // The operator can only update EmissionRate and AllocPoint to protect tokenomics

    //i.e some wrong setting and a pools get too much allocation accidentally

    address private _operator;



    // Dev address.

    address public devAddress;



    // Deposit Fee address

    address public feeAddress;



    // Solar tokens created per block

    uint256 public solarPerBlock;



    // Max harvest interval: 14 days

    uint256 public constant MAXIMUM_HARVEST_INTERVAL = 14 days;



    // Maximum deposit fee rate: 10%

    uint16 public constant MAXIMUM_DEPOSIT_FEE_RATE = 1000;



    // Info of each pool

    PoolInfo[] public poolInfo;



    // Info of each user that stakes LP tokens.

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    // Total allocation points. Must be the sum of all allocation points in all pools.

    uint256 public totalAllocPoint = 0;



    // The block number when Solar mining starts.

    uint256 public startBlock;



    // Total locked up rewards

    uint256 public totalLockedUpRewards;



    // Total Solar in Solar Pools (can be multiple pools)

    uint256 public totalSolarInPools = 0;



    // Control support for EIP-2771 Meta Transactions

    bool public metaTxnsEnabled = false;



    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);

    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);

    event EmergencyWithdraw(

        address indexed user,

        uint256 indexed pid,

        uint256 amount

    );

    event EmissionRateUpdated(

        address indexed caller,

        uint256 previousAmount,

        uint256 newAmount

    );

    event RewardLockedUp(

        address indexed user,

        uint256 indexed pid,

        uint256 amountLockedUp

    );

    event OperatorTransferred(

        address indexed previousOperator,

        address indexed newOperator

    );

    event DevAddressChanged(

        address indexed caller,

        address oldAddress,

        address newAddress

    );

    event FeeAddressChanged(

        address indexed caller,

        address oldAddress,

        address newAddress

    );

    event AllocPointsUpdated(

        address indexed caller,

        uint256 previousAmount,

        uint256 newAmount

    );

    event MetaTxnsEnabled(address indexed caller);

    event MetaTxnsDisabled(address indexed caller);



    modifier onlyOperator() {

        require(

            _operator == msg.sender,

            "Operator: caller is not the operator"

        );

        _;

    }



    constructor(ISolarERC20 _solar, uint256 _solarPerBlock) {

        //StartBlock always many years later from contract construct, will be set later in StartFarming function

        startBlock = block.number + (10 * 365 * 24 * 60 * 60);



        solar = _solar;

        solarPerBlock = _solarPerBlock;



        devAddress = msg.sender;

        feeAddress = msg.sender;

        _operator = msg.sender;

        emit OperatorTransferred(address(0), _operator);

    }



    function isTrustedForwarder(address forwarder)

        public

        view

        virtual

        returns (bool)

    {

        return metaTxnsEnabled && forwarder == _trustedForwarder;

    }



    function _msgSender()

        internal

        view

        virtual

        override

        returns (address sender)

    {

        if (isTrustedForwarder(msg.sender)) {

            // The assembly code is more direct than the Solidity version using `abi.decode`.

            assembly {

                sender := shr(96, calldataload(sub(calldatasize(), 20)))

            }

        } else {

            return super._msgSender();

        }

    }



    function _msgData()

        internal

        view

        virtual

        override

        returns (bytes calldata)

    {

        if (isTrustedForwarder(msg.sender)) {

            return msg.data[:msg.data.length - 20];

        } else {

            return super._msgData();

        }

    }



    function operator() public view returns (address) {

        return _operator;

    }



    // Return reward multiplier over the given _from to _to block.

    function getMultiplier(uint256 _from, uint256 _to)

        public

        pure

        returns (uint256)

    {

        return _to.sub(_from);

    }



    function transferOperator(address newOperator) public onlyOperator {

        require(

            newOperator != address(0),

            "TransferOperator: new operator is the zero address"

        );

        emit OperatorTransferred(_operator, newOperator);

        _operator = newOperator;

    }



    // Set farming start, can call only once

    function startFarming() public onlyOwner {

        require(block.number < startBlock, "Error::Farm started already");



        uint256 length = poolInfo.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            PoolInfo storage pool = poolInfo[pid];

            pool.lastRewardBlock = block.number;

        }



        startBlock = block.number;

    }



    function poolLength() external view returns (uint256) {

        return poolInfo.length;

    }



    // Add a new lp to the pool. Can only be called by the owner.

    // Can add multiple pool with same lp token without messing up rewards, because each pool's balance is tracked using its own totalLp

    function add(

        uint256 _allocPoint,

        IERC20 _lpToken,

        uint16 _depositFeeBP,

        uint256 _harvestInterval,

        bool _withUpdate

    ) public onlyOwner {

        require(

            _depositFeeBP <= MAXIMUM_DEPOSIT_FEE_RATE,

            "add: deposit fee too high"

        );

        require(

            _harvestInterval <= MAXIMUM_HARVEST_INTERVAL,

            "add: invalid harvest interval"

        );

        if (_withUpdate) {

            massUpdatePools();

        }

        uint256 lastRewardBlock = block.number > startBlock

            ? block.number

            : startBlock;

        totalAllocPoint = totalAllocPoint.add(_allocPoint);

        poolInfo.push(

            PoolInfo({

                lpToken: _lpToken,

                allocPoint: _allocPoint,

                lastRewardBlock: lastRewardBlock,

                accSolarPerShare: 0,

                depositFeeBP: _depositFeeBP,

                harvestInterval: _harvestInterval,

                totalLp: 0

            })

        );

    }



    // Update the given pool's Solar allocation point and deposit fee. Can only be called by the owner.

    function set(

        uint256 _pid,

        uint256 _allocPoint,

        uint16 _depositFeeBP,

        uint256 _harvestInterval,

        bool _withUpdate

    ) public onlyOwner {

        require(

            _depositFeeBP <= MAXIMUM_DEPOSIT_FEE_RATE,

            "set: deposit fee too high"

        );

        require(

            _harvestInterval <= MAXIMUM_HARVEST_INTERVAL,

            "set: invalid harvest interval"

        );

        if (_withUpdate) {

            massUpdatePools();

        }

        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(

            _allocPoint

        );

        poolInfo[_pid].allocPoint = _allocPoint;

        poolInfo[_pid].depositFeeBP = _depositFeeBP;

        poolInfo[_pid].harvestInterval = _harvestInterval;

    }



    // View function to see pending Solar on frontend.

    function pendingSolar(uint256 _pid, address _user)

        external

        view

        returns (uint256)

    {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_user];

        uint256 accSolarPerShare = pool.accSolarPerShare;

        uint256 lpSupply = pool.lpToken.balanceOf(address(this));



        if (block.number > pool.lastRewardBlock && lpSupply != 0) {

            uint256 multiplier = getMultiplier(

                pool.lastRewardBlock,

                block.number

            );

            uint256 solarReward = multiplier

                .mul(solarPerBlock)

                .mul(pool.allocPoint)

                .div(totalAllocPoint);

            accSolarPerShare = accSolarPerShare.add(

                solarReward.mul(1e12).div(lpSupply)

            );

        }



        uint256 pending = user.amount.mul(accSolarPerShare).div(1e12).sub(

            user.rewardDebt

        );

        return pending.add(user.rewardLockedUp);

    }



    // View function to see if user can harvest Solar.

    function canHarvest(uint256 _pid, address _user)

        public

        view

        returns (bool)

    {

        UserInfo storage user = userInfo[_pid][_user];

        return

            block.number >= startBlock &&

            block.timestamp >= user.nextHarvestUntil;

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function massUpdatePools() public {

        uint256 length = poolInfo.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            updatePool(pid);

        }

    }



    // Update reward variables of the given pool to be up-to-date.

    function updatePool(uint256 _pid) public {

        PoolInfo storage pool = poolInfo[_pid];

        if (block.number <= pool.lastRewardBlock) {

            return;

        }



        uint256 lpSupply = pool.totalLp;

        if (lpSupply == 0 || pool.allocPoint == 0) {

            pool.lastRewardBlock = block.number;

            return;

        }



        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);

        uint256 solarReward = multiplier

            .mul(solarPerBlock)

            .mul(pool.allocPoint)

            .div(totalAllocPoint);



        solar.mint(devAddress, solarReward.div(10));

        solar.mint(address(this), solarReward);



        pool.accSolarPerShare = pool.accSolarPerShare.add(

            solarReward.mul(1e12).div(pool.totalLp)

        );

        pool.lastRewardBlock = block.number;

    }



    // Deposit LP tokens to MasterChef for Solar allocation.

    function deposit(uint256 _pid, uint256 _amount) public nonReentrant {

        require(

            block.number >= startBlock,

            "SolarDistributor: Can not deposit before start"

        );



        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_msgSender()];



        updatePool(_pid);



        payOrLockupPendingSolar(_pid);



        if (_amount > 0) {

            uint256 beforeDeposit = pool.lpToken.balanceOf(address(this));

            pool.lpToken.safeTransferFrom(_msgSender(), address(this), _amount);

            uint256 afterDeposit = pool.lpToken.balanceOf(address(this));



            _amount = afterDeposit.sub(beforeDeposit);



            if (pool.depositFeeBP > 0) {

                uint256 depositFee = _amount.mul(pool.depositFeeBP).div(10000);

                pool.lpToken.safeTransfer(feeAddress, depositFee);



                _amount = _amount.sub(depositFee);

            }



            user.amount = user.amount.add(_amount);

            pool.totalLp = pool.totalLp.add(_amount);



            if (address(pool.lpToken) == address(solar)) {

                totalSolarInPools = totalSolarInPools.add(_amount);

            }

        }

        user.rewardDebt = user.amount.mul(pool.accSolarPerShare).div(1e12);

        emit Deposit(_msgSender(), _pid, _amount);

    }



    // Withdraw tokens

    function withdraw(uint256 _pid, uint256 _amount) public nonReentrant {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_msgSender()];



        //this will make sure that user can only withdraw from his pool

        require(user.amount >= _amount, "Withdraw: User amount not enough");



        //Cannot withdraw more than pool's balance

        require(pool.totalLp >= _amount, "Withdraw: Pool total not enough");



        updatePool(_pid);



        payOrLockupPendingSolar(_pid);



        if (_amount > 0) {

            user.amount = user.amount.sub(_amount);

            pool.totalLp = pool.totalLp.sub(_amount);

            if (address(pool.lpToken) == address(solar)) {

                totalSolarInPools = totalSolarInPools.sub(_amount);

            }

            pool.lpToken.safeTransfer(_msgSender(), _amount);

        }

        user.rewardDebt = user.amount.mul(pool.accSolarPerShare).div(1e12);

        emit Withdraw(_msgSender(), _pid, _amount);

    }



    // Withdraw without caring about rewards. EMERGENCY ONLY.

    function emergencyWithdraw(uint256 _pid) public nonReentrant {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_msgSender()];

        uint256 amount = user.amount;



        //Cannot withdraw more than pool's balance

        require(

            pool.totalLp >= amount,

            "EmergencyWithdraw: Pool total not enough"

        );



        user.amount = 0;

        user.rewardDebt = 0;

        user.rewardLockedUp = 0;

        user.nextHarvestUntil = 0;

        pool.totalLp = pool.totalLp.sub(amount);



        if (address(pool.lpToken) == address(solar)) {

            totalSolarInPools = totalSolarInPools.sub(amount);

        }

        pool.lpToken.safeTransfer(_msgSender(), amount);



        emit EmergencyWithdraw(_msgSender(), _pid, amount);

    }



    // Pay or lockup pending Solar.

    function payOrLockupPendingSolar(uint256 _pid) internal {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_msgSender()];



        if (user.nextHarvestUntil == 0 && block.number >= startBlock) {

            user.nextHarvestUntil = block.timestamp.add(pool.harvestInterval);

        }



        uint256 pending = user.amount.mul(pool.accSolarPerShare).div(1e12).sub(

            user.rewardDebt

        );

        if (canHarvest(_pid, _msgSender())) {

            if (pending > 0 || user.rewardLockedUp > 0) {

                uint256 totalRewards = pending.add(user.rewardLockedUp);



                // reset lockup

                totalLockedUpRewards = totalLockedUpRewards.sub(

                    user.rewardLockedUp

                );

                user.rewardLockedUp = 0;

                user.nextHarvestUntil = block.timestamp.add(

                    pool.harvestInterval

                );



                // send rewards

                safeSolarTransfer(_msgSender(), totalRewards);

            }

        } else if (pending > 0) {

            user.rewardLockedUp = user.rewardLockedUp.add(pending);

            totalLockedUpRewards = totalLockedUpRewards.add(pending);

            emit RewardLockedUp(_msgSender(), _pid, pending);

        }

    }



    // Safe Solar transfer function, just in case if rounding error causes pool do not have enough Solar.

    function safeSolarTransfer(address _to, uint256 _amount) internal {

        if (solar.balanceOf(address(this)) > totalSolarInPools) {

            //SolarBal = total Solar in SolarDistributor - total Solar in Solar pools, this will make sure that SolarDistributor never transfer rewards from deposited Solar pools

            uint256 SolarBal = solar.balanceOf(address(this)).sub(

                totalSolarInPools

            );

            if (_amount >= SolarBal) {

                solar.transfer(_to, SolarBal);

            } else if (_amount > 0) {

                solar.transfer(_to, _amount);

            }

        }

    }



    // Update dev address by the previous dev.

    function setDevAddress(address _devAddress) public {

        require(_msgSender() == devAddress, "setDevAddress: FORBIDDEN");

        require(_devAddress != address(0), "setDevAddress: ZERO");



        emit DevAddressChanged(_msgSender(), devAddress, _devAddress);



        devAddress = _devAddress;

    }



    function setFeeAddress(address _feeAddress) public {

        require(_msgSender() == feeAddress, "setFeeAddress: FORBIDDEN");

        require(_feeAddress != address(0), "setFeeAddress: ZERO");



        emit FeeAddressChanged(_msgSender(), feeAddress, _feeAddress);



        feeAddress = _feeAddress;

    }



    // Pancake has to add hidden dummy pools in order to alter the emission, here we make it simple and transparent to all.

    function updateEmissionRate(uint256 _solarPerBlock) public onlyOperator {

        massUpdatePools();



        emit EmissionRateUpdated(msg.sender, solarPerBlock, _solarPerBlock);

        solarPerBlock = _solarPerBlock;

    }



    function updateAllocPoint(

        uint256 _pid,

        uint256 _allocPoint,

        bool _withUpdate

    ) public onlyOperator {

        if (_withUpdate) {

            massUpdatePools();

        }



        emit AllocPointsUpdated(

            _msgSender(),

            poolInfo[_pid].allocPoint,

            _allocPoint

        );



        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(

            _allocPoint

        );

        poolInfo[_pid].allocPoint = _allocPoint;

    }



    // Enable support for meta transactions

    function enableMetaTxns() public onlyOperator {

        require(!metaTxnsEnabled, "Meta transactions are already enabled");



        metaTxnsEnabled = true;

        emit MetaTxnsEnabled(_msgSender());

    }



    // Disable support for meta transactions

    function disableMetaTxns() public onlyOperator {

        require(metaTxnsEnabled, "Meta transactions are already disabled");



        metaTxnsEnabled = false;

        emit MetaTxnsDisabled(_msgSender());

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarDistributorV2.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/utils/Address.sol";

import "./rewarders/IComplexRewarder.sol";

import "./libraries/BoringERC20.sol";

import "./ISolarPair.sol";



contract SolarDistributorV2 is Ownable, ReentrancyGuard {

    using BoringERC20 for IBoringERC20;



    // Info of each user.

    struct UserInfo {

        uint256 amount; // How many LP tokens the user has provided.

        uint256 rewardDebt; // Reward debt. See explanation below.

        uint256 rewardLockedUp; // Reward locked up.

        uint256 nextHarvestUntil; // When can the user harvest again.

    }



    // Info of each pool.

    struct PoolInfo {

        IBoringERC20 lpToken; // Address of LP token contract.

        uint256 allocPoint; // How many allocation points assigned to this pool. Solar to distribute per block.

        uint256 lastRewardTimestamp; // Last block number that Solar distribution occurs.

        uint256 accSolarPerShare; // Accumulated Solar per share, times 1e18. See below.

        uint16 depositFeeBP; // Deposit fee in basis points

        uint256 harvestInterval; // Harvest interval in seconds

        uint256 totalLp; // Total token in Pool

        IComplexRewarder[] rewarders; // Array of rewarder contract for pools with incentives

    }



    IBoringERC20 public solar;



    // Solar tokens created per second

    uint256 public solarPerSec;



    // Max harvest interval: 14 days

    uint256 public constant MAXIMUM_HARVEST_INTERVAL = 14 days;



    // Maximum deposit fee rate: 10%

    uint16 public constant MAXIMUM_DEPOSIT_FEE_RATE = 1000;



    // Info of each pool

    PoolInfo[] public poolInfo;



    // Info of each user that stakes LP tokens.

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    // Total allocation points. Must be the sum of all allocation points in all pools.

    uint256 public totalAllocPoint = 0;



    // The timestamp when Solar mining starts.

    uint256 public startTimestamp;



    // Total locked up rewards

    uint256 public totalLockedUpRewards;



    // Total Solar in Solar Pools (can be multiple pools)

    uint256 public totalSolarInPools = 0;



    // Team address.

    address public teamAddress;



    // Treasury address.

    address public treasuryAddress;



    // Investor address.

    address public investorAddress;



    // Percentage of pool rewards that goto the team.

    uint256 public teamPercent;



    // Percentage of pool rewards that goes to the treasury.

    uint256 public treasuryPercent;



    // Percentage of pool rewards that goes to the investor.

    uint256 public investorPercent;



    // The precision factor

    uint256 private immutable ACC_TOKEN_PRECISION = 1e12;



    modifier validatePoolByPid(uint256 _pid) {

        require(_pid < poolInfo.length, "Pool does not exist");

        _;

    }



    event Add(

        uint256 indexed pid,

        uint256 allocPoint,

        IBoringERC20 indexed lpToken,

        uint16 depositFeeBP,

        uint256 harvestInterval,

        IComplexRewarder[] indexed rewarders

    );



    event Set(

        uint256 indexed pid,

        uint256 allocPoint,

        uint16 depositFeeBP,

        uint256 harvestInterval,

        IComplexRewarder[] indexed rewarders

    );



    event UpdatePool(

        uint256 indexed pid,

        uint256 lastRewardTimestamp,

        uint256 lpSupply,

        uint256 accSolarPerShare

    );



    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);



    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);



    event EmergencyWithdraw(

        address indexed user,

        uint256 indexed pid,

        uint256 amount

    );



    event EmissionRateUpdated(

        address indexed caller,

        uint256 previousValue,

        uint256 newValue

    );



    event RewardLockedUp(

        address indexed user,

        uint256 indexed pid,

        uint256 amountLockedUp

    );



    event AllocPointsUpdated(

        address indexed caller,

        uint256 previousAmount,

        uint256 newAmount

    );



    event SetTeamAddress(

        address indexed oldAddress,

        address indexed newAddress

    );



    event SetTreasuryAddress(

        address indexed oldAddress,

        address indexed newAddress

    );



    event SetInvestorAddress(

        address indexed oldAddress,

        address indexed newAddress

    );



    event SetTeamPercent(uint256 oldPercent, uint256 newPercent);



    event SetTreasuryPercent(uint256 oldPercent, uint256 newPercent);



    event SetInvestorPercent(uint256 oldPercent, uint256 newPercent);



    constructor(

        IBoringERC20 _solar,

        uint256 _solarPerSec,

        address _teamAddress,

        address _treasuryAddress,

        address _investorAddress,

        uint256 _teamPercent,

        uint256 _treasuryPercent,

        uint256 _investorPercent

    ) {

        require(

            _teamPercent <= 1000,

            "constructor: invalid team percent value"

        );

        require(

            _treasuryPercent <= 1000,

            "constructor: invalid treasury percent value"

        );

        require(

            _investorPercent <= 1000,

            "constructor: invalid investor percent value"

        );

        require(

            _teamPercent + _treasuryPercent + _investorPercent <= 1000,

            "constructor: total percent over max"

        );



        //StartBlock always many years later from contract const ruct, will be set later in StartFarming function

        startTimestamp = block.timestamp + (60 * 60 * 24 * 365);



        solar = _solar;

        solarPerSec = _solarPerSec;



        teamAddress = _teamAddress;

        treasuryAddress = _treasuryAddress;

        investorAddress = _investorAddress;



        teamPercent = _teamPercent;

        treasuryPercent = _treasuryPercent;

        investorPercent = _investorPercent;

    }



    // Set farming start, can call only once

    function startFarming() public onlyOwner {

        require(

            block.timestamp < startTimestamp,

            "start farming: farm started already"

        );



        uint256 length = poolInfo.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            PoolInfo storage pool = poolInfo[pid];

            pool.lastRewardTimestamp = block.timestamp;

        }



        startTimestamp = block.timestamp;

    }



    function poolLength() external view returns (uint256) {

        return poolInfo.length;

    }



    // Add a new lp to the pool. Can only be called by the owner.

    // Can add multiple pool with same lp token without messing up rewards, because each pool's balance is tracked using its own totalLp

    function add(

        uint256 _allocPoint,

        IBoringERC20 _lpToken,

        uint16 _depositFeeBP,

        uint256 _harvestInterval,

        IComplexRewarder[] calldata _rewarders

    ) public onlyOwner {

        require(_rewarders.length <= 10, "add: too many rewarders");

        require(

            _depositFeeBP <= MAXIMUM_DEPOSIT_FEE_RATE,

            "add: deposit fee too high"

        );

        require(

            _harvestInterval <= MAXIMUM_HARVEST_INTERVAL,

            "add: invalid harvest interval"

        );

        require(

            Address.isContract(address(_lpToken)),

            "add: LP token must be a valid contract"

        );



        for (

            uint256 rewarderId = 0;

            rewarderId < _rewarders.length;

            ++rewarderId

        ) {

            require(

                Address.isContract(address(_rewarders[rewarderId])),

                "add: rewarder must be contract"

            );

        }



        _massUpdatePools();



        uint256 lastRewardTimestamp = block.timestamp > startTimestamp

            ? block.timestamp

            : startTimestamp;



        totalAllocPoint += _allocPoint;



        poolInfo.push(

            PoolInfo({

                lpToken: _lpToken,

                allocPoint: _allocPoint,

                lastRewardTimestamp: lastRewardTimestamp,

                accSolarPerShare: 0,

                depositFeeBP: _depositFeeBP,

                harvestInterval: _harvestInterval,

                totalLp: 0,

                rewarders: _rewarders

            })

        );



        emit Add(

            poolInfo.length - 1,

            _allocPoint,

            _lpToken,

            _depositFeeBP,

            _harvestInterval,

            _rewarders

        );

    }



    // Update the given pool's Solar allocation point and deposit fee. Can only be called by the owner.

    function set(

        uint256 _pid,

        uint256 _allocPoint,

        uint16 _depositFeeBP,

        uint256 _harvestInterval,

        IComplexRewarder[] calldata _rewarders

    ) public onlyOwner validatePoolByPid(_pid) {

        require(_rewarders.length <= 10, "set: too many rewarders");



        require(

            _depositFeeBP <= MAXIMUM_DEPOSIT_FEE_RATE,

            "set: deposit fee too high"

        );

        require(

            _harvestInterval <= MAXIMUM_HARVEST_INTERVAL,

            "set: invalid harvest interval"

        );



        for (

            uint256 rewarderId = 0;

            rewarderId < _rewarders.length;

            ++rewarderId

        ) {

            require(

                Address.isContract(address(_rewarders[rewarderId])),

                "set: rewarder must be contract"

            );

        }



        _massUpdatePools();



        totalAllocPoint =

            totalAllocPoint -

            poolInfo[_pid].allocPoint +

            _allocPoint;



        poolInfo[_pid].allocPoint = _allocPoint;

        poolInfo[_pid].depositFeeBP = _depositFeeBP;

        poolInfo[_pid].harvestInterval = _harvestInterval;

        poolInfo[_pid].rewarders = _rewarders;



        emit Set(

            _pid,

            _allocPoint,

            _depositFeeBP,

            _harvestInterval,

            _rewarders

        );

    }



    // View function to see pending rewards on frontend.

    function pendingTokens(uint256 _pid, address _user)

        external

        view

        validatePoolByPid(_pid)

        returns (

            address[] memory addresses,

            string[] memory symbols,

            uint256[] memory decimals,

            uint256[] memory amounts

        )

    {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_user];

        uint256 accSolarPerShare = pool.accSolarPerShare;

        uint256 lpSupply = pool.totalLp;



        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {

            uint256 multiplier = block.timestamp - pool.lastRewardTimestamp;

            uint256 total = 1000;

            uint256 lpPercent = total -

                teamPercent -

                treasuryPercent -

                investorPercent;



            uint256 solarReward = (multiplier *

                solarPerSec *

                pool.allocPoint *

                lpPercent) /

                totalAllocPoint /

                total;



            accSolarPerShare += (

                ((solarReward * ACC_TOKEN_PRECISION) / lpSupply)

            );

        }



        uint256 pendingSolar = (((user.amount * accSolarPerShare) /

            ACC_TOKEN_PRECISION) - user.rewardDebt) + user.rewardLockedUp;



        addresses = new address[](pool.rewarders.length + 1);

        symbols = new string[](pool.rewarders.length + 1);

        amounts = new uint256[](pool.rewarders.length + 1);

        decimals = new uint256[](pool.rewarders.length + 1);



        addresses[0] = address(solar);

        symbols[0] = IBoringERC20(solar).safeSymbol();

        decimals[0] = IBoringERC20(solar).safeDecimals();

        amounts[0] = pendingSolar;



        for (

            uint256 rewarderId = 0;

            rewarderId < pool.rewarders.length;

            ++rewarderId

        ) {

            addresses[rewarderId + 1] = address(

                pool.rewarders[rewarderId].rewardToken()

            );



            symbols[rewarderId + 1] = IBoringERC20(

                pool.rewarders[rewarderId].rewardToken()

            ).safeSymbol();



            decimals[rewarderId + 1] = IBoringERC20(

                pool.rewarders[rewarderId].rewardToken()

            ).safeDecimals();



            amounts[rewarderId + 1] = pool.rewarders[rewarderId].pendingTokens(

                _pid,

                _user

            );

        }

    }



    /// @notice View function to see pool rewards per sec

    function poolRewardsPerSec(uint256 _pid)

        external

        view

        validatePoolByPid(_pid)

        returns (

            address[] memory addresses,

            string[] memory symbols,

            uint256[] memory decimals,

            uint256[] memory rewardsPerSec

        )

    {

        PoolInfo storage pool = poolInfo[_pid];



        addresses = new address[](pool.rewarders.length + 1);

        symbols = new string[](pool.rewarders.length + 1);

        decimals = new uint256[](pool.rewarders.length + 1);

        rewardsPerSec = new uint256[](pool.rewarders.length + 1);



        addresses[0] = address(solar);

        symbols[0] = IBoringERC20(solar).safeSymbol();

        decimals[0] = IBoringERC20(solar).safeDecimals();



        uint256 total = 1000;

        uint256 lpPercent = total -

            teamPercent -

            treasuryPercent -

            investorPercent;



        rewardsPerSec[0] =

            (pool.allocPoint * solarPerSec * lpPercent) /

            totalAllocPoint /

            total;



        for (

            uint256 rewarderId = 0;

            rewarderId < pool.rewarders.length;

            ++rewarderId

        ) {

            addresses[rewarderId + 1] = address(

                pool.rewarders[rewarderId].rewardToken()

            );



            symbols[rewarderId + 1] = IBoringERC20(

                pool.rewarders[rewarderId].rewardToken()

            ).safeSymbol();



            decimals[rewarderId + 1] = IBoringERC20(

                pool.rewarders[rewarderId].rewardToken()

            ).safeDecimals();



            rewardsPerSec[rewarderId + 1] = pool

                .rewarders[rewarderId]

                .poolRewardsPerSec(_pid);

        }

    }



    // View function to see rewarders for a pool

    function poolRewarders(uint256 _pid)

        external

        view

        validatePoolByPid(_pid)

        returns (address[] memory rewarders)

    {

        PoolInfo storage pool = poolInfo[_pid];

        rewarders = new address[](pool.rewarders.length);

        for (

            uint256 rewarderId = 0;

            rewarderId < pool.rewarders.length;

            ++rewarderId

        ) {

            rewarders[rewarderId] = address(pool.rewarders[rewarderId]);

        }

    }



    // View function to see if user can harvest Solar.

    function canHarvest(uint256 _pid, address _user)

        public

        view

        validatePoolByPid(_pid)

        returns (bool)

    {

        UserInfo storage user = userInfo[_pid][_user];

        return

            block.timestamp >= startTimestamp &&

            block.timestamp >= user.nextHarvestUntil;

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function massUpdatePools() external nonReentrant {

        _massUpdatePools();

    }



    // Internal method for massUpdatePools

    function _massUpdatePools() internal {

        for (uint256 pid = 0; pid < poolInfo.length; ++pid) {

            _updatePool(pid);

        }

    }



    // Update reward variables of the given pool to be up-to-date.

    function updatePool(uint256 _pid) external nonReentrant {

        _updatePool(_pid);

    }



    // Internal method for _updatePool

    function _updatePool(uint256 _pid) internal validatePoolByPid(_pid) {

        PoolInfo storage pool = poolInfo[_pid];



        if (block.timestamp <= pool.lastRewardTimestamp) {

            return;

        }



        uint256 lpSupply = pool.totalLp;



        if (lpSupply == 0 || pool.allocPoint == 0) {

            pool.lastRewardTimestamp = block.timestamp;

            return;

        }



        uint256 multiplier = block.timestamp - pool.lastRewardTimestamp;



        uint256 solarReward = ((multiplier * solarPerSec) * pool.allocPoint) /

            totalAllocPoint;



        uint256 total = 1000;

        uint256 lpPercent = total -

            teamPercent -

            treasuryPercent -

            investorPercent;



        solar.mint(teamAddress, (solarReward * teamPercent) / total);

        solar.mint(treasuryAddress, (solarReward * treasuryPercent) / total);

        solar.mint(investorAddress, (solarReward * investorPercent) / total);

        solar.mint(address(this), (solarReward * lpPercent) / total);



        pool.accSolarPerShare +=

            (solarReward * ACC_TOKEN_PRECISION * lpPercent) /

            pool.totalLp /

            total;



        pool.lastRewardTimestamp = block.timestamp;



        emit UpdatePool(

            _pid,

            pool.lastRewardTimestamp,

            lpSupply,

            pool.accSolarPerShare

        );

    }



    function depositWithPermit(

        uint256 pid,

        uint256 amount,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) public nonReentrant validatePoolByPid(pid) {

        PoolInfo storage pool = poolInfo[pid];

        ISolarPair pair = ISolarPair(address(pool.lpToken));

        pair.permit(msg.sender, address(this), amount, deadline, v, r, s);

        _deposit(pid, amount);

    }



    // Deposit tokens for Solar allocation.

    function deposit(uint256 _pid, uint256 _amount) public nonReentrant {

        _deposit(_pid, _amount);

    }



    // Deposit tokens for Solar allocation.

    function _deposit(uint256 _pid, uint256 _amount)

        internal

        validatePoolByPid(_pid)

    {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];



        _updatePool(_pid);



        payOrLockupPendingSolar(_pid);



        if (_amount > 0) {

            uint256 beforeDeposit = pool.lpToken.balanceOf(address(this));

            pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);

            uint256 afterDeposit = pool.lpToken.balanceOf(address(this));



            _amount = afterDeposit - beforeDeposit;



            if (pool.depositFeeBP > 0) {

                uint256 depositFee = (_amount * pool.depositFeeBP) / 10000;

                pool.lpToken.safeTransfer(treasuryAddress, depositFee);



                _amount = _amount - depositFee;

            }



            user.amount += _amount;



            if (address(pool.lpToken) == address(solar)) {

                totalSolarInPools += _amount;

            }

        }

        user.rewardDebt =

            (user.amount * pool.accSolarPerShare) /

            ACC_TOKEN_PRECISION;



        for (

            uint256 rewarderId = 0;

            rewarderId < pool.rewarders.length;

            ++rewarderId

        ) {

            pool.rewarders[rewarderId].onSolarReward(

                _pid,

                msg.sender,

                user.amount

            );

        }



        if (_amount > 0) {

            pool.totalLp += _amount;

        }



        emit Deposit(msg.sender, _pid, _amount);

    }



    //withdraw tokens

    function withdraw(uint256 _pid, uint256 _amount)

        public

        nonReentrant

        validatePoolByPid(_pid)

    {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];



        //this will make sure that user can only withdraw from his pool

        require(user.amount >= _amount, "withdraw: user amount not enough");



        //cannot withdraw more than pool's balance

        require(pool.totalLp >= _amount, "withdraw: pool total not enough");



        _updatePool(_pid);



        payOrLockupPendingSolar(_pid);



        if (_amount > 0) {

            user.amount -= _amount;

            if (address(pool.lpToken) == address(solar)) {

                totalSolarInPools -= _amount;

            }

            pool.lpToken.safeTransfer(msg.sender, _amount);

        }



        user.rewardDebt =

            (user.amount * pool.accSolarPerShare) /

            ACC_TOKEN_PRECISION;



        for (

            uint256 rewarderId = 0;

            rewarderId < pool.rewarders.length;

            ++rewarderId

        ) {

            pool.rewarders[rewarderId].onSolarReward(

                _pid,

                msg.sender,

                user.amount

            );

        }



        if (_amount > 0) {

            pool.totalLp -= _amount;

        }



        emit Withdraw(msg.sender, _pid, _amount);

    }



    // Withdraw without caring about rewards. EMERGENCY ONLY.

    function emergencyWithdraw(uint256 _pid) public nonReentrant {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];

        uint256 amount = user.amount;



        //Cannot withdraw more than pool's balance

        require(

            pool.totalLp >= amount,

            "emergency withdraw: pool total not enough"

        );



        user.amount = 0;

        user.rewardDebt = 0;

        user.rewardLockedUp = 0;

        user.nextHarvestUntil = 0;

        pool.totalLp -= amount;



        for (

            uint256 rewarderId = 0;

            rewarderId < pool.rewarders.length;

            ++rewarderId

        ) {

            pool.rewarders[rewarderId].onSolarReward(_pid, msg.sender, 0);

        }



        if (address(pool.lpToken) == address(solar)) {

            totalSolarInPools -= amount;

        }



        pool.lpToken.safeTransfer(msg.sender, amount);



        emit EmergencyWithdraw(msg.sender, _pid, amount);

    }



    // Pay or lockup pending Solar.

    function payOrLockupPendingSolar(uint256 _pid) internal {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];



        if (user.nextHarvestUntil == 0 && block.timestamp >= startTimestamp) {

            user.nextHarvestUntil = block.timestamp + pool.harvestInterval;

        }



        uint256 pending = ((user.amount * pool.accSolarPerShare) /

            ACC_TOKEN_PRECISION) - user.rewardDebt;



        if (canHarvest(_pid, msg.sender)) {

            if (pending > 0 || user.rewardLockedUp > 0) {

                uint256 pendingRewards = pending + user.rewardLockedUp;



                // reset lockup

                totalLockedUpRewards -= user.rewardLockedUp;

                user.rewardLockedUp = 0;

                user.nextHarvestUntil = block.timestamp + pool.harvestInterval;



                // send rewards

                safeSolarTransfer(msg.sender, pendingRewards);

            }

        } else if (pending > 0) {

            totalLockedUpRewards += pending;

            user.rewardLockedUp += pending;

            emit RewardLockedUp(msg.sender, _pid, pending);

        }

    }



    // Safe Solar transfer function, just in case if rounding error causes pool do not have enough Solar.

    function safeSolarTransfer(address _to, uint256 _amount) internal {

        if (solar.balanceOf(address(this)) > totalSolarInPools) {

            //solarBal = total Solar in SolarDistributor - total Solar in Solar pools, this will make sure that SolarDistributor never transfer rewards from deposited Solar pools

            uint256 solarBal = solar.balanceOf(address(this)) -

                totalSolarInPools;

            if (_amount >= solarBal) {

                solar.safeTransfer(_to, solarBal);

            } else if (_amount > 0) {

                solar.safeTransfer(_to, _amount);

            }

        }

    }



    function updateEmissionRate(uint256 _solarPerSec) public onlyOwner {

        _massUpdatePools();



        emit EmissionRateUpdated(msg.sender, solarPerSec, _solarPerSec);



        solarPerSec = _solarPerSec;

    }



    function updateAllocPoint(uint256 _pid, uint256 _allocPoint)

        public

        onlyOwner

    {

        _massUpdatePools();



        emit AllocPointsUpdated(

            msg.sender,

            poolInfo[_pid].allocPoint,

            _allocPoint

        );



        totalAllocPoint =

            totalAllocPoint -

            poolInfo[_pid].allocPoint +

            _allocPoint;

        poolInfo[_pid].allocPoint = _allocPoint;

    }



    function poolTotalLp(uint256 pid) external view returns (uint256) {

        return poolInfo[pid].totalLp;

    }



    // Function to harvest many pools in a single transaction

    function harvestMany(uint256[] calldata _pids) public nonReentrant {

        require(_pids.length <= 30, "harvest many: too many pool ids");

        for (uint256 index = 0; index < _pids.length; ++index) {

            _deposit(_pids[index], 0);

        }

    }



    // Update team address by the previous team address.

    function setTeamAddress(address _teamAddress) public {

        require(

            msg.sender == teamAddress,

            "set team address: only previous team address can call this method"

        );

        require(

            _teamAddress != address(0),

            "set team address: invalid new team address"

        );

        teamAddress = _teamAddress;

        emit SetTeamAddress(msg.sender, _teamAddress);

    }



    function setTeamPercent(uint256 _newTeamPercent) public onlyOwner {

        require(

            _newTeamPercent <= 1000,

            "set team percent: invalid percent value"

        );

        require(

            treasuryPercent + _newTeamPercent + investorPercent <= 1000,

            "set team percent: total percent over max"

        );

        emit SetTeamPercent(teamPercent, _newTeamPercent);

        teamPercent = _newTeamPercent;

    }



    // Update treasury address by the previous treasury.

    function setTreasuryAddress(address _treasuryAddress) public {

        require(

            msg.sender == treasuryAddress,

            "set treasury address: only previous treasury address can call this method"

        );

        require(

            _treasuryAddress != address(0),

            "set treasury address: invalid new treasury address"

        );

        treasuryAddress = _treasuryAddress;

        emit SetTreasuryAddress(msg.sender, _treasuryAddress);

    }



    function setTreasuryPercent(uint256 _newTreasuryPercent) public onlyOwner {

        require(

            _newTreasuryPercent <= 1000,

            "set treasury percent: invalid percent value"

        );

        require(

            teamPercent + _newTreasuryPercent + investorPercent <= 1000,

            "set treasury percent: total percent over max"

        );

        emit SetTreasuryPercent(treasuryPercent, _newTreasuryPercent);

        treasuryPercent = _newTreasuryPercent;

    }



    // Update the investor address by the previous investor.

    function setInvestorAddress(address _investorAddress) public {

        require(

            msg.sender == investorAddress,

            "set investor address: only previous investor can call this method"

        );

        require(

            _investorAddress != address(0),

            "set investor address: invalid new investor address"

        );

        investorAddress = _investorAddress;

        emit SetInvestorAddress(msg.sender, _investorAddress);

    }



    function setInvestorPercent(uint256 _newInvestorPercent) public onlyOwner {

        require(

            _newInvestorPercent <= 1000,

            "set investor percent: invalid percent value"

        );

        require(

            teamPercent + _newInvestorPercent + treasuryPercent <= 1000,

            "set investor percent: total percent over max"

        );

        emit SetInvestorPercent(investorPercent, _newInvestorPercent);

        investorPercent = _newInvestorPercent;

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarERC20.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



import "./libraries/SafeMath.sol";



contract SolarERC20 {

    using SafeMathSolar for uint256;



    string public constant name = "SolarBeam LP Token";

    string public constant symbol = "SLP";

    uint8 public constant decimals = 18;

    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;



    bytes32 public DOMAIN_SEPARATOR;

    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");

    bytes32 public constant PERMIT_TYPEHASH =

        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    mapping(address => uint256) public nonces;



    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );

    event Transfer(address indexed from, address indexed to, uint256 value);



    constructor() public {

        uint256 chainId;

        assembly {

            chainId := chainid()

        }

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256(

                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"

                ),

                keccak256(bytes(name)),

                keccak256(bytes("1")),

                chainId,

                address(this)

            )

        );

    }



    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal pure virtual returns (bytes calldata) {

        return msg.data;

    }



    function _mint(address to, uint256 value) internal {

        totalSupply = totalSupply.add(value);

        balanceOf[to] = balanceOf[to].add(value);

        emit Transfer(address(0), to, value);

    }



    function _burn(address from, uint256 value) internal {

        balanceOf[from] = balanceOf[from].sub(value);

        totalSupply = totalSupply.sub(value);

        emit Transfer(from, address(0), value);

    }



    function _approve(

        address owner,

        address spender,

        uint256 value

    ) private {

        allowance[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    function _transfer(

        address from,

        address to,

        uint256 value

    ) private {

        balanceOf[from] = balanceOf[from].sub(value);

        balanceOf[to] = balanceOf[to].add(value);

        emit Transfer(from, to, value);

    }



    function approve(address spender, uint256 value) external returns (bool) {

        _approve(_msgSender(), spender, value);

        return true;

    }



    function transfer(address to, uint256 value) external returns (bool) {

        _transfer(_msgSender(), to, value);

        return true;

    }



    function transferFrom(

        address from,

        address to,

        uint256 value

    ) external returns (bool) {

        if (allowance[from][_msgSender()] != uint256(-1)) {

            allowance[from][_msgSender()] = allowance[from][_msgSender()].sub(

                value

            );

        }

        _transfer(from, to, value);

        return true;

    }



    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external {

        require(deadline >= block.timestamp, "SolarBeam: EXPIRED");

        bytes32 digest = keccak256(

            abi.encodePacked(

                "\x19\x01",

                DOMAIN_SEPARATOR,

                keccak256(

                    abi.encode(

                        PERMIT_TYPEHASH,

                        owner,

                        spender,

                        value,

                        nonces[owner]++,

                        deadline

                    )

                )

            )

        );

        address recoveredAddress = ecrecover(digest, v, r, s);

        require(

            recoveredAddress != address(0) && recoveredAddress == owner,

            "SolarBeam: INVALID_SIGNATURE"

        );

        _approve(owner, spender, value);

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarFactory.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



import "./interfaces/ISolarFactory.sol";

import "./SolarPair.sol";



contract SolarFactory is ISolarFactory {

    bytes32 public constant INIT_CODE_PAIR_HASH =

        keccak256(abi.encodePacked(type(SolarPair).creationCode));



    address public override feeTo;

    address public override feeToSetter;

    address public override migrator;



    mapping(address => mapping(address => address)) public override getPair;

    address[] public override allPairs;



    event PairCreated(

        address indexed token0,

        address indexed token1,

        address pair,

        uint256

    );



    constructor(address _feeToSetter) public {

        feeToSetter = _feeToSetter;

    }



    function allPairsLength() external view override returns (uint256) {

        return allPairs.length;

    }



    function createPair(address tokenA, address tokenB)

        external

        override

        returns (address pair)

    {

        require(tokenA != tokenB, "SolarBeam: IDENTICAL_ADDRESSES");

        (address token0, address token1) = tokenA < tokenB

            ? (tokenA, tokenB)

            : (tokenB, tokenA);

        require(token0 != address(0), "SolarBeam: ZERO_ADDRESS");

        require(

            getPair[token0][token1] == address(0),

            "SolarBeam: PAIR_EXISTS"

        ); // single check is sufficient

        bytes memory bytecode = type(SolarPair).creationCode;

        bytes32 salt = keccak256(abi.encodePacked(token0, token1));

        assembly {

            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)

        }

        SolarPair(pair).initialize(token0, token1);

        getPair[token0][token1] = pair;

        getPair[token1][token0] = pair; // populate mapping in the reverse direction

        allPairs.push(pair);

        emit PairCreated(token0, token1, pair, allPairs.length);

    }



    function setFeeTo(address _feeTo) external override {

        require(msg.sender == feeToSetter, "SolarBeam: FORBIDDEN");

        feeTo = _feeTo;

    }



    function setMigrator(address _migrator) external override {

        require(msg.sender == feeToSetter, "SolarBeam: FORBIDDEN");

        migrator = _migrator;

    }



    function setFeeToSetter(address _feeToSetter) external override {

        require(msg.sender == feeToSetter, "SolarBeam: FORBIDDEN");

        feeToSetter = _feeToSetter;

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarFeeColector.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



import "./interfaces/ISolarERC20.sol";

import "./interfaces/ISolarPair.sol";

import "./interfaces/ISolarFactory.sol";

import "./interfaces/ISolarRouter02.sol";

import "./interfaces/ISmartRouter.sol";



contract SolarFeeColector is Ownable {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;

    uint256 internal constant UINT_MAX = type(uint256).max;



    ISmartRouter public smartRouter;

    ISolarRouter02 public router;

    address private immutable wmovr;



    constructor(

        address _smartRouter,

        address _router,

        address _wmovr

    ) {

        smartRouter = ISmartRouter(_smartRouter);

        router = ISolarRouter02(_router);

        wmovr = _wmovr;

    }



    function removeLiquidityAndSwap(address[] memory lpTokens, address toToken)

        external

        onlyOwner

    {

        uint256 len = lpTokens.length;

        for (uint256 i = 0; i < len; i++) {

            ISolarPair pair = ISolarPair(lpTokens[i]);

            address token0 = ISolarPair(pair).token0();

            address token1 = ISolarPair(pair).token1();



            _removeLiquidity(address(pair), address(this));

            _swap(token0, toToken, address(this));

            _swap(token1, toToken, address(this));

        }

    }



    function removeLiquidity(address[] memory lpTokens) external onlyOwner {

        uint256 len = lpTokens.length;

        for (uint256 i = 0; i < len; i++) {

            _removeLiquidity(lpTokens[i], address(this));

        }

    }



    function removeLiquidityFrom(address[] memory lpTokens) external onlyOwner {

        uint256 len = lpTokens.length;

        for (uint256 i = 0; i < len; i++) {

            _removeLiquidity(lpTokens[i], msg.sender);

        }

    }



    function _removeLiquidity(address lpToken, address from) internal {

        ISolarPair pair = ISolarPair(lpToken);

        address token0 = ISolarPair(lpToken).token0();

        address token1 = ISolarPair(lpToken).token1();

        require(address(pair) != address(0), "SolarFeeColector: Invalid pair");



        uint256 amount = IERC20(address(pair)).balanceOf(from);



        if (amount > 0) {

            if (from != address(this)) {

                IERC20(address(pair)).safeTransferFrom(

                    from,

                    address(this),

                    amount

                );

            }



            if (

                IERC20(lpToken).allowance(address(this), address(router)) <

                amount

            ) {

                IERC20(lpToken).safeApprove(address(router), UINT_MAX);

            }



            router.removeLiquidity(

                token0,

                token1,

                amount,

                0,

                0,

                msg.sender,

                block.timestamp

            );

        }

    }



    function swapTokens(address[] memory tokens, address toToken)

        external

        onlyOwner

    {

        uint256 len = tokens.length;

        for (uint256 i = 0; i < len; i++) {

            _swap(tokens[i], toToken, address(this));

        }

    }



    function swapTokensFrom(address[] memory tokens, address toToken)

        external

        onlyOwner

    {

        uint256 len = tokens.length;

        for (uint256 i = 0; i < len; i++) {

            _swap(tokens[i], toToken, msg.sender);

        }

    }



    function _swap(

        address fromToken,

        address toToken,

        address from

    ) internal {

        uint256 amount = IERC20(address(fromToken)).balanceOf(from);



        if (amount > 0) {

            if (from != address(this)) {

                IERC20(address(fromToken)).safeTransferFrom(

                    from,

                    address(this),

                    amount

                );

            }



            if (

                IERC20(fromToken).allowance(

                    address(this),

                    address(smartRouter)

                ) < amount

            ) {

                IERC20(fromToken).safeApprove(address(smartRouter), UINT_MAX);

            }



            ISmartRouter.FormattedOffer memory offer = smartRouter.findBestPath(

                amount,

                fromToken,

                toToken,

                3,

                ISmartRouter.InputType.AMOUNT_IN

            );



            ISmartRouter.Trade memory trade = ISmartRouter.Trade(

                offer.amounts,

                offer.path,

                offer.adapters

            );



            smartRouter.swapNoSplit(trade, msg.sender, 0);

        }

    }



    receive() external payable {}



    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)

        external

        onlyOwner

    {

        require(_tokenAmount > 0, "Nothing to recover");

        IERC20(_tokenAddress).safeTransfer(msg.sender, _tokenAmount);

    }



    function recoverNATIVE(uint256 _amount) external onlyOwner {

        require(_amount > 0, "Nothing to recover");

        payable(msg.sender).transfer(_amount);

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarLibrary.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



import "../interfaces/ISolarPair.sol";

import "./SafeMath.sol";



library SolarLibrary {

    using SafeMathSolar for uint256;



    // returns sorted token addresses, used to handle return values from pairs sorted in this order

    function sortTokens(address tokenA, address tokenB)

        internal

        pure

        returns (address token0, address token1)

    {

        require(tokenA != tokenB, "SolarLibrary: IDENTICAL_ADDRESSES");

        (token0, token1) = tokenA < tokenB

            ? (tokenA, tokenB)

            : (tokenB, tokenA);

        require(token0 != address(0), "SolarLibrary: ZERO_ADDRESS");

    }



    // calculates the CREATE2 address for a pair without making any external calls

    function pairFor(

        address factory,

        address tokenA,

        address tokenB

    ) internal pure returns (address pair) {

        (address token0, address token1) = sortTokens(tokenA, tokenB);

        pair = address(

            uint256(

                keccak256(

                    abi.encodePacked(

                        hex"ff",

                        factory,

                        keccak256(abi.encodePacked(token0, token1)),

                        hex"0f53772a0b91c61dc3aaaa6aa3f0c898f1dbd2c53070a959c4254207038e064d" // init code hash

                    )

                )

            )

        );

    }



    // fetches and sorts the reserves for a pair

    function getReserves(

        address factory,

        address tokenA,

        address tokenB

    ) internal view returns (uint256 reserveA, uint256 reserveB) {

        (address token0, ) = sortTokens(tokenA, tokenB);

        (uint256 reserve0, uint256 reserve1, ) = ISolarPair(

            pairFor(factory, tokenA, tokenB)

        ).getReserves();

        (reserveA, reserveB) = tokenA == token0

            ? (reserve0, reserve1)

            : (reserve1, reserve0);

    }



    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset

    function quote(

        uint256 amountA,

        uint256 reserveA,

        uint256 reserveB

    ) internal pure returns (uint256 amountB) {

        require(amountA > 0, "SolarLibrary: INSUFFICIENT_AMOUNT");

        require(

            reserveA > 0 && reserveB > 0,

            "SolarLibrary: INSUFFICIENT_LIQUIDITY"

        );

        amountB = amountA.mul(reserveB) / reserveA;

    }



    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset

    function getAmountOut(

        uint256 amountIn,

        uint256 reserveIn,

        uint256 reserveOut

    ) internal pure returns (uint256 amountOut) {

        require(amountIn > 0, "SolarLibrary: INSUFFICIENT_INPUT_AMOUNT");

        require(

            reserveIn > 0 && reserveOut > 0,

            "SolarLibrary: INSUFFICIENT_LIQUIDITY"

        );

        uint256 feeMul = uint256(10000).sub(25);

        uint256 amountInWithFee = amountIn.mul(feeMul);

        uint256 numerator = amountInWithFee.mul(reserveOut);

        uint256 denominator = reserveIn.mul(10000).add(amountInWithFee);

        amountOut = numerator / denominator;

    }



    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset

    function getAmountIn(

        uint256 amountOut,

        uint256 reserveIn,

        uint256 reserveOut

    ) internal pure returns (uint256 amountIn) {

        require(amountOut > 0, "SolarLibrary: INSUFFICIENT_OUTPUT_AMOUNT");

        require(

            reserveIn > 0 && reserveOut > 0,

            "SolarLibrary: INSUFFICIENT_LIQUIDITY"

        );

        uint256 feeMul = uint256(10000).sub(25);

        uint256 numerator = reserveIn.mul(amountOut).mul(10000);

        uint256 denominator = reserveOut.sub(amountOut).mul(feeMul);

        amountIn = (numerator / denominator).add(1);

    }



    // performs chained getAmountOut calculations on any number of pairs

    function getAmountsOut(

        address factory,

        uint256 amountIn,

        address[] memory path

    ) internal view returns (uint256[] memory amounts) {

        require(path.length >= 2, "SolarLibrary: INVALID_PATH");

        amounts = new uint256[](path.length);

        amounts[0] = amountIn;

        for (uint256 i; i < path.length - 1; i++) {

            (uint256 reserveIn, uint256 reserveOut) = getReserves(

                factory,

                path[i],

                path[i + 1]

            );

            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);

        }

    }



    // performs chained getAmountIn calculations on any number of pairs

    function getAmountsIn(

        address factory,

        uint256 amountOut,

        address[] memory path

    ) internal view returns (uint256[] memory amounts) {

        require(path.length >= 2, "SolarLibrary: INVALID_PATH");

        amounts = new uint256[](path.length);

        amounts[amounts.length - 1] = amountOut;

        for (uint256 i = path.length - 1; i > 0; i--) {

            (uint256 reserveIn, uint256 reserveOut) = getReserves(

                factory,

                path[i - 1],

                path[i]

            );

            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);

        }

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarLocker.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "@openzeppelin/contracts/access/Ownable.sol";



contract SolarLocker is Ownable{

    using SafeMath for uint256;

    using SafeERC20 for IERC20;

    

    struct Items {

        IERC20 token;

        address withdrawer;

        uint256 amount;

        uint256 unlockTimestamp;

        bool withdrawn;

    }

    

    uint256 public depositsCount;

    mapping (address => uint256[]) private depositsByTokenAddress;

    mapping (address => uint256[]) public depositsByWithdrawer;

    mapping (uint256 => Items) public lockedToken;

    mapping (address => mapping(address => uint256)) public walletTokenBalance;

    

    uint256 public lockFee = 0.1 ether;

    address public marketingAddress;

    

    event Withdraw(address withdrawer, uint256 amount);

    event Lock(address token, uint256 amount, uint256 id);

    

    constructor() {

        marketingAddress = msg.sender;

    }

    

    function lockTokens(IERC20 _token, address _withdrawer, uint256 _amount, uint256 _unlockTimestamp) payable external returns (uint256 _id) {

        require(_amount > 0, 'Token amount too low!');

        require(_unlockTimestamp < 10000000000, 'Unlock timestamp is not in seconds!');

        require(_unlockTimestamp > block.timestamp, 'Unlock timestamp is not in the future!');

        require(_token.allowance(msg.sender, address(this)) >= _amount, 'Approve tokens first!');

        require(msg.value >= lockFee, 'Need to pay lock fee!');



        uint256 beforeDeposit = _token.balanceOf(address(this));

        _token.safeTransferFrom(msg.sender, address(this), _amount);

        uint256 afterDeposit = _token.balanceOf(address(this));

        

        _amount = afterDeposit.sub(beforeDeposit); 



        payable(marketingAddress).transfer(msg.value);

                

        walletTokenBalance[address(_token)][msg.sender] = walletTokenBalance[address(_token)][msg.sender].add(_amount);

        

        _id = ++depositsCount;

        lockedToken[_id].token = _token;

        lockedToken[_id].withdrawer = _withdrawer;

        lockedToken[_id].amount = _amount;

        lockedToken[_id].unlockTimestamp = _unlockTimestamp;

        lockedToken[_id].withdrawn = false;

        

        depositsByTokenAddress[address(_token)].push(_id);

        depositsByWithdrawer[_withdrawer].push(_id);



        emit Lock(address(_token), _amount, _id);

        

        return _id;

    }

        

    function withdrawTokens(uint256 _id) external {

        require(block.timestamp >= lockedToken[_id].unlockTimestamp, 'Tokens are still locked!');

        require(msg.sender == lockedToken[_id].withdrawer, 'You are not the withdrawer!');

        require(!lockedToken[_id].withdrawn, 'Tokens are already withdrawn!');

        

        lockedToken[_id].withdrawn = true;

        

        walletTokenBalance[address(lockedToken[_id].token)][msg.sender] = walletTokenBalance[address(lockedToken[_id].token)][msg.sender].sub(lockedToken[_id].amount);

        

        emit Withdraw(msg.sender, lockedToken[_id].amount);

        lockedToken[_id].token.safeTransfer(msg.sender, lockedToken[_id].amount);

    }

    

    function setMarketingAddress(address _marketingAddress) external onlyOwner {

        marketingAddress = _marketingAddress;

    }

    

    function setLockFee(uint256 _lockFee) external onlyOwner {

        lockFee = _lockFee;

    }

    

    function getDepositsByTokenAddress(address _token) view external returns (uint256[] memory) {

        return depositsByTokenAddress[_token];

    }

    

    function getDepositsByWithdrawer(address _withdrawer) view external returns (uint256[] memory) {

        return depositsByWithdrawer[_withdrawer];

    }

    

    

    function getTokenTotalLockedBalance(address _token) view external returns (uint256) {

       return IERC20(_token).balanceOf(address(this));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarPair.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



import "./SolarERC20.sol";

import "./libraries/Math.sol";

import "./libraries/UQ112x112.sol";

import "./interfaces/IERC20.sol";

import "./interfaces/ISolarFactory.sol";

import "./interfaces/ISolarCallee.sol";



interface IMigrator {

    // Return the desired amount of liquidity token that the migrator wants.

    function desiredLiquidity() external view returns (uint256);

}



contract SolarPair is SolarERC20 {

    using SafeMathSolar for uint256;

    using UQ112x112 for uint224;



    uint256 public constant MINIMUM_LIQUIDITY = 10**3;

    bytes4 private constant SELECTOR =

        bytes4(keccak256(bytes("transfer(address,uint256)")));



    address public factory;

    address public token0;

    address public token1;



    uint112 private reserve0; // uses single storage slot, accessible via getReserves

    uint112 private reserve1; // uses single storage slot, accessible via getReserves

    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves



    uint256 public price0CumulativeLast;

    uint256 public price1CumulativeLast;

    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event



    struct SwapVariables {

        uint112 _reserve0;

        uint112 _reserve1;

        uint256 balance0;

        uint256 balance1;

        uint256 amount0In;

        uint256 amount1In;

    }



    uint256 private unlocked = 1;

    modifier lock() {

        require(unlocked == 1, "SolarBeam: LOCKED");

        unlocked = 0;

        _;

        unlocked = 1;

    }



    function getReserves()

        public

        view

        returns (

            uint112 _reserve0,

            uint112 _reserve1,

            uint32 _blockTimestampLast

        )

    {

        _reserve0 = reserve0;

        _reserve1 = reserve1;

        _blockTimestampLast = blockTimestampLast;

    }



    function _safeTransfer(

        address token,

        address to,

        uint256 value

    ) private {

        (bool success, bytes memory data) = token.call(

            abi.encodeWithSelector(SELECTOR, to, value)

        );

        require(

            success && (data.length == 0 || abi.decode(data, (bool))),

            "SolarBeam: TRANSFER_FAILED"

        );

    }



    event Mint(address indexed sender, uint256 amount0, uint256 amount1);

    event Burn(

        address indexed sender,

        uint256 amount0,

        uint256 amount1,

        address indexed to

    );

    event Swap(

        address indexed sender,

        uint256 amount0In,

        uint256 amount1In,

        uint256 amount0Out,

        uint256 amount1Out,

        address indexed to

    );

    event Sync(uint112 reserve0, uint112 reserve1);



    constructor() public {

        factory = msg.sender;

    }



    // called once by the factory at time of deployment

    function initialize(address _token0, address _token1) external {

        require(msg.sender == factory, "SolarBeam: FORBIDDEN"); // sufficient check

        token0 = _token0;

        token1 = _token1;

    }



    // update reserves and, on the first call per block, price accumulators

    function _update(

        uint256 balance0,

        uint256 balance1,

        uint112 _reserve0,

        uint112 _reserve1

    ) private {

        require(

            balance0 <= uint112(-1) && balance1 <= uint112(-1),

            "SolarBeam: OVERFLOW"

        );

        uint32 blockTimestamp = uint32(block.timestamp % 2**32);

        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired

        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {

            // * never overflows, and + overflow is desired

            price0CumulativeLast +=

                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *

                timeElapsed;

            price1CumulativeLast +=

                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *

                timeElapsed;

        }

        reserve0 = uint112(balance0);

        reserve1 = uint112(balance1);

        blockTimestampLast = blockTimestamp;

        emit Sync(reserve0, reserve1);

    }



    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)

    function _mintFee(uint112 _reserve0, uint112 _reserve1)

        private

        returns (bool feeOn)

    {

        address feeTo = ISolarFactory(factory).feeTo();

        feeOn = feeTo != address(0);

        uint256 _kLast = kLast; // gas savings

        if (feeOn) {

            if (_kLast != 0) {

                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));

                uint256 rootKLast = Math.sqrt(_kLast);

                if (rootK > rootKLast) {

                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));

                    uint256 denominator = rootK.mul(5).add(rootKLast);

                    uint256 liquidity = numerator / denominator;

                    if (liquidity > 0) _mint(feeTo, liquidity);

                }

            }

        } else if (_kLast != 0) {

            kLast = 0;

        }

    }



    // this low-level function should be called from a contract which performs important safety checks

    function mint(address to) external lock returns (uint256 liquidity) {

        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings

        uint256 balance0 = IERC20Solar(token0).balanceOf(address(this));

        uint256 balance1 = IERC20Solar(token1).balanceOf(address(this));

        uint256 amount0 = balance0.sub(_reserve0);

        uint256 amount1 = balance1.sub(_reserve1);



        bool feeOn = _mintFee(_reserve0, _reserve1);

        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

        if (_totalSupply == 0) {

            address migrator = ISolarFactory(factory).migrator();

            if (_msgSender() == migrator) {

                liquidity = IMigrator(migrator).desiredLiquidity();

                require(

                    liquidity > 0 && liquidity != uint256(-1),

                    "Bad desired liquidity"

                );

            } else {

                require(migrator == address(0), "Must not have migrator");

                liquidity = Math.sqrt(amount0.mul(amount1)).sub(

                    MINIMUM_LIQUIDITY

                );

                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens

            }

        } else {

            liquidity = Math.min(

                amount0.mul(_totalSupply) / _reserve0,

                amount1.mul(_totalSupply) / _reserve1

            );

        }

        require(liquidity > 0, "SolarBeam: INSUFFICIENT_LIQUIDITY_MINTED");

        _mint(to, liquidity);



        _update(balance0, balance1, _reserve0, _reserve1);

        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

        emit Mint(_msgSender(), amount0, amount1);

    }



    // this low-level function should be called from a contract which performs important safety checks

    function burn(address to)

        external

        lock

        returns (uint256 amount0, uint256 amount1)

    {

        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings

        address _token0 = token0; // gas savings

        address _token1 = token1; // gas savings

        uint256 balance0 = IERC20Solar(_token0).balanceOf(address(this));

        uint256 balance1 = IERC20Solar(_token1).balanceOf(address(this));

        uint256 liquidity = balanceOf[address(this)];



        bool feeOn = _mintFee(_reserve0, _reserve1);

        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution

        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution

        require(

            amount0 > 0 && amount1 > 0,

            "SolarBeam: INSUFFICIENT_LIQUIDITY_BURNED"

        );

        _burn(address(this), liquidity);

        _safeTransfer(_token0, to, amount0);

        _safeTransfer(_token1, to, amount1);

        balance0 = IERC20Solar(_token0).balanceOf(address(this));

        balance1 = IERC20Solar(_token1).balanceOf(address(this));



        _update(balance0, balance1, _reserve0, _reserve1);

        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

        emit Burn(_msgSender(), amount0, amount1, to);

    }



    // this low-level function should be called from a contract which performs important safety checks

    function swap(

        uint256 amount0Out,

        uint256 amount1Out,

        address to,

        bytes calldata data

    ) external lock {

        require(

            amount0Out > 0 || amount1Out > 0,

            "SolarBeam: INSUFFICIENT_OUTPUT_AMOUNT"

        );

        SwapVariables memory vars = SwapVariables(0, 0, 0, 0, 0, 0);

        (vars._reserve0, vars._reserve1, ) = getReserves(); // gas savings

        require(

            amount0Out < vars._reserve0 && amount1Out < vars._reserve1,

            "SolarBeam: INSUFFICIENT_LIQUIDITY"

        );



        {

            // scope for _token{0,1}, avoids stack too deep errors

            address _token0 = token0;

            address _token1 = token1;

            require(to != _token0 && to != _token1, "SolarBeam: INVALID_TO");

            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens

            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens

            if (data.length > 0)

                ISolarCallee(to).uniswapV2Call(

                    _msgSender(),

                    amount0Out,

                    amount1Out,

                    data

                );

            vars.balance0 = IERC20Solar(_token0).balanceOf(address(this));

            vars.balance1 = IERC20Solar(_token1).balanceOf(address(this));

        }

        vars.amount0In = vars.balance0 > vars._reserve0 - amount0Out

            ? vars.balance0 - (vars._reserve0 - amount0Out)

            : 0;

        vars.amount1In = vars.balance1 > vars._reserve1 - amount1Out

            ? vars.balance1 - (vars._reserve1 - amount1Out)

            : 0;

        require(

            vars.amount0In > 0 || vars.amount1In > 0,

            "SolarBeam: INSUFFICIENT_INPUT_AMOUNT"

        );

        {

            // scope for reserve{0,1} - Adjusted, avoids stack too deep errors

            uint256 balance0Adjusted = vars.balance0.mul(10000).sub(

                vars.amount0In.mul(25)

            );

            uint256 balance1Adjusted = vars.balance1.mul(10000).sub(

                vars.amount1In.mul(25)

            );

            require(

                balance0Adjusted.mul(balance1Adjusted) >=

                    uint256(vars._reserve0).mul(vars._reserve1).mul(10000**2),

                "SolarBeam: K"

            );

        }



        _update(vars.balance0, vars.balance1, vars._reserve0, vars._reserve1);

        emit Swap(

            _msgSender(),

            vars.amount0In,

            vars.amount1In,

            amount0Out,

            amount1Out,

            to

        );

    }



    // force balances to match reserves

    function skim(address to) external lock {

        address _token0 = token0; // gas savings

        address _token1 = token1; // gas savings

        _safeTransfer(

            _token0,

            to,

            IERC20Solar(_token0).balanceOf(address(this)).sub(reserve0)

        );

        _safeTransfer(

            _token1,

            to,

            IERC20Solar(_token1).balanceOf(address(this)).sub(reserve1)

        );

    }



    // force reserves to match balances

    function sync() external lock {

        _update(

            IERC20Solar(token0).balanceOf(address(this)),

            IERC20Solar(token1).balanceOf(address(this)),

            reserve0,

            reserve1

        );

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarRouter02.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



import "./libraries/SolarLibrary.sol";

import "./libraries/SafeMath.sol";

import "./libraries/TransferHelper.sol";

import "./interfaces/ISolarRouter02.sol";

import "./interfaces/ISolarFactory.sol";

import "./interfaces/IERC20.sol";

import "./interfaces/IWETH.sol";



contract SolarRouter02 is ISolarRouter02 {

    using SafeMathSolar for uint256;



    address public immutable override factory;

    address public immutable override WETH;



    modifier ensure(uint256 deadline) {

        require(deadline >= block.timestamp, "SolarRouter: EXPIRED");

        _;

    }



    constructor(address _factory, address _WETH) public {

        factory = _factory;

        WETH = _WETH;

    }



    receive() external payable {

        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract

    }



    // **** ADD LIQUIDITY ****

    function _addLiquidity(

        address tokenA,

        address tokenB,

        uint256 amountADesired,

        uint256 amountBDesired,

        uint256 amountAMin,

        uint256 amountBMin

    ) internal virtual returns (uint256 amountA, uint256 amountB) {

        // create the pair if it doesn't exist yet

        if (ISolarFactory(factory).getPair(tokenA, tokenB) == address(0)) {

            ISolarFactory(factory).createPair(tokenA, tokenB);

        }

        (uint256 reserveA, uint256 reserveB) = SolarLibrary.getReserves(

            factory,

            tokenA,

            tokenB

        );

        if (reserveA == 0 && reserveB == 0) {

            (amountA, amountB) = (amountADesired, amountBDesired);

        } else {

            uint256 amountBOptimal = SolarLibrary.quote(

                amountADesired,

                reserveA,

                reserveB

            );

            if (amountBOptimal <= amountBDesired) {

                require(

                    amountBOptimal >= amountBMin,

                    "SolarRouter: INSUFFICIENT_B_AMOUNT"

                );

                (amountA, amountB) = (amountADesired, amountBOptimal);

            } else {

                uint256 amountAOptimal = SolarLibrary.quote(

                    amountBDesired,

                    reserveB,

                    reserveA

                );

                assert(amountAOptimal <= amountADesired);

                require(

                    amountAOptimal >= amountAMin,

                    "SolarRouter: INSUFFICIENT_A_AMOUNT"

                );

                (amountA, amountB) = (amountAOptimal, amountBDesired);

            }

        }

    }



    function addLiquidity(

        address tokenA,

        address tokenB,

        uint256 amountADesired,

        uint256 amountBDesired,

        uint256 amountAMin,

        uint256 amountBMin,

        address to,

        uint256 deadline

    )

        external

        virtual

        override

        ensure(deadline)

        returns (

            uint256 amountA,

            uint256 amountB,

            uint256 liquidity

        )

    {

        (amountA, amountB) = _addLiquidity(

            tokenA,

            tokenB,

            amountADesired,

            amountBDesired,

            amountAMin,

            amountBMin

        );

        address pair = SolarLibrary.pairFor(factory, tokenA, tokenB);

        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);

        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);

        liquidity = ISolarPair(pair).mint(to);

    }



    function addLiquidityETH(

        address token,

        uint256 amountTokenDesired,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline

    )

        external

        payable

        virtual

        override

        ensure(deadline)

        returns (

            uint256 amountToken,

            uint256 amountETH,

            uint256 liquidity

        )

    {

        (amountToken, amountETH) = _addLiquidity(

            token,

            WETH,

            amountTokenDesired,

            msg.value,

            amountTokenMin,

            amountETHMin

        );

        address pair = SolarLibrary.pairFor(factory, token, WETH);

        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);

        IWETH(WETH).deposit{value: amountETH}();

        assert(IWETH(WETH).transfer(pair, amountETH));

        liquidity = ISolarPair(pair).mint(to);

        // refund dust eth, if any

        if (msg.value > amountETH)

            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);

    }



    // **** REMOVE LIQUIDITY ****

    function removeLiquidity(

        address tokenA,

        address tokenB,

        uint256 liquidity,

        uint256 amountAMin,

        uint256 amountBMin,

        address to,

        uint256 deadline

    )

        public

        virtual

        override

        ensure(deadline)

        returns (uint256 amountA, uint256 amountB)

    {

        address pair = SolarLibrary.pairFor(factory, tokenA, tokenB);

        ISolarPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair

        (uint256 amount0, uint256 amount1) = ISolarPair(pair).burn(to);

        (address token0, ) = SolarLibrary.sortTokens(tokenA, tokenB);

        (amountA, amountB) = tokenA == token0

            ? (amount0, amount1)

            : (amount1, amount0);

        require(amountA >= amountAMin, "SolarRouter: INSUFFICIENT_A_AMOUNT");

        require(amountB >= amountBMin, "SolarRouter: INSUFFICIENT_B_AMOUNT");

    }



    function removeLiquidityETH(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline

    )

        public

        virtual

        override

        ensure(deadline)

        returns (uint256 amountToken, uint256 amountETH)

    {

        (amountToken, amountETH) = removeLiquidity(

            token,

            WETH,

            liquidity,

            amountTokenMin,

            amountETHMin,

            address(this),

            deadline

        );

        TransferHelper.safeTransfer(token, to, amountToken);

        IWETH(WETH).withdraw(amountETH);

        TransferHelper.safeTransferETH(to, amountETH);

    }



    function removeLiquidityWithPermit(

        address tokenA,

        address tokenB,

        uint256 liquidity,

        uint256 amountAMin,

        uint256 amountBMin,

        address to,

        uint256 deadline,

        bool approveMax,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external virtual override returns (uint256 amountA, uint256 amountB) {

        address pair = SolarLibrary.pairFor(factory, tokenA, tokenB);

        uint256 value = approveMax ? uint256(-1) : liquidity;

        ISolarPair(pair).permit(

            msg.sender,

            address(this),

            value,

            deadline,

            v,

            r,

            s

        );

        (amountA, amountB) = removeLiquidity(

            tokenA,

            tokenB,

            liquidity,

            amountAMin,

            amountBMin,

            to,

            deadline

        );

    }



    function removeLiquidityETHWithPermit(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline,

        bool approveMax,

        uint8 v,

        bytes32 r,

        bytes32 s

    )

        external

        virtual

        override

        returns (uint256 amountToken, uint256 amountETH)

    {

        address pair = SolarLibrary.pairFor(factory, token, WETH);

        uint256 value = approveMax ? uint256(-1) : liquidity;

        ISolarPair(pair).permit(

            msg.sender,

            address(this),

            value,

            deadline,

            v,

            r,

            s

        );

        (amountToken, amountETH) = removeLiquidityETH(

            token,

            liquidity,

            amountTokenMin,

            amountETHMin,

            to,

            deadline

        );

    }



    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****

    function removeLiquidityETHSupportingFeeOnTransferTokens(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline

    ) public virtual override ensure(deadline) returns (uint256 amountETH) {

        (, amountETH) = removeLiquidity(

            token,

            WETH,

            liquidity,

            amountTokenMin,

            amountETHMin,

            address(this),

            deadline

        );

        TransferHelper.safeTransfer(

            token,

            to,

            IERC20Solar(token).balanceOf(address(this))

        );

        IWETH(WETH).withdraw(amountETH);

        TransferHelper.safeTransferETH(to, amountETH);

    }



    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline,

        bool approveMax,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external virtual override returns (uint256 amountETH) {

        address pair = SolarLibrary.pairFor(factory, token, WETH);

        uint256 value = approveMax ? uint256(-1) : liquidity;

        ISolarPair(pair).permit(

            msg.sender,

            address(this),

            value,

            deadline,

            v,

            r,

            s

        );

        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(

            token,

            liquidity,

            amountTokenMin,

            amountETHMin,

            to,

            deadline

        );

    }



    // **** SWAP ****

    // requires the initial amount to have already been sent to the first pair

    function _swap(

        uint256[] memory amounts,

        address[] memory path,

        address _to

    ) internal virtual {

        for (uint256 i; i < path.length - 1; i++) {

            (address input, address output) = (path[i], path[i + 1]);

            (address token0, ) = SolarLibrary.sortTokens(input, output);

            uint256 amountOut = amounts[i + 1];

            (uint256 amount0Out, uint256 amount1Out) = input == token0

                ? (uint256(0), amountOut)

                : (amountOut, uint256(0));

            address to = i < path.length - 2

                ? SolarLibrary.pairFor(factory, output, path[i + 2])

                : _to;

            ISolarPair(SolarLibrary.pairFor(factory, input, output)).swap(

                amount0Out,

                amount1Out,

                to,

                new bytes(0)

            );

        }

    }



    function swapExactTokensForTokens(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    )

        external

        virtual

        override

        ensure(deadline)

        returns (uint256[] memory amounts)

    {

        amounts = SolarLibrary.getAmountsOut(factory, amountIn, path);

        require(

            amounts[amounts.length - 1] >= amountOutMin,

            "SolarRouter: INSUFFICIENT_OUTPUT_AMOUNT"

        );

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            SolarLibrary.pairFor(factory, path[0], path[1]),

            amounts[0]

        );

        _swap(amounts, path, to);

    }



    function swapTokensForExactTokens(

        uint256 amountOut,

        uint256 amountInMax,

        address[] calldata path,

        address to,

        uint256 deadline

    )

        external

        virtual

        override

        ensure(deadline)

        returns (uint256[] memory amounts)

    {

        amounts = SolarLibrary.getAmountsIn(factory, amountOut, path);

        require(

            amounts[0] <= amountInMax,

            "SolarRouter: EXCESSIVE_INPUT_AMOUNT"

        );

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            SolarLibrary.pairFor(factory, path[0], path[1]),

            amounts[0]

        );

        _swap(amounts, path, to);

    }



    function swapExactETHForTokens(

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    )

        external

        payable

        virtual

        override

        ensure(deadline)

        returns (uint256[] memory amounts)

    {

        require(path[0] == WETH, "SolarRouter: INVALID_PATH");

        amounts = SolarLibrary.getAmountsOut(factory, msg.value, path);

        require(

            amounts[amounts.length - 1] >= amountOutMin,

            "SolarRouter: INSUFFICIENT_OUTPUT_AMOUNT"

        );

        IWETH(WETH).deposit{value: amounts[0]}();

        assert(

            IWETH(WETH).transfer(

                SolarLibrary.pairFor(factory, path[0], path[1]),

                amounts[0]

            )

        );

        _swap(amounts, path, to);

    }



    function swapTokensForExactETH(

        uint256 amountOut,

        uint256 amountInMax,

        address[] calldata path,

        address to,

        uint256 deadline

    )

        external

        virtual

        override

        ensure(deadline)

        returns (uint256[] memory amounts)

    {

        require(path[path.length - 1] == WETH, "SolarRouter: INVALID_PATH");

        amounts = SolarLibrary.getAmountsIn(factory, amountOut, path);

        require(

            amounts[0] <= amountInMax,

            "SolarRouter: EXCESSIVE_INPUT_AMOUNT"

        );

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            SolarLibrary.pairFor(factory, path[0], path[1]),

            amounts[0]

        );

        _swap(amounts, path, address(this));

        IWETH(WETH).withdraw(amounts[amounts.length - 1]);

        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);

    }



    function swapExactTokensForETH(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    )

        external

        virtual

        override

        ensure(deadline)

        returns (uint256[] memory amounts)

    {

        require(path[path.length - 1] == WETH, "SolarRouter: INVALID_PATH");

        amounts = SolarLibrary.getAmountsOut(factory, amountIn, path);

        require(

            amounts[amounts.length - 1] >= amountOutMin,

            "SolarRouter: INSUFFICIENT_OUTPUT_AMOUNT"

        );

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            SolarLibrary.pairFor(factory, path[0], path[1]),

            amounts[0]

        );

        _swap(amounts, path, address(this));

        IWETH(WETH).withdraw(amounts[amounts.length - 1]);

        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);

    }



    function swapETHForExactTokens(

        uint256 amountOut,

        address[] calldata path,

        address to,

        uint256 deadline

    )

        external

        payable

        virtual

        override

        ensure(deadline)

        returns (uint256[] memory amounts)

    {

        require(path[0] == WETH, "SolarRouter: INVALID_PATH");

        amounts = SolarLibrary.getAmountsIn(factory, amountOut, path);

        require(amounts[0] <= msg.value, "SolarRouter: EXCESSIVE_INPUT_AMOUNT");

        IWETH(WETH).deposit{value: amounts[0]}();

        assert(

            IWETH(WETH).transfer(

                SolarLibrary.pairFor(factory, path[0], path[1]),

                amounts[0]

            )

        );

        _swap(amounts, path, to);

        // refund dust eth, if any

        if (msg.value > amounts[0])

            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);

    }



    // **** SWAP (supporting fee-on-transfer tokens) ****

    // requires the initial amount to have already been sent to the first pair

    function _swapSupportingFeeOnTransferTokens(

        address[] memory path,

        address _to

    ) internal virtual {

        for (uint256 i; i < path.length - 1; i++) {

            (address input, address output) = (path[i], path[i + 1]);

            (address token0, ) = SolarLibrary.sortTokens(input, output);

            ISolarPair pair = ISolarPair(

                SolarLibrary.pairFor(factory, input, output)

            );

            uint256 amountInput;

            uint256 amountOutput;



            {

                // scope to avoid stack too deep errors

                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();

                (uint256 reserveInput, uint256 reserveOutput) = input == token0

                    ? (reserve0, reserve1)

                    : (reserve1, reserve0);

                amountInput = IERC20Solar(input).balanceOf(address(pair)).sub(

                    reserveInput

                );

                amountOutput = SolarLibrary.getAmountOut(

                    amountInput,

                    reserveInput,

                    reserveOutput

                );

            }



            (uint256 amount0Out, uint256 amount1Out) = input == token0

                ? (uint256(0), amountOutput)

                : (amountOutput, uint256(0));

            address to = i < path.length - 2

                ? SolarLibrary.pairFor(factory, output, path[i + 2])

                : _to;

            pair.swap(amount0Out, amount1Out, to, new bytes(0));

        }

    }



    function swapExactTokensForTokensSupportingFeeOnTransferTokens(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external virtual override ensure(deadline) {

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            SolarLibrary.pairFor(factory, path[0], path[1]),

            amountIn

        );

        uint256 balanceBefore = IERC20Solar(path[path.length - 1]).balanceOf(

            to

        );

        _swapSupportingFeeOnTransferTokens(path, to);

        require(

            IERC20Solar(path[path.length - 1]).balanceOf(to).sub(

                balanceBefore

            ) >= amountOutMin,

            "SolarRouter: INSUFFICIENT_OUTPUT_AMOUNT"

        );

    }



    function swapExactETHForTokensSupportingFeeOnTransferTokens(

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external payable virtual override ensure(deadline) {

        require(path[0] == WETH, "SolarRouter: INVALID_PATH");

        uint256 amountIn = msg.value;

        IWETH(WETH).deposit{value: amountIn}();

        assert(

            IWETH(WETH).transfer(

                SolarLibrary.pairFor(factory, path[0], path[1]),

                amountIn

            )

        );

        uint256 balanceBefore = IERC20Solar(path[path.length - 1]).balanceOf(

            to

        );

        _swapSupportingFeeOnTransferTokens(path, to);

        require(

            IERC20Solar(path[path.length - 1]).balanceOf(to).sub(

                balanceBefore

            ) >= amountOutMin,

            "SolarRouter: INSUFFICIENT_OUTPUT_AMOUNT"

        );

    }



    function swapExactTokensForETHSupportingFeeOnTransferTokens(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external virtual override ensure(deadline) {

        require(path[path.length - 1] == WETH, "SolarRouter: INVALID_PATH");

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            SolarLibrary.pairFor(factory, path[0], path[1]),

            amountIn

        );

        _swapSupportingFeeOnTransferTokens(path, address(this));

        uint256 amountOut = IERC20Solar(WETH).balanceOf(address(this));

        require(

            amountOut >= amountOutMin,

            "SolarRouter: INSUFFICIENT_OUTPUT_AMOUNT"

        );

        IWETH(WETH).withdraw(amountOut);

        TransferHelper.safeTransferETH(to, amountOut);

    }



    // **** LIBRARY FUNCTIONS ****

    function quote(

        uint256 amountA,

        uint256 reserveA,

        uint256 reserveB

    ) public pure virtual override returns (uint256 amountB) {

        return SolarLibrary.quote(amountA, reserveA, reserveB);

    }



    function getAmountOut(

        uint256 amountIn,

        uint256 reserveIn,

        uint256 reserveOut

    ) public pure virtual override returns (uint256 amountOut) {

        return SolarLibrary.getAmountOut(amountIn, reserveIn, reserveOut);

    }



    function getAmountIn(

        uint256 amountOut,

        uint256 reserveIn,

        uint256 reserveOut

    ) public pure virtual override returns (uint256 amountIn) {

        return SolarLibrary.getAmountIn(amountOut, reserveIn, reserveOut);

    }



    function getAmountsOut(uint256 amountIn, address[] memory path)

        public

        view

        virtual

        override

        returns (uint256[] memory amounts)

    {

        return SolarLibrary.getAmountsOut(factory, amountIn, path);

    }



    function getAmountsIn(uint256 amountOut, address[] memory path)

        public

        view

        virtual

        override

        returns (uint256[] memory amounts)

    {

        return SolarLibrary.getAmountsIn(factory, amountOut, path);

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\SolarVault.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./ISolarERC20.sol";



contract SolarVault is Ownable, ReentrancyGuard {

    address constant _trustedForwarder =

        0x0D0b4862F5FfA3A47D04DDf0351356d20C830460; //Trusted forwarder



    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    // Info of each user.

    struct UserInfo {

        uint256 amount; // How many LP tokens the user has provided.

        uint256 rewardDebt; // Reward debt. See explanation below.

        uint256 rewardLockedUp; // Reward locked up.

        uint256 nextHarvestUntil; // When can the user harvest again.

        uint256 lastInteraction; // Last time when user deposited or claimed rewards, renewing the lock

    }



    // Info of each pool.

    struct PoolInfo {

        IERC20 lpToken; // Address of LP token contract

        uint256 allocPoint; // How many allocation points assigned to this pool. Solar to distribute per block.

        uint256 lastRewardBlock; // Last block number that Solar distribution occurs.

        uint256 accSolarPerShare; // Accumulated Solar per share, times 1e12. See below.

        uint16 depositFeeBP; // Deposit fee in basis points

        uint256 harvestInterval; // Harvest interval in seconds

        uint256 totalLp; // Total token in Pool

        uint256 lockupDuration; // Amount of time the participant will be locked in the pool after depositing or claiming rewards

    }



    ISolarERC20 public solar;



    // The operator can only update EmissionRate and AllocPoint to protect tokenomics

    //i.e some wrong setting and a pools get too much allocation accidentally

    address private _operator;



    // Dev address.

    address public devAddress;



    // Deposit Fee address

    address public feeAddress;



    // Solar tokens created per block

    uint256 public solarPerBlock;



    // Max harvest interval: 14 days

    uint256 public constant MAXIMUM_HARVEST_INTERVAL = 14 days;



    // Maximum deposit fee rate: 10%

    uint16 public constant MAXIMUM_DEPOSIT_FEE_RATE = 1000;



    // Info of each pool

    PoolInfo[] public poolInfo;



    // Info of each user that stakes LP tokens.

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    // Total allocation points. Must be the sum of all allocation points in all pools.

    uint256 public totalAllocPoint = 0;



    // The block number when Solar mining starts.

    uint256 public startBlock;



    // Total locked up rewards

    uint256 public totalLockedUpRewards;



    // Total Solar in Solar Pools (can be multiple pools)

    uint256 public totalSolarInPools = 0;



    // Control support for EIP-2771 Meta Transactions

    bool public metaTxnsEnabled = false;



    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);

    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);

    event EmergencyWithdraw(

        address indexed user,

        uint256 indexed pid,

        uint256 amount

    );

    event EmissionRateUpdated(

        address indexed caller,

        uint256 previousAmount,

        uint256 newAmount

    );

    event RewardLockedUp(

        address indexed user,

        uint256 indexed pid,

        uint256 amountLockedUp

    );

    event OperatorTransferred(

        address indexed previousOperator,

        address indexed newOperator

    );

    event DevAddressChanged(

        address indexed caller,

        address oldAddress,

        address newAddress

    );

    event FeeAddressChanged(

        address indexed caller,

        address oldAddress,

        address newAddress

    );

    event AllocPointsUpdated(

        address indexed caller,

        uint256 previousAmount,

        uint256 newAmount

    );

    event MetaTxnsEnabled(address indexed caller);

    event MetaTxnsDisabled(address indexed caller);



    modifier onlyOperator() {

        require(

            _operator == msg.sender,

            "Operator: caller is not the operator"

        );

        _;

    }



    constructor(ISolarERC20 _solar, uint256 _solarPerBlock) {

        //StartBlock always many years later from contract construct, will be set later in StartFarming function

        startBlock = block.number + (10 * 365 * 24 * 60 * 60);



        solar = _solar;

        solarPerBlock = _solarPerBlock;



        devAddress = msg.sender;

        feeAddress = msg.sender;

        _operator = msg.sender;

        emit OperatorTransferred(address(0), _operator);

    }



    function isTrustedForwarder(address forwarder)

        public

        view

        virtual

        returns (bool)

    {

        return metaTxnsEnabled && forwarder == _trustedForwarder;

    }



    function _msgSender()

        internal

        view

        virtual

        override

        returns (address sender)

    {

        if (isTrustedForwarder(msg.sender)) {

            // The assembly code is more direct than the Solidity version using `abi.decode`.

            assembly {

                sender := shr(96, calldataload(sub(calldatasize(), 20)))

            }

        } else {

            return super._msgSender();

        }

    }



    function _msgData()

        internal

        view

        virtual

        override

        returns (bytes calldata)

    {

        if (isTrustedForwarder(msg.sender)) {

            return msg.data[:msg.data.length - 20];

        } else {

            return super._msgData();

        }

    }



    function operator() public view returns (address) {

        return _operator;

    }



    // Return reward multiplier over the given _from to _to block.

    function getMultiplier(uint256 _from, uint256 _to)

        public

        pure

        returns (uint256)

    {

        return _to.sub(_from);

    }



    function transferOperator(address newOperator) public onlyOperator {

        require(

            newOperator != address(0),

            "TransferOperator: new operator is the zero address"

        );

        emit OperatorTransferred(_operator, newOperator);

        _operator = newOperator;

    }



    // Set farming start, can call only once

    function startFarming() public onlyOwner {

        require(block.number < startBlock, "Error: farm started already");



        uint256 length = poolInfo.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            PoolInfo storage pool = poolInfo[pid];

            pool.lastRewardBlock = block.number;

        }



        startBlock = block.number;

    }



    function poolLength() external view returns (uint256) {

        return poolInfo.length;

    }



    // Add a new lp to the pool. Can only be called by the owner.

    // Can add multiple pool with same lp token without messing up rewards, because each pool's balance is tracked using its own totalLp

    function add(

        uint256 _allocPoint,

        IERC20 _lpToken,

        uint16 _depositFeeBP,

        uint256 _harvestInterval,

        uint256 _lockupDuration,

        bool _withUpdate

    ) public onlyOwner {

        require(

            _depositFeeBP <= MAXIMUM_DEPOSIT_FEE_RATE,

            "Add: deposit fee too high"

        );

        require(

            _harvestInterval <= MAXIMUM_HARVEST_INTERVAL,

            "Add: invalid harvest interval"

        );

        if (_withUpdate) {

            massUpdatePools();

        }

        uint256 lastRewardBlock = block.number > startBlock

            ? block.number

            : startBlock;

        totalAllocPoint = totalAllocPoint.add(_allocPoint);

        poolInfo.push(

            PoolInfo({

                lpToken: _lpToken,

                allocPoint: _allocPoint,

                lastRewardBlock: lastRewardBlock,

                accSolarPerShare: 0,

                depositFeeBP: _depositFeeBP,

                harvestInterval: _harvestInterval,

                totalLp: 0,

                lockupDuration: _lockupDuration

            })

        );

    }



    // View function to see pending Solar on frontend.

    function pendingSolar(uint256 _pid, address _user)

        external

        view

        returns (uint256)

    {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_user];

        uint256 accSolarPerShare = pool.accSolarPerShare;

        uint256 lpSupply = pool.lpToken.balanceOf(address(this));



        if (block.number > pool.lastRewardBlock && lpSupply != 0) {

            uint256 multiplier = getMultiplier(

                pool.lastRewardBlock,

                block.number

            );

            uint256 solarReward = multiplier

                .mul(solarPerBlock)

                .mul(pool.allocPoint)

                .div(totalAllocPoint);

            accSolarPerShare = accSolarPerShare.add(

                solarReward.mul(1e12).div(lpSupply)

            );

        }



        uint256 pending = user.amount.mul(accSolarPerShare).div(1e12).sub(

            user.rewardDebt

        );

        return pending.add(user.rewardLockedUp);

    }



    // View function to see when user will be unlocked from pool

    function userLockedUntil(uint256 _pid, address _user)

        public

        view

        returns (uint256)

    {

        UserInfo storage user = userInfo[_pid][_user];

        PoolInfo storage pool = poolInfo[_pid];



        return user.lastInteraction + pool.lockupDuration;

    }



    // View function to see if user can harvest Solar.

    function canHarvest(uint256 _pid, address _user)

        public

        view

        returns (bool)

    {

        UserInfo storage user = userInfo[_pid][_user];

        return

            block.number >= startBlock &&

            block.timestamp >= user.nextHarvestUntil;

    }



    // Update reward vairables for all pools. Be careful of gas spending!

    function massUpdatePools() public {

        uint256 length = poolInfo.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            updatePool(pid);

        }

    }



    // Update reward variables of the given pool to be up-to-date.

    function updatePool(uint256 _pid) public {

        PoolInfo storage pool = poolInfo[_pid];

        if (block.number <= pool.lastRewardBlock) {

            return;

        }



        uint256 lpSupply = pool.totalLp;

        if (lpSupply == 0 || pool.allocPoint == 0) {

            pool.lastRewardBlock = block.number;

            return;

        }



        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);

        uint256 solarReward = multiplier

            .mul(solarPerBlock)

            .mul(pool.allocPoint)

            .div(totalAllocPoint);



        solar.mint(devAddress, solarReward.div(10));

        solar.mint(address(this), solarReward);



        pool.accSolarPerShare = pool.accSolarPerShare.add(

            solarReward.mul(1e12).div(pool.totalLp)

        );

        pool.lastRewardBlock = block.number;

    }



    // Deposit LP tokens to SolarVault for Solar allocation

    function deposit(uint256 _pid, uint256 _amount) public nonReentrant {

        require(

            block.number >= startBlock,

            "SolarVault: cannot deposit before farming start"

        );



        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_msgSender()];



        updatePool(_pid);



        payOrLockupPendingSolar(_pid);



        if (_amount > 0) {

            uint256 beforeDeposit = pool.lpToken.balanceOf(address(this));

            pool.lpToken.safeTransferFrom(_msgSender(), address(this), _amount);

            uint256 afterDeposit = pool.lpToken.balanceOf(address(this));



            _amount = afterDeposit.sub(beforeDeposit);



            if (pool.depositFeeBP > 0) {

                uint256 depositFee = _amount.mul(pool.depositFeeBP).div(10000);

                pool.lpToken.safeTransfer(feeAddress, depositFee);



                _amount = _amount.sub(depositFee);

            }



            user.amount = user.amount.add(_amount);

            pool.totalLp = pool.totalLp.add(_amount);



            if (address(pool.lpToken) == address(solar)) {

                totalSolarInPools = totalSolarInPools.add(_amount);

            }

        }

        user.rewardDebt = user.amount.mul(pool.accSolarPerShare).div(1e12);

        user.lastInteraction = block.timestamp;

        emit Deposit(_msgSender(), _pid, _amount);

    }



    // Withdraw tokens

    function withdraw(uint256 _pid, uint256 _amount) public nonReentrant {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_msgSender()];



        //this will make sure that user can only withdraw from his pool

        require(user.amount >= _amount, "Withdraw: user amount is not enough");



        //Cannot withdraw more than pool's balance

        require(pool.totalLp >= _amount, "Withdraw: pool total is not enough");



        //Cannot withdraw before lock time

        require(

            block.timestamp > user.lastInteraction + pool.lockupDuration,

            "Withdraw: you cannot withdraw yet"

        );



        updatePool(_pid);



        payOrLockupPendingSolar(_pid);



        if (_amount > 0) {

            user.amount = user.amount.sub(_amount);

            pool.totalLp = pool.totalLp.sub(_amount);

            if (address(pool.lpToken) == address(solar)) {

                totalSolarInPools = totalSolarInPools.sub(_amount);

            }

            pool.lpToken.safeTransfer(_msgSender(), _amount);

        }

        user.rewardDebt = user.amount.mul(pool.accSolarPerShare).div(1e12);

        user.lastInteraction = block.timestamp;

        emit Withdraw(_msgSender(), _pid, _amount);

    }



    // Pay or lockup pending Solar.

    function payOrLockupPendingSolar(uint256 _pid) internal {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_msgSender()];



        if (user.nextHarvestUntil == 0 && block.number >= startBlock) {

            user.nextHarvestUntil = block.timestamp.add(pool.harvestInterval);

        }



        uint256 pending = user.amount.mul(pool.accSolarPerShare).div(1e12).sub(

            user.rewardDebt

        );

        if (canHarvest(_pid, _msgSender())) {

            if (pending > 0 || user.rewardLockedUp > 0) {

                uint256 totalRewards = pending.add(user.rewardLockedUp);



                // reset lockup

                totalLockedUpRewards = totalLockedUpRewards.sub(

                    user.rewardLockedUp

                );

                user.rewardLockedUp = 0;

                user.lastInteraction = block.timestamp;

                user.nextHarvestUntil = block.timestamp.add(

                    pool.harvestInterval

                );



                // send rewards

                safeSolarTransfer(_msgSender(), totalRewards);

            }

        } else if (pending > 0) {

            user.rewardLockedUp = user.rewardLockedUp.add(pending);

            user.lastInteraction = block.timestamp;

            totalLockedUpRewards = totalLockedUpRewards.add(pending);

            emit RewardLockedUp(_msgSender(), _pid, pending);

        }

    }



    // Safe Solar transfer function, just in case if rounding error causes pool do not have enough Solar.

    function safeSolarTransfer(address _to, uint256 _amount) internal {

        if (solar.balanceOf(address(this)) > totalSolarInPools) {

            //SolarBal = total Solar in SolarVault - total Solar in Solar pools, this will make sure that SolarVault never transfer rewards from deposited Solar pools

            uint256 SolarBal = solar.balanceOf(address(this)).sub(

                totalSolarInPools

            );

            if (_amount >= SolarBal) {

                solar.transfer(_to, SolarBal);

            } else if (_amount > 0) {

                solar.transfer(_to, _amount);

            }

        }

    }



    // Update dev address by the previous dev.

    function setDevAddress(address _devAddress) public {

        require(_msgSender() == devAddress, "setDevAddress: FORBIDDEN");

        require(_devAddress != address(0), "setDevAddress: ZERO");



        emit DevAddressChanged(_msgSender(), devAddress, _devAddress);



        devAddress = _devAddress;

    }



    function setFeeAddress(address _feeAddress) public {

        require(_msgSender() == feeAddress, "setFeeAddress: FORBIDDEN");

        require(_feeAddress != address(0), "setFeeAddress: ZERO");



        emit FeeAddressChanged(_msgSender(), feeAddress, _feeAddress);



        feeAddress = _feeAddress;

    }



    // Pancake has to add hidden dummy pools in order to alter the emission, here we make it simple and transparent to all.

    function updateEmissionRate(uint256 _solarPerBlock) public onlyOperator {

        massUpdatePools();



        emit EmissionRateUpdated(msg.sender, solarPerBlock, _solarPerBlock);

        solarPerBlock = _solarPerBlock;

    }



    function updateAllocPoint(

        uint256 _pid,

        uint256 _allocPoint,

        bool _withUpdate

    ) public onlyOperator {

        if (_withUpdate) {

            massUpdatePools();

        }



        emit AllocPointsUpdated(

            _msgSender(),

            poolInfo[_pid].allocPoint,

            _allocPoint

        );



        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(

            _allocPoint

        );

        poolInfo[_pid].allocPoint = _allocPoint;

    }



    // Enable support for meta transactions

    function enableMetaTxns() public onlyOperator {

        require(

            !metaTxnsEnabled,

            "SolarVault: meta transactions are already enabled"

        );



        metaTxnsEnabled = true;

        emit MetaTxnsEnabled(_msgSender());

    }



    // Disable support for meta transactions

    function disableMetaTxns() public onlyOperator {

        require(

            metaTxnsEnabled,

            "SolarVault: meta transactions are already disabled"

        );



        metaTxnsEnabled = false;

        emit MetaTxnsDisabled(_msgSender());

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\Timelock.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity =0.8.2;



import "@openzeppelin/contracts/utils/math/SafeMath.sol";



contract Timelock {

    using SafeMath for uint256;



    event NewAdmin(address indexed newAdmin);

    event NewPendingAdmin(address indexed newPendingAdmin);

    event NewDelay(uint256 indexed newDelay);

    event CancelTransaction(

        bytes32 indexed txHash,

        address indexed target,

        uint256 value,

        string signature,

        bytes data,

        uint256 eta

    );

    event ExecuteTransaction(

        bytes32 indexed txHash,

        address indexed target,

        uint256 value,

        string signature,

        bytes data,

        uint256 eta

    );

    event QueueTransaction(

        bytes32 indexed txHash,

        address indexed target,

        uint256 value,

        string signature,

        bytes data,

        uint256 eta

    );



    uint256 public constant GRACE_PERIOD = 14 days;

    uint256 public constant MINIMUM_DELAY = 6 hours;

    uint256 public constant MAXIMUM_DELAY = 30 days;



    address public admin;

    address public pendingAdmin;

    uint256 public delay;

    bool public admin_initialized;



    mapping(bytes32 => bool) public queuedTransactions;



    constructor(address admin_, uint256 delay_) {

        require(

            delay_ >= MINIMUM_DELAY,

            "Timelock::constructor: Delay must exceed minimum delay."

        );

        require(

            delay_ <= MAXIMUM_DELAY,

            "Timelock::constructor: Delay must not exceed maximum delay."

        );



        admin = admin_;

        delay = delay_;

        admin_initialized = false;

    }



    // XXX: function() external payable { }

    receive() external payable {}



    function setDelay(uint256 delay_) public {

        require(

            msg.sender == address(this),

            "Timelock::setDelay: Call must come from Timelock."

        );

        require(

            delay_ >= MINIMUM_DELAY,

            "Timelock::setDelay: Delay must exceed minimum delay."

        );

        require(

            delay_ <= MAXIMUM_DELAY,

            "Timelock::setDelay: Delay must not exceed maximum delay."

        );

        delay = delay_;



        emit NewDelay(delay);

    }



    function acceptAdmin() public {

        require(

            msg.sender == pendingAdmin,

            "Timelock::acceptAdmin: Call must come from pendingAdmin."

        );

        admin = msg.sender;

        pendingAdmin = address(0);



        emit NewAdmin(admin);

    }



    function setPendingAdmin(address pendingAdmin_) public {

        // allows one time setting of admin for deployment purposes

        if (admin_initialized) {

            require(

                msg.sender == address(this),

                "Timelock::setPendingAdmin: Call must come from Timelock."

            );

        } else {

            require(

                msg.sender == admin,

                "Timelock::setPendingAdmin: First call must come from admin."

            );

            admin_initialized = true;

        }

        pendingAdmin = pendingAdmin_;



        emit NewPendingAdmin(pendingAdmin);

    }



    function queueTransaction(

        address target,

        uint256 value,

        string memory signature,

        bytes memory data,

        uint256 eta

    ) public returns (bytes32) {

        require(

            msg.sender == admin,

            "Timelock::queueTransaction: Call must come from admin."

        );

        require(

            eta >= getBlockTimestamp().add(delay),

            "Timelock::queueTransaction: Estimated execution block must satisfy delay."

        );



        bytes32 txHash = keccak256(

            abi.encode(target, value, signature, data, eta)

        );

        queuedTransactions[txHash] = true;



        emit QueueTransaction(txHash, target, value, signature, data, eta);

        return txHash;

    }



    function cancelTransaction(

        address target,

        uint256 value,

        string memory signature,

        bytes memory data,

        uint256 eta

    ) public {

        require(

            msg.sender == admin,

            "Timelock::cancelTransaction: Call must come from admin."

        );



        bytes32 txHash = keccak256(

            abi.encode(target, value, signature, data, eta)

        );

        queuedTransactions[txHash] = false;



        emit CancelTransaction(txHash, target, value, signature, data, eta);

    }



    function executeTransaction(

        address target,

        uint256 value,

        string memory signature,

        bytes memory data,

        uint256 eta

    ) public payable returns (bytes memory) {

        require(

            msg.sender == admin,

            "Timelock::executeTransaction: Call must come from admin."

        );



        bytes32 txHash = keccak256(

            abi.encode(target, value, signature, data, eta)

        );

        require(

            queuedTransactions[txHash],

            "Timelock::executeTransaction: Transaction hasn't been queued."

        );

        require(

            getBlockTimestamp() >= eta,

            "Timelock::executeTransaction: Transaction hasn't surpassed time lock."

        );

        require(

            getBlockTimestamp() <= eta.add(GRACE_PERIOD),

            "Timelock::executeTransaction: Transaction is stale."

        );



        queuedTransactions[txHash] = false;



        bytes memory callData;



        if (bytes(signature).length == 0) {

            callData = data;

        } else {

            callData = abi.encodePacked(

                bytes4(keccak256(bytes(signature))),

                data

            );

        }



        // solium-disable-next-line security/no-call-value

        (bool success, bytes memory returnData) = target.call{value: value}(

            callData

        );

        require(

            success,

            "Timelock::executeTransaction: Transaction execution reverted."

        );



        emit ExecuteTransaction(txHash, target, value, signature, data, eta);



        return returnData;

    }



    function getBlockTimestamp() internal view returns (uint256) {

        // solium-disable-next-line security/no-block-members

        return block.timestamp;

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\TokenFarm.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;



import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "../libraries/IBoringERC20.sol";

import "../libraries/BoringERC20.sol";



contract TokenFarm is Ownable, ReentrancyGuard {

    using BoringERC20 for IBoringERC20;



    // Info of each user for each farm.

    struct UserInfo {

        uint256 amount; // How many Staking tokens the user has provided.

        uint256 rewardDebt; // Reward debt. See explanation below.

    }



    // Info of each reward distribution campaign.

    struct CampaignInfo {

        IBoringERC20 stakingToken; // Address of Staking token contract.

        IBoringERC20 rewardToken; // Address of Reward token contract

        uint256 precision; //reward token precision

        uint256 startTimestamp; // start timestamp of the campaign

        uint256 lastRewardTimestamp; // Last timestamp that Reward Token distribution occurs.

        uint256 accRewardPerShare; // Accumulated Reward Token per share. See below.

        uint256 totalStaked; // total staked amount each campaign's stake token, typically, each campaign has the same stake token, so need to track it separatedly

        uint256 totalRewards;

    }



    // Reward info

    struct RewardInfo {

        uint256 endTimestamp;

        uint256 rewardPerSec;

    }



    // @dev this is mostly used for extending reward period

    // @notice Reward info is a set of {endTimestamp, rewardPerTimestamp}

    // indexed by campaigh ID

    mapping(uint256 => RewardInfo[]) public campaignRewardInfo;



    // @notice Info of each campaign. mapped from campaigh ID

    CampaignInfo[] public campaignInfo;

    // Info of each user that stakes Staking tokens.

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    // @notice limit length of reward info

    // how many phases are allowed

    uint256 public rewardInfoLimit;

    // @dev reward holder account

    address public rewardHolder;



    event Deposit(address indexed user, uint256 amount, uint256 campaign);

    event Withdraw(address indexed user, uint256 amount, uint256 campaign);

    event EmergencyWithdraw(

        address indexed user,

        uint256 amount,

        uint256 campaign

    );

    event AddCampaignInfo(

        uint256 indexed campaignID,

        IBoringERC20 stakingToken,

        IBoringERC20 rewardToken,

        uint256 startTimestamp

    );

    event AddRewardInfo(

        uint256 indexed campaignID,

        uint256 indexed phase,

        uint256 endTimestamp,

        uint256 rewardPerTimestamp

    );

    event SetRewardInfoLimit(uint256 rewardInfoLimit);

    event SetRewardHolder(address rewardHolder);



    // constructor

    constructor(address _rewardHolder) {

        rewardInfoLimit = 53;

        rewardHolder = _rewardHolder;

    }



    // @notice function for setting a reward holder who is responsible for adding a reward info

    function setRewardHolder(address _rewardHolder) external onlyOwner {

        rewardHolder = _rewardHolder;

        emit SetRewardHolder(_rewardHolder);

    }



    // @notice set new reward info limit

    function setRewardInfoLimit(uint256 _updatedRewardInfoLimit)

        external

        onlyOwner

    {

        rewardInfoLimit = _updatedRewardInfoLimit;

        emit SetRewardInfoLimit(rewardInfoLimit);

    }



    // @notice reward campaign, one campaign represents a pair of staking and reward token, last reward Timestamp and acc reward Per Share

    function addCampaignInfo(

        IBoringERC20 _stakingToken,

        IBoringERC20 _rewardToken,

        uint256 _startTimestamp

    ) external onlyOwner {

        uint256 decimalsRewardToken = uint256(_rewardToken.safeDecimals());



        require(

            decimalsRewardToken < 30,

            "constructor: reward token decimals must be inferior to 30"

        );



        uint256 precision = uint256(10**(uint256(30) - (decimalsRewardToken)));



        campaignInfo.push(

            CampaignInfo({

                stakingToken: _stakingToken,

                rewardToken: _rewardToken,

                precision: precision,

                startTimestamp: _startTimestamp,

                lastRewardTimestamp: _startTimestamp,

                accRewardPerShare: 0,

                totalStaked: 0,

                totalRewards: 0

            })

        );

        emit AddCampaignInfo(

            campaignInfo.length - 1,

            _stakingToken,

            _rewardToken,

            _startTimestamp

        );

    }



    // @notice if the new reward info is added, the reward & its end timestamp will be extended by the newly pushed reward info.

    function addRewardInfo(

        uint256 _campaignID,

        uint256 _endTimestamp,

        uint256 _rewardPerSec

    ) external onlyOwner {

        RewardInfo[] storage rewardInfo = campaignRewardInfo[_campaignID];

        CampaignInfo storage campaign = campaignInfo[_campaignID];

        require(

            rewardInfo.length < rewardInfoLimit,

            "addRewardInfo::reward info length exceeds the limit"

        );

        require(

            rewardInfo.length == 0 ||

                rewardInfo[rewardInfo.length - 1].endTimestamp >=

                block.timestamp,

            "addRewardInfo::reward period ended"

        );

        require(

            rewardInfo.length == 0 ||

                rewardInfo[rewardInfo.length - 1].endTimestamp < _endTimestamp,

            "addRewardInfo::bad new endTimestamp"

        );

        uint256 startTimestamp = rewardInfo.length == 0

            ? campaign.startTimestamp

            : rewardInfo[rewardInfo.length - 1].endTimestamp;

        uint256 timeRange = _endTimestamp - startTimestamp;

        uint256 totalRewards = _rewardPerSec * timeRange;

        campaign.rewardToken.safeTransferFrom(

            rewardHolder,

            address(this),

            totalRewards

        );

        campaign.totalRewards += totalRewards;

        rewardInfo.push(

            RewardInfo({

                endTimestamp: _endTimestamp,

                rewardPerSec: _rewardPerSec

            })

        );

        emit AddRewardInfo(

            _campaignID,

            rewardInfo.length - 1,

            _endTimestamp,

            _rewardPerSec

        );

    }



    function rewardInfoLen(uint256 _campaignID)

        external

        view

        returns (uint256)

    {

        return campaignRewardInfo[_campaignID].length;

    }



    function campaignInfoLen() external view returns (uint256) {

        return campaignInfo.length;

    }



    // @notice this will return  end block based on the current block timestamp.

    function currentEndTimestamp(uint256 _campaignID)

        external

        view

        returns (uint256)

    {

        return _endTimestampOf(_campaignID, block.timestamp);

    }



    function _endTimestampOf(uint256 _campaignID, uint256 _blockTimestamp)

        internal

        view

        returns (uint256)

    {

        RewardInfo[] memory rewardInfo = campaignRewardInfo[_campaignID];

        uint256 len = rewardInfo.length;

        if (len == 0) {

            return 0;

        }

        for (uint256 i = 0; i < len; ++i) {

            if (_blockTimestamp <= rewardInfo[i].endTimestamp)

                return rewardInfo[i].endTimestamp;

        }

        // @dev when couldn't find any reward info, it means that _blockTimestamp exceed endTimestamp

        // so return the latest reward info.

        return rewardInfo[len - 1].endTimestamp;

    }



    // @notice this will return reward per block based on the current block timestamp.

    function currentRewardPerSec(uint256 _campaignID)

        external

        view

        returns (uint256)

    {

        return _rewardPerSecOf(_campaignID, block.timestamp);

    }



    function _rewardPerSecOf(uint256 _campaignID, uint256 _blockTimestamp)

        internal

        view

        returns (uint256)

    {

        RewardInfo[] memory rewardInfo = campaignRewardInfo[_campaignID];

        uint256 len = rewardInfo.length;

        if (len == 0) {

            return 0;

        }

        for (uint256 i = 0; i < len; ++i) {

            if (_blockTimestamp <= rewardInfo[i].endTimestamp)

                return rewardInfo[i].rewardPerSec;

        }

        // @dev when couldn't find any reward info, it means that timestamp exceed endtimestamp

        // so return 0

        return 0;

    }



    // @notice Return reward multiplier over the given _from to _to timestamp.

    function getMultiplier(

        uint256 _from,

        uint256 _to,

        uint256 _endTimestamp

    ) public pure returns (uint256) {

        if ((_from >= _endTimestamp) || (_from > _to)) {

            return 0;

        }

        if (_to <= _endTimestamp) {

            return _to - _from;

        }

        return _endTimestamp - _from;

    }



    // @notice View function to see pending Reward on frontend.

    function pendingReward(uint256 _campaignID, address _user)

        external

        view

        returns (uint256)

    {

        return

            _pendingReward(

                _campaignID,

                userInfo[_campaignID][_user].amount,

                userInfo[_campaignID][_user].rewardDebt

            );

    }



    function _pendingReward(

        uint256 _campaignID,

        uint256 _amount,

        uint256 _rewardDebt

    ) internal view returns (uint256) {

        CampaignInfo memory campaign = campaignInfo[_campaignID];

        RewardInfo[] memory rewardInfo = campaignRewardInfo[_campaignID];

        uint256 accRewardPerShare = campaign.accRewardPerShare;

        if (

            block.timestamp > campaign.lastRewardTimestamp &&

            campaign.totalStaked != 0

        ) {

            uint256 cursor = campaign.lastRewardTimestamp;

            for (uint256 i = 0; i < rewardInfo.length; ++i) {

                uint256 multiplier = getMultiplier(

                    cursor,

                    block.timestamp,

                    rewardInfo[i].endTimestamp

                );

                if (multiplier == 0) continue;

                cursor = rewardInfo[i].endTimestamp;

                accRewardPerShare +=

                    ((multiplier * rewardInfo[i].rewardPerSec) *

                        campaign.precision) /

                    campaign.totalStaked;

            }

        }

        return

            ((_amount * accRewardPerShare) / campaign.precision) - _rewardDebt;

    }



    function updateCampaign(uint256 _campaignID) external nonReentrant {

        _updateCampaign(_campaignID);

    }



    // @notice Update reward variables of the given campaign to be up-to-date.

    function _updateCampaign(uint256 _campaignID) internal {

        CampaignInfo storage campaign = campaignInfo[_campaignID];

        RewardInfo[] memory rewardInfo = campaignRewardInfo[_campaignID];

        if (block.timestamp <= campaign.lastRewardTimestamp) {

            return;

        }

        if (campaign.totalStaked == 0) {

            // if there is no total supply, return and use the campaign's start block timestamp as the last reward block timestamp

            // so that ALL reward will be distributed.

            // however, if the first deposit is out of reward period, last reward block will be its block timestamp

            // in order to keep the multiplier = 0

            if (

                block.timestamp > _endTimestampOf(_campaignID, block.timestamp)

            ) {

                campaign.lastRewardTimestamp = block.timestamp;

            }

            return;

        }

        // @dev for each reward info

        for (uint256 i = 0; i < rewardInfo.length; ++i) {

            // @dev get multiplier based on current Block and rewardInfo's end block

            // multiplier will be a range of either (current block - campaign.lastRewardBlock)

            // or (reward info's endblock - campaign.lastRewardTimestamp) or 0

            uint256 multiplier = getMultiplier(

                campaign.lastRewardTimestamp,

                block.timestamp,

                rewardInfo[i].endTimestamp

            );

            if (multiplier == 0) continue;

            // @dev if currentTimestamp exceed end block, use end block as the last reward block

            // so that for the next iteration, previous endTimestamp will be used as the last reward block

            if (block.timestamp > rewardInfo[i].endTimestamp) {

                campaign.lastRewardTimestamp = rewardInfo[i].endTimestamp;

            } else {

                campaign.lastRewardTimestamp = block.timestamp;

            }

            campaign.accRewardPerShare +=

                ((multiplier * rewardInfo[i].rewardPerSec) *

                    campaign.precision) /

                campaign.totalStaked;

        }

    }



    // @notice Update reward variables for all campaigns. gas spending is HIGH in this method call, BE CAREFUL

    function massUpdateCampaigns() external nonReentrant {

        uint256 length = campaignInfo.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            _updateCampaign(pid);

        }

    }



    function depositWithPermit(

        uint256 _campaignID,

        uint256 _amount,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external nonReentrant {

        CampaignInfo storage campaign = campaignInfo[_campaignID];

        campaign.stakingToken.permit(

            msg.sender,

            address(this),

            _amount,

            deadline,

            v,

            r,

            s

        );

        _deposit(_campaignID, _amount);

    }



    // @notice Stake Staking tokens to TokenFarm

    function deposit(uint256 _campaignID, uint256 _amount)

        external

        nonReentrant

    {

        _deposit(_campaignID, _amount);

    }



    // @notice Stake Staking tokens to TokenFarm

    function _deposit(uint256 _campaignID, uint256 _amount) internal {

        CampaignInfo storage campaign = campaignInfo[_campaignID];

        UserInfo storage user = userInfo[_campaignID][msg.sender];

        _updateCampaign(_campaignID);

        if (user.amount > 0) {

            uint256 pending = ((user.amount * campaign.accRewardPerShare) /

                campaign.precision) - user.rewardDebt;

            if (pending > 0) {

                campaign.rewardToken.safeTransfer(address(msg.sender), pending);

            }

        }

        if (_amount > 0) {

            campaign.stakingToken.safeTransferFrom(

                address(msg.sender),

                address(this),

                _amount

            );

            user.amount += _amount;

            campaign.totalStaked += _amount;

        }

        user.rewardDebt =

            (user.amount * campaign.accRewardPerShare) /

            campaign.precision;

        emit Deposit(msg.sender, _amount, _campaignID);

    }



    // @notice Withdraw Staking tokens from STAKING.

    function withdraw(uint256 _campaignID, uint256 _amount)

        external

        nonReentrant

    {

        _withdraw(_campaignID, _amount);

    }



    // @notice internal method for withdraw (withdraw and harvest method depend on this method)

    function _withdraw(uint256 _campaignID, uint256 _amount) internal {

        CampaignInfo storage campaign = campaignInfo[_campaignID];

        UserInfo storage user = userInfo[_campaignID][msg.sender];

        require(user.amount >= _amount, "withdraw::bad withdraw amount");

        _updateCampaign(_campaignID);

        uint256 pending = ((user.amount * campaign.accRewardPerShare) /

            campaign.precision) - user.rewardDebt;

        if (pending > 0) {

            campaign.rewardToken.safeTransfer(address(msg.sender), pending);

        }

        if (_amount > 0) {

            user.amount -= _amount;

            campaign.stakingToken.safeTransfer(address(msg.sender), _amount);

            campaign.totalStaked -= _amount;

        }

        user.rewardDebt =

            (user.amount * campaign.accRewardPerShare) /

            campaign.precision;



        emit Withdraw(msg.sender, _amount, _campaignID);

    }



    // @notice method for harvest campaigns (used when the user want to claim their reward token based on specified campaigns)

    function harvest(uint256[] calldata _campaignIDs) external nonReentrant {

        for (uint256 i = 0; i < _campaignIDs.length; ++i) {

            _withdraw(_campaignIDs[i], 0);

        }

    }



    // @notice Withdraw without caring about rewards. EMERGENCY ONLY.

    function emergencyWithdraw(uint256 _campaignID) external nonReentrant {

        CampaignInfo storage campaign = campaignInfo[_campaignID];

        UserInfo storage user = userInfo[_campaignID][msg.sender];

        uint256 _amount = user.amount;

        campaign.totalStaked -= _amount;

        user.amount = 0;

        user.rewardDebt = 0;

        campaign.stakingToken.safeTransfer(address(msg.sender), _amount);

        emit EmergencyWithdraw(msg.sender, _amount, _campaignID);

    }



    // @notice Withdraw reward. EMERGENCY ONLY.

    function emergencyRewardWithdraw(

        uint256 _campaignID,

        uint256 _amount,

        address _beneficiary

    ) external onlyOwner nonReentrant {

        CampaignInfo storage campaign = campaignInfo[_campaignID];

        uint256 currentStakingPendingReward = _pendingReward(

            _campaignID,

            campaign.totalStaked,

            0

        );

        require(

            currentStakingPendingReward + _amount <= campaign.totalRewards,

            "emergencyRewardWithdraw::not enough reward token"

        );

        campaign.totalRewards -= _amount;

        campaign.rewardToken.safeTransfer(_beneficiary, _amount);

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\TransferHelper.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false

library TransferHelper {

    function safeApprove(

        address token,

        address to,

        uint256 value

    ) internal {

        // bytes4(keccak256(bytes('approve(address,uint256)')));

        (bool success, bytes memory data) = token.call(

            abi.encodeWithSelector(0x095ea7b3, to, value)

        );

        require(

            success && (data.length == 0 || abi.decode(data, (bool))),

            "TransferHelper: APPROVE_FAILED"

        );

    }



    function safeTransfer(

        address token,

        address to,

        uint256 value

    ) internal {

        // bytes4(keccak256(bytes('transfer(address,uint256)')));

        (bool success, bytes memory data) = token.call(

            abi.encodeWithSelector(0xa9059cbb, to, value)

        );

        require(

            success && (data.length == 0 || abi.decode(data, (bool))),

            "TransferHelper: TRANSFER_FAILED"

        );

    }



    function safeTransferFrom(

        address token,

        address from,

        address to,

        uint256 value

    ) internal {

        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));

        (bool success, bytes memory data) = token.call(

            abi.encodeWithSelector(0x23b872dd, from, to, value)

        );

        require(

            success && (data.length == 0 || abi.decode(data, (bool))),

            "TransferHelper: TRANSFER_FROM_FAILED"

        );

    }



    function safeTransferETH(address to, uint256 value) internal {

        (bool success, ) = to.call{value: value}(new bytes(0));

        require(success, "TransferHelper: ETH_TRANSFER_FAILED");

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\UQ112x112.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.6.12;



// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))



// range: [0, 2**112 - 1]

// resolution: 1 / 2**112



library UQ112x112 {

    uint224 constant Q112 = 2**112;



    // encode a uint112 as a UQ112x112

    function encode(uint112 y) internal pure returns (uint224 z) {

        z = uint224(y) * Q112; // never overflows

    }



    // divide a UQ112x112 by a uint112, returning a UQ112x112

    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {

        z = x / uint224(y);

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\SolarBeam Bridge\contracts\VestedSolarBeamToken.sol
File type: .sol
// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.7;



import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";

import "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "../libraries/IBoringERC20.sol";

import "../libraries/BoringERC20.sol";



interface IVestedSolarBeamToken {

    function userLockedAmount(address _addr) external view returns (uint256);



    function userLockedUntil(address _addr) external view returns (uint256);



    function votingPowerUnlockTime(uint256 _value, uint256 _unlock_time)

        external

        view

        returns (uint256);



    function votingPowerLockedDays(uint256 _value, uint256 _days)

        external

        view

        returns (uint256);



    function deposit(address _addr, uint256 _value) external;



    function create(uint256 _value, uint256 _days) external;



    function increaseAmount(uint256 _value) external;



    function increaseLock(uint256 _days) external;



    function withdraw() external;

}



contract VestedSolarBeamToken is

    ERC20Burnable,

    ERC20Permit,

    IVestedSolarBeamToken,

    Ownable,

    ReentrancyGuard

{

    using BoringERC20 for IBoringERC20;



    uint256 public constant MINDAYS = 7;

    uint256 public constant MAXDAYS = 4 * 365;



    uint256 public constant MAXTIME = MAXDAYS * 1 days; // 4 years

    uint256 public constant MAX_WITHDRAWAL_PENALTY = 90000; // 90%

    uint256 public constant PRECISION = 1e5; // 5 decimals



    address public immutable lockedToken;

    address public penaltyCollector;

    uint256 public minLockedAmount;

    uint256 public earlyWithdrawPenaltyRate;



    // flags

    uint256 private _unlocked;



    struct LockedBalance {

        uint256 amount;

        uint256 end;

    }



    mapping(address => LockedBalance) public locked;

    mapping(address => uint256) public mintedForLock;



    /* ========== MODIFIERS ========== */



    modifier lock() {

        require(_unlocked == 1, "LOCKED");

        _unlocked = 0;

        _;

        _unlocked = 1;

    }



    /* =============== EVENTS ==================== */

    event Deposit(address indexed provider, uint256 value, uint256 locktime);

    event Withdraw(address indexed provider, uint256 value);

    event PenaltyCollectorSet(address indexed addr);

    event EarlyWithdrawPenaltySet(uint256 indexed penalty);

    event MinLockedAmountSet(uint256 indexed amount);



    constructor(

        string memory _tokenName,

        string memory _tokenSymbol,

        address _lockedToken,

        uint256 _minLockedAmount

    ) ERC20(_tokenName, _tokenSymbol) ERC20Permit(_tokenName) {

        lockedToken = _lockedToken;

        minLockedAmount = _minLockedAmount;

        earlyWithdrawPenaltyRate = 75000; // 75%

        penaltyCollector = 0x000000000000000000000000000000000000dEaD;

        _unlocked = 1;

    }



    /* ========== PUBLIC FUNCTIONS ========== */

    function userLockedAmount(address _addr)

        external

        view

        override

        returns (uint256)

    {

        return locked[_addr].amount;

    }



    function userLockedUntil(address _addr)

        external

        view

        override

        returns (uint256)

    {

        return locked[_addr].end;

    }



    function votingPowerUnlockTime(uint256 _value, uint256 _unlockTime)

        public

        view

        override

        returns (uint256)

    {

        uint256 _now = block.timestamp;

        if (_unlockTime <= _now) return 0;

        uint256 _lockedSeconds = _unlockTime - _now;

        if (_lockedSeconds >= MAXTIME) {

            return _value;

        }

        return (_value * _lockedSeconds) / MAXTIME;

    }



    function votingPowerLockedDays(uint256 _value, uint256 _days)

        public

        pure

        override

        returns (uint256)

    {

        if (_days >= MAXDAYS) {

            return _value;

        }

        return (_value * _days) / MAXDAYS;

    }



    function deposit(address _addr, uint256 _value)

        external

        override

        nonReentrant

    {

        require(_value > 0, "deposit: invalid amount");

        require(locked[_addr].amount > 0, "deposit: no lock for this address");

        _deposit(_addr, _value, 0);

    }



    function createWithPermit(

        uint256 _value,

        uint256 _days,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external nonReentrant {

        require(_value >= minLockedAmount, "create: less than min amount");

        require(

            locked[_msgSender()].amount == 0,

            "create: withdraw old tokens first"

        );

        require(_days >= MINDAYS, "create: less than min amount of 7 days");

        require(_days <= MAXDAYS, "create: voting lock can be 4 years max");



        IBoringERC20(lockedToken).permit(

            _msgSender(),

            address(this),

            _value,

            deadline,

            v,

            r,

            s

        );



        _deposit(_msgSender(), _value, _days);

    }



    function create(uint256 _value, uint256 _days)

        external

        override

        nonReentrant

    {

        require(_value >= minLockedAmount, "create: less than min amount");

        require(

            locked[_msgSender()].amount == 0,

            "create: withdraw old tokens first"

        );

        require(_days >= MINDAYS, "create: less than min amount of 7 days");

        require(_days <= MAXDAYS, "create: voting lock can be 4 years max");

        _deposit(_msgSender(), _value, _days);

    }



    function increaseAmountWithPermit(

        uint256 _value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external nonReentrant {

        require(_value > 0, "increaseAmount: invalid amount");



        IBoringERC20(lockedToken).permit(

            _msgSender(),

            address(this),

            _value,

            deadline,

            v,

            r,

            s

        );



        _deposit(_msgSender(), _value, 0);

    }



    function increaseAmount(uint256 _value) external override nonReentrant {

        require(_value > 0, "increaseAmount: invalid amount");

        _deposit(_msgSender(), _value, 0);

    }



    function increaseLock(uint256 _days) external override nonReentrant {

        require(_days > 0, "increaseLock: invalid amount");

        require(

            _days <= MAXDAYS,

            "increaseLock: voting lock can be 4 years max"

        );

        _deposit(_msgSender(), 0, _days);

    }



    function withdraw() external override lock {

        LockedBalance storage _locked = locked[_msgSender()];

        uint256 _now = block.timestamp;

        require(_locked.amount > 0, "withdraw: nothing to withdraw");

        require(_now >= _locked.end, "withdraw: user still locked");

        uint256 _amount = _locked.amount;

        _locked.end = 0;

        _locked.amount = 0;

        _burn(_msgSender(), mintedForLock[_msgSender()]);

        mintedForLock[_msgSender()] = 0;

        IBoringERC20(lockedToken).safeTransfer(_msgSender(), _amount);



        emit Withdraw(_msgSender(), _amount);

    }



    // This will charge PENALTY if lock is not expired yet

    function emergencyWithdraw() external lock {

        LockedBalance storage _locked = locked[_msgSender()];

        uint256 _now = block.timestamp;

        require(_locked.amount > 0, "emergencyWithdraw: nothing to withdraw");

        uint256 _amount = _locked.amount;

        if (_now < _locked.end) {

            uint256 _fee = (_amount * earlyWithdrawPenaltyRate) / PRECISION;

            _penalize(_fee);

            _amount = _amount - _fee;

        }

        _locked.end = 0;

        _locked.amount = 0;

        _burn(_msgSender(), mintedForLock[_msgSender()]);

        mintedForLock[_msgSender()] = 0;



        IBoringERC20(lockedToken).safeTransfer(_msgSender(), _amount);



        emit Withdraw(_msgSender(), _amount);

    }



    /* ========== INTERNAL FUNCTIONS ========== */

    function _deposit(

        address _addr,

        uint256 _value,

        uint256 _days

    ) internal lock {

        LockedBalance storage _locked = locked[_addr];

        uint256 _now = block.timestamp;

        uint256 _amount = _locked.amount;

        uint256 _end = _locked.end;

        uint256 _vp;

        if (_amount == 0) {

            _vp = votingPowerLockedDays(_value, _days);

            _locked.amount = _value;

            _locked.end = _now + _days * 1 days;

        } else if (_days == 0) {

            _vp = votingPowerUnlockTime(_value, _end);

            _locked.amount = _amount + _value;

        } else {

            require(

                _value == 0,

                "_deposit: cannot increase amount and extend lock in the same time"

            );

            _vp = votingPowerLockedDays(_amount, _days);

            _locked.end = _end + _days * 1 days;

            require(

                _locked.end - _now <= MAXTIME,

                "_deposit: cannot extend lock to more than 4 years"

            );

        }

        require(_vp > 0, "No benefit to lock");

        if (_value > 0) {

            IBoringERC20(lockedToken).safeTransferFrom(

                _msgSender(),

                address(this),

                _value

            );

        }

        _mint(_addr, _vp);

        mintedForLock[_addr] += _vp;



        emit Deposit(_addr, _locked.amount, _locked.end);

    }



    function _penalize(uint256 _amount) internal {

        IBoringERC20(lockedToken).safeTransfer(penaltyCollector, _amount);

    }



    /* ========== RESTRICTED FUNCTIONS ========== */

    function setMinLockedAmount(uint256 _minLockedAmount) external onlyOwner {

        minLockedAmount = _minLockedAmount;

        emit MinLockedAmountSet(_minLockedAmount);

    }



    function setEarlyWithdrawPenaltyRate(uint256 _earlyWithdrawPenaltyRate)

        external

        onlyOwner

    {

        require(

            _earlyWithdrawPenaltyRate <= MAX_WITHDRAWAL_PENALTY,

            "setEarlyWithdrawPenaltyRate: withdrawal penalty is too high"

        ); // <= 90%

        earlyWithdrawPenaltyRate = _earlyWithdrawPenaltyRate;

        emit EarlyWithdrawPenaltySet(_earlyWithdrawPenaltyRate);

    }



    function setPenaltyCollector(address _addr) external onlyOwner {

        require(

            penaltyCollector != address(0),

            "setPenaltyCollector: set a valid address"

        );

        penaltyCollector = _addr;

        emit PenaltyCollectorSet(_addr);

    }

}



--------------------------------------------------
File End
--------------------------------------------------

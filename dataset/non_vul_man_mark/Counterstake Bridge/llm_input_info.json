{
    "src_chain": {
        "NewExpatriation1": [
            {
                "transferToForeignChain": "function transferToForeignChain(\n string memory foreign_address,\n string memory data,\n uint amount,\n int reward\n ) external payable nonReentrant {\n function receiveStakeAsset(...) {...}\nreceiveStakeAsset(amount);\n if (reward >= 0) require(uint(reward) < amount, \"reward too big\");\n emit NewExpatriation(msg.sender, amount, reward, foreign_address, data);\n }"
            },
            {
                "receiveStakeAsset": "function receiveStakeAsset(uint stake_asset_amount) internal {\n if (settings.tokenAddress == address(0))\n require(msg.value == stake_asset_amount, \"wrong amount received\");\n else {\n require(msg.value == 0, \"don't send ETH\");\n IERC20(settings.tokenAddress).safeTransferFrom(\n msg.sender,\n address(this),\n stake_asset_amount\n );\n }\n }"
            }
        ],
        "NewExpatriation2": [
            {
                "claim": "function claim(\n Settings storage settings,\n mapping(string => uint) storage claim_nums,\n mapping(uint => Claim) storage claims,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n ClaimRequest memory req\n ) external {\n require(req.amount > 0, \"0 claim\");\n require(req.stake >= req.required_stake, \"the stake is too small\");\n require(block.timestamp >= req.txts + settings.min_tx_age, \"too early\");\n if (req.recipient_address == address(0))\n req.recipient_address = payable(msg.sender);\n if (req.reward < 0)\n require(\n req.recipient_address == payable(msg.sender),\n \"the sender disallowed third-party claiming by setting a negative reward\"\n );\n string memory claim_id = getClaimId(\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.data\n );\n require(\n claim_nums[claim_id] == 0,\n \"this transfer has already been claimed\"\n );\n bool is_large = (settings.large_threshold > 0 &&\n req.stake >= settings.large_threshold);\n uint32 expiry_ts = uint32(\n block.timestamp + getChallengingPeriod(settings, 0, is_large)\n ); \n claim_nums[claim_id] = claim_num;\n \n claims[claim_num] = Claim({\n amount: req.amount,\n \n recipient_address: req.recipient_address,\n claimant_address: payable(msg.sender),\n sender_address: req.sender_address,\n \n data: req.data,\n yes_stake: req.stake,\n no_stake: 0,\n current_outcome: Side.yes,\n is_large: is_large,\n period_number: 0,\n txts: req.txts,\n ts: uint32(block.timestamp),\n expiry_ts: expiry_ts,\n \n withdrawn: false,\n finished: false\n });\n stakes[claim_num][Side.yes][msg.sender] = req.stake;\n emit NewClaim(\n claim_num,\n msg.sender,\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.stake,\n req.data,\n expiry_ts\n );\n \n }"
            }
        ]
    },
    "rel_chain": {
        "NewClaim": [
            {
                "claim": "function claim(\n Settings storage settings,\n mapping(string => uint) storage claim_nums,\n mapping(uint => Claim) storage claims,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n ClaimRequest memory req\n ) external {\n require(req.amount > 0, \"0 claim\");\n require(req.stake >= req.required_stake, \"the stake is too small\");\n require(block.timestamp >= req.txts + settings.min_tx_age, \"too early\");\n if (req.recipient_address == address(0))\n req.recipient_address = payable(msg.sender);\n if (req.reward < 0)\n require(\n req.recipient_address == payable(msg.sender),\n \"the sender disallowed third-party claiming by setting a negative reward\"\n );\n string memory claim_id = getClaimId(\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.data\n );\n require(\n claim_nums[claim_id] == 0,\n \"this transfer has already been claimed\"\n );\n bool is_large = (settings.large_threshold > 0 &&\n req.stake >= settings.large_threshold);\n uint32 expiry_ts = uint32(\n block.timestamp + getChallengingPeriod(settings, 0, is_large)\n ); \n claim_nums[claim_id] = claim_num;\n \n claims[claim_num] = Claim({\n amount: req.amount,\n \n recipient_address: req.recipient_address,\n claimant_address: payable(msg.sender),\n sender_address: req.sender_address,\n \n data: req.data,\n yes_stake: req.stake,\n no_stake: 0,\n current_outcome: Side.yes,\n is_large: is_large,\n period_number: 0,\n txts: req.txts,\n ts: uint32(block.timestamp),\n expiry_ts: expiry_ts,\n \n withdrawn: false,\n finished: false\n });\n stakes[claim_num][Side.yes][msg.sender] = req.stake;\n emit NewClaim(\n claim_num,\n msg.sender,\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.stake,\n req.data,\n expiry_ts\n );\n \n }"
            }
        ],
        "NewChallenge": [
            {
                "challenge": "function challenge(\n Settings storage settings,\n Claim storage c,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n Side stake_on,\n uint stake\n ) external {\n require(\n block.timestamp < c.expiry_ts,\n \"the challenging period has expired\"\n );\n require(\n stake_on != c.current_outcome,\n \"this outcome is already current\"\n );\n uint excess;\n uint challenging_target = ((\n c.current_outcome == Side.yes ? c.yes_stake : c.no_stake\n ) * settings.counterstake_coef100) / 100;\n {\n \n uint stake_on_proposed_outcome = (\n stake_on == Side.yes ? c.yes_stake : c.no_stake\n ) + stake;\n bool would_override_current_outcome = stake_on_proposed_outcome >=\n challenging_target;\n excess = would_override_current_outcome\n ? stake_on_proposed_outcome - challenging_target\n : 0;\n uint accepted_stake = stake - excess;\n if (stake_on == Side.yes) c.yes_stake += accepted_stake;\n else c.no_stake += accepted_stake;\n if (would_override_current_outcome) {\n c.period_number++;\n c.current_outcome = stake_on;\n c.expiry_ts = uint32(\n block.timestamp +\n getChallengingPeriod(\n settings,\n c.period_number,\n c.is_large\n )\n );\n challenging_target =\n (challenging_target * settings.counterstake_coef100) /\n 100;\n }\n stakes[claim_num][stake_on][msg.sender] += accepted_stake;\n }\n emit NewChallenge(\n claim_num,\n msg.sender,\n stake,\n stake_on,\n c.current_outcome,\n c.yes_stake,\n c.no_stake,\n c.expiry_ts,\n challenging_target\n );\n if (excess > 0) {\n if (settings.tokenAddress == address(0))\n payable(msg.sender).transfer(excess);\n else IERC20(settings.tokenAddress).safeTransfer(msg.sender, excess);\n }\n }"
            }
        ],
        "FinishedClaim": [
            {
                "finish": "function finish(\n Claim storage c,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n address payable to_address\n ) external returns (bool, bool, uint) {\n require(\n block.timestamp > c.expiry_ts,\n \"challenging period is still ongoing\"\n );\n if (to_address == address(0)) to_address = payable(msg.sender);\n bool is_winning_claimant = (to_address == c.claimant_address &&\n c.current_outcome == Side.yes);\n require(!(is_winning_claimant && c.withdrawn), \"already withdrawn\");\n uint won_stake;\n {\n \n uint my_stake = stakes[claim_num][c.current_outcome][to_address];\n require(\n my_stake > 0 || is_winning_claimant,\n \"you are not the recipient and you didn't stake on the winning outcome or you have already withdrawn\"\n );\n uint winning_stake = c.current_outcome == Side.yes\n ? c.yes_stake\n : c.no_stake;\n if (my_stake > 0)\n won_stake =\n ((c.yes_stake + c.no_stake) * my_stake) /\n winning_stake;\n }\n if (is_winning_claimant) c.withdrawn = true;\n bool finished;\n if (!c.finished) {\n finished = true;\n c.finished = true;\n \n \n emit FinishedClaim(claim_num, c.current_outcome);\n }\n delete stakes[claim_num][c.current_outcome][to_address];\n return (finished, is_winning_claimant, won_stake);\n }"
            }
        ]
    },
    "det_chain": {}
}
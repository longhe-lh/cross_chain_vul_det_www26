{
    "src_chain": {
        "SendToCosmosEvent1": [
            {
                "sendToCosmos": "function sendToCosmos(\n address _tokenContract,\n string calldata _destination,\n uint256 _amount\n ) external nonReentrant {\n \n uint256 ourStartingBalance = IERC20(_tokenContract).balanceOf(\n address(this)\n );\n \n IERC20(_tokenContract).safeTransferFrom(\n msg.sender,\n address(this),\n _amount\n );\n \n \n uint256 ourEndingBalance = IERC20(_tokenContract).balanceOf(\n address(this)\n );\n \n \n if (ourEndingBalance <= ourStartingBalance) {\n revert InvalidSendToCosmos();\n }\n state_lastEventNonce = state_lastEventNonce + 1;\n \n \n \n emit SendToCosmosEvent(\n _tokenContract,\n msg.sender,\n _destination,\n ourEndingBalance - ourStartingBalance,\n state_lastEventNonce\n );\n }"
            }
        ],
        "TransactionBatchExecutedEvent1": [
            {
                "submitBatch": "function submitBatch(\n \n ValsetArgs calldata _currentValset,\n \n Signature[] calldata _sigs,\n \n uint256[] calldata _amounts,\n address[] calldata _destinations,\n uint256[] calldata _fees,\n uint256 _batchNonce,\n address _tokenContract,\n \n \n uint256 _batchTimeout\n ) external nonReentrant {\n \n {\n \n if (_batchNonce <= state_lastBatchNonces[_tokenContract]) {\n revert InvalidBatchNonce({\n newNonce: _batchNonce,\n currentNonce: state_lastBatchNonces[_tokenContract]\n });\n }\n \n \n \n if (_batchNonce > state_lastBatchNonces[_tokenContract] + 1000000) {\n revert InvalidBatchNonce({\n newNonce: _batchNonce,\n currentNonce: state_lastBatchNonces[_tokenContract]\n });\n }\n \n if (block.number >= _batchTimeout) {\n revert BatchTimedOut();\n }\n \n validateValset(_currentValset, _sigs);\n \n if (\n makeCheckpoint(_currentValset, state_gravityId) !=\n state_lastValsetCheckpoint\n ) {\n revert IncorrectCheckpoint();\n }\n \n if (\n _amounts.length != _destinations.length ||\n _amounts.length != _fees.length\n ) {\n revert MalformedBatch();\n }\n \n checkValidatorSignatures(\n _currentValset,\n _sigs,\n \n keccak256(\n abi.encode(\n state_gravityId,\n \n 0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n _amounts,\n _destinations,\n _fees,\n _batchNonce,\n _tokenContract,\n _batchTimeout\n )\n ),\n constant_powerThreshold\n );\n \n \n state_lastBatchNonces[_tokenContract] = _batchNonce;\n {\n \n uint256 totalFee;\n for (uint256 i = 0; i < _amounts.length; i++) {\n IERC20(_tokenContract).safeTransfer(\n _destinations[i],\n _amounts[i]\n );\n totalFee = totalFee + _fees[i];\n }\n \n IERC20(_tokenContract).safeTransfer(msg.sender, totalFee);\n }\n }\n \n {\n state_lastEventNonce = state_lastEventNonce + 1;\n emit TransactionBatchExecutedEvent(\n _batchNonce,\n _tokenContract,\n state_lastEventNonce\n );\n }\n }"
            }
        ],
        "LogicCallEvent1": [
            {
                "submitLogicCall": "function submitLogicCall(\n \n ValsetArgs calldata _currentValset,\n \n Signature[] calldata _sigs,\n LogicCallArgs memory _args\n ) external nonReentrant {\n \n {\n \n if (block.number >= _args.timeOut) {\n revert LogicCallTimedOut();\n }\n \n if (\n state_invalidationMapping[_args.invalidationId] >=\n _args.invalidationNonce\n ) {\n revert InvalidLogicCallNonce({\n newNonce: _args.invalidationNonce,\n currentNonce: state_invalidationMapping[\n _args.invalidationId\n ]\n });\n }\n \n \n \n \n validateValset(_currentValset, _sigs);\n \n if (\n makeCheckpoint(_currentValset, state_gravityId) !=\n state_lastValsetCheckpoint\n ) {\n revert IncorrectCheckpoint();\n }\n if (\n _args.transferAmounts.length !=\n _args.transferTokenContracts.length\n ) {\n revert InvalidLogicCallTransfers();\n }\n if (_args.feeAmounts.length != _args.feeTokenContracts.length) {\n revert InvalidLogicCallFees();\n }\n }\n {\n bytes32 argsHash = keccak256(\n abi.encode(\n state_gravityId,\n \n 0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n _args.transferAmounts,\n _args.transferTokenContracts,\n _args.feeAmounts,\n _args.feeTokenContracts,\n _args.logicContractAddress,\n _args.payload,\n _args.timeOut,\n _args.invalidationId,\n _args.invalidationNonce\n )\n );\n \n checkValidatorSignatures(\n _currentValset,\n _sigs,\n \n argsHash,\n constant_powerThreshold\n );\n }\n \n \n state_invalidationMapping[_args.invalidationId] = _args\n .invalidationNonce;\n \n for (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n IERC20(_args.transferTokenContracts[i]).safeTransfer(\n _args.logicContractAddress,\n _args.transferAmounts[i]\n );\n }\n \n bytes memory returnData = Address.functionCall(\n _args.logicContractAddress,\n _args.payload\n );\n \n for (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n IERC20(_args.feeTokenContracts[i]).safeTransfer(\n msg.sender,\n _args.feeAmounts[i]\n );\n }\n \n {\n state_lastEventNonce = state_lastEventNonce + 1;\n emit LogicCallEvent(\n _args.invalidationId,\n _args.invalidationNonce,\n returnData,\n state_lastEventNonce\n );\n }\n }"
            }
        ],
        "ERC20DeployedEvent1": []
    },
    "rel_chain": {
        "ValsetUpdatedEvent": []
    },
    "det_chain": {
        "SendToCosmosEvent1": [
            {
                "sendToCosmos": "function sendToCosmos(\n address _tokenContract,\n string calldata _destination,\n uint256 _amount\n ) external nonReentrant {\n \n uint256 ourStartingBalance = IERC20(_tokenContract).balanceOf(\n address(this)\n );\n \n IERC20(_tokenContract).safeTransferFrom(\n msg.sender,\n address(this),\n _amount\n );\n \n \n uint256 ourEndingBalance = IERC20(_tokenContract).balanceOf(\n address(this)\n );\n \n \n if (ourEndingBalance <= ourStartingBalance) {\n revert InvalidSendToCosmos();\n }\n state_lastEventNonce = state_lastEventNonce + 1;\n \n \n \n emit SendToCosmosEvent(\n _tokenContract,\n msg.sender,\n _destination,\n ourEndingBalance - ourStartingBalance,\n state_lastEventNonce\n );\n }"
            }
        ],
        "TransactionBatchExecutedEvent1": [
            {
                "submitBatch": "function submitBatch(\n \n ValsetArgs calldata _currentValset,\n \n Signature[] calldata _sigs,\n \n uint256[] calldata _amounts,\n address[] calldata _destinations,\n uint256[] calldata _fees,\n uint256 _batchNonce,\n address _tokenContract,\n \n \n uint256 _batchTimeout\n ) external nonReentrant {\n \n {\n \n if (_batchNonce <= state_lastBatchNonces[_tokenContract]) {\n revert InvalidBatchNonce({\n newNonce: _batchNonce,\n currentNonce: state_lastBatchNonces[_tokenContract]\n });\n }\n \n \n \n if (_batchNonce > state_lastBatchNonces[_tokenContract] + 1000000) {\n revert InvalidBatchNonce({\n newNonce: _batchNonce,\n currentNonce: state_lastBatchNonces[_tokenContract]\n });\n }\n \n if (block.number >= _batchTimeout) {\n revert BatchTimedOut();\n }\n \n validateValset(_currentValset, _sigs);\n \n if (\n makeCheckpoint(_currentValset, state_gravityId) !=\n state_lastValsetCheckpoint\n ) {\n revert IncorrectCheckpoint();\n }\n \n if (\n _amounts.length != _destinations.length ||\n _amounts.length != _fees.length\n ) {\n revert MalformedBatch();\n }\n \n checkValidatorSignatures(\n _currentValset,\n _sigs,\n \n keccak256(\n abi.encode(\n state_gravityId,\n \n 0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n _amounts,\n _destinations,\n _fees,\n _batchNonce,\n _tokenContract,\n _batchTimeout\n )\n ),\n constant_powerThreshold\n );\n \n \n state_lastBatchNonces[_tokenContract] = _batchNonce;\n {\n \n uint256 totalFee;\n for (uint256 i = 0; i < _amounts.length; i++) {\n IERC20(_tokenContract).safeTransfer(\n _destinations[i],\n _amounts[i]\n );\n totalFee = totalFee + _fees[i];\n }\n \n IERC20(_tokenContract).safeTransfer(msg.sender, totalFee);\n }\n }\n \n {\n state_lastEventNonce = state_lastEventNonce + 1;\n emit TransactionBatchExecutedEvent(\n _batchNonce,\n _tokenContract,\n state_lastEventNonce\n );\n }\n }"
            }
        ],
        "LogicCallEvent1": [
            {
                "submitLogicCall": "function submitLogicCall(\n \n ValsetArgs calldata _currentValset,\n \n Signature[] calldata _sigs,\n LogicCallArgs memory _args\n ) external nonReentrant {\n \n {\n \n if (block.number >= _args.timeOut) {\n revert LogicCallTimedOut();\n }\n \n if (\n state_invalidationMapping[_args.invalidationId] >=\n _args.invalidationNonce\n ) {\n revert InvalidLogicCallNonce({\n newNonce: _args.invalidationNonce,\n currentNonce: state_invalidationMapping[\n _args.invalidationId\n ]\n });\n }\n \n \n \n \n validateValset(_currentValset, _sigs);\n \n if (\n makeCheckpoint(_currentValset, state_gravityId) !=\n state_lastValsetCheckpoint\n ) {\n revert IncorrectCheckpoint();\n }\n if (\n _args.transferAmounts.length !=\n _args.transferTokenContracts.length\n ) {\n revert InvalidLogicCallTransfers();\n }\n if (_args.feeAmounts.length != _args.feeTokenContracts.length) {\n revert InvalidLogicCallFees();\n }\n }\n {\n bytes32 argsHash = keccak256(\n abi.encode(\n state_gravityId,\n \n 0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n _args.transferAmounts,\n _args.transferTokenContracts,\n _args.feeAmounts,\n _args.feeTokenContracts,\n _args.logicContractAddress,\n _args.payload,\n _args.timeOut,\n _args.invalidationId,\n _args.invalidationNonce\n )\n );\n \n checkValidatorSignatures(\n _currentValset,\n _sigs,\n \n argsHash,\n constant_powerThreshold\n );\n }\n \n \n state_invalidationMapping[_args.invalidationId] = _args\n .invalidationNonce;\n \n for (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n IERC20(_args.transferTokenContracts[i]).safeTransfer(\n _args.logicContractAddress,\n _args.transferAmounts[i]\n );\n }\n \n bytes memory returnData = Address.functionCall(\n _args.logicContractAddress,\n _args.payload\n );\n \n for (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n IERC20(_args.feeTokenContracts[i]).safeTransfer(\n msg.sender,\n _args.feeAmounts[i]\n );\n }\n \n {\n state_lastEventNonce = state_lastEventNonce + 1;\n emit LogicCallEvent(\n _args.invalidationId,\n _args.invalidationNonce,\n returnData,\n state_lastEventNonce\n );\n }\n }"
            }
        ],
        "ERC20DeployedEvent1": []
    }
}
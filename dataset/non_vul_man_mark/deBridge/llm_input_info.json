{
    "src_chain": {
        "send1": [
            {
                "send": "function send(\n address _tokenAddress,\n uint256 _amount,\n uint256 _chainIdTo,\n bytes memory _receiver,\n bytes memory _permit,\n bool _useAssetFee,\n uint32 _referralCode,\n bytes calldata _autoParams\n ) external payable override nonReentrant whenNotPaused {\n bytes32 debridgeId;\n FeeParams memory feeParams;\n uint256 amountAfterFee;\n \n (amountAfterFee, debridgeId, feeParams) = _send(\n _permit,\n _tokenAddress,\n _amount,\n _chainIdTo,\n _useAssetFee\n );\n SubmissionAutoParamsTo memory autoParams;\n \n if (_autoParams.length > 0) {\n autoParams = abi.decode(_autoParams, (SubmissionAutoParamsTo));\n autoParams.executionFee = _normalizeTokenAmount(\n _tokenAddress,\n autoParams.executionFee\n );\n if (autoParams.executionFee > _amount) revert ProposedFeeTooHigh();\n if (\n autoParams.data.length > 0 &&\n autoParams.fallbackAddress.length == 0\n ) revert WrongAutoArgument();\n }\n amountAfterFee -= autoParams.executionFee;\n \n amountAfterFee = _normalizeTokenAmount(_tokenAddress, amountAfterFee);\n _publishSubmission(\n debridgeId,\n _chainIdTo,\n amountAfterFee,\n _receiver,\n feeParams,\n _referralCode,\n autoParams,\n _autoParams.length > 0\n );\n }"
            },
            {
                "_send": "function _send(\n bytes memory _permit,\n address _tokenAddress,\n uint256 _amount,\n uint256 _chainIdTo,\n bool _useAssetFee\n )\n internal\n returns (\n uint256 amountAfterFee,\n bytes32 debridgeId,\n FeeParams memory feeParams\n )\n {\n function _validateToken(...) {...}\n_validateToken(_tokenAddress);\n \n if (_permit.length > 0) {\n \n uint256 deadline = _permit.toUint256(0);\n (bytes32 r, bytes32 s, uint8 v) = _permit.parseSignature(32);\n IERC20Permit(_tokenAddress).permit(\n msg.sender,\n address(this),\n _amount,\n deadline,\n v,\n r,\n s\n );\n }\n TokenInfo memory nativeTokenInfo = getNativeInfo[_tokenAddress];\n bool isNativeToken = nativeTokenInfo.nativeChainId == 0\n ? true \n : nativeTokenInfo.nativeChainId == getChainId(); \n if (isNativeToken) {\n \n debridgeId = getDebridgeId(\n getChainId(),\n _tokenAddress == address(0) ? address(weth) : _tokenAddress\n );\n } else {\n debridgeId = getbDebridgeId(\n nativeTokenInfo.nativeChainId,\n nativeTokenInfo.nativeAddress\n );\n }\n DebridgeInfo storage debridge = getDebridge[debridgeId];\n if (!debridge.exist) {\n if (isNativeToken) {\n \n address assetAddress = _tokenAddress == address(0)\n ? address(weth)\n : _tokenAddress;\n _addAsset(\n debridgeId,\n assetAddress,\n abi.encodePacked(assetAddress),\n getChainId()\n );\n } else revert DebridgeNotFound();\n }\n ChainSupportInfo memory chainFees = getChainToConfig[_chainIdTo];\n if (!chainFees.isSupported) revert WrongChainTo();\n if (_tokenAddress == address(0)) {\n \n _amount = msg.value;\n weth.deposit{value: _amount}();\n _useAssetFee = true;\n } else {\n IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n uint256 balanceBefore = token.balanceOf(address(this));\n token.safeTransferFrom(msg.sender, address(this), _amount);\n \n _amount = token.balanceOf(address(this)) - balanceBefore;\n }\n if (_amount > debridge.maxAmount) revert TransferAmountTooHigh();\n \n {\n DiscountInfo memory discountInfo = feeDiscount[msg.sender];\n DebridgeFeeInfo storage debridgeFee = getDebridgeFeeInfo[\n debridgeId\n ];\n \n uint256 assetsFixedFee;\n if (_useAssetFee) {\n if (_tokenAddress == address(0)) {\n \n assetsFixedFee = chainFees.fixedNativeFee == 0\n ? globalFixedNativeFee\n : chainFees.fixedNativeFee;\n } else {\n \n assetsFixedFee = debridgeFee.getChainFee[_chainIdTo];\n if (assetsFixedFee == 0) revert NotSupportedFixedFee();\n }\n \n assetsFixedFee = _applyDiscount(\n assetsFixedFee,\n discountInfo.discountFixBps\n );\n if (_amount < assetsFixedFee)\n revert TransferAmountNotCoverFees();\n feeParams.fixFee = assetsFixedFee;\n } else {\n \n \n uint256 nativeFee = chainFees.fixedNativeFee == 0\n ? globalFixedNativeFee\n : chainFees.fixedNativeFee;\n \n nativeFee = _applyDiscount(\n nativeFee,\n discountInfo.discountFixBps\n );\n if (msg.value < nativeFee) revert TransferAmountNotCoverFees();\n else if (msg.value > nativeFee) {\n \n _safeTransferETH(msg.sender, msg.value - nativeFee);\n }\n bytes32 nativeDebridgeId = getDebridgeId(\n getChainId(),\n address(0)\n );\n getDebridgeFeeInfo[nativeDebridgeId].collectedFees += nativeFee;\n feeParams.fixFee = nativeFee;\n }\n \n \n uint256 transferFee = ((\n chainFees.transferFeeBps == 0\n ? globalTransferFeeBps\n : chainFees.transferFeeBps\n ) * (_amount - assetsFixedFee)) / BPS_DENOMINATOR;\n \n transferFee = _applyDiscount(\n transferFee,\n discountInfo.discountTransferBps\n );\n uint256 totalFee = transferFee + assetsFixedFee;\n if (_amount < totalFee) revert TransferAmountNotCoverFees();\n debridgeFee.collectedFees += totalFee;\n amountAfterFee = _amount - totalFee;\n \n feeParams.transferFee = transferFee;\n feeParams.useAssetFee = _useAssetFee;\n feeParams.receivedAmount = _amount;\n feeParams.isNativeToken = isNativeToken;\n }\n if (isNativeToken) {\n debridge.balance += amountAfterFee;\n } else {\n debridge.balance -= amountAfterFee;\n IDeBridgeToken(debridge.tokenAddress).burn(amountAfterFee);\n }\n return (amountAfterFee, debridgeId, feeParams);\n }"
            }
        ],
        "claim1": [
            {
                "claim": "function claim(\n bytes32 _debridgeId,\n uint256 _amount,\n uint256 _chainIdFrom,\n address _receiver,\n uint256 _nonce,\n bytes calldata _signatures,\n bytes calldata _autoParams\n ) external override whenNotPaused {\n if (!getChainFromConfig[_chainIdFrom].isSupported)\n revert WrongChainFrom();\n SubmissionAutoParamsFrom memory autoParams;\n if (_autoParams.length > 0) {\n autoParams = abi.decode(_autoParams, (SubmissionAutoParamsFrom));\n }\n bytes32 submissionId = getSubmissionIdFrom(\n _debridgeId,\n _chainIdFrom,\n _amount,\n _receiver,\n _nonce,\n autoParams,\n _autoParams.length > 0,\n msg.sender\n );\n \n if (isSubmissionUsed[submissionId]) revert SubmissionUsed();\n isSubmissionUsed[submissionId] = true;\n function _checkConfirmations(...) {...}\n_checkConfirmations(submissionId, _debridgeId, _amount, _signatures);\n bool isNativeToken = _claim(\n submissionId,\n _debridgeId,\n _receiver,\n _amount,\n _chainIdFrom,\n autoParams\n );\n emit Claimed(\n submissionId,\n _debridgeId,\n _amount,\n _receiver,\n _nonce,\n _chainIdFrom,\n _autoParams,\n isNativeToken\n );\n }"
            },
            {
                "_checkConfirmations": "function _checkConfirmations(\n bytes32 _submissionId,\n bytes32 _debridgeId,\n uint256 _amount,\n bytes calldata _signatures\n ) internal {\n if (isBlockedSubmission[_submissionId]) revert SubmissionBlocked();\n \n ISignatureVerifier(signatureVerifier).submit(\n _submissionId,\n _signatures,\n _amount >= getAmountThreshold[_debridgeId] ? excessConfirmations : 0\n );\n }"
            }
        ]
    },
    "rel_chain": {
        "submit1": [
            {
                "submit": "function submit(\n bytes32 _submissionId,\n bytes memory _signatures,\n uint8 _excessConfirmations\n ) external override onlyDeBridgeGate {\n \n uint8 needConfirmations = _excessConfirmations > minConfirmations\n ? _excessConfirmations\n : minConfirmations;\n \n uint256 currentRequiredOraclesCount;\n \n uint8 confirmations;\n uint256 signaturesCount = _countSignatures(_signatures);\n address[] memory validators = new address[](signaturesCount);\n for (uint256 i = 0; i < signaturesCount; i++) {\n (bytes32 r, bytes32 s, uint8 v) = _signatures.parseSignature(\n i * 65\n );\n address oracle = ecrecover(_submissionId.getUnsignedMsg(), v, r, s);\n if (getOracleInfo[oracle].isValid) {\n for (uint256 k = 0; k < i; k++) {\n if (validators[k] == oracle) revert DuplicateSignatures();\n }\n validators[i] = oracle;\n confirmations += 1;\n emit Confirmed(_submissionId, oracle);\n if (getOracleInfo[oracle].required) {\n currentRequiredOraclesCount += 1;\n }\n if (\n confirmations >= needConfirmations &&\n currentRequiredOraclesCount >= requiredOraclesCount\n ) {\n break;\n }\n }\n }\n if (currentRequiredOraclesCount != requiredOraclesCount)\n revert NotConfirmedByRequiredOracles();\n if (confirmations >= minConfirmations) {\n if (currentBlock == uint40(block.number)) {\n submissionsInBlock += 1;\n } else {\n currentBlock = uint40(block.number);\n submissionsInBlock = 1;\n }\n emit SubmissionApproved(_submissionId);\n }\n if (submissionsInBlock > confirmationThreshold) {\n if (confirmations < excessConfirmations)\n revert NotConfirmedThreshold();\n }\n if (confirmations < needConfirmations) revert SubmissionNotConfirmed();\n }"
            }
        ]
    },
    "det_chain": {
        "claim1": [
            {
                "claim": "function claim(\n bytes32 _debridgeId,\n uint256 _amount,\n uint256 _chainIdFrom,\n address _receiver,\n uint256 _nonce,\n bytes calldata _signatures,\n bytes calldata _autoParams\n ) external override whenNotPaused {\n if (!getChainFromConfig[_chainIdFrom].isSupported)\n revert WrongChainFrom();\n SubmissionAutoParamsFrom memory autoParams;\n if (_autoParams.length > 0) {\n autoParams = abi.decode(_autoParams, (SubmissionAutoParamsFrom));\n }\n bytes32 submissionId = getSubmissionIdFrom(\n _debridgeId,\n _chainIdFrom,\n _amount,\n _receiver,\n _nonce,\n autoParams,\n _autoParams.length > 0,\n msg.sender\n );\n \n if (isSubmissionUsed[submissionId]) revert SubmissionUsed();\n isSubmissionUsed[submissionId] = true;\n _checkConfirmations(submissionId, _debridgeId, _amount, _signatures);\n bool isNativeToken = _claim(\n submissionId,\n _debridgeId,\n _receiver,\n _amount,\n _chainIdFrom,\n autoParams\n );\n emit Claimed(\n submissionId,\n _debridgeId,\n _amount,\n _receiver,\n _nonce,\n _chainIdFrom,\n _autoParams,\n isNativeToken\n );\n }"
            },
            {
                "_claim": "function _claim(\n bytes32 _submissionId,\n bytes32 _debridgeId,\n address _receiver,\n uint256 _amount,\n uint256 _chainIdFrom,\n SubmissionAutoParamsFrom memory _autoParams\n ) internal returns (bool isNativeToken) {\n DebridgeInfo storage debridge = getDebridge[_debridgeId];\n if (!debridge.exist) revert DebridgeNotFound();\n isNativeToken = debridge.chainId == getChainId();\n if (isNativeToken) {\n debridge.balance -= _amount + _autoParams.executionFee;\n } else {\n debridge.balance += _amount + _autoParams.executionFee;\n }\n address _token = debridge.tokenAddress;\n bool unwrapETH = isNativeToken &&\n _autoParams.flags.getFlag(Flags.UNWRAP_ETH) &&\n _token == address(weth);\n if (_autoParams.executionFee > 0) {\n _mintOrTransfer(\n _token,\n msg.sender,\n _autoParams.executionFee,\n isNativeToken\n );\n }\n if (_autoParams.data.length > 0) {\n \n address _callProxy = callProxy;\n bool status;\n if (unwrapETH) {\n \n _withdrawWeth(_callProxy, _amount);\n status = ICallProxy(_callProxy).call(\n _autoParams.fallbackAddress,\n _receiver,\n _autoParams.data,\n _autoParams.flags,\n _autoParams.nativeSender,\n _chainIdFrom\n );\n } else {\n _mintOrTransfer(_token, _callProxy, _amount, isNativeToken);\n status = ICallProxy(_callProxy).callERC20(\n _token,\n _autoParams.fallbackAddress,\n _receiver,\n _autoParams.data,\n _autoParams.flags,\n _autoParams.nativeSender,\n _chainIdFrom\n );\n }\n emit AutoRequestExecuted(_submissionId, status, _callProxy);\n } else if (unwrapETH) {\n \n _withdrawWeth(_receiver, _amount);\n } else {\n function _mintOrTransfer(...) {...}\n_mintOrTransfer(_token, _receiver, _amount, isNativeToken);\n }\n emit MonitoringClaimEvent(\n _submissionId,\n debridge.balance,\n IERC20Upgradeable(debridge.tokenAddress).totalSupply()\n );\n }"
            },
            {
                "_mintOrTransfer": "function _mintOrTransfer(\n address _token,\n address _receiver,\n uint256 _amount,\n bool isNativeToken\n ) internal {\n if (_amount > 0) {\n if (isNativeToken) {\n IERC20Upgradeable(_token).safeTransfer(_receiver, _amount);\n } else {\n IDeBridgeToken(_token).mint(_receiver, _amount);\n }\n }\n }"
            }
        ]
    }
}
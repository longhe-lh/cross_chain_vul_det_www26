{
    "src_chain": {
        "ETHBridgeInitiated1": [
            {
                "_initiateBridgeETH": "function _initiateBridgeETH(\n address _from,\n address _to,\n uint256 _amount,\n uint32 _minGasLimit,\n bytes memory _extraData\n ) internal {\n require(\n msg.value == _amount,\n \"StandardBridge: bridging ETH must include sufficient ETH value\"\n );\n\n \n\n \n\n _emitETHBridgeInitiated(_from, _to, _amount, _extraData);\n\n MESSENGER.sendMessage{value: _amount}(\n address(OTHER_BRIDGE),\n abi.encodeWithSelector(\n this.finalizeBridgeETH.selector,\n _from,\n _to,\n _amount,\n _extraData\n ),\n _minGasLimit\n );\n }"
            },
            {
                "relayMessage": "function relayMessage(\n uint256 _nonce,\n address _sender,\n address _target,\n uint256 _value,\n uint256 _minGasLimit,\n bytes calldata _message\n ) external payable {\n (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n\n require(\n version < 2,\n \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n );\n\n \n\n \n\n if (version == 0) {\n bytes32 oldHash = Hashing.hashCrossDomainMessageV0(\n _target,\n _sender,\n _message,\n _nonce\n );\n\n require(\n successfulMessages[oldHash] == false,\n \"CrossDomainMessenger: legacy withdrawal already relayed\"\n );\n }\n\n \n\n \n\n bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n _nonce,\n _sender,\n _target,\n _value,\n _minGasLimit,\n _message\n );\n\n if (_isOtherMessenger()) {\n \n\n \n\n assert(msg.value == _value);\n\n assert(!failedMessages[versionedHash]);\n } else {\n require(\n msg.value == 0,\n \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n );\n\n require(\n failedMessages[versionedHash],\n \"CrossDomainMessenger: message cannot be replayed\"\n );\n }\n\n require(\n _isUnsafeTarget(_target) == false,\n \"CrossDomainMessenger: cannot send message to blocked system address\"\n );\n\n require(\n successfulMessages[versionedHash] == false,\n \"CrossDomainMessenger: message has already been relayed\"\n );\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n if (\n !SafeCall.hasMinGas(\n _minGasLimit,\n RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER\n ) || xDomainMsgSender != Constants.DEFAULT_L2_SENDER\n ) {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n\n return;\n }\n\n xDomainMsgSender = _sender;\n\n bool success = SafeCall.call(\n _target,\n gasleft() - RELAY_RESERVED_GAS,\n _value,\n _message\n );\n\n xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n if (success) {\n successfulMessages[versionedHash] = true;\n\n emit RelayedMessage(versionedHash);\n } else {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n }\n }"
            }
        ],
        "ERC20BridgeInitiated2": [
            {
                "_initiateBridgeERC20": "function _initiateBridgeERC20(\n address _localToken,\n address _remoteToken,\n address _from,\n address _to,\n uint256 _amount,\n uint32 _minGasLimit,\n bytes memory _extraData\n ) internal {\n if (_isOptimismMintableERC20(_localToken)) {\n require(\n _isCorrectTokenPair(_localToken, _remoteToken),\n \"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\"\n );\n\n OptimismMintableERC20(_localToken).burn(_from, _amount);\n } else {\n IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\n\n deposits[_localToken][_remoteToken] =\n deposits[_localToken][_remoteToken] +\n _amount;\n }\n\n \n\n \n\n _emitERC20BridgeInitiated(\n _localToken,\n _remoteToken,\n _from,\n _to,\n _amount,\n _extraData\n );\n\n MESSENGER.sendMessage(\n address(OTHER_BRIDGE),\n abi.encodeWithSelector(\n this.finalizeBridgeERC20.selector,\n \n\n \n\n \n\n _remoteToken,\n _localToken,\n _from,\n _to,\n _amount,\n _extraData\n ),\n _minGasLimit\n );\n }"
            },
            {
                "relayMessage": "function relayMessage(\n uint256 _nonce,\n address _sender,\n address _target,\n uint256 _value,\n uint256 _minGasLimit,\n bytes calldata _message\n ) external payable {\n (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n\n require(\n version < 2,\n \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n );\n\n \n\n \n\n if (version == 0) {\n bytes32 oldHash = Hashing.hashCrossDomainMessageV0(\n _target,\n _sender,\n _message,\n _nonce\n );\n\n require(\n successfulMessages[oldHash] == false,\n \"CrossDomainMessenger: legacy withdrawal already relayed\"\n );\n }\n\n \n\n \n\n bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n _nonce,\n _sender,\n _target,\n _value,\n _minGasLimit,\n _message\n );\n\n if (_isOtherMessenger()) {\n \n\n \n\n assert(msg.value == _value);\n\n assert(!failedMessages[versionedHash]);\n } else {\n require(\n msg.value == 0,\n \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n );\n\n require(\n failedMessages[versionedHash],\n \"CrossDomainMessenger: message cannot be replayed\"\n );\n }\n\n require(\n _isUnsafeTarget(_target) == false,\n \"CrossDomainMessenger: cannot send message to blocked system address\"\n );\n\n require(\n successfulMessages[versionedHash] == false,\n \"CrossDomainMessenger: message has already been relayed\"\n );\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n if (\n !SafeCall.hasMinGas(\n _minGasLimit,\n RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER\n ) || xDomainMsgSender != Constants.DEFAULT_L2_SENDER\n ) {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n\n return;\n }\n\n xDomainMsgSender = _sender;\n\n bool success = SafeCall.call(\n _target,\n gasleft() - RELAY_RESERVED_GAS,\n _value,\n _message\n );\n\n xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n if (success) {\n successfulMessages[versionedHash] = true;\n\n emit RelayedMessage(versionedHash);\n } else {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n }\n }"
            }
        ]
    },
    "rel_chain": {
        "relayMessage": [
            {
                "relayMessage": "function relayMessage(\n uint256 _nonce,\n address _sender,\n address _target,\n uint256 _value,\n uint256 _minGasLimit,\n bytes calldata _message\n ) external payable {\n (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n\n require(\n version < 2,\n \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n );\n\n \n\n \n\n if (version == 0) {\n bytes32 oldHash = Hashing.hashCrossDomainMessageV0(\n _target,\n _sender,\n _message,\n _nonce\n );\n\n require(\n successfulMessages[oldHash] == false,\n \"CrossDomainMessenger: legacy withdrawal already relayed\"\n );\n }\n\n \n\n \n\n bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n _nonce,\n _sender,\n _target,\n _value,\n _minGasLimit,\n _message\n );\n\n if (_isOtherMessenger()) {\n \n\n \n\n assert(msg.value == _value);\n\n assert(!failedMessages[versionedHash]);\n } else {\n require(\n msg.value == 0,\n \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n );\n\n require(\n failedMessages[versionedHash],\n \"CrossDomainMessenger: message cannot be replayed\"\n );\n }\n\n require(\n _isUnsafeTarget(_target) == false,\n \"CrossDomainMessenger: cannot send message to blocked system address\"\n );\n\n require(\n successfulMessages[versionedHash] == false,\n \"CrossDomainMessenger: message has already been relayed\"\n );\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n if (\n !SafeCall.hasMinGas(\n _minGasLimit,\n RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER\n ) || xDomainMsgSender != Constants.DEFAULT_L2_SENDER\n ) {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n\n return;\n }\n\n xDomainMsgSender = _sender;\n\n bool success = SafeCall.call(\n _target,\n gasleft() - RELAY_RESERVED_GAS,\n _value,\n _message\n );\n\n xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n if (success) {\n successfulMessages[versionedHash] = true;\n\n emit RelayedMessage(versionedHash);\n } else {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n }\n }"
            },
            {
                "finalizeBridgeETH": "function finalizeBridgeETH(\n address _from,\n address _to,\n uint256 _amount,\n bytes calldata _extraData\n ) public payable onlyOtherBridge {\n require(\n msg.value == _amount,\n \"StandardBridge: amount sent does not match amount required\"\n );\n\n require(_to != address(this), \"StandardBridge: cannot send to self\");\n\n require(\n _to != address(MESSENGER),\n \"StandardBridge: cannot send to messenger\"\n );\n\n \n\n \n\n _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\n\n bool success = SafeCall.call(_to, gasleft(), _amount, hex\"\");\n\n require(success, \"StandardBridge: ETH transfer failed\");\n }"
            }
        ]
    },
    "det_chain": {
        "ETHBridgeFinalized1": [
            {
                "finalizeBridgeETH": "function finalizeBridgeETH(\n address _from,\n address _to,\n uint256 _amount,\n bytes calldata _extraData\n ) public payable onlyOtherBridge {\n require(\n msg.value == _amount,\n \"StandardBridge: amount sent does not match amount required\"\n );\n\n require(_to != address(this), \"StandardBridge: cannot send to self\");\n\n require(\n _to != address(MESSENGER),\n \"StandardBridge: cannot send to messenger\"\n );\n\n \n\n \n\n _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\n\n bool success = SafeCall.call(_to, gasleft(), _amount, hex\"\");\n\n require(success, \"StandardBridge: ETH transfer failed\");\n }"
            }
        ],
        "ERC20BridgeFinalized2": [
            {
                "finalizeBridgeERC20": "function finalizeBridgeERC20(\n address _localToken,\n address _remoteToken,\n address _from,\n address _to,\n uint256 _amount,\n bytes calldata _extraData\n ) public onlyOtherBridge {\n if (_isOptimismMintableERC20(_localToken)) {\n require(\n _isCorrectTokenPair(_localToken, _remoteToken),\n \"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\"\n );\n\n OptimismMintableERC20(_localToken).mint(_to, _amount);\n } else {\n deposits[_localToken][_remoteToken] =\n deposits[_localToken][_remoteToken] -\n _amount;\n\n IERC20(_localToken).safeTransfer(_to, _amount);\n }\n\n \n\n \n\n _emitERC20BridgeFinalized(\n _localToken,\n _remoteToken,\n _from,\n _to,\n _amount,\n _extraData\n );\n }"
            }
        ]
    }
}
Folder Structure
--------------------------------------------------
contracts/
    Address.sol
    AddressAliasHelper.sol
    AddressUpgradeable.sol
    Arithmetic.sol
    Burn.sol
    Bytes.sol
    CanonicalTransactionChain.sol
    Constants.sol
    Context.sol
    ContextUpgradeable.sol
    CrossDomainEnabled.sol
    CrossDomainMessenger.sol
    draft-IERC20Permit.sol
    Encoding.sol
    ERC165Checker.sol
    ERC20.sol
    FixedPointMathLib.sol
    Hashing.sol
    ICanonicalTransactionChain.sol
    IChainStorageContainer.sol
    ICrossDomainMessenger.sol
    IERC165.sol
    IERC20.sol
    IERC20Metadata.sol
    iL1ChugSplashDeployer.sol
    IL1CrossDomainMessenger.sol
    IL1ERC20Bridge.sol
    IL1StandardBridge.sol
    IL2ERC20Bridge.sol
    Initializable.sol
    IOptimismMintableERC20.sol
    iOVM_BondManager.sol
    iOVM_CanonicalTransactionChain.sol
    iOVM_ChainStorageContainer.sol
    iOVM_CrossDomainMessenger.sol
    iOVM_DeployerWhitelist.sol
    iOVM_ExecutionManager.sol
    iOVM_FraudVerifier.sol
    iOVM_L1CrossDomainMessenger.sol
    iOVM_L1ERC20Bridge.sol
    iOVM_L1MultiMessageRelayer.sol
    iOVM_L2ERC20Bridge.sol
    iOVM_SafetyChecker.sol
    iOVM_StateCommitmentChain.sol
    iOVM_StateManager.sol
    iOVM_StateTransitioner.sol
    IStateCommitmentChain.sol
    L1ChugSplashProxy.sol
    L1CrossDomainMessenger.sol
    L1DAITokenBridge.sol
    L1StandardBridge.sol
    L2OutputOracle.sol
    Lib_AddressManager.sol
    Lib_AddressResolver.sol
    Lib_Bytes32Utils.sol
    Lib_BytesUtils.sol
    Lib_CrossDomainUtils.sol
    Lib_DefaultValues.sol
    Lib_ErrorUtils.sol
    Lib_EthUtils.sol
    Lib_MerkleTree.sol
    Lib_MerkleTrie.sol
    Lib_OVMCodec.sol
    Lib_PredeployAddresses.sol
    Lib_RLPReader.sol
    Lib_RLPWriter.sol
    Lib_SecureMerkleTrie.sol
    Math.sol
    MerkleTrie.sol
    OptimismMintableERC20.sol
    OptimismPortal.sol
    OVM_CanonicalTransactionChain.sol
    OVM_CrossDomainEnabled.sol
    OVM_DeployerWhitelist.sol
    OVM_ExecutionManager.sol
    OVM_L1MultiMessageRelayer.sol
    OVM_StateCommitmentChain.sol
    Ownable.sol
    OwnableUpgradeable.sol
    PausableUpgradeable.sol
    Predeploys.sol
    ReentrancyGuardUpgradeable.sol
    ResourceMetering.sol
    RLPReader.sol
    RLPWriter.sol
    SafeCall.sol
    SafeERC20.sol
    SafeMath.sol
    SecureMerkleTrie.sol
    Semver.sol
    SignedMath.sol
    StandardBridge.sol
    Strings.sol
    SystemConfig.sol
    TeleportrDeposit.sol
    Types.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity >=0.6.2 <0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: value }(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.staticcall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.delegatecall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\AddressAliasHelper.sol
File type: .sol
// SPDX-License-Identifier: Apache-2.0



/*

 * Copyright 2019-2021, Offchain Labs, Inc.

 *

 * Licensed under the Apache License, Version 2.0 (the "License");

 * you may not use this file except in compliance with the License.

 * You may obtain a copy of the License at

 *

 *    http://www.apache.org/licenses/LICENSE-2.0

 *

 * Unless required by applicable law or agreed to in writing, software

 * distributed under the License is distributed on an "AS IS" BASIS,

 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

 * See the License for the specific language governing permissions and

 * limitations under the License.

 */



pragma solidity ^0.8.0;



library AddressAliasHelper {

    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);



    /// @notice Utility function that converts the address in the L1 that submitted a tx to

    /// the inbox to the msg.sender viewed in the L2

    /// @param l1Address the address in the L1 that triggered the tx to L2

    /// @return l2Address L2 address as viewed in msg.sender

    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {

        unchecked {

            l2Address = address(uint160(l1Address) + offset);

        }

    }



    /// @notice Utility function that converts the msg.sender viewed in the L2 to the

    /// address in the L1 that submitted a tx to the inbox

    /// @param l2Address L2 address as viewed in msg.sender

    /// @return l1Address the address in the L1 that triggered the tx to L2

    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {

        unchecked {

            l1Address = address(uint160(l2Address) - offset);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\AddressUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)



pragma solidity ^0.8.1;



/**

 * @dev Collection of functions related to the address type

 */

library AddressUpgradeable {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     *

     * [IMPORTANT]

     * ====

     * You shouldn't rely on `isContract` to protect against flash loan attacks!

     *

     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets

     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract

     * constructor.

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize/address.code.length, which returns 0

        // for contracts in construction, since the code is only stored at the end

        // of the constructor execution.



        return account.code.length > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly

                /// @solidity memory-safe-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Arithmetic.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



import { SignedMath } from "@openzeppelin/contracts/utils/math/SignedMath.sol";

import { FixedPointMathLib } from "@rari-capital/solmate/src/utils/FixedPointMathLib.sol";



/**

 * @title Arithmetic

 * @notice Even more math than before.

 */

library Arithmetic {

    /**

     * @notice Clamps a value between a minimum and maximum.

     *

     * @param _value The value to clamp.

     * @param _min   The minimum value.

     * @param _max   The maximum value.

     *

     * @return The clamped value.

     */

    function clamp(

        int256 _value,

        int256 _min,

        int256 _max

    ) internal pure returns (int256) {

        return SignedMath.min(SignedMath.max(_value, _min), _max);

    }



    /**

     * @notice (c)oefficient (d)enominator (exp)onentiation function.

     *         Returns the result of: c * (1 - 1/d)^exp.

     *

     * @param _coefficient Coefficient of the function.

     * @param _denominator Fractional denominator.

     * @param _exponent    Power function exponent.

     *

     * @return Result of c * (1 - 1/d)^exp.

     */

    function cdexp(

        int256 _coefficient,

        int256 _denominator,

        int256 _exponent

    ) internal pure returns (int256) {

        return

            (_coefficient *

                (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Burn.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



/**

 * @title Burn

 * @notice Utilities for burning stuff.

 */

library Burn {

    /**

     * Burns a given amount of ETH.

     *

     * @param _amount Amount of ETH to burn.

     */

    function eth(uint256 _amount) internal {

        new Burner{ value: _amount }();

    }



    /**

     * Burns a given amount of gas.

     *

     * @param _amount Amount of gas to burn.

     */

    function gas(uint256 _amount) internal view {

        uint256 i = 0;

        uint256 initialGas = gasleft();

        while (initialGas - gasleft() < _amount) {

            ++i;

        }

    }

}



/**

 * @title Burner

 * @notice Burner self-destructs on creation and sends all ETH to itself, removing all ETH given to

 *         the contract from the circulating supply. Self-destructing is the only way to remove ETH

 *         from the circulating supply.

 */

contract Burner {

    constructor() payable {

        selfdestruct(payable(address(this)));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Bytes.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



/**

 * @title Bytes

 * @notice Bytes is a library for manipulating byte arrays.

 */

library Bytes {

    /**

     * @custom:attribution https://github.com/GNSPS/solidity-bytes-utils

     * @notice Slices a byte array with a given starting index and length. Returns a new byte array

     *         as opposed to a pointer to the original array. Will throw if trying to slice more

     *         bytes than exist in the array.

     *

     * @param _bytes Byte array to slice.

     * @param _start Starting index of the slice.

     * @param _length Length of the slice.

     *

     * @return Slice of the input byte array.

     */

    function slice(

        bytes memory _bytes,

        uint256 _start,

        uint256 _length

    ) internal pure returns (bytes memory) {

        unchecked {

            require(_length + 31 >= _length, "slice_overflow");

            require(_start + _length >= _start, "slice_overflow");

            require(_bytes.length >= _start + _length, "slice_outOfBounds");

        }



        bytes memory tempBytes;



        assembly {

            switch iszero(_length)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                let lengthmod := and(_length, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, _length)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, _length)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                //zero out the 32 bytes slice we are about to return

                //we need to do it because Solidity does not garbage collect

                mstore(tempBytes, 0)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return tempBytes;

    }



    /**

     * @notice Slices a byte array with a given starting index up to the end of the original byte

     *         array. Returns a new array rathern than a pointer to the original.

     *

     * @param _bytes Byte array to slice.

     * @param _start Starting index of the slice.

     *

     * @return Slice of the input byte array.

     */

    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {

        if (_start >= _bytes.length) {

            return bytes("");

        }

        return slice(_bytes, _start, _bytes.length - _start);

    }



    /**

     * @notice Converts a byte array into a nibble array by splitting each byte into two nibbles.

     *         Resulting nibble array will be exactly twice as long as the input byte array.

     *

     * @param _bytes Input byte array to convert.

     *

     * @return Resulting nibble array.

     */

    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {

        uint256 bytesLength = _bytes.length;

        bytes memory nibbles = new bytes(bytesLength * 2);

        bytes1 b;



        for (uint256 i = 0; i < bytesLength; ) {

            b = _bytes[i];

            nibbles[i * 2] = b >> 4;

            nibbles[i * 2 + 1] = b & 0x0f;

            unchecked {

                ++i;

            }

        }



        return nibbles;

    }



    /**

     * @notice Compares two byte arrays by comparing their keccak256 hashes.

     *

     * @param _bytes First byte array to compare.

     * @param _other Second byte array to compare.

     *

     * @return True if the two byte arrays are equal, false otherwise.

     */

    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {

        return keccak256(_bytes) == keccak256(_other);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\CanonicalTransactionChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { AddressAliasHelper } from "../../standards/AddressAliasHelper.sol";

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";

import { Lib_AddressResolver } from "../../libraries/resolver/Lib_AddressResolver.sol";



/* Interface Imports */

import { ICanonicalTransactionChain } from "./ICanonicalTransactionChain.sol";

import { IChainStorageContainer } from "./IChainStorageContainer.sol";



/**

 * @title CanonicalTransactionChain

 * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions

 * which must be applied to the rollup state. It defines the ordering of rollup transactions by

 * writing them to the 'CTC:batches' instance of the Chain Storage Container.

 * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the

 * Sequencer will eventually append it to the rollup state.

 *

 * Runtime target: EVM

 */

contract CanonicalTransactionChain is ICanonicalTransactionChain, Lib_AddressResolver {

    /*************

     * Constants *

     *************/



    // L2 tx gas-related

    uint256 public constant MIN_ROLLUP_TX_GAS = 100000;

    uint256 public constant MAX_ROLLUP_TX_SIZE = 50000;



    // The approximate cost of calling the enqueue function

    uint256 public enqueueGasCost;

    // The ratio of the cost of L1 gas to the cost of L2 gas

    uint256 public l2GasDiscountDivisor;

    // The amount of L2 gas which can be forwarded to L2 without spam prevention via 'gas burn'.

    // Calculated as the product of l2GasDiscountDivisor * enqueueGasCost.

    // See comments in enqueue() for further detail.

    uint256 public enqueueL2GasPrepaid;



    // Encoding-related (all in bytes)

    uint256 internal constant BATCH_CONTEXT_SIZE = 16;

    uint256 internal constant BATCH_CONTEXT_LENGTH_POS = 12;

    uint256 internal constant BATCH_CONTEXT_START_POS = 15;

    uint256 internal constant TX_DATA_HEADER_SIZE = 3;

    uint256 internal constant BYTES_TILL_TX_DATA = 65;



    /*************

     * Variables *

     *************/



    uint256 public maxTransactionGasLimit;



    /***************

     * Queue State *

     ***************/



    uint40 private _nextQueueIndex; // index of the first queue element not yet included

    Lib_OVMCodec.QueueElement[] queueElements;



    /***************

     * Constructor *

     ***************/



    constructor(

        address _libAddressManager,

        uint256 _maxTransactionGasLimit,

        uint256 _l2GasDiscountDivisor,

        uint256 _enqueueGasCost

    ) Lib_AddressResolver(_libAddressManager) {

        maxTransactionGasLimit = _maxTransactionGasLimit;

        l2GasDiscountDivisor = _l2GasDiscountDivisor;

        enqueueGasCost = _enqueueGasCost;

        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;

    }



    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Modifier to enforce that, if configured, only the Burn Admin may

     * successfully call a method.

     */

    modifier onlyBurnAdmin() {

        require(msg.sender == libAddressManager.owner(), "Only callable by the Burn Admin.");

        _;

    }



    /*******************************

     * Authorized Setter Functions *

     *******************************/



    /**

     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.

     * The value of enqueueL2GasPrepaid is immediately updated as well.

     */

    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost)

        external

        onlyBurnAdmin

    {

        enqueueGasCost = _enqueueGasCost;

        l2GasDiscountDivisor = _l2GasDiscountDivisor;

        // See the comment in enqueue() for the rationale behind this formula.

        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;



        emit L2GasParamsUpdated(l2GasDiscountDivisor, enqueueGasCost, enqueueL2GasPrepaid);

    }



    /********************

     * Public Functions *

     ********************/



    /**

     * Accesses the batch storage container.

     * @return Reference to the batch storage container.

     */

    function batches() public view returns (IChainStorageContainer) {

        return IChainStorageContainer(resolve("ChainStorageContainer-CTC-batches"));

    }



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements() public view returns (uint256 _totalElements) {

        (uint40 totalElements, , , ) = _getBatchExtraData();

        return uint256(totalElements);

    }



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches() public view returns (uint256 _totalBatches) {

        return batches().length();

    }



    /**

     * Returns the index of the next element to be enqueued.

     * @return Index for the next queue element.

     */

    function getNextQueueIndex() public view returns (uint40) {

        return _nextQueueIndex;

    }



    /**

     * Returns the timestamp of the last transaction.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestamp() public view returns (uint40) {

        (, , uint40 lastTimestamp, ) = _getBatchExtraData();

        return lastTimestamp;

    }



    /**

     * Returns the blocknumber of the last transaction.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumber() public view returns (uint40) {

        (, , , uint40 lastBlockNumber) = _getBatchExtraData();

        return lastBlockNumber;

    }



    /**

     * Gets the queue element at a particular index.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElement(uint256 _index)

        public

        view

        returns (Lib_OVMCodec.QueueElement memory _element)

    {

        return queueElements[_index];

    }



    /**

     * Get the number of queue elements which have not yet been included.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElements() public view returns (uint40) {

        return uint40(queueElements.length) - _nextQueueIndex;

    }



    /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @return Length of the queue.

     */

    function getQueueLength() public view returns (uint40) {

        return uint40(queueElements.length);

    }



    /**

     * Adds a transaction to the queue.

     * @param _target Target L2 contract to send the transaction to.

     * @param _gasLimit Gas limit for the enqueued L2 transaction.

     * @param _data Transaction data.

     */

    function enqueue(

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    ) external {

        require(

            _data.length <= MAX_ROLLUP_TX_SIZE,

            "Transaction data size exceeds maximum for rollup transaction."

        );



        require(

            _gasLimit <= maxTransactionGasLimit,

            "Transaction gas limit exceeds maximum for rollup transaction."

        );



        require(_gasLimit >= MIN_ROLLUP_TX_GAS, "Transaction gas limit too low to enqueue.");



        // Transactions submitted to the queue lack a method for paying gas fees to the Sequencer.

        // So we need to prevent spam attacks by ensuring that the cost of enqueueing a transaction

        // from L1 to L2 is not underpriced. For transaction with a high L2 gas limit, we do this by

        // burning some extra gas on L1. Of course there is also some intrinsic cost to enqueueing a

        // transaction, so we want to make sure not to over-charge (by burning too much L1 gas).

        // Therefore, we define 'enqueueL2GasPrepaid' as the L2 gas limit above which we must burn

        // additional gas on L1. This threshold is the product of two inputs:

        // 1. enqueueGasCost: the base cost of calling this function.

        // 2. l2GasDiscountDivisor: the ratio between the cost of gas on L1 and L2. This is a

        //    positive integer, meaning we assume L2 gas is always less costly.

        // The calculation below for gasToConsume can be seen as converting the difference (between

        // the specified L2 gas limit and the prepaid L2 gas limit) to an L1 gas amount.

        if (_gasLimit > enqueueL2GasPrepaid) {

            uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) / l2GasDiscountDivisor;

            uint256 startingGas = gasleft();



            // Although this check is not necessary (burn below will run out of gas if not true), it

            // gives the user an explicit reason as to why the enqueue attempt failed.

            require(startingGas > gasToConsume, "Insufficient gas for L2 rate limiting burn.");



            uint256 i;

            while (startingGas - gasleft() < gasToConsume) {

                i++;

            }

        }



        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a

        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.

        // We can safely ignore this for EOAs because they're guaranteed to have the same "code"

        // (i.e. no code at all). This also makes it possible for users to interact with contracts

        // on L2 even when the Sequencer is down.

        address sender;

        if (msg.sender == tx.origin) {

            sender = msg.sender;

        } else {

            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);

        }



        bytes32 transactionHash = keccak256(abi.encode(sender, _target, _gasLimit, _data));



        queueElements.push(

            Lib_OVMCodec.QueueElement({

                transactionHash: transactionHash,

                timestamp: uint40(block.timestamp),

                blockNumber: uint40(block.number)

            })

        );

        uint256 queueIndex = queueElements.length - 1;

        emit TransactionEnqueued(sender, _target, _gasLimit, _data, queueIndex, block.timestamp);

    }



    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatch() external {

        uint40 shouldStartAtElement;

        uint24 totalElementsToAppend;

        uint24 numContexts;

        assembly {

            shouldStartAtElement := shr(216, calldataload(4))

            totalElementsToAppend := shr(232, calldataload(9))

            numContexts := shr(232, calldataload(12))

        }



        require(

            shouldStartAtElement == getTotalElements(),

            "Actual batch start index does not match expected start index."

        );



        require(

            msg.sender == resolve("OVM_Sequencer"),

            "Function can only be called by the Sequencer."

        );



        uint40 nextTransactionPtr = uint40(

            BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts

        );



        require(msg.data.length >= nextTransactionPtr, "Not enough BatchContexts provided.");



        // Counter for number of sequencer transactions appended so far.

        uint32 numSequencerTransactions = 0;



        // Cache the _nextQueueIndex storage variable to a temporary stack variable.

        // This is safe as long as nothing reads or writes to the storage variable

        // until it is updated by the temp variable.

        uint40 nextQueueIndex = _nextQueueIndex;



        BatchContext memory curContext;

        for (uint32 i = 0; i < numContexts; i++) {

            BatchContext memory nextContext = _getBatchContext(i);



            // Now we can update our current context.

            curContext = nextContext;



            // Process sequencer transactions first.

            numSequencerTransactions += uint32(curContext.numSequencedTransactions);



            // Now process any subsequent queue transactions.

            nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);

        }



        require(

            nextQueueIndex <= queueElements.length,

            "Attempted to append more elements than are available in the queue."

        );



        // Generate the required metadata that we need to append this batch

        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;

        uint40 blockTimestamp;

        uint40 blockNumber;

        if (curContext.numSubsequentQueueTransactions == 0) {

            // The last element is a sequencer tx, therefore pull timestamp and block number from

            // the last context.

            blockTimestamp = uint40(curContext.timestamp);

            blockNumber = uint40(curContext.blockNumber);

        } else {

            // The last element is a queue tx, therefore pull timestamp and block number from the

            // queue element.

            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at

            // least one queue element. We increment nextQueueIndex after processing each queue

            // element, so the index of the last element we processed is nextQueueIndex - 1.

            Lib_OVMCodec.QueueElement memory lastElement = queueElements[nextQueueIndex - 1];



            blockTimestamp = lastElement.timestamp;

            blockNumber = lastElement.blockNumber;

        }



        // Cache the previous blockhash to ensure all transaction data can be retrieved efficiently.

        _appendBatch(

            blockhash(block.number - 1),

            totalElementsToAppend,

            numQueuedTransactions,

            blockTimestamp,

            blockNumber

        );



        emit SequencerBatchAppended(

            nextQueueIndex - numQueuedTransactions,

            numQueuedTransactions,

            getTotalElements()

        );



        // Update the _nextQueueIndex storage variable.

        _nextQueueIndex = nextQueueIndex;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Returns the BatchContext located at a particular index.

     * @param _index The index of the BatchContext

     * @return The BatchContext at the specified index.

     */

    function _getBatchContext(uint256 _index) internal pure returns (BatchContext memory) {

        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;

        uint256 numSequencedTransactions;

        uint256 numSubsequentQueueTransactions;

        uint256 ctxTimestamp;

        uint256 ctxBlockNumber;



        assembly {

            numSequencedTransactions := shr(232, calldataload(contextPtr))

            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))

            ctxTimestamp := shr(216, calldataload(add(contextPtr, 6)))

            ctxBlockNumber := shr(216, calldataload(add(contextPtr, 11)))

        }



        return

            BatchContext({

                numSequencedTransactions: numSequencedTransactions,

                numSubsequentQueueTransactions: numSubsequentQueueTransactions,

                timestamp: ctxTimestamp,

                blockNumber: ctxBlockNumber

            });

    }



    /**

     * Parses the batch context from the extra data.

     * @return Total number of elements submitted.

     * @return Index of the next queue element.

     */

    function _getBatchExtraData()

        internal

        view

        returns (

            uint40,

            uint40,

            uint40,

            uint40

        )

    {

        bytes27 extraData = batches().getGlobalMetadata();



        uint40 totalElements;

        uint40 nextQueueIndex;

        uint40 lastTimestamp;

        uint40 lastBlockNumber;



        // solhint-disable max-line-length

        assembly {

            extraData := shr(40, extraData)

            totalElements := and(

                extraData,

                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF

            )

            nextQueueIndex := shr(

                40,

                and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000)

            )

            lastTimestamp := shr(

                80,

                and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000)

            )

            lastBlockNumber := shr(

                120,

                and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000)

            )

        }

        // solhint-enable max-line-length



        return (totalElements, nextQueueIndex, lastTimestamp, lastBlockNumber);

    }



    /**

     * Encodes the batch context for the extra data.

     * @param _totalElements Total number of elements submitted.

     * @param _nextQueueIdx Index of the next queue element.

     * @param _timestamp Timestamp for the last batch.

     * @param _blockNumber Block number of the last batch.

     * @return Encoded batch context.

     */

    function _makeBatchExtraData(

        uint40 _totalElements,

        uint40 _nextQueueIdx,

        uint40 _timestamp,

        uint40 _blockNumber

    ) internal pure returns (bytes27) {

        bytes27 extraData;

        assembly {

            extraData := _totalElements

            extraData := or(extraData, shl(40, _nextQueueIdx))

            extraData := or(extraData, shl(80, _timestamp))

            extraData := or(extraData, shl(120, _blockNumber))

            extraData := shl(40, extraData)

        }



        return extraData;

    }



    /**

     * Inserts a batch into the chain of batches.

     * @param _transactionRoot Root of the transaction tree for this batch.

     * @param _batchSize Number of elements in the batch.

     * @param _numQueuedTransactions Number of queue transactions in the batch.

     * @param _timestamp The latest batch timestamp.

     * @param _blockNumber The latest batch blockNumber.

     */

    function _appendBatch(

        bytes32 _transactionRoot,

        uint256 _batchSize,

        uint256 _numQueuedTransactions,

        uint40 _timestamp,

        uint40 _blockNumber

    ) internal {

        IChainStorageContainer batchesRef = batches();

        (uint40 totalElements, uint40 nextQueueIndex, , ) = _getBatchExtraData();



        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({

            batchIndex: batchesRef.length(),

            batchRoot: _transactionRoot,

            batchSize: _batchSize,

            prevTotalElements: totalElements,

            extraData: hex""

        });



        emit TransactionBatchAppended(

            header.batchIndex,

            header.batchRoot,

            header.batchSize,

            header.prevTotalElements,

            header.extraData

        );



        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);

        bytes27 latestBatchContext = _makeBatchExtraData(

            totalElements + uint40(header.batchSize),

            nextQueueIndex + uint40(_numQueuedTransactions),

            _timestamp,

            _blockNumber

        );



        batchesRef.push(batchHeaderHash, latestBatchContext);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Constants.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import { ResourceMetering } from "../L1/ResourceMetering.sol";



/**

 * @title Constants

 * @notice Constants is a library for storing constants. Simple! Don't put everything in here, just

 *         the stuff used in multiple contracts. Constants that only apply to a single contract

 *         should be defined in that contract instead.

 */

library Constants {

    /**

     * @notice Special address to be used as the tx origin for gas estimation calls in the

     *         OptimismPortal and CrossDomainMessenger calls. You only need to use this address if

     *         the minimum gas limit specified by the user is not actually enough to execute the

     *         given message and you're attempting to estimate the actual necessary gas limit. We

     *         use address(1) because it's the ecrecover precompile and therefore guaranteed to

     *         never have any code on any EVM chain.

     */

    address internal constant ESTIMATION_ADDRESS = address(1);



    /**

     * @notice Value used for the L2 sender storage slot in both the OptimismPortal and the

     *         CrossDomainMessenger contracts before an actual sender is set. This value is

     *         non-zero to reduce the gas cost of message passing transactions.

     */

    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;



    /**

     * @notice Returns the default values for the ResourceConfig. These are the recommended values

     *         for a production network.

     */

    function DEFAULT_RESOURCE_CONFIG()

        internal

        pure

        returns (ResourceMetering.ResourceConfig memory)

    {

        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({

            maxResourceLimit: 20_000_000,

            elasticityMultiplier: 10,

            baseFeeMaxChangeDenominator: 8,

            minimumBaseFee: 1 gwei,

            systemTxMaxGas: 1_000_000,

            maximumBaseFee: type(uint128).max

        });

        return config;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity >=0.6.0 <0.8.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\ContextUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)



pragma solidity ^0.8.0;

import "../proxy/utils/Initializable.sol";



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract ContextUpgradeable is Initializable {

    function __Context_init() internal onlyInitializing {

    }



    function __Context_init_unchained() internal onlyInitializing {

    }

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[50] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\CrossDomainEnabled.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/* Interface Imports */

import { ICrossDomainMessenger } from "./ICrossDomainMessenger.sol";



/**

 * @title CrossDomainEnabled

 * @dev Helper contract for contracts performing cross-domain communications

 *

 * Compiler used: defined by inheriting contract

 * Runtime target: defined by inheriting contract

 */

contract CrossDomainEnabled {

    /*************

     * Variables *

     *************/



    // Messenger contract used to send and recieve messages from the other domain.

    address public messenger;



    /***************

     * Constructor *

     ***************/



    /**

     * @param _messenger Address of the CrossDomainMessenger on the current layer.

     */

    constructor(address _messenger) {

        messenger = _messenger;

    }



    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Enforces that the modified function is only callable by a specific cross-domain account.

     * @param _sourceDomainAccount The only account on the originating domain which is

     *  authenticated to call this function.

     */

    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {

        require(

            msg.sender == address(getCrossDomainMessenger()),

            "OVM_XCHAIN: messenger contract unauthenticated"

        );



        require(

            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,

            "OVM_XCHAIN: wrong sender of cross-domain message"

        );



        _;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Gets the messenger, usually from storage. This function is exposed in case a child contract

     * needs to override.

     * @return The address of the cross-domain messenger contract which should be used.

     */

    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {

        return ICrossDomainMessenger(messenger);

    }



    /**q

     * Sends a message to an account on another domain

     * @param _crossDomainTarget The intended recipient on the destination domain

     * @param _message The data to send to the target (usually calldata to a function with

     *  `onlyFromCrossDomainAccount()`)

     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.

     */

    function sendCrossDomainMessage(

        address _crossDomainTarget,

        uint32 _gasLimit,

        bytes memory _message

    ) internal {

        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\CrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



import { Initializable } from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import { SafeCall } from "../libraries/SafeCall.sol";

import { Hashing } from "../libraries/Hashing.sol";

import { Encoding } from "../libraries/Encoding.sol";

import { Constants } from "../libraries/Constants.sol";



/**

 * @custom:legacy

 * @title CrossDomainMessengerLegacySpacer0

 * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the

 *         libAddressManager variable used to exist. Must be the first contract in the inheritance

 *         tree of the CrossDomainMessenger.

 */

contract CrossDomainMessengerLegacySpacer0 {

    /**

     * @custom:legacy

     * @custom:spacer libAddressManager

     * @notice Spacer for backwards compatibility.

     */

    address private spacer_0_0_20;

}



/**

 * @custom:legacy

 * @title CrossDomainMessengerLegacySpacer1

 * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the

 *         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be

 *         the third contract in the inheritance tree of the CrossDomainMessenger.

 */

contract CrossDomainMessengerLegacySpacer1 {

    /**

     * @custom:legacy

     * @custom:spacer ContextUpgradable's __gap

     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin

     *         ContextUpgradable.

     *

     */

    uint256[50] private spacer_1_0_1600;



    /**

     * @custom:legacy

     * @custom:spacer OwnableUpgradeable's _owner

     * @notice Spacer for backwards compatibility.

     *         Come from OpenZeppelin OwnableUpgradeable.

     */

    address private spacer_51_0_20;



    /**

     * @custom:legacy

     * @custom:spacer OwnableUpgradeable's __gap

     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin

     *         OwnableUpgradeable.

     */

    uint256[49] private spacer_52_0_1568;



    /**

     * @custom:legacy

     * @custom:spacer PausableUpgradable's _paused

     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin

     *         PausableUpgradable.

     */

    bool private spacer_101_0_1;



    /**

     * @custom:legacy

     * @custom:spacer PausableUpgradable's __gap

     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin

     *         PausableUpgradable.

     */

    uint256[49] private spacer_102_0_1568;



    /**

     * @custom:legacy

     * @custom:spacer ReentrancyGuardUpgradeable's `_status` field.

     * @notice Spacer for backwards compatibility.

     */

    uint256 private spacer_151_0_32;



    /**

     * @custom:legacy

     * @custom:spacer ReentrancyGuardUpgradeable's __gap

     * @notice Spacer for backwards compatibility.

     */

    uint256[49] private spacer_152_0_1568;



    /**

     * @custom:legacy

     * @custom:spacer blockedMessages

     * @notice Spacer for backwards compatibility.

     */

    mapping(bytes32 => bool) private spacer_201_0_32;



    /**

     * @custom:legacy

     * @custom:spacer relayedMessages

     * @notice Spacer for backwards compatibility.

     */

    mapping(bytes32 => bool) private spacer_202_0_32;

}



/**

 * @custom:upgradeable

 * @title CrossDomainMessenger

 * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2

 *         cross-chain messenger contracts. It's designed to be a universal interface that only

 *         needs to be extended slightly to provide low-level message passing functionality on each

 *         chain it's deployed on. Currently only designed for message passing between two paired

 *         chains and does not support one-to-many interactions.

 *

 *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.

 */

abstract contract CrossDomainMessenger is

    CrossDomainMessengerLegacySpacer0,

    Initializable,

    CrossDomainMessengerLegacySpacer1

{

    /**

     * @notice Current message version identifier.

     */

    uint16 public constant MESSAGE_VERSION = 1;



    /**

     * @notice Constant overhead added to the base gas for a message.

     */

    uint64 public constant RELAY_CONSTANT_OVERHEAD = 200_000;



    /**

     * @notice Numerator for dynamic overhead added to the base gas for a message.

     */

    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 64;



    /**

     * @notice Denominator for dynamic overhead added to the base gas for a message.

     */

    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 63;



    /**

     * @notice Extra gas added to base gas for each byte of calldata in a message.

     */

    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;



    /**

     * @notice Gas reserved for performing the external call in `relayMessage`.

     */

    uint64 public constant RELAY_CALL_OVERHEAD = 40_000;



    /**

     * @notice Gas reserved for finalizing the execution of `relayMessage` after the safe call.

     */

    uint64 public constant RELAY_RESERVED_GAS = 40_000;



    /**

     * @notice Gas reserved for the execution between the `hasMinGas` check and the external

     *         call in `relayMessage`.

     */

    uint64 public constant RELAY_GAS_CHECK_BUFFER = 5_000;



    /**

     * @notice Address of the paired CrossDomainMessenger contract on the other chain.

     */

    address public immutable OTHER_MESSENGER;



    /**

     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only

     *         be present in this mapping if it has successfully been relayed on this chain, and

     *         can therefore not be relayed again.

     */

    mapping(bytes32 => bool) public successfulMessages;



    /**

     * @notice Address of the sender of the currently executing message on the other chain. If the

     *         value of this variable is the default value (0x00000000...dead) then no message is

     *         currently being executed. Use the xDomainMessageSender getter which will throw an

     *         error if this is the case.

     */

    address internal xDomainMsgSender;



    /**

     * @notice Nonce for the next message to be sent, without the message version applied. Use the

     *         messageNonce getter which will insert the message version into the nonce to give you

     *         the actual nonce to be used for the message.

     */

    uint240 internal msgNonce;



    /**

     * @notice Mapping of message hashes to a boolean if and only if the message has failed to be

     *         executed at least once. A message will not be present in this mapping if it

     *         successfully executed on the first attempt.

     */

    mapping(bytes32 => bool) public failedMessages;



    /**

     * @notice Reserve extra slots in the storage layout for future upgrades.

     *         A gap size of 41 was chosen here, so that the first slot used in a child contract

     *         would be a multiple of 50.

     */

    uint256[42] private __gap;



    /**

     * @notice Emitted whenever a message is sent to the other chain.

     *

     * @param target       Address of the recipient of the message.

     * @param sender       Address of the sender of the message.

     * @param message      Message to trigger the recipient address with.

     * @param messageNonce Unique nonce attached to the message.

     * @param gasLimit     Minimum gas limit that the message can be executed with.

     */

    event SentMessage(

        address indexed target,

        address sender,

        bytes message,

        uint256 messageNonce,

        uint256 gasLimit

    );



    /**

     * @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the

     *         SentMessage event without breaking the ABI of this contract, this is good enough.

     *

     * @param sender Address of the sender of the message.

     * @param value  ETH value sent along with the message to the recipient.

     */

    event SentMessageExtension1(address indexed sender, uint256 value);



    /**

     * @notice Emitted whenever a message is successfully relayed on this chain.

     *

     * @param msgHash Hash of the message that was relayed.

     */

    event RelayedMessage(bytes32 indexed msgHash);



    /**

     * @notice Emitted whenever a message fails to be relayed on this chain.

     *

     * @param msgHash Hash of the message that failed to be relayed.

     */

    event FailedRelayedMessage(bytes32 indexed msgHash);



    /**

     * @param _otherMessenger Address of the messenger on the paired chain.

     */

    constructor(address _otherMessenger) {

        OTHER_MESSENGER = _otherMessenger;

    }



    /**

     * @notice Sends a message to some target address on the other chain. Note that if the call

     *         always reverts, then the message will be unrelayable, and any ETH sent will be

     *         permanently locked. The same will occur if the target on the other chain is

     *         considered unsafe (see the _isUnsafeTarget() function).

     *

     * @param _target      Target contract or wallet address.

     * @param _message     Message to trigger the target address with.

     * @param _minGasLimit Minimum gas limit that the message can be executed with.

     */

    function sendMessage(

        address _target,

        bytes calldata _message,

        uint32 _minGasLimit

    ) external payable {

        // Triggers a message to the other messenger. Note that the amount of gas provided to the

        // message is the amount of gas requested by the user PLUS the base gas value. We want to

        // guarantee the property that the call to the target contract will always have at least

        // the minimum gas limit specified by the user.

        _sendMessage(

            OTHER_MESSENGER,

            baseGas(_message, _minGasLimit),

            msg.value,

            abi.encodeWithSelector(

                this.relayMessage.selector,

                messageNonce(),

                msg.sender,

                _target,

                msg.value,

                _minGasLimit,

                _message

            )

        );



        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);

        emit SentMessageExtension1(msg.sender, msg.value);



        unchecked {

            ++msgNonce;

        }

    }



    /**

     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only

     *         be executed via cross-chain call from the other messenger OR if the message was

     *         already received once and is currently being replayed.

     *

     * @param _nonce       Nonce of the message being relayed.

     * @param _sender      Address of the user who sent the message.

     * @param _target      Address that the message is targeted at.

     * @param _value       ETH value to send with the message.

     * @param _minGasLimit Minimum amount of gas that the message can be executed with.

     * @param _message     Message to send to the target.

     */

    function relayMessage(

        uint256 _nonce,

        address _sender,

        address _target,

        uint256 _value,

        uint256 _minGasLimit,

        bytes calldata _message

    ) external payable {

        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);

        require(

            version < 2,

            "CrossDomainMessenger: only version 0 or 1 messages are supported at this time"

        );



        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need

        // to check that the legacy version of the message has not already been relayed.

        if (version == 0) {

            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);

            require(

                successfulMessages[oldHash] == false,

                "CrossDomainMessenger: legacy withdrawal already relayed"

            );

        }



        // We use the v1 message hash as the unique identifier for the message because it commits

        // to the value and minimum gas limit of the message.

        bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(

            _nonce,

            _sender,

            _target,

            _value,

            _minGasLimit,

            _message

        );



        if (_isOtherMessenger()) {

            // These properties should always hold when the message is first submitted (as

            // opposed to being replayed).

            assert(msg.value == _value);

            assert(!failedMessages[versionedHash]);

        } else {

            require(

                msg.value == 0,

                "CrossDomainMessenger: value must be zero unless message is from a system address"

            );



            require(

                failedMessages[versionedHash],

                "CrossDomainMessenger: message cannot be replayed"

            );

        }



        require(

            _isUnsafeTarget(_target) == false,

            "CrossDomainMessenger: cannot send message to blocked system address"

        );



        require(

            successfulMessages[versionedHash] == false,

            "CrossDomainMessenger: message has already been relayed"

        );



        // If there is not enough gas left to perform the external call and finish the execution,

        // return early and assign the message to the failedMessages mapping.

        // We are asserting that we have enough gas to:

        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)

        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.

        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).

        //

        // If `xDomainMsgSender` is not the default L2 sender, this function

        // is being re-entered. This marks the message as failed to allow it to be replayed.

        if (

            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER) ||

            xDomainMsgSender != Constants.DEFAULT_L2_SENDER

        ) {

            failedMessages[versionedHash] = true;

            emit FailedRelayedMessage(versionedHash);



            // Revert in this case if the transaction was triggered by the estimation address. This

            // should only be possible during gas estimation or we have bigger problems. Reverting

            // here will make the behavior of gas estimation change such that the gas limit

            // computed will be the amount required to relay the message, even if that amount is

            // greater than the minimum gas limit specified by the user.

            if (tx.origin == Constants.ESTIMATION_ADDRESS) {

                revert("CrossDomainMessenger: failed to relay message");

            }



            return;

        }



        xDomainMsgSender = _sender;

        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _value, _message);

        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;



        if (success) {

            successfulMessages[versionedHash] = true;

            emit RelayedMessage(versionedHash);

        } else {

            failedMessages[versionedHash] = true;

            emit FailedRelayedMessage(versionedHash);



            // Revert in this case if the transaction was triggered by the estimation address. This

            // should only be possible during gas estimation or we have bigger problems. Reverting

            // here will make the behavior of gas estimation change such that the gas limit

            // computed will be the amount required to relay the message, even if that amount is

            // greater than the minimum gas limit specified by the user.

            if (tx.origin == Constants.ESTIMATION_ADDRESS) {

                revert("CrossDomainMessenger: failed to relay message");

            }

        }

    }



    /**

     * @notice Retrieves the address of the contract or wallet that initiated the currently

     *         executing message on the other chain. Will throw an error if there is no message

     *         currently being executed. Allows the recipient of a call to see who triggered it.

     *

     * @return Address of the sender of the currently executing message on the other chain.

     */

    function xDomainMessageSender() external view returns (address) {

        require(

            xDomainMsgSender != Constants.DEFAULT_L2_SENDER,

            "CrossDomainMessenger: xDomainMessageSender is not set"

        );



        return xDomainMsgSender;

    }



    /**

     * @notice Retrieves the next message nonce. Message version will be added to the upper two

     *         bytes of the message nonce. Message version allows us to treat messages as having

     *         different structures.

     *

     * @return Nonce of the next message to be sent, with added message version.

     */

    function messageNonce() public view returns (uint256) {

        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);

    }



    /**

     * @notice Computes the amount of gas required to guarantee that a given message will be

     *         received on the other chain without running out of gas. Guaranteeing that a message

     *         will not run out of gas is important because this ensures that a message can always

     *         be replayed on the other chain if it fails to execute completely.

     *

     * @param _message     Message to compute the amount of required gas for.

     * @param _minGasLimit Minimum desired gas limit when message goes to target.

     *

     * @return Amount of gas required to guarantee message receipt.

     */

    function baseGas(bytes calldata _message, uint32 _minGasLimit) public pure returns (uint64) {

        return

            // Constant overhead

            RELAY_CONSTANT_OVERHEAD +

            // Calldata overhead

            (uint64(_message.length) * MIN_GAS_CALLDATA_OVERHEAD) +

            // Dynamic overhead (EIP-150)

            ((_minGasLimit * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) /

                MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR) +

            // Gas reserved for the worst-case cost of 3/5 of the `CALL` opcode's dynamic gas

            // factors. (Conservative)

            RELAY_CALL_OVERHEAD +

            // Relay reserved gas (to ensure execution of `relayMessage` completes after the

            // subcontext finishes executing) (Conservative)

            RELAY_RESERVED_GAS +

            // Gas reserved for the execution between the `hasMinGas` check and the `CALL`

            // opcode. (Conservative)

            RELAY_GAS_CHECK_BUFFER;

    }



    /**

     * @notice Intializer.

     */

    // solhint-disable-next-line func-name-mixedcase

    function __CrossDomainMessenger_init() internal onlyInitializing {

        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;

    }



    /**

     * @notice Sends a low-level message to the other messenger. Needs to be implemented by child

     *         contracts because the logic for this depends on the network where the messenger is

     *         being deployed.

     *

     * @param _to       Recipient of the message on the other chain.

     * @param _gasLimit Minimum gas limit the message can be executed with.

     * @param _value    Amount of ETH to send with the message.

     * @param _data     Message data.

     */

    function _sendMessage(

        address _to,

        uint64 _gasLimit,

        uint256 _value,

        bytes memory _data

    ) internal virtual;



    /**

     * @notice Checks whether the message is coming from the other messenger. Implemented by child

     *         contracts because the logic for this depends on the network where the messenger is

     *         being deployed.

     *

     * @return Whether the message is coming from the other messenger.

     */

    function _isOtherMessenger() internal view virtual returns (bool);



    /**

     * @notice Checks whether a given call target is a system address that could cause the

     *         messenger to peform an unsafe action. This is NOT a mechanism for blocking user

     *         addresses. This is ONLY used to prevent the execution of messages to specific

     *         system addresses that could cause security issues, e.g., having the

     *         CrossDomainMessenger send messages to itself.

     *

     * @param _target Address of the contract to check.

     *

     * @return Whether or not the address is an unsafe system address.

     */

    function _isUnsafeTarget(address _target) internal view virtual returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\draft-IERC20Permit.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in

 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].

 *

 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by

 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't

 * need to send a transaction, and thus is not required to hold Ether at all.

 */

interface IERC20Permit {

    /**

     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,

     * given ``owner``'s signed approval.

     *

     * IMPORTANT: The same issues {IERC20-approve} has related to transaction

     * ordering also apply here.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `deadline` must be a timestamp in the future.

     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`

     * over the EIP712-formatted function arguments.

     * - the signature must use ``owner``'s current nonce (see {nonces}).

     *

     * For more information on the signature format, see the

     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP

     * section].

     */

    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external;



    /**

     * @dev Returns the current nonce for `owner`. This value must be

     * included whenever a signature is generated for {permit}.

     *

     * Every successful call to {permit} increases ``owner``'s nonce by one. This

     * prevents a signature from being used multiple times.

     */

    function nonces(address owner) external view returns (uint256);



    /**

     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.

     */

    // solhint-disable-next-line func-name-mixedcase

    function DOMAIN_SEPARATOR() external view returns (bytes32);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Encoding.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import { Types } from "./Types.sol";

import { Hashing } from "./Hashing.sol";

import { RLPWriter } from "./rlp/RLPWriter.sol";



/**

 * @title Encoding

 * @notice Encoding handles Optimism's various different encoding schemes.

 */

library Encoding {

    /**

     * @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent

     *         to the L2 system. Useful for searching for a deposit in the L2 system. The

     *         transaction is prefixed with 0x7e to identify its EIP-2718 type.

     *

     * @param _tx User deposit transaction to encode.

     *

     * @return RLP encoded L2 deposit transaction.

     */

    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx)

        internal

        pure

        returns (bytes memory)

    {

        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);

        bytes[] memory raw = new bytes[](8);

        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));

        raw[1] = RLPWriter.writeAddress(_tx.from);

        raw[2] = _tx.isCreation ? RLPWriter.writeBytes("") : RLPWriter.writeAddress(_tx.to);

        raw[3] = RLPWriter.writeUint(_tx.mint);

        raw[4] = RLPWriter.writeUint(_tx.value);

        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));

        raw[6] = RLPWriter.writeBool(false);

        raw[7] = RLPWriter.writeBytes(_tx.data);

        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));

    }



    /**

     * @notice Encodes the cross domain message based on the version that is encoded into the

     *         message nonce.

     *

     * @param _nonce    Message nonce with version encoded into the first two bytes.

     * @param _sender   Address of the sender of the message.

     * @param _target   Address of the target of the message.

     * @param _value    ETH value to send to the target.

     * @param _gasLimit Gas limit to use for the message.

     * @param _data     Data to send with the message.

     *

     * @return Encoded cross domain message.

     */

    function encodeCrossDomainMessage(

        uint256 _nonce,

        address _sender,

        address _target,

        uint256 _value,

        uint256 _gasLimit,

        bytes memory _data

    ) internal pure returns (bytes memory) {

        (, uint16 version) = decodeVersionedNonce(_nonce);

        if (version == 0) {

            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);

        } else if (version == 1) {

            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);

        } else {

            revert("Encoding: unknown cross domain message version");

        }

    }



    /**

     * @notice Encodes a cross domain message based on the V0 (legacy) encoding.

     *

     * @param _target Address of the target of the message.

     * @param _sender Address of the sender of the message.

     * @param _data   Data to send with the message.

     * @param _nonce  Message nonce.

     *

     * @return Encoded cross domain message.

     */

    function encodeCrossDomainMessageV0(

        address _target,

        address _sender,

        bytes memory _data,

        uint256 _nonce

    ) internal pure returns (bytes memory) {

        return

            abi.encodeWithSignature(

                "relayMessage(address,address,bytes,uint256)",

                _target,

                _sender,

                _data,

                _nonce

            );

    }



    /**

     * @notice Encodes a cross domain message based on the V1 (current) encoding.

     *

     * @param _nonce    Message nonce.

     * @param _sender   Address of the sender of the message.

     * @param _target   Address of the target of the message.

     * @param _value    ETH value to send to the target.

     * @param _gasLimit Gas limit to use for the message.

     * @param _data     Data to send with the message.

     *

     * @return Encoded cross domain message.

     */

    function encodeCrossDomainMessageV1(

        uint256 _nonce,

        address _sender,

        address _target,

        uint256 _value,

        uint256 _gasLimit,

        bytes memory _data

    ) internal pure returns (bytes memory) {

        return

            abi.encodeWithSignature(

                "relayMessage(uint256,address,address,uint256,uint256,bytes)",

                _nonce,

                _sender,

                _target,

                _value,

                _gasLimit,

                _data

            );

    }



    /**

     * @notice Adds a version number into the first two bytes of a message nonce.

     *

     * @param _nonce   Message nonce to encode into.

     * @param _version Version number to encode into the message nonce.

     *

     * @return Message nonce with version encoded into the first two bytes.

     */

    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {

        uint256 nonce;

        assembly {

            nonce := or(shl(240, _version), _nonce)

        }

        return nonce;

    }



    /**

     * @notice Pulls the version out of a version-encoded nonce.

     *

     * @param _nonce Message nonce with version encoded into the first two bytes.

     *

     * @return Nonce without encoded version.

     * @return Version of the message.

     */

    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {

        uint240 nonce;

        uint16 version;

        assembly {

            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)

            version := shr(240, _nonce)

        }

        return (nonce, version);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\ERC165Checker.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * @dev Library used to query support of an interface declared via {IERC165}.

 *

 * Note that these functions return the actual result of the query: they do not

 * `revert` if an interface is not supported. It is up to the caller to decide

 * what to do in these cases.

 */

library ERC165Checker {

    // As per the EIP-165 spec, no interface should ever match 0xffffffff

    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;



    /**

     * @dev Returns true if `account` supports the {IERC165} interface,

     */

    function supportsERC165(address account) internal view returns (bool) {

        // Any contract that implements ERC165 must explicitly indicate support of

        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid

        return

            _supportsERC165Interface(account, type(IERC165).interfaceId) &&

            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);

    }



    /**

     * @dev Returns true if `account` supports the interface defined by

     * `interfaceId`. Support for {IERC165} itself is queried automatically.

     *

     * See {IERC165-supportsInterface}.

     */

    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {

        // query support of both ERC165 as per the spec and support of _interfaceId

        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);

    }



    /**

     * @dev Returns a boolean array where each value corresponds to the

     * interfaces passed in and whether they're supported or not. This allows

     * you to batch check interfaces for a contract where your expectation

     * is that some interfaces may not be supported.

     *

     * See {IERC165-supportsInterface}.

     *

     * _Available since v3.4._

     */

    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)

        internal

        view

        returns (bool[] memory)

    {

        // an array of booleans corresponding to interfaceIds and whether they're supported or not

        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);



        // query support of ERC165 itself

        if (supportsERC165(account)) {

            // query support of each interface in interfaceIds

            for (uint256 i = 0; i < interfaceIds.length; i++) {

                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);

            }

        }



        return interfaceIdsSupported;

    }



    /**

     * @dev Returns true if `account` supports all the interfaces defined in

     * `interfaceIds`. Support for {IERC165} itself is queried automatically.

     *

     * Batch-querying can lead to gas savings by skipping repeated checks for

     * {IERC165} support.

     *

     * See {IERC165-supportsInterface}.

     */

    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {

        // query support of ERC165 itself

        if (!supportsERC165(account)) {

            return false;

        }



        // query support of each interface in _interfaceIds

        for (uint256 i = 0; i < interfaceIds.length; i++) {

            if (!_supportsERC165Interface(account, interfaceIds[i])) {

                return false;

            }

        }



        // all interfaces supported

        return true;

    }



    /**

     * @notice Query if a contract implements an interface, does not check ERC165 support

     * @param account The address of the contract to query for support of an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @return true if the contract at account indicates support of the interface with

     * identifier interfaceId, false otherwise

     * @dev Assumes that account contains a contract that supports ERC165, otherwise

     * the behavior of this method is undefined. This precondition can be checked

     * with {supportsERC165}.

     * Interface identification is specified in ERC-165.

     */

    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {

        // prepare call

        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);



        // perform static call

        bool success;

        uint256 returnSize;

        uint256 returnValue;

        assembly {

            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)

            returnSize := returndatasize()

            returnValue := mload(0x00)

        }



        return success && returnSize >= 0x20 && returnValue > 0;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\ERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)



pragma solidity ^0.8.0;



import "./IERC20.sol";

import "./extensions/IERC20Metadata.sol";

import "../../utils/Context.sol";



/**

 * @dev Implementation of the {IERC20} interface.

 *

 * This implementation is agnostic to the way tokens are created. This means

 * that a supply mechanism has to be added in a derived contract using {_mint}.

 * For a generic mechanism see {ERC20PresetMinterPauser}.

 *

 * TIP: For a detailed writeup see our guide

 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How

 * to implement supply mechanisms].

 *

 * We have followed general OpenZeppelin Contracts guidelines: functions revert

 * instead returning `false` on failure. This behavior is nonetheless

 * conventional and does not conflict with the expectations of ERC20

 * applications.

 *

 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.

 * This allows applications to reconstruct the allowance for all accounts just

 * by listening to said events. Other implementations of the EIP may not emit

 * these events, as it isn't required by the specification.

 *

 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}

 * functions have been added to mitigate the well-known issues around setting

 * allowances. See {IERC20-approve}.

 */

contract ERC20 is Context, IERC20, IERC20Metadata {

    mapping(address => uint256) private _balances;



    mapping(address => mapping(address => uint256)) private _allowances;



    uint256 private _totalSupply;



    string private _name;

    string private _symbol;



    /**

     * @dev Sets the values for {name} and {symbol}.

     *

     * The default value of {decimals} is 18. To select a different value for

     * {decimals} you should overload it.

     *

     * All two of these values are immutable: they can only be set once during

     * construction.

     */

    constructor(string memory name_, string memory symbol_) {

        _name = name_;

        _symbol = symbol_;

    }



    /**

     * @dev Returns the name of the token.

     */

    function name() public view virtual override returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view virtual override returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5.05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei. This is the value {ERC20} uses, unless this function is

     * overridden;

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view virtual override returns (uint8) {

        return 18;

    }



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view virtual override returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view virtual override returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address to, uint256 amount) public virtual override returns (bool) {

        address owner = _msgSender();

        _transfer(owner, to, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on

     * `transferFrom`. This is semantically equivalent to an infinite approval.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        address owner = _msgSender();

        _approve(owner, spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20}.

     *

     * NOTE: Does not update the allowance if the current allowance

     * is the maximum `uint256`.

     *

     * Requirements:

     *

     * - `from` and `to` cannot be the zero address.

     * - `from` must have a balance of at least `amount`.

     * - the caller must have allowance for ``from``'s tokens of at least

     * `amount`.

     */

    function transferFrom(

        address from,

        address to,

        uint256 amount

    ) public virtual override returns (bool) {

        address spender = _msgSender();

        _spendAllowance(from, spender, amount);

        _transfer(from, to, amount);

        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        address owner = _msgSender();

        _approve(owner, spender, allowance(owner, spender) + addedValue);

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        address owner = _msgSender();

        uint256 currentAllowance = allowance(owner, spender);

        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");

        unchecked {

            _approve(owner, spender, currentAllowance - subtractedValue);

        }



        return true;

    }



    /**

     * @dev Moves `amount` of tokens from `from` to `to`.

     *

     * This internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `from` must have a balance of at least `amount`.

     */

    function _transfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual {

        require(from != address(0), "ERC20: transfer from the zero address");

        require(to != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(from, to, amount);



        uint256 fromBalance = _balances[from];

        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");

        unchecked {

            _balances[from] = fromBalance - amount;

        }

        _balances[to] += amount;



        emit Transfer(from, to, amount);



        _afterTokenTransfer(from, to, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply += amount;

        _balances[account] += amount;

        emit Transfer(address(0), account, amount);



        _afterTokenTransfer(address(0), account, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        uint256 accountBalance = _balances[account];

        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");

        unchecked {

            _balances[account] = accountBalance - amount;

        }

        _totalSupply -= amount;



        emit Transfer(account, address(0), amount);



        _afterTokenTransfer(account, address(0), amount);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.

     *

     * This internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(

        address owner,

        address spender,

        uint256 amount

    ) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    /**

     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.

     *

     * Does not update the allowance amount in case of infinite allowance.

     * Revert if not enough allowance is available.

     *

     * Might emit an {Approval} event.

     */

    function _spendAllowance(

        address owner,

        address spender,

        uint256 amount

    ) internal virtual {

        uint256 currentAllowance = allowance(owner, spender);

        if (currentAllowance != type(uint256).max) {

            require(currentAllowance >= amount, "ERC20: insufficient allowance");

            unchecked {

                _approve(owner, spender, currentAllowance - amount);

            }

        }

    }



    /**

     * @dev Hook that is called before any transfer of tokens. This includes

     * minting and burning.

     *

     * Calling conditions:

     *

     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * will be transferred to `to`.

     * - when `from` is zero, `amount` tokens will be minted for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.

     * - `from` and `to` are never both zero.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual {}



    /**

     * @dev Hook that is called after any transfer of tokens. This includes

     * minting and burning.

     *

     * Calling conditions:

     *

     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * has been transferred to `to`.

     * - when `from` is zero, `amount` tokens have been minted for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.

     * - `from` and `to` are never both zero.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _afterTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\FixedPointMathLib.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;



/// @notice Arithmetic library with operations for fixed-point numbers.

/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)

library FixedPointMathLib {

    /*//////////////////////////////////////////////////////////////

                    SIMPLIFIED FIXED POINT OPERATIONS

    //////////////////////////////////////////////////////////////*/



    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.



    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {

        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.

    }



    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {

        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.

    }



    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {

        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.

    }



    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {

        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.

    }



    function powWad(int256 x, int256 y) internal pure returns (int256) {

        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)

        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.

    }



    function expWad(int256 x) internal pure returns (int256 r) {

        unchecked {

            // When the result is < 0.5 we return zero. This happens when

            // x <= floor(log(0.5e18) * 1e18) ~ -42e18

            if (x <= -42139678854452767551) return 0;



            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an

            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.

            if (x >= 135305999368893231589) revert("EXP_OVERFLOW");



            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96

            // for more intermediate precision and a binary basis. This base conversion

            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.

            x = (x << 78) / 5**18;



            // Reduce range of x to (-? ln 2, ? ln 2) * 2**96 by factoring out powers

            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.

            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).

            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;

            x = x - k * 54916777467707473351141471128;



            // k is in the range [-61, 195].



            // Evaluate using a (6, 7)-term rational approximation.

            // p is made monic, we'll multiply by a scale factor later.

            int256 y = x + 1346386616545796478920950773328;

            y = ((y * x) >> 96) + 57155421227552351082224309758442;

            int256 p = y + x - 94201549194550492254356042504812;

            p = ((p * y) >> 96) + 28719021644029726153956944680412240;

            p = p * x + (4385272521454847904659076985693276 << 96);



            // We leave p in 2**192 basis so we don't need to scale it back up for the division.

            int256 q = x - 2855989394907223263936484059900;

            q = ((q * x) >> 96) + 50020603652535783019961831881945;

            q = ((q * x) >> 96) - 533845033583426703283633433725380;

            q = ((q * x) >> 96) + 3604857256930695427073651918091429;

            q = ((q * x) >> 96) - 14423608567350463180887372962807573;

            q = ((q * x) >> 96) + 26449188498355588339934803723976023;



            assembly {

                // Div in assembly because solidity adds a zero check despite the unchecked.

                // The q polynomial won't have zeros in the domain as all its roots are complex.

                // No scaling is necessary because p is already 2**96 too large.

                r := sdiv(p, q)

            }



            // r should be in the range (0.09, 0.25) * 2**96.



            // We now need to multiply r by:

            // * the scale factor s = ~6.031367120.

            // * the 2**k factor from the range reduction.

            // * the 1e18 / 2**96 factor for base conversion.

            // We do this all at once, with an intermediate result in 2**213

            // basis, so the final right shift is always by a positive amount.

            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));

        }

    }



    function lnWad(int256 x) internal pure returns (int256 r) {

        unchecked {

            require(x > 0, "UNDEFINED");



            // We want to convert x from 10**18 fixed point to 2**96 fixed point.

            // We do this by multiplying by 2**96 / 10**18. But since

            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here

            // and add ln(2**96 / 10**18) at the end.



            // Reduce range of x to (1, 2) * 2**96

            // ln(2^k * x) = k * ln(2) + ln(x)

            int256 k = int256(log2(uint256(x))) - 96;

            x <<= uint256(159 - k);

            x = int256(uint256(x) >> 159);



            // Evaluate using a (8, 8)-term rational approximation.

            // p is made monic, we will multiply by a scale factor later.

            int256 p = x + 3273285459638523848632254066296;

            p = ((p * x) >> 96) + 24828157081833163892658089445524;

            p = ((p * x) >> 96) + 43456485725739037958740375743393;

            p = ((p * x) >> 96) - 11111509109440967052023855526967;

            p = ((p * x) >> 96) - 45023709667254063763336534515857;

            p = ((p * x) >> 96) - 14706773417378608786704636184526;

            p = p * x - (795164235651350426258249787498 << 96);



            // We leave p in 2**192 basis so we don't need to scale it back up for the division.

            // q is monic by convention.

            int256 q = x + 5573035233440673466300451813936;

            q = ((q * x) >> 96) + 71694874799317883764090561454958;

            q = ((q * x) >> 96) + 283447036172924575727196451306956;

            q = ((q * x) >> 96) + 401686690394027663651624208769553;

            q = ((q * x) >> 96) + 204048457590392012362485061816622;

            q = ((q * x) >> 96) + 31853899698501571402653359427138;

            q = ((q * x) >> 96) + 909429971244387300277376558375;

            assembly {

                // Div in assembly because solidity adds a zero check despite the unchecked.

                // The q polynomial is known not to have zeros in the domain.

                // No scaling required because p is already 2**96 too large.

                r := sdiv(p, q)

            }



            // r is in the range (0, 0.125) * 2**96



            // Finalization, we need to:

            // * multiply by the scale factor s = 5.549

            // * add ln(2**96 / 10**18)

            // * add k * ln(2)

            // * multiply by 10**18 / 2**96 = 5**18 >> 78



            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192

            r *= 1677202110996718588342820967067443963516166;

            // add ln(2) * k * 5e18 * 2**192

            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;

            // add ln(2**96 / 10**18) * 5e18 * 2**192

            r += 600920179829731861736702779321621459595472258049074101567377883020018308;

            // base conversion: mul 2**18 / 2**192

            r >>= 174;

        }

    }



    /*//////////////////////////////////////////////////////////////

                    LOW LEVEL FIXED POINT OPERATIONS

    //////////////////////////////////////////////////////////////*/



    function mulDivDown(

        uint256 x,

        uint256 y,

        uint256 denominator

    ) internal pure returns (uint256 z) {

        assembly {

            // Store x * y in z for now.

            z := mul(x, y)



            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))

            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {

                revert(0, 0)

            }



            // Divide z by the denominator.

            z := div(z, denominator)

        }

    }



    function mulDivUp(

        uint256 x,

        uint256 y,

        uint256 denominator

    ) internal pure returns (uint256 z) {

        assembly {

            // Store x * y in z for now.

            z := mul(x, y)



            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))

            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {

                revert(0, 0)

            }



            // First, divide z - 1 by the denominator and add 1.

            // We allow z - 1 to underflow if z is 0, because we multiply the

            // end result by 0 if z is zero, ensuring we return 0 if z is zero.

            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))

        }

    }



    function rpow(

        uint256 x,

        uint256 n,

        uint256 scalar

    ) internal pure returns (uint256 z) {

        assembly {

            switch x

            case 0 {

                switch n

                case 0 {

                    // 0 ** 0 = 1

                    z := scalar

                }

                default {

                    // 0 ** n = 0

                    z := 0

                }

            }

            default {

                switch mod(n, 2)

                case 0 {

                    // If n is even, store scalar in z for now.

                    z := scalar

                }

                default {

                    // If n is odd, store x in z for now.

                    z := x

                }



                // Shifting right by 1 is like dividing by 2.

                let half := shr(1, scalar)



                for {

                    // Shift n right by 1 before looping to halve it.

                    n := shr(1, n)

                } n {

                    // Shift n right by 1 each iteration to halve it.

                    n := shr(1, n)

                } {

                    // Revert immediately if x ** 2 would overflow.

                    // Equivalent to iszero(eq(div(xx, x), x)) here.

                    if shr(128, x) {

                        revert(0, 0)

                    }



                    // Store x squared.

                    let xx := mul(x, x)



                    // Round to the nearest number.

                    let xxRound := add(xx, half)



                    // Revert if xx + half overflowed.

                    if lt(xxRound, xx) {

                        revert(0, 0)

                    }



                    // Set x to scaled xxRound.

                    x := div(xxRound, scalar)



                    // If n is even:

                    if mod(n, 2) {

                        // Compute z * x.

                        let zx := mul(z, x)



                        // If z * x overflowed:

                        if iszero(eq(div(zx, x), z)) {

                            // Revert if x is non-zero.

                            if iszero(iszero(x)) {

                                revert(0, 0)

                            }

                        }



                        // Round to the nearest number.

                        let zxRound := add(zx, half)



                        // Revert if zx + half overflowed.

                        if lt(zxRound, zx) {

                            revert(0, 0)

                        }



                        // Return properly scaled zxRound.

                        z := div(zxRound, scalar)

                    }

                }

            }

        }

    }



    /*//////////////////////////////////////////////////////////////

                        GENERAL NUMBER UTILITIES

    //////////////////////////////////////////////////////////////*/



    function sqrt(uint256 x) internal pure returns (uint256 z) {

        assembly {

            let y := x // We start y at x, which will help us make our initial estimate.



            z := 181 // The "correct" value is 1, but this saves a multiplication later.



            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad

            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.



            // We check y >= 2^(k + 8) but shift right by k bits

            // each branch to ensure that if x >= 256, then y >= 256.

            if iszero(lt(y, 0x10000000000000000000000000000000000)) {

                y := shr(128, y)

                z := shl(64, z)

            }

            if iszero(lt(y, 0x1000000000000000000)) {

                y := shr(64, y)

                z := shl(32, z)

            }

            if iszero(lt(y, 0x10000000000)) {

                y := shr(32, y)

                z := shl(16, z)

            }

            if iszero(lt(y, 0x1000000)) {

                y := shr(16, y)

                z := shl(8, z)

            }



            // Goal was to get z*z*y within a small factor of x. More iterations could

            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).

            // We ensured y >= 256 so that the relative difference between y and y+1 is small.

            // That's not possible if x < 256 but we can just verify those cases exhaustively.



            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.

            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.

            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.



            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range

            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.



            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate

            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.



            // There is no overflow risk here since y < 2^136 after the first branch above.

            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.



            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.

            z := shr(1, add(z, div(x, z)))

            z := shr(1, add(z, div(x, z)))

            z := shr(1, add(z, div(x, z)))

            z := shr(1, add(z, div(x, z)))

            z := shr(1, add(z, div(x, z)))

            z := shr(1, add(z, div(x, z)))

            z := shr(1, add(z, div(x, z)))



            // If x+1 is a perfect square, the Babylonian method cycles between

            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.

            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division

            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.

            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.

            z := sub(z, lt(div(x, z), z))

        }

    }



    function log2(uint256 x) internal pure returns (uint256 r) {

        require(x > 0, "UNDEFINED");



        assembly {

            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))

            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))

            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))

            r := or(r, shl(4, lt(0xffff, shr(r, x))))

            r := or(r, shl(3, lt(0xff, shr(r, x))))

            r := or(r, shl(2, lt(0xf, shr(r, x))))

            r := or(r, shl(1, lt(0x3, shr(r, x))))

            r := or(r, lt(0x1, shr(r, x)))

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Hashing.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import { Types } from "./Types.sol";

import { Encoding } from "./Encoding.sol";



/**

 * @title Hashing

 * @notice Hashing handles Optimism's various different hashing schemes.

 */

library Hashing {

    /**

     * @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a

     *         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2

     *         system.

     *

     * @param _tx User deposit transaction to hash.

     *

     * @return Hash of the RLP encoded L2 deposit transaction.

     */

    function hashDepositTransaction(Types.UserDepositTransaction memory _tx)

        internal

        pure

        returns (bytes32)

    {

        return keccak256(Encoding.encodeDepositTransaction(_tx));

    }



    /**

     * @notice Computes the deposit transaction's "source hash", a value that guarantees the hash

     *         of the L2 transaction that corresponds to a deposit is unique and is

     *         deterministically generated from L1 transaction data.

     *

     * @param _l1BlockHash Hash of the L1 block where the deposit was included.

     * @param _logIndex    The index of the log that created the deposit transaction.

     *

     * @return Hash of the deposit transaction's "source hash".

     */

    function hashDepositSource(bytes32 _l1BlockHash, uint256 _logIndex)

        internal

        pure

        returns (bytes32)

    {

        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));

        return keccak256(abi.encode(bytes32(0), depositId));

    }



    /**

     * @notice Hashes the cross domain message based on the version that is encoded into the

     *         message nonce.

     *

     * @param _nonce    Message nonce with version encoded into the first two bytes.

     * @param _sender   Address of the sender of the message.

     * @param _target   Address of the target of the message.

     * @param _value    ETH value to send to the target.

     * @param _gasLimit Gas limit to use for the message.

     * @param _data     Data to send with the message.

     *

     * @return Hashed cross domain message.

     */

    function hashCrossDomainMessage(

        uint256 _nonce,

        address _sender,

        address _target,

        uint256 _value,

        uint256 _gasLimit,

        bytes memory _data

    ) internal pure returns (bytes32) {

        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);

        if (version == 0) {

            return hashCrossDomainMessageV0(_target, _sender, _data, _nonce);

        } else if (version == 1) {

            return hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);

        } else {

            revert("Hashing: unknown cross domain message version");

        }

    }



    /**

     * @notice Hashes a cross domain message based on the V0 (legacy) encoding.

     *

     * @param _target Address of the target of the message.

     * @param _sender Address of the sender of the message.

     * @param _data   Data to send with the message.

     * @param _nonce  Message nonce.

     *

     * @return Hashed cross domain message.

     */

    function hashCrossDomainMessageV0(

        address _target,

        address _sender,

        bytes memory _data,

        uint256 _nonce

    ) internal pure returns (bytes32) {

        return keccak256(Encoding.encodeCrossDomainMessageV0(_target, _sender, _data, _nonce));

    }



    /**

     * @notice Hashes a cross domain message based on the V1 (current) encoding.

     *

     * @param _nonce    Message nonce.

     * @param _sender   Address of the sender of the message.

     * @param _target   Address of the target of the message.

     * @param _value    ETH value to send to the target.

     * @param _gasLimit Gas limit to use for the message.

     * @param _data     Data to send with the message.

     *

     * @return Hashed cross domain message.

     */

    function hashCrossDomainMessageV1(

        uint256 _nonce,

        address _sender,

        address _target,

        uint256 _value,

        uint256 _gasLimit,

        bytes memory _data

    ) internal pure returns (bytes32) {

        return

            keccak256(

                Encoding.encodeCrossDomainMessageV1(

                    _nonce,

                    _sender,

                    _target,

                    _value,

                    _gasLimit,

                    _data

                )

            );

    }



    /**

     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract

     *

     * @param _tx Withdrawal transaction to hash.

     *

     * @return Hashed withdrawal transaction.

     */

    function hashWithdrawal(Types.WithdrawalTransaction memory _tx)

        internal

        pure

        returns (bytes32)

    {

        return

            keccak256(

                abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data)

            );

    }



    /**

     * @notice Hashes the various elements of an output root proof into an output root hash which

     *         can be used to check if the proof is valid.

     *

     * @param _outputRootProof Output root proof which should hash to an output root.

     *

     * @return Hashed output root proof.

     */

    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof)

        internal

        pure

        returns (bytes32)

    {

        return

            keccak256(

                abi.encode(

                    _outputRootProof.version,

                    _outputRootProof.stateRoot,

                    _outputRootProof.messagePasserStorageRoot,

                    _outputRootProof.latestBlockhash

                )

            );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\ICanonicalTransactionChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/* Interface Imports */

import { IChainStorageContainer } from "./IChainStorageContainer.sol";



/**

 * @title ICanonicalTransactionChain

 */

interface ICanonicalTransactionChain {

    /**********

     * Events *

     **********/



    event L2GasParamsUpdated(

        uint256 l2GasDiscountDivisor,

        uint256 enqueueGasCost,

        uint256 enqueueL2GasPrepaid

    );



    event TransactionEnqueued(

        address indexed _l1TxOrigin,

        address indexed _target,

        uint256 _gasLimit,

        bytes _data,

        uint256 indexed _queueIndex,

        uint256 _timestamp

    );



    event QueueBatchAppended(

        uint256 _startingQueueIndex,

        uint256 _numQueueElements,

        uint256 _totalElements

    );



    event SequencerBatchAppended(

        uint256 _startingQueueIndex,

        uint256 _numQueueElements,

        uint256 _totalElements

    );



    event TransactionBatchAppended(

        uint256 indexed _batchIndex,

        bytes32 _batchRoot,

        uint256 _batchSize,

        uint256 _prevTotalElements,

        bytes _extraData

    );



    /***********

     * Structs *

     ***********/



    struct BatchContext {

        uint256 numSequencedTransactions;

        uint256 numSubsequentQueueTransactions;

        uint256 timestamp;

        uint256 blockNumber;

    }



    /*******************************

     * Authorized Setter Functions *

     *******************************/



    /**

     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.

     * The value of enqueueL2GasPrepaid is immediately updated as well.

     */

    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost) external;



    /********************

     * Public Functions *

     ********************/



    /**

     * Accesses the batch storage container.

     * @return Reference to the batch storage container.

     */

    function batches() external view returns (IChainStorageContainer);



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements() external view returns (uint256 _totalElements);



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches() external view returns (uint256 _totalBatches);



    /**

     * Returns the index of the next element to be enqueued.

     * @return Index for the next queue element.

     */

    function getNextQueueIndex() external view returns (uint40);



    /**

     * Gets the queue element at a particular index.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElement(uint256 _index)

        external

        view

        returns (Lib_OVMCodec.QueueElement memory _element);



    /**

     * Returns the timestamp of the last transaction.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestamp() external view returns (uint40);



    /**

     * Returns the blocknumber of the last transaction.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumber() external view returns (uint40);



    /**

     * Get the number of queue elements which have not yet been included.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElements() external view returns (uint40);



    /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @return Length of the queue.

     */

    function getQueueLength() external view returns (uint40);



    /**

     * Adds a transaction to the queue.

     * @param _target Target contract to send the transaction to.

     * @param _gasLimit Gas limit for the given transaction.

     * @param _data Transaction data.

     */

    function enqueue(

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    ) external;



    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatch(

        // uint40 _shouldStartAtElement,

        // uint24 _totalElementsToAppend,

        // BatchContext[] _contexts,

        // bytes[] _transactionDataFields

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IChainStorageContainer.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title IChainStorageContainer

 */

interface IChainStorageContainer {

    /********************

     * Public Functions *

     ********************/



    /**

     * Sets the container's global metadata field. We're using `bytes27` here because we use five

     * bytes to maintain the length of the underlying data structure, meaning we have an extra

     * 27 bytes to store arbitrary data.

     * @param _globalMetadata New global metadata to set.

     */

    function setGlobalMetadata(bytes27 _globalMetadata) external;



    /**

     * Retrieves the container's global metadata field.

     * @return Container global metadata field.

     */

    function getGlobalMetadata() external view returns (bytes27);



    /**

     * Retrieves the number of objects stored in the container.

     * @return Number of objects in the container.

     */

    function length() external view returns (uint256);



    /**

     * Pushes an object into the container.

     * @param _object A 32 byte value to insert into the container.

     */

    function push(bytes32 _object) external;



    /**

     * Pushes an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _object A 32 byte value to insert into the container.

     * @param _globalMetadata New global metadata for the container.

     */

    function push(bytes32 _object, bytes27 _globalMetadata) external;



    /**

     * Retrieves an object from the container.

     * @param _index Index of the particular object to access.

     * @return 32 byte object value.

     */

    function get(uint256 _index) external view returns (bytes32);



    /**

     * Removes all objects after and including a given index.

     * @param _index Object index to delete from.

     */

    function deleteElementsAfterInclusive(uint256 _index) external;



    /**

     * Removes all objects after and including a given index. Also allows setting the global

     * metadata field.

     * @param _index Object index to delete from.

     * @param _globalMetadata New global metadata for the container.

     */

    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\ICrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title ICrossDomainMessenger

 */

interface ICrossDomainMessenger {

    /**********

     * Events *

     **********/



    event SentMessage(

        address indexed target,

        address sender,

        bytes message,

        uint256 messageNonce,

        uint256 gasLimit

    );

    event RelayedMessage(bytes32 indexed msgHash);

    event FailedRelayedMessage(bytes32 indexed msgHash);



    /*************

     * Variables *

     *************/



    function xDomainMessageSender() external view returns (address);



    /********************

     * Public Functions *

     ********************/



    /**

     * Sends a cross domain message to the target messenger.

     * @param _target Target contract address.

     * @param _message Message to send to the target.

     * @param _gasLimit Gas limit for the provided message.

     */

    function sendMessage(

        address _target,

        bytes calldata _message,

        uint32 _gasLimit

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IERC20Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)



pragma solidity ^0.8.0;



import "../IERC20.sol";



/**

 * @dev Interface for the optional metadata functions from the ERC20 standard.

 *

 * _Available since v4.1._

 */

interface IERC20Metadata is IERC20 {

    /**

     * @dev Returns the name of the token.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the symbol of the token.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the decimals places of the token.

     */

    function decimals() external view returns (uint8);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iL1ChugSplashDeployer.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/**

 * @title iL1ChugSplashDeployer

 */

interface iL1ChugSplashDeployer {

    function isUpgrading()

        external

        view

        returns (

            bool

        );

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IL1CrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/* Interface Imports */

import { ICrossDomainMessenger } from "../../libraries/bridge/ICrossDomainMessenger.sol";



/**

 * @title IL1CrossDomainMessenger

 */

interface IL1CrossDomainMessenger is ICrossDomainMessenger {

    /*******************

     * Data Structures *

     *******************/



    struct L2MessageInclusionProof {

        bytes32 stateRoot;

        Lib_OVMCodec.ChainBatchHeader stateRootBatchHeader;

        Lib_OVMCodec.ChainInclusionProof stateRootProof;

        bytes stateTrieWitness;

        bytes storageTrieWitness;

    }



    /********************

     * Public Functions *

     ********************/



    /**

     * Relays a cross domain message to a contract.

     * @param _target Target contract address.

     * @param _sender Message sender address.

     * @param _message Message to send to the target.

     * @param _messageNonce Nonce for the provided message.

     * @param _proof Inclusion proof for the given message.

     */

    function relayMessage(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _messageNonce,

        L2MessageInclusionProof memory _proof

    ) external;



    /**

     * Replays a cross domain message to the target messenger.

     * @param _target Target contract address.

     * @param _sender Original sender address.

     * @param _message Message to send to the target.

     * @param _queueIndex CTC Queue index for the message to replay.

     * @param _oldGasLimit Original gas limit used to send the message.

     * @param _newGasLimit New gas limit to be used for this message.

     */

    function replayMessage(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _queueIndex,

        uint32 _oldGasLimit,

        uint32 _newGasLimit

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IL1ERC20Bridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title IL1ERC20Bridge

 */

interface IL1ERC20Bridge {

    /**********

     * Events *

     **********/



    event ERC20DepositInitiated(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event ERC20WithdrawalFinalized(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    /********************

     * Public Functions *

     ********************/



    /**

     * @dev get the address of the corresponding L2 bridge contract.

     * @return Address of the corresponding L2 bridge contract.

     */

    function l2TokenBridge() external returns (address);



    /**

     * @dev deposit an amount of the ERC20 to the caller's balance on L2.

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _amount Amount of the ERC20 to deposit

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20(

        address _l1Token,

        address _l2Token,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external;



    /**

     * @dev deposit an amount of ERC20 to a recipient's balance on L2.

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _to L2 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20To(

        address _l1Token,

        address _l2Token,

        address _to,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external;



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the

     * L1 ERC20 token.

     * This call will fail if the initialized withdrawal from L2 has not been finalized.

     *

     * @param _l1Token Address of L1 token to finalizeWithdrawal for.

     * @param _l2Token Address of L2 token where withdrawal was initiated.

     * @param _from L2 address initiating the transfer.

     * @param _to L1 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _data Data provided by the sender on L2. This data is provided

     *   solely as a convenience for external contracts. Aside from enforcing a maximum

     *   length, these contracts provide no guarantees about its content.

     */

    function finalizeERC20Withdrawal(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IL1StandardBridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



import "./IL1ERC20Bridge.sol";



/**

 * @title IL1StandardBridge

 */

interface IL1StandardBridge is IL1ERC20Bridge {

    /**********

     * Events *

     **********/

    event ETHDepositInitiated(

        address indexed _from,

        address indexed _to,

        uint256 _amount,

        bytes _data

    );



    event ETHWithdrawalFinalized(

        address indexed _from,

        address indexed _to,

        uint256 _amount,

        bytes _data

    );



    /********************

     * Public Functions *

     ********************/



    /**

     * @dev Deposit an amount of the ETH to the caller's balance on L2.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;



    /**

     * @dev Deposit an amount of ETH to a recipient's balance on L2.

     * @param _to L2 address to credit the withdrawal to.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositETHTo(

        address _to,

        uint32 _l2Gas,

        bytes calldata _data

    ) external payable;



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the

     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called

     * before the withdrawal is finalized.

     * @param _from L2 address initiating the transfer.

     * @param _to L1 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function finalizeETHWithdrawal(

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IL2ERC20Bridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title IL2ERC20Bridge

 */

interface IL2ERC20Bridge {

    /**********

     * Events *

     **********/



    event WithdrawalInitiated(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event DepositFinalized(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event DepositFailed(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    /********************

     * Public Functions *

     ********************/



    /**

     * @dev get the address of the corresponding L1 bridge contract.

     * @return Address of the corresponding L1 bridge contract.

     */

    function l1TokenBridge() external returns (address);



    /**

     * @dev initiate a withdraw of some tokens to the caller's account on L1

     * @param _l2Token Address of L2 token where withdrawal was initiated.

     * @param _amount Amount of the token to withdraw.

     * param _l1Gas Unused, but included for potential forward compatibility considerations.

     * @param _data Optional data to forward to L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function withdraw(

        address _l2Token,

        uint256 _amount,

        uint32 _l1Gas,

        bytes calldata _data

    ) external;



    /**

     * @dev initiate a withdraw of some token to a recipient's account on L1.

     * @param _l2Token Address of L2 token where withdrawal is initiated.

     * @param _to L1 adress to credit the withdrawal to.

     * @param _amount Amount of the token to withdraw.

     * param _l1Gas Unused, but included for potential forward compatibility considerations.

     * @param _data Optional data to forward to L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function withdrawTo(

        address _l2Token,

        address _to,

        uint256 _amount,

        uint32 _l1Gas,

        bytes calldata _data

    ) external;



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this

     * L2 token. This call will fail if it did not originate from a corresponding deposit in

     * L1StandardTokenBridge.

     * @param _l1Token Address for the l1 token this is called with

     * @param _l2Token Address for the l2 token this is called with

     * @param _from Account to pull the deposit from on L2.

     * @param _to Address to receive the withdrawal at

     * @param _amount Amount of the token to withdraw

     * @param _data Data provider by the sender on L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function finalizeDeposit(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Initializable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)



pragma solidity ^0.8.2;



import "../../utils/AddressUpgradeable.sol";



/**

 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed

 * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an

 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer

 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.

 *

 * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be

 * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in

 * case an upgrade adds a module that needs to be initialized.

 *

 * For example:

 *

 * [.hljs-theme-light.nopadding]

 * ```

 * contract MyToken is ERC20Upgradeable {

 *     function initialize() initializer public {

 *         __ERC20_init("MyToken", "MTK");

 *     }

 * }

 * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {

 *     function initializeV2() reinitializer(2) public {

 *         __ERC20Permit_init("MyToken");

 *     }

 * }

 * ```

 *

 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as

 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.

 *

 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure

 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.

 *

 * [CAUTION]

 * ====

 * Avoid leaving a contract uninitialized.

 *

 * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation

 * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke

 * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:

 *

 * [.hljs-theme-light.nopadding]

 * ```

 * /// @custom:oz-upgrades-unsafe-allow constructor

 * constructor() {

 *     _disableInitializers();

 * }

 * ```

 * ====

 */

abstract contract Initializable {

    /**

     * @dev Indicates that the contract has been initialized.

     * @custom:oz-retyped-from bool

     */

    uint8 private _initialized;



    /**

     * @dev Indicates that the contract is in the process of being initialized.

     */

    bool private _initializing;



    /**

     * @dev Triggered when the contract has been initialized or reinitialized.

     */

    event Initialized(uint8 version);



    /**

     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,

     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.

     */

    modifier initializer() {

        bool isTopLevelCall = !_initializing;

        require(

            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),

            "Initializable: contract is already initialized"

        );

        _initialized = 1;

        if (isTopLevelCall) {

            _initializing = true;

        }

        _;

        if (isTopLevelCall) {

            _initializing = false;

            emit Initialized(1);

        }

    }



    /**

     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the

     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be

     * used to initialize parent contracts.

     *

     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original

     * initialization step. This is essential to configure modules that are added through upgrades and that require

     * initialization.

     *

     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in

     * a contract, executing them in the right order is up to the developer or operator.

     */

    modifier reinitializer(uint8 version) {

        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");

        _initialized = version;

        _initializing = true;

        _;

        _initializing = false;

        emit Initialized(version);

    }



    /**

     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the

     * {initializer} and {reinitializer} modifiers, directly or indirectly.

     */

    modifier onlyInitializing() {

        require(_initializing, "Initializable: contract is not initializing");

        _;

    }



    /**

     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.

     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized

     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called

     * through proxies.

     */

    function _disableInitializers() internal virtual {

        require(!_initializing, "Initializable: contract is initializing");

        if (_initialized < type(uint8).max) {

            _initialized = type(uint8).max;

            emit Initialized(type(uint8).max);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IOptimismMintableERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";



/**

 * @title IOptimismMintableERC20

 * @notice This interface is available on the OptimismMintableERC20 contract. We declare it as a

 *         separate interface so that it can be used in custom implementations of

 *         OptimismMintableERC20.

 */

interface IOptimismMintableERC20 is IERC165 {

    function remoteToken() external view returns (address);



    function bridge() external returns (address);



    function mint(address _to, uint256 _amount) external;



    function burn(address _from, uint256 _amount) external;

}



/**

 * @custom:legacy

 * @title ILegacyMintableERC20

 * @notice This interface was available on the legacy L2StandardERC20 contract. It remains available

 *         on the OptimismMintableERC20 contract for backwards compatibility.

 */

interface ILegacyMintableERC20 is IERC165 {

    function l1Token() external view returns (address);



    function mint(address _to, uint256 _amount) external;



    function burn(address _from, uint256 _amount) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_BondManager.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



interface ERC20 {

    function transfer(address, uint256) external returns (bool);

    function transferFrom(address, address, uint256) external returns (bool);

}



/// All the errors which may be encountered on the bond manager

library Errors {

    string constant ERC20_ERR = "BondManager: Could not post bond";

    string constant ALREADY_FINALIZED = "BondManager: Fraud proof for this pre-state root has already been finalized";

    string constant SLASHED = "BondManager: Cannot finalize withdrawal, you probably got slashed";

    string constant WRONG_STATE = "BondManager: Wrong bond state for proposer";

    string constant CANNOT_CLAIM = "BondManager: Cannot claim yet. Dispute must be finalized first";



    string constant WITHDRAWAL_PENDING = "BondManager: Withdrawal already pending";

    string constant TOO_EARLY = "BondManager: Too early to finalize your withdrawal";



    string constant ONLY_TRANSITIONER = "BondManager: Only the transitioner for this pre-state root may call this function";

    string constant ONLY_FRAUD_VERIFIER = "BondManager: Only the fraud verifier may call this function";

    string constant ONLY_STATE_COMMITMENT_CHAIN = "BondManager: Only the state commitment chain may call this function";

    string constant WAIT_FOR_DISPUTES = "BondManager: Wait for other potential disputes";

}



/**

 * @title iOVM_BondManager

 */

interface iOVM_BondManager {



    /*******************

     * Data Structures *

     *******************/



    /// The lifecycle of a proposer's bond

    enum State {

        // Before depositing or after getting slashed, a user is uncollateralized

        NOT_COLLATERALIZED,

        // After depositing, a user is collateralized

        COLLATERALIZED,

        // After a user has initiated a withdrawal

        WITHDRAWING

    }



    /// A bond posted by a proposer

    struct Bond {

        // The user's state

        State state;

        // The timestamp at which a proposer issued their withdrawal request

        uint32 withdrawalTimestamp;

        // The time when the first disputed was initiated for this bond

        uint256 firstDisputeAt;

        // The earliest observed state root for this bond which has had fraud

        bytes32 earliestDisputedStateRoot;

        // The state root's timestamp

        uint256 earliestTimestamp;

    }



    // Per pre-state root, store the number of state provisions that were made

    // and how many of these calls were made by each user. Payouts will then be

    // claimed by users proportionally for that dispute.

    struct Rewards {

        // Flag to check if rewards for a fraud proof are claimable

        bool canClaim;

        // Total number of `recordGasSpent` calls made

        uint256 total;

        // The gas spent by each user to provide witness data. The sum of all

        // values inside this map MUST be equal to the value of `total`

        mapping(address => uint256) gasSpent;

    }





    /********************

     * Public Functions *

     ********************/



    function recordGasSpent(

        bytes32 _preStateRoot,

        bytes32 _txHash,

        address _who,

        uint256 _gasSpent

    ) external;



    function finalize(

        bytes32 _preStateRoot,

        address _publisher,

        uint256 _timestamp

    ) external;



    function deposit() external;



    function startWithdrawal() external;



    function finalizeWithdrawal() external;



    function claim(

        address _who

    ) external;



    function isCollateralized(

        address _who

    ) external view returns (bool);



    function getGasSpent(

        bytes32 _preStateRoot,

        address _who

    ) external view returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_CanonicalTransactionChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/* Interface Imports */

import { iOVM_ChainStorageContainer } from "./iOVM_ChainStorageContainer.sol";



/**

 * @title iOVM_CanonicalTransactionChain

 */

interface iOVM_CanonicalTransactionChain {



    /**********

     * Events *

     **********/



    event TransactionEnqueued(

        address _l1TxOrigin,

        address _target,

        uint256 _gasLimit,

        bytes _data,

        uint256 _queueIndex,

        uint256 _timestamp

    );



    event QueueBatchAppended(

        uint256 _startingQueueIndex,

        uint256 _numQueueElements,

        uint256 _totalElements

    );



    event SequencerBatchAppended(

        uint256 _startingQueueIndex,

        uint256 _numQueueElements,

        uint256 _totalElements

    );



    event TransactionBatchAppended(

        uint256 indexed _batchIndex,

        bytes32 _batchRoot,

        uint256 _batchSize,

        uint256 _prevTotalElements,

        bytes _extraData

    );





    /***********

     * Structs *

     ***********/



    struct BatchContext {

        uint256 numSequencedTransactions;

        uint256 numSubsequentQueueTransactions;

        uint256 timestamp;

        uint256 blockNumber;

    }





    /********************

     * Public Functions *

     ********************/





    /**

     * Accesses the batch storage container.

     * @return Reference to the batch storage container.

     */

    function batches()

        external

        view

        returns (

            iOVM_ChainStorageContainer

        );



    /**

     * Accesses the queue storage container.

     * @return Reference to the queue storage container.

     */

    function queue()

        external

        view

        returns (

            iOVM_ChainStorageContainer

        );



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements()

        external

        view

        returns (

            uint256 _totalElements

        );



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches()

        external

        view

        returns (

            uint256 _totalBatches

        );



    /**

     * Returns the index of the next element to be enqueued.

     * @return Index for the next queue element.

     */

    function getNextQueueIndex()

        external

        view

        returns (

            uint40

        );



    /**

     * Gets the queue element at a particular index.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElement(

        uint256 _index

    )

        external

        view

        returns (

            Lib_OVMCodec.QueueElement memory _element

        );



    /**

     * Returns the timestamp of the last transaction.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestamp()

        external

        view

        returns (

            uint40

        );



    /**

     * Returns the blocknumber of the last transaction.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumber()

        external

        view

        returns (

            uint40

        );



    /**

     * Get the number of queue elements which have not yet been included.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElements()

        external

        view

        returns (

            uint40

        );



    /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @return Length of the queue.

     */

    function getQueueLength()

        external

        view

        returns (

            uint40

        );





    /**

     * Adds a transaction to the queue.

     * @param _target Target contract to send the transaction to.

     * @param _gasLimit Gas limit for the given transaction.

     * @param _data Transaction data.

     */

    function enqueue(

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    )

        external;



    /**

     * Appends a given number of queued transactions as a single batch.

     * @param _numQueuedTransactions Number of transactions to append.

     */

    function appendQueueBatch(

        uint256 _numQueuedTransactions

    )

        external;



    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatch(

        // uint40 _shouldStartAtElement,

        // uint24 _totalElementsToAppend,

        // BatchContext[] _contexts,

        // bytes[] _transactionDataFields

    )

        external;



    /**

     * Verifies whether a transaction is included in the chain.

     * @param _transaction Transaction to verify.

     * @param _txChainElement Transaction chain element corresponding to the transaction.

     * @param _batchHeader Header of the batch the transaction was included in.

     * @param _inclusionProof Inclusion proof for the provided transaction chain element.

     * @return True if the transaction exists in the CTC, false if not.

     */

    function verifyTransaction(

        Lib_OVMCodec.Transaction memory _transaction,

        Lib_OVMCodec.TransactionChainElement memory _txChainElement,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof

    )

        external

        view

        returns (

            bool

        );

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_ChainStorageContainer.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/**

 * @title iOVM_ChainStorageContainer

 */

interface iOVM_ChainStorageContainer {



    /********************

     * Public Functions *

     ********************/



    /**

     * Sets the container's global metadata field. We're using `bytes27` here because we use five

     * bytes to maintain the length of the underlying data structure, meaning we have an extra

     * 27 bytes to store arbitrary data.

     * @param _globalMetadata New global metadata to set.

     */

    function setGlobalMetadata(

        bytes27 _globalMetadata

    )

        external;



    /**

     * Retrieves the container's global metadata field.

     * @return Container global metadata field.

     */

    function getGlobalMetadata()

        external

        view

        returns (

            bytes27

        );



    /**

     * Retrieves the number of objects stored in the container.

     * @return Number of objects in the container.

     */

    function length()

        external

        view

        returns (

            uint256

        );



    /**

     * Pushes an object into the container.

     * @param _object A 32 byte value to insert into the container.

     */

    function push(

        bytes32 _object

    )

        external;



    /**

     * Pushes an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _object A 32 byte value to insert into the container.

     * @param _globalMetadata New global metadata for the container.

     */

    function push(

        bytes32 _object,

        bytes27 _globalMetadata

    )

        external;



    /**

     * Retrieves an object from the container.

     * @param _index Index of the particular object to access.

     * @return 32 byte object value.

     */

    function get(

        uint256 _index

    )

        external

        view

        returns (

            bytes32

        );



    /**

     * Removes all objects after and including a given index.

     * @param _index Object index to delete from.

     */

    function deleteElementsAfterInclusive(

        uint256 _index

    )

        external;



    /**

     * Removes all objects after and including a given index. Also allows setting the global

     * metadata field.

     * @param _index Object index to delete from.

     * @param _globalMetadata New global metadata for the container.

     */

    function deleteElementsAfterInclusive(

        uint256 _index,

        bytes27 _globalMetadata

    )

        external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_CrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/**

 * @title iOVM_CrossDomainMessenger

 */

interface iOVM_CrossDomainMessenger {



    /**********

     * Events *

     **********/



    event SentMessage(bytes message);

    event RelayedMessage(bytes32 msgHash);

    event FailedRelayedMessage(bytes32 msgHash);





    /*************

     * Variables *

     *************/



    function xDomainMessageSender() external view returns (address);





    /********************

     * Public Functions *

     ********************/



    /**

     * Sends a cross domain message to the target messenger.

     * @param _target Target contract address.

     * @param _message Message to send to the target.

     * @param _gasLimit Gas limit for the provided message.

     */

    function sendMessage(

        address _target,

        bytes calldata _message,

        uint32 _gasLimit

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_DeployerWhitelist.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/**

 * @title iOVM_DeployerWhitelist

 */

interface iOVM_DeployerWhitelist {



    /********************

     * Public Functions *

     ********************/



    function initialize(address _owner, bool _allowArbitraryDeployment) external;

    function owner() external returns (address _owner);

    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external;

    function setOwner(address _newOwner) external;

    function setAllowArbitraryDeployment(bool _allowArbitraryDeployment) external;

    function enableArbitraryContractDeployment() external;

    function isDeployerAllowed(address _deployer) external returns (bool _allowed);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_ExecutionManager.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



interface iOVM_ExecutionManager {

    /**********

     * Enums *

     *********/



    enum RevertFlag {

        OUT_OF_GAS,

        INTENTIONAL_REVERT,

        EXCEEDS_NUISANCE_GAS,

        INVALID_STATE_ACCESS,

        UNSAFE_BYTECODE,

        CREATE_COLLISION,

        STATIC_VIOLATION,

        CREATOR_NOT_ALLOWED

    }



    enum GasMetadataKey {

        CURRENT_EPOCH_START_TIMESTAMP,

        CUMULATIVE_SEQUENCER_QUEUE_GAS,

        CUMULATIVE_L1TOL2_QUEUE_GAS,

        PREV_EPOCH_SEQUENCER_QUEUE_GAS,

        PREV_EPOCH_L1TOL2_QUEUE_GAS

    }



    enum MessageType {

        ovmCALL,

        ovmSTATICCALL,

        ovmDELEGATECALL,

        ovmCREATE,

        ovmCREATE2

    }



    /***********

     * Structs *

     ***********/



    struct GasMeterConfig {

        uint256 minTransactionGasLimit;

        uint256 maxTransactionGasLimit;

        uint256 maxGasPerQueuePerEpoch;

        uint256 secondsPerEpoch;

    }



    struct GlobalContext {

        uint256 ovmCHAINID;

    }



    struct TransactionContext {

        Lib_OVMCodec.QueueOrigin ovmL1QUEUEORIGIN;

        uint256 ovmTIMESTAMP;

        uint256 ovmNUMBER;

        uint256 ovmGASLIMIT;

        uint256 ovmTXGASLIMIT;

        address ovmL1TXORIGIN;

    }



    struct TransactionRecord {

        uint256 ovmGasRefund;

    }



    struct MessageContext {

        address ovmCALLER;

        address ovmADDRESS;

        uint256 ovmCALLVALUE;

        bool isStatic;

    }



    struct MessageRecord {

        uint256 nuisanceGasLeft;

    }





    /************************************

     * Transaction Execution Entrypoint *

     ************************************/



    function run(

        Lib_OVMCodec.Transaction calldata _transaction,

        address _txStateManager

    ) external returns (bytes memory);





    /*******************

     * Context Opcodes *

     *******************/



    function ovmCALLER() external view returns (address _caller);

    function ovmADDRESS() external view returns (address _address);

    function ovmCALLVALUE() external view returns (uint _callValue);

    function ovmTIMESTAMP() external view returns (uint256 _timestamp);

    function ovmNUMBER() external view returns (uint256 _number);

    function ovmGASLIMIT() external view returns (uint256 _gasLimit);

    function ovmCHAINID() external view returns (uint256 _chainId);





    /**********************

     * L2 Context Opcodes *

     **********************/



    function ovmL1QUEUEORIGIN() external view returns (Lib_OVMCodec.QueueOrigin _queueOrigin);

    function ovmL1TXORIGIN() external view returns (address _l1TxOrigin);





    /*******************

     * Halting Opcodes *

     *******************/



    function ovmREVERT(bytes memory _data) external;





    /*****************************

     * Contract Creation Opcodes *

     *****************************/



    function ovmCREATE(bytes memory _bytecode) external returns (address _contract, bytes memory _revertdata);

    function ovmCREATE2(bytes memory _bytecode, bytes32 _salt) external returns (address _contract, bytes memory _revertdata);





    /*******************************

     * Account Abstraction Opcodes *

     ******************************/



    function ovmGETNONCE() external returns (uint256 _nonce);

    function ovmINCREMENTNONCE() external;

    function ovmCREATEEOA(bytes32 _messageHash, uint8 _v, bytes32 _r, bytes32 _s) external;





    /****************************

     * Contract Calling Opcodes *

     ****************************/



    // Valueless ovmCALL for maintaining backwards compatibility with legacy OVM bytecode.

    function ovmCALL(uint256 _gasLimit, address _address, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);

    function ovmCALL(uint256 _gasLimit, address _address, uint256 _value, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);

    function ovmSTATICCALL(uint256 _gasLimit, address _address, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);

    function ovmDELEGATECALL(uint256 _gasLimit, address _address, bytes memory _calldata) external returns (bool _success, bytes memory _returndata);





    /****************************

     * Contract Storage Opcodes *

     ****************************/



    function ovmSLOAD(bytes32 _key) external returns (bytes32 _value);

    function ovmSSTORE(bytes32 _key, bytes32 _value) external;





    /*************************

     * Contract Code Opcodes *

     *************************/



    function ovmEXTCODECOPY(address _contract, uint256 _offset, uint256 _length) external returns (bytes memory _code);

    function ovmEXTCODESIZE(address _contract) external returns (uint256 _size);

    function ovmEXTCODEHASH(address _contract) external returns (bytes32 _hash);





    /*********************

     * ETH Value Opcodes *

     *********************/



    function ovmBALANCE(address _contract) external returns (uint256 _balance);

    function ovmSELFBALANCE() external returns (uint256 _balance);





    /***************************************

     * Public Functions: Execution Context *

     ***************************************/



    function getMaxTransactionGasLimit() external view returns (uint _maxTransactionGasLimit);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_FraudVerifier.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/* Interface Imports */

import { iOVM_StateTransitioner } from "./iOVM_StateTransitioner.sol";



/**

 * @title iOVM_FraudVerifier

 */

interface iOVM_FraudVerifier {



    /**********

     * Events *

     **********/



    event FraudProofInitialized(

        bytes32 _preStateRoot,

        uint256 _preStateRootIndex,

        bytes32 _transactionHash,

        address _who

    );



    event FraudProofFinalized(

        bytes32 _preStateRoot,

        uint256 _preStateRootIndex,

        bytes32 _transactionHash,

        address _who

    );





    /***************************************

     * Public Functions: Transition Status *

     ***************************************/



    function getStateTransitioner(bytes32 _preStateRoot, bytes32 _txHash) external view returns (iOVM_StateTransitioner _transitioner);





    /****************************************

     * Public Functions: Fraud Verification *

     ****************************************/



    function initializeFraudVerification(

        bytes32 _preStateRoot,

        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,

        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,

        Lib_OVMCodec.Transaction calldata _transaction,

        Lib_OVMCodec.TransactionChainElement calldata _txChainElement,

        Lib_OVMCodec.ChainBatchHeader calldata _transactionBatchHeader,

        Lib_OVMCodec.ChainInclusionProof calldata _transactionProof

    ) external;



    function finalizeFraudVerification(

        bytes32 _preStateRoot,

        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,

        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,

        bytes32 _txHash,

        bytes32 _postStateRoot,

        Lib_OVMCodec.ChainBatchHeader calldata _postStateRootBatchHeader,

        Lib_OVMCodec.ChainInclusionProof calldata _postStateRootProof

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_L1CrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../../libraries/codec/Lib_OVMCodec.sol";



/* Interface Imports */

import { iOVM_CrossDomainMessenger } from "./iOVM_CrossDomainMessenger.sol";



/**

 * @title iOVM_L1CrossDomainMessenger

 */

interface iOVM_L1CrossDomainMessenger is iOVM_CrossDomainMessenger {



    /*******************

     * Data Structures *

     *******************/



    struct L2MessageInclusionProof {

        bytes32 stateRoot;

        Lib_OVMCodec.ChainBatchHeader stateRootBatchHeader;

        Lib_OVMCodec.ChainInclusionProof stateRootProof;

        bytes stateTrieWitness;

        bytes storageTrieWitness;

    }





    /********************

     * Public Functions *

     ********************/



    /**

     * Relays a cross domain message to a contract.

     * @param _target Target contract address.

     * @param _sender Message sender address.

     * @param _message Message to send to the target.

     * @param _messageNonce Nonce for the provided message.

     * @param _proof Inclusion proof for the given message.

     */

    function relayMessage(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _messageNonce,

        L2MessageInclusionProof memory _proof

    ) external;



    /**

     * Replays a cross domain message to the target messenger.

     * @param _target Target contract address.

     * @param _sender Original sender address.

     * @param _message Message to send to the target.

     * @param _queueIndex CTC Queue index for the message to replay.

     * @param _gasLimit Gas limit for the provided message.

     */

    function replayMessage(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _queueIndex,

        uint32 _gasLimit

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_L1ERC20Bridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0;

pragma experimental ABIEncoderV2;



/**

 * @title iOVM_L1ERC20Bridge

 */

interface iOVM_L1ERC20Bridge {



    /**********

     * Events *

     **********/



    event ERC20DepositInitiated (

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event ERC20WithdrawalFinalized (

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    /********************

     * Public Functions *

     ********************/



    /**

     * @dev deposit an amount of the ERC20 to the caller's balance on L2.

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _amount Amount of the ERC20 to deposit

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20 (

        address _l1Token,

        address _l2Token,

        uint _amount,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external;



    /**

     * @dev deposit an amount of ERC20 to a recipient's balance on L2.

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _to L2 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20To (

        address _l1Token,

        address _l2Token,

        address _to,

        uint _amount,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external;





    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the

     * L1 ERC20 token.

     * This call will fail if the initialized withdrawal from L2 has not been finalized.

     *

     * @param _l1Token Address of L1 token to finalizeWithdrawal for.

     * @param _l2Token Address of L2 token where withdrawal was initiated.

     * @param _from L2 address initiating the transfer.

     * @param _to L1 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _data Data provided by the sender on L2. This data is provided

     *   solely as a convenience for external contracts. Aside from enforcing a maximum

     *   length, these contracts provide no guarantees about its content.

     */

    function finalizeERC20Withdrawal (

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint _amount,

        bytes calldata _data

    )

        external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_L1MultiMessageRelayer.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Interface Imports */

import { iOVM_L1CrossDomainMessenger } from "../../../iOVM/bridge/messaging/iOVM_L1CrossDomainMessenger.sol";

interface iOVM_L1MultiMessageRelayer {



    struct L2ToL1Message {

        address target;

        address sender;

        bytes message;

        uint256 messageNonce;

        iOVM_L1CrossDomainMessenger.L2MessageInclusionProof proof;

    }



    function batchRelayMessages(L2ToL1Message[] calldata _messages) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_L2ERC20Bridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0;

pragma experimental ABIEncoderV2;



/**

 * @title iOVM_L2ERC20Bridge

 */

interface iOVM_L2ERC20Bridge {



    /**********

     * Events *

     **********/



    event WithdrawalInitiated (

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event DepositFinalized (

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event DepositFailed (

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );





    /********************

     * Public Functions *

     ********************/



    /**

     * @dev initiate a withdraw of some tokens to the caller's account on L1

     * @param _l2Token Address of L2 token where withdrawal was initiated.

     * @param _amount Amount of the token to withdraw.

     * param _l1Gas Unused, but included for potential forward compatibility considerations.

     * @param _data Optional data to forward to L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function withdraw (

        address _l2Token,

        uint _amount,

        uint32 _l1Gas,

        bytes calldata _data

    )

        external;



    /**

     * @dev initiate a withdraw of some token to a recipient's account on L1.

     * @param _l2Token Address of L2 token where withdrawal is initiated.

     * @param _to L1 adress to credit the withdrawal to.

     * @param _amount Amount of the token to withdraw.

     * param _l1Gas Unused, but included for potential forward compatibility considerations.

     * @param _data Optional data to forward to L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function withdrawTo (

        address _l2Token,

        address _to,

        uint _amount,

        uint32 _l1Gas,

        bytes calldata _data

    )

        external;



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this

     * L2 token.

     * This call will fail if it did not originate from a corresponding deposit in OVM_l1TokenGateway.

     * @param _l1Token Address for the l1 token this is called with

     * @param _l2Token Address for the l2 token this is called with

     * @param _from Account to pull the deposit from on L2.

     * @param _to Address to receive the withdrawal at

     * @param _amount Amount of the token to withdraw

     * @param _data Data provider by the sender on L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function finalizeDeposit (

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint _amount,

        bytes calldata _data

    )

        external;



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_SafetyChecker.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/**

 * @title iOVM_SafetyChecker

 */

interface iOVM_SafetyChecker {



    /********************

     * Public Functions *

     ********************/



    function isBytecodeSafe(bytes calldata _bytecode) external pure returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_StateCommitmentChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/**

 * @title iOVM_StateCommitmentChain

 */

interface iOVM_StateCommitmentChain {



    /**********

     * Events *

     **********/



    event StateBatchAppended(

        uint256 indexed _batchIndex,

        bytes32 _batchRoot,

        uint256 _batchSize,

        uint256 _prevTotalElements,

        bytes _extraData

    );



    event StateBatchDeleted(

        uint256 indexed _batchIndex,

        bytes32 _batchRoot

    );





    /********************

     * Public Functions *

     ********************/



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements()

        external

        view

        returns (

            uint256 _totalElements

        );



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches()

        external

        view

        returns (

            uint256 _totalBatches

        );



    /**

     * Retrieves the timestamp of the last batch submitted by the sequencer.

     * @return _lastSequencerTimestamp Last sequencer batch timestamp.

     */

    function getLastSequencerTimestamp()

        external

        view

        returns (

            uint256 _lastSequencerTimestamp

        );



    /**

     * Appends a batch of state roots to the chain.

     * @param _batch Batch of state roots.

     * @param _shouldStartAtElement Index of the element at which this batch should start.

     */

    function appendStateBatch(

        bytes32[] calldata _batch,

        uint256 _shouldStartAtElement

    )

        external;



    /**

     * Deletes all state roots after (and including) a given batch.

     * @param _batchHeader Header of the batch to start deleting from.

     */

    function deleteStateBatch(

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        external;



    /**

     * Verifies a batch inclusion proof.

     * @param _element Hash of the element to verify a proof for.

     * @param _batchHeader Header of the batch in which the element was included.

     * @param _proof Merkle inclusion proof for the element.

     */

    function verifyStateCommitment(

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    )

        external

        view

        returns (

            bool _verified

        );



    /**

     * Checks whether a given batch is still inside its fraud proof window.

     * @param _batchHeader Header of the batch to check.

     * @return _inside Whether or not the batch is inside the fraud proof window.

     */

    function insideFraudProofWindow(

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        external

        view

        returns (

            bool _inside

        );

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_StateManager.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/**

 * @title iOVM_StateManager

 */

interface iOVM_StateManager {



    /*******************

     * Data Structures *

     *******************/



    enum ItemState {

        ITEM_UNTOUCHED,

        ITEM_LOADED,

        ITEM_CHANGED,

        ITEM_COMMITTED

    }



    /***************************

     * Public Functions: Misc *

     ***************************/



    function isAuthenticated(address _address) external view returns (bool);



    /***************************

     * Public Functions: Setup *

     ***************************/



    function owner() external view returns (address _owner);

    function ovmExecutionManager() external view returns (address _ovmExecutionManager);

    function setExecutionManager(address _ovmExecutionManager) external;





    /************************************

     * Public Functions: Account Access *

     ************************************/



    function putAccount(address _address, Lib_OVMCodec.Account memory _account) external;

    function putEmptyAccount(address _address) external;

    function getAccount(address _address) external view returns (Lib_OVMCodec.Account memory _account);

    function hasAccount(address _address) external view returns (bool _exists);

    function hasEmptyAccount(address _address) external view returns (bool _exists);

    function setAccountNonce(address _address, uint256 _nonce) external;

    function getAccountNonce(address _address) external view returns (uint256 _nonce);

    function getAccountEthAddress(address _address) external view returns (address _ethAddress);

    function getAccountStorageRoot(address _address) external view returns (bytes32 _storageRoot);

    function initPendingAccount(address _address) external;

    function commitPendingAccount(address _address, address _ethAddress, bytes32 _codeHash) external;

    function testAndSetAccountLoaded(address _address) external returns (bool _wasAccountAlreadyLoaded);

    function testAndSetAccountChanged(address _address) external returns (bool _wasAccountAlreadyChanged);

    function commitAccount(address _address) external returns (bool _wasAccountCommitted);

    function incrementTotalUncommittedAccounts() external;

    function getTotalUncommittedAccounts() external view returns (uint256 _total);

    function wasAccountChanged(address _address) external view returns (bool);

    function wasAccountCommitted(address _address) external view returns (bool);





    /************************************

     * Public Functions: Storage Access *

     ************************************/



    function putContractStorage(address _contract, bytes32 _key, bytes32 _value) external;

    function getContractStorage(address _contract, bytes32 _key) external view returns (bytes32 _value);

    function hasContractStorage(address _contract, bytes32 _key) external view returns (bool _exists);

    function testAndSetContractStorageLoaded(address _contract, bytes32 _key) external returns (bool _wasContractStorageAlreadyLoaded);

    function testAndSetContractStorageChanged(address _contract, bytes32 _key) external returns (bool _wasContractStorageAlreadyChanged);

    function commitContractStorage(address _contract, bytes32 _key) external returns (bool _wasContractStorageCommitted);

    function incrementTotalUncommittedContractStorage() external;

    function getTotalUncommittedContractStorage() external view returns (uint256 _total);

    function wasContractStorageChanged(address _contract, bytes32 _key) external view returns (bool);

    function wasContractStorageCommitted(address _contract, bytes32 _key) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\iOVM_StateTransitioner.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/**

 * @title iOVM_StateTransitioner

 */

interface iOVM_StateTransitioner {



    /**********

     * Events *

     **********/



    event AccountCommitted(

        address _address

    );



    event ContractStorageCommitted(

        address _address,

        bytes32 _key

    );





    /**********************************

     * Public Functions: State Access *

     **********************************/



    function getPreStateRoot() external view returns (bytes32 _preStateRoot);

    function getPostStateRoot() external view returns (bytes32 _postStateRoot);

    function isComplete() external view returns (bool _complete);





    /***********************************

     * Public Functions: Pre-Execution *

     ***********************************/



    function proveContractState(

        address _ovmContractAddress,

        address _ethContractAddress,

        bytes calldata _stateTrieWitness

    ) external;



    function proveStorageSlot(

        address _ovmContractAddress,

        bytes32 _key,

        bytes calldata _storageTrieWitness

    ) external;





    /*******************************

     * Public Functions: Execution *

     *******************************/



    function applyTransaction(

        Lib_OVMCodec.Transaction calldata _transaction

    ) external;





    /************************************

     * Public Functions: Post-Execution *

     ************************************/



    function commitContractState(

        address _ovmContractAddress,

        bytes calldata _stateTrieWitness

    ) external;



    function commitStorageSlot(

        address _ovmContractAddress,

        bytes32 _key,

        bytes calldata _storageTrieWitness

    ) external;





    /**********************************

     * Public Functions: Finalization *

     **********************************/



    function completeTransition() external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\IStateCommitmentChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/**

 * @title IStateCommitmentChain

 */

interface IStateCommitmentChain {

    /**********

     * Events *

     **********/



    event StateBatchAppended(

        uint256 indexed _batchIndex,

        bytes32 _batchRoot,

        uint256 _batchSize,

        uint256 _prevTotalElements,

        bytes _extraData

    );



    event StateBatchDeleted(uint256 indexed _batchIndex, bytes32 _batchRoot);



    /********************

     * Public Functions *

     ********************/



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements() external view returns (uint256 _totalElements);



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches() external view returns (uint256 _totalBatches);



    /**

     * Retrieves the timestamp of the last batch submitted by the sequencer.

     * @return _lastSequencerTimestamp Last sequencer batch timestamp.

     */

    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);



    /**

     * Appends a batch of state roots to the chain.

     * @param _batch Batch of state roots.

     * @param _shouldStartAtElement Index of the element at which this batch should start.

     */

    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;



    /**

     * Deletes all state roots after (and including) a given batch.

     * @param _batchHeader Header of the batch to start deleting from.

     */

    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) external;



    /**

     * Verifies a batch inclusion proof.

     * @param _element Hash of the element to verify a proof for.

     * @param _batchHeader Header of the batch in which the element was included.

     * @param _proof Merkle inclusion proof for the element.

     */

    function verifyStateCommitment(

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    ) external view returns (bool _verified);



    /**

     * Checks whether a given batch is still inside its fraud proof window.

     * @param _batchHeader Header of the batch to check.

     * @return _inside Whether or not the batch is inside the fraud proof window.

     */

    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)

        external

        view

        returns (bool _inside);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\L1ChugSplashProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



import { iL1ChugSplashDeployer } from "./interfaces/iL1ChugSplashDeployer.sol";



/**

 * @title L1ChugSplashProxy

 * @dev Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added

 * functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty!

 *

 * Note for future developers: do NOT make anything in this contract 'public' unless you know what

 * you're doing. Anything public can potentially have a function signature that conflicts with a

 * signature attached to the implementation contract. Public functions SHOULD always have the

 * 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that

 * modifier. And there almost certainly is not a good reason to not have that modifier. Beware!

 */

contract L1ChugSplashProxy {



    /*************

     * Constants *

     *************/



    // "Magic" prefix. When prepended to some arbitrary bytecode and used to create a contract, the

    // appended bytecode will be deployed as given.

    bytes13 constant internal DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;



    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)

    bytes32 constant internal IMPLEMENTATION_KEY = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)

    bytes32 constant internal OWNER_KEY = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;





    /***************

     * Constructor *

     ***************/

    

    /**

     * @param _owner Address of the initial contract owner.

     */

    constructor(

        address _owner

    ) {

        _setOwner(_owner);

    }





    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Blocks a function from being called when the parent signals that the system should be paused

     * via an isUpgrading function.

     */

    modifier onlyWhenNotPaused() {

        address owner = _getOwner();



        // We do a low-level call because there's no guarantee that the owner actually *is* an

        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and

        // it turns out that it isn't the right type of contract.

        (bool success, bytes memory returndata) = owner.staticcall(

            abi.encodeWithSelector(

                iL1ChugSplashDeployer.isUpgrading.selector

            )

        );



        // If the call was unsuccessful then we assume that there's no "isUpgrading" method and we

        // can just continue as normal. We also expect that the return value is exactly 32 bytes

        // long. If this isn't the case then we can safely ignore the result.

        if (success && returndata.length == 32) {

            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the

            // case that the isUpgrading function returned something other than 0 or 1. But we only

            // really care about the case where this value is 0 (= false).

            uint256 ret = abi.decode(returndata, (uint256));

            require(

                ret == 0,

                "L1ChugSplashProxy: system is currently being upgraded"

            );

        }



        _;

    }



    /**

     * Makes a proxy call instead of triggering the given function when the caller is either the

     * owner or the zero address. Caller can only ever be the zero address if this function is

     * being called off-chain via eth_call, which is totally fine and can be convenient for

     * client-side tooling. Avoids situations where the proxy and implementation share a sighash

     * and the proxy function ends up being called instead of the implementation one.

     *

     * Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If there's a

     * way for someone to send a transaction with msg.sender == address(0) in any real context then

     * we have much bigger problems. Primary reason to include this additional allowed sender is

     * because the owner address can be changed dynamically and we do not want clients to have to

     * keep track of the current owner in order to make an eth_call that doesn't trigger the

     * proxied contract.

     */

    modifier proxyCallIfNotOwner() {

        if (msg.sender == _getOwner() || msg.sender == address(0)) {

            _;

        } else {

            // This WILL halt the call frame on completion.

            _doProxyCall();

        }

    }





    /*********************

     * Fallback Function *

     *********************/



    fallback()

        external

        payable

    {

        // Proxy call by default.

        _doProxyCall();

    }





    /********************

     * Public Functions *

     ********************/



    /**

     * Sets the code that should be running behind this proxy. Note that this scheme is a bit

     * different from the standard proxy scheme where one would typically deploy the code

     * separately and then set the implementation address. We're doing it this way because it gives

     * us a lot more freedom on the client side. Can only be triggered by the contract owner.

     * @param _code New contract code to run inside this contract.

     */

    function setCode(

        bytes memory _code

    )

        proxyCallIfNotOwner

        public

    {

        // Get the code hash of the current implementation.

        address implementation = _getImplementation();



        // If the code hash matches the new implementation then we return early.

        if (keccak256(_code) == _getAccountCodeHash(implementation)) {

            return;

        }



        // Create the deploycode by appending the magic prefix.

        bytes memory deploycode = abi.encodePacked(

            DEPLOY_CODE_PREFIX,

            _code

        );



        // Deploy the code and set the new implementation address.

        address newImplementation;

        assembly {

            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))

        }



        // Check that the code was actually deployed correctly. I'm not sure if you can ever

        // actually fail this check. Should only happen if the contract creation from above runs

        // out of gas but this parent execution thread does NOT run out of gas. Seems like we

        // should be doing this check anyway though.

        require(

            _getAccountCodeHash(newImplementation) == keccak256(_code),

            "L1ChugSplashProxy: code was not correctly deployed."

        );



        _setImplementation(newImplementation);

    }



    /**

     * Modifies some storage slot within the proxy contract. Gives us a lot of power to perform

     * upgrades in a more transparent way. Only callable by the owner.

     * @param _key Storage key to modify.

     * @param _value New value for the storage key.

     */

    function setStorage(

        bytes32 _key,

        bytes32 _value

    )

        proxyCallIfNotOwner

        public

    {

        assembly {

            sstore(_key, _value)

        }

    }



    /**

     * Changes the owner of the proxy contract. Only callable by the owner.

     * @param _owner New owner of the proxy contract.

     */

    function setOwner(

        address _owner

    )

        proxyCallIfNotOwner

        public

    {

        _setOwner(_owner);

    }



    /**

     * Queries the owner of the proxy contract. Can only be called by the owner OR by making an

     * eth_call and setting the "from" address to address(0).

     * @return Owner address.

     */

    function getOwner()

        proxyCallIfNotOwner

        public

        returns (

            address

        )

    {

        return _getOwner();

    }



    /**

     * Queries the implementation address. Can only be called by the owner OR by making an

     * eth_call and setting the "from" address to address(0).

     * @return Implementation address.

     */

    function getImplementation()

        proxyCallIfNotOwner

        public

        returns (

            address

        )

    {

        return _getImplementation();

    }





    /**********************

     * Internal Functions *

     **********************/



    /**

     * Sets the implementation address.

     * @param _implementation New implementation address.

     */

    function _setImplementation(

        address _implementation

    )

        internal

    {

        assembly {

            sstore(IMPLEMENTATION_KEY, _implementation)

        }

    }



    /**

     * Queries the implementation address.

     * @return Implementation address.

     */

    function _getImplementation()

        internal

        view

        returns (

            address

        )

    {

        address implementation;

        assembly {

            implementation := sload(IMPLEMENTATION_KEY)

        }

        return implementation;

    }



    /**

     * Changes the owner of the proxy contract.

     * @param _owner New owner of the proxy contract.

     */

    function _setOwner(

        address _owner

    )

        internal

    {

        assembly {

            sstore(OWNER_KEY, _owner)

        }

    }



    /**

     * Queries the owner of the proxy contract.

     * @return Owner address.

     */

    function _getOwner()

        internal

        view 

        returns (

            address

        )

    {

        address owner;

        assembly {

            owner := sload(OWNER_KEY)

        }

        return owner;

    }



    /**

     * Gets the code hash for a given account.

     * @param _account Address of the account to get a code hash for.

     * @return Code hash for the account.

     */

    function _getAccountCodeHash(

        address _account

    )

        internal

        view

        returns (

            bytes32

        )

    {

        bytes32 codeHash;

        assembly {

            codeHash := extcodehash(_account)

        }

        return codeHash;

    }



    /**

     * Performs the proxy call via a delegatecall.

     */

    function _doProxyCall()

        onlyWhenNotPaused

        internal

    {

        address implementation = _getImplementation();



        require(

            implementation != address(0),

            "L1ChugSplashProxy: implementation is not set yet"

        );



        assembly {

            // Copy calldata into memory at 0x0....calldatasize.

            calldatacopy(0x0, 0x0, calldatasize())



            // Perform the delegatecall, make sure to pass all available gas.

            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)



            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*

            // overwrite the calldata that we just copied into memory but that doesn't really

            // matter because we'll be returning in a second anyway.

            returndatacopy(0x0, 0x0, returndatasize())

            

            // Success == 0 means a revert. We'll revert too and pass the data up.

            if iszero(success) {

                revert(0x0, returndatasize())

            }



            // Otherwise we'll just return and pass the data up.

            return(0x0, returndatasize())

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\L1CrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



import { Predeploys } from "../libraries/Predeploys.sol";

import { OptimismPortal } from "./OptimismPortal.sol";

import { CrossDomainMessenger } from "../universal/CrossDomainMessenger.sol";

import { Semver } from "../universal/Semver.sol";



/**

 * @custom:proxied

 * @title L1CrossDomainMessenger

 * @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible

 *         for sending and receiving data on the L1 side. Users are encouraged to use this

 *         interface instead of interacting with lower-level contracts directly.

 */

contract L1CrossDomainMessenger is CrossDomainMessenger, Semver {

    /**

     * @notice Address of the OptimismPortal.

     */

    OptimismPortal public immutable PORTAL;



    /**

     * @custom:semver 1.4.0

     *

     * @param _portal Address of the OptimismPortal contract on this network.

     */

    constructor(OptimismPortal _portal)

        Semver(1, 4, 0)

        CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER)

    {

        PORTAL = _portal;

        initialize();

    }



    /**

     * @notice Initializer.

     */

    function initialize() public initializer {

        __CrossDomainMessenger_init();

    }



    /**

     * @inheritdoc CrossDomainMessenger

     */

    function _sendMessage(

        address _to,

        uint64 _gasLimit,

        uint256 _value,

        bytes memory _data

    ) internal override {

        PORTAL.depositTransaction{ value: _value }(_to, _value, _gasLimit, false, _data);

    }



    /**

     * @inheritdoc CrossDomainMessenger

     */

    function _isOtherMessenger() internal view override returns (bool) {

        return msg.sender == address(PORTAL) && PORTAL.l2Sender() == OTHER_MESSENGER;

    }



    /**

     * @inheritdoc CrossDomainMessenger

     */

    function _isUnsafeTarget(address _target) internal view override returns (bool) {

        return _target == address(this) || _target == address(PORTAL);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\L1DAITokenBridge.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-or-later

// Copyright (C) 2021 Dai Foundation

// @unsupported: ovm

// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU Affero General Public License as published by

// the Free Software Foundation, either version 3 of the License, or

// (at your option) any later version.

//

// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU Affero General Public License for more details.

//

// You should have received a copy of the GNU Affero General Public License

// along with this program.  If not, see <https://www.gnu.org/licenses/>.



pragma solidity >=0.7.6;



import {iOVM_L1ERC20Bridge} from "@eth-optimism/contracts/iOVM/bridge/tokens/iOVM_L1ERC20Bridge.sol";

import {iOVM_L2ERC20Bridge} from "@eth-optimism/contracts/iOVM/bridge/tokens/iOVM_L2ERC20Bridge.sol";

import {OVM_CrossDomainEnabled} from "@eth-optimism/contracts/libraries/bridge/OVM_CrossDomainEnabled.sol";

import { Address } from "@openzeppelin/contracts/utils/Address.sol";



interface TokenLike {

  function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);

}



// Managed locked funds in L1Escrow and send / receive messages to L2DAITokenBridge counterpart

// Note: when bridge is closed it will still process in progress messages



contract L1DAITokenBridge is iOVM_L1ERC20Bridge, OVM_CrossDomainEnabled {

  // --- Auth ---

  mapping (address => uint256) public wards;

  function rely(address usr) external auth {

    wards[usr] = 1;

    emit Rely(usr);

  }

  function deny(address usr) external auth {

    wards[usr] = 0;

    emit Deny(usr);

  }

  modifier auth {

    require(wards[msg.sender] == 1, "L1DAITokenBridge/not-authorized");

    _;

  }



  event Rely(address indexed usr);

  event Deny(address indexed usr);



  address public immutable l1Token;

  address public immutable l2DAITokenBridge;

  address public immutable l2Token;

  address public immutable escrow;

  uint256 public isOpen = 1;



  event Closed();



  constructor(

    address _l1Token,

    address _l2DAITokenBridge,

    address _l2Token,

    address _l1messenger,

    address _escrow

  ) OVM_CrossDomainEnabled(_l1messenger) {

    wards[msg.sender] = 1;

    emit Rely(msg.sender);



    l1Token = _l1Token;

    l2DAITokenBridge = _l2DAITokenBridge;

    l2Token = _l2Token;

    escrow = _escrow;

  }



  function close() external auth {

    isOpen = 0;



    emit Closed();

  }



  function depositERC20(

    address _l1Token,

    address _l2Token,

    uint256 _amount,

    uint32 _l2Gas,

    bytes calldata _data

  ) external virtual override {

    // Used to stop deposits from contracts (avoid accidentally lost tokens)

    // Note: This check could be bypassed by a malicious contract via initcode, but it takes care of the user error we want to avoid.

    require(!Address.isContract(msg.sender), "L1DAITokenBridge/Sender-not-EOA");

    require(_l1Token == l1Token && _l2Token == l2Token, "L1DAITokenBridge/token-not-dai");



    _initiateERC20Deposit(msg.sender, msg.sender, _amount, _l2Gas, _data);

  }



  function depositERC20To(

    address _l1Token,

    address _l2Token,

    address _to,

    uint256 _amount,

    uint32 _l2Gas,

    bytes calldata _data

  ) external virtual override {

    require(_l1Token == l1Token && _l2Token == l2Token, "L1DAITokenBridge/token-not-dai");



    _initiateERC20Deposit(msg.sender, _to, _amount, _l2Gas, _data);

  }



  function _initiateERC20Deposit(

    address _from,

    address _to,

    uint256 _amount,

    uint32 _l2Gas,

    bytes calldata _data

  ) internal {

    // do not allow initiating new xchain messages if bridge is closed

    require(isOpen == 1, "L1DAITokenBridge/closed");



    TokenLike(l1Token).transferFrom(_from, escrow, _amount);



    bytes memory message =

      abi.encodeWithSelector(iOVM_L2ERC20Bridge.finalizeDeposit.selector, l1Token, l2Token, _from, _to, _amount, _data);



    sendCrossDomainMessage(l2DAITokenBridge, _l2Gas, message);



    emit ERC20DepositInitiated(l1Token, l2Token, _from, _to, _amount, _data);

  }



  function finalizeERC20Withdrawal(

    address _l1Token,

    address _l2Token,

    address _from,

    address _to,

    uint256 _amount,

    bytes calldata _data

  ) external override onlyFromCrossDomainAccount(l2DAITokenBridge) {

    require(_l1Token == l1Token && _l2Token == l2Token, "L1DAITokenBridge/token-not-dai");

    

    TokenLike(l1Token).transferFrom(escrow, _to, _amount);



    emit ERC20WithdrawalFinalized(l1Token, l2Token, _from, _to, _amount, _data);

  }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\L1StandardBridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Interface Imports */

import { IL1StandardBridge } from "./IL1StandardBridge.sol";

import { IL1ERC20Bridge } from "./IL1ERC20Bridge.sol";

import { IL2ERC20Bridge } from "../../L2/messaging/IL2ERC20Bridge.sol";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";



/* Library Imports */

import { CrossDomainEnabled } from "../../libraries/bridge/CrossDomainEnabled.sol";

import { Lib_PredeployAddresses } from "../../libraries/constants/Lib_PredeployAddresses.sol";

import { Address } from "@openzeppelin/contracts/utils/Address.sol";

import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



/**

 * @title L1StandardBridge

 * @dev The L1 ETH and ERC20 Bridge is a contract which stores deposited L1 funds and standard

 * tokens that are in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits

 * and listening to it for newly finalized withdrawals.

 *

 * Runtime target: EVM

 */

contract L1StandardBridge is IL1StandardBridge, CrossDomainEnabled {

    using SafeERC20 for IERC20;



    /********************************

     * External Contract References *

     ********************************/



    address public l2TokenBridge;



    // Maps L1 token to L2 token to balance of the L1 token deposited

    mapping(address => mapping(address => uint256)) public deposits;



    /***************

     * Constructor *

     ***************/



    // This contract lives behind a proxy, so the constructor parameters will go unused.

    constructor() CrossDomainEnabled(address(0)) {}



    /******************

     * Initialization *

     ******************/



    /**

     * @param _l1messenger L1 Messenger address being used for cross-chain communications.

     * @param _l2TokenBridge L2 standard bridge address.

     */

    function initialize(address _l1messenger, address _l2TokenBridge) public {

        require(messenger == address(0), "Contract has already been initialized.");

        messenger = _l1messenger;

        l2TokenBridge = _l2TokenBridge;

    }



    /**************

     * Depositing *

     **************/



    /** @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious

     *  contract via initcode, but it takes care of the user error we want to avoid.

     */

    modifier onlyEOA() {

        // Used to stop deposits from contracts (avoid accidentally lost tokens)

        require(!Address.isContract(msg.sender), "Account not EOA");

        _;

    }



    /**

     * @dev This function can be called with no data

     * to deposit an amount of ETH to the caller's balance on L2.

     * Since the receive function doesn't take data, a conservative

     * default amount is forwarded to L2.

     */

    receive() external payable onlyEOA {

        _initiateETHDeposit(msg.sender, msg.sender, 200_000, bytes(""));

    }



    /**

     * @inheritdoc IL1StandardBridge

     */

    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable onlyEOA {

        _initiateETHDeposit(msg.sender, msg.sender, _l2Gas, _data);

    }



    /**

     * @inheritdoc IL1StandardBridge

     */

    function depositETHTo(

        address _to,

        uint32 _l2Gas,

        bytes calldata _data

    ) external payable {

        _initiateETHDeposit(msg.sender, _to, _l2Gas, _data);

    }



    /**

     * @dev Performs the logic for deposits by storing the ETH and informing the L2 ETH Gateway of

     * the deposit.

     * @param _from Account to pull the deposit from on L1.

     * @param _to Account to give the deposit to on L2.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function _initiateETHDeposit(

        address _from,

        address _to,

        uint32 _l2Gas,

        bytes memory _data

    ) internal {

        // Construct calldata for finalizeDeposit call

        bytes memory message = abi.encodeWithSelector(

            IL2ERC20Bridge.finalizeDeposit.selector,

            address(0),

            Lib_PredeployAddresses.OVM_ETH,

            _from,

            _to,

            msg.value,

            _data

        );



        // Send calldata into L2

        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);



        emit ETHDepositInitiated(_from, _to, msg.value, _data);

    }



    /**

     * @inheritdoc IL1ERC20Bridge

     */

    function depositERC20(

        address _l1Token,

        address _l2Token,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external virtual onlyEOA {

        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _l2Gas, _data);

    }



    /**

     * @inheritdoc IL1ERC20Bridge

     */

    function depositERC20To(

        address _l1Token,

        address _l2Token,

        address _to,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external virtual {

        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _l2Gas, _data);

    }



    /**

     * @dev Performs the logic for deposits by informing the L2 Deposited Token

     * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)

     *

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _from Account to pull the deposit from on L1

     * @param _to Account to give the deposit to on L2

     * @param _amount Amount of the ERC20 to deposit.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function _initiateERC20Deposit(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) internal {

        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future

        // withdrawals. safeTransferFrom also checks if the contract has code, so this will fail if

        // _from is an EOA or address(0).

        IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);



        // Construct calldata for _l2Token.finalizeDeposit(_to, _amount)

        bytes memory message = abi.encodeWithSelector(

            IL2ERC20Bridge.finalizeDeposit.selector,

            _l1Token,

            _l2Token,

            _from,

            _to,

            _amount,

            _data

        );



        // Send calldata into L2

        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);



        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount;



        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _data);

    }



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @inheritdoc IL1StandardBridge

     */

    function finalizeETHWithdrawal(

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external onlyFromCrossDomainAccount(l2TokenBridge) {

        (bool success, ) = _to.call{ value: _amount }(new bytes(0));

        require(success, "TransferHelper::safeTransferETH: ETH transfer failed");



        emit ETHWithdrawalFinalized(_from, _to, _amount, _data);

    }



    /**

     * @inheritdoc IL1ERC20Bridge

     */

    function finalizeERC20Withdrawal(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external onlyFromCrossDomainAccount(l2TokenBridge) {

        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;



        // When a withdrawal is finalized on L1, the L1 Bridge transfers the funds to the withdrawer

        IERC20(_l1Token).safeTransfer(_to, _amount);



        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);

    }



    /*****************************

     * Temporary - Migrating ETH *

     *****************************/



    /**

     * @dev Adds ETH balance to the account. This is meant to allow for ETH

     * to be migrated from an old gateway to a new gateway.

     * NOTE: This is left for one upgrade only so we are able to receive the migrated ETH from the

     * old contract

     */

    function donateETH() external payable {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\L2OutputOracle.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



import { Initializable } from "@openzeppelin/contracts/proxy/utils/Initializable.sol";

import { Semver } from "../universal/Semver.sol";

import { Types } from "../libraries/Types.sol";



/**

 * @custom:proxied

 * @title L2OutputOracle

 * @notice The L2OutputOracle contains an array of L2 state outputs, where each output is a

 *         commitment to the state of the L2 chain. Other contracts like the OptimismPortal use

 *         these outputs to verify information about the state of L2.

 */

contract L2OutputOracle is Initializable, Semver {

    /**

     * @notice The interval in L2 blocks at which checkpoints must be submitted. Although this is

     *         immutable, it can safely be modified by upgrading the implementation contract.

     */

    uint256 public immutable SUBMISSION_INTERVAL;



    /**

     * @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.

     */

    uint256 public immutable L2_BLOCK_TIME;



    /**

     * @notice The address of the challenger. Can be updated via upgrade.

     */

    address public immutable CHALLENGER;



    /**

     * @notice The address of the proposer. Can be updated via upgrade.

     */

    address public immutable PROPOSER;



    /**

     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.

     */

    uint256 public immutable FINALIZATION_PERIOD_SECONDS;



    /**

     * @notice The number of the first L2 block recorded in this contract.

     */

    uint256 public startingBlockNumber;



    /**

     * @notice The timestamp of the first L2 block recorded in this contract.

     */

    uint256 public startingTimestamp;



    /**

     * @notice Array of L2 output proposals.

     */

    Types.OutputProposal[] internal l2Outputs;



    /**

     * @notice Emitted when an output is proposed.

     *

     * @param outputRoot    The output root.

     * @param l2OutputIndex The index of the output in the l2Outputs array.

     * @param l2BlockNumber The L2 block number of the output root.

     * @param l1Timestamp   The L1 timestamp when proposed.

     */

    event OutputProposed(

        bytes32 indexed outputRoot,

        uint256 indexed l2OutputIndex,

        uint256 indexed l2BlockNumber,

        uint256 l1Timestamp

    );



    /**

     * @notice Emitted when outputs are deleted.

     *

     * @param prevNextOutputIndex Next L2 output index before the deletion.

     * @param newNextOutputIndex  Next L2 output index after the deletion.

     */

    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);



    /**

     * @custom:semver 1.3.0

     *

     * @param _submissionInterval  Interval in blocks at which checkpoints must be submitted.

     * @param _l2BlockTime         The time per L2 block, in seconds.

     * @param _startingBlockNumber The number of the first L2 block.

     * @param _startingTimestamp   The timestamp of the first L2 block.

     * @param _proposer            The address of the proposer.

     * @param _challenger          The address of the challenger.

     */

    constructor(

        uint256 _submissionInterval,

        uint256 _l2BlockTime,

        uint256 _startingBlockNumber,

        uint256 _startingTimestamp,

        address _proposer,

        address _challenger,

        uint256 _finalizationPeriodSeconds

    ) Semver(1, 3, 0) {

        require(_l2BlockTime > 0, "L2OutputOracle: L2 block time must be greater than 0");

        require(

            _submissionInterval > 0,

            "L2OutputOracle: submission interval must be greater than 0"

        );



        SUBMISSION_INTERVAL = _submissionInterval;

        L2_BLOCK_TIME = _l2BlockTime;

        PROPOSER = _proposer;

        CHALLENGER = _challenger;

        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;



        initialize(_startingBlockNumber, _startingTimestamp);

    }



    /**

     * @notice Initializer.

     *

     * @param _startingBlockNumber Block number for the first recoded L2 block.

     * @param _startingTimestamp   Timestamp for the first recoded L2 block.

     */

    function initialize(uint256 _startingBlockNumber, uint256 _startingTimestamp)

        public

        initializer

    {

        require(

            _startingTimestamp <= block.timestamp,

            "L2OutputOracle: starting L2 timestamp must be less than current time"

        );



        startingTimestamp = _startingTimestamp;

        startingBlockNumber = _startingBlockNumber;

    }



    /**

     * @notice Deletes all output proposals after and including the proposal that corresponds to

     *         the given output index. Only the challenger address can delete outputs.

     *

     * @param _l2OutputIndex Index of the first L2 output to be deleted. All outputs after this

     *                       output will also be deleted.

     */

    // solhint-disable-next-line ordering

    function deleteL2Outputs(uint256 _l2OutputIndex) external {

        require(

            msg.sender == CHALLENGER,

            "L2OutputOracle: only the challenger address can delete outputs"

        );



        // Make sure we're not *increasing* the length of the array.

        require(

            _l2OutputIndex < l2Outputs.length,

            "L2OutputOracle: cannot delete outputs after the latest output index"

        );



        // Do not allow deleting any outputs that have already been finalized.

        require(

            block.timestamp - l2Outputs[_l2OutputIndex].timestamp < FINALIZATION_PERIOD_SECONDS,

            "L2OutputOracle: cannot delete outputs that have already been finalized"

        );



        uint256 prevNextL2OutputIndex = nextOutputIndex();



        // Use assembly to delete the array elements because Solidity doesn't allow it.

        assembly {

            sstore(l2Outputs.slot, _l2OutputIndex)

        }



        emit OutputsDeleted(prevNextL2OutputIndex, _l2OutputIndex);

    }



    /**

     * @notice Accepts an outputRoot and the timestamp of the corresponding L2 block. The timestamp

     *         must be equal to the current value returned by `nextTimestamp()` in order to be

     *         accepted. This function may only be called by the Proposer.

     *

     * @param _outputRoot    The L2 output of the checkpoint block.

     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.

     * @param _l1BlockHash   A block hash which must be included in the current chain.

     * @param _l1BlockNumber The block number with the specified block hash.

     */

    function proposeL2Output(

        bytes32 _outputRoot,

        uint256 _l2BlockNumber,

        bytes32 _l1BlockHash,

        uint256 _l1BlockNumber

    ) external payable {

        require(

            msg.sender == PROPOSER,

            "L2OutputOracle: only the proposer address can propose new outputs"

        );



        require(

            _l2BlockNumber == nextBlockNumber(),

            "L2OutputOracle: block number must be equal to next expected block number"

        );



        require(

            computeL2Timestamp(_l2BlockNumber) < block.timestamp,

            "L2OutputOracle: cannot propose L2 output in the future"

        );



        require(

            _outputRoot != bytes32(0),

            "L2OutputOracle: L2 output proposal cannot be the zero hash"

        );



        if (_l1BlockHash != bytes32(0)) {

            // This check allows the proposer to propose an output based on a given L1 block,

            // without fear that it will be reorged out.

            // It will also revert if the blockheight provided is more than 256 blocks behind the

            // chain tip (as the hash will return as zero). This does open the door to a griefing

            // attack in which the proposer's submission is censored until the block is no longer

            // retrievable, if the proposer is experiencing this attack it can simply leave out the

            // blockhash value, and delay submission until it is confident that the L1 block is

            // finalized.

            require(

                blockhash(_l1BlockNumber) == _l1BlockHash,

                "L2OutputOracle: block hash does not match the hash at the expected height"

            );

        }



        emit OutputProposed(_outputRoot, nextOutputIndex(), _l2BlockNumber, block.timestamp);



        l2Outputs.push(

            Types.OutputProposal({

                outputRoot: _outputRoot,

                timestamp: uint128(block.timestamp),

                l2BlockNumber: uint128(_l2BlockNumber)

            })

        );

    }



    /**

     * @notice Returns an output by index. Exists because Solidity's array access will return a

     *         tuple instead of a struct.

     *

     * @param _l2OutputIndex Index of the output to return.

     *

     * @return The output at the given index.

     */

    function getL2Output(uint256 _l2OutputIndex)

        external

        view

        returns (Types.OutputProposal memory)

    {

        return l2Outputs[_l2OutputIndex];

    }



    /**

     * @notice Returns the index of the L2 output that checkpoints a given L2 block number. Uses a

     *         binary search to find the first output greater than or equal to the given block.

     *

     * @param _l2BlockNumber L2 block number to find a checkpoint for.

     *

     * @return Index of the first checkpoint that commits to the given L2 block number.

     */

    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {

        // Make sure an output for this block number has actually been proposed.

        require(

            _l2BlockNumber <= latestBlockNumber(),

            "L2OutputOracle: cannot get output for a block that has not been proposed"

        );



        // Make sure there's at least one output proposed.

        require(

            l2Outputs.length > 0,

            "L2OutputOracle: cannot get output as no outputs have been proposed yet"

        );



        // Find the output via binary search, guaranteed to exist.

        uint256 lo = 0;

        uint256 hi = l2Outputs.length;

        while (lo < hi) {

            uint256 mid = (lo + hi) / 2;

            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {

                lo = mid + 1;

            } else {

                hi = mid;

            }

        }



        return lo;

    }



    /**

     * @notice Returns the L2 output proposal that checkpoints a given L2 block number. Uses a

     *         binary search to find the first output greater than or equal to the given block.

     *

     * @param _l2BlockNumber L2 block number to find a checkpoint for.

     *

     * @return First checkpoint that commits to the given L2 block number.

     */

    function getL2OutputAfter(uint256 _l2BlockNumber)

        external

        view

        returns (Types.OutputProposal memory)

    {

        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];

    }



    /**

     * @notice Returns the number of outputs that have been proposed. Will revert if no outputs

     *         have been proposed yet.

     *

     * @return The number of outputs that have been proposed.

     */

    function latestOutputIndex() external view returns (uint256) {

        return l2Outputs.length - 1;

    }



    /**

     * @notice Returns the index of the next output to be proposed.

     *

     * @return The index of the next output to be proposed.

     */

    function nextOutputIndex() public view returns (uint256) {

        return l2Outputs.length;

    }



    /**

     * @notice Returns the block number of the latest submitted L2 output proposal. If no proposals

     *         been submitted yet then this function will return the starting block number.

     *

     * @return Latest submitted L2 block number.

     */

    function latestBlockNumber() public view returns (uint256) {

        return

            l2Outputs.length == 0

                ? startingBlockNumber

                : l2Outputs[l2Outputs.length - 1].l2BlockNumber;

    }



    /**

     * @notice Computes the block number of the next L2 block that needs to be checkpointed.

     *

     * @return Next L2 block number.

     */

    function nextBlockNumber() public view returns (uint256) {

        return latestBlockNumber() + SUBMISSION_INTERVAL;

    }



    /**

     * @notice Returns the L2 timestamp corresponding to a given L2 block number.

     *

     * @param _l2BlockNumber The L2 block number of the target block.

     *

     * @return L2 timestamp of the given block.

     */

    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {

        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * L2_BLOCK_TIME);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_AddressManager.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/* External Imports */

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";



/**

 * @title Lib_AddressManager

 */

contract Lib_AddressManager is Ownable {



    /**********

     * Events *

     **********/



    event AddressSet(

        string indexed _name,

        address _newAddress,

        address _oldAddress

    );





    /*************

     * Variables *

     *************/



    mapping (bytes32 => address) private addresses;





    /********************

     * Public Functions *

     ********************/



    /**

     * Changes the address associated with a particular name.

     * @param _name String name to associate an address with.

     * @param _address Address to associate with the name.

     */

    function setAddress(

        string memory _name,

        address _address

    )

        external

        onlyOwner

    {

        bytes32 nameHash = _getNameHash(_name);

        address oldAddress = addresses[nameHash];

        addresses[nameHash] = _address;



        emit AddressSet(

            _name,

            _address,

            oldAddress

        );

    }



    /**

     * Retrieves the address associated with a given name.

     * @param _name Name to retrieve an address for.

     * @return Address associated with the given name.

     */

    function getAddress(

        string memory _name

    )

        external

        view

        returns (

            address

        )

    {

        return addresses[_getNameHash(_name)];

    }





    /**********************

     * Internal Functions *

     **********************/



    /**

     * Computes the hash of a name.

     * @param _name Name to compute a hash for.

     * @return Hash of the given name.

     */

    function _getNameHash(

        string memory _name

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        return keccak256(abi.encodePacked(_name));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_AddressResolver.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/* Library Imports */

import { Lib_AddressManager } from "./Lib_AddressManager.sol";



/**

 * @title Lib_AddressResolver

 */

abstract contract Lib_AddressResolver {



    /*************

     * Variables *

     *************/



    Lib_AddressManager public libAddressManager;





    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Lib_AddressManager.

     */

    constructor(

        address _libAddressManager

    ) {

        libAddressManager = Lib_AddressManager(_libAddressManager);

    }





    /********************

     * Public Functions *

     ********************/



    /**

     * Resolves the address associated with a given name.

     * @param _name Name to resolve an address for.

     * @return Address associated with the given name.

     */

    function resolve(

        string memory _name

    )

        public

        view

        returns (

            address

        )

    {

        return libAddressManager.getAddress(_name);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_Bytes32Utils.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/**

 * @title Lib_Byte32Utils

 */

library Lib_Bytes32Utils {



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to "true."

     * @param _in Input bytes32 value.

     * @return Bytes32 as a boolean.

     */

    function toBool(

        bytes32 _in

    )

        internal

        pure

        returns (

            bool

        )

    {

        return _in != 0;

    }



    /**

     * Converts a boolean to a bytes32 value.

     * @param _in Input boolean value.

     * @return Boolean as a bytes32.

     */

    function fromBool(

        bool _in

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        return bytes32(uint256(_in ? 1 : 0));

    }



    /**

     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.

     * @param _in Input bytes32 value.

     * @return Bytes32 as an address.

     */

    function toAddress(

        bytes32 _in

    )

        internal

        pure

        returns (

            address

        )

    {

        return address(uint160(uint256(_in)));

    }



    /**

     * Converts an address to a bytes32.

     * @param _in Input address value.

     * @return Address as a bytes32.

     */

    function fromAddress(

        address _in

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        return bytes32(uint256(_in));

    }



    /**

     * Removes the leading zeros from a bytes32 value and returns a new (smaller) bytes value.

     * @param _in Input bytes32 value.

     * @return Bytes32 without any leading zeros.

     */

    function removeLeadingZeros(

        bytes32 _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        bytes memory out;



        assembly {

            // Figure out how many leading zero bytes to remove.

            let shift := 0

            for { let i := 0 } and(lt(i, 32), eq(byte(i, _in), 0)) { i := add(i, 1) } {

                shift := add(shift, 1)

            }



            // Reserve some space for our output and fix the free memory pointer.

            out := mload(0x40)

            mstore(0x40, add(out, 0x40))



            // Shift the value and store it into the output bytes.

            mstore(add(out, 0x20), shl(mul(shift, 8), _in))



            // Store the new size (with leading zero bytes removed) in the output byte size.

            mstore(out, sub(32, shift))

        }



        return out;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_BytesUtils.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/**

 * @title Lib_BytesUtils

 */

library Lib_BytesUtils {



    /**********************

     * Internal Functions *

     **********************/



    function slice(

        bytes memory _bytes,

        uint256 _start,

        uint256 _length

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        require(_length + 31 >= _length, "slice_overflow");

        require(_start + _length >= _start, "slice_overflow");

        require(_bytes.length >= _start + _length, "slice_outOfBounds");



        bytes memory tempBytes;



        assembly {

            switch iszero(_length)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                let lengthmod := and(_length, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, _length)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, _length)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                //zero out the 32 bytes slice we are about to return

                //we need to do it because Solidity does not garbage collect

                mstore(tempBytes, 0)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return tempBytes;

    }



    function slice(

        bytes memory _bytes,

        uint256 _start

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        if (_start >= _bytes.length) {

            return bytes('');

        }



        return slice(_bytes, _start, _bytes.length - _start);

    }



    function toBytes32PadLeft(

        bytes memory _bytes

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        bytes32 ret;

        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;

        assembly {

            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))

        }

        return ret;

    }



    function toBytes32(

        bytes memory _bytes

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        if (_bytes.length < 32) {

            bytes32 ret;

            assembly {

                ret := mload(add(_bytes, 32))

            }

            return ret;

        }



        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes

    }



    function toUint256(

        bytes memory _bytes

    )

        internal

        pure

        returns (

            uint256

        )

    {

        return uint256(toBytes32(_bytes));

    }



    function toUint24(

        bytes memory _bytes,

        uint256 _start

    )

        internal

        pure

        returns (

            uint24

        )

    {

        require(_start + 3 >= _start, "toUint24_overflow");

        require(_bytes.length >= _start + 3 , "toUint24_outOfBounds");

        uint24 tempUint;



        assembly {

            tempUint := mload(add(add(_bytes, 0x3), _start))

        }



        return tempUint;

    }



    function toUint8(

        bytes memory _bytes,

        uint256 _start

    )

        internal

        pure

        returns (

            uint8

        )

    {

        require(_start + 1 >= _start, "toUint8_overflow");

        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");

        uint8 tempUint;



        assembly {

            tempUint := mload(add(add(_bytes, 0x1), _start))

        }



        return tempUint;

    }



    function toAddress(

        bytes memory _bytes,

        uint256 _start

    )

        internal

        pure

        returns (

            address

        )

    {

        require(_start + 20 >= _start, "toAddress_overflow");

        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");

        address tempAddress;



        assembly {

            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)

        }



        return tempAddress;

    }



    function toNibbles(

        bytes memory _bytes

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        bytes memory nibbles = new bytes(_bytes.length * 2);



        for (uint256 i = 0; i < _bytes.length; i++) {

            nibbles[i * 2] = _bytes[i] >> 4;

            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);

        }



        return nibbles;

    }



    function fromNibbles(

        bytes memory _bytes

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        bytes memory ret = new bytes(_bytes.length / 2);



        for (uint256 i = 0; i < ret.length; i++) {

            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);

        }



        return ret;

    }



    function equal(

        bytes memory _bytes,

        bytes memory _other

    )

        internal

        pure

        returns (

            bool

        )

    {

        return keccak256(_bytes) == keccak256(_other);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_CrossDomainUtils.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_RLPReader } from "../rlp/Lib_RLPReader.sol";



/**

 * @title Lib_CrossDomainUtils

 */

library Lib_CrossDomainUtils {

    /**

     * Generates the correct cross domain calldata for a message.

     * @param _target Target contract address.

     * @param _sender Message sender address.

     * @param _message Message to send to the target.

     * @param _messageNonce Nonce for the provided message.

     * @return ABI encoded cross domain calldata.

     */

    function encodeXDomainCalldata(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _messageNonce

    ) internal pure returns (bytes memory) {

        return

            abi.encodeWithSignature(

                "relayMessage(address,address,bytes,uint256)",

                _target,

                _sender,

                _message,

                _messageNonce

            );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_DefaultValues.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_DefaultValues

 */

library Lib_DefaultValues {

    // The default x-domain message sender being set to a non-zero value makes

    // deployment a bit more expensive, but in exchange the refund on every call to

    // `relayMessage` by the L1 and L2 messengers will be higher.

    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_ErrorUtils.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/**

 * @title Lib_ErrorUtils

 */

library Lib_ErrorUtils {



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Encodes an error string into raw solidity-style revert data.

     * (i.e. ascii bytes, prefixed with bytes4(keccak("Error(string))"))

     * Ref: https://docs.soliditylang.org/en/v0.8.2/control-structures.html?highlight=Error(string)#panic-via-assert-and-error-via-require

     * @param _reason Reason for the reversion.

     * @return Standard solidity revert data for the given reason.

     */

    function encodeRevertString(

        string memory _reason

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        return abi.encodeWithSignature(

            "Error(string)",

            _reason

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_EthUtils.sol
File type: .sol
// SPDX-License-Identifier: MIT

// @unsupported: ovm

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_RLPWriter } from "../rlp/Lib_RLPWriter.sol";

import { Lib_Bytes32Utils } from "./Lib_Bytes32Utils.sol";



/**

 * @title Lib_EthUtils

 */

library Lib_EthUtils {



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Gets the code for a given address.

     * @param _address Address to get code for.

     * @param _offset Offset to start reading from.

     * @param _length Number of bytes to read.

     * @return Code read from the contract.

     */

    function getCode(

        address _address,

        uint256 _offset,

        uint256 _length

    )

        internal

        view

        returns (

            bytes memory

        )

    {

        bytes memory code;

        assembly {

            code := mload(0x40)

            mstore(0x40, add(code, add(_length, 0x20)))

            mstore(code, _length)

            extcodecopy(_address, add(code, 0x20), _offset, _length)

        }



        return code;

    }



    /**

     * Gets the full code for a given address.

     * @param _address Address to get code for.

     * @return Full code of the contract.

     */

    function getCode(

        address _address

    )

        internal

        view

        returns (

            bytes memory

        )

    {

        return getCode(

            _address,

            0,

            getCodeSize(_address)

        );

    }



    /**

     * Gets the size of a contract's code in bytes.

     * @param _address Address to get code size for.

     * @return Size of the contract's code in bytes.

     */

    function getCodeSize(

        address _address

    )

        internal

        view

        returns (

            uint256

        )

    {

        uint256 codeSize;

        assembly {

            codeSize := extcodesize(_address)

        }



        return codeSize;

    }



    /**

     * Gets the hash of a contract's code.

     * @param _address Address to get a code hash for.

     * @return Hash of the contract's code.

     */

    function getCodeHash(

        address _address

    )

        internal

        view

        returns (

            bytes32

        )

    {

        bytes32 codeHash;

        assembly {

            codeHash := extcodehash(_address)

        }



        return codeHash;

    }



    /**

     * Creates a contract with some given initialization code.

     * @param _code Contract initialization code.

     * @return Address of the created contract.

     */

    function createContract(

        bytes memory _code

    )

        internal

        returns (

            address

        )

    {

        address created;

        assembly {

            created := create(

                0,

                add(_code, 0x20),

                mload(_code)

            )

        }



        return created;

    }



    /**

     * Computes the address that would be generated by CREATE.

     * @param _creator Address creating the contract.

     * @param _nonce Creator's nonce.

     * @return Address to be generated by CREATE.

     */

    function getAddressForCREATE(

        address _creator,

        uint256 _nonce

    )

        internal

        pure

        returns (

            address

        )

    {

        bytes[] memory encoded = new bytes[](2);

        encoded[0] = Lib_RLPWriter.writeAddress(_creator);

        encoded[1] = Lib_RLPWriter.writeUint(_nonce);



        bytes memory encodedList = Lib_RLPWriter.writeList(encoded);

        return Lib_Bytes32Utils.toAddress(keccak256(encodedList));

    }



    /**

     * Computes the address that would be generated by CREATE2.

     * @param _creator Address creating the contract.

     * @param _bytecode Bytecode of the contract to be created.

     * @param _salt 32 byte salt value mixed into the hash.

     * @return Address to be generated by CREATE2.

     */

    function getAddressForCREATE2(

        address _creator,

        bytes memory _bytecode,

        bytes32 _salt

    )

        internal

        pure

        returns (

            address

        )

    {

        bytes32 hashedData = keccak256(abi.encodePacked(

            byte(0xff),

            _creator,

            _salt,

            keccak256(_bytecode)

        ));



        return Lib_Bytes32Utils.toAddress(hashedData);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_MerkleTree.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/**

 * @title Lib_MerkleTree

 * @author River Keefer

 */

library Lib_MerkleTree {



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number

     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.

     * If you do not know the original length of elements for the tree you are verifying,

     * then this may allow empty leaves past _elements.length to pass a verification check down the line.

     * Note that the _elements argument is modified, therefore it must not be used again afterwards

     * @param _elements Array of hashes from which to generate a merkle root.

     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).

     */

    function getMerkleRoot(

        bytes32[] memory _elements

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        require(

            _elements.length > 0,

            "Lib_MerkleTree: Must provide at least one leaf hash."

        );



        if (_elements.length == 1) {

            return _elements[0];

        }



        uint256[16] memory defaults = [

            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,

            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,

            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,

            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,

            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,

            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,

            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,

            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,

            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,

            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,

            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,

            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,

            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,

            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,

            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,

            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10

        ];



        // Reserve memory space for our hashes.

        bytes memory buf = new bytes(64);



        // We'll need to keep track of left and right siblings.

        bytes32 leftSibling;

        bytes32 rightSibling;



        // Number of non-empty nodes at the current depth.

        uint256 rowSize = _elements.length;



        // Current depth, counting from 0 at the leaves

        uint256 depth = 0;



        // Common sub-expressions

        uint256 halfRowSize;         // rowSize / 2

        bool rowSizeIsOdd;           // rowSize % 2 == 1



        while (rowSize > 1) {

            halfRowSize = rowSize / 2;

            rowSizeIsOdd = rowSize % 2 == 1;



            for (uint256 i = 0; i < halfRowSize; i++) {

                leftSibling  = _elements[(2 * i)    ];

                rightSibling = _elements[(2 * i) + 1];

                assembly {

                    mstore(add(buf, 32), leftSibling )

                    mstore(add(buf, 64), rightSibling)

                }



                _elements[i] = keccak256(buf);

            }



            if (rowSizeIsOdd) {

                leftSibling  = _elements[rowSize - 1];

                rightSibling = bytes32(defaults[depth]);

                assembly {

                    mstore(add(buf, 32), leftSibling)

                    mstore(add(buf, 64), rightSibling)

                }



                _elements[halfRowSize] = keccak256(buf);

            }



            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);

            depth++;

        }



        return _elements[0];

    }



    /**

     * Verifies a merkle branch for the given leaf hash.  Assumes the original length

     * of leaves generated is a known, correct input, and does not return true for indices

     * extending past that index (even if _siblings would be otherwise valid.)

     * @param _root The Merkle root to verify against.

     * @param _leaf The leaf hash to verify inclusion of.

     * @param _index The index in the tree of this leaf.

     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0 (bottom of the tree).

     * @param _totalLeaves The total number of leaves originally passed into.

     * @return Whether or not the merkle branch and leaf passes verification.

     */

    function verify(

        bytes32 _root,

        bytes32 _leaf,

        uint256 _index,

        bytes32[] memory _siblings,

        uint256 _totalLeaves

    )

        internal

        pure

        returns (

            bool

        )

    {

        require(

            _totalLeaves > 0,

            "Lib_MerkleTree: Total leaves must be greater than zero."

        );



        require(

            _index < _totalLeaves,

            "Lib_MerkleTree: Index out of bounds."

        );



        require(

            _siblings.length == _ceilLog2(_totalLeaves),

            "Lib_MerkleTree: Total siblings does not correctly correspond to total leaves."

        );



        bytes32 computedRoot = _leaf;



        for (uint256 i = 0; i < _siblings.length; i++) {

            if ((_index & 1) == 1) {

                computedRoot = keccak256(

                    abi.encodePacked(

                        _siblings[i],

                        computedRoot

                    )

                );

            } else {

                computedRoot = keccak256(

                    abi.encodePacked(

                        computedRoot,

                        _siblings[i]

                    )

                );

            }



            _index >>= 1;

        }



        return _root == computedRoot;

    }





    /*********************

     * Private Functions *

     *********************/



    /**

     * Calculates the integer ceiling of the log base 2 of an input.

     * @param _in Unsigned input to calculate the log.

     * @return ceil(log_base_2(_in))

     */

    function _ceilLog2(

        uint256 _in

    )

        private

        pure

        returns (

            uint256

        )

    {

        require(

            _in > 0,

            "Lib_MerkleTree: Cannot compute ceil(log_2) of 0."

        );



        if (_in == 1) {

            return 0;

        }



        // Find the highest set bit (will be floor(log_2)).

        // Borrowed with <3 from https://github.com/ethereum/solidity-examples

        uint256 val = _in;

        uint256 highest = 0;

        for (uint256 i = 128; i >= 1; i >>= 1) {

            if (val & (uint(1) << i) - 1 << i != 0) {

                highest += i;

                val >>= i;

            }

        }



        // Increment by one if this is not a perfect logarithm.

        if ((uint(1) << highest) != _in) {

            highest += 1;

        }



        return highest;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_MerkleTrie.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_BytesUtils } from "../utils/Lib_BytesUtils.sol";

import { Lib_RLPReader } from "../rlp/Lib_RLPReader.sol";

import { Lib_RLPWriter } from "../rlp/Lib_RLPWriter.sol";



/**

 * @title Lib_MerkleTrie

 */

library Lib_MerkleTrie {

    /*******************

     * Data Structures *

     *******************/



    enum NodeType {

        BranchNode,

        ExtensionNode,

        LeafNode

    }



    struct TrieNode {

        bytes encoded;

        Lib_RLPReader.RLPItem[] decoded;

    }



    /**********************

     * Contract Constants *

     **********************/



    // TREE_RADIX determines the number of elements per branch node.

    uint256 constant TREE_RADIX = 16;

    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.

    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;

    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.

    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;



    // Prefixes are prepended to the `path` within a leaf or extension node and

    // allow us to differentiate between the two node types. `ODD` or `EVEN` is

    // determined by the number of nibbles within the unprefixed `path`. If the

    // number of nibbles if even, we need to insert an extra padding nibble so

    // the resulting prefixed `path` has an even number of nibbles.

    uint8 constant PREFIX_EXTENSION_EVEN = 0;

    uint8 constant PREFIX_EXTENSION_ODD = 1;

    uint8 constant PREFIX_LEAF_EVEN = 2;

    uint8 constant PREFIX_LEAF_ODD = 3;



    // Just a utility constant. RLP represents `NULL` as 0x80.

    bytes1 constant RLP_NULL = bytes1(0x80);

    bytes constant RLP_NULL_BYTES = hex"80";

    bytes32 internal constant KECCAK256_RLP_NULL_BYTES = keccak256(RLP_NULL_BYTES);



    /**********************

     * Internal Functions *

     **********************/



    /**

     * @notice Verifies a proof that a given key/value pair is present in the

     * Merkle trie.

     * @param _key Key of the node to search for, as a hex string.

     * @param _value Value of the node to search for, as a hex string.

     * @param _proof Merkle trie inclusion proof for the desired node. Unlike

     * traditional Merkle trees, this proof is executed top-down and consists

     * of a list of RLP-encoded nodes that make a path down to the target node.

     * @param _root Known root of the Merkle trie. Used to verify that the

     * included proof is correctly constructed.

     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.

     */

    function verifyInclusionProof(

        bytes memory _key,

        bytes memory _value,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bool _verified) {

        (bool exists, bytes memory value) = get(_key, _proof, _root);



        return (exists && Lib_BytesUtils.equal(_value, value));

    }



    /**

     * @notice Updates a Merkle trie and returns a new root hash.

     * @param _key Key of the node to update, as a hex string.

     * @param _value Value of the node to update, as a hex string.

     * @param _proof Merkle trie inclusion proof for the node *nearest* the

     * target node. If the key exists, we can simply update the value.

     * Otherwise, we need to modify the trie to handle the new k/v pair.

     * @param _root Known root of the Merkle trie. Used to verify that the

     * included proof is correctly constructed.

     * @return _updatedRoot Root hash of the newly constructed trie.

     */

    function update(

        bytes memory _key,

        bytes memory _value,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bytes32 _updatedRoot) {

        // Special case when inserting the very first node.

        if (_root == KECCAK256_RLP_NULL_BYTES) {

            return getSingleNodeRootHash(_key, _value);

        }



        TrieNode[] memory proof = _parseProof(_proof);

        (uint256 pathLength, bytes memory keyRemainder, ) = _walkNodePath(proof, _key, _root);

        TrieNode[] memory newPath = _getNewPath(proof, pathLength, _key, keyRemainder, _value);



        return _getUpdatedTrieRoot(newPath, _key);

    }



    /**

     * @notice Retrieves the value associated with a given key.

     * @param _key Key to search for, as hex bytes.

     * @param _proof Merkle trie inclusion proof for the key.

     * @param _root Known root of the Merkle trie.

     * @return _exists Whether or not the key exists.

     * @return _value Value of the key if it exists.

     */

    function get(

        bytes memory _key,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bool _exists, bytes memory _value) {

        TrieNode[] memory proof = _parseProof(_proof);

        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(

            proof,

            _key,

            _root

        );



        bool exists = keyRemainder.length == 0;



        require(exists || isFinalNode, "Provided proof is invalid.");



        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes("");



        return (exists, value);

    }



    /**

     * Computes the root hash for a trie with a single node.

     * @param _key Key for the single node.

     * @param _value Value for the single node.

     * @return _updatedRoot Hash of the trie.

     */

    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)

        internal

        pure

        returns (bytes32 _updatedRoot)

    {

        return keccak256(_makeLeafNode(Lib_BytesUtils.toNibbles(_key), _value).encoded);

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * @notice Walks through a proof using a provided key.

     * @param _proof Inclusion proof to walk through.

     * @param _key Key to use for the walk.

     * @param _root Known root of the trie.

     * @return _pathLength Length of the final path

     * @return _keyRemainder Portion of the key remaining after the walk.

     * @return _isFinalNode Whether or not we've hit a dead end.

     */

    function _walkNodePath(

        TrieNode[] memory _proof,

        bytes memory _key,

        bytes32 _root

    )

        private

        pure

        returns (

            uint256 _pathLength,

            bytes memory _keyRemainder,

            bool _isFinalNode

        )

    {

        uint256 pathLength = 0;

        bytes memory key = Lib_BytesUtils.toNibbles(_key);



        bytes32 currentNodeID = _root;

        uint256 currentKeyIndex = 0;

        uint256 currentKeyIncrement = 0;

        TrieNode memory currentNode;



        // Proof is top-down, so we start at the first element (root).

        for (uint256 i = 0; i < _proof.length; i++) {

            currentNode = _proof[i];

            currentKeyIndex += currentKeyIncrement;



            // Keep track of the proof elements we actually need.

            // It's expensive to resize arrays, so this simply reduces gas costs.

            pathLength += 1;



            if (currentKeyIndex == 0) {

                // First proof element is always the root node.

                require(keccak256(currentNode.encoded) == currentNodeID, "Invalid root hash");

            } else if (currentNode.encoded.length >= 32) {

                // Nodes 32 bytes or larger are hashed inside branch nodes.

                require(

                    keccak256(currentNode.encoded) == currentNodeID,

                    "Invalid large internal hash"

                );

            } else {

                // Nodes smaller than 31 bytes aren't hashed.

                require(

                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,

                    "Invalid internal node hash"

                );

            }



            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {

                if (currentKeyIndex == key.length) {

                    // We've hit the end of the key

                    // meaning the value should be within this branch node.

                    break;

                } else {

                    // We're not at the end of the key yet.

                    // Figure out what the next node ID should be and continue.

                    uint8 branchKey = uint8(key[currentKeyIndex]);

                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];

                    currentNodeID = _getNodeID(nextNode);

                    currentKeyIncrement = 1;

                    continue;

                }

            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {

                bytes memory path = _getNodePath(currentNode);

                uint8 prefix = uint8(path[0]);

                uint8 offset = 2 - (prefix % 2);

                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);

                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);

                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);



                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {

                    if (

                        pathRemainder.length == sharedNibbleLength &&

                        keyRemainder.length == sharedNibbleLength

                    ) {

                        // The key within this leaf matches our key exactly.

                        // Increment the key index to reflect that we have no remainder.

                        currentKeyIndex += sharedNibbleLength;

                    }



                    // We've hit a leaf node, so our next node should be NULL.

                    currentNodeID = bytes32(RLP_NULL);

                    break;

                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {

                    if (sharedNibbleLength != pathRemainder.length) {

                        // Our extension node is not identical to the remainder.

                        // We've hit the end of this path

                        // updates will need to modify this extension.

                        currentNodeID = bytes32(RLP_NULL);

                        break;

                    } else {

                        // Our extension shares some nibbles.

                        // Carry on to the next node.

                        currentNodeID = _getNodeID(currentNode.decoded[1]);

                        currentKeyIncrement = sharedNibbleLength;

                        continue;

                    }

                } else {

                    revert("Received a node with an unknown prefix");

                }

            } else {

                revert("Received an unparseable node.");

            }

        }



        // If our node ID is NULL, then we're at a dead end.

        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);

        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);

    }



    /**

     * @notice Creates new nodes to support a k/v pair insertion into a given Merkle trie path.

     * @param _path Path to the node nearest the k/v pair.

     * @param _pathLength Length of the path. Necessary because the provided path may include

     *  additional nodes (e.g., it comes directly from a proof) and we can't resize in-memory

     *  arrays without costly duplication.

     * @param _key Full original key.

     * @param _keyRemainder Portion of the initial key that must be inserted into the trie.

     * @param _value Value to insert at the given key.

     * @return _newPath A new path with the inserted k/v pair and extra supporting nodes.

     */

    function _getNewPath(

        TrieNode[] memory _path,

        uint256 _pathLength,

        bytes memory _key,

        bytes memory _keyRemainder,

        bytes memory _value

    ) private pure returns (TrieNode[] memory _newPath) {

        bytes memory keyRemainder = _keyRemainder;



        // Most of our logic depends on the status of the last node in the path.

        TrieNode memory lastNode = _path[_pathLength - 1];

        NodeType lastNodeType = _getNodeType(lastNode);



        // Create an array for newly created nodes.

        // We need up to three new nodes, depending on the contents of the last node.

        // Since array resizing is expensive, we'll keep track of the size manually.

        // We're using an explicit `totalNewNodes += 1` after insertions for clarity.

        TrieNode[] memory newNodes = new TrieNode[](3);

        uint256 totalNewNodes = 0;



        // solhint-disable-next-line max-line-length

        // Reference: https://github.com/ethereumjs/merkle-patricia-tree/blob/c0a10395aab37d42c175a47114ebfcbd7efcf059/src/baseTrie.ts#L294-L313

        bool matchLeaf = false;

        if (lastNodeType == NodeType.LeafNode) {

            uint256 l = 0;

            if (_path.length > 0) {

                for (uint256 i = 0; i < _path.length - 1; i++) {

                    if (_getNodeType(_path[i]) == NodeType.BranchNode) {

                        l++;

                    } else {

                        l += _getNodeKey(_path[i]).length;

                    }

                }

            }



            if (

                _getSharedNibbleLength(

                    _getNodeKey(lastNode),

                    Lib_BytesUtils.slice(Lib_BytesUtils.toNibbles(_key), l)

                ) ==

                _getNodeKey(lastNode).length &&

                keyRemainder.length == 0

            ) {

                matchLeaf = true;

            }

        }



        if (matchLeaf) {

            // We've found a leaf node with the given key.

            // Simply need to update the value of the node to match.

            newNodes[totalNewNodes] = _makeLeafNode(_getNodeKey(lastNode), _value);

            totalNewNodes += 1;

        } else if (lastNodeType == NodeType.BranchNode) {

            if (keyRemainder.length == 0) {

                // We've found a branch node with the given key.

                // Simply need to update the value of the node to match.

                newNodes[totalNewNodes] = _editBranchValue(lastNode, _value);

                totalNewNodes += 1;

            } else {

                // We've found a branch node, but it doesn't contain our key.

                // Reinsert the old branch for now.

                newNodes[totalNewNodes] = lastNode;

                totalNewNodes += 1;

                // Create a new leaf node, slicing our remainder since the first byte points

                // to our branch node.

                newNodes[totalNewNodes] = _makeLeafNode(

                    Lib_BytesUtils.slice(keyRemainder, 1),

                    _value

                );

                totalNewNodes += 1;

            }

        } else {

            // Our last node is either an extension node or a leaf node with a different key.

            bytes memory lastNodeKey = _getNodeKey(lastNode);

            uint256 sharedNibbleLength = _getSharedNibbleLength(lastNodeKey, keyRemainder);



            if (sharedNibbleLength != 0) {

                // We've got some shared nibbles between the last node and our key remainder.

                // We'll need to insert an extension node that covers these shared nibbles.

                bytes memory nextNodeKey = Lib_BytesUtils.slice(lastNodeKey, 0, sharedNibbleLength);

                newNodes[totalNewNodes] = _makeExtensionNode(nextNodeKey, _getNodeHash(_value));

                totalNewNodes += 1;



                // Cut down the keys since we've just covered these shared nibbles.

                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, sharedNibbleLength);

                keyRemainder = Lib_BytesUtils.slice(keyRemainder, sharedNibbleLength);

            }



            // Create an empty branch to fill in.

            TrieNode memory newBranch = _makeEmptyBranchNode();



            if (lastNodeKey.length == 0) {

                // Key remainder was larger than the key for our last node.

                // The value within our last node is therefore going to be shifted into

                // a branch value slot.

                newBranch = _editBranchValue(newBranch, _getNodeValue(lastNode));

            } else {

                // Last node key was larger than the key remainder.

                // We're going to modify some index of our branch.

                uint8 branchKey = uint8(lastNodeKey[0]);

                // Move on to the next nibble.

                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, 1);



                if (lastNodeType == NodeType.LeafNode) {

                    // We're dealing with a leaf node.

                    // We'll modify the key and insert the old leaf node into the branch index.

                    TrieNode memory modifiedLastNode = _makeLeafNode(

                        lastNodeKey,

                        _getNodeValue(lastNode)

                    );

                    newBranch = _editBranchIndex(

                        newBranch,

                        branchKey,

                        _getNodeHash(modifiedLastNode.encoded)

                    );

                } else if (lastNodeKey.length != 0) {

                    // We're dealing with a shrinking extension node.

                    // We need to modify the node to decrease the size of the key.

                    TrieNode memory modifiedLastNode = _makeExtensionNode(

                        lastNodeKey,

                        _getNodeValue(lastNode)

                    );

                    newBranch = _editBranchIndex(

                        newBranch,

                        branchKey,

                        _getNodeHash(modifiedLastNode.encoded)

                    );

                } else {

                    // We're dealing with an unnecessary extension node.

                    // We're going to delete the node entirely.

                    // Simply insert its current value into the branch index.

                    newBranch = _editBranchIndex(newBranch, branchKey, _getNodeValue(lastNode));

                }

            }



            if (keyRemainder.length == 0) {

                // We've got nothing left in the key remainder.

                // Simply insert the value into the branch value slot.

                newBranch = _editBranchValue(newBranch, _value);

                // Push the branch into the list of new nodes.

                newNodes[totalNewNodes] = newBranch;

                totalNewNodes += 1;

            } else {

                // We've got some key remainder to work with.

                // We'll be inserting a leaf node into the trie.

                // First, move on to the next nibble.

                keyRemainder = Lib_BytesUtils.slice(keyRemainder, 1);

                // Push the branch into the list of new nodes.

                newNodes[totalNewNodes] = newBranch;

                totalNewNodes += 1;

                // Push a new leaf node for our k/v pair.

                newNodes[totalNewNodes] = _makeLeafNode(keyRemainder, _value);

                totalNewNodes += 1;

            }

        }



        // Finally, join the old path with our newly created nodes.

        // Since we're overwriting the last node in the path, we use `_pathLength - 1`.

        return _joinNodeArrays(_path, _pathLength - 1, newNodes, totalNewNodes);

    }



    /**

     * @notice Computes the trie root from a given path.

     * @param _nodes Path to some k/v pair.

     * @param _key Key for the k/v pair.

     * @return _updatedRoot Root hash for the updated trie.

     */

    function _getUpdatedTrieRoot(TrieNode[] memory _nodes, bytes memory _key)

        private

        pure

        returns (bytes32 _updatedRoot)

    {

        bytes memory key = Lib_BytesUtils.toNibbles(_key);



        // Some variables to keep track of during iteration.

        TrieNode memory currentNode;

        NodeType currentNodeType;

        bytes memory previousNodeHash;



        // Run through the path backwards to rebuild our root hash.

        for (uint256 i = _nodes.length; i > 0; i--) {

            // Pick out the current node.

            currentNode = _nodes[i - 1];

            currentNodeType = _getNodeType(currentNode);



            if (currentNodeType == NodeType.LeafNode) {

                // Leaf nodes are already correctly encoded.

                // Shift the key over to account for the nodes key.

                bytes memory nodeKey = _getNodeKey(currentNode);

                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);

            } else if (currentNodeType == NodeType.ExtensionNode) {

                // Shift the key over to account for the nodes key.

                bytes memory nodeKey = _getNodeKey(currentNode);

                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);



                // If this node is the last element in the path, it'll be correctly encoded

                // and we can skip this part.

                if (previousNodeHash.length > 0) {

                    // Re-encode the node based on the previous node.

                    currentNode = _editExtensionNodeValue(currentNode, previousNodeHash);

                }

            } else if (currentNodeType == NodeType.BranchNode) {

                // If this node is the last element in the path, it'll be correctly encoded

                // and we can skip this part.

                if (previousNodeHash.length > 0) {

                    // Re-encode the node based on the previous node.

                    uint8 branchKey = uint8(key[key.length - 1]);

                    key = Lib_BytesUtils.slice(key, 0, key.length - 1);

                    currentNode = _editBranchIndex(currentNode, branchKey, previousNodeHash);

                }

            }



            // Compute the node hash for the next iteration.

            previousNodeHash = _getNodeHash(currentNode.encoded);

        }



        // Current node should be the root at this point.

        // Simply return the hash of its encoding.

        return keccak256(currentNode.encoded);

    }



    /**

     * @notice Parses an RLP-encoded proof into something more useful.

     * @param _proof RLP-encoded proof to parse.

     * @return _parsed Proof parsed into easily accessible structs.

     */

    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {

        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);

        TrieNode[] memory proof = new TrieNode[](nodes.length);



        for (uint256 i = 0; i < nodes.length; i++) {

            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);

            proof[i] = TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });

        }



        return proof;

    }



    /**

     * @notice Picks out the ID for a node. Node ID is referred to as the

     * "hash" within the specification, but nodes < 32 bytes are not actually

     * hashed.

     * @param _node Node to pull an ID for.

     * @return _nodeID ID for the node, depending on the size of its contents.

     */

    function _getNodeID(Lib_RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {

        bytes memory nodeID;



        if (_node.length < 32) {

            // Nodes smaller than 32 bytes are RLP encoded.

            nodeID = Lib_RLPReader.readRawBytes(_node);

        } else {

            // Nodes 32 bytes or larger are hashed.

            nodeID = Lib_RLPReader.readBytes(_node);

        }



        return Lib_BytesUtils.toBytes32(nodeID);

    }



    /**

     * @notice Gets the path for a leaf or extension node.

     * @param _node Node to get a path for.

     * @return _path Node path, converted to an array of nibbles.

     */

    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {

        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));

    }



    /**

     * @notice Gets the key for a leaf or extension node. Keys are essentially

     * just paths without any prefix.

     * @param _node Node to get a key for.

     * @return _key Node key, converted to an array of nibbles.

     */

    function _getNodeKey(TrieNode memory _node) private pure returns (bytes memory _key) {

        return _removeHexPrefix(_getNodePath(_node));

    }



    /**

     * @notice Gets the path for a node.

     * @param _node Node to get a value for.

     * @return _value Node value, as hex bytes.

     */

    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {

        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);

    }



    /**

     * @notice Computes the node hash for an encoded node. Nodes < 32 bytes

     * are not hashed, all others are keccak256 hashed.

     * @param _encoded Encoded node to hash.

     * @return _hash Hash of the encoded node. Simply the input if < 32 bytes.

     */

    function _getNodeHash(bytes memory _encoded) private pure returns (bytes memory _hash) {

        if (_encoded.length < 32) {

            return _encoded;

        } else {

            return abi.encodePacked(keccak256(_encoded));

        }

    }



    /**

     * @notice Determines the type for a given node.

     * @param _node Node to determine a type for.

     * @return _type Type of the node; BranchNode/ExtensionNode/LeafNode.

     */

    function _getNodeType(TrieNode memory _node) private pure returns (NodeType _type) {

        if (_node.decoded.length == BRANCH_NODE_LENGTH) {

            return NodeType.BranchNode;

        } else if (_node.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {

            bytes memory path = _getNodePath(_node);

            uint8 prefix = uint8(path[0]);



            if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {

                return NodeType.LeafNode;

            } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {

                return NodeType.ExtensionNode;

            }

        }



        revert("Invalid node type");

    }



    /**

     * @notice Utility; determines the number of nibbles shared between two

     * nibble arrays.

     * @param _a First nibble array.

     * @param _b Second nibble array.

     * @return _shared Number of shared nibbles.

     */

    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)

        private

        pure

        returns (uint256 _shared)

    {

        uint256 i = 0;

        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {

            i++;

        }

        return i;

    }



    /**

     * @notice Utility; converts an RLP-encoded node into our nice struct.

     * @param _raw RLP-encoded node to convert.

     * @return _node Node as a TrieNode struct.

     */

    function _makeNode(bytes[] memory _raw) private pure returns (TrieNode memory _node) {

        bytes memory encoded = Lib_RLPWriter.writeList(_raw);



        return TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });

    }



    /**

     * @notice Utility; converts an RLP-decoded node into our nice struct.

     * @param _items RLP-decoded node to convert.

     * @return _node Node as a TrieNode struct.

     */

    function _makeNode(Lib_RLPReader.RLPItem[] memory _items)

        private

        pure

        returns (TrieNode memory _node)

    {

        bytes[] memory raw = new bytes[](_items.length);

        for (uint256 i = 0; i < _items.length; i++) {

            raw[i] = Lib_RLPReader.readRawBytes(_items[i]);

        }

        return _makeNode(raw);

    }



    /**

     * @notice Creates a new extension node.

     * @param _key Key for the extension node, unprefixed.

     * @param _value Value for the extension node.

     * @return _node New extension node with the given k/v pair.

     */

    function _makeExtensionNode(bytes memory _key, bytes memory _value)

        private

        pure

        returns (TrieNode memory _node)

    {

        bytes[] memory raw = new bytes[](2);

        bytes memory key = _addHexPrefix(_key, false);

        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));

        raw[1] = Lib_RLPWriter.writeBytes(_value);

        return _makeNode(raw);

    }



    /**

     * Creates a new extension node with the same key but a different value.

     * @param _node Extension node to copy and modify.

     * @param _value New value for the extension node.

     * @return New node with the same key and different value.

     */

    function _editExtensionNodeValue(TrieNode memory _node, bytes memory _value)

        private

        pure

        returns (TrieNode memory)

    {

        bytes[] memory raw = new bytes[](2);

        bytes memory key = _addHexPrefix(_getNodeKey(_node), false);

        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));

        if (_value.length < 32) {

            raw[1] = _value;

        } else {

            raw[1] = Lib_RLPWriter.writeBytes(_value);

        }

        return _makeNode(raw);

    }



    /**

     * @notice Creates a new leaf node.

     * @dev This function is essentially identical to `_makeExtensionNode`.

     * Although we could route both to a single method with a flag, it's

     * more gas efficient to keep them separate and duplicate the logic.

     * @param _key Key for the leaf node, unprefixed.

     * @param _value Value for the leaf node.

     * @return _node New leaf node with the given k/v pair.

     */

    function _makeLeafNode(bytes memory _key, bytes memory _value)

        private

        pure

        returns (TrieNode memory _node)

    {

        bytes[] memory raw = new bytes[](2);

        bytes memory key = _addHexPrefix(_key, true);

        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));

        raw[1] = Lib_RLPWriter.writeBytes(_value);

        return _makeNode(raw);

    }



    /**

     * @notice Creates an empty branch node.

     * @return _node Empty branch node as a TrieNode struct.

     */

    function _makeEmptyBranchNode() private pure returns (TrieNode memory _node) {

        bytes[] memory raw = new bytes[](BRANCH_NODE_LENGTH);

        for (uint256 i = 0; i < raw.length; i++) {

            raw[i] = RLP_NULL_BYTES;

        }

        return _makeNode(raw);

    }



    /**

     * @notice Modifies the value slot for a given branch.

     * @param _branch Branch node to modify.

     * @param _value Value to insert into the branch.

     * @return _updatedNode Modified branch node.

     */

    function _editBranchValue(TrieNode memory _branch, bytes memory _value)

        private

        pure

        returns (TrieNode memory _updatedNode)

    {

        bytes memory encoded = Lib_RLPWriter.writeBytes(_value);

        _branch.decoded[_branch.decoded.length - 1] = Lib_RLPReader.toRLPItem(encoded);

        return _makeNode(_branch.decoded);

    }



    /**

     * @notice Modifies a slot at an index for a given branch.

     * @param _branch Branch node to modify.

     * @param _index Slot index to modify.

     * @param _value Value to insert into the slot.

     * @return _updatedNode Modified branch node.

     */

    function _editBranchIndex(

        TrieNode memory _branch,

        uint8 _index,

        bytes memory _value

    ) private pure returns (TrieNode memory _updatedNode) {

        bytes memory encoded = _value.length < 32 ? _value : Lib_RLPWriter.writeBytes(_value);

        _branch.decoded[_index] = Lib_RLPReader.toRLPItem(encoded);

        return _makeNode(_branch.decoded);

    }



    /**

     * @notice Utility; adds a prefix to a key.

     * @param _key Key to prefix.

     * @param _isLeaf Whether or not the key belongs to a leaf.

     * @return _prefixedKey Prefixed key.

     */

    function _addHexPrefix(bytes memory _key, bool _isLeaf)

        private

        pure

        returns (bytes memory _prefixedKey)

    {

        uint8 prefix = _isLeaf ? uint8(0x02) : uint8(0x00);

        uint8 offset = uint8(_key.length % 2);

        bytes memory prefixed = new bytes(2 - offset);

        prefixed[0] = bytes1(prefix + offset);

        return abi.encodePacked(prefixed, _key);

    }



    /**

     * @notice Utility; removes a prefix from a path.

     * @param _path Path to remove the prefix from.

     * @return _unprefixedKey Unprefixed key.

     */

    function _removeHexPrefix(bytes memory _path)

        private

        pure

        returns (bytes memory _unprefixedKey)

    {

        if (uint8(_path[0]) % 2 == 0) {

            return Lib_BytesUtils.slice(_path, 2);

        } else {

            return Lib_BytesUtils.slice(_path, 1);

        }

    }



    /**

     * @notice Utility; combines two node arrays. Array lengths are required

     * because the actual lengths may be longer than the filled lengths.

     * Array resizing is extremely costly and should be avoided.

     * @param _a First array to join.

     * @param _aLength Length of the first array.

     * @param _b Second array to join.

     * @param _bLength Length of the second array.

     * @return _joined Combined node array.

     */

    function _joinNodeArrays(

        TrieNode[] memory _a,

        uint256 _aLength,

        TrieNode[] memory _b,

        uint256 _bLength

    ) private pure returns (TrieNode[] memory _joined) {

        TrieNode[] memory ret = new TrieNode[](_aLength + _bLength);



        // Copy elements from the first array.

        for (uint256 i = 0; i < _aLength; i++) {

            ret[i] = _a[i];

        }



        // Copy elements from the second array.

        for (uint256 i = 0; i < _bLength; i++) {

            ret[i + _aLength] = _b[i];

        }



        return ret;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_OVMCodec.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_RLPReader } from "../rlp/Lib_RLPReader.sol";

import { Lib_RLPWriter } from "../rlp/Lib_RLPWriter.sol";

import { Lib_BytesUtils } from "../utils/Lib_BytesUtils.sol";

import { Lib_Bytes32Utils } from "../utils/Lib_Bytes32Utils.sol";



/**

 * @title Lib_OVMCodec

 */

library Lib_OVMCodec {



    /*********

     * Enums *

     *********/



    enum QueueOrigin {

        SEQUENCER_QUEUE,

        L1TOL2_QUEUE

    }





    /***********

     * Structs *

     ***********/



    struct Account {

        uint256 nonce;

        uint256 balance;

        bytes32 storageRoot;

        bytes32 codeHash;

        address ethAddress;

        bool isFresh;

    }



    struct EVMAccount {

        uint256 nonce;

        uint256 balance;

        bytes32 storageRoot;

        bytes32 codeHash;

    }



    struct ChainBatchHeader {

        uint256 batchIndex;

        bytes32 batchRoot;

        uint256 batchSize;

        uint256 prevTotalElements;

        bytes extraData;

    }



    struct ChainInclusionProof {

        uint256 index;

        bytes32[] siblings;

    }



    struct Transaction {

        uint256 timestamp;

        uint256 blockNumber;

        QueueOrigin l1QueueOrigin;

        address l1TxOrigin;

        address entrypoint;

        uint256 gasLimit;

        bytes data;

    }



    struct TransactionChainElement {

        bool isSequenced;

        uint256 queueIndex;  // QUEUED TX ONLY

        uint256 timestamp;   // SEQUENCER TX ONLY

        uint256 blockNumber; // SEQUENCER TX ONLY

        bytes txData;        // SEQUENCER TX ONLY

    }



    struct QueueElement {

        bytes32 transactionHash;

        uint40 timestamp;

        uint40 blockNumber;

    }





    /**********************

     * Internal Functions *

     **********************/



    /**

     * Encodes a standard OVM transaction.

     * @param _transaction OVM transaction to encode.

     * @return Encoded transaction bytes.

     */

    function encodeTransaction(

        Transaction memory _transaction

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        return abi.encodePacked(

            _transaction.timestamp,

            _transaction.blockNumber,

            _transaction.l1QueueOrigin,

            _transaction.l1TxOrigin,

            _transaction.entrypoint,

            _transaction.gasLimit,

            _transaction.data

        );

    }



    /**

     * Hashes a standard OVM transaction.

     * @param _transaction OVM transaction to encode.

     * @return Hashed transaction

     */

    function hashTransaction(

        Transaction memory _transaction

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        return keccak256(encodeTransaction(_transaction));

    }



    /**

     * Converts an OVM account to an EVM account.

     * @param _in OVM account to convert.

     * @return Converted EVM account.

     */

    function toEVMAccount(

        Account memory _in

    )

        internal

        pure

        returns (

            EVMAccount memory

        )

    {

        return EVMAccount({

            nonce: _in.nonce,

            balance: _in.balance,

            storageRoot: _in.storageRoot,

            codeHash: _in.codeHash

        });

    }



    /**

     * @notice RLP-encodes an account state struct.

     * @param _account Account state struct.

     * @return RLP-encoded account state.

     */

    function encodeEVMAccount(

        EVMAccount memory _account

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        bytes[] memory raw = new bytes[](4);



        // Unfortunately we can't create this array outright because

        // Lib_RLPWriter.writeList will reject fixed-size arrays. Assigning

        // index-by-index circumvents this issue.

        raw[0] = Lib_RLPWriter.writeBytes(

            Lib_Bytes32Utils.removeLeadingZeros(

                bytes32(_account.nonce)

            )

        );

        raw[1] = Lib_RLPWriter.writeBytes(

            Lib_Bytes32Utils.removeLeadingZeros(

                bytes32(_account.balance)

            )

        );

        raw[2] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.storageRoot));

        raw[3] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.codeHash));



        return Lib_RLPWriter.writeList(raw);

    }



    /**

     * @notice Decodes an RLP-encoded account state into a useful struct.

     * @param _encoded RLP-encoded account state.

     * @return Account state struct.

     */

    function decodeEVMAccount(

        bytes memory _encoded

    )

        internal

        pure

        returns (

            EVMAccount memory

        )

    {

        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);



        return EVMAccount({

            nonce: Lib_RLPReader.readUint256(accountState[0]),

            balance: Lib_RLPReader.readUint256(accountState[1]),

            storageRoot: Lib_RLPReader.readBytes32(accountState[2]),

            codeHash: Lib_RLPReader.readBytes32(accountState[3])

        });

    }



    /**

     * Calculates a hash for a given batch header.

     * @param _batchHeader Header to hash.

     * @return Hash of the header.

     */

    function hashBatchHeader(

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        return keccak256(

            abi.encode(

                _batchHeader.batchRoot,

                _batchHeader.batchSize,

                _batchHeader.prevTotalElements,

                _batchHeader.extraData

            )

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_PredeployAddresses.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_PredeployAddresses

 */

library Lib_PredeployAddresses {

    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;

    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;

    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;

    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);

    address internal constant L2_CROSS_DOMAIN_MESSENGER =

        0x4200000000000000000000000000000000000007;

    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;

    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;

    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;

    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;

    address internal constant L2_STANDARD_TOKEN_FACTORY =

        0x4200000000000000000000000000000000000012;

    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_RLPReader.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/**

 * @title Lib_RLPReader

 * @dev Adapted from "RLPReader" by Hamdi Allam (hamdi.allam97@gmail.com).

 */

library Lib_RLPReader {



    /*************

     * Constants *

     *************/



    uint256 constant internal MAX_LIST_LENGTH = 32;





    /*********

     * Enums *

     *********/



    enum RLPItemType {

        DATA_ITEM,

        LIST_ITEM

    }





    /***********

     * Structs *

     ***********/



    struct RLPItem {

        uint256 length;

        uint256 ptr;

    }





    /**********************

     * Internal Functions *

     **********************/



    /**

     * Converts bytes to a reference to memory position and length.

     * @param _in Input bytes to convert.

     * @return Output memory reference.

     */

    function toRLPItem(

        bytes memory _in

    )

        internal

        pure

        returns (

            RLPItem memory

        )

    {

        uint256 ptr;

        assembly {

            ptr := add(_in, 32)

        }



        return RLPItem({

            length: _in.length,

            ptr: ptr

        });

    }



    /**

     * Reads an RLP list value into a list of RLP items.

     * @param _in RLP list value.

     * @return Decoded RLP list items.

     */

    function readList(

        RLPItem memory _in

    )

        internal

        pure

        returns (

            RLPItem[] memory

        )

    {

        (

            uint256 listOffset,

            ,

            RLPItemType itemType

        ) = _decodeLength(_in);



        require(

            itemType == RLPItemType.LIST_ITEM,

            "Invalid RLP list value."

        );



        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by

        // writing to the length. Since we can't know the number of RLP items without looping over

        // the entire input, we'd have to loop twice to accurately size this array. It's easier to

        // simply set a reasonable maximum list length and decrease the size before we finish.

        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);



        uint256 itemCount = 0;

        uint256 offset = listOffset;

        while (offset < _in.length) {

            require(

                itemCount < MAX_LIST_LENGTH,

                "Provided RLP list exceeds max list length."

            );



            (

                uint256 itemOffset,

                uint256 itemLength,

            ) = _decodeLength(RLPItem({

                length: _in.length - offset,

                ptr: _in.ptr + offset

            }));



            out[itemCount] = RLPItem({

                length: itemLength + itemOffset,

                ptr: _in.ptr + offset

            });



            itemCount += 1;

            offset += itemOffset + itemLength;

        }



        // Decrease the array size to match the actual item count.

        assembly {

            mstore(out, itemCount)

        }



        return out;

    }



    /**

     * Reads an RLP list value into a list of RLP items.

     * @param _in RLP list value.

     * @return Decoded RLP list items.

     */

    function readList(

        bytes memory _in

    )

        internal

        pure

        returns (

            RLPItem[] memory

        )

    {

        return readList(

            toRLPItem(_in)

        );

    }



    /**

     * Reads an RLP bytes value into bytes.

     * @param _in RLP bytes value.

     * @return Decoded bytes.

     */

    function readBytes(

        RLPItem memory _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        (

            uint256 itemOffset,

            uint256 itemLength,

            RLPItemType itemType

        ) = _decodeLength(_in);



        require(

            itemType == RLPItemType.DATA_ITEM,

            "Invalid RLP bytes value."

        );



        return _copy(_in.ptr, itemOffset, itemLength);

    }



    /**

     * Reads an RLP bytes value into bytes.

     * @param _in RLP bytes value.

     * @return Decoded bytes.

     */

    function readBytes(

        bytes memory _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        return readBytes(

            toRLPItem(_in)

        );

    }



    /**

     * Reads an RLP string value into a string.

     * @param _in RLP string value.

     * @return Decoded string.

     */

    function readString(

        RLPItem memory _in

    )

        internal

        pure

        returns (

            string memory

        )

    {

        return string(readBytes(_in));

    }



    /**

     * Reads an RLP string value into a string.

     * @param _in RLP string value.

     * @return Decoded string.

     */

    function readString(

        bytes memory _in

    )

        internal

        pure

        returns (

            string memory

        )

    {

        return readString(

            toRLPItem(_in)

        );

    }



    /**

     * Reads an RLP bytes32 value into a bytes32.

     * @param _in RLP bytes32 value.

     * @return Decoded bytes32.

     */

    function readBytes32(

        RLPItem memory _in

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        require(

            _in.length <= 33,

            "Invalid RLP bytes32 value."

        );



        (

            uint256 itemOffset,

            uint256 itemLength,

            RLPItemType itemType

        ) = _decodeLength(_in);



        require(

            itemType == RLPItemType.DATA_ITEM,

            "Invalid RLP bytes32 value."

        );



        uint256 ptr = _in.ptr + itemOffset;

        bytes32 out;

        assembly {

            out := mload(ptr)



            // Shift the bytes over to match the item size.

            if lt(itemLength, 32) {

                out := div(out, exp(256, sub(32, itemLength)))

            }

        }



        return out;

    }



    /**

     * Reads an RLP bytes32 value into a bytes32.

     * @param _in RLP bytes32 value.

     * @return Decoded bytes32.

     */

    function readBytes32(

        bytes memory _in

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        return readBytes32(

            toRLPItem(_in)

        );

    }



    /**

     * Reads an RLP uint256 value into a uint256.

     * @param _in RLP uint256 value.

     * @return Decoded uint256.

     */

    function readUint256(

        RLPItem memory _in

    )

        internal

        pure

        returns (

            uint256

        )

    {

        return uint256(readBytes32(_in));

    }



    /**

     * Reads an RLP uint256 value into a uint256.

     * @param _in RLP uint256 value.

     * @return Decoded uint256.

     */

    function readUint256(

        bytes memory _in

    )

        internal

        pure

        returns (

            uint256

        )

    {

        return readUint256(

            toRLPItem(_in)

        );

    }



    /**

     * Reads an RLP bool value into a bool.

     * @param _in RLP bool value.

     * @return Decoded bool.

     */

    function readBool(

        RLPItem memory _in

    )

        internal

        pure

        returns (

            bool

        )

    {

        require(

            _in.length == 1,

            "Invalid RLP boolean value."

        );



        uint256 ptr = _in.ptr;

        uint256 out;

        assembly {

            out := byte(0, mload(ptr))

        }



        require(

            out == 0 || out == 1,

            "Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1"

        );



        return out != 0;

    }



    /**

     * Reads an RLP bool value into a bool.

     * @param _in RLP bool value.

     * @return Decoded bool.

     */

    function readBool(

        bytes memory _in

    )

        internal

        pure

        returns (

            bool

        )

    {

        return readBool(

            toRLPItem(_in)

        );

    }



    /**

     * Reads an RLP address value into a address.

     * @param _in RLP address value.

     * @return Decoded address.

     */

    function readAddress(

        RLPItem memory _in

    )

        internal

        pure

        returns (

            address

        )

    {

        if (_in.length == 1) {

            return address(0);

        }



        require(

            _in.length == 21,

            "Invalid RLP address value."

        );



        return address(readUint256(_in));

    }



    /**

     * Reads an RLP address value into a address.

     * @param _in RLP address value.

     * @return Decoded address.

     */

    function readAddress(

        bytes memory _in

    )

        internal

        pure

        returns (

            address

        )

    {

        return readAddress(

            toRLPItem(_in)

        );

    }



    /**

     * Reads the raw bytes of an RLP item.

     * @param _in RLP item to read.

     * @return Raw RLP bytes.

     */

    function readRawBytes(

        RLPItem memory _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        return _copy(_in);

    }





    /*********************

     * Private Functions *

     *********************/



    /**

     * Decodes the length of an RLP item.

     * @param _in RLP item to decode.

     * @return Offset of the encoded data.

     * @return Length of the encoded data.

     * @return RLP item type (LIST_ITEM or DATA_ITEM).

     */

    function _decodeLength(

        RLPItem memory _in

    )

        private

        pure

        returns (

            uint256,

            uint256,

            RLPItemType

        )

    {

        require(

            _in.length > 0,

            "RLP item cannot be null."

        );



        uint256 ptr = _in.ptr;

        uint256 prefix;

        assembly {

            prefix := byte(0, mload(ptr))

        }



        if (prefix <= 0x7f) {

            // Single byte.



            return (0, 1, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xb7) {

            // Short string.



            uint256 strLen = prefix - 0x80;



            require(

                _in.length > strLen,

                "Invalid RLP short string."

            );



            return (1, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xbf) {

            // Long string.

            uint256 lenOfStrLen = prefix - 0xb7;



            require(

                _in.length > lenOfStrLen,

                "Invalid RLP long string length."

            );



            uint256 strLen;

            assembly {

                // Pick out the string length.

                strLen := div(

                    mload(add(ptr, 1)),

                    exp(256, sub(32, lenOfStrLen))

                )

            }



            require(

                _in.length > lenOfStrLen + strLen,

                "Invalid RLP long string."

            );



            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xf7) {

            // Short list.

            uint256 listLen = prefix - 0xc0;



            require(

                _in.length > listLen,

                "Invalid RLP short list."

            );



            return (1, listLen, RLPItemType.LIST_ITEM);

        } else {

            // Long list.

            uint256 lenOfListLen = prefix - 0xf7;



            require(

                _in.length > lenOfListLen,

                "Invalid RLP long list length."

            );



            uint256 listLen;

            assembly {

                // Pick out the list length.

                listLen := div(

                    mload(add(ptr, 1)),

                    exp(256, sub(32, lenOfListLen))

                )

            }



            require(

                _in.length > lenOfListLen + listLen,

                "Invalid RLP long list."

            );



            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);

        }

    }



    /**

     * Copies the bytes from a memory location.

     * @param _src Pointer to the location to read from.

     * @param _offset Offset to start reading from.

     * @param _length Number of bytes to read.

     * @return Copied bytes.

     */

    function _copy(

        uint256 _src,

        uint256 _offset,

        uint256 _length

    )

        private

        pure

        returns (

            bytes memory

        )

    {

        bytes memory out = new bytes(_length);

        if (out.length == 0) {

            return out;

        }



        uint256 src = _src + _offset;

        uint256 dest;

        assembly {

            dest := add(out, 32)

        }



        // Copy over as many complete words as we can.

        for (uint256 i = 0; i < _length / 32; i++) {

            assembly {

                mstore(dest, mload(src))

            }



            src += 32;

            dest += 32;

        }



        // Pick out the remaining bytes.

        uint256 mask = 256 ** (32 - (_length % 32)) - 1;

        assembly {

            mstore(

                dest,

                or(

                    and(mload(src), not(mask)),

                    and(mload(dest), mask)

                )

            )

        }



        return out;

    }



    /**

     * Copies an RLP item into bytes.

     * @param _in RLP item to copy.

     * @return Copied bytes.

     */

    function _copy(

        RLPItem memory _in

    )

        private

        pure

        returns (

            bytes memory

        )

    {

        return _copy(_in.ptr, 0, _in.length);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_RLPWriter.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/**

 * @title Lib_RLPWriter

 * @author Bakaoh (with modifications)

 */

library Lib_RLPWriter {



    /**********************

     * Internal Functions *

     **********************/



    /**

     * RLP encodes a byte string.

     * @param _in The byte string to encode.

     * @return The RLP encoded string in bytes.

     */

    function writeBytes(

        bytes memory _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        bytes memory encoded;



        if (_in.length == 1 && uint8(_in[0]) < 128) {

            encoded = _in;

        } else {

            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);

        }



        return encoded;

    }



    /**

     * RLP encodes a list of RLP encoded byte byte strings.

     * @param _in The list of RLP encoded byte strings.

     * @return The RLP encoded list of items in bytes.

     */

    function writeList(

        bytes[] memory _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        bytes memory list = _flatten(_in);

        return abi.encodePacked(_writeLength(list.length, 192), list);

    }



    /**

     * RLP encodes a string.

     * @param _in The string to encode.

     * @return The RLP encoded string in bytes.

     */

    function writeString(

        string memory _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        return writeBytes(bytes(_in));

    }



    /**

     * RLP encodes an address.

     * @param _in The address to encode.

     * @return The RLP encoded address in bytes.

     */

    function writeAddress(

        address _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        return writeBytes(abi.encodePacked(_in));

    }



    /**

     * RLP encodes a bytes32 value.

     * @param _in The bytes32 to encode.

     * @return _out The RLP encoded bytes32 in bytes.

     */

    function writeBytes32(

        bytes32 _in

    )

        internal

        pure

        returns (

            bytes memory _out

        )

    {

        return writeBytes(abi.encodePacked(_in));

    }



    /**

     * RLP encodes a uint.

     * @param _in The uint256 to encode.

     * @return The RLP encoded uint256 in bytes.

     */

    function writeUint(

        uint256 _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        return writeBytes(_toBinary(_in));

    }



    /**

     * RLP encodes a bool.

     * @param _in The bool to encode.

     * @return The RLP encoded bool in bytes.

     */

    function writeBool(

        bool _in

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        bytes memory encoded = new bytes(1);

        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));

        return encoded;

    }





    /*********************

     * Private Functions *

     *********************/



    /**

     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.

     * @param _len The length of the string or the payload.

     * @param _offset 128 if item is string, 192 if item is list.

     * @return RLP encoded bytes.

     */

    function _writeLength(

        uint256 _len,

        uint256 _offset

    )

        private

        pure

        returns (

            bytes memory

        )

    {

        bytes memory encoded;



        if (_len < 56) {

            encoded = new bytes(1);

            encoded[0] = byte(uint8(_len) + uint8(_offset));

        } else {

            uint256 lenLen;

            uint256 i = 1;

            while (_len / i != 0) {

                lenLen++;

                i *= 256;

            }



            encoded = new bytes(lenLen + 1);

            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);

            for(i = 1; i <= lenLen; i++) {

                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));

            }

        }



        return encoded;

    }



    /**

     * Encode integer in big endian binary form with no leading zeroes.

     * @notice TODO: This should be optimized with assembly to save gas costs.

     * @param _x The integer to encode.

     * @return RLP encoded bytes.

     */

    function _toBinary(

        uint256 _x

    )

        private

        pure

        returns (

            bytes memory

        )

    {

        bytes memory b = abi.encodePacked(_x);



        uint256 i = 0;

        for (; i < 32; i++) {

            if (b[i] != 0) {

                break;

            }

        }



        bytes memory res = new bytes(32 - i);

        for (uint256 j = 0; j < res.length; j++) {

            res[j] = b[i++];

        }



        return res;

    }



    /**

     * Copies a piece of memory to another location.

     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.

     * @param _dest Destination location.

     * @param _src Source location.

     * @param _len Length of memory to copy.

     */

    function _memcpy(

        uint256 _dest,

        uint256 _src,

        uint256 _len

    )

        private

        pure

    {

        uint256 dest = _dest;

        uint256 src = _src;

        uint256 len = _len;



        for(; len >= 32; len -= 32) {

            assembly {

                mstore(dest, mload(src))

            }

            dest += 32;

            src += 32;

        }



        uint256 mask = 256 ** (32 - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }

    }



    /**

     * Flattens a list of byte strings into one byte string.

     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.

     * @param _list List of byte strings to flatten.

     * @return The flattened byte string.

     */

    function _flatten(

        bytes[] memory _list

    )

        private

        pure

        returns (

            bytes memory

        )

    {

        if (_list.length == 0) {

            return new bytes(0);

        }



        uint256 len;

        uint256 i = 0;

        for (; i < _list.length; i++) {

            len += _list[i].length;

        }



        bytes memory flattened = new bytes(len);

        uint256 flattenedPtr;

        assembly { flattenedPtr := add(flattened, 0x20) }



        for(i = 0; i < _list.length; i++) {

            bytes memory item = _list[i];



            uint256 listPtr;

            assembly { listPtr := add(item, 0x20)}



            _memcpy(flattenedPtr, listPtr, item.length);

            flattenedPtr += _list[i].length;

        }



        return flattened;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Lib_SecureMerkleTrie.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_MerkleTrie } from "./Lib_MerkleTrie.sol";



/**

 * @title Lib_SecureMerkleTrie

 */

library Lib_SecureMerkleTrie {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * @notice Verifies a proof that a given key/value pair is present in the

     * Merkle trie.

     * @param _key Key of the node to search for, as a hex string.

     * @param _value Value of the node to search for, as a hex string.

     * @param _proof Merkle trie inclusion proof for the desired node. Unlike

     * traditional Merkle trees, this proof is executed top-down and consists

     * of a list of RLP-encoded nodes that make a path down to the target node.

     * @param _root Known root of the Merkle trie. Used to verify that the

     * included proof is correctly constructed.

     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.

     */

    function verifyInclusionProof(

        bytes memory _key,

        bytes memory _value,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bool _verified) {

        bytes memory key = _getSecureKey(_key);

        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);

    }



    /**

     * @notice Updates a Merkle trie and returns a new root hash.

     * @param _key Key of the node to update, as a hex string.

     * @param _value Value of the node to update, as a hex string.

     * @param _proof Merkle trie inclusion proof for the node *nearest* the

     * target node. If the key exists, we can simply update the value.

     * Otherwise, we need to modify the trie to handle the new k/v pair.

     * @param _root Known root of the Merkle trie. Used to verify that the

     * included proof is correctly constructed.

     * @return _updatedRoot Root hash of the newly constructed trie.

     */

    function update(

        bytes memory _key,

        bytes memory _value,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bytes32 _updatedRoot) {

        bytes memory key = _getSecureKey(_key);

        return Lib_MerkleTrie.update(key, _value, _proof, _root);

    }



    /**

     * @notice Retrieves the value associated with a given key.

     * @param _key Key to search for, as hex bytes.

     * @param _proof Merkle trie inclusion proof for the key.

     * @param _root Known root of the Merkle trie.

     * @return _exists Whether or not the key exists.

     * @return _value Value of the key if it exists.

     */

    function get(

        bytes memory _key,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bool _exists, bytes memory _value) {

        bytes memory key = _getSecureKey(_key);

        return Lib_MerkleTrie.get(key, _proof, _root);

    }



    /**

     * Computes the root hash for a trie with a single node.

     * @param _key Key for the single node.

     * @param _value Value for the single node.

     * @return _updatedRoot Hash of the trie.

     */

    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)

        internal

        pure

        returns (bytes32 _updatedRoot)

    {

        bytes memory key = _getSecureKey(_key);

        return Lib_MerkleTrie.getSingleNodeRootHash(key, _value);

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Computes the secure counterpart to a key.

     * @param _key Key to get a secure key from.

     * @return _secureKey Secure version of the key.

     */

    function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {

        return abi.encodePacked(keccak256(_key));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Math.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)



pragma solidity ^0.8.0;



/**

 * @dev Standard math utilities missing in the Solidity language.

 */

library Math {

    enum Rounding {

        Down, // Toward negative infinity

        Up, // Toward infinity

        Zero // Toward zero

    }



    /**

     * @dev Returns the largest of two numbers.

     */

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    /**

     * @dev Returns the smallest of two numbers.

     */

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    /**

     * @dev Returns the average of two numbers. The result is rounded towards

     * zero.

     */

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b) / 2 can overflow.

        return (a & b) + (a ^ b) / 2;

    }



    /**

     * @dev Returns the ceiling of the division of two numbers.

     *

     * This differs from standard division with `/` in that it rounds up instead

     * of rounding down.

     */

    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b - 1) / b can overflow on addition, so we distribute.

        return a == 0 ? 0 : (a - 1) / b + 1;

    }



    /**

     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)

     * with further edits by Uniswap Labs also under MIT license.

     */

    function mulDiv(

        uint256 x,

        uint256 y,

        uint256 denominator

    ) internal pure returns (uint256 result) {

        unchecked {

            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use

            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256

            // variables such that product = prod1 * 2^256 + prod0.

            uint256 prod0; // Least significant 256 bits of the product

            uint256 prod1; // Most significant 256 bits of the product

            assembly {

                let mm := mulmod(x, y, not(0))

                prod0 := mul(x, y)

                prod1 := sub(sub(mm, prod0), lt(mm, prod0))

            }



            // Handle non-overflow cases, 256 by 256 division.

            if (prod1 == 0) {

                return prod0 / denominator;

            }



            // Make sure the result is less than 2^256. Also prevents denominator == 0.

            require(denominator > prod1);



            ///////////////////////////////////////////////

            // 512 by 256 division.

            ///////////////////////////////////////////////



            // Make division exact by subtracting the remainder from [prod1 prod0].

            uint256 remainder;

            assembly {

                // Compute remainder using mulmod.

                remainder := mulmod(x, y, denominator)



                // Subtract 256 bit number from 512 bit number.

                prod1 := sub(prod1, gt(remainder, prod0))

                prod0 := sub(prod0, remainder)

            }



            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.

            // See https://cs.stackexchange.com/q/138556/92363.



            // Does not overflow because the denominator cannot be zero at this stage in the function.

            uint256 twos = denominator & (~denominator + 1);

            assembly {

                // Divide denominator by twos.

                denominator := div(denominator, twos)



                // Divide [prod1 prod0] by twos.

                prod0 := div(prod0, twos)



                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.

                twos := add(div(sub(0, twos), twos), 1)

            }



            // Shift in bits from prod1 into prod0.

            prod0 |= prod1 * twos;



            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such

            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for

            // four bits. That is, denominator * inv = 1 mod 2^4.

            uint256 inverse = (3 * denominator) ^ 2;



            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works

            // in modular arithmetic, doubling the correct bits in each step.

            inverse *= 2 - denominator * inverse; // inverse mod 2^8

            inverse *= 2 - denominator * inverse; // inverse mod 2^16

            inverse *= 2 - denominator * inverse; // inverse mod 2^32

            inverse *= 2 - denominator * inverse; // inverse mod 2^64

            inverse *= 2 - denominator * inverse; // inverse mod 2^128

            inverse *= 2 - denominator * inverse; // inverse mod 2^256



            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.

            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is

            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1

            // is no longer required.

            result = prod0 * inverse;

            return result;

        }

    }



    /**

     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.

     */

    function mulDiv(

        uint256 x,

        uint256 y,

        uint256 denominator,

        Rounding rounding

    ) internal pure returns (uint256) {

        uint256 result = mulDiv(x, y, denominator);

        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {

            result += 1;

        }

        return result;

    }



    /**

     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.

     *

     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).

     */

    function sqrt(uint256 a) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        }



        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.

        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have

        // `msb(a) <= a < 2*msb(a)`.

        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.

        // This gives `2**k < a <= 2**(k+1)` ???? `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.

        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a

        // good first aproximation of `sqrt(a)` with at least 1 correct bit.

        uint256 result = 1;

        uint256 x = a;

        if (x >> 128 > 0) {

            x >>= 128;

            result <<= 64;

        }

        if (x >> 64 > 0) {

            x >>= 64;

            result <<= 32;

        }

        if (x >> 32 > 0) {

            x >>= 32;

            result <<= 16;

        }

        if (x >> 16 > 0) {

            x >>= 16;

            result <<= 8;

        }

        if (x >> 8 > 0) {

            x >>= 8;

            result <<= 4;

        }

        if (x >> 4 > 0) {

            x >>= 4;

            result <<= 2;

        }

        if (x >> 2 > 0) {

            result <<= 1;

        }



        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,

        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at

        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision

        // into the expected uint128 result.

        unchecked {

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            return min(result, a / result);

        }

    }



    /**

     * @notice Calculates sqrt(a), following the selected rounding direction.

     */

    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {

        uint256 result = sqrt(a);

        if (rounding == Rounding.Up && result * result < a) {

            result += 1;

        }

        return result;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\MerkleTrie.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import { Bytes } from "../Bytes.sol";

import { RLPReader } from "../rlp/RLPReader.sol";



/**

 * @title MerkleTrie

 * @notice MerkleTrie is a small library for verifying standard Ethereum Merkle-Patricia trie

 *         inclusion proofs. By default, this library assumes a hexary trie. One can change the

 *         trie radix constant to support other trie radixes.

 */

library MerkleTrie {

    /**

     * @notice Struct representing a node in the trie.

     *

     * @custom:field encoded The RLP-encoded node.

     * @custom:field decoded The RLP-decoded node.

     */

    struct TrieNode {

        bytes encoded;

        RLPReader.RLPItem[] decoded;

    }



    /**

     * @notice Determines the number of elements per branch node.

     */

    uint256 internal constant TREE_RADIX = 16;



    /**

     * @notice Branch nodes have TREE_RADIX elements and one value element.

     */

    uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;



    /**

     * @notice Leaf nodes and extension nodes have two elements, a `path` and a `value`.

     */

    uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;



    /**

     * @notice Prefix for even-nibbled extension node paths.

     */

    uint8 internal constant PREFIX_EXTENSION_EVEN = 0;



    /**

     * @notice Prefix for odd-nibbled extension node paths.

     */

    uint8 internal constant PREFIX_EXTENSION_ODD = 1;



    /**

     * @notice Prefix for even-nibbled leaf node paths.

     */

    uint8 internal constant PREFIX_LEAF_EVEN = 2;



    /**

     * @notice Prefix for odd-nibbled leaf node paths.

     */

    uint8 internal constant PREFIX_LEAF_ODD = 3;



    /**

     * @notice Verifies a proof that a given key/value pair is present in the trie.

     *

     * @param _key   Key of the node to search for, as a hex string.

     * @param _value Value of the node to search for, as a hex string.

     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle

     *               trees, this proof is executed top-down and consists of a list of RLP-encoded

     *               nodes that make a path down to the target node.

     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is

     *               correctly constructed.

     *

     * @return Whether or not the proof is valid.

     */

    function verifyInclusionProof(

        bytes memory _key,

        bytes memory _value,

        bytes[] memory _proof,

        bytes32 _root

    ) internal pure returns (bool) {

        return Bytes.equal(_value, get(_key, _proof, _root));

    }



    /**

     * @notice Retrieves the value associated with a given key.

     *

     * @param _key   Key to search for, as hex bytes.

     * @param _proof Merkle trie inclusion proof for the key.

     * @param _root  Known root of the Merkle trie.

     *

     * @return Value of the key if it exists.

     */

    function get(

        bytes memory _key,

        bytes[] memory _proof,

        bytes32 _root

    ) internal pure returns (bytes memory) {

        require(_key.length > 0, "MerkleTrie: empty key");



        TrieNode[] memory proof = _parseProof(_proof);

        bytes memory key = Bytes.toNibbles(_key);

        bytes memory currentNodeID = abi.encodePacked(_root);

        uint256 currentKeyIndex = 0;



        // Proof is top-down, so we start at the first element (root).

        for (uint256 i = 0; i < proof.length; i++) {

            TrieNode memory currentNode = proof[i];



            // Key index should never exceed total key length or we'll be out of bounds.

            require(

                currentKeyIndex <= key.length,

                "MerkleTrie: key index exceeds total key length"

            );



            if (currentKeyIndex == 0) {

                // First proof element is always the root node.

                require(

                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),

                    "MerkleTrie: invalid root hash"

                );

            } else if (currentNode.encoded.length >= 32) {

                // Nodes 32 bytes or larger are hashed inside branch nodes.

                require(

                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),

                    "MerkleTrie: invalid large internal hash"

                );

            } else {

                // Nodes smaller than 32 bytes aren't hashed.

                require(

                    Bytes.equal(currentNode.encoded, currentNodeID),

                    "MerkleTrie: invalid internal node hash"

                );

            }



            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {

                if (currentKeyIndex == key.length) {

                    // Value is the last element of the decoded list (for branch nodes). There's

                    // some ambiguity in the Merkle trie specification because bytes(0) is a

                    // valid value to place into the trie, but for branch nodes bytes(0) can exist

                    // even when the value wasn't explicitly placed there. Geth treats a value of

                    // bytes(0) as "key does not exist" and so we do the same.

                    bytes memory value = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);

                    require(

                        value.length > 0,

                        "MerkleTrie: value length must be greater than zero (branch)"

                    );



                    // Extra proof elements are not allowed.

                    require(

                        i == proof.length - 1,

                        "MerkleTrie: value node must be last node in proof (branch)"

                    );



                    return value;

                } else {

                    // We're not at the end of the key yet.

                    // Figure out what the next node ID should be and continue.

                    uint8 branchKey = uint8(key[currentKeyIndex]);

                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];

                    currentNodeID = _getNodeID(nextNode);

                    currentKeyIndex += 1;

                }

            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {

                bytes memory path = _getNodePath(currentNode);

                uint8 prefix = uint8(path[0]);

                uint8 offset = 2 - (prefix % 2);

                bytes memory pathRemainder = Bytes.slice(path, offset);

                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);

                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);



                // Whether this is a leaf node or an extension node, the path remainder MUST be a

                // prefix of the key remainder (or be equal to the key remainder) or the proof is

                // considered invalid.

                require(

                    pathRemainder.length == sharedNibbleLength,

                    "MerkleTrie: path remainder must share all nibbles with key"

                );



                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {

                    // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,

                    // the key remainder must be exactly equal to the path remainder. We already

                    // did the necessary byte comparison, so it's more efficient here to check that

                    // the key remainder length equals the shared nibble length, which implies

                    // equality with the path remainder (since we already did the same check with

                    // the path remainder and the shared nibble length).

                    require(

                        keyRemainder.length == sharedNibbleLength,

                        "MerkleTrie: key remainder must be identical to path remainder"

                    );



                    // Our Merkle Trie is designed specifically for the purposes of the Ethereum

                    // state trie. Empty values are not allowed in the state trie, so we can safely

                    // say that if the value is empty, the key should not exist and the proof is

                    // invalid.

                    bytes memory value = RLPReader.readBytes(currentNode.decoded[1]);

                    require(

                        value.length > 0,

                        "MerkleTrie: value length must be greater than zero (leaf)"

                    );



                    // Extra proof elements are not allowed.

                    require(

                        i == proof.length - 1,

                        "MerkleTrie: value node must be last node in proof (leaf)"

                    );



                    return value;

                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {

                    // Prefix of 0 or 1 means this is an extension node. We move onto the next node

                    // in the proof and increment the key index by the length of the path remainder

                    // which is equal to the shared nibble length.

                    currentNodeID = _getNodeID(currentNode.decoded[1]);

                    currentKeyIndex += sharedNibbleLength;

                } else {

                    revert("MerkleTrie: received a node with an unknown prefix");

                }

            } else {

                revert("MerkleTrie: received an unparseable node");

            }

        }



        revert("MerkleTrie: ran out of proof elements");

    }



    /**

     * @notice Parses an array of proof elements into a new array that contains both the original

     *         encoded element and the RLP-decoded element.

     *

     * @param _proof Array of proof elements to parse.

     *

     * @return Proof parsed into easily accessible structs.

     */

    function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory) {

        uint256 length = _proof.length;

        TrieNode[] memory proof = new TrieNode[](length);

        for (uint256 i = 0; i < length; ) {

            proof[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });

            unchecked {

                ++i;

            }

        }

        return proof;

    }



    /**

     * @notice Picks out the ID for a node. Node ID is referred to as the "hash" within the

     *         specification, but nodes < 32 bytes are not actually hashed.

     *

     * @param _node Node to pull an ID for.

     *

     * @return ID for the node, depending on the size of its contents.

     */

    function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory) {

        return _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);

    }



    /**

     * @notice Gets the path for a leaf or extension node.

     *

     * @param _node Node to get a path for.

     *

     * @return Node path, converted to an array of nibbles.

     */

    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory) {

        return Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));

    }



    /**

     * @notice Utility; determines the number of nibbles shared between two nibble arrays.

     *

     * @param _a First nibble array.

     * @param _b Second nibble array.

     *

     * @return Number of shared nibbles.

     */

    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)

        private

        pure

        returns (uint256)

    {

        uint256 shared;

        uint256 max = (_a.length < _b.length) ? _a.length : _b.length;

        for (; shared < max && _a[shared] == _b[shared]; ) {

            unchecked {

                ++shared;

            }

        }

        return shared;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\OptimismMintableERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

import { ILegacyMintableERC20, IOptimismMintableERC20 } from "./IOptimismMintableERC20.sol";

import { Semver } from "../universal/Semver.sol";



/**

 * @title OptimismMintableERC20

 * @notice OptimismMintableERC20 is a standard extension of the base ERC20 token contract designed

 *         to allow the StandardBridge contracts to mint and burn tokens. This makes it possible to

 *         use an OptimismMintablERC20 as the L2 representation of an L1 token, or vice-versa.

 *         Designed to be backwards compatible with the older StandardL2ERC20 token which was only

 *         meant for use on L2.

 */

contract OptimismMintableERC20 is IOptimismMintableERC20, ILegacyMintableERC20, ERC20, Semver {

    /**

     * @notice Address of the corresponding version of this token on the remote chain.

     */

    address public immutable REMOTE_TOKEN;



    /**

     * @notice Address of the StandardBridge on this network.

     */

    address public immutable BRIDGE;



    /**

     * @notice Emitted whenever tokens are minted for an account.

     *

     * @param account Address of the account tokens are being minted for.

     * @param amount  Amount of tokens minted.

     */

    event Mint(address indexed account, uint256 amount);



    /**

     * @notice Emitted whenever tokens are burned from an account.

     *

     * @param account Address of the account tokens are being burned from.

     * @param amount  Amount of tokens burned.

     */

    event Burn(address indexed account, uint256 amount);



    /**

     * @notice A modifier that only allows the bridge to call

     */

    modifier onlyBridge() {

        require(msg.sender == BRIDGE, "OptimismMintableERC20: only bridge can mint and burn");

        _;

    }



    /**

     * @custom:semver 1.0.0

     *

     * @param _bridge      Address of the L2 standard bridge.

     * @param _remoteToken Address of the corresponding L1 token.

     * @param _name        ERC20 name.

     * @param _symbol      ERC20 symbol.

     */

    constructor(

        address _bridge,

        address _remoteToken,

        string memory _name,

        string memory _symbol

    ) ERC20(_name, _symbol) Semver(1, 0, 0) {

        REMOTE_TOKEN = _remoteToken;

        BRIDGE = _bridge;

    }



    /**

     * @notice Allows the StandardBridge on this network to mint tokens.

     *

     * @param _to     Address to mint tokens to.

     * @param _amount Amount of tokens to mint.

     */

    function mint(address _to, uint256 _amount)

        external

        virtual

        override(IOptimismMintableERC20, ILegacyMintableERC20)

        onlyBridge

    {

        _mint(_to, _amount);

        emit Mint(_to, _amount);

    }



    /**

     * @notice Allows the StandardBridge on this network to burn tokens.

     *

     * @param _from   Address to burn tokens from.

     * @param _amount Amount of tokens to burn.

     */

    function burn(address _from, uint256 _amount)

        external

        virtual

        override(IOptimismMintableERC20, ILegacyMintableERC20)

        onlyBridge

    {

        _burn(_from, _amount);

        emit Burn(_from, _amount);

    }



    /**

     * @notice ERC165 interface check function.

     *

     * @param _interfaceId Interface ID to check.

     *

     * @return Whether or not the interface is supported by this contract.

     */

    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {

        bytes4 iface1 = type(IERC165).interfaceId;

        // Interface corresponding to the legacy L2StandardERC20.

        bytes4 iface2 = type(ILegacyMintableERC20).interfaceId;

        // Interface corresponding to the updated OptimismMintableERC20 (this contract).

        bytes4 iface3 = type(IOptimismMintableERC20).interfaceId;

        return _interfaceId == iface1 || _interfaceId == iface2 || _interfaceId == iface3;

    }



    /**

     * @custom:legacy

     * @notice Legacy getter for the remote token. Use REMOTE_TOKEN going forward.

     */

    function l1Token() public view returns (address) {

        return REMOTE_TOKEN;

    }



    /**

     * @custom:legacy

     * @notice Legacy getter for the bridge. Use BRIDGE going forward.

     */

    function l2Bridge() public view returns (address) {

        return BRIDGE;

    }



    /**

     * @custom:legacy

     * @notice Legacy getter for REMOTE_TOKEN.

     */

    function remoteToken() public view returns (address) {

        return REMOTE_TOKEN;

    }



    /**

     * @custom:legacy

     * @notice Legacy getter for BRIDGE.

     */

    function bridge() public view returns (address) {

        return BRIDGE;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\OptimismPortal.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



import { Initializable } from "@openzeppelin/contracts/proxy/utils/Initializable.sol";

import { SafeCall } from "../libraries/SafeCall.sol";

import { L2OutputOracle } from "./L2OutputOracle.sol";

import { SystemConfig } from "./SystemConfig.sol";

import { Constants } from "../libraries/Constants.sol";

import { Types } from "../libraries/Types.sol";

import { Hashing } from "../libraries/Hashing.sol";

import { SecureMerkleTrie } from "../libraries/trie/SecureMerkleTrie.sol";

import { AddressAliasHelper } from "../vendor/AddressAliasHelper.sol";

import { ResourceMetering } from "./ResourceMetering.sol";

import { Semver } from "../universal/Semver.sol";



/**

 * @custom:proxied

 * @title OptimismPortal

 * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1

 *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.

 *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.

 */

contract OptimismPortal is Initializable, ResourceMetering, Semver {

    /**

     * @notice Represents a proven withdrawal.

     *

     * @custom:field outputRoot    Root of the L2 output this was proven against.

     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.

     * @custom:field l2OutputIndex Index of the output this was proven against.

     */

    struct ProvenWithdrawal {

        bytes32 outputRoot;

        uint128 timestamp;

        uint128 l2OutputIndex;

    }



    /**

     * @notice Version of the deposit event.

     */

    uint256 internal constant DEPOSIT_VERSION = 0;



    /**

     * @notice The L2 gas limit set when eth is deposited using the receive() function.

     */

    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;



    /**

     * @notice Address of the L2OutputOracle contract.

     */

    L2OutputOracle public immutable L2_ORACLE;



    /**

     * @notice Address of the SystemConfig contract.

     */

    SystemConfig public immutable SYSTEM_CONFIG;



    /**

     * @notice Address that has the ability to pause and unpause withdrawals.

     */

    address public immutable GUARDIAN;



    /**

     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the

     *         of this variable is the default L2 sender address, then we are NOT inside of a call

     *         to finalizeWithdrawalTransaction.

     */

    address public l2Sender;



    /**

     * @notice A list of withdrawal hashes which have been successfully finalized.

     */

    mapping(bytes32 => bool) public finalizedWithdrawals;



    /**

     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.

     */

    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;



    /**

     * @notice Determines if cross domain messaging is paused. When set to true,

     *         withdrawals are paused. This may be removed in the future.

     */

    bool public paused;



    /**

     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event

     *         are read by the rollup node and used to derive deposit transactions on L2.

     *

     * @param from       Address that triggered the deposit transaction.

     * @param to         Address that the deposit transaction is directed to.

     * @param version    Version of this deposit transaction event.

     * @param opaqueData ABI encoded deposit data to be parsed off-chain.

     */

    event TransactionDeposited(

        address indexed from,

        address indexed to,

        uint256 indexed version,

        bytes opaqueData

    );



    /**

     * @notice Emitted when a withdrawal transaction is proven.

     *

     * @param withdrawalHash Hash of the withdrawal transaction.

     */

    event WithdrawalProven(

        bytes32 indexed withdrawalHash,

        address indexed from,

        address indexed to

    );



    /**

     * @notice Emitted when a withdrawal transaction is finalized.

     *

     * @param withdrawalHash Hash of the withdrawal transaction.

     * @param success        Whether the withdrawal transaction was successful.

     */

    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);



    /**

     * @notice Emitted when the pause is triggered.

     *

     * @param account Address of the account triggering the pause.

     */

    event Paused(address account);



    /**

     * @notice Emitted when the pause is lifted.

     *

     * @param account Address of the account triggering the unpause.

     */

    event Unpaused(address account);



    /**

     * @notice Reverts when paused.

     */

    modifier whenNotPaused() {

        require(paused == false, "OptimismPortal: paused");

        _;

    }



    /**

     * @custom:semver 1.6.0

     *

     * @param _l2Oracle                  Address of the L2OutputOracle contract.

     * @param _guardian                  Address that can pause deposits and withdrawals.

     * @param _paused                    Sets the contract's pausability state.

     * @param _config                    Address of the SystemConfig contract.

     */

    constructor(

        L2OutputOracle _l2Oracle,

        address _guardian,

        bool _paused,

        SystemConfig _config

    ) Semver(1, 6, 0) {

        L2_ORACLE = _l2Oracle;

        GUARDIAN = _guardian;

        SYSTEM_CONFIG = _config;

        initialize(_paused);

    }



    /**

     * @notice Initializer.

     */

    function initialize(bool _paused) public initializer {

        l2Sender = Constants.DEFAULT_L2_SENDER;

        paused = _paused;

        __ResourceMetering_init();

    }



    /**

     * @notice Pause deposits and withdrawals.

     */

    function pause() external {

        require(msg.sender == GUARDIAN, "OptimismPortal: only guardian can pause");

        paused = true;

        emit Paused(msg.sender);

    }



    /**

     * @notice Unpause deposits and withdrawals.

     */

    function unpause() external {

        require(msg.sender == GUARDIAN, "OptimismPortal: only guardian can unpause");

        paused = false;

        emit Unpaused(msg.sender);

    }



    /**

     * @notice Computes the minimum gas limit for a deposit. The minimum gas limit

     *         linearly increases based on the size of the calldata. This is to prevent

     *         users from creating L2 resource usage without paying for it. This function

     *         can be used when interacting with the portal to ensure forwards compatibility.

     *

     */

    function minimumGasLimit(uint64 _byteCount) public pure returns (uint64) {

        return _byteCount * 16 + 21000;

    }



    /**

     * @notice Accepts value so that users can send ETH directly to this contract and have the

     *         funds be deposited to their address on L2. This is intended as a convenience

     *         function for EOAs. Contracts should call the depositTransaction() function directly

     *         otherwise any deposited funds will be lost due to address aliasing.

     */

    // solhint-disable-next-line ordering

    receive() external payable {

        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(""));

    }



    /**

     * @notice Accepts ETH value without triggering a deposit to L2. This function mainly exists

     *         for the sake of the migration between the legacy Optimism system and Bedrock.

     */

    function donateETH() external payable {

        // Intentionally empty.

    }



    /**

     * @notice Getter for the resource config. Used internally by the ResourceMetering

     *         contract. The SystemConfig is the source of truth for the resource config.

     *

     * @return ResourceMetering.ResourceConfig

     */

    function _resourceConfig()

        internal

        view

        override

        returns (ResourceMetering.ResourceConfig memory)

    {

        return SYSTEM_CONFIG.resourceConfig();

    }



    /**

     * @notice Proves a withdrawal transaction.

     *

     * @param _tx              Withdrawal transaction to finalize.

     * @param _l2OutputIndex   L2 output index to prove against.

     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.

     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.

     */

    function proveWithdrawalTransaction(

        Types.WithdrawalTransaction memory _tx,

        uint256 _l2OutputIndex,

        Types.OutputRootProof calldata _outputRootProof,

        bytes[] calldata _withdrawalProof

    ) external whenNotPaused {

        // Prevent users from creating a deposit transaction where this address is the message

        // sender on L2. Because this is checked here, we do not need to check again in

        // `finalizeWithdrawalTransaction`.

        require(

            _tx.target != address(this),

            "OptimismPortal: you cannot send messages to the portal contract"

        );



        // Get the output root and load onto the stack to prevent multiple mloads. This will

        // revert if there is no output root for the given block number.

        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;



        // Verify that the output root can be generated with the elements in the proof.

        require(

            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),

            "OptimismPortal: invalid output root proof"

        );



        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.

        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);

        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];



        // We generally want to prevent users from proving the same withdrawal multiple times

        // because each successive proof will update the timestamp. A malicious user can take

        // advantage of this to prevent other users from finalizing their withdrawal. However,

        // since withdrawals are proven before an output root is finalized, we need to allow users

        // to re-prove their withdrawal only in the case that the output root for their specified

        // output index has been updated.

        require(

            provenWithdrawal.timestamp == 0 ||

                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=

                provenWithdrawal.outputRoot,

            "OptimismPortal: withdrawal hash has already been proven"

        );



        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.

        // Refer to the Solidity documentation for more information on how storage layouts are

        // computed for mappings.

        bytes32 storageKey = keccak256(

            abi.encode(

                withdrawalHash,

                uint256(0) // The withdrawals mapping is at the first slot in the layout.

            )

        );



        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract

        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have

        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore

        // be relayed on L1.

        require(

            SecureMerkleTrie.verifyInclusionProof(

                abi.encode(storageKey),

                hex"01",

                _withdrawalProof,

                _outputRootProof.messagePasserStorageRoot

            ),

            "OptimismPortal: invalid withdrawal inclusion proof"

        );



        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and

        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be

        // proven once unless it is submitted again with a different outputRoot.

        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({

            outputRoot: outputRoot,

            timestamp: uint128(block.timestamp),

            l2OutputIndex: uint128(_l2OutputIndex)

        });



        // Emit a `WithdrawalProven` event.

        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);

    }



    /**

     * @notice Finalizes a withdrawal transaction.

     *

     * @param _tx Withdrawal transaction to finalize.

     */

    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)

        external

        whenNotPaused

    {

        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other

        // than the default value when a withdrawal transaction is being finalized. This check is

        // a defacto reentrancy guard.

        require(

            l2Sender == Constants.DEFAULT_L2_SENDER,

            "OptimismPortal: can only trigger one withdrawal per transaction"

        );



        // Grab the proven withdrawal from the `provenWithdrawals` map.

        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);

        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];



        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has

        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have

        // a timestamp of zero.

        require(

            provenWithdrawal.timestamp != 0,

            "OptimismPortal: withdrawal has not been proven yet"

        );



        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than

        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of

        // safety against weird bugs in the proving step.

        require(

            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),

            "OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp"

        );



        // A proven withdrawal must wait at least the finalization period before it can be

        // finalized. This waiting period can elapse in parallel with the waiting period for the

        // output the withdrawal was proven against. In effect, this means that the minimum

        // withdrawal time is proposal submission time + finalization period.

        require(

            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),

            "OptimismPortal: proven withdrawal finalization period has not elapsed"

        );



        // Grab the OutputProposal from the L2OutputOracle, will revert if the output that

        // corresponds to the given index has not been proposed yet.

        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(

            provenWithdrawal.l2OutputIndex

        );



        // Check that the output root that was used to prove the withdrawal is the same as the

        // current output root for the given output index. An output root may change if it is

        // deleted by the challenger address and then re-proposed.

        require(

            proposal.outputRoot == provenWithdrawal.outputRoot,

            "OptimismPortal: output root proven is not the same as current output root"

        );



        // Check that the output proposal has also been finalized.

        require(

            _isFinalizationPeriodElapsed(proposal.timestamp),

            "OptimismPortal: output proposal finalization period has not elapsed"

        );



        // Check that this withdrawal has not already been finalized, this is replay protection.

        require(

            finalizedWithdrawals[withdrawalHash] == false,

            "OptimismPortal: withdrawal has already been finalized"

        );



        // Mark the withdrawal as finalized so it can't be replayed.

        finalizedWithdrawals[withdrawalHash] = true;



        // Set the l2Sender so contracts know who triggered this withdrawal on L2.

        l2Sender = _tx.sender;



        // Trigger the call to the target contract. We use a custom low level method

        // SafeCall.callWithMinGas to ensure two key properties

        //   1. Target contracts cannot force this call to run out of gas by returning a very large

        //      amount of data (and this is OK because we don't care about the returndata here).

        //   2. The amount of gas provided to the execution context of the target is at least the

        //      gas limit specified by the user. If there is not enough gas in the current context

        //      to accomplish this, `callWithMinGas` will revert.

        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);



        // Reset the l2Sender back to the default value.

        l2Sender = Constants.DEFAULT_L2_SENDER;



        // All withdrawals are immediately finalized. Replayability can

        // be achieved through contracts built on top of this contract

        emit WithdrawalFinalized(withdrawalHash, success);



        // Reverting here is useful for determining the exact gas cost to successfully execute the

        // sub call to the target contract if the minimum gas limit specified by the user would not

        // be sufficient to execute the sub call.

        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {

            revert("OptimismPortal: withdrawal failed");

        }

    }



    /**

     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in

     *         deriving deposit transactions. Note that if a deposit is made by a contract, its

     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider

     *         using the CrossDomainMessenger contracts for a simpler developer experience.

     *

     * @param _to         Target address on L2.

     * @param _value      ETH value to send to the recipient.

     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).

     * @param _isCreation Whether or not the transaction is a contract creation.

     * @param _data       Data to trigger the recipient with.

     */

    function depositTransaction(

        address _to,

        uint256 _value,

        uint64 _gasLimit,

        bool _isCreation,

        bytes memory _data

    ) public payable metered(_gasLimit) {

        // Just to be safe, make sure that people specify address(0) as the target when doing

        // contract creations.

        if (_isCreation) {

            require(

                _to == address(0),

                "OptimismPortal: must send to address(0) when creating a contract"

            );

        }



        // Prevent depositing transactions that have too small of a gas limit. Users should pay

        // more for more resource usage.

        require(

            _gasLimit >= minimumGasLimit(uint64(_data.length)),

            "OptimismPortal: gas limit too small"

        );



        // Prevent the creation of deposit transactions that have too much calldata. This gives an

        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure

        // that the transaction can fit into the p2p network policy of 128kb even though deposit

        // transactions are not gossipped over the p2p network.

        require(_data.length <= 120_000, "OptimismPortal: data too large");



        // Transform the from-address to its alias if the caller is a contract.

        address from = msg.sender;

        if (msg.sender != tx.origin) {

            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);

        }



        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.

        // We use opaque data so that we can update the TransactionDeposited event in the future

        // without breaking the current interface.

        bytes memory opaqueData = abi.encodePacked(

            msg.value,

            _value,

            _gasLimit,

            _isCreation,

            _data

        );



        // Emit a TransactionDeposited event so that the rollup node can derive a deposit

        // transaction for this deposit.

        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);

    }



    /**

     * @notice Determine if a given output is finalized. Reverts if the call to

     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.

     *

     * @param _l2OutputIndex Index of the L2 output to check.

     *

     * @return Whether or not the output is finalized.

     */

    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {

        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);

    }



    /**

     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.

     *

     * @param _timestamp Timestamp to check.

     *

     * @return Whether or not the finalization period has elapsed.

     */

    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {

        return block.timestamp > _timestamp + L2_ORACLE.FINALIZATION_PERIOD_SECONDS();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\OVM_CanonicalTransactionChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

// @unsupported: ovm

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";

import { Lib_AddressResolver } from "../../libraries/resolver/Lib_AddressResolver.sol";

import { Lib_MerkleTree } from "../../libraries/utils/Lib_MerkleTree.sol";



/* Interface Imports */

import { iOVM_CanonicalTransactionChain } from "../../iOVM/chain/iOVM_CanonicalTransactionChain.sol";

import { iOVM_ChainStorageContainer } from "../../iOVM/chain/iOVM_ChainStorageContainer.sol";



/* Contract Imports */

import { OVM_ExecutionManager } from "../execution/OVM_ExecutionManager.sol";



/* External Imports */

import { Math } from "@openzeppelin/contracts/math/Math.sol";



/**

 * @title OVM_CanonicalTransactionChain

 * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions

 * which must be applied to the rollup state. It defines the ordering of rollup transactions by

 * writing them to the 'CTC:batches' instance of the Chain Storage Container.

 * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the Sequencer

 * will eventually append it to the rollup state.

 * If the Sequencer does not include an enqueued transaction within the 'force inclusion period',

 * then any account may force it to be included by calling appendQueueBatch().

 *

 * Compiler used: solc

 * Runtime target: EVM

 */

contract OVM_CanonicalTransactionChain is iOVM_CanonicalTransactionChain, Lib_AddressResolver {



    /*************

     * Constants *

     *************/



    // L2 tx gas-related

    uint256 constant public MIN_ROLLUP_TX_GAS = 100000;

    uint256 constant public MAX_ROLLUP_TX_SIZE = 50000;

    uint256 constant public L2_GAS_DISCOUNT_DIVISOR = 32;



    // Encoding-related (all in bytes)

    uint256 constant internal BATCH_CONTEXT_SIZE = 16;

    uint256 constant internal BATCH_CONTEXT_LENGTH_POS = 12;

    uint256 constant internal BATCH_CONTEXT_START_POS = 15;

    uint256 constant internal TX_DATA_HEADER_SIZE = 3;

    uint256 constant internal BYTES_TILL_TX_DATA = 65;





    /*************

     * Variables *

     *************/



    uint256 public forceInclusionPeriodSeconds;

    uint256 public forceInclusionPeriodBlocks;

    uint256 public maxTransactionGasLimit;





    /***************

     * Constructor *

     ***************/



    constructor(

        address _libAddressManager,

        uint256 _forceInclusionPeriodSeconds,

        uint256 _forceInclusionPeriodBlocks,

        uint256 _maxTransactionGasLimit

    )

        Lib_AddressResolver(_libAddressManager)

    {

        forceInclusionPeriodSeconds = _forceInclusionPeriodSeconds;

        forceInclusionPeriodBlocks = _forceInclusionPeriodBlocks;

        maxTransactionGasLimit = _maxTransactionGasLimit;

    }





    /********************

     * Public Functions *

     ********************/



    /**

     * Accesses the batch storage container.

     * @return Reference to the batch storage container.

     */

    function batches()

        override

        public

        view

        returns (

            iOVM_ChainStorageContainer

        )

    {

        return iOVM_ChainStorageContainer(

            resolve("OVM_ChainStorageContainer-CTC-batches")

        );

    }



    /**

     * Accesses the queue storage container.

     * @return Reference to the queue storage container.

     */

    function queue()

        override

        public

        view

        returns (

            iOVM_ChainStorageContainer

        )

    {

        return iOVM_ChainStorageContainer(

            resolve("OVM_ChainStorageContainer-CTC-queue")

        );

    }



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements()

        override

        public

        view

        returns (

            uint256 _totalElements

        )

    {

        (uint40 totalElements,,,) = _getBatchExtraData();

        return uint256(totalElements);

    }



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches()

        override

        public

        view

        returns (

            uint256 _totalBatches

        )

    {

        return batches().length();

    }



    /**

     * Returns the index of the next element to be enqueued.

     * @return Index for the next queue element.

     */

    function getNextQueueIndex()

        override

        public

        view

        returns (

            uint40

        )

    {

        (,uint40 nextQueueIndex,,) = _getBatchExtraData();

        return nextQueueIndex;

    }



    /**

     * Returns the timestamp of the last transaction.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestamp()

        override

        public

        view

        returns (

            uint40

        )

    {

        (,,uint40 lastTimestamp,) = _getBatchExtraData();

        return lastTimestamp;

    }



    /**

     * Returns the blocknumber of the last transaction.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumber()

        override

        public

        view

        returns (

            uint40

        )

    {

        (,,,uint40 lastBlockNumber) = _getBatchExtraData();

        return lastBlockNumber;

    }



    /**

     * Gets the queue element at a particular index.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElement(

        uint256 _index

    )

        override

        public

        view

        returns (

            Lib_OVMCodec.QueueElement memory _element

        )

    {

        return _getQueueElement(

            _index,

            queue()

        );

    }



    /**

     * Get the number of queue elements which have not yet been included.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElements()

        override

        public

        view

        returns (

            uint40

        )

    {

        return getQueueLength() - getNextQueueIndex();

    }



   /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @return Length of the queue.

     */

    function getQueueLength()

        override

        public

        view

        returns (

            uint40

        )

    {

        return _getQueueLength(

            queue()

        );

    }



    /**

     * Adds a transaction to the queue.

     * @param _target Target L2 contract to send the transaction to.

     * @param _gasLimit Gas limit for the enqueued L2 transaction.

     * @param _data Transaction data.

     */

    function enqueue(

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    )

        override

        public

    {

        require(

            _data.length <= MAX_ROLLUP_TX_SIZE,

            "Transaction data size exceeds maximum for rollup transaction."

        );



        require(

            _gasLimit <= maxTransactionGasLimit,

            "Transaction gas limit exceeds maximum for rollup transaction."

        );



        require(

            _gasLimit >= MIN_ROLLUP_TX_GAS,

            "Transaction gas limit too low to enqueue."

        );



        // We need to consume some amount of L1 gas in order to rate limit transactions going into

        // L2. However, L2 is cheaper than L1 so we only need to burn some small proportion of the

        // provided L1 gas.

        uint256 gasToConsume = _gasLimit/L2_GAS_DISCOUNT_DIVISOR;

        uint256 startingGas = gasleft();



        // Although this check is not necessary (burn below will run out of gas if not true), it

        // gives the user an explicit reason as to why the enqueue attempt failed.

        require(

            startingGas > gasToConsume,

            "Insufficient gas for L2 rate limiting burn."

        );



        // Here we do some "dumb" work in order to burn gas, although we should probably replace

        // this with something like minting gas token later on.

        uint256 i;

        while(startingGas - gasleft() < gasToConsume) {

            i++;

        }



        bytes32 transactionHash = keccak256(

            abi.encode(

                msg.sender,

                _target,

                _gasLimit,

                _data

            )

        );



        bytes32 timestampAndBlockNumber;

        assembly {

            timestampAndBlockNumber := timestamp()

            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))

        }



        iOVM_ChainStorageContainer queueRef = queue();



        queueRef.push(transactionHash);

        queueRef.push(timestampAndBlockNumber);



        // The underlying queue data structure stores 2 elements

        // per insertion, so to get the real queue length we need

        // to divide by 2 and subtract 1.

        uint256 queueIndex = queueRef.length() / 2 - 1;

        emit TransactionEnqueued(

            msg.sender,

            _target,

            _gasLimit,

            _data,

            queueIndex,

            block.timestamp

        );

    }



    /**

     * Appends a given number of queued transactions as a single batch.

     * param _numQueuedTransactions Number of transactions to append.

     */

    function appendQueueBatch(

        uint256 // _numQueuedTransactions

    )

        override

        public

        pure

    {

        // TEMPORARY: Disable `appendQueueBatch` for minnet

        revert("appendQueueBatch is currently disabled.");



        // _numQueuedTransactions = Math.min(_numQueuedTransactions, getNumPendingQueueElements());

        // require(

        //     _numQueuedTransactions > 0,

        //     "Must append more than zero transactions."

        // );



        // bytes32[] memory leaves = new bytes32[](_numQueuedTransactions);

        // uint40 nextQueueIndex = getNextQueueIndex();



        // for (uint256 i = 0; i < _numQueuedTransactions; i++) {

        //     if (msg.sender != resolve("OVM_Sequencer")) {

        //         Lib_OVMCodec.QueueElement memory el = getQueueElement(nextQueueIndex);

        //         require(

        //             el.timestamp + forceInclusionPeriodSeconds < block.timestamp,

        //             "Queue transactions cannot be submitted during the sequencer inclusion period."

        //         );

        //     }

        //     leaves[i] = _getQueueLeafHash(nextQueueIndex);

        //     nextQueueIndex++;

        // }



        // Lib_OVMCodec.QueueElement memory lastElement = getQueueElement(nextQueueIndex - 1);



        // _appendBatch(

        //     Lib_MerkleTree.getMerkleRoot(leaves),

        //     _numQueuedTransactions,

        //     _numQueuedTransactions,

        //     lastElement.timestamp,

        //     lastElement.blockNumber

        // );



        // emit QueueBatchAppended(

        //     nextQueueIndex - _numQueuedTransactions,

        //     _numQueuedTransactions,

        //     getTotalElements()

        // );

    }



    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatch()

        override

        public

    {

        uint40 shouldStartAtElement;

        uint24 totalElementsToAppend;

        uint24 numContexts;

        assembly {

            shouldStartAtElement  := shr(216, calldataload(4))

            totalElementsToAppend := shr(232, calldataload(9))

            numContexts           := shr(232, calldataload(12))

        }



        require(

            shouldStartAtElement == getTotalElements(),

            "Actual batch start index does not match expected start index."

        );



        require(

            msg.sender == resolve("OVM_Sequencer"),

            "Function can only be called by the Sequencer."

        );



        require(

            numContexts > 0,

            "Must provide at least one batch context."

        );



        require(

            totalElementsToAppend > 0,

            "Must append at least one element."

        );



        uint40 nextTransactionPtr = uint40(BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts);



        require(

            msg.data.length >= nextTransactionPtr,

            "Not enough BatchContexts provided."

        );



        // Take a reference to the queue and its length so we don't have to keep resolving it.

        // Length isn't going to change during the course of execution, so it's fine to simply

        // resolve this once at the start. Saves gas.

        iOVM_ChainStorageContainer queueRef = queue();

        uint40 queueLength = _getQueueLength(queueRef);



        // Reserve some memory to save gas on hashing later on. This is a relatively safe estimate

        // for the average transaction size that will prevent having to resize this chunk of memory

        // later on. Saves gas.

        bytes memory hashMemory = new bytes((msg.data.length / totalElementsToAppend) * 2);



        // Initialize the array of canonical chain leaves that we will append.

        bytes32[] memory leaves = new bytes32[](totalElementsToAppend);



        // Each leaf index corresponds to a tx, either sequenced or enqueued.

        uint32 leafIndex = 0;



        // Counter for number of sequencer transactions appended so far.

        uint32 numSequencerTransactions = 0;



        // We will sequentially append leaves which are pointers to the queue.

        // The initial queue index is what is currently in storage.

        uint40 nextQueueIndex = getNextQueueIndex();



        BatchContext memory curContext;

        for (uint32 i = 0; i < numContexts; i++) {

            BatchContext memory nextContext = _getBatchContext(i);



            if (i == 0) {

                // Execute a special check for the first batch.

                _validateFirstBatchContext(nextContext);

            }



            // Execute this check on every single batch, including the first one.

            _validateNextBatchContext(

                curContext,

                nextContext,

                nextQueueIndex,

                queueRef

            );



            // Now we can update our current context.

            curContext = nextContext;



            // Process sequencer transactions first.

            for (uint32 j = 0; j < curContext.numSequencedTransactions; j++) {

                uint256 txDataLength;

                assembly {

                    txDataLength := shr(232, calldataload(nextTransactionPtr))

                }

                require(

                    txDataLength <= MAX_ROLLUP_TX_SIZE,

                    "Transaction data size exceeds maximum for rollup transaction."

                );



                leaves[leafIndex] = _getSequencerLeafHash(

                    curContext,

                    nextTransactionPtr,

                    txDataLength,

                    hashMemory

                );



                nextTransactionPtr += uint40(TX_DATA_HEADER_SIZE + txDataLength);

                numSequencerTransactions++;

                leafIndex++;

            }



            // Now process any subsequent queue transactions.

            for (uint32 j = 0; j < curContext.numSubsequentQueueTransactions; j++) {

                require(

                    nextQueueIndex < queueLength,

                    "Not enough queued transactions to append."

                );



                leaves[leafIndex] = _getQueueLeafHash(nextQueueIndex);

                nextQueueIndex++;

                leafIndex++;

            }

        }



        _validateFinalBatchContext(

            curContext,

            nextQueueIndex,

            queueLength,

            queueRef

        );



        require(

            msg.data.length == nextTransactionPtr,

            "Not all sequencer transactions were processed."

        );



        require(

            leafIndex == totalElementsToAppend,

            "Actual transaction index does not match expected total elements to append."

        );



        // Generate the required metadata that we need to append this batch

        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;

        uint40 blockTimestamp;

        uint40 blockNumber;

        if (curContext.numSubsequentQueueTransactions == 0) {

            // The last element is a sequencer tx, therefore pull timestamp and block number from the last context.

            blockTimestamp = uint40(curContext.timestamp);

            blockNumber = uint40(curContext.blockNumber);

        } else {

            // The last element is a queue tx, therefore pull timestamp and block number from the queue element.

            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at least one queue element.

            // We increment nextQueueIndex after processing each queue element,

            // so the index of the last element we processed is nextQueueIndex - 1.

            Lib_OVMCodec.QueueElement memory lastElement = _getQueueElement(

                nextQueueIndex - 1,

                queueRef

            );



            blockTimestamp = lastElement.timestamp;

            blockNumber = lastElement.blockNumber;

        }



        // For efficiency reasons getMerkleRoot modifies the `leaves` argument in place

        // while calculating the root hash therefore any arguments passed to it must not

        // be used again afterwards

        _appendBatch(

            Lib_MerkleTree.getMerkleRoot(leaves),

            totalElementsToAppend,

            numQueuedTransactions,

            blockTimestamp,

            blockNumber

        );



        emit SequencerBatchAppended(

            nextQueueIndex - numQueuedTransactions,

            numQueuedTransactions,

            getTotalElements()

        );

    }



    /**

     * Verifies whether a transaction is included in the chain.

     * @param _transaction Transaction to verify.

     * @param _txChainElement Transaction chain element corresponding to the transaction.

     * @param _batchHeader Header of the batch the transaction was included in.

     * @param _inclusionProof Inclusion proof for the provided transaction chain element.

     * @return True if the transaction exists in the CTC, false if not.

     */

    function verifyTransaction(

        Lib_OVMCodec.Transaction memory _transaction,

        Lib_OVMCodec.TransactionChainElement memory _txChainElement,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof

    )

        override

        public

        view

        returns (

            bool

        )

    {

        if (_txChainElement.isSequenced == true) {

            return _verifySequencerTransaction(

                _transaction,

                _txChainElement,

                _batchHeader,

                _inclusionProof

            );

        } else {

            return _verifyQueueTransaction(

                _transaction,

                _txChainElement.queueIndex,

                _batchHeader,

                _inclusionProof

            );

        }

    }





    /**********************

     * Internal Functions *

     **********************/



    /**

     * Returns the BatchContext located at a particular index.

     * @param _index The index of the BatchContext

     * @return The BatchContext at the specified index.

     */

    function _getBatchContext(

        uint256 _index

    )

        internal

        pure

        returns (

            BatchContext memory

        )

    {

        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;

        uint256 numSequencedTransactions;

        uint256 numSubsequentQueueTransactions;

        uint256 ctxTimestamp;

        uint256 ctxBlockNumber;



        assembly {

            numSequencedTransactions       := shr(232, calldataload(contextPtr))

            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))

            ctxTimestamp                   := shr(216, calldataload(add(contextPtr, 6)))

            ctxBlockNumber                 := shr(216, calldataload(add(contextPtr, 11)))

        }



        return BatchContext({

            numSequencedTransactions: numSequencedTransactions,

            numSubsequentQueueTransactions: numSubsequentQueueTransactions,

            timestamp: ctxTimestamp,

            blockNumber: ctxBlockNumber

        });

    }



    /**

     * Parses the batch context from the extra data.

     * @return Total number of elements submitted.

     * @return Index of the next queue element.

     */

    function _getBatchExtraData()

        internal

        view

        returns (

            uint40,

            uint40,

            uint40,

            uint40

        )

    {

        bytes27 extraData = batches().getGlobalMetadata();



        uint40 totalElements;

        uint40 nextQueueIndex;

        uint40 lastTimestamp;

        uint40 lastBlockNumber;

        assembly {

            extraData       :=  shr(40, extraData)

            totalElements   :=  and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)

            nextQueueIndex  :=  shr(40, and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000))

            lastTimestamp   :=  shr(80, and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000))

            lastBlockNumber :=  shr(120, and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000))

        }



        return (

            totalElements,

            nextQueueIndex,

            lastTimestamp,

            lastBlockNumber

        );

    }



    /**

     * Encodes the batch context for the extra data.

     * @param _totalElements Total number of elements submitted.

     * @param _nextQueueIndex Index of the next queue element.

     * @param _timestamp Timestamp for the last batch.

     * @param _blockNumber Block number of the last batch.

     * @return Encoded batch context.

     */

    function _makeBatchExtraData(

        uint40 _totalElements,

        uint40 _nextQueueIndex,

        uint40 _timestamp,

        uint40 _blockNumber

    )

        internal

        pure

        returns (

            bytes27

        )

    {

        bytes27 extraData;

        assembly {

            extraData := _totalElements

            extraData := or(extraData, shl(40, _nextQueueIndex))

            extraData := or(extraData, shl(80, _timestamp))

            extraData := or(extraData, shl(120, _blockNumber))

            extraData := shl(40, extraData)

        }



        return extraData;

    }



    /**

     * Retrieves the hash of a queue element.

     * @param _index Index of the queue element to retrieve a hash for.

     * @return Hash of the queue element.

     */

    function _getQueueLeafHash(

        uint256 _index

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        return _hashTransactionChainElement(

            Lib_OVMCodec.TransactionChainElement({

                isSequenced: false,

                queueIndex: _index,

                timestamp: 0,

                blockNumber: 0,

                txData: hex""

            })

        );

    }



    /**

     * Gets the queue element at a particular index.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function _getQueueElement(

        uint256 _index,

        iOVM_ChainStorageContainer _queueRef

    )

        internal

        view

        returns (

            Lib_OVMCodec.QueueElement memory _element

        )

    {

        // The underlying queue data structure stores 2 elements

        // per insertion, so to get the actual desired queue index

        // we need to multiply by 2.

        uint40 trueIndex = uint40(_index * 2);

        bytes32 transactionHash = _queueRef.get(trueIndex);

        bytes32 timestampAndBlockNumber = _queueRef.get(trueIndex + 1);



        uint40 elementTimestamp;

        uint40 elementBlockNumber;

        assembly {

            elementTimestamp   :=         and(timestampAndBlockNumber, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)

            elementBlockNumber := shr(40, and(timestampAndBlockNumber, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))

        }



        return Lib_OVMCodec.QueueElement({

            transactionHash: transactionHash,

            timestamp: elementTimestamp,

            blockNumber: elementBlockNumber

        });

    }



    /**

     * Retrieves the length of the queue.

     * @return Length of the queue.

     */

    function _getQueueLength(

        iOVM_ChainStorageContainer _queueRef

    )

        internal

        view

        returns (

            uint40

        )

    {

        // The underlying queue data structure stores 2 elements

        // per insertion, so to get the real queue length we need

        // to divide by 2.

        return uint40(_queueRef.length() / 2);

    }



    /**

     * Retrieves the hash of a sequencer element.

     * @param _context Batch context for the given element.

     * @param _nextTransactionPtr Pointer to the next transaction in the calldata.

     * @param _txDataLength Length of the transaction item.

     * @return Hash of the sequencer element.

     */

    function _getSequencerLeafHash(

        BatchContext memory _context,

        uint256 _nextTransactionPtr,

        uint256 _txDataLength,

        bytes memory _hashMemory

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        // Only allocate more memory if we didn't reserve enough to begin with.

        if (BYTES_TILL_TX_DATA + _txDataLength > _hashMemory.length) {

            _hashMemory = new bytes(BYTES_TILL_TX_DATA + _txDataLength);

        }



        uint256 ctxTimestamp = _context.timestamp;

        uint256 ctxBlockNumber = _context.blockNumber;



        bytes32 leafHash;

        assembly {

            let chainElementStart := add(_hashMemory, 0x20)



            // Set the first byte equal to `1` to indicate this is a sequencer chain element.

            // This distinguishes sequencer ChainElements from queue ChainElements because

            // all queue ChainElements are ABI encoded and the first byte of ABI encoded

            // elements is always zero

            mstore8(chainElementStart, 1)



            mstore(add(chainElementStart, 1), ctxTimestamp)

            mstore(add(chainElementStart, 33), ctxBlockNumber)



            calldatacopy(add(chainElementStart, BYTES_TILL_TX_DATA), add(_nextTransactionPtr, 3), _txDataLength)



            leafHash := keccak256(chainElementStart, add(BYTES_TILL_TX_DATA, _txDataLength))

        }



        return leafHash;

    }



    /**

     * Retrieves the hash of a sequencer element.

     * @param _txChainElement The chain element which is hashed to calculate the leaf.

     * @return Hash of the sequencer element.

     */

    function _getSequencerLeafHash(

        Lib_OVMCodec.TransactionChainElement memory _txChainElement

    )

        internal

        view

        returns(

            bytes32

        )

    {

        bytes memory txData = _txChainElement.txData;

        uint256 txDataLength = _txChainElement.txData.length;



        bytes memory chainElement = new bytes(BYTES_TILL_TX_DATA + txDataLength);

        uint256 ctxTimestamp = _txChainElement.timestamp;

        uint256 ctxBlockNumber = _txChainElement.blockNumber;



        bytes32 leafHash;

        assembly {

            let chainElementStart := add(chainElement, 0x20)



            // Set the first byte equal to `1` to indicate this is a sequencer chain element.

            // This distinguishes sequencer ChainElements from queue ChainElements because

            // all queue ChainElements are ABI encoded and the first byte of ABI encoded

            // elements is always zero

            mstore8(chainElementStart, 1)



            mstore(add(chainElementStart, 1), ctxTimestamp)

            mstore(add(chainElementStart, 33), ctxBlockNumber)



            pop(staticcall(gas(), 0x04, add(txData, 0x20), txDataLength, add(chainElementStart, BYTES_TILL_TX_DATA), txDataLength))



            leafHash := keccak256(chainElementStart, add(BYTES_TILL_TX_DATA, txDataLength))

        }



        return leafHash;

    }



    /**

     * Inserts a batch into the chain of batches.

     * @param _transactionRoot Root of the transaction tree for this batch.

     * @param _batchSize Number of elements in the batch.

     * @param _numQueuedTransactions Number of queue transactions in the batch.

     * @param _timestamp The latest batch timestamp.

     * @param _blockNumber The latest batch blockNumber.

     */

    function _appendBatch(

        bytes32 _transactionRoot,

        uint256 _batchSize,

        uint256 _numQueuedTransactions,

        uint40 _timestamp,

        uint40 _blockNumber

    )

        internal

    {

        iOVM_ChainStorageContainer batchesRef = batches();

        (uint40 totalElements, uint40 nextQueueIndex,,) = _getBatchExtraData();



        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({

            batchIndex: batchesRef.length(),

            batchRoot: _transactionRoot,

            batchSize: _batchSize,

            prevTotalElements: totalElements,

            extraData: hex""

        });



        emit TransactionBatchAppended(

            header.batchIndex,

            header.batchRoot,

            header.batchSize,

            header.prevTotalElements,

            header.extraData

        );



        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);

        bytes27 latestBatchContext = _makeBatchExtraData(

            totalElements + uint40(header.batchSize),

            nextQueueIndex + uint40(_numQueuedTransactions),

            _timestamp,

            _blockNumber

        );



        batchesRef.push(batchHeaderHash, latestBatchContext);

    }



    /**

     * Checks that the first batch context in a sequencer submission is valid

     * @param _firstContext The batch context to validate.

     */

    function _validateFirstBatchContext(

        BatchContext memory _firstContext

    )

        internal

        view

    {

        // If there are existing elements, this batch must have the same context

        // or a later timestamp and block number.

        if (getTotalElements() > 0) {

            (,, uint40 lastTimestamp, uint40 lastBlockNumber) = _getBatchExtraData();



            require(

                _firstContext.blockNumber >= lastBlockNumber,

                "Context block number is lower than last submitted."

            );



            require(

                _firstContext.timestamp >= lastTimestamp,

                "Context timestamp is lower than last submitted."

            );

        }



        // Sequencer cannot submit contexts which are more than the force inclusion period old.

        require(

            _firstContext.timestamp + forceInclusionPeriodSeconds >= block.timestamp,

            "Context timestamp too far in the past."

        );



        require(

            _firstContext.blockNumber + forceInclusionPeriodBlocks >= block.number,

            "Context block number too far in the past."

        );

    }



    /**

     * Checks that a given batch context has a time context which is below a given que element

     * @param _context The batch context to validate has values lower.

     * @param _queueIndex Index of the queue element we are validating came later than the context.

     * @param _queueRef The storage container for the queue.

     */

    function _validateContextBeforeEnqueue(

        BatchContext memory _context,

        uint40 _queueIndex,

        iOVM_ChainStorageContainer _queueRef

    )

        internal

        view

    {

            Lib_OVMCodec.QueueElement memory nextQueueElement = _getQueueElement(

                _queueIndex,

                _queueRef

            );



            // If the force inclusion period has passed for an enqueued transaction, it MUST be the next chain element.

            require(

                block.timestamp < nextQueueElement.timestamp + forceInclusionPeriodSeconds,

                "Previously enqueued batches have expired and must be appended before a new sequencer batch."

            );



            // Just like sequencer transaction times must be increasing relative to each other,

            // We also require that they be increasing relative to any interspersed queue elements.

            require(

                _context.timestamp <= nextQueueElement.timestamp,

                "Sequencer transaction timestamp exceeds that of next queue element."

            );



            require(

                _context.blockNumber <= nextQueueElement.blockNumber,

                "Sequencer transaction blockNumber exceeds that of next queue element."

            );

    }



    /**

     * Checks that a given batch context is valid based on its previous context, and the next queue elemtent.

     * @param _prevContext The previously validated batch context.

     * @param _nextContext The batch context to validate with this call.

     * @param _nextQueueIndex Index of the next queue element to process for the _nextContext's subsequentQueueElements.

     * @param _queueRef The storage container for the queue.

     */

    function _validateNextBatchContext(

        BatchContext memory _prevContext,

        BatchContext memory _nextContext,

        uint40 _nextQueueIndex,

        iOVM_ChainStorageContainer _queueRef

    )

        internal

        view

    {

        // All sequencer transactions' times must be greater than or equal to the previous ones.

        require(

            _nextContext.timestamp >= _prevContext.timestamp,

            "Context timestamp values must monotonically increase."

        );



        require(

            _nextContext.blockNumber >= _prevContext.blockNumber,

            "Context blockNumber values must monotonically increase."

        );



        // If there is going to be a queue element pulled in from this context:

        if (_nextContext.numSubsequentQueueTransactions > 0) {

            _validateContextBeforeEnqueue(

                _nextContext,

                _nextQueueIndex,

                _queueRef

            );

        }

    }



    /**

     * Checks that the final batch context in a sequencer submission is valid.

     * @param _finalContext The batch context to validate.

     * @param _queueLength The length of the queue at the start of the batchAppend call.

     * @param _nextQueueIndex The next element in the queue that will be pulled into the CTC.

     * @param _queueRef The storage container for the queue.

     */

    function _validateFinalBatchContext(

        BatchContext memory _finalContext,

        uint40 _nextQueueIndex,

        uint40 _queueLength,

        iOVM_ChainStorageContainer _queueRef

    )

        internal

        view

    {

        // If the queue is not now empty, check the mononoticity of whatever the next batch that will come in is.

        if (_queueLength - _nextQueueIndex > 0 && _finalContext.numSubsequentQueueTransactions == 0) {

            _validateContextBeforeEnqueue(

                _finalContext,

                _nextQueueIndex,

                _queueRef

            );

        }

        // Batches cannot be added from the future, or subsequent enqueue() contexts would violate monotonicity.

        require(_finalContext.timestamp <= block.timestamp, "Context timestamp is from the future.");

        require(_finalContext.blockNumber <= block.number, "Context block number is from the future.");

    }



    /**

     * Hashes a transaction chain element.

     * @param _element Chain element to hash.

     * @return Hash of the chain element.

     */

    function _hashTransactionChainElement(

        Lib_OVMCodec.TransactionChainElement memory _element

    )

        internal

        pure

        returns (

            bytes32

        )

    {

        return keccak256(

            abi.encode(

                _element.isSequenced,

                _element.queueIndex,

                _element.timestamp,

                _element.blockNumber,

                _element.txData

            )

        );

    }



    /**

     * Verifies a sequencer transaction, returning true if it was indeed included in the CTC

     * @param _transaction The transaction we are verifying inclusion of.

     * @param _txChainElement The chain element that the transaction is claimed to be a part of.

     * @param _batchHeader Header of the batch the transaction was included in.

     * @param _inclusionProof An inclusion proof into the CTC at a particular index.

     * @return True if the transaction was included in the specified location, else false.

     */

    function _verifySequencerTransaction(

        Lib_OVMCodec.Transaction memory _transaction,

        Lib_OVMCodec.TransactionChainElement memory _txChainElement,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof

    )

        internal

        view

        returns (

            bool

        )

    {

        OVM_ExecutionManager ovmExecutionManager = OVM_ExecutionManager(resolve("OVM_ExecutionManager"));

        uint256 gasLimit = ovmExecutionManager.getMaxTransactionGasLimit();

        bytes32 leafHash = _getSequencerLeafHash(_txChainElement);



        require(

            _verifyElement(

                leafHash,

                _batchHeader,

                _inclusionProof

            ),

            "Invalid Sequencer transaction inclusion proof."

        );



        require(

            _transaction.blockNumber        == _txChainElement.blockNumber

            && _transaction.timestamp       == _txChainElement.timestamp

            && _transaction.entrypoint      == resolve("OVM_DecompressionPrecompileAddress")

            && _transaction.gasLimit        == gasLimit

            && _transaction.l1TxOrigin      == address(0)

            && _transaction.l1QueueOrigin   == Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE

            && keccak256(_transaction.data) == keccak256(_txChainElement.txData),

            "Invalid Sequencer transaction."

        );



        return true;

    }



    /**

     * Verifies a queue transaction, returning true if it was indeed included in the CTC

     * @param _transaction The transaction we are verifying inclusion of.

     * @param _queueIndex The queueIndex of the queued transaction.

     * @param _batchHeader Header of the batch the transaction was included in.

     * @param _inclusionProof An inclusion proof into the CTC at a particular index (should point to queue tx).

     * @return True if the transaction was included in the specified location, else false.

     */

    function _verifyQueueTransaction(

        Lib_OVMCodec.Transaction memory _transaction,

        uint256 _queueIndex,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof

    )

        internal

        view

        returns (

            bool

        )

    {

        bytes32 leafHash = _getQueueLeafHash(_queueIndex);



        require(

            _verifyElement(

                leafHash,

                _batchHeader,

                _inclusionProof

            ),

            "Invalid Queue transaction inclusion proof."

        );



        bytes32 transactionHash = keccak256(

            abi.encode(

                _transaction.l1TxOrigin,

                _transaction.entrypoint,

                _transaction.gasLimit,

                _transaction.data

            )

        );



        Lib_OVMCodec.QueueElement memory el = getQueueElement(_queueIndex);

        require(

            el.transactionHash      == transactionHash

            && el.timestamp   == _transaction.timestamp

            && el.blockNumber == _transaction.blockNumber,

            "Invalid Queue transaction."

        );



        return true;

    }



    /**

     * Verifies a batch inclusion proof.

     * @param _element Hash of the element to verify a proof for.

     * @param _batchHeader Header of the batch in which the element was included.

     * @param _proof Merkle inclusion proof for the element.

     */

    function _verifyElement(

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    )

        internal

        view

        returns (

            bool

        )

    {

        require(

            Lib_OVMCodec.hashBatchHeader(_batchHeader) == batches().get(uint32(_batchHeader.batchIndex)),

            "Invalid batch header."

        );



        require(

            Lib_MerkleTree.verify(

                _batchHeader.batchRoot,

                _element,

                _proof.index,

                _proof.siblings,

                _batchHeader.batchSize

            ),

            "Invalid inclusion proof."

        );



        return true;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\OVM_CrossDomainEnabled.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/* Interface Imports */

import { iOVM_CrossDomainMessenger } from "../../iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol";



/**

 * @title OVM_CrossDomainEnabled

 * @dev Helper contract for contracts performing cross-domain communications

 *

 * Compiler used: defined by inheriting contract

 * Runtime target: defined by inheriting contract

 */

contract OVM_CrossDomainEnabled {



    /*************

     * Variables *

     *************/



    // Messenger contract used to send and recieve messages from the other domain.

    address public messenger;





    /***************

     * Constructor *

     ***************/



    /**

     * @param _messenger Address of the CrossDomainMessenger on the current layer.

     */

    constructor(

        address _messenger

    ) {

        messenger = _messenger;

    }





    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Enforces that the modified function is only callable by a specific cross-domain account.

     * @param _sourceDomainAccount The only account on the originating domain which is

     *  authenticated to call this function.

     */

    modifier onlyFromCrossDomainAccount(

        address _sourceDomainAccount

    ) {

        require(

            msg.sender == address(getCrossDomainMessenger()),

            "OVM_XCHAIN: messenger contract unauthenticated"

        );



        require(

            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,

            "OVM_XCHAIN: wrong sender of cross-domain message"

        );



        _;

    }





    /**********************

     * Internal Functions *

     **********************/



    /**

     * Gets the messenger, usually from storage. This function is exposed in case a child contract

     * needs to override.

     * @return The address of the cross-domain messenger contract which should be used.

     */

    function getCrossDomainMessenger()

        internal

        virtual

        returns (

            iOVM_CrossDomainMessenger

        )

    {

        return iOVM_CrossDomainMessenger(messenger);

    }



    /**

     * Sends a message to an account on another domain

     * @param _crossDomainTarget The intended recipient on the destination domain

     * @param _message The data to send to the target (usually calldata to a function with

     *  `onlyFromCrossDomainAccount()`)

     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.

     */

    function sendCrossDomainMessage(

        address _crossDomainTarget,

        uint32 _gasLimit,

        bytes memory _message

    )

        internal

    {

        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\OVM_DeployerWhitelist.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;



/* Interface Imports */

import { iOVM_DeployerWhitelist } from "../../iOVM/predeploys/iOVM_DeployerWhitelist.sol";



/**

 * @title OVM_DeployerWhitelist

 * @dev The Deployer Whitelist is a temporary predeploy used to provide additional safety during the

 * initial phases of our mainnet roll out. It is owned by the Optimism team, and defines accounts

 * which are allowed to deploy contracts on Layer2. The Execution Manager will only allow an

 * ovmCREATE or ovmCREATE2 operation to proceed if the deployer's address whitelisted.

 *

 * Compiler used: optimistic-solc

 * Runtime target: OVM

 */

contract OVM_DeployerWhitelist is iOVM_DeployerWhitelist {



    /**********************

     * Contract Constants *

     **********************/



    bool public initialized;

    bool public allowArbitraryDeployment;

    address override public owner;

    mapping (address => bool) public whitelist;





    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Blocks functions to anyone except the contract owner.

     */

    modifier onlyOwner() {

        require(

            msg.sender == owner,

            "Function can only be called by the owner of this contract."

        );

        _;

    }





    /********************

     * Public Functions *

     ********************/



    /**

     * Initializes the whitelist.

     * @param _owner Address of the owner for this contract.

     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.

     */

    function initialize(

        address _owner,

        bool _allowArbitraryDeployment

    )

        override

        external

    {

        if (initialized == true) {

            return;

        }



        initialized = true;

        allowArbitraryDeployment = _allowArbitraryDeployment;

        owner = _owner;

    }



    /**

     * Adds or removes an address from the deployment whitelist.

     * @param _deployer Address to update permissions for.

     * @param _isWhitelisted Whether or not the address is whitelisted.

     */

    function setWhitelistedDeployer(

        address _deployer,

        bool _isWhitelisted

    )

        override

        external

        onlyOwner

    {

        whitelist[_deployer] = _isWhitelisted;

    }



    /**

     * Updates the owner of this contract.

     * @param _owner Address of the new owner.

     */

    function setOwner(

        address _owner

    )

        override

        public

        onlyOwner

    {

        owner = _owner;

    }



    /**

     * Updates the arbitrary deployment flag.

     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.

     */

    function setAllowArbitraryDeployment(

        bool _allowArbitraryDeployment

    )

        override

        public

        onlyOwner

    {

        allowArbitraryDeployment = _allowArbitraryDeployment;

    }



    /**

     * Permanently enables arbitrary contract deployment and deletes the owner.

     */

    function enableArbitraryContractDeployment()

        override

        external

        onlyOwner

    {

        setAllowArbitraryDeployment(true);

        setOwner(address(0));

    }



    /**

     * Checks whether an address is allowed to deploy contracts.

     * @param _deployer Address to check.

     * @return _allowed Whether or not the address can deploy contracts.

     */

    function isDeployerAllowed(

        address _deployer

    )

        override

        external

        returns (

            bool

        )

    {

        return (

            initialized == false

            || allowArbitraryDeployment == true

            || whitelist[_deployer]

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\OVM_ExecutionManager.sol
File type: .sol
// SPDX-License-Identifier: MIT

// @unsupported: ovm

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";

import { Lib_AddressResolver } from "../../libraries/resolver/Lib_AddressResolver.sol";

import { Lib_Bytes32Utils } from "../../libraries/utils/Lib_Bytes32Utils.sol";

import { Lib_EthUtils } from "../../libraries/utils/Lib_EthUtils.sol";

import { Lib_ErrorUtils } from "../../libraries/utils/Lib_ErrorUtils.sol";

import { Lib_PredeployAddresses } from "../../libraries/constants/Lib_PredeployAddresses.sol";



/* Interface Imports */

import { iOVM_ExecutionManager } from "../../iOVM/execution/iOVM_ExecutionManager.sol";

import { iOVM_StateManager } from "../../iOVM/execution/iOVM_StateManager.sol";

import { iOVM_SafetyChecker } from "../../iOVM/execution/iOVM_SafetyChecker.sol";



/* Contract Imports */

import { OVM_DeployerWhitelist } from "../predeploys/OVM_DeployerWhitelist.sol";



/* External Imports */

import { Math } from "@openzeppelin/contracts/math/Math.sol";



/**

 * @title OVM_ExecutionManager

 * @dev The Execution Manager (EM) is the core of our OVM implementation, and provides a sandboxed

 * environment allowing us to execute OVM transactions deterministically on either Layer 1 or

 * Layer 2.

 * The EM's run() function is the first function called during the execution of any

 * transaction on L2.

 * For each context-dependent EVM operation the EM has a function which implements a corresponding

 * OVM operation, which will read state from the State Manager contract.

 * The EM relies on the Safety Checker to verify that code deployed to Layer 2 does not contain any

 * context-dependent operations.

 *

 * Compiler used: solc

 * Runtime target: EVM

 */

contract OVM_ExecutionManager is iOVM_ExecutionManager, Lib_AddressResolver {



    /********************************

     * External Contract References *

     ********************************/



    iOVM_SafetyChecker internal ovmSafetyChecker;

    iOVM_StateManager internal ovmStateManager;





    /*******************************

     * Execution Context Variables *

     *******************************/



    GasMeterConfig internal gasMeterConfig;

    GlobalContext internal globalContext;

    TransactionContext internal transactionContext;

    MessageContext internal messageContext;

    TransactionRecord internal transactionRecord;

    MessageRecord internal messageRecord;





    /**************************

     * Gas Metering Constants *

     **************************/



    address constant GAS_METADATA_ADDRESS = 0x06a506A506a506A506a506a506A506A506A506A5;

    uint256 constant NUISANCE_GAS_SLOAD = 20000;

    uint256 constant NUISANCE_GAS_SSTORE = 20000;

    uint256 constant MIN_NUISANCE_GAS_PER_CONTRACT = 30000;

    uint256 constant NUISANCE_GAS_PER_CONTRACT_BYTE = 100;

    uint256 constant MIN_GAS_FOR_INVALID_STATE_ACCESS = 30000;





    /**************************

     * Native Value Constants *

     **************************/



    // Public so we can access and make assertions in integration tests.

    uint256 public constant CALL_WITH_VALUE_INTRINSIC_GAS = 90000;





    /**************************

     * Default Context Values *

     **************************/



    uint256 constant DEFAULT_UINT256 = 0xdefa017defa017defa017defa017defa017defa017defa017defa017defa017d;

    address constant DEFAULT_ADDRESS = 0xdEfa017defA017DeFA017DEfa017DeFA017DeFa0;





    /*************************************

     * Container Contract Address Prefix *

     *************************************/



    /**

     * @dev The Execution Manager and State Manager each have this 30 byte prefix, and are uncallable.

     */

    address constant CONTAINER_CONTRACT_PREFIX = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;





    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Address Manager.

     */

    constructor(

        address _libAddressManager,

        GasMeterConfig memory _gasMeterConfig,

        GlobalContext memory _globalContext

    )

        Lib_AddressResolver(_libAddressManager)

    {

        ovmSafetyChecker = iOVM_SafetyChecker(resolve("OVM_SafetyChecker"));

        gasMeterConfig = _gasMeterConfig;

        globalContext = _globalContext;

        _resetContext();

    }





    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Applies dynamically-sized refund to a transaction to account for the difference in execution

     * between L1 and L2, so that the overall cost of the ovmOPCODE is fixed.

     * @param _cost Desired gas cost for the function after the refund.

     */

    modifier netGasCost(

        uint256 _cost

    ) {

        uint256 gasProvided = gasleft();

        _;

        uint256 gasUsed = gasProvided - gasleft();



        // We want to refund everything *except* the specified cost.

        if (_cost < gasUsed) {

            transactionRecord.ovmGasRefund += gasUsed - _cost;

        }

    }



    /**

     * Applies a fixed-size gas refund to a transaction to account for the difference in execution

     * between L1 and L2, so that the overall cost of an ovmOPCODE can be lowered.

     * @param _discount Amount of gas cost to refund for the ovmOPCODE.

     */

    modifier fixedGasDiscount(

        uint256 _discount

    ) {

        uint256 gasProvided = gasleft();

        _;

        uint256 gasUsed = gasProvided - gasleft();



        // We want to refund the specified _discount, unless this risks underflow.

        if (_discount < gasUsed) {

            transactionRecord.ovmGasRefund += _discount;

        } else {

            // refund all we can without risking underflow.

            transactionRecord.ovmGasRefund += gasUsed;

        }

    }



    /**

     * Makes sure we're not inside a static context.

     */

    modifier notStatic() {

        if (messageContext.isStatic == true) {

            _revertWithFlag(RevertFlag.STATIC_VIOLATION);

        }

        _;

    }





    /************************************

     * Transaction Execution Entrypoint *

     ************************************/



    /**

     * Starts the execution of a transaction via the OVM_ExecutionManager.

     * @param _transaction Transaction data to be executed.

     * @param _ovmStateManager iOVM_StateManager implementation providing account state.

     */

    function run(

        Lib_OVMCodec.Transaction memory _transaction,

        address _ovmStateManager

    )

        override

        external

        returns (

            bytes memory

        )

    {

        // Make sure that run() is not re-enterable.  This condition should always be satisfied

        // Once run has been called once, due to the behavior of _isValidInput().

        if (transactionContext.ovmNUMBER != DEFAULT_UINT256) {

            return bytes("");

        }



        // Store our OVM_StateManager instance (significantly easier than attempting to pass the

        // address around in calldata).

        ovmStateManager = iOVM_StateManager(_ovmStateManager);



        // Make sure this function can't be called by anyone except the owner of the

        // OVM_StateManager (expected to be an OVM_StateTransitioner). We can revert here because

        // this would make the `run` itself invalid.

        require(

            // This method may return false during fraud proofs, but always returns true in L2 nodes' State Manager precompile.

            ovmStateManager.isAuthenticated(msg.sender),

            "Only authenticated addresses in ovmStateManager can call this function"

        );



        // Initialize the execution context, must be initialized before we perform any gas metering

        // or we'll throw a nuisance gas error.

        _initContext(_transaction);



        // TEMPORARY: Gas metering is disabled for minnet.

        // // Check whether we need to start a new epoch, do so if necessary.

        // _checkNeedsNewEpoch(_transaction.timestamp);



        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve

        // reverts for INVALID_STATE_ACCESS.

        if (_isValidInput(_transaction) == false) {

            _resetContext();

            return bytes("");

        }



        // TEMPORARY: Gas metering is disabled for minnet.

        // // Check gas right before the call to get total gas consumed by OVM transaction.

        // uint256 gasProvided = gasleft();



        // Run the transaction, make sure to meter the gas usage.

        (, bytes memory returndata) = ovmCALL(

            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,

            _transaction.entrypoint,

            0,

            _transaction.data

        );



        // TEMPORARY: Gas metering is disabled for minnet.

        // // Update the cumulative gas based on the amount of gas used.

        // uint256 gasUsed = gasProvided - gasleft();

        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);



        // Wipe the execution context.

        _resetContext();



        return returndata;

    }





    /******************************

     * Opcodes: Execution Context *

     ******************************/



    /**

     * @notice Overrides CALLER.

     * @return _CALLER Address of the CALLER within the current message context.

     */

    function ovmCALLER()

        override

        external

        view

        returns (

            address _CALLER

        )

    {

        return messageContext.ovmCALLER;

    }



    /**

     * @notice Overrides ADDRESS.

     * @return _ADDRESS Active ADDRESS within the current message context.

     */

    function ovmADDRESS()

        override

        public

        view

        returns (

            address _ADDRESS

        )

    {

        return messageContext.ovmADDRESS;

    }



    /**

     * @notice Overrides CALLVALUE.

     * @return _CALLVALUE Value sent along with the call according to the current message context.

     */

    function ovmCALLVALUE()

        override

        public

        view

        returns (

            uint256 _CALLVALUE

        )

    {

        return messageContext.ovmCALLVALUE;

    }



    /**

     * @notice Overrides TIMESTAMP.

     * @return _TIMESTAMP Value of the TIMESTAMP within the transaction context.

     */

    function ovmTIMESTAMP()

        override

        external

        view

        returns (

            uint256 _TIMESTAMP

        )

    {

        return transactionContext.ovmTIMESTAMP;

    }



    /**

     * @notice Overrides NUMBER.

     * @return _NUMBER Value of the NUMBER within the transaction context.

     */

    function ovmNUMBER()

        override

        external

        view

        returns (

            uint256 _NUMBER

        )

    {

        return transactionContext.ovmNUMBER;

    }



    /**

     * @notice Overrides GASLIMIT.

     * @return _GASLIMIT Value of the block's GASLIMIT within the transaction context.

     */

    function ovmGASLIMIT()

        override

        external

        view

        returns (

            uint256 _GASLIMIT

        )

    {

        return transactionContext.ovmGASLIMIT;

    }



    /**

     * @notice Overrides CHAINID.

     * @return _CHAINID Value of the chain's CHAINID within the global context.

     */

    function ovmCHAINID()

        override

        external

        view

        returns (

            uint256 _CHAINID

        )

    {

        return globalContext.ovmCHAINID;

    }



    /*********************************

     * Opcodes: L2 Execution Context *

     *********************************/



    /**

     * @notice Specifies from which source (Sequencer or Queue) this transaction originated from.

     * @return _queueOrigin Enum indicating the ovmL1QUEUEORIGIN within the current message context.

     */

    function ovmL1QUEUEORIGIN()

        override

        external

        view

        returns (

            Lib_OVMCodec.QueueOrigin _queueOrigin

        )

    {

        return transactionContext.ovmL1QUEUEORIGIN;

    }



    /**

     * @notice Specifies which L1 account, if any, sent this transaction by calling enqueue().

     * @return _l1TxOrigin Address of the account which sent the tx into L2 from L1.

     */

    function ovmL1TXORIGIN()

        override

        external

        view

        returns (

            address _l1TxOrigin

        )

    {

        return transactionContext.ovmL1TXORIGIN;

    }



    /********************

     * Opcodes: Halting *

     ********************/



    /**

     * @notice Overrides REVERT.

     * @param _data Bytes data to pass along with the REVERT.

     */

    function ovmREVERT(

        bytes memory _data

    )

        override

        public

    {

        _revertWithFlag(RevertFlag.INTENTIONAL_REVERT, _data);

    }





    /******************************

     * Opcodes: Contract Creation *

     ******************************/



    /**

     * @notice Overrides CREATE.

     * @param _bytecode Code to be used to CREATE a new contract.

     * @return Address of the created contract.

     * @return Revert data, if and only if the creation threw an exception.

     */

    function ovmCREATE(

        bytes memory _bytecode

    )

        override

        public

        notStatic

        fixedGasDiscount(40000)

        returns (

            address,

            bytes memory

        )

    {

        // Creator is always the current ADDRESS.

        address creator = ovmADDRESS();



        // Check that the deployer is whitelisted, or

        // that arbitrary contract deployment has been enabled.

        _checkDeployerAllowed(creator);



        // Generate the correct CREATE address.

        address contractAddress = Lib_EthUtils.getAddressForCREATE(

            creator,

            _getAccountNonce(creator)

        );



        return _createContract(

            contractAddress,

            _bytecode,

            MessageType.ovmCREATE

        );

    }



    /**

     * @notice Overrides CREATE2.

     * @param _bytecode Code to be used to CREATE2 a new contract.

     * @param _salt Value used to determine the contract's address.

     * @return Address of the created contract.

     * @return Revert data, if and only if the creation threw an exception.

     */

    function ovmCREATE2(

        bytes memory _bytecode,

        bytes32 _salt

    )

        override

        external

        notStatic

        fixedGasDiscount(40000)

        returns (

            address,

            bytes memory

        )

    {

        // Creator is always the current ADDRESS.

        address creator = ovmADDRESS();



        // Check that the deployer is whitelisted, or

        // that arbitrary contract deployment has been enabled.

        _checkDeployerAllowed(creator);



        // Generate the correct CREATE2 address.

        address contractAddress = Lib_EthUtils.getAddressForCREATE2(

            creator,

            _bytecode,

            _salt

        );



        return _createContract(

            contractAddress,

            _bytecode,

            MessageType.ovmCREATE2

        );

    }





    /*******************************

     * Account Abstraction Opcodes *

     ******************************/



    /**

     * Retrieves the nonce of the current ovmADDRESS.

     * @return _nonce Nonce of the current contract.

     */

    function ovmGETNONCE()

        override

        external

        returns (

            uint256 _nonce

        )

    {

        return _getAccountNonce(ovmADDRESS());

    }



    /**

     * Bumps the nonce of the current ovmADDRESS by one.

     */

    function ovmINCREMENTNONCE()

        override

        external

        notStatic

    {

        address account = ovmADDRESS();

        uint256 nonce = _getAccountNonce(account);



        // Prevent overflow.

        if (nonce + 1 > nonce) {

            _setAccountNonce(account, nonce + 1);

        }

    }



    /**

     * Creates a new EOA contract account, for account abstraction.

     * @dev Essentially functions like ovmCREATE or ovmCREATE2, but we can bypass a lot of checks

     *      because the contract we're creating is trusted (no need to do safety checking or to

     *      handle unexpected reverts). Doesn't need to return an address because the address is

     *      assumed to be the user's actual address.

     * @param _messageHash Hash of a message signed by some user, for verification.

     * @param _v Signature `v` parameter.

     * @param _r Signature `r` parameter.

     * @param _s Signature `s` parameter.

     */

    function ovmCREATEEOA(

        bytes32 _messageHash,

        uint8 _v,

        bytes32 _r,

        bytes32 _s

    )

        override

        public

        notStatic

    {

        // Recover the EOA address from the message hash and signature parameters. Since we do the

        // hashing in advance, we don't have handle different message hashing schemes. Even if this

        // function were to return the wrong address (rather than explicitly returning the zero

        // address), the rest of the transaction would simply fail (since there's no EOA account to

        // actually execute the transaction).

        address eoa = ecrecover(

            _messageHash,

            _v + 27,

            _r,

            _s

        );



        // Invalid signature is a case we proactively handle with a revert. We could alternatively

        // have this function return a `success` boolean, but this is just easier.

        if (eoa == address(0)) {

            ovmREVERT(bytes("Signature provided for EOA contract creation is invalid."));

        }



        // If the user already has an EOA account, then there's no need to perform this operation.

        if (_hasEmptyAccount(eoa) == false) {

            return;

        }



        // We always need to initialize the contract with the default account values.

        _initPendingAccount(eoa);



        // Temporarily set the current address so it's easier to access on L2.

        address prevADDRESS = messageContext.ovmADDRESS;

        messageContext.ovmADDRESS = eoa;



        // Creates a duplicate of the OVM_ProxyEOA located at 0x42....09. Uses the following

        // "magic" prefix to deploy an exact copy of the code:

        // PUSH1 0x0D   # size of this prefix in bytes

        // CODESIZE

        // SUB          # subtract prefix size from codesize

        // DUP1

        // PUSH1 0x0D

        // PUSH1 0x00

        // CODECOPY     # copy everything after prefix into memory at pos 0

        // PUSH1 0x00

        // RETURN       # return the copied code

        address proxyEOA = Lib_EthUtils.createContract(abi.encodePacked(

            hex"600D380380600D6000396000f3",

            ovmEXTCODECOPY(

                Lib_PredeployAddresses.PROXY_EOA,

                0,

                ovmEXTCODESIZE(Lib_PredeployAddresses.PROXY_EOA)

            )

        ));



        // Reset the address now that we're done deploying.

        messageContext.ovmADDRESS = prevADDRESS;



        // Commit the account with its final values.

        _commitPendingAccount(

            eoa,

            address(proxyEOA),

            keccak256(Lib_EthUtils.getCode(address(proxyEOA)))

        );



        _setAccountNonce(eoa, 0);

    }





    /*********************************

     * Opcodes: Contract Interaction *

     *********************************/



    /**

     * @notice Overrides CALL.

     * @param _gasLimit Amount of gas to be passed into this call.

     * @param _address Address of the contract to call.

     * @param _value ETH value to pass with the call.

     * @param _calldata Data to send along with the call.

     * @return _success Whether or not the call returned (rather than reverted).

     * @return _returndata Data returned by the call.

     */

    function ovmCALL(

        uint256 _gasLimit,

        address _address,

        uint256 _value,

        bytes memory _calldata

    )

        override

        public

        fixedGasDiscount(100000)

        returns (

            bool _success,

            bytes memory _returndata

        )

    {

        // CALL updates the CALLER and ADDRESS.

        MessageContext memory nextMessageContext = messageContext;

        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;

        nextMessageContext.ovmADDRESS = _address;

        nextMessageContext.ovmCALLVALUE = _value;



        return _callContract(

            nextMessageContext,

            _gasLimit,

            _address,

            _calldata,

            MessageType.ovmCALL

        );

    }



    /**

     * @notice Overrides STATICCALL.

     * @param _gasLimit Amount of gas to be passed into this call.

     * @param _address Address of the contract to call.

     * @param _calldata Data to send along with the call.

     * @return _success Whether or not the call returned (rather than reverted).

     * @return _returndata Data returned by the call.

     */

    function ovmSTATICCALL(

        uint256 _gasLimit,

        address _address,

        bytes memory _calldata

    )

        override

        public

        fixedGasDiscount(80000)

        returns (

            bool _success,

            bytes memory _returndata

        )

    {

        // STATICCALL updates the CALLER, updates the ADDRESS, and runs in a static, valueless context.

        MessageContext memory nextMessageContext = messageContext;

        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;

        nextMessageContext.ovmADDRESS = _address;

        nextMessageContext.isStatic = true;

        nextMessageContext.ovmCALLVALUE = 0;



        return _callContract(

            nextMessageContext,

            _gasLimit,

            _address,

            _calldata,

            MessageType.ovmSTATICCALL

        );

    }



    /**

     * @notice Overrides DELEGATECALL.

     * @param _gasLimit Amount of gas to be passed into this call.

     * @param _address Address of the contract to call.

     * @param _calldata Data to send along with the call.

     * @return _success Whether or not the call returned (rather than reverted).

     * @return _returndata Data returned by the call.

     */

    function ovmDELEGATECALL(

        uint256 _gasLimit,

        address _address,

        bytes memory _calldata

    )

        override

        public

        fixedGasDiscount(40000)

        returns (

            bool _success,

            bytes memory _returndata

        )

    {

        // DELEGATECALL does not change anything about the message context.

        MessageContext memory nextMessageContext = messageContext;



        return _callContract(

            nextMessageContext,

            _gasLimit,

            _address,

            _calldata,

            MessageType.ovmDELEGATECALL

        );

    }



    /**

     * @notice Legacy ovmCALL function which did not support ETH value; this maintains backwards compatibility.

     * @param _gasLimit Amount of gas to be passed into this call.

     * @param _address Address of the contract to call.

     * @param _calldata Data to send along with the call.

     * @return _success Whether or not the call returned (rather than reverted).

     * @return _returndata Data returned by the call.

     */

    function ovmCALL(

        uint256 _gasLimit,

        address _address,

        bytes memory _calldata

    )

        override

        public

        returns(

            bool _success,

            bytes memory _returndata

        )

    {

        // Legacy ovmCALL assumed always-0 value.

        return ovmCALL(

            _gasLimit,

            _address,

            0,

            _calldata

        );

    }





    /************************************

     * Opcodes: Contract Storage Access *

     ************************************/



    /**

     * @notice Overrides SLOAD.

     * @param _key 32 byte key of the storage slot to load.

     * @return _value 32 byte value of the requested storage slot.

     */

    function ovmSLOAD(

        bytes32 _key

    )

        override

        external

        netGasCost(40000)

        returns (

            bytes32 _value

        )

    {

        // We always SLOAD from the storage of ADDRESS.

        address contractAddress = ovmADDRESS();



        return _getContractStorage(

            contractAddress,

            _key

        );

    }



    /**

     * @notice Overrides SSTORE.

     * @param _key 32 byte key of the storage slot to set.

     * @param _value 32 byte value for the storage slot.

     */

    function ovmSSTORE(

        bytes32 _key,

        bytes32 _value

    )

        override

        external

        notStatic

        netGasCost(60000)

    {

        // We always SSTORE to the storage of ADDRESS.

        address contractAddress = ovmADDRESS();



        _putContractStorage(

            contractAddress,

            _key,

            _value

        );

    }





    /*********************************

     * Opcodes: Contract Code Access *

     *********************************/



    /**

     * @notice Overrides EXTCODECOPY.

     * @param _contract Address of the contract to copy code from.

     * @param _offset Offset in bytes from the start of contract code to copy beyond.

     * @param _length Total number of bytes to copy from the contract's code.

     * @return _code Bytes of code copied from the requested contract.

     */

    function ovmEXTCODECOPY(

        address _contract,

        uint256 _offset,

        uint256 _length

    )

        override

        public

        returns (

            bytes memory _code

        )

    {

        return Lib_EthUtils.getCode(

            _getAccountEthAddress(_contract),

            _offset,

            _length

        );

    }



    /**

     * @notice Overrides EXTCODESIZE.

     * @param _contract Address of the contract to query the size of.

     * @return _EXTCODESIZE Size of the requested contract in bytes.

     */

    function ovmEXTCODESIZE(

        address _contract

    )

        override

        public

        returns (

            uint256 _EXTCODESIZE

        )

    {

        return Lib_EthUtils.getCodeSize(

            _getAccountEthAddress(_contract)

        );

    }



    /**

     * @notice Overrides EXTCODEHASH.

     * @param _contract Address of the contract to query the hash of.

     * @return _EXTCODEHASH Hash of the requested contract.

     */

    function ovmEXTCODEHASH(

        address _contract

    )

        override

        external

        returns (

            bytes32 _EXTCODEHASH

        )

    {

        return Lib_EthUtils.getCodeHash(

            _getAccountEthAddress(_contract)

        );

    }





    /***************************************

     * Public Functions: ETH Value Opcodes *

     ***************************************/



    /**

     * @notice Overrides BALANCE.

     * NOTE: In the future, this could be optimized to directly invoke EM._getContractStorage(...).

     * @param _contract Address of the contract to query the OVM_ETH balance of.

     * @return _BALANCE OVM_ETH balance of the requested contract.

     */

    function ovmBALANCE(

        address _contract

    )

        override

        public

        returns (

            uint256 _BALANCE

        )

    {

        // Easiest way to get the balance is query OVM_ETH as normal.

        bytes memory balanceOfCalldata = abi.encodeWithSignature(

            "balanceOf(address)",

            _contract

        );



        // Static call because this should be a read-only query.

        (bool success, bytes memory returndata) = ovmSTATICCALL(

            gasleft(),

            Lib_PredeployAddresses.OVM_ETH,

            balanceOfCalldata

        );



        // All balanceOf queries should successfully return a uint, otherwise this must be an OOG.

        if (!success || returndata.length != 32) {

            _revertWithFlag(RevertFlag.OUT_OF_GAS);

        }



        // Return the decoded balance.

        return abi.decode(returndata, (uint256));

    }



    /**

     * @notice Overrides SELFBALANCE.

     * @return _BALANCE OVM_ETH balance of the requesting contract.

     */

    function ovmSELFBALANCE()

        override

        external

        returns (

            uint256 _BALANCE

        )

    {

        return ovmBALANCE(ovmADDRESS());

    }





    /***************************************

     * Public Functions: Execution Context *

     ***************************************/



    function getMaxTransactionGasLimit()

        external

        view

        override

        returns (

            uint256 _maxTransactionGasLimit

        )

    {

        return gasMeterConfig.maxTransactionGasLimit;

    }



    /********************************************

     * Public Functions: Deployment Whitelisting *

     ********************************************/



    /**

     * Checks whether the given address is on the whitelist to ovmCREATE/ovmCREATE2, and reverts if not.

     * @param _deployerAddress Address attempting to deploy a contract.

     */

    function _checkDeployerAllowed(

        address _deployerAddress

    )

        internal

    {

        // From an OVM semantics perspective, this will appear identical to

        // the deployer ovmCALLing the whitelist.  This is fine--in a sense, we are forcing them to.

        (bool success, bytes memory data) = ovmSTATICCALL(

            gasleft(),

            Lib_PredeployAddresses.DEPLOYER_WHITELIST,

            abi.encodeWithSelector(

                OVM_DeployerWhitelist.isDeployerAllowed.selector,

                _deployerAddress

            )

        );

        bool isAllowed = abi.decode(data, (bool));



        if (!isAllowed || !success) {

            _revertWithFlag(RevertFlag.CREATOR_NOT_ALLOWED);

        }

    }



    /********************************************

     * Internal Functions: Contract Interaction *

     ********************************************/



    /**

     * Creates a new contract and associates it with some contract address.

     * @param _contractAddress Address to associate the created contract with.

     * @param _bytecode Bytecode to be used to create the contract.

     * @return Final OVM contract address.

     * @return Revertdata, if and only if the creation threw an exception.

     */

    function _createContract(

        address _contractAddress,

        bytes memory _bytecode,

        MessageType _messageType

    )

        internal

        returns (

            address,

            bytes memory

        )

    {

        // We always update the nonce of the creating account, even if the creation fails.

        _setAccountNonce(ovmADDRESS(), _getAccountNonce(ovmADDRESS()) + 1);



        // We're stepping into a CREATE or CREATE2, so we need to update ADDRESS to point

        // to the contract's associated address and CALLER to point to the previous ADDRESS.

        MessageContext memory nextMessageContext = messageContext;

        nextMessageContext.ovmCALLER = messageContext.ovmADDRESS;

        nextMessageContext.ovmADDRESS = _contractAddress;



        // Run the common logic which occurs between call-type and create-type messages,

        // passing in the creation bytecode and `true` to trigger create-specific logic.

        (bool success, bytes memory data) = _handleExternalMessage(

            nextMessageContext,

            gasleft(),

            _contractAddress,

            _bytecode,

            _messageType

        );



        // Yellow paper requires that address returned is zero if the contract deployment fails.

        return (

            success ? _contractAddress : address(0),

            data

        );

    }



    /**

     * Calls the deployed contract associated with a given address.

     * @param _nextMessageContext Message context to be used for the call.

     * @param _gasLimit Amount of gas to be passed into this call.

     * @param _contract OVM address to be called.

     * @param _calldata Data to send along with the call.

     * @return _success Whether or not the call returned (rather than reverted).

     * @return _returndata Data returned by the call.

     */

    function _callContract(

        MessageContext memory _nextMessageContext,

        uint256 _gasLimit,

        address _contract,

        bytes memory _calldata,

        MessageType _messageType

    )

        internal

        returns (

            bool _success,

            bytes memory _returndata

        )

    {

        // We reserve addresses of the form 0xdeaddeaddead...NNNN for the container contracts in L2 geth.

        // So, we block calls to these addresses since they are not safe to run as an OVM contract itself.

        if (

            (uint256(_contract) & uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000))

            == uint256(CONTAINER_CONTRACT_PREFIX)

        ) {

            // EVM does not return data in the success case, see: https://github.com/ethereum/go-ethereum/blob/aae7660410f0ef90279e14afaaf2f429fdc2a186/core/vm/instructions.go#L600-L604

            return (true, hex'');

        }



        // Both 0x0000... and the EVM precompiles have the same address on L1 and L2 --> no trie lookup needed.

        address codeContractAddress =

            uint(_contract) < 100

            ? _contract

            : _getAccountEthAddress(_contract);



        return _handleExternalMessage(

            _nextMessageContext,

            _gasLimit,

            codeContractAddress,

            _calldata,

            _messageType

        );

    }



    /**

     * Handles all interactions which involve the execution manager calling out to untrusted code (both calls and creates).

     * Ensures that OVM-related measures are enforced, including L2 gas refunds, nuisance gas, and flagged reversions.

     *

     * @param _nextMessageContext Message context to be used for the external message.

     * @param _gasLimit Amount of gas to be passed into this message. NOTE: this argument is overwritten in some cases to avoid stack-too-deep.

     * @param _contract OVM address being called or deployed to

     * @param _data Data for the message (either calldata or creation code)

     * @param _messageType What type of ovmOPCODE this message corresponds to.

     * @return Whether or not the message (either a call or deployment) succeeded.

     * @return Data returned by the message.

     */

    function _handleExternalMessage(

        MessageContext memory _nextMessageContext,

        // NOTE: this argument is overwritten in some cases to avoid stack-too-deep.

        uint256 _gasLimit,

        address _contract,

        bytes memory _data,

        MessageType _messageType

    )

        internal

        returns (

            bool,

            bytes memory

        )

    {

        uint256 messageValue = _nextMessageContext.ovmCALLVALUE;

        // If there is value in this message, we need to transfer the ETH over before switching contexts.

        if (

            messageValue > 0

            && _isValueType(_messageType)

        ) {

            // Handle out-of-intrinsic gas consistent with EVM behavior -- the subcall "appears to revert" if we don't have enough gas to transfer the ETH.

            // Similar to dynamic gas cost of value exceeding gas here:

            // https://github.com/ethereum/go-ethereum/blob/c503f98f6d5e80e079c1d8a3601d188af2a899da/core/vm/interpreter.go#L268-L273

            if (gasleft() < CALL_WITH_VALUE_INTRINSIC_GAS) {

                return (false, hex"");

            }



            // If there *is* enough gas to transfer ETH, then we need to make sure this amount of gas is reserved (i.e. not

            // given to the _contract.call below) to guarantee that _handleExternalMessage can't run out of gas.

            // In particular, in the event that the call fails, we will need to transfer the ETH back to the sender.

            // Taking the lesser of _gasLimit and gasleft() - CALL_WITH_VALUE_INTRINSIC_GAS guarantees that the second

            // _attemptForcedEthTransfer below, if needed, always has enough gas to succeed.

            _gasLimit = Math.min(

                _gasLimit,

                gasleft() - CALL_WITH_VALUE_INTRINSIC_GAS // Cannot overflow due to the above check.

            );



            // Now transfer the value of the call.

            // The target is interpreted to be the next message's ovmADDRESS account.

            bool transferredOvmEth = _attemptForcedEthTransfer(

                _nextMessageContext.ovmADDRESS,

                messageValue

            );



            // If the ETH transfer fails (should only be possible in the case of insufficient balance), then treat this as a revert.

            // This mirrors EVM behavior, see https://github.com/ethereum/go-ethereum/blob/2dee31930c9977af2a9fcb518fb9838aa609a7cf/core/vm/evm.go#L298

            if (!transferredOvmEth) {

                return (false, hex"");

            }

        }



        // We need to switch over to our next message context for the duration of this call.

        MessageContext memory prevMessageContext = messageContext;

        _switchMessageContext(prevMessageContext, _nextMessageContext);



        // Nuisance gas is a system used to bound the ability for an attacker to make fraud proofs

        // expensive by touching a lot of different accounts or storage slots. Since most contracts

        // only use a few storage slots during any given transaction, this shouldn't be a limiting

        // factor.

        uint256 prevNuisanceGasLeft = messageRecord.nuisanceGasLeft;

        uint256 nuisanceGasLimit = _getNuisanceGasLimit(_gasLimit);

        messageRecord.nuisanceGasLeft = nuisanceGasLimit;



        // Make the call and make sure to pass in the gas limit. Another instance of hidden

        // complexity. `_contract` is guaranteed to be a safe contract, meaning its return/revert

        // behavior can be controlled. In particular, we enforce that flags are passed through

        // revert data as to retrieve execution metadata that would normally be reverted out of

        // existence.



        bool success;

        bytes memory returndata;

        if (_isCreateType(_messageType)) {

            // safeCREATE() is a function which replicates a CREATE message, but uses return values

            // Which match that of CALL (i.e. bool, bytes).  This allows many security checks to be

            // to be shared between untrusted call and create call frames.

            (success, returndata) = address(this).call{gas: _gasLimit}(

                abi.encodeWithSelector(

                    this.safeCREATE.selector,

                    _data,

                    _contract

                )

            );

        } else {

            (success, returndata) = _contract.call{gas: _gasLimit}(_data);

        }



        // If the message threw an exception, its value should be returned back to the sender.

        // So, we force it back, BEFORE returning the messageContext to the previous addresses.

        // This operation is part of the reason we "reserved the intrinsic gas" above.

        if (

            messageValue > 0

            && _isValueType(_messageType)

            && !success

        ) {

            bool transferredOvmEth = _attemptForcedEthTransfer(

                prevMessageContext.ovmADDRESS,

                messageValue

            );



            // Since we transferred it in above and the call reverted, the transfer back should always pass.

            // This code path should NEVER be triggered since we sent `messageValue` worth of OVM_ETH into the target

            // and reserved sufficient gas to execute the transfer, but in case there is some edge case which has

            // been missed, we revert the entire frame (and its parent) to make sure the ETH gets sent back.

            if (!transferredOvmEth) {

                _revertWithFlag(RevertFlag.OUT_OF_GAS);

            }

        }



        // Switch back to the original message context now that we're out of the call and all OVM_ETH is in the right place.

        _switchMessageContext(_nextMessageContext, prevMessageContext);



        // Assuming there were no reverts, the message record should be accurate here. We'll update

        // this value in the case of a revert.

        uint256 nuisanceGasLeft = messageRecord.nuisanceGasLeft;



        // Reverts at this point are completely OK, but we need to make a few updates based on the

        // information passed through the revert.

        if (success == false) {

            (

                RevertFlag flag,

                uint256 nuisanceGasLeftPostRevert,

                uint256 ovmGasRefund,

                bytes memory returndataFromFlag

            ) = _decodeRevertData(returndata);



            // INVALID_STATE_ACCESS is the only flag that triggers an immediate abort of the

            // parent EVM message. This behavior is necessary because INVALID_STATE_ACCESS must

            // halt any further transaction execution that could impact the execution result.

            if (flag == RevertFlag.INVALID_STATE_ACCESS) {

                _revertWithFlag(flag);

            }



            // INTENTIONAL_REVERT, UNSAFE_BYTECODE, STATIC_VIOLATION, and CREATOR_NOT_ALLOWED aren't

            // dependent on the input state, so we can just handle them like standard reverts. Our only change here

            // is to record the gas refund reported by the call (enforced by safety checking).

            if (

                flag == RevertFlag.INTENTIONAL_REVERT

                || flag == RevertFlag.UNSAFE_BYTECODE

                || flag == RevertFlag.STATIC_VIOLATION

                || flag == RevertFlag.CREATOR_NOT_ALLOWED

            ) {

                transactionRecord.ovmGasRefund = ovmGasRefund;

            }



            // INTENTIONAL_REVERT needs to pass up the user-provided return data encoded into the

            // flag, *not* the full encoded flag.  Additionally, we surface custom error messages

            // to developers in the case of unsafe creations for improved devex.

            // All other revert types return no data.

            if (

                flag == RevertFlag.INTENTIONAL_REVERT

                || flag == RevertFlag.UNSAFE_BYTECODE

            ) {

                returndata = returndataFromFlag;

            } else {

                returndata = hex'';

            }



            // Reverts mean we need to use up whatever "nuisance gas" was used by the call.

            // EXCEEDS_NUISANCE_GAS explicitly reduces the remaining nuisance gas for this message

            // to zero. OUT_OF_GAS is a "pseudo" flag given that messages return no data when they

            // run out of gas, so we have to treat this like EXCEEDS_NUISANCE_GAS. All other flags

            // will simply pass up the remaining nuisance gas.

            nuisanceGasLeft = nuisanceGasLeftPostRevert;

        }



        // We need to reset the nuisance gas back to its original value minus the amount used here.

        messageRecord.nuisanceGasLeft = prevNuisanceGasLeft - (nuisanceGasLimit - nuisanceGasLeft);



        return (

            success,

            returndata

        );

    }



    /**

     * Handles the creation-specific safety measures required for OVM contract deployment.

     * This function sanitizes the return types for creation messages to match calls (bool, bytes),

     * by being an external function which the EM can call, that mimics the success/fail case of the CREATE.

     * This allows for consistent handling of both types of messages in _handleExternalMessage().

     * Having this step occur as a separate call frame also allows us to easily revert the

     * contract deployment in the event that the code is unsafe.

     *

     * @param _creationCode Code to pass into CREATE for deployment.

     * @param _address OVM address being deployed to.

     */

    function safeCREATE(

        bytes memory _creationCode,

        address _address

    )

        external

    {

        // The only way this should callable is from within _createContract(),

        // and it should DEFINITELY not be callable by a non-EM code contract.

        if (msg.sender != address(this)) {

            return;

        }

        // Check that there is not already code at this address.

        if (_hasEmptyAccount(_address) == false) {

            // Note: in the EVM, this case burns all allotted gas.  For improved

            // developer experience, we do return the remaining gas.

            _revertWithFlag(

                RevertFlag.CREATE_COLLISION

            );

        }



        // Check the creation bytecode against the OVM_SafetyChecker.

        if (ovmSafetyChecker.isBytecodeSafe(_creationCode) == false) {

            // Note: in the EVM, this case burns all allotted gas.  For improved

            // developer experience, we do return the remaining gas.

            _revertWithFlag(

                RevertFlag.UNSAFE_BYTECODE,

                Lib_ErrorUtils.encodeRevertString("Contract creation code contains unsafe opcodes. Did you use the right compiler or pass an unsafe constructor argument?")

            );

        }



        // We always need to initialize the contract with the default account values.

        _initPendingAccount(_address);



        // Actually execute the EVM create message.

        // NOTE: The inline assembly below means we can NOT make any evm calls between here and then.

        address ethAddress = Lib_EthUtils.createContract(_creationCode);



        if (ethAddress == address(0)) {

            // If the creation fails, the EVM lets us grab its revert data. This may contain a revert flag

            // to be used above in _handleExternalMessage, so we pass the revert data back up unmodified.

            assembly {

                returndatacopy(0,0,returndatasize())

                revert(0, returndatasize())

            }

        }



        // Again simply checking that the deployed code is safe too. Contracts can generate

        // arbitrary deployment code, so there's no easy way to analyze this beforehand.

        bytes memory deployedCode = Lib_EthUtils.getCode(ethAddress);

        if (ovmSafetyChecker.isBytecodeSafe(deployedCode) == false) {

            _revertWithFlag(

                RevertFlag.UNSAFE_BYTECODE,

                Lib_ErrorUtils.encodeRevertString("Constructor attempted to deploy unsafe bytecode.")

            );

        }



        // Contract creation didn't need to be reverted and the bytecode is safe. We finish up by

        // associating the desired address with the newly created contract's code hash and address.

        _commitPendingAccount(

            _address,

            ethAddress,

            Lib_EthUtils.getCodeHash(ethAddress)

        );

    }



    /******************************************

     * Internal Functions: Value Manipulation *

     ******************************************/



    /**

     * Invokes an ovmCALL to OVM_ETH.transfer on behalf of the current ovmADDRESS, allowing us to force movement of OVM_ETH in correspondence with ETH's native value functionality.

     * WARNING: this will send on behalf of whatever the messageContext.ovmADDRESS is in storage at the time of the call.

     * NOTE: In the future, this could be optimized to directly invoke EM._setContractStorage(...).

     * @param _to Amount of OVM_ETH to be sent.

     * @param _value Amount of OVM_ETH to send.

     * @return _success Whether or not the transfer worked.

     */

    function _attemptForcedEthTransfer(

        address _to,

        uint256 _value

    )

        internal

        returns(

            bool _success

        )

    {

        bytes memory transferCalldata = abi.encodeWithSignature(

            "transfer(address,uint256)",

            _to,

            _value

        );



        // OVM_ETH inherits from the UniswapV2ERC20 standard.  In this implementation, its return type

        // is a boolean.  However, the implementation always returns true if it does not revert.

        // Thus, success of the call frame is sufficient to infer success of the transfer itself.

        (bool success, ) = ovmCALL(

            gasleft(),

            Lib_PredeployAddresses.OVM_ETH,

            0,

            transferCalldata

        );



        return success;

    }



    /******************************************

     * Internal Functions: State Manipulation *

     ******************************************/



    /**

     * Checks whether an account exists within the OVM_StateManager.

     * @param _address Address of the account to check.

     * @return _exists Whether or not the account exists.

     */

    function _hasAccount(

        address _address

    )

        internal

        returns (

            bool _exists

        )

    {

        _checkAccountLoad(_address);

        return ovmStateManager.hasAccount(_address);

    }



    /**

     * Checks whether a known empty account exists within the OVM_StateManager.

     * @param _address Address of the account to check.

     * @return _exists Whether or not the account empty exists.

     */

    function _hasEmptyAccount(

        address _address

    )

        internal

        returns (

            bool _exists

        )

    {

        _checkAccountLoad(_address);

        return ovmStateManager.hasEmptyAccount(_address);

    }



    /**

     * Sets the nonce of an account.

     * @param _address Address of the account to modify.

     * @param _nonce New account nonce.

     */

    function _setAccountNonce(

        address _address,

        uint256 _nonce

    )

        internal

    {

        _checkAccountChange(_address);

        ovmStateManager.setAccountNonce(_address, _nonce);

    }



    /**

     * Gets the nonce of an account.

     * @param _address Address of the account to access.

     * @return _nonce Nonce of the account.

     */

    function _getAccountNonce(

        address _address

    )

        internal

        returns (

            uint256 _nonce

        )

    {

        _checkAccountLoad(_address);

        return ovmStateManager.getAccountNonce(_address);

    }



    /**

     * Retrieves the Ethereum address of an account.

     * @param _address Address of the account to access.

     * @return _ethAddress Corresponding Ethereum address.

     */

    function _getAccountEthAddress(

        address _address

    )

        internal

        returns (

            address _ethAddress

        )

    {

        _checkAccountLoad(_address);

        return ovmStateManager.getAccountEthAddress(_address);

    }



    /**

     * Creates the default account object for the given address.

     * @param _address Address of the account create.

     */

    function _initPendingAccount(

        address _address

    )

        internal

    {

        // Although it seems like `_checkAccountChange` would be more appropriate here, we don't

        // actually consider an account "changed" until it's inserted into the state (in this case

        // by `_commitPendingAccount`).

        _checkAccountLoad(_address);

        ovmStateManager.initPendingAccount(_address);

    }



    /**

     * Stores additional relevant data for a new account, thereby "committing" it to the state.

     * This function is only called during `ovmCREATE` and `ovmCREATE2` after a successful contract

     * creation.

     * @param _address Address of the account to commit.

     * @param _ethAddress Address of the associated deployed contract.

     * @param _codeHash Hash of the code stored at the address.

     */

    function _commitPendingAccount(

        address _address,

        address _ethAddress,

        bytes32 _codeHash

    )

        internal

    {

        _checkAccountChange(_address);

        ovmStateManager.commitPendingAccount(

            _address,

            _ethAddress,

            _codeHash

        );

    }



    /**

     * Retrieves the value of a storage slot.

     * @param _contract Address of the contract to query.

     * @param _key 32 byte key of the storage slot.

     * @return _value 32 byte storage slot value.

     */

    function _getContractStorage(

        address _contract,

        bytes32 _key

    )

        internal

        returns (

            bytes32 _value

        )

    {

        _checkContractStorageLoad(_contract, _key);

        return ovmStateManager.getContractStorage(_contract, _key);

    }



    /**

     * Sets the value of a storage slot.

     * @param _contract Address of the contract to modify.

     * @param _key 32 byte key of the storage slot.

     * @param _value 32 byte storage slot value.

     */

    function _putContractStorage(

        address _contract,

        bytes32 _key,

        bytes32 _value

    )

        internal

    {

        // We don't set storage if the value didn't change. Although this acts as a convenient

        // optimization, it's also necessary to avoid the case in which a contract with no storage

        // attempts to store the value "0" at any key. Putting this value (and therefore requiring

        // that the value be committed into the storage trie after execution) would incorrectly

        // modify the storage root.

        if (_getContractStorage(_contract, _key) == _value) {

            return;

        }



        _checkContractStorageChange(_contract, _key);

        ovmStateManager.putContractStorage(_contract, _key, _value);

    }



    /**

     * Validation whenever a contract needs to be loaded. Checks that the account exists, charges

     * nuisance gas if the account hasn't been loaded before.

     * @param _address Address of the account to load.

     */

    function _checkAccountLoad(

        address _address

    )

        internal

    {

        // See `_checkContractStorageLoad` for more information.

        if (gasleft() < MIN_GAS_FOR_INVALID_STATE_ACCESS) {

            _revertWithFlag(RevertFlag.OUT_OF_GAS);

        }



        // See `_checkContractStorageLoad` for more information.

        if (ovmStateManager.hasAccount(_address) == false) {

            _revertWithFlag(RevertFlag.INVALID_STATE_ACCESS);

        }



        // Check whether the account has been loaded before and mark it as loaded if not. We need

        // this because "nuisance gas" only applies to the first time that an account is loaded.

        (

            bool _wasAccountAlreadyLoaded

        ) = ovmStateManager.testAndSetAccountLoaded(_address);



        // If we hadn't already loaded the account, then we'll need to charge "nuisance gas" based

        // on the size of the contract code.

        if (_wasAccountAlreadyLoaded == false) {

            _useNuisanceGas(

                (Lib_EthUtils.getCodeSize(_getAccountEthAddress(_address)) * NUISANCE_GAS_PER_CONTRACT_BYTE) + MIN_NUISANCE_GAS_PER_CONTRACT

            );

        }

    }



    /**

     * Validation whenever a contract needs to be changed. Checks that the account exists, charges

     * nuisance gas if the account hasn't been changed before.

     * @param _address Address of the account to change.

     */

    function _checkAccountChange(

        address _address

    )

        internal

    {

        // Start by checking for a load as we only want to charge nuisance gas proportional to

        // contract size once.

        _checkAccountLoad(_address);



        // Check whether the account has been changed before and mark it as changed if not. We need

        // this because "nuisance gas" only applies to the first time that an account is changed.

        (

            bool _wasAccountAlreadyChanged

        ) = ovmStateManager.testAndSetAccountChanged(_address);



        // If we hadn't already loaded the account, then we'll need to charge "nuisance gas" based

        // on the size of the contract code.

        if (_wasAccountAlreadyChanged == false) {

            ovmStateManager.incrementTotalUncommittedAccounts();

            _useNuisanceGas(

                (Lib_EthUtils.getCodeSize(_getAccountEthAddress(_address)) * NUISANCE_GAS_PER_CONTRACT_BYTE) + MIN_NUISANCE_GAS_PER_CONTRACT

            );

        }

    }



    /**

     * Validation whenever a slot needs to be loaded. Checks that the account exists, charges

     * nuisance gas if the slot hasn't been loaded before.

     * @param _contract Address of the account to load from.

     * @param _key 32 byte key to load.

     */

    function _checkContractStorageLoad(

        address _contract,

        bytes32 _key

    )

        internal

    {

        // Another case of hidden complexity. If we didn't enforce this requirement, then a

        // contract could pass in just enough gas to cause the INVALID_STATE_ACCESS check to fail

        // on L1 but not on L2. A contract could use this behavior to prevent the

        // OVM_ExecutionManager from detecting an invalid state access. Reverting with OUT_OF_GAS

        // allows us to also charge for the full message nuisance gas, because you deserve that for

        // trying to break the contract in this way.

        if (gasleft() < MIN_GAS_FOR_INVALID_STATE_ACCESS) {

            _revertWithFlag(RevertFlag.OUT_OF_GAS);

        }



        // We need to make sure that the transaction isn't trying to access storage that hasn't

        // been provided to the OVM_StateManager. We'll immediately abort if this is the case.

        // We know that we have enough gas to do this check because of the above test.

        if (ovmStateManager.hasContractStorage(_contract, _key) == false) {

            _revertWithFlag(RevertFlag.INVALID_STATE_ACCESS);

        }



        // Check whether the slot has been loaded before and mark it as loaded if not. We need

        // this because "nuisance gas" only applies to the first time that a slot is loaded.

        (

            bool _wasContractStorageAlreadyLoaded

        ) = ovmStateManager.testAndSetContractStorageLoaded(_contract, _key);



        // If we hadn't already loaded the account, then we'll need to charge some fixed amount of

        // "nuisance gas".

        if (_wasContractStorageAlreadyLoaded == false) {

            _useNuisanceGas(NUISANCE_GAS_SLOAD);

        }

    }



    /**

     * Validation whenever a slot needs to be changed. Checks that the account exists, charges

     * nuisance gas if the slot hasn't been changed before.

     * @param _contract Address of the account to change.

     * @param _key 32 byte key to change.

     */

    function _checkContractStorageChange(

        address _contract,

        bytes32 _key

    )

        internal

    {

        // Start by checking for load to make sure we have the storage slot and that we charge the

        // "nuisance gas" necessary to prove the storage slot state.

        _checkContractStorageLoad(_contract, _key);



        // Check whether the slot has been changed before and mark it as changed if not. We need

        // this because "nuisance gas" only applies to the first time that a slot is changed.

        (

            bool _wasContractStorageAlreadyChanged

        ) = ovmStateManager.testAndSetContractStorageChanged(_contract, _key);



        // If we hadn't already changed the account, then we'll need to charge some fixed amount of

        // "nuisance gas".

        if (_wasContractStorageAlreadyChanged == false) {

            // Changing a storage slot means that we're also going to have to change the

            // corresponding account, so do an account change check.

            _checkAccountChange(_contract);



            ovmStateManager.incrementTotalUncommittedContractStorage();

            _useNuisanceGas(NUISANCE_GAS_SSTORE);

        }

    }





    /************************************

     * Internal Functions: Revert Logic *

     ************************************/



    /**

     * Simple encoding for revert data.

     * @param _flag Flag to revert with.

     * @param _data Additional user-provided revert data.

     * @return _revertdata Encoded revert data.

     */

    function _encodeRevertData(

        RevertFlag _flag,

        bytes memory _data

    )

        internal

        view

        returns (

            bytes memory _revertdata

        )

    {

        // Out of gas and create exceptions will fundamentally return no data, so simulating it shouldn't either.

        if (

            _flag == RevertFlag.OUT_OF_GAS

        ) {

            return bytes('');

        }



        // INVALID_STATE_ACCESS doesn't need to return any data other than the flag.

        if (_flag == RevertFlag.INVALID_STATE_ACCESS) {

            return abi.encode(

                _flag,

                0,

                0,

                bytes('')

            );

        }



        // Just ABI encode the rest of the parameters.

        return abi.encode(

            _flag,

            messageRecord.nuisanceGasLeft,

            transactionRecord.ovmGasRefund,

            _data

        );

    }



    /**

     * Simple decoding for revert data.

     * @param _revertdata Revert data to decode.

     * @return _flag Flag used to revert.

     * @return _nuisanceGasLeft Amount of nuisance gas unused by the message.

     * @return _ovmGasRefund Amount of gas refunded during the message.

     * @return _data Additional user-provided revert data.

     */

    function _decodeRevertData(

        bytes memory _revertdata

    )

        internal

        pure

        returns (

            RevertFlag _flag,

            uint256 _nuisanceGasLeft,

            uint256 _ovmGasRefund,

            bytes memory _data

        )

    {

        // A length of zero means the call ran out of gas, just return empty data.

        if (_revertdata.length == 0) {

            return (

                RevertFlag.OUT_OF_GAS,

                0,

                0,

                bytes('')

            );

        }



        // ABI decode the incoming data.

        return abi.decode(_revertdata, (RevertFlag, uint256, uint256, bytes));

    }



    /**

     * Causes a message to revert or abort.

     * @param _flag Flag to revert with.

     * @param _data Additional user-provided data.

     */

    function _revertWithFlag(

        RevertFlag _flag,

        bytes memory _data

    )

        internal

        view

    {

        bytes memory revertdata = _encodeRevertData(

            _flag,

            _data

        );



        assembly {

            revert(add(revertdata, 0x20), mload(revertdata))

        }

    }



    /**

     * Causes a message to revert or abort.

     * @param _flag Flag to revert with.

     */

    function _revertWithFlag(

        RevertFlag _flag

    )

        internal

    {

        _revertWithFlag(_flag, bytes(''));

    }





    /******************************************

     * Internal Functions: Nuisance Gas Logic *

     ******************************************/



    /**

     * Computes the nuisance gas limit from the gas limit.

     * @dev This function is currently using a naive implementation whereby the nuisance gas limit

     *      is set to exactly equal the lesser of the gas limit or remaining gas. It's likely that

     *      this implementation is perfectly fine, but we may change this formula later.

     * @param _gasLimit Gas limit to compute from.

     * @return _nuisanceGasLimit Computed nuisance gas limit.

     */

    function _getNuisanceGasLimit(

        uint256 _gasLimit

    )

        internal

        view

        returns (

            uint256 _nuisanceGasLimit

        )

    {

        return _gasLimit < gasleft() ? _gasLimit : gasleft();

    }



    /**

     * Uses a certain amount of nuisance gas.

     * @param _amount Amount of nuisance gas to use.

     */

    function _useNuisanceGas(

        uint256 _amount

    )

        internal

    {

        // Essentially the same as a standard OUT_OF_GAS, except we also retain a record of the gas

        // refund to be given at the end of the transaction.

        if (messageRecord.nuisanceGasLeft < _amount) {

            _revertWithFlag(RevertFlag.EXCEEDS_NUISANCE_GAS);

        }



        messageRecord.nuisanceGasLeft -= _amount;

    }





    /************************************

     * Internal Functions: Gas Metering *

     ************************************/



    /**

     * Checks whether a transaction needs to start a new epoch and does so if necessary.

     * @param _timestamp Transaction timestamp.

     */

    function _checkNeedsNewEpoch(

        uint256 _timestamp

    )

        internal

    {

        if (

            _timestamp >= (

                _getGasMetadata(GasMetadataKey.CURRENT_EPOCH_START_TIMESTAMP)

                + gasMeterConfig.secondsPerEpoch

            )

        ) {

            _putGasMetadata(

                GasMetadataKey.CURRENT_EPOCH_START_TIMESTAMP,

                _timestamp

            );



            _putGasMetadata(

                GasMetadataKey.PREV_EPOCH_SEQUENCER_QUEUE_GAS,

                _getGasMetadata(

                    GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS

                )

            );



            _putGasMetadata(

                GasMetadataKey.PREV_EPOCH_L1TOL2_QUEUE_GAS,

                _getGasMetadata(

                    GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS

                )

            );

        }

    }



    /**

     * Validates the input values of a transaction.

     * @return _valid Whether or not the transaction data is valid.

     */

    function _isValidInput(

        Lib_OVMCodec.Transaction memory _transaction

    )

        view

        internal

        returns (

            bool

        )

    {

        // Prevent reentrancy to run():

        // This check prevents calling run with the default ovmNumber.

        // Combined with the first check in run():

        //      if (transactionContext.ovmNUMBER != DEFAULT_UINT256) { return; }

        // It should be impossible to re-enter since run() returns before any other call frames are created.

        // Since this value is already being written to storage, we save much gas compared to

        // using the standard nonReentrant pattern.

        if (_transaction.blockNumber == DEFAULT_UINT256)  {

            return false;

        }



        if (_isValidGasLimit(_transaction.gasLimit, _transaction.l1QueueOrigin) == false) {

            return false;

        }



        return true;

    }



    /**

     * Validates the gas limit for a given transaction.

     * @param _gasLimit Gas limit provided by the transaction.

     * param _queueOrigin Queue from which the transaction originated.

     * @return _valid Whether or not the gas limit is valid.

     */

    function _isValidGasLimit(

        uint256 _gasLimit,

        Lib_OVMCodec.QueueOrigin // _queueOrigin

    )

        view

        internal

        returns (

            bool _valid

        )

    {

        // Always have to be below the maximum gas limit.

        if (_gasLimit > gasMeterConfig.maxTransactionGasLimit) {

            return false;

        }



        // Always have to be above the minimum gas limit.

        if (_gasLimit < gasMeterConfig.minTransactionGasLimit) {

            return false;

        }



        // TEMPORARY: Gas metering is disabled for minnet.

        return true;

        // GasMetadataKey cumulativeGasKey;

        // GasMetadataKey prevEpochGasKey;

        // if (_queueOrigin == Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE) {

        //     cumulativeGasKey = GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS;

        //     prevEpochGasKey = GasMetadataKey.PREV_EPOCH_SEQUENCER_QUEUE_GAS;

        // } else {

        //     cumulativeGasKey = GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS;

        //     prevEpochGasKey = GasMetadataKey.PREV_EPOCH_L1TOL2_QUEUE_GAS;

        // }



        // return (

        //     (

        //         _getGasMetadata(cumulativeGasKey)

        //         - _getGasMetadata(prevEpochGasKey)

        //         + _gasLimit

        //     ) < gasMeterConfig.maxGasPerQueuePerEpoch

        // );

    }



    /**

     * Updates the cumulative gas after a transaction.

     * @param _gasUsed Gas used by the transaction.

     * @param _queueOrigin Queue from which the transaction originated.

     */

    function _updateCumulativeGas(

        uint256 _gasUsed,

        Lib_OVMCodec.QueueOrigin _queueOrigin

    )

        internal

    {

        GasMetadataKey cumulativeGasKey;

        if (_queueOrigin == Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE) {

            cumulativeGasKey = GasMetadataKey.CUMULATIVE_SEQUENCER_QUEUE_GAS;

        } else {

            cumulativeGasKey = GasMetadataKey.CUMULATIVE_L1TOL2_QUEUE_GAS;

        }



        _putGasMetadata(

            cumulativeGasKey,

            (

                _getGasMetadata(cumulativeGasKey)

                + gasMeterConfig.minTransactionGasLimit

                + _gasUsed

                - transactionRecord.ovmGasRefund

            )

        );

    }



    /**

     * Retrieves the value of a gas metadata key.

     * @param _key Gas metadata key to retrieve.

     * @return _value Value stored at the given key.

     */

    function _getGasMetadata(

        GasMetadataKey _key

    )

        internal

        returns (

            uint256 _value

        )

    {

        return uint256(_getContractStorage(

            GAS_METADATA_ADDRESS,

            bytes32(uint256(_key))

        ));

    }



    /**

     * Sets the value of a gas metadata key.

     * @param _key Gas metadata key to set.

     * @param _value Value to store at the given key.

     */

    function _putGasMetadata(

        GasMetadataKey _key,

        uint256 _value

    )

        internal

    {

        _putContractStorage(

            GAS_METADATA_ADDRESS,

            bytes32(uint256(_key)),

            bytes32(uint256(_value))

        );

    }





    /*****************************************

     * Internal Functions: Execution Context *

     *****************************************/



    /**

     * Swaps over to a new message context.

     * @param _prevMessageContext Context we're switching from.

     * @param _nextMessageContext Context we're switching to.

     */

    function _switchMessageContext(

        MessageContext memory _prevMessageContext,

        MessageContext memory _nextMessageContext

    )

        internal

    {

        // These conditionals allow us to avoid unneccessary SSTOREs.  However, they do mean that the current storage

        // value for the messageContext MUST equal the _prevMessageContext argument, or an SSTORE might be erroneously skipped.

        if (_prevMessageContext.ovmCALLER != _nextMessageContext.ovmCALLER) {

            messageContext.ovmCALLER = _nextMessageContext.ovmCALLER;

        }



        if (_prevMessageContext.ovmADDRESS != _nextMessageContext.ovmADDRESS) {

            messageContext.ovmADDRESS = _nextMessageContext.ovmADDRESS;

        }



        if (_prevMessageContext.isStatic != _nextMessageContext.isStatic) {

            messageContext.isStatic = _nextMessageContext.isStatic;

        }



        if (_prevMessageContext.ovmCALLVALUE != _nextMessageContext.ovmCALLVALUE) {

            messageContext.ovmCALLVALUE = _nextMessageContext.ovmCALLVALUE;

        }

    }



    /**

     * Initializes the execution context.

     * @param _transaction OVM transaction being executed.

     */

    function _initContext(

        Lib_OVMCodec.Transaction memory _transaction

    )

        internal

    {

        transactionContext.ovmTIMESTAMP = _transaction.timestamp;

        transactionContext.ovmNUMBER = _transaction.blockNumber;

        transactionContext.ovmTXGASLIMIT = _transaction.gasLimit;

        transactionContext.ovmL1QUEUEORIGIN = _transaction.l1QueueOrigin;

        transactionContext.ovmL1TXORIGIN = _transaction.l1TxOrigin;

        transactionContext.ovmGASLIMIT = gasMeterConfig.maxGasPerQueuePerEpoch;



        messageRecord.nuisanceGasLeft = _getNuisanceGasLimit(_transaction.gasLimit);

    }



    /**

     * Resets the transaction and message context.

     */

    function _resetContext()

        internal

    {

        transactionContext.ovmL1TXORIGIN = DEFAULT_ADDRESS;

        transactionContext.ovmTIMESTAMP = DEFAULT_UINT256;

        transactionContext.ovmNUMBER = DEFAULT_UINT256;

        transactionContext.ovmGASLIMIT = DEFAULT_UINT256;

        transactionContext.ovmTXGASLIMIT = DEFAULT_UINT256;

        transactionContext.ovmL1QUEUEORIGIN = Lib_OVMCodec.QueueOrigin.SEQUENCER_QUEUE;



        transactionRecord.ovmGasRefund = DEFAULT_UINT256;



        messageContext.ovmCALLER = DEFAULT_ADDRESS;

        messageContext.ovmADDRESS = DEFAULT_ADDRESS;

        messageContext.isStatic = false;



        messageRecord.nuisanceGasLeft = DEFAULT_UINT256;



        // Reset the ovmStateManager.

        ovmStateManager = iOVM_StateManager(address(0));

    }





    /******************************************

     * Internal Functions: Message Typechecks *

     ******************************************/



    /**

     * Returns whether or not the given message type is a CREATE-type.

     * @param _messageType the message type in question.

     */

    function _isCreateType(

        MessageType _messageType

    )

        internal

        pure

        returns(

            bool

        )

    {

        return (

            _messageType == MessageType.ovmCREATE

            || _messageType == MessageType.ovmCREATE2

        );

    }



    /**

     * Returns whether or not the given message type (potentially) requires the transfer of ETH value along with the message.

     * @param _messageType the message type in question.

     */

    function _isValueType(

        MessageType _messageType

    )

        internal

        pure

        returns(

            bool

        )

    {

        // ovmSTATICCALL and ovmDELEGATECALL types do not accept or transfer value.

        return (

            _messageType == MessageType.ovmCALL

            || _messageType == MessageType.ovmCREATE

            || _messageType == MessageType.ovmCREATE2

        );

    }





    /*****************************

     * L2-only Helper Functions *

     *****************************/



    /**

     * Unreachable helper function for simulating eth_calls with an OVM message context.

     * This function will throw an exception in all cases other than when used as a custom entrypoint in L2 Geth to simulate eth_call.

     * @param _transaction the message transaction to simulate.

     * @param _from the OVM account the simulated call should be from.

     * @param _value the amount of ETH value to send.

     * @param _ovmStateManager the address of the OVM_StateManager precompile in the L2 state.

     */

    function simulateMessage(

        Lib_OVMCodec.Transaction memory _transaction,

        address _from,

        uint256 _value,

        iOVM_StateManager _ovmStateManager

    )

        external

        returns (

            bytes memory

        )

    {

        // Prevent this call from having any effect unless in a custom-set VM frame

        require(msg.sender == address(0));



        // Initialize the EM's internal state, ignoring nuisance gas.

        ovmStateManager = _ovmStateManager;

        _initContext(_transaction);

        messageRecord.nuisanceGasLeft = uint(-1);



        // Set the ovmADDRESS to the _from so that the subsequent call frame "comes from" them.

        messageContext.ovmADDRESS = _from;



        // Execute the desired message.

        bool isCreate = _transaction.entrypoint == address(0);

        if (isCreate) {

            (address created, bytes memory revertData) = ovmCREATE(_transaction.data);

            if (created == address(0)) {

                return abi.encode(false, revertData);

            } else {

                // The eth_call RPC endpoint for to = undefined will return the deployed bytecode

                // in the success case, differing from standard create messages.

                return abi.encode(true, Lib_EthUtils.getCode(created));

            }

        } else {

            (bool success, bytes memory returndata) = ovmCALL(

                _transaction.gasLimit,

                _transaction.entrypoint,

                _value,

                _transaction.data

            );

            return abi.encode(success, returndata);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\OVM_L1MultiMessageRelayer.sol
File type: .sol
// SPDX-License-Identifier: MIT

// @unsupported: ovm

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Interface Imports */

import { iOVM_L1CrossDomainMessenger } from "../../../iOVM/bridge/messaging/iOVM_L1CrossDomainMessenger.sol";

import { iOVM_L1MultiMessageRelayer } from "../../../iOVM/bridge/messaging/iOVM_L1MultiMessageRelayer.sol";



/* Library Imports */

import { Lib_AddressResolver } from "../../../libraries/resolver/Lib_AddressResolver.sol";



/**

 * @title OVM_L1MultiMessageRelayer

 * @dev The L1 Multi-Message Relayer contract is a gas efficiency optimization which enables the

 * relayer to submit multiple messages in a single transaction to be relayed by the L1 Cross Domain

 * Message Sender.

 *

 * Compiler used: solc

 * Runtime target: EVM

 */

contract OVM_L1MultiMessageRelayer is iOVM_L1MultiMessageRelayer, Lib_AddressResolver {



    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Address Manager.

     */

    constructor(

        address _libAddressManager

    )

        Lib_AddressResolver(_libAddressManager)

    {}





    /**********************

     * Function Modifiers *

     **********************/



    modifier onlyBatchRelayer() {

        require(

            msg.sender == resolve("OVM_L2BatchMessageRelayer"),

            "OVM_L1MultiMessageRelayer: Function can only be called by the OVM_L2BatchMessageRelayer"

        );

        _;

    }





    /********************

     * Public Functions *

     ********************/



    /**

     * @notice Forwards multiple cross domain messages to the L1 Cross Domain Messenger for relaying

     * @param _messages An array of L2 to L1 messages

     */

    function batchRelayMessages(

        L2ToL1Message[] calldata _messages

    ) 

        override

        external

        onlyBatchRelayer

    {

        iOVM_L1CrossDomainMessenger messenger = iOVM_L1CrossDomainMessenger(

            resolve("Proxy__OVM_L1CrossDomainMessenger")

        );



        for (uint256 i = 0; i < _messages.length; i++) {

            L2ToL1Message memory message = _messages[i];

            messenger.relayMessage(

                message.target,

                message.sender,

                message.message,

                message.messageNonce,

                message.proof

            );

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\OVM_StateCommitmentChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";

import { Lib_AddressResolver } from "../../libraries/resolver/Lib_AddressResolver.sol";

import { Lib_MerkleTree } from "../../libraries/utils/Lib_MerkleTree.sol";



/* Interface Imports */

import { iOVM_FraudVerifier } from "../../iOVM/verification/iOVM_FraudVerifier.sol";

import { iOVM_StateCommitmentChain } from "../../iOVM/chain/iOVM_StateCommitmentChain.sol";

import { iOVM_CanonicalTransactionChain } from "../../iOVM/chain/iOVM_CanonicalTransactionChain.sol";

import { iOVM_BondManager } from "../../iOVM/verification/iOVM_BondManager.sol";

import { iOVM_ChainStorageContainer } from "../../iOVM/chain/iOVM_ChainStorageContainer.sol";



/* External Imports */

import '@openzeppelin/contracts/math/SafeMath.sol';



/**

 * @title OVM_StateCommitmentChain

 * @dev The State Commitment Chain (SCC) contract contains a list of proposed state roots which

 * Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC).

 * Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique

 * state root calculated off-chain by applying the canonical transactions one by one.

 *

 * Compiler used: solc

 * Runtime target: EVM

 */

contract OVM_StateCommitmentChain is iOVM_StateCommitmentChain, Lib_AddressResolver {



    /*************

     * Constants *

     *************/



    uint256 public FRAUD_PROOF_WINDOW;

    uint256 public SEQUENCER_PUBLISH_WINDOW;





    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Address Manager.

     */

    constructor(

        address _libAddressManager,

        uint256 _fraudProofWindow,

        uint256 _sequencerPublishWindow

    )

        Lib_AddressResolver(_libAddressManager)

    {

        FRAUD_PROOF_WINDOW = _fraudProofWindow;

        SEQUENCER_PUBLISH_WINDOW = _sequencerPublishWindow;

    }





    /********************

     * Public Functions *

     ********************/



    /**

     * Accesses the batch storage container.

     * @return Reference to the batch storage container.

     */

    function batches()

        public

        view

        returns (

            iOVM_ChainStorageContainer

        )

    {

        return iOVM_ChainStorageContainer(

            resolve("OVM_ChainStorageContainer-SCC-batches")

        );

    }



    /**

     * @inheritdoc iOVM_StateCommitmentChain

     */

    function getTotalElements()

        override

        public

        view

        returns (

            uint256 _totalElements

        )

    {

        (uint40 totalElements, ) = _getBatchExtraData();

        return uint256(totalElements);

    }



    /**

     * @inheritdoc iOVM_StateCommitmentChain

     */

    function getTotalBatches()

        override

        public

        view

        returns (

            uint256 _totalBatches

        )

    {

        return batches().length();

    }



    /**

     * @inheritdoc iOVM_StateCommitmentChain

     */

    function getLastSequencerTimestamp()

        override

        public

        view

        returns (

            uint256 _lastSequencerTimestamp

        )

    {

        (, uint40 lastSequencerTimestamp) = _getBatchExtraData();

        return uint256(lastSequencerTimestamp);

    }



    /**

     * @inheritdoc iOVM_StateCommitmentChain

     */

    function appendStateBatch(

        bytes32[] memory _batch,

        uint256 _shouldStartAtElement

    )

        override

        public

    {

        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the

        // publication of batches by some other user.

        require(

            _shouldStartAtElement == getTotalElements(),

            "Actual batch start index does not match expected start index."

        );



        // Proposers must have previously staked at the BondManager

        require(

            iOVM_BondManager(resolve("OVM_BondManager")).isCollateralized(msg.sender),

            "Proposer does not have enough collateral posted"

        );



        require(

            _batch.length > 0,

            "Cannot submit an empty state batch."

        );



        require(

            getTotalElements() + _batch.length <= iOVM_CanonicalTransactionChain(resolve("OVM_CanonicalTransactionChain")).getTotalElements(),

            "Number of state roots cannot exceed the number of canonical transactions."

        );



        // Pass the block's timestamp and the publisher of the data

        // to be used in the fraud proofs

        _appendBatch(

            _batch,

            abi.encode(block.timestamp, msg.sender)

        );

    }



    /**

     * @inheritdoc iOVM_StateCommitmentChain

     */

    function deleteStateBatch(

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        override

        public

    {

        require(

            msg.sender == resolve("OVM_FraudVerifier"),

            "State batches can only be deleted by the OVM_FraudVerifier."

        );



        require(

            _isValidBatchHeader(_batchHeader),

            "Invalid batch header."

        );



        require(

            insideFraudProofWindow(_batchHeader),

            "State batches can only be deleted within the fraud proof window."

        );



        _deleteBatch(_batchHeader);

    }



    /**

     * @inheritdoc iOVM_StateCommitmentChain

     */

    function verifyStateCommitment(

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    )

        override

        public

        view

        returns (

            bool

        )

    {

        require(

            _isValidBatchHeader(_batchHeader),

            "Invalid batch header."

        );



        require(

            Lib_MerkleTree.verify(

                _batchHeader.batchRoot,

                _element,

                _proof.index,

                _proof.siblings,

                _batchHeader.batchSize

            ),

            "Invalid inclusion proof."

        );



        return true;

    }



    /**

     * @inheritdoc iOVM_StateCommitmentChain

     */

    function insideFraudProofWindow(

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        override

        public

        view

        returns (

            bool _inside

        )

    {

        (uint256 timestamp,) = abi.decode(

            _batchHeader.extraData,

            (uint256, address)

        );



        require(

            timestamp != 0,

            "Batch header timestamp cannot be zero"

        );

        return SafeMath.add(timestamp, FRAUD_PROOF_WINDOW) > block.timestamp;

    }





    /**********************

     * Internal Functions *

     **********************/



    /**

     * Parses the batch context from the extra data.

     * @return Total number of elements submitted.

     * @return Timestamp of the last batch submitted by the sequencer.

     */

    function _getBatchExtraData()

        internal

        view

        returns (

            uint40,

            uint40

        )

    {

        bytes27 extraData = batches().getGlobalMetadata();



        uint40 totalElements;

        uint40 lastSequencerTimestamp;

        assembly {

            extraData              := shr(40, extraData)

            totalElements          :=         and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)

            lastSequencerTimestamp := shr(40, and(extraData, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))

        }



        return (

            totalElements,

            lastSequencerTimestamp

        );

    }



    /**

     * Encodes the batch context for the extra data.

     * @param _totalElements Total number of elements submitted.

     * @param _lastSequencerTimestamp Timestamp of the last batch submitted by the sequencer.

     * @return Encoded batch context.

     */

    function _makeBatchExtraData(

        uint40 _totalElements,

        uint40 _lastSequencerTimestamp

    )

        internal

        pure

        returns (

            bytes27

        )

    {

        bytes27 extraData;

        assembly {

            extraData := _totalElements

            extraData := or(extraData, shl(40, _lastSequencerTimestamp))

            extraData := shl(40, extraData)

        }



        return extraData;

    }



    /**

     * Appends a batch to the chain.

     * @param _batch Elements within the batch.

     * @param _extraData Any extra data to append to the batch.

     */

    function _appendBatch(

        bytes32[] memory _batch,

        bytes memory _extraData

    )

        internal

    {

        address sequencer = resolve("OVM_Proposer");

        (uint40 totalElements, uint40 lastSequencerTimestamp) = _getBatchExtraData();



        if (msg.sender == sequencer) {

            lastSequencerTimestamp = uint40(block.timestamp);

        } else {

            // We keep track of the last batch submitted by the sequencer so there's a window in

            // which only the sequencer can publish state roots. A window like this just reduces

            // the chance of "system breaking" state roots being published while we're still in

            // testing mode. This window should be removed or significantly reduced in the future.

            require(

                lastSequencerTimestamp + SEQUENCER_PUBLISH_WINDOW < block.timestamp,

                "Cannot publish state roots within the sequencer publication window."

            );

        }



        // For efficiency reasons getMerkleRoot modifies the `_batch` argument in place

        // while calculating the root hash therefore any arguments passed to it must not

        // be used again afterwards

        Lib_OVMCodec.ChainBatchHeader memory batchHeader = Lib_OVMCodec.ChainBatchHeader({

            batchIndex: getTotalBatches(),

            batchRoot: Lib_MerkleTree.getMerkleRoot(_batch),

            batchSize: _batch.length,

            prevTotalElements: totalElements,

            extraData: _extraData

        });



        emit StateBatchAppended(

            batchHeader.batchIndex,

            batchHeader.batchRoot,

            batchHeader.batchSize,

            batchHeader.prevTotalElements,

            batchHeader.extraData

        );



        batches().push(

            Lib_OVMCodec.hashBatchHeader(batchHeader),

            _makeBatchExtraData(

                uint40(batchHeader.prevTotalElements + batchHeader.batchSize),

                lastSequencerTimestamp

            )

        );

    }



    /**

     * Removes a batch and all subsequent batches from the chain.

     * @param _batchHeader Header of the batch to remove.

     */

    function _deleteBatch(

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        internal

    {

        require(

            _batchHeader.batchIndex < batches().length(),

            "Invalid batch index."

        );



        require(

            _isValidBatchHeader(_batchHeader),

            "Invalid batch header."

        );



        batches().deleteElementsAfterInclusive(

            _batchHeader.batchIndex,

            _makeBatchExtraData(

                uint40(_batchHeader.prevTotalElements),

                0

            )

        );



        emit StateBatchDeleted(

            _batchHeader.batchIndex,

            _batchHeader.batchRoot

        );

    }



    /**

     * Checks that a batch header matches the stored hash for the given index.

     * @param _batchHeader Batch header to validate.

     * @return Whether or not the header matches the stored one.

     */

    function _isValidBatchHeader(

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        internal

        view

        returns (

            bool

        )

    {

        return Lib_OVMCodec.hashBatchHeader(_batchHeader) == batches().get(_batchHeader.batchIndex);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity >=0.6.0 <0.8.0;



import "../utils/Context.sol";

/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\OwnableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)



pragma solidity ^0.8.0;



import "../utils/ContextUpgradeable.sol";

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    function __Ownable_init() internal onlyInitializing {

        __Ownable_init_unchained();

    }



    function __Ownable_init_unchained() internal onlyInitializing {

        _transferOwnership(_msgSender());

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        _checkOwner();

        _;

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if the sender is not the owner.

     */

    function _checkOwner() internal view virtual {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _transferOwnership(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Internal function without access restriction.

     */

    function _transferOwnership(address newOwner) internal virtual {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\PausableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/ContextUpgradeable.sol";

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module which allows children to implement an emergency stop

 * mechanism that can be triggered by an authorized account.

 *

 * This module is used through inheritance. It will make available the

 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to

 * the functions of your contract. Note that they will not be pausable by

 * simply including this module, only once the modifiers are put in place.

 */

abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {

    /**

     * @dev Emitted when the pause is triggered by `account`.

     */

    event Paused(address account);



    /**

     * @dev Emitted when the pause is lifted by `account`.

     */

    event Unpaused(address account);



    bool private _paused;



    /**

     * @dev Initializes the contract in unpaused state.

     */

    function __Pausable_init() internal initializer {

        __Context_init_unchained();

        __Pausable_init_unchained();

    }



    function __Pausable_init_unchained() internal initializer {

        _paused = false;

    }



    /**

     * @dev Returns true if the contract is paused, and false otherwise.

     */

    function paused() public view virtual returns (bool) {

        return _paused;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is not paused.

     *

     * Requirements:

     *

     * - The contract must not be paused.

     */

    modifier whenNotPaused() {

        require(!paused(), "Pausable: paused");

        _;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is paused.

     *

     * Requirements:

     *

     * - The contract must be paused.

     */

    modifier whenPaused() {

        require(paused(), "Pausable: not paused");

        _;

    }



    /**

     * @dev Triggers stopped state.

     *

     * Requirements:

     *

     * - The contract must not be paused.

     */

    function _pause() internal virtual whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    /**

     * @dev Returns to normal state.

     *

     * Requirements:

     *

     * - The contract must be paused.

     */

    function _unpause() internal virtual whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Predeploys.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



/**

 * @title Predeploys

 * @notice Contains constant addresses for contracts that are pre-deployed to the L2 system.

 */

library Predeploys {

    /**

     * @notice Address of the L2ToL1MessagePasser predeploy.

     */

    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000016;



    /**

     * @notice Address of the L2CrossDomainMessenger predeploy.

     */

    address internal constant L2_CROSS_DOMAIN_MESSENGER =

        0x4200000000000000000000000000000000000007;



    /**

     * @notice Address of the L2StandardBridge predeploy.

     */

    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;



    /**

     * @notice Address of the L2ERC721Bridge predeploy.

     */

    address internal constant L2_ERC721_BRIDGE = 0x4200000000000000000000000000000000000014;



    /**

     * @notice Address of the SequencerFeeWallet predeploy.

     */

    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;



    /**

     * @notice Address of the OptimismMintableERC20Factory predeploy.

     */

    address internal constant OPTIMISM_MINTABLE_ERC20_FACTORY =

        0x4200000000000000000000000000000000000012;



    /**

     * @notice Address of the OptimismMintableERC721Factory predeploy.

     */

    address internal constant OPTIMISM_MINTABLE_ERC721_FACTORY =

        0x4200000000000000000000000000000000000017;



    /**

     * @notice Address of the L1Block predeploy.

     */

    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;



    /**

     * @notice Address of the GasPriceOracle predeploy. Includes fee information

     *         and helpers for computing the L1 portion of the transaction fee.

     */

    address internal constant GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;



    /**

     * @custom:legacy

     * @notice Address of the L1MessageSender predeploy. Deprecated. Use L2CrossDomainMessenger

     *         or access tx.origin (or msg.sender) in a L1 to L2 transaction instead.

     */

    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;



    /**

     * @custom:legacy

     * @notice Address of the DeployerWhitelist predeploy. No longer active.

     */

    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;



    /**

     * @custom:legacy

     * @notice Address of the LegacyERC20ETH predeploy. Deprecated. Balances are migrated to the

     *         state trie as of the Bedrock upgrade. Contract has been locked and write functions

     *         can no longer be accessed.

     */

    address internal constant LEGACY_ERC20_ETH = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;



    /**

     * @custom:legacy

     * @notice Address of the L1BlockNumber predeploy. Deprecated. Use the L1Block predeploy

     *         instead, which exposes more information about the L1 state.

     */

    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;



    /**

     * @custom:legacy

     * @notice Address of the LegacyMessagePasser predeploy. Deprecate. Use the updated

     *         L2ToL1MessagePasser contract instead.

     */

    address internal constant LEGACY_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;



    /**

     * @notice Address of the ProxyAdmin predeploy.

     */

    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000018;



    /**

     * @notice Address of the BaseFeeVault predeploy.

     */

    address internal constant BASE_FEE_VAULT = 0x4200000000000000000000000000000000000019;



    /**

     * @notice Address of the L1FeeVault predeploy.

     */

    address internal constant L1_FEE_VAULT = 0x420000000000000000000000000000000000001A;



    /**

     * @notice Address of the GovernanceToken predeploy.

     */

    address internal constant GOVERNANCE_TOKEN = 0x4200000000000000000000000000000000000042;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\ReentrancyGuardUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * TIP: If you would like to learn more about reentrancy and alternative ways

 * to protect against it, check out our blog post

 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].

 */

abstract contract ReentrancyGuardUpgradeable is Initializable {

    // Booleans are more expensive than uint256 or any type that takes up a full

    // word because each write operation emits an extra SLOAD to first read the

    // slot's contents, replace the bits taken up by the boolean, and then write

    // back. This is the compiler's defense against contract upgrades and

    // pointer aliasing, and it cannot be disabled.



    // The values being non-zero value makes deployment a bit more expensive,

    // but in exchange the refund on every call to nonReentrant will be lower in

    // amount. Since refunds are capped to a percentage of the total

    // transaction's gas, it is best to keep them low in cases like this one, to

    // increase the likelihood of the full refund coming into effect.

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    uint256 private _status;



    function __ReentrancyGuard_init() internal initializer {

        __ReentrancyGuard_init_unchained();

    }



    function __ReentrancyGuard_init_unchained() internal initializer {

        _status = _NOT_ENTERED;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _status = _ENTERED;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _status = _NOT_ENTERED;

    }

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\ResourceMetering.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



import { Initializable } from "@openzeppelin/contracts/proxy/utils/Initializable.sol";

import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";

import { Burn } from "../libraries/Burn.sol";

import { Arithmetic } from "../libraries/Arithmetic.sol";



/**

 * @custom:upgradeable

 * @title ResourceMetering

 * @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing

 *         updates automatically based on current demand.

 */

abstract contract ResourceMetering is Initializable {

    /**

     * @notice Represents the various parameters that control the way in which resources are

     *         metered. Corresponds to the EIP-1559 resource metering system.

     *

     * @custom:field prevBaseFee   Base fee from the previous block(s).

     * @custom:field prevBoughtGas Amount of gas bought so far in the current block.

     * @custom:field prevBlockNum  Last block number that the base fee was updated.

     */

    struct ResourceParams {

        uint128 prevBaseFee;

        uint64 prevBoughtGas;

        uint64 prevBlockNum;

    }



    /**

     * @notice Represents the configuration for the EIP-1559 based curve for the deposit gas

     *         market. These values should be set with care as it is possible to set them in

     *         a way that breaks the deposit gas market. The target resource limit is defined as

     *         maxResourceLimit / elasticityMultiplier. This struct was designed to fit within a

     *         single word. There is additional space for additions in the future.

     *

     * @custom:field maxResourceLimit             Represents the maximum amount of deposit gas that

     *                                            can be purchased per block.

     * @custom:field elasticityMultiplier         Determines the target resource limit along with

     *                                            the resource limit.

     * @custom:field baseFeeMaxChangeDenominator  Determines max change on fee per block.

     * @custom:field minimumBaseFee               The min deposit base fee, it is clamped to this

     *                                            value.

     * @custom:field systemTxMaxGas               The amount of gas supplied to the system

     *                                            transaction. This should be set to the same number

     *                                            that the op-node sets as the gas limit for the

     *                                            system transaction.

     * @custom:field maximumBaseFee               The max deposit base fee, it is clamped to this

     *                                            value.

     */

    struct ResourceConfig {

        uint32 maxResourceLimit;

        uint8 elasticityMultiplier;

        uint8 baseFeeMaxChangeDenominator;

        uint32 minimumBaseFee;

        uint32 systemTxMaxGas;

        uint128 maximumBaseFee;

    }



    /**

     * @notice EIP-1559 style gas parameters.

     */

    ResourceParams public params;



    /**

     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.

     */

    uint256[48] private __gap;



    /**

     * @notice Meters access to a function based an amount of a requested resource.

     *

     * @param _amount Amount of the resource requested.

     */

    modifier metered(uint64 _amount) {

        // Record initial gas amount so we can refund for it later.

        uint256 initialGas = gasleft();



        // Run the underlying function.

        _;



        // Run the metering function.

        _metered(_amount, initialGas);

    }



    /**

     * @notice An internal function that holds all of the logic for metering a resource.

     *

     * @param _amount     Amount of the resource requested.

     * @param _initialGas The amount of gas before any modifier execution.

     */

    function _metered(uint64 _amount, uint256 _initialGas) internal {

        // Update block number and base fee if necessary.

        uint256 blockDiff = block.number - params.prevBlockNum;



        ResourceConfig memory config = _resourceConfig();

        int256 targetResourceLimit = int256(uint256(config.maxResourceLimit)) /

            int256(uint256(config.elasticityMultiplier));



        if (blockDiff > 0) {

            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate

            // at which deposits can be created and therefore limit the potential for deposits to

            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.

            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - targetResourceLimit;

            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /

                (targetResourceLimit * int256(uint256(config.baseFeeMaxChangeDenominator)));



            // Update base fee by adding the base fee delta and clamp the resulting value between

            // min and max.

            int256 newBaseFee = Arithmetic.clamp({

                _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,

                _min: int256(uint256(config.minimumBaseFee)),

                _max: int256(uint256(config.maximumBaseFee))

            });



            // If we skipped more than one block, we also need to account for every empty block.

            // Empty block means there was no demand for deposits in that block, so we should

            // reflect this lack of demand in the fee.

            if (blockDiff > 1) {

                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)

                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value

                // between min and max.

                newBaseFee = Arithmetic.clamp({

                    _value: Arithmetic.cdexp({

                        _coefficient: newBaseFee,

                        _denominator: int256(uint256(config.baseFeeMaxChangeDenominator)),

                        _exponent: int256(blockDiff - 1)

                    }),

                    _min: int256(uint256(config.minimumBaseFee)),

                    _max: int256(uint256(config.maximumBaseFee))

                });

            }



            // Update new base fee, reset bought gas, and update block number.

            params.prevBaseFee = uint128(uint256(newBaseFee));

            params.prevBoughtGas = 0;

            params.prevBlockNum = uint64(block.number);

        }



        // Make sure we can actually buy the resource amount requested by the user.

        params.prevBoughtGas += _amount;

        require(

            int256(uint256(params.prevBoughtGas)) <= int256(uint256(config.maxResourceLimit)),

            "ResourceMetering: cannot buy more gas than available gas limit"

        );



        // Determine the amount of ETH to be paid.

        uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);



        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount

        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid

        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during

        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei

        // during any 1 day period in the last 5 years, so should be fine.

        uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);



        // Give the user a refund based on the amount of gas they used to do all of the work up to

        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts

        // effectively like a dynamic stipend (with a minimum value).

        uint256 usedGas = _initialGas - gasleft();

        if (gasCost > usedGas) {

            Burn.gas(gasCost - usedGas);

        }

    }



    /**

     * @notice Virtual function that returns the resource config. Contracts that inherit this

     *         contract must implement this function.

     *

     * @return ResourceConfig

     */

    function _resourceConfig() internal virtual returns (ResourceConfig memory);



    /**

     * @notice Sets initial resource parameter values. This function must either be called by the

     *         initializer function of an upgradeable child contract.

     */

    // solhint-disable-next-line func-name-mixedcase

    function __ResourceMetering_init() internal onlyInitializing {

        params = ResourceParams({

            prevBaseFee: 1 gwei,

            prevBoughtGas: 0,

            prevBlockNum: uint64(block.number)

        });

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\RLPReader.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.8;



/**

 * @custom:attribution https://github.com/hamdiallam/Solidity-RLP

 * @title RLPReader

 * @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted

 *         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with

 *         various tweaks to improve readability.

 */

library RLPReader {

    /**

     * Custom pointer type to avoid confusion between pointers and uint256s.

     */

    type MemoryPointer is uint256;



    /**

     * @notice RLP item types.

     *

     * @custom:value DATA_ITEM Represents an RLP data item (NOT a list).

     * @custom:value LIST_ITEM Represents an RLP list item.

     */

    enum RLPItemType {

        DATA_ITEM,

        LIST_ITEM

    }



    /**

     * @notice Struct representing an RLP item.

     *

     * @custom:field length Length of the RLP item.

     * @custom:field ptr    Pointer to the RLP item in memory.

     */

    struct RLPItem {

        uint256 length;

        MemoryPointer ptr;

    }



    /**

     * @notice Max list length that this library will accept.

     */

    uint256 internal constant MAX_LIST_LENGTH = 32;



    /**

     * @notice Converts bytes to a reference to memory position and length.

     *

     * @param _in Input bytes to convert.

     *

     * @return Output memory reference.

     */

    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {

        // Empty arrays are not RLP items.

        require(

            _in.length > 0,

            "RLPReader: length of an RLP item must be greater than zero to be decodable"

        );



        MemoryPointer ptr;

        assembly {

            ptr := add(_in, 32)

        }



        return RLPItem({ length: _in.length, ptr: ptr });

    }



    /**

     * @notice Reads an RLP list value into a list of RLP items.

     *

     * @param _in RLP list value.

     *

     * @return Decoded RLP list items.

     */

    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {

        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);



        require(

            itemType == RLPItemType.LIST_ITEM,

            "RLPReader: decoded item type for list is not a list item"

        );



        require(

            listOffset + listLength == _in.length,

            "RLPReader: list item has an invalid data remainder"

        );



        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by

        // writing to the length. Since we can't know the number of RLP items without looping over

        // the entire input, we'd have to loop twice to accurately size this array. It's easier to

        // simply set a reasonable maximum list length and decrease the size before we finish.

        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);



        uint256 itemCount = 0;

        uint256 offset = listOffset;

        while (offset < _in.length) {

            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(

                RLPItem({

                    length: _in.length - offset,

                    ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)

                })

            );



            // We don't need to check itemCount < out.length explicitly because Solidity already

            // handles this check on our behalf, we'd just be wasting gas.

            out[itemCount] = RLPItem({

                length: itemLength + itemOffset,

                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)

            });



            itemCount += 1;

            offset += itemOffset + itemLength;

        }



        // Decrease the array size to match the actual item count.

        assembly {

            mstore(out, itemCount)

        }



        return out;

    }



    /**

     * @notice Reads an RLP list value into a list of RLP items.

     *

     * @param _in RLP list value.

     *

     * @return Decoded RLP list items.

     */

    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {

        return readList(toRLPItem(_in));

    }



    /**

     * @notice Reads an RLP bytes value into bytes.

     *

     * @param _in RLP bytes value.

     *

     * @return Decoded bytes.

     */

    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {

        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);



        require(

            itemType == RLPItemType.DATA_ITEM,

            "RLPReader: decoded item type for bytes is not a data item"

        );



        require(

            _in.length == itemOffset + itemLength,

            "RLPReader: bytes value contains an invalid remainder"

        );



        return _copy(_in.ptr, itemOffset, itemLength);

    }



    /**

     * @notice Reads an RLP bytes value into bytes.

     *

     * @param _in RLP bytes value.

     *

     * @return Decoded bytes.

     */

    function readBytes(bytes memory _in) internal pure returns (bytes memory) {

        return readBytes(toRLPItem(_in));

    }



    /**

     * @notice Reads the raw bytes of an RLP item.

     *

     * @param _in RLP item to read.

     *

     * @return Raw RLP bytes.

     */

    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {

        return _copy(_in.ptr, 0, _in.length);

    }



    /**

     * @notice Decodes the length of an RLP item.

     *

     * @param _in RLP item to decode.

     *

     * @return Offset of the encoded data.

     * @return Length of the encoded data.

     * @return RLP item type (LIST_ITEM or DATA_ITEM).

     */

    function _decodeLength(RLPItem memory _in)

        private

        pure

        returns (

            uint256,

            uint256,

            RLPItemType

        )

    {

        // Short-circuit if there's nothing to decode, note that we perform this check when

        // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass

        // that function and create an RLP item directly. So we need to check this anyway.

        require(

            _in.length > 0,

            "RLPReader: length of an RLP item must be greater than zero to be decodable"

        );



        MemoryPointer ptr = _in.ptr;

        uint256 prefix;

        assembly {

            prefix := byte(0, mload(ptr))

        }



        if (prefix <= 0x7f) {

            // Single byte.

            return (0, 1, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xb7) {

            // Short string.



            // slither-disable-next-line variable-scope

            uint256 strLen = prefix - 0x80;



            require(

                _in.length > strLen,

                "RLPReader: length of content must be greater than string length (short string)"

            );



            bytes1 firstByteOfContent;

            assembly {

                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))

            }



            require(

                strLen != 1 || firstByteOfContent >= 0x80,

                "RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)"

            );



            return (1, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xbf) {

            // Long string.

            uint256 lenOfStrLen = prefix - 0xb7;



            require(

                _in.length > lenOfStrLen,

                "RLPReader: length of content must be > than length of string length (long string)"

            );



            bytes1 firstByteOfContent;

            assembly {

                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))

            }



            require(

                firstByteOfContent != 0x00,

                "RLPReader: length of content must not have any leading zeros (long string)"

            );



            uint256 strLen;

            assembly {

                strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))

            }



            require(

                strLen > 55,

                "RLPReader: length of content must be greater than 55 bytes (long string)"

            );



            require(

                _in.length > lenOfStrLen + strLen,

                "RLPReader: length of content must be greater than total length (long string)"

            );



            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xf7) {

            // Short list.

            // slither-disable-next-line variable-scope

            uint256 listLen = prefix - 0xc0;



            require(

                _in.length > listLen,

                "RLPReader: length of content must be greater than list length (short list)"

            );



            return (1, listLen, RLPItemType.LIST_ITEM);

        } else {

            // Long list.

            uint256 lenOfListLen = prefix - 0xf7;



            require(

                _in.length > lenOfListLen,

                "RLPReader: length of content must be > than length of list length (long list)"

            );



            bytes1 firstByteOfContent;

            assembly {

                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))

            }



            require(

                firstByteOfContent != 0x00,

                "RLPReader: length of content must not have any leading zeros (long list)"

            );



            uint256 listLen;

            assembly {

                listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))

            }



            require(

                listLen > 55,

                "RLPReader: length of content must be greater than 55 bytes (long list)"

            );



            require(

                _in.length > lenOfListLen + listLen,

                "RLPReader: length of content must be greater than total length (long list)"

            );



            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);

        }

    }



    /**

     * @notice Copies the bytes from a memory location.

     *

     * @param _src    Pointer to the location to read from.

     * @param _offset Offset to start reading from.

     * @param _length Number of bytes to read.

     *

     * @return Copied bytes.

     */

    function _copy(

        MemoryPointer _src,

        uint256 _offset,

        uint256 _length

    ) private pure returns (bytes memory) {

        bytes memory out = new bytes(_length);

        if (_length == 0) {

            return out;

        }



        // Mostly based on Solidity's copy_memory_to_memory:

        // solhint-disable max-line-length

        // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114

        uint256 src = MemoryPointer.unwrap(_src) + _offset;

        assembly {

            let dest := add(out, 32)

            let i := 0

            for {



            } lt(i, _length) {

                i := add(i, 32)

            } {

                mstore(add(dest, i), mload(add(src, i)))

            }



            if gt(i, _length) {

                mstore(add(dest, _length), 0)

            }

        }



        return out;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\RLPWriter.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



/**

 * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode

 * @title RLPWriter

 * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's

 *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor

 *         modifications to improve legibility.

 */

library RLPWriter {

    /**

     * @notice RLP encodes a byte string.

     *

     * @param _in The byte string to encode.

     *

     * @return The RLP encoded string in bytes.

     */

    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {

        bytes memory encoded;



        if (_in.length == 1 && uint8(_in[0]) < 128) {

            encoded = _in;

        } else {

            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);

        }



        return encoded;

    }



    /**

     * @notice RLP encodes a list of RLP encoded byte byte strings.

     *

     * @param _in The list of RLP encoded byte strings.

     *

     * @return The RLP encoded list of items in bytes.

     */

    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {

        bytes memory list = _flatten(_in);

        return abi.encodePacked(_writeLength(list.length, 192), list);

    }



    /**

     * @notice RLP encodes a string.

     *

     * @param _in The string to encode.

     *

     * @return The RLP encoded string in bytes.

     */

    function writeString(string memory _in) internal pure returns (bytes memory) {

        return writeBytes(bytes(_in));

    }



    /**

     * @notice RLP encodes an address.

     *

     * @param _in The address to encode.

     *

     * @return The RLP encoded address in bytes.

     */

    function writeAddress(address _in) internal pure returns (bytes memory) {

        return writeBytes(abi.encodePacked(_in));

    }



    /**

     * @notice RLP encodes a uint.

     *

     * @param _in The uint256 to encode.

     *

     * @return The RLP encoded uint256 in bytes.

     */

    function writeUint(uint256 _in) internal pure returns (bytes memory) {

        return writeBytes(_toBinary(_in));

    }



    /**

     * @notice RLP encodes a bool.

     *

     * @param _in The bool to encode.

     *

     * @return The RLP encoded bool in bytes.

     */

    function writeBool(bool _in) internal pure returns (bytes memory) {

        bytes memory encoded = new bytes(1);

        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));

        return encoded;

    }



    /**

     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.

     *

     * @param _len    The length of the string or the payload.

     * @param _offset 128 if item is string, 192 if item is list.

     *

     * @return RLP encoded bytes.

     */

    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {

        bytes memory encoded;



        if (_len < 56) {

            encoded = new bytes(1);

            encoded[0] = bytes1(uint8(_len) + uint8(_offset));

        } else {

            uint256 lenLen;

            uint256 i = 1;

            while (_len / i != 0) {

                lenLen++;

                i *= 256;

            }



            encoded = new bytes(lenLen + 1);

            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);

            for (i = 1; i <= lenLen; i++) {

                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));

            }

        }



        return encoded;

    }



    /**

     * @notice Encode integer in big endian binary form with no leading zeroes.

     *

     * @param _x The integer to encode.

     *

     * @return RLP encoded bytes.

     */

    function _toBinary(uint256 _x) private pure returns (bytes memory) {

        bytes memory b = abi.encodePacked(_x);



        uint256 i = 0;

        for (; i < 32; i++) {

            if (b[i] != 0) {

                break;

            }

        }



        bytes memory res = new bytes(32 - i);

        for (uint256 j = 0; j < res.length; j++) {

            res[j] = b[i++];

        }



        return res;

    }



    /**

     * @custom:attribution https://github.com/Arachnid/solidity-stringutils

     * @notice Copies a piece of memory to another location.

     *

     * @param _dest Destination location.

     * @param _src  Source location.

     * @param _len  Length of memory to copy.

     */

    function _memcpy(

        uint256 _dest,

        uint256 _src,

        uint256 _len

    ) private pure {

        uint256 dest = _dest;

        uint256 src = _src;

        uint256 len = _len;



        for (; len >= 32; len -= 32) {

            assembly {

                mstore(dest, mload(src))

            }

            dest += 32;

            src += 32;

        }



        uint256 mask;

        unchecked {

            mask = 256**(32 - len) - 1;

        }

        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }

    }



    /**

     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder

     * @notice Flattens a list of byte strings into one byte string.

     *

     * @param _list List of byte strings to flatten.

     *

     * @return The flattened byte string.

     */

    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {

        if (_list.length == 0) {

            return new bytes(0);

        }



        uint256 len;

        uint256 i = 0;

        for (; i < _list.length; i++) {

            len += _list[i].length;

        }



        bytes memory flattened = new bytes(len);

        uint256 flattenedPtr;

        assembly {

            flattenedPtr := add(flattened, 0x20)

        }



        for (i = 0; i < _list.length; i++) {

            bytes memory item = _list[i];



            uint256 listPtr;

            assembly {

                listPtr := add(item, 0x20)

            }



            _memcpy(flattenedPtr, listPtr, item.length);

            flattenedPtr += _list[i].length;

        }



        return flattened;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\SafeCall.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



/**

 * @title SafeCall

 * @notice Perform low level safe calls

 */

library SafeCall {

    /**

     * @notice Performs a low level call without copying any returndata.

     * @dev Passes no calldata to the call context.

     *

     * @param _target   Address to call

     * @param _gas      Amount of gas to pass to the call

     * @param _value    Amount of value to pass to the call

     */

    function send(

        address _target,

        uint256 _gas,

        uint256 _value

    ) internal returns (bool) {

        bool _success;

        assembly {

            _success := call(

                _gas, // gas

                _target, // recipient

                _value, // ether value

                0, // inloc

                0, // inlen

                0, // outloc

                0 // outlen

            )

        }

        return _success;

    }



    /**

     * @notice Perform a low level call without copying any returndata

     *

     * @param _target   Address to call

     * @param _gas      Amount of gas to pass to the call

     * @param _value    Amount of value to pass to the call

     * @param _calldata Calldata to pass to the call

     */

    function call(

        address _target,

        uint256 _gas,

        uint256 _value,

        bytes memory _calldata

    ) internal returns (bool) {

        bool _success;

        assembly {

            _success := call(

                _gas, // gas

                _target, // recipient

                _value, // ether value

                add(_calldata, 32), // inloc

                mload(_calldata), // inlen

                0, // outloc

                0 // outlen

            )

        }

        return _success;

    }



    /**

     * @notice Helper function to determine if there is sufficient gas remaining within the context

     *         to guarantee that the minimum gas requirement for a call will be met as well as

     *         optionally reserving a specified amount of gas for after the call has concluded.

     * @param _minGas      The minimum amount of gas that may be passed to the target context.

     * @param _reservedGas Optional amount of gas to reserve for the caller after the execution

     *                     of the target context.

     * @return `true` if there is enough gas remaining to safely supply `_minGas` to the target

     *         context as well as reserve `_reservedGas` for the caller after the execution of

     *         the target context.

     * @dev !!!!! FOOTGUN ALERT !!!!!

     *      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the

     *          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and

     *          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is

     *          still possible to self-rekt by initiating a withdrawal with a minimum gas limit

     *          that does not account for the `memory_expansion_cost` & `code_execution_cost`

     *          factors of the dynamic cost of the `CALL` opcode.

     *      2.) This function should *directly* precede the external call if possible. There is an

     *          added buffer to account for gas consumed between this check and the call, but it

     *          is only 5,700 gas.

     *      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call

     *          frame may be passed to a subcontext, we need to ensure that the gas will not be

     *          truncated.

     *      4.) Use wisely. This function is not a silver bullet.

     */

    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {

        bool _hasMinGas;

        assembly {

            // Equation: gas ?? 63 ?? minGas ?? 64 + 63(40_000 + reservedGas)

            _hasMinGas := iszero(

                lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63)))

            )

        }

        return _hasMinGas;

    }



    /**

     * @notice Perform a low level call without copying any returndata. This function

     *         will revert if the call cannot be performed with the specified minimum

     *         gas.

     *

     * @param _target   Address to call

     * @param _minGas   The minimum amount of gas that may be passed to the call

     * @param _value    Amount of value to pass to the call

     * @param _calldata Calldata to pass to the call

     */

    function callWithMinGas(

        address _target,

        uint256 _minGas,

        uint256 _value,

        bytes memory _calldata

    ) internal returns (bool) {

        bool _success;

        bool _hasMinGas = hasMinGas(_minGas, 0);

        assembly {

            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000

            if iszero(_hasMinGas) {

                // Store the "Error(string)" selector in scratch space.

                mstore(0, 0x08c379a0)

                // Store the pointer to the string length in scratch space.

                mstore(32, 32)

                // Store the string.

                //

                // SAFETY:

                // - We pad the beginning of the string with two zero bytes as well as the

                // length (24) to ensure that we override the free memory pointer at offset

                // 0x40. This is necessary because the free memory pointer is likely to

                // be greater than 1 byte when this function is called, but it is incredibly

                // unlikely that it will be greater than 3 bytes. As for the data within

                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.

                // - It's fine to clobber the free memory pointer, we're reverting.

                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)



                // Revert with 'Error("SafeCall: Not enough gas")'

                revert(28, 100)

            }



            // The call will be supplied at least ((_minGas * 64) / 63) gas due to the

            // above assertion. This ensures that, in all circumstances (except for when the

            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`

            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least

            // the minimum amount of gas specified.

            _success := call(

                gas(), // gas

                _target, // recipient

                _value, // ether value

                add(_calldata, 32), // inloc

                mload(_calldata), // inlen

                0x00, // outloc

                0x00 // outlen

            )

        }

        return _success;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC20.sol";

import "../../../utils/Address.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender) + value;

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        unchecked {

            uint256 oldAllowance = token.allowance(address(this), spender);

            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");

            uint256 newAllowance = oldAllowance - value;

            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

        }

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {

            // Return data is optional

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\SafeMath.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity >=0.6.0 <0.8.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        uint256 c = a + b;

        if (c < a) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the substraction of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b > a) return (false, 0);

        return (true, a - b);

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) return (true, 0);

        uint256 c = a * b;

        if (c / a != b) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the division of two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a / b);

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a % b);

    }



    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");

        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        return a - b;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) return 0;

        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");

        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: division by zero");

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: modulo by zero");

        return a % b;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {trySub}.

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        return a - b;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryDiv}.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting with custom message when dividing by zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryMod}.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a % b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\SecureMerkleTrie.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



/* Library Imports */

import { MerkleTrie } from "./MerkleTrie.sol";



/**

 * @title SecureMerkleTrie

 * @notice SecureMerkleTrie is a thin wrapper around the MerkleTrie library that hashes the input

 *         keys. Ethereum's state trie hashes input keys before storing them.

 */

library SecureMerkleTrie {

    /**

     * @notice Verifies a proof that a given key/value pair is present in the Merkle trie.

     *

     * @param _key   Key of the node to search for, as a hex string.

     * @param _value Value of the node to search for, as a hex string.

     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle

     *               trees, this proof is executed top-down and consists of a list of RLP-encoded

     *               nodes that make a path down to the target node.

     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is

     *               correctly constructed.

     *

     * @return Whether or not the proof is valid.

     */

    function verifyInclusionProof(

        bytes memory _key,

        bytes memory _value,

        bytes[] memory _proof,

        bytes32 _root

    ) internal pure returns (bool) {

        bytes memory key = _getSecureKey(_key);

        return MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);

    }



    /**

     * @notice Retrieves the value associated with a given key.

     *

     * @param _key   Key to search for, as hex bytes.

     * @param _proof Merkle trie inclusion proof for the key.

     * @param _root  Known root of the Merkle trie.

     *

     * @return Value of the key if it exists.

     */

    function get(

        bytes memory _key,

        bytes[] memory _proof,

        bytes32 _root

    ) internal pure returns (bytes memory) {

        bytes memory key = _getSecureKey(_key);

        return MerkleTrie.get(key, _proof, _root);

    }



    /**

     * @notice Computes the hashed version of the input key.

     *

     * @param _key Key to hash.

     *

     * @return Hashed version of the key.

     */

    function _getSecureKey(bytes memory _key) private pure returns (bytes memory) {

        return abi.encodePacked(keccak256(_key));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Semver.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import { Strings } from "@openzeppelin/contracts/utils/Strings.sol";



/**

 * @title Semver

 * @notice Semver is a simple contract for managing contract versions.

 */

contract Semver {

    /**

     * @notice Contract version number (major).

     */

    uint256 private immutable MAJOR_VERSION;



    /**

     * @notice Contract version number (minor).

     */

    uint256 private immutable MINOR_VERSION;



    /**

     * @notice Contract version number (patch).

     */

    uint256 private immutable PATCH_VERSION;



    /**

     * @param _major Version number (major).

     * @param _minor Version number (minor).

     * @param _patch Version number (patch).

     */

    constructor(

        uint256 _major,

        uint256 _minor,

        uint256 _patch

    ) {

        MAJOR_VERSION = _major;

        MINOR_VERSION = _minor;

        PATCH_VERSION = _patch;

    }



    /**

     * @notice Returns the full semver contract version.

     *

     * @return Semver contract version as a string.

     */

    function version() public view returns (string memory) {

        return

            string(

                abi.encodePacked(

                    Strings.toString(MAJOR_VERSION),

                    ".",

                    Strings.toString(MINOR_VERSION),

                    ".",

                    Strings.toString(PATCH_VERSION)

                )

            );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\SignedMath.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)



pragma solidity ^0.8.0;



/**

 * @dev Standard signed math utilities missing in the Solidity language.

 */

library SignedMath {

    /**

     * @dev Returns the largest of two signed numbers.

     */

    function max(int256 a, int256 b) internal pure returns (int256) {

        return a >= b ? a : b;

    }



    /**

     * @dev Returns the smallest of two signed numbers.

     */

    function min(int256 a, int256 b) internal pure returns (int256) {

        return a < b ? a : b;

    }



    /**

     * @dev Returns the average of two signed numbers without overflow.

     * The result is rounded towards zero.

     */

    function average(int256 a, int256 b) internal pure returns (int256) {

        // Formula from the book "Hacker's Delight"

        int256 x = (a & b) + ((a ^ b) >> 1);

        return x + (int256(uint256(x) >> 255) & (a ^ b));

    }



    /**

     * @dev Returns the absolute unsigned value of a signed value.

     */

    function abs(int256 n) internal pure returns (uint256) {

        unchecked {

            // must be unchecked in order to support `n = type(int256).min`

            return uint256(n >= 0 ? n : -n);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\StandardBridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import { ERC165Checker } from "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";

import { Address } from "@openzeppelin/contracts/utils/Address.sol";

import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import { SafeCall } from "../libraries/SafeCall.sol";

import { IOptimismMintableERC20, ILegacyMintableERC20 } from "./IOptimismMintableERC20.sol";

import { CrossDomainMessenger } from "./CrossDomainMessenger.sol";

import { OptimismMintableERC20 } from "./OptimismMintableERC20.sol";



/**

 * @custom:upgradeable

 * @title StandardBridge

 * @notice StandardBridge is a base contract for the L1 and L2 standard ERC20 bridges. It handles

 *         the core bridging logic, including escrowing tokens that are native to the local chain

 *         and minting/burning tokens that are native to the remote chain.

 */

abstract contract StandardBridge {

    using SafeERC20 for IERC20;



    /**

     * @notice The L2 gas limit set when eth is depoisited using the receive() function.

     */

    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;



    /**

     * @notice Messenger contract on this domain.

     */

    CrossDomainMessenger public immutable MESSENGER;



    /**

     * @notice Corresponding bridge on the other domain.

     */

    StandardBridge public immutable OTHER_BRIDGE;



    /**

     * @custom:legacy

     * @custom:spacer messenger

     * @notice Spacer for backwards compatibility.

     */

    address private spacer_0_0_20;



    /**

     * @custom:legacy

     * @custom:spacer l2TokenBridge

     * @notice Spacer for backwards compatibility.

     */

    address private spacer_1_0_20;



    /**

     * @notice Mapping that stores deposits for a given pair of local and remote tokens.

     */

    mapping(address => mapping(address => uint256)) public deposits;



    /**

     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.

     *         A gap size of 47 was chosen here, so that the first slot used in a child contract

     *         would be a multiple of 50.

     */

    uint256[47] private __gap;



    /**

     * @notice Emitted when an ETH bridge is initiated to the other chain.

     *

     * @param from      Address of the sender.

     * @param to        Address of the receiver.

     * @param amount    Amount of ETH sent.

     * @param extraData Extra data sent with the transaction.

     */

    event ETHBridgeInitiated(

        address indexed from,

        address indexed to,

        uint256 amount,

        bytes extraData

    );



    /**

     * @notice Emitted when an ETH bridge is finalized on this chain.

     *

     * @param from      Address of the sender.

     * @param to        Address of the receiver.

     * @param amount    Amount of ETH sent.

     * @param extraData Extra data sent with the transaction.

     */

    event ETHBridgeFinalized(

        address indexed from,

        address indexed to,

        uint256 amount,

        bytes extraData

    );



    /**

     * @notice Emitted when an ERC20 bridge is initiated to the other chain.

     *

     * @param localToken  Address of the ERC20 on this chain.

     * @param remoteToken Address of the ERC20 on the remote chain.

     * @param from        Address of the sender.

     * @param to          Address of the receiver.

     * @param amount      Amount of the ERC20 sent.

     * @param extraData   Extra data sent with the transaction.

     */

    event ERC20BridgeInitiated(

        address indexed localToken,

        address indexed remoteToken,

        address indexed from,

        address to,

        uint256 amount,

        bytes extraData

    );



    /**

     * @notice Emitted when an ERC20 bridge is finalized on this chain.

     *

     * @param localToken  Address of the ERC20 on this chain.

     * @param remoteToken Address of the ERC20 on the remote chain.

     * @param from        Address of the sender.

     * @param to          Address of the receiver.

     * @param amount      Amount of the ERC20 sent.

     * @param extraData   Extra data sent with the transaction.

     */

    event ERC20BridgeFinalized(

        address indexed localToken,

        address indexed remoteToken,

        address indexed from,

        address to,

        uint256 amount,

        bytes extraData

    );



    /**

     * @notice Only allow EOAs to call the functions. Note that this is not safe against contracts

     *         calling code within their constructors, but also doesn't really matter since we're

     *         just trying to prevent users accidentally depositing with smart contract wallets.

     */

    modifier onlyEOA() {

        require(

            !Address.isContract(msg.sender),

            "StandardBridge: function can only be called from an EOA"

        );

        _;

    }



    /**

     * @notice Ensures that the caller is a cross-chain message from the other bridge.

     */

    modifier onlyOtherBridge() {

        require(

            msg.sender == address(MESSENGER) &&

                MESSENGER.xDomainMessageSender() == address(OTHER_BRIDGE),

            "StandardBridge: function can only be called from the other bridge"

        );

        _;

    }



    /**

     * @param _messenger   Address of CrossDomainMessenger on this network.

     * @param _otherBridge Address of the other StandardBridge contract.

     */

    constructor(address payable _messenger, address payable _otherBridge) {

        MESSENGER = CrossDomainMessenger(_messenger);

        OTHER_BRIDGE = StandardBridge(_otherBridge);

    }



    /**

     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.

     *         Must be implemented by contracts that inherit.

     */

    receive() external payable virtual;



    /**

     * @custom:legacy

     * @notice Legacy getter for messenger contract.

     *

     * @return Messenger contract on this domain.

     */

    function messenger() external view returns (CrossDomainMessenger) {

        return MESSENGER;

    }



    /**

     * @notice Sends ETH to the sender's address on the other chain.

     *

     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.

     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will

     *                     not be triggered with this data, but it will be emitted and can be used

     *                     to identify the transaction.

     */

    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {

        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);

    }



    /**

     * @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a

     *         smart contract and the call fails, the ETH will be temporarily locked in the

     *         StandardBridge on the other chain until the call is replayed. If the call cannot be

     *         replayed with any amount of gas (call always reverts), then the ETH will be

     *         permanently locked in the StandardBridge on the other chain. ETH will also

     *         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert

     *         in that case.

     *

     * @param _to          Address of the receiver.

     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.

     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will

     *                     not be triggered with this data, but it will be emitted and can be used

     *                     to identify the transaction.

     */

    function bridgeETHTo(

        address _to,

        uint32 _minGasLimit,

        bytes calldata _extraData

    ) public payable {

        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);

    }



    /**

     * @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the

     *         ERC20 token on the other chain does not recognize the local token as the correct

     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on

     *         this chain.

     *

     * @param _localToken  Address of the ERC20 on this chain.

     * @param _remoteToken Address of the corresponding token on the remote chain.

     * @param _amount      Amount of local tokens to deposit.

     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.

     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will

     *                     not be triggered with this data, but it will be emitted and can be used

     *                     to identify the transaction.

     */

    function bridgeERC20(

        address _localToken,

        address _remoteToken,

        uint256 _amount,

        uint32 _minGasLimit,

        bytes calldata _extraData

    ) public virtual onlyEOA {

        _initiateBridgeERC20(

            _localToken,

            _remoteToken,

            msg.sender,

            msg.sender,

            _amount,

            _minGasLimit,

            _extraData

        );

    }



    /**

     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the

     *         ERC20 token on the other chain does not recognize the local token as the correct

     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on

     *         this chain.

     *

     * @param _localToken  Address of the ERC20 on this chain.

     * @param _remoteToken Address of the corresponding token on the remote chain.

     * @param _to          Address of the receiver.

     * @param _amount      Amount of local tokens to deposit.

     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.

     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will

     *                     not be triggered with this data, but it will be emitted and can be used

     *                     to identify the transaction.

     */

    function bridgeERC20To(

        address _localToken,

        address _remoteToken,

        address _to,

        uint256 _amount,

        uint32 _minGasLimit,

        bytes calldata _extraData

    ) public virtual {

        _initiateBridgeERC20(

            _localToken,

            _remoteToken,

            msg.sender,

            _to,

            _amount,

            _minGasLimit,

            _extraData

        );

    }



    /**

     * @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other

     *         StandardBridge contract on the remote chain.

     *

     * @param _from      Address of the sender.

     * @param _to        Address of the receiver.

     * @param _amount    Amount of ETH being bridged.

     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will

     *                   not be triggered with this data, but it will be emitted and can be used

     *                   to identify the transaction.

     */

    function finalizeBridgeETH(

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _extraData

    ) public payable onlyOtherBridge {

        require(msg.value == _amount, "StandardBridge: amount sent does not match amount required");

        require(_to != address(this), "StandardBridge: cannot send to self");

        require(_to != address(MESSENGER), "StandardBridge: cannot send to messenger");



        // Emit the correct events. By default this will be _amount, but child

        // contracts may override this function in order to emit legacy events as well.

        _emitETHBridgeFinalized(_from, _to, _amount, _extraData);



        bool success = SafeCall.call(_to, gasleft(), _amount, hex"");

        require(success, "StandardBridge: ETH transfer failed");

    }



    /**

     * @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other

     *         StandardBridge contract on the remote chain.

     *

     * @param _localToken  Address of the ERC20 on this chain.

     * @param _remoteToken Address of the corresponding token on the remote chain.

     * @param _from        Address of the sender.

     * @param _to          Address of the receiver.

     * @param _amount      Amount of the ERC20 being bridged.

     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will

     *                     not be triggered with this data, but it will be emitted and can be used

     *                     to identify the transaction.

     */

    function finalizeBridgeERC20(

        address _localToken,

        address _remoteToken,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _extraData

    ) public onlyOtherBridge {

        if (_isOptimismMintableERC20(_localToken)) {

            require(

                _isCorrectTokenPair(_localToken, _remoteToken),

                "StandardBridge: wrong remote token for Optimism Mintable ERC20 local token"

            );



            OptimismMintableERC20(_localToken).mint(_to, _amount);

        } else {

            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;

            IERC20(_localToken).safeTransfer(_to, _amount);

        }



        // Emit the correct events. By default this will be ERC20BridgeFinalized, but child

        // contracts may override this function in order to emit legacy events as well.

        _emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);

    }



    /**

     * @notice Initiates a bridge of ETH through the CrossDomainMessenger.

     *

     * @param _from        Address of the sender.

     * @param _to          Address of the receiver.

     * @param _amount      Amount of ETH being bridged.

     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.

     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will

     *                     not be triggered with this data, but it will be emitted and can be used

     *                     to identify the transaction.

     */

    function _initiateBridgeETH(

        address _from,

        address _to,

        uint256 _amount,

        uint32 _minGasLimit,

        bytes memory _extraData

    ) internal {

        require(

            msg.value == _amount,

            "StandardBridge: bridging ETH must include sufficient ETH value"

        );



        // Emit the correct events. By default this will be _amount, but child

        // contracts may override this function in order to emit legacy events as well.

        _emitETHBridgeInitiated(_from, _to, _amount, _extraData);



        MESSENGER.sendMessage{ value: _amount }(

            address(OTHER_BRIDGE),

            abi.encodeWithSelector(

                this.finalizeBridgeETH.selector,

                _from,

                _to,

                _amount,

                _extraData

            ),

            _minGasLimit

        );

    }



    /**

     * @notice Sends ERC20 tokens to a receiver's address on the other chain.

     *

     * @param _localToken  Address of the ERC20 on this chain.

     * @param _remoteToken Address of the corresponding token on the remote chain.

     * @param _to          Address of the receiver.

     * @param _amount      Amount of local tokens to deposit.

     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.

     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will

     *                     not be triggered with this data, but it will be emitted and can be used

     *                     to identify the transaction.

     */

    function _initiateBridgeERC20(

        address _localToken,

        address _remoteToken,

        address _from,

        address _to,

        uint256 _amount,

        uint32 _minGasLimit,

        bytes memory _extraData

    ) internal {

        if (_isOptimismMintableERC20(_localToken)) {

            require(

                _isCorrectTokenPair(_localToken, _remoteToken),

                "StandardBridge: wrong remote token for Optimism Mintable ERC20 local token"

            );



            OptimismMintableERC20(_localToken).burn(_from, _amount);

        } else {

            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);

            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;

        }



        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child

        // contracts may override this function in order to emit legacy events as well.

        _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);



        MESSENGER.sendMessage(

            address(OTHER_BRIDGE),

            abi.encodeWithSelector(

                this.finalizeBridgeERC20.selector,

                // Because this call will be executed on the remote chain, we reverse the order of

                // the remote and local token addresses relative to their order in the

                // finalizeBridgeERC20 function.

                _remoteToken,

                _localToken,

                _from,

                _to,

                _amount,

                _extraData

            ),

            _minGasLimit

        );

    }



    /**

     * @notice Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.

     *         Just the way we like it.

     *

     * @param _token Address of the token to check.

     *

     * @return True if the token is an OptimismMintableERC20.

     */

    function _isOptimismMintableERC20(address _token) internal view returns (bool) {

        return

            ERC165Checker.supportsInterface(_token, type(ILegacyMintableERC20).interfaceId) ||

            ERC165Checker.supportsInterface(_token, type(IOptimismMintableERC20).interfaceId);

    }



    /**

     * @notice Checks if the "other token" is the correct pair token for the OptimismMintableERC20.

     *         Calls can be saved in the future by combining this logic with

     *         `_isOptimismMintableERC20`.

     *

     * @param _mintableToken OptimismMintableERC20 to check against.

     * @param _otherToken    Pair token to check.

     *

     * @return True if the other token is the correct pair token for the OptimismMintableERC20.

     */

    function _isCorrectTokenPair(address _mintableToken, address _otherToken)

        internal

        view

        returns (bool)

    {

        if (

            ERC165Checker.supportsInterface(_mintableToken, type(ILegacyMintableERC20).interfaceId)

        ) {

            return _otherToken == ILegacyMintableERC20(_mintableToken).l1Token();

        } else {

            return _otherToken == IOptimismMintableERC20(_mintableToken).remoteToken();

        }

    }



    /** @notice Emits the ETHBridgeInitiated event and if necessary the appropriate legacy event

     *          when an ETH bridge is finalized on this chain.

     *

     * @param _from      Address of the sender.

     * @param _to        Address of the receiver.

     * @param _amount    Amount of ETH sent.

     * @param _extraData Extra data sent with the transaction.

     */

    function _emitETHBridgeInitiated(

        address _from,

        address _to,

        uint256 _amount,

        bytes memory _extraData

    ) internal virtual {

        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);

    }



    /**

     * @notice Emits the ETHBridgeFinalized and if necessary the appropriate legacy event when an

     *         ETH bridge is finalized on this chain.

     *

     * @param _from      Address of the sender.

     * @param _to        Address of the receiver.

     * @param _amount    Amount of ETH sent.

     * @param _extraData Extra data sent with the transaction.

     */

    function _emitETHBridgeFinalized(

        address _from,

        address _to,

        uint256 _amount,

        bytes memory _extraData

    ) internal virtual {

        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);

    }



    /**

     * @notice Emits the ERC20BridgeInitiated event and if necessary the appropriate legacy

     *         event when an ERC20 bridge is initiated to the other chain.

     *

     * @param _localToken  Address of the ERC20 on this chain.

     * @param _remoteToken Address of the ERC20 on the remote chain.

     * @param _from        Address of the sender.

     * @param _to          Address of the receiver.

     * @param _amount      Amount of the ERC20 sent.

     * @param _extraData   Extra data sent with the transaction.

     */

    function _emitERC20BridgeInitiated(

        address _localToken,

        address _remoteToken,

        address _from,

        address _to,

        uint256 _amount,

        bytes memory _extraData

    ) internal virtual {

        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);

    }



    /**

     * @notice Emits the ERC20BridgeFinalized event and if necessary the appropriate legacy

     *         event when an ERC20 bridge is initiated to the other chain.

     *

     * @param _localToken  Address of the ERC20 on this chain.

     * @param _remoteToken Address of the ERC20 on the remote chain.

     * @param _from        Address of the sender.

     * @param _to          Address of the receiver.

     * @param _amount      Amount of the ERC20 sent.

     * @param _extraData   Extra data sent with the transaction.

     */

    function _emitERC20BridgeFinalized(

        address _localToken,

        address _remoteToken,

        address _from,

        address _to,

        uint256 _amount,

        bytes memory _extraData

    ) internal virtual {

        emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Strings.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)



pragma solidity ^0.8.0;



/**

 * @dev String operations.

 */

library Strings {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    uint8 private constant _ADDRESS_LENGTH = 20;



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }



    /**

     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.

     */

    function toHexString(address addr) internal pure returns (string memory) {

        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\SystemConfig.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;



import {

    OwnableUpgradeable

} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

import { Semver } from "../universal/Semver.sol";

import { ResourceMetering } from "./ResourceMetering.sol";



/**

 * @title SystemConfig

 * @notice The SystemConfig contract is used to manage configuration of an Optimism network. All

 *         configuration is stored on L1 and picked up by L2 as part of the derviation of the L2

 *         chain.

 */

contract SystemConfig is OwnableUpgradeable, Semver {

    /**

     * @notice Enum representing different types of updates.

     *

     * @custom:value BATCHER              Represents an update to the batcher hash.

     * @custom:value GAS_CONFIG           Represents an update to txn fee config on L2.

     * @custom:value GAS_LIMIT            Represents an update to gas limit on L2.

     * @custom:value UNSAFE_BLOCK_SIGNER  Represents an update to the signer key for unsafe

     *                                    block distrubution.

     */

    enum UpdateType {

        BATCHER,

        GAS_CONFIG,

        GAS_LIMIT,

        UNSAFE_BLOCK_SIGNER

    }



    /**

     * @notice Version identifier, used for upgrades.

     */

    uint256 public constant VERSION = 0;



    /**

     * @notice Storage slot that the unsafe block signer is stored at. Storing it at this

     *         deterministic storage slot allows for decoupling the storage layout from the way

     *         that `solc` lays out storage. The `op-node` uses a storage proof to fetch this value.

     */

    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256("systemconfig.unsafeblocksigner");



    /**

     * @notice Fixed L2 gas overhead. Used as part of the L2 fee calculation.

     */

    uint256 public overhead;



    /**

     * @notice Dynamic L2 gas overhead. Used as part of the L2 fee calculation.

     */

    uint256 public scalar;



    /**

     * @notice Identifier for the batcher. For version 1 of this configuration, this is represented

     *         as an address left-padded with zeros to 32 bytes.

     */

    bytes32 public batcherHash;



    /**

     * @notice L2 block gas limit.

     */

    uint64 public gasLimit;



    /**

     * @notice The configuration for the deposit fee market. Used by the OptimismPortal

     *         to meter the cost of buying L2 gas on L1. Set as internal and wrapped with a getter

     *         so that the struct is returned instead of a tuple.

     */

    ResourceMetering.ResourceConfig internal _resourceConfig;



    /**

     * @notice Emitted when configuration is updated

     *

     * @param version    SystemConfig version.

     * @param updateType Type of update.

     * @param data       Encoded update data.

     */

    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);



    /**

     * @custom:semver 1.3.0

     *

     * @param _owner             Initial owner of the contract.

     * @param _overhead          Initial overhead value.

     * @param _scalar            Initial scalar value.

     * @param _batcherHash       Initial batcher hash.

     * @param _gasLimit          Initial gas limit.

     * @param _unsafeBlockSigner Initial unsafe block signer address.

     * @param _config            Initial resource config.

     */

    constructor(

        address _owner,

        uint256 _overhead,

        uint256 _scalar,

        bytes32 _batcherHash,

        uint64 _gasLimit,

        address _unsafeBlockSigner,

        ResourceMetering.ResourceConfig memory _config

    ) Semver(1, 3, 0) {

        initialize({

            _owner: _owner,

            _overhead: _overhead,

            _scalar: _scalar,

            _batcherHash: _batcherHash,

            _gasLimit: _gasLimit,

            _unsafeBlockSigner: _unsafeBlockSigner,

            _config: _config

        });

    }



    /**

     * @notice Initializer. The resource config must be set before the

     *         require check.

     *

     * @param _owner             Initial owner of the contract.

     * @param _overhead          Initial overhead value.

     * @param _scalar            Initial scalar value.

     * @param _batcherHash       Initial batcher hash.

     * @param _gasLimit          Initial gas limit.

     * @param _unsafeBlockSigner Initial unsafe block signer address.

     * @param _config            Initial ResourceConfig.

     */

    function initialize(

        address _owner,

        uint256 _overhead,

        uint256 _scalar,

        bytes32 _batcherHash,

        uint64 _gasLimit,

        address _unsafeBlockSigner,

        ResourceMetering.ResourceConfig memory _config

    ) public initializer {

        __Ownable_init();

        transferOwnership(_owner);

        overhead = _overhead;

        scalar = _scalar;

        batcherHash = _batcherHash;

        gasLimit = _gasLimit;

        _setUnsafeBlockSigner(_unsafeBlockSigner);

        _setResourceConfig(_config);

        require(_gasLimit >= minimumGasLimit(), "SystemConfig: gas limit too low");

    }



    /**

     * @notice Returns the minimum L2 gas limit that can be safely set for the system to

     *         operate. The L2 gas limit must be larger than or equal to the amount of

     *         gas that is allocated for deposits per block plus the amount of gas that

     *         is allocated for the system transaction.

     *         This function is used to determine if changes to parameters are safe.

     *

     * @return uint64

     */

    function minimumGasLimit() public view returns (uint64) {

        return uint64(_resourceConfig.maxResourceLimit) + uint64(_resourceConfig.systemTxMaxGas);

    }



    /**

     * @notice High level getter for the unsafe block signer address. Unsafe blocks can be

     *         propagated across the p2p network if they are signed by the key corresponding to

     *         this address.

     *

     * @return Address of the unsafe block signer.

     */

    // solhint-disable-next-line ordering

    function unsafeBlockSigner() external view returns (address) {

        address addr;

        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;

        assembly {

            addr := sload(slot)

        }

        return addr;

    }



    /**

     * @notice Updates the unsafe block signer address.

     *

     * @param _unsafeBlockSigner New unsafe block signer address.

     */

    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {

        _setUnsafeBlockSigner(_unsafeBlockSigner);



        bytes memory data = abi.encode(_unsafeBlockSigner);

        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);

    }



    /**

     * @notice Updates the batcher hash.

     *

     * @param _batcherHash New batcher hash.

     */

    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {

        batcherHash = _batcherHash;



        bytes memory data = abi.encode(_batcherHash);

        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);

    }



    /**

     * @notice Updates gas config.

     *

     * @param _overhead New overhead value.

     * @param _scalar   New scalar value.

     */

    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {

        overhead = _overhead;

        scalar = _scalar;



        bytes memory data = abi.encode(_overhead, _scalar);

        emit ConfigUpdate(VERSION, UpdateType.GAS_CONFIG, data);

    }



    /**

     * @notice Updates the L2 gas limit.

     *

     * @param _gasLimit New gas limit.

     */

    function setGasLimit(uint64 _gasLimit) external onlyOwner {

        require(_gasLimit >= minimumGasLimit(), "SystemConfig: gas limit too low");

        gasLimit = _gasLimit;



        bytes memory data = abi.encode(_gasLimit);

        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);

    }



    /**

     * @notice Low level setter for the unsafe block signer address. This function exists to

     *         deduplicate code around storing the unsafeBlockSigner address in storage.

     *

     * @param _unsafeBlockSigner New unsafeBlockSigner value.

     */

    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {

        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;

        assembly {

            sstore(slot, _unsafeBlockSigner)

        }

    }



    /**

     * @notice A getter for the resource config. Ensures that the struct is

     *         returned instead of a tuple.

     *

     * @return ResourceConfig

     */

    function resourceConfig() external view returns (ResourceMetering.ResourceConfig memory) {

        return _resourceConfig;

    }



    /**

     * @notice An external setter for the resource config. In the future, this

     *         method may emit an event that the `op-node` picks up for when the

     *         resource config is changed.

     *

     * @param _config The new resource config values.

     */

    function setResourceConfig(ResourceMetering.ResourceConfig memory _config) external onlyOwner {

        _setResourceConfig(_config);

    }



    /**

     * @notice An internal setter for the resource config. Ensures that the

     *         config is sane before storing it by checking for invariants.

     *

     * @param _config The new resource config.

     */

    function _setResourceConfig(ResourceMetering.ResourceConfig memory _config) internal {

        // Min base fee must be less than or equal to max base fee.

        require(

            _config.minimumBaseFee <= _config.maximumBaseFee,

            "SystemConfig: min base fee must be less than max base"

        );

        // Base fee change denominator must be greater than 1.

        require(

            _config.baseFeeMaxChangeDenominator > 1,

            "SystemConfig: denominator must be larger than 1"

        );

        // Max resource limit plus system tx gas must be less than or equal to the L2 gas limit.

        // The gas limit must be increased before these values can be increased.

        require(

            _config.maxResourceLimit + _config.systemTxMaxGas <= gasLimit,

            "SystemConfig: gas limit too low"

        );

        // Elasticity multiplier must be greater than 0.

        require(

            _config.elasticityMultiplier > 0,

            "SystemConfig: elasticity multiplier cannot be 0"

        );

        // No precision loss when computing target resource limit.

        require(

            ((_config.maxResourceLimit / _config.elasticityMultiplier) *

                _config.elasticityMultiplier) == _config.maxResourceLimit,

            "SystemConfig: precision loss with target resource limit"

        );



        _resourceConfig = _config;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\TeleportrDeposit.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.8.9;



import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";



/**

 * @title TeleportrDeposit

 *

 * Shout out to 0xclem for providing the inspiration for this contract:

 * https://github.com/0xclem/teleportr/blob/main/contracts/BridgeDeposit.sol

 */

contract TeleportrDeposit is Ownable {

    /// The minimum amount that be deposited in a receive.

    uint256 public minDepositAmount;

    /// The maximum amount that be deposited in a receive.

    uint256 public maxDepositAmount;

    /// The maximum balance the contract can hold after a receive.

    uint256 public maxBalance;

    /// The total number of successful deposits received.

    uint256 public totalDeposits;



    /**

     * @notice Emitted any time the minimum deposit amount is set.

     * @param previousAmount The previous minimum deposit amount.

     * @param newAmount The new minimum deposit amount.

     */

    event MinDepositAmountSet(uint256 previousAmount, uint256 newAmount);



    /**

     * @notice Emitted any time the maximum deposit amount is set.

     * @param previousAmount The previous maximum deposit amount.

     * @param newAmount The new maximum deposit amount.

     */

    event MaxDepositAmountSet(uint256 previousAmount, uint256 newAmount);



    /**

     * @notice Emitted any time the contract maximum balance is set.

     * @param previousBalance The previous maximum contract balance.

     * @param newBalance The new maximum contract balance.

     */

    event MaxBalanceSet(uint256 previousBalance, uint256 newBalance);



    /**

     * @notice Emitted any time the balance is withdrawn by the owner.

     * @param owner The current owner and recipient of the funds.

     * @param balance The current contract balance paid to the owner.

     */

    event BalanceWithdrawn(address indexed owner, uint256 balance);



    /**

     * @notice Emitted any time a successful deposit is received.

     * @param depositId A unique sequencer number identifying the deposit.

     * @param emitter The sending address of the payer.

     * @param amount The amount deposited by the payer.

     */

    event EtherReceived(uint256 indexed depositId, address indexed emitter, uint256 indexed amount);



    /**

     * @notice Initializes a new TeleportrDeposit contract.

     * @param _minDepositAmount The initial minimum deposit amount.

     * @param _maxDepositAmount The initial maximum deposit amount.

     * @param _maxBalance The initial maximum contract balance.

     */

    constructor(

        uint256 _minDepositAmount,

        uint256 _maxDepositAmount,

        uint256 _maxBalance

    ) {

        minDepositAmount = _minDepositAmount;

        maxDepositAmount = _maxDepositAmount;

        maxBalance = _maxBalance;

        totalDeposits = 0;

        emit MinDepositAmountSet(0, _minDepositAmount);

        emit MaxDepositAmountSet(0, _maxDepositAmount);

        emit MaxBalanceSet(0, _maxBalance);

    }



    /**

     * @notice Accepts deposits that will be disbursed to the sender's address on L2.

     * The method reverts if the amount is less than the current

     * minDepositAmount, the amount is greater than the current

     * maxDepositAmount, or the amount causes the contract to exceed its maximum

     * allowed balance.

     */

    receive() external payable {

        require(msg.value >= minDepositAmount, "Deposit amount is too small");

        require(msg.value <= maxDepositAmount, "Deposit amount is too big");

        require(address(this).balance <= maxBalance, "Contract max balance exceeded");



        emit EtherReceived(totalDeposits, msg.sender, msg.value);

        unchecked {

            totalDeposits += 1;

        }

    }



    /**

     * @notice Sends the contract's current balance to the owner.

     */

    function withdrawBalance() external onlyOwner {

        address _owner = owner();

        uint256 _balance = address(this).balance;

        emit BalanceWithdrawn(_owner, _balance);

        payable(_owner).transfer(_balance);

    }



    /**

     * @notice Sets the minimum amount that can be deposited in a receive.

     * @param _minDepositAmount The new minimum deposit amount.

     */

    function setMinAmount(uint256 _minDepositAmount) external onlyOwner {

        emit MinDepositAmountSet(minDepositAmount, _minDepositAmount);

        minDepositAmount = _minDepositAmount;

    }



    /**

     * @notice Sets the maximum amount that can be deposited in a receive.

     * @param _maxDepositAmount The new maximum deposit amount.

     */

    function setMaxAmount(uint256 _maxDepositAmount) external onlyOwner {

        emit MaxDepositAmountSet(maxDepositAmount, _maxDepositAmount);

        maxDepositAmount = _maxDepositAmount;

    }



    /**

     * @notice Sets the maximum balance the contract can hold after a receive.

     * @param _maxBalance The new maximum contract balance.

     */

    function setMaxBalance(uint256 _maxBalance) external onlyOwner {

        emit MaxBalanceSet(maxBalance, _maxBalance);

        maxBalance = _maxBalance;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Optimism\contracts\Types.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



/**

 * @title Types

 * @notice Contains various types used throughout the Optimism contract system.

 */

library Types {

    /**

     * @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1

     *         timestamp that the output root is posted. This timestamp is used to verify that the

     *         finalization period has passed since the output root was submitted.

     *

     * @custom:field outputRoot    Hash of the L2 output.

     * @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.

     * @custom:field l2BlockNumber L2 block number that the output corresponds to.

     */

    struct OutputProposal {

        bytes32 outputRoot;

        uint128 timestamp;

        uint128 l2BlockNumber;

    }



    /**

     * @notice Struct representing the elements that are hashed together to generate an output root

     *         which itself represents a snapshot of the L2 state.

     *

     * @custom:field version                  Version of the output root.

     * @custom:field stateRoot                Root of the state trie at the block of this output.

     * @custom:field messagePasserStorageRoot Root of the message passer storage trie.

     * @custom:field latestBlockhash          Hash of the block this output was generated from.

     */

    struct OutputRootProof {

        bytes32 version;

        bytes32 stateRoot;

        bytes32 messagePasserStorageRoot;

        bytes32 latestBlockhash;

    }



    /**

     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end

     *         user (as opposed to a system deposit transaction generated by the system).

     *

     * @custom:field from        Address of the sender of the transaction.

     * @custom:field to          Address of the recipient of the transaction.

     * @custom:field isCreation  True if the transaction is a contract creation.

     * @custom:field value       Value to send to the recipient.

     * @custom:field mint        Amount of ETH to mint.

     * @custom:field gasLimit    Gas limit of the transaction.

     * @custom:field data        Data of the transaction.

     * @custom:field l1BlockHash Hash of the block the transaction was submitted in.

     * @custom:field logIndex    Index of the log in the block the transaction was submitted in.

     */

    struct UserDepositTransaction {

        address from;

        address to;

        bool isCreation;

        uint256 value;

        uint256 mint;

        uint64 gasLimit;

        bytes data;

        bytes32 l1BlockHash;

        uint256 logIndex;

    }



    /**

     * @notice Struct representing a withdrawal transaction.

     *

     * @custom:field nonce    Nonce of the withdrawal transaction

     * @custom:field sender   Address of the sender of the transaction.

     * @custom:field target   Address of the recipient of the transaction.

     * @custom:field value    Value to send to the recipient.

     * @custom:field gasLimit Gas limit of the transaction.

     * @custom:field data     Data of the transaction.

     */

    struct WithdrawalTransaction {

        uint256 nonce;

        address sender;

        address target;

        uint256 value;

        uint256 gasLimit;

        bytes data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------

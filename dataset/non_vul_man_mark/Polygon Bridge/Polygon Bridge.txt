Folder Structure
--------------------------------------------------
contracts/
    Address.sol
    BytesLib.sol
    Common.sol
    Context.sol
    Create2.sol
    DepositManager.sol
    DepositManagerProxy.sol
    draft-IERC20Permit.sol
    ECVerify.sol
    EIP1559Burn.sol
    ERC1155.sol
    ERC1155Holder.sol
    ERC1155Predicate.sol
    ERC1155PredicateProxy.sol
    ERC1155Receiver.sol
    ERC165.sol
    ERC20.sol
    ERC20Predicate.sol
    ERC20PredicateBurnOnly.sol
    ERC20PredicateProxy.sol
    ERC721.sol
    ERC721Predicate.sol
    ERC721PredicateBurnOnly.sol
    ERC721PredicateProxy.sol
    EtherPredicate.sol
    EtherPredicateProxy.sol
    ExitNFT.sol
    ExitPayloadReader.sol
    FxBaseRootTunnel.sol
    FxERC1155RootTunnel.sol
    FxERC20RootTunnel.sol
    FxERC721RootTunnel.sol
    FxMintableERC1155RootTunnel.sol
    FxMintableERC20RootTunnel.sol
    FxMintableERC721RootTunnel.sol
    FxRoot.sol
    Governance.sol
    GovernanceProxy.sol
    IERC1155.sol
    IERC1155MetadataURI.sol
    IERC1155Receiver.sol
    IERC165.sol
    IERC20.sol
    IERC721.sol
    IERC721Metadata.sol
    IERC721Receiver.sol
    IFxERC1155.sol
    IFxERC20.sol
    IFxERC721.sol
    IRootChainManager.sol
    Merkle.sol
    MerklePatriciaProof.sol
    MintableERC1155Predicate.sol
    MintableERC1155PredicateProxy.sol
    MintableERC20Predicate.sol
    MintableERC20PredicateProxy.sol
    MintableERC721Predicate.sol
    MintableERC721PredicateProxy.sol
    PriorityQueue.sol
    Registry.sol
    RLPEncode.sol
    RLPReader.sol
    RootChain.sol
    RootChainManager.sol
    RootChainManagerProxy.sol
    RootChainProxy.sol
    SafeERC20.sol
    SafeMath.sol
    StakeManager.sol
    StakeManagerProxy.sol
    StakingInfo.sol
    StakingNFT.sol
    StateSender.sol
    Strings.sol
    ValidatorShare.sol
    ValidatorShareFactory.sol
    WithdrawManager.sol
    WithdrawManagerProxy.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\BytesLib.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



library BytesLib {

    function concat(bytes memory _preBytes, bytes memory _postBytes)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;

        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(

                0x40,

                and(

                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),

                    not(31) // Round down to the nearest 32 bytes.

                )

            )

        }

        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start, uint256 _length)

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));

        bytes memory tempBytes;

        assembly {

            switch iszero(_length)

                case 0 {

                    // Get a location of some free memory and store it in tempBytes as

                    // Solidity does for memory variables.

                    tempBytes := mload(0x40)



                    // The first word of the slice result is potentially a partial

                    // word read from the original array. To read it, we calculate

                    // the length of that partial word and start copying that many

                    // bytes into the array. The first word we copy will start with

                    // data we don't care about, but the last `lengthmod` bytes will

                    // land at the beginning of the contents of the new array. When

                    // we're done copying, we overwrite the full first word with

                    // the actual length of the slice.

                    let lengthmod := and(_length, 31)



                    // The multiplication in the next line is necessary

                    // because when slicing multiples of 32 bytes (lengthmod == 0)

                    // the following copy loop was copying the origin's length

                    // and then ending prematurely not copying everything it should.

                    let mc := add(

                        add(tempBytes, lengthmod),

                        mul(0x20, iszero(lengthmod))

                    )

                    let end := add(mc, _length)



                    for {

                        // The multiplication in the next line has the same exact purpose

                        // as the one above.

                        let cc := add(

                            add(

                                add(_bytes, lengthmod),

                                mul(0x20, iszero(lengthmod))

                            ),

                            _start

                        )

                    } lt(mc, end) {

                        mc := add(mc, 0x20)

                        cc := add(cc, 0x20)

                    } {

                        mstore(mc, mload(cc))

                    }



                    mstore(tempBytes, _length)



                    //update free-memory pointer

                    //allocating the array padded to 32 bytes like the compiler does now

                    mstore(0x40, and(add(mc, 31), not(31)))

                }

                //if we want a zero-length slice let's just return a zero-length array

                default {

                    tempBytes := mload(0x40)

                    mstore(0x40, add(tempBytes, 0x20))

                }

        }



        return tempBytes;

    }



    // Pad a bytes array to 32 bytes

    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {

        // may underflow if bytes.length < 32. Hence using SafeMath.sub

        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));

        return concat(newBytes, _bytes);

    }



    function toBytes32(bytes memory b) internal pure returns (bytes32) {

        require(b.length >= 32, "Bytes array should atleast be 32 bytes");

        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {

            out |= bytes32(b[i] & 0xFF) >> (i * 8);

        }

        return out;

    }



    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {

        assembly {

            result := mload(add(b, 32))

        }

    }



    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {

        bytes memory b = new bytes(32);

        for (uint256 i = 0; i < 32; i++) {

            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));

        }

        return b;

    }



    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {

        _ret = new bytes(32);

        assembly {

            mstore(add(_ret, 32), _num)

        }

    }



    function toUint(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (uint256)

    {

        require(_bytes.length >= (_start + 32));

        uint256 tempUint;

        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }

        return tempUint;

    }



    function toAddress(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (address)

    {

        require(_bytes.length >= (_start + 20));

        address tempAddress;

        assembly {

            tempAddress := div(

                mload(add(add(_bytes, 0x20), _start)),

                0x1000000000000000000000000

            )

        }



        return tempAddress;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\Common.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



library BytesLib {

    function concat(bytes memory _preBytes, bytes memory _postBytes)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;

        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(

                0x40,

                and(

                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),

                    not(31) // Round down to the nearest 32 bytes.

                )

            )

        }

        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start, uint256 _length)

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));

        bytes memory tempBytes;

        assembly {

            switch iszero(_length)

                case 0 {

                    // Get a location of some free memory and store it in tempBytes as

                    // Solidity does for memory variables.

                    tempBytes := mload(0x40)



                    // The first word of the slice result is potentially a partial

                    // word read from the original array. To read it, we calculate

                    // the length of that partial word and start copying that many

                    // bytes into the array. The first word we copy will start with

                    // data we don't care about, but the last `lengthmod` bytes will

                    // land at the beginning of the contents of the new array. When

                    // we're done copying, we overwrite the full first word with

                    // the actual length of the slice.

                    let lengthmod := and(_length, 31)



                    // The multiplication in the next line is necessary

                    // because when slicing multiples of 32 bytes (lengthmod == 0)

                    // the following copy loop was copying the origin's length

                    // and then ending prematurely not copying everything it should.

                    let mc := add(

                        add(tempBytes, lengthmod),

                        mul(0x20, iszero(lengthmod))

                    )

                    let end := add(mc, _length)



                    for {

                        // The multiplication in the next line has the same exact purpose

                        // as the one above.

                        let cc := add(

                            add(

                                add(_bytes, lengthmod),

                                mul(0x20, iszero(lengthmod))

                            ),

                            _start

                        )

                    } lt(mc, end) {

                        mc := add(mc, 0x20)

                        cc := add(cc, 0x20)

                    } {

                        mstore(mc, mload(cc))

                    }



                    mstore(tempBytes, _length)



                    //update free-memory pointer

                    //allocating the array padded to 32 bytes like the compiler does now

                    mstore(0x40, and(add(mc, 31), not(31)))

                }

                //if we want a zero-length slice let's just return a zero-length array

                default {

                    tempBytes := mload(0x40)

                    mstore(0x40, add(tempBytes, 0x20))

                }

        }



        return tempBytes;

    }



    // Pad a bytes array to 32 bytes

    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {

        // may underflow if bytes.length < 32. Hence using SafeMath.sub

        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));

        return concat(newBytes, _bytes);

    }



    function toBytes32(bytes memory b) internal pure returns (bytes32) {

        require(b.length >= 32, "Bytes array should atleast be 32 bytes");

        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {

            out |= bytes32(b[i] & 0xFF) >> (i * 8);

        }

        return out;

    }



    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {

        assembly {

            result := mload(add(b, 32))

        }

    }



    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {

        bytes memory b = new bytes(32);

        for (uint256 i = 0; i < 32; i++) {

            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));

        }

        return b;

    }



    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {

        _ret = new bytes(32);

        assembly {

            mstore(add(_ret, 32), _num)

        }

    }



    function toUint(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (uint256)

    {

        require(_bytes.length >= (_start + 32));

        uint256 tempUint;

        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }

        return tempUint;

    }



    function toAddress(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (address)

    {

        require(_bytes.length >= (_start + 20));

        address tempAddress;

        assembly {

            tempAddress := div(

                mload(add(add(_bytes, 0x20), _start)),

                0x1000000000000000000000000

            )

        }



        return tempAddress;

    }

}



library Common {

    function getV(bytes memory v, uint16 chainId) public pure returns (uint8) {

        if (chainId > 0) {

            return

                uint8(

                    BytesLib.toUint(BytesLib.leftPad(v), 0) - (chainId * 2) - 8

                );

        } else {

            return uint8(BytesLib.toUint(BytesLib.leftPad(v), 0));

        }

    }



    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.

    function isContract(address _addr) public view returns (bool) {

        uint256 length;

        assembly {

            //retrieve the size of the code on target address, this needs assembly

            length := extcodesize(_addr)

        }

        return (length > 0);

    }



    // convert bytes to uint8

    function toUint8(bytes memory _arg) public pure returns (uint8) {

        return uint8(_arg[0]);

    }



    function toUint16(bytes memory _arg) public pure returns (uint16) {

        return (uint16(uint8(_arg[0])) << 8) | uint16(uint8(_arg[1]));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\Create2.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



// Create2 adds common methods for minimal proxy with create2

abstract contract Create2 {

    // creates clone using minimal proxy

    function createClone(bytes32 _salt, address _target) internal returns (address _result) {

        bytes20 _targetBytes = bytes20(_target);



        assembly {

            let clone := mload(0x40)

            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)

            mstore(add(clone, 0x14), _targetBytes)

            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)

            _result := create2(0, clone, 0x37, _salt)

        }



        require(_result != address(0), "Create2: Failed on minimal deploy");

    }



    // get minimal proxy creation code

    function minimalProxyCreationCode(address logic) internal pure returns (bytes memory) {

        bytes10 creation = 0x3d602d80600a3d3981f3;

        bytes10 prefix = 0x363d3d373d3d3d363d73;

        bytes20 targetBytes = bytes20(logic);

        bytes15 suffix = 0x5af43d82803e903d91602b57fd5bf3;

        return abi.encodePacked(creation, prefix, targetBytes, suffix);

    }



    // get computed create2 address

    function computedCreate2Address(

        bytes32 salt,

        bytes32 bytecodeHash,

        address deployer

    ) public pure returns (address) {

        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));

        return address(uint160(uint256(_data)));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\DepositManager.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-09-17

*/



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol



pragma solidity ^0.5.2;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract IERC721Receiver {

    /**

     * @notice Handle the receipt of an NFT

     * @dev The ERC721 smart contract calls this function on the recipient

     * after a `safeTransfer`. This function MUST return the function selector,

     * otherwise the caller will revert the transaction. The selector to be

     * returned can be obtained as `this.onERC721Received.selector`. This

     * function MAY throw to revert and reject the transfer.

     * Note: the ERC721 contract address is always the message sender.

     * @param operator The address which called `safeTransferFrom` function

     * @param from The address which previously owned the token

     * @param tokenId The NFT identifier which is being transferred

     * @param data Additional data with no specified format

     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)

    public returns (bytes4);

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Holder.sol



pragma solidity ^0.5.2;





contract ERC721Holder is IERC721Receiver {

    function onERC721Received(address, address, uint256, bytes memory) public returns (bytes4) {

        return this.onERC721Received.selector;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.2;



/**

 * @title ERC20 interface

 * @dev see https://eips.ethereum.org/EIPS/eip-20

 */

interface IERC20 {

    function transfer(address to, uint256 value) external returns (bool);



    function approve(address spender, uint256 value) external returns (bool);



    function transferFrom(address from, address to, uint256 value) external returns (bool);



    function totalSupply() external view returns (uint256);



    function balanceOf(address who) external view returns (uint256);



    function allowance(address owner, address spender) external view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: openzeppelin-solidity/contracts/introspection/IERC165.sol



pragma solidity ^0.5.2;



/**

 * @title IERC165

 * @dev https://eips.ethereum.org/EIPS/eip-165

 */

interface IERC165 {

    /**

     * @notice Query if a contract implements an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @dev Interface identification is specified in ERC-165. This function

     * uses less than 30,000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol



pragma solidity ^0.5.2;





/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    function balanceOf(address owner) public view returns (uint256 balance);

    function ownerOf(uint256 tokenId) public view returns (address owner);



    function approve(address to, uint256 tokenId) public;

    function getApproved(uint256 tokenId) public view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) public;

    function isApprovedForAll(address owner, address operator) public view returns (bool);



    function transferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId) public;



    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: openzeppelin-solidity/contracts/utils/Address.sol



pragma solidity ^0.5.2;



/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol



pragma solidity ^0.5.2;









/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        require((value == 0) || (token.allowance(address(this), spender) == 0));

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must equal true).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves.



        // A Solidity high level call has three parts:

        //  1. The target address is checked to verify it contains contract code

        //  2. The call itself is made, and success asserted

        //  3. The return value is decoded, which in turn checks the size of the returned data.



        require(address(token).isContract());



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success);



        if (returndata.length > 0) { // Return data is optional

            require(abi.decode(returndata, (bool)));

        }

    }

}



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        _assertGovernance();

        _;

    }



    function _assertGovernance() private view {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;









contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.5.2;







/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * https://eips.ethereum.org/EIPS/eip-20

 * Originally based on code by FirstBlood:

 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 *

 * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for

 * all accounts just by listening to said events. Note that this isn't required by the specification, and other

 * compliant implementations may not do it.

 */

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowed;



    uint256 private _totalSupply;



    /**

     * @dev Total number of tokens in existence

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev Gets the balance of the specified address.

     * @param owner The address to query the balance of.

     * @return A uint256 representing the amount owned by the passed address.

     */

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    /**

     * @dev Function to check the amount of tokens that an owner allowed to a spender.

     * @param owner address The address which owns the funds.

     * @param spender address The address which will spend the funds.

     * @return A uint256 specifying the amount of tokens still available for the spender.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    /**

     * @dev Transfer token to a specified address

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    /**

     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param spender The address which will spend the funds.

     * @param value The amount of tokens to be spent.

     */

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    /**

     * @dev Transfer tokens from one address to another.

     * Note that while this function emits an Approval event, this is not required as per the specification,

     * and other compliant implementations may not emit the event.

     * @param from address The address which you want to send tokens from

     * @param to address The address which you want to transfer to

     * @param value uint256 the amount of tokens to be transferred

     */

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _transfer(from, to, value);

        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));

        return true;

    }



    /**

     * @dev Increase the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To increment

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param addedValue The amount of tokens to increase the allowance by.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Decrease the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param subtractedValue The amount of tokens to decrease the allowance by.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    /**

     * @dev Transfer token for a specified addresses

     * @param from The address to transfer from.

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    /**

     * @dev Internal function that mints an amount of the token and assigns it to

     * an account. This encapsulates the modification of balances such that the

     * proper events are emitted.

     * @param account The account that will receive the created tokens.

     * @param value The amount that will be created.

     */

    function _mint(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account.

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burn(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    /**

     * @dev Approve an address to spend another addresses' tokens.

     * @param owner The address that owns the tokens.

     * @param spender The address that will spend the tokens.

     * @param value The number of tokens that can be spent.

     */

    function _approve(address owner, address spender, uint256 value) internal {

        require(spender != address(0));

        require(owner != address(0));



        _allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account, deducting from the sender's allowance for said account. Uses the

     * internal burn function.

     * Emits an Approval event (reflecting the reduced allowance).

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burnFrom(address account, uint256 value) internal {

        _burn(account, value);

        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));

    }

}



// File: contracts/common/tokens/WETH.sol



pragma solidity ^0.5.2;





contract WETH is ERC20 {

    event Deposit(address indexed dst, uint256 wad);

    event Withdrawal(address indexed src, uint256 wad);



    function deposit() public payable;



    function withdraw(uint256 wad) public;



    function withdraw(uint256 wad, address user) public;

}



// File: contracts/root/depositManager/IDepositManager.sol



pragma solidity ^0.5.2;



interface IDepositManager {

    function depositEther() external payable;

    function transferAssets(

        address _token,

        address _user,

        uint256 _amountOrNFTId

    ) external;

    function depositERC20(address _token, uint256 _amount) external;

    function depositERC721(address _token, uint256 _tokenId) external;

}



// File: solidity-rlp/contracts/RLPReader.sol



/*

* @author Hamdi Allam hamdi.allam97@gmail.com

* Please reach out with any questions or concerns

*/

pragma solidity ^0.5.0;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param item RLP encoded bytes

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        return item.len - _payloadOffset(item.memPtr);

    }



    /*

    * @param item RLP encoded list in bytes

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        return result == 0 ? false : true;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset;



        uint result;

        uint memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/misc/ProxyStorage.sol



pragma solidity ^0.5.2;





contract ProxyStorage is Ownable {

    address internal proxyTo;

}



// File: contracts/common/mixin/ChainIdMixin.sol



pragma solidity ^0.5.2;



contract ChainIdMixin {

  bytes constant public networkId = hex"3A99";

  uint256 constant public CHAINID = 15001;

}



// File: contracts/root/RootChainStorage.sol



pragma solidity ^0.5.2;











contract RootChainHeader {

    event NewHeaderBlock(

        address indexed proposer,

        uint256 indexed headerBlockId,

        uint256 indexed reward,

        uint256 start,

        uint256 end,

        bytes32 root

    );

    // housekeeping event

    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }

}





contract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {

    bytes32 public heimdallId;

    uint8 public constant VOTE_TYPE = 2;



    uint16 internal constant MAX_DEPOSITS = 10000;

    uint256 public _nextHeaderBlock = MAX_DEPOSITS;

    uint256 internal _blockDepositId = 1;

    mapping(uint256 => HeaderBlock) public headerBlocks;

    Registry internal registry;

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity 0.5.17;



contract IStakeManager {

    // validator replacement

    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        uint[3][] calldata sigs

    ) external returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes calldata slashingInfoList) external returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function getRegistry() public view returns (address);



    function withdrawalDelay() public view returns (uint256);



    function delegatedAmount(uint256 validatorId) public view returns(uint256);



    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;



    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);



    function delegatorsReward(uint256 validatorId) public view returns(uint256);



    function dethroneAndStake(

        address auctionUser,

        uint256 heimdallFee,

        uint256 validatorId,

        uint256 auctionAmount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;

}



// File: contracts/root/IRootChain.sol



pragma solidity ^0.5.2;





interface IRootChain {

    function slash() external;



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)

        external;

    

    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs)

        external;



    function getLastChildBlock() external view returns (uint256);



    function currentHeaderBlock() external view returns (uint256);

}



// File: contracts/root/RootChain.sol



pragma solidity ^0.5.2;

















contract RootChain is RootChainStorage, IRootChain {

    using SafeMath for uint256;

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    modifier onlyDepositManager() {

        require(msg.sender == registry.getDepositManagerAddress(), "UNAUTHORIZED_DEPOSIT_MANAGER_ONLY");

        _;

    }



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {

        revert();

    }



    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs) external {

        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi

            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));

        require(CHAINID == _borChainID, "Invalid bor chain id");



        require(_buildHeaderBlock(proposer, start, end, rootHash), "INCORRECT_HEADER_DATA");



        // check if it is better to keep it in local storage instead

        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());

        uint256 _reward = stakeManager.checkSignatures(

            end.sub(start).add(1),

            /**  

                prefix 01 to data 

                01 represents positive vote on data and 00 is negative vote

                malicious validator can try to send 2/3 on negative vote so 01 is appended

             */

            keccak256(abi.encodePacked(bytes(hex"01"), data)),

            accountHash,

            proposer,

            sigs

        );



        require(_reward != 0, "Invalid checkpoint");

        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);

        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);

        _blockDepositId = 1;

    }



    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {

        depositId = currentHeaderBlock().add(_blockDepositId);

        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)

        _blockDepositId = _blockDepositId.add(numDeposits);

        require(

            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed

            _blockDepositId <= MAX_DEPOSITS,

            "TOO_MANY_DEPOSITS"

        );

    }



    function getLastChildBlock() external view returns (uint256) {

        return headerBlocks[currentHeaderBlock()].end;

    }



    function slash() external {

        //TODO: future implementation

    }



    function currentHeaderBlock() public view returns (uint256) {

        return _nextHeaderBlock.sub(MAX_DEPOSITS);

    }



    function _buildHeaderBlock(

        address proposer,

        uint256 start,

        uint256 end,

        bytes32 rootHash

    ) private returns (bool) {

        uint256 nextChildBlock;

        /*

    The ID of the 1st header block is MAX_DEPOSITS.

    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0

    */

        if (_nextHeaderBlock > MAX_DEPOSITS) {

            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;

        }

        if (nextChildBlock != start) {

            return false;

        }



        HeaderBlock memory headerBlock = HeaderBlock({

            root: rootHash,

            start: nextChildBlock,

            end: end,

            createdAt: now,

            proposer: proposer

        });



        headerBlocks[_nextHeaderBlock] = headerBlock;

        return true;

    }



    // Housekeeping function. @todo remove later

    function setNextHeaderBlock(uint256 _value) public onlyOwner {

        require(_value % MAX_DEPOSITS == 0, "Invalid value");

        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {

            delete headerBlocks[i];

        }

        _nextHeaderBlock = _value;

        _blockDepositId = 1;

        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);

    }



    // Housekeeping function. @todo remove later

    function setHeimdallId(string memory _heimdallId) public onlyOwner {

        heimdallId = keccak256(abi.encodePacked(_heimdallId));

    }

}



// File: contracts/root/stateSyncer/StateSender.sol



pragma solidity ^0.5.2;







contract StateSender is Ownable {

    using SafeMath for uint256;



    uint256 public counter;

    mapping(address => address) public registrations;



    event NewRegistration(

        address indexed user,

        address indexed sender,

        address indexed receiver

    );

    event RegistrationUpdated(

        address indexed user,

        address indexed sender,

        address indexed receiver

    );

    event StateSynced(

        uint256 indexed id,

        address indexed contractAddress,

        bytes data

    );



    modifier onlyRegistered(address receiver) {

        require(registrations[receiver] == msg.sender, "Invalid sender");

        _;

    }



    function syncState(address receiver, bytes calldata data)

        external

        onlyRegistered(receiver)

    {

        counter = counter.add(1);

        emit StateSynced(counter, receiver, data);

    }



    // register new contract for state sync

    function register(address sender, address receiver) public {

        require(

            isOwner() || registrations[receiver] == msg.sender,

            "StateSender.register: Not authorized to register"

        );

        registrations[receiver] = sender;

        if (registrations[receiver] == address(0)) {

            emit NewRegistration(msg.sender, sender, receiver);

        } else {

            emit RegistrationUpdated(msg.sender, sender, receiver);

        }

    }

}



// File: contracts/common/mixin/Lockable.sol



pragma solidity ^0.5.2;



contract Lockable {

    bool public locked;



    modifier onlyWhenUnlocked() {

        _assertUnlocked();

        _;

    }



    function _assertUnlocked() private view {

        require(!locked, "locked");

    }



    function lock() public {

        locked = true;

    }



    function unlock() public {

        locked = false;

    }

}



// File: contracts/common/mixin/GovernanceLockable.sol



pragma solidity ^0.5.2;







contract GovernanceLockable is Lockable, Governable {

    constructor(address governance) public Governable(governance) {}



    function lock() public onlyGovernance {

        super.lock();

    }



    function unlock() public onlyGovernance {

        super.unlock();

    }

}



// File: contracts/root/depositManager/DepositManagerStorage.sol



pragma solidity ^0.5.2;















contract DepositManagerHeader {

    event NewDepositBlock(address indexed owner, address indexed token, uint256 amountOrNFTId, uint256 depositBlockId);

    event MaxErc20DepositUpdate(uint256 indexed oldLimit, uint256 indexed newLimit);



    struct DepositBlock {

        bytes32 depositHash;

        uint256 createdAt;

    }

}





contract DepositManagerStorage is ProxyStorage, GovernanceLockable, DepositManagerHeader {

    Registry public registry;

    RootChain public rootChain;

    StateSender public stateSender;



    mapping(uint256 => DepositBlock) public deposits;



    address public childChain;

    uint256 public maxErc20Deposit = 100 * (10**18);

}



// File: contracts/root/depositManager/DepositManager.sol



pragma solidity ^0.5.2;





























contract DepositManager is DepositManagerStorage, IDepositManager, ERC721Holder {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    modifier isTokenMapped(address _token) {

        require(registry.isTokenMapped(_token), "TOKEN_NOT_SUPPORTED");

        _;

    }



    modifier isPredicateAuthorized() {

        require(uint8(registry.predicates(msg.sender)) != 0, "Not a valid predicate");

        _;

    }



    constructor() public GovernanceLockable(address(0x0)) {}



    // deposit ETH by sending to this contract

    function() external payable {

        depositEther();

    }



    function updateMaxErc20Deposit(uint256 maxDepositAmount) public onlyGovernance {

        require(maxDepositAmount != 0);

        emit MaxErc20DepositUpdate(maxErc20Deposit, maxDepositAmount);

        maxErc20Deposit = maxDepositAmount;

    }



    function transferAssets(

        address _token,

        address _user,

        uint256 _amountOrNFTId

    ) external isPredicateAuthorized {

        address wethToken = registry.getWethTokenAddress();

        if (registry.isERC721(_token)) {

            IERC721(_token).transferFrom(address(this), _user, _amountOrNFTId);

        } else if (_token == wethToken) {

            WETH t = WETH(_token);

            t.withdraw(_amountOrNFTId, _user);

        } else {

            require(IERC20(_token).transfer(_user, _amountOrNFTId), "TRANSFER_FAILED");

        }

    }



    function depositERC20(address _token, uint256 _amount) external {

        depositERC20ForUser(_token, msg.sender, _amount);

    }



    function depositERC721(address _token, uint256 _tokenId) external {

        depositERC721ForUser(_token, msg.sender, _tokenId);

    }



    function depositBulk(

        address[] calldata _tokens,

        uint256[] calldata _amountOrTokens,

        address _user

    )

        external

        onlyWhenUnlocked // unlike other deposit functions, depositBulk doesn't invoke _safeCreateDepositBlock

    {

        require(_tokens.length == _amountOrTokens.length, "Invalid Input");

        uint256 depositId = rootChain.updateDepositId(_tokens.length);

        Registry _registry = registry;



        for (uint256 i = 0; i < _tokens.length; i++) {

            // will revert if token is not mapped

            if (_registry.isTokenMappedAndIsErc721(_tokens[i])) {

                _safeTransferERC721(msg.sender, _tokens[i], _amountOrTokens[i]);

            } else {

                IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amountOrTokens[i]);

            }



            _createDepositBlock(_user, _tokens[i], _amountOrTokens[i], depositId);

            depositId = depositId.add(1);

        }

    }



    /**

     * @dev Caches childChain and stateSender (frequently used variables) from registry

     */

    function updateChildChainAndStateSender() public {

        (address _childChain, address _stateSender) = registry.getChildChainAndStateSender();

        require(

            _stateSender != address(stateSender) || _childChain != childChain,

            "Atleast one of stateSender or childChain address should change"

        );

        childChain = _childChain;

        stateSender = StateSender(_stateSender);

    }



    function depositERC20ForUser(

        address _token,

        address _user,

        uint256 _amount

    ) public {

        require(_amount <= maxErc20Deposit, "exceed maximum deposit amount");

        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        _safeCreateDepositBlock(_user, _token, _amount);

    }



    function depositERC721ForUser(

        address _token,

        address _user,

        uint256 _tokenId

    ) public {

        require(registry.isTokenMappedAndIsErc721(_token), "not erc721");



        _safeTransferERC721(msg.sender, _token, _tokenId);

        _safeCreateDepositBlock(_user, _token, _tokenId);

    }



    // @todo: write depositEtherForUser

    function depositEther() public payable {

        address wethToken = registry.getWethTokenAddress();

        WETH t = WETH(wethToken);

        t.deposit.value(msg.value)();

        _safeCreateDepositBlock(msg.sender, wethToken, msg.value);

    }



    function _safeCreateDepositBlock(

        address _user,

        address _token,

        uint256 _amountOrToken

    ) internal onlyWhenUnlocked isTokenMapped(_token) {

        _createDepositBlock(

            _user,

            _token,

            _amountOrToken,

            rootChain.updateDepositId(1) /* returns _depositId */

        );

    }



    function _createDepositBlock(

        address _user,

        address _token,

        uint256 _amountOrToken,

        uint256 _depositId

    ) internal {

        deposits[_depositId] = DepositBlock(keccak256(abi.encodePacked(_user, _token, _amountOrToken)), now);

        stateSender.syncState(childChain, abi.encode(_user, _token, _amountOrToken, _depositId));

        emit NewDepositBlock(_user, _token, _amountOrToken, _depositId);

    }



    // Housekeeping function. @todo remove later

    function updateRootChain(address _rootChain) public onlyOwner {

        rootChain = RootChain(_rootChain);

    }



    function _safeTransferERC721(address _user, address _token, uint256 _tokenId) private {

        IERC721(_token).safeTransferFrom(_user, address(this), _tokenId);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\DepositManagerProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-31

*/



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

        _;

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;









contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: solidity-rlp/contracts/RLPReader.sol



/*

* @author Hamdi Allam hamdi.allam97@gmail.com

* Please reach out with any questions or concerns

*/

pragma solidity ^0.5.0;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param item RLP encoded bytes

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        return item.len - _payloadOffset(item.memPtr);

    }



    /*

    * @param item RLP encoded list in bytes

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        return result == 0 ? false : true;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset;



        uint result;

        uint memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/misc/ProxyStorage.sol



pragma solidity ^0.5.2;





contract ProxyStorage is Ownable {

    address internal proxyTo;

}



// File: contracts/common/mixin/ChainIdMixin.sol



pragma solidity ^0.5.2;



contract ChainIdMixin {

  bytes constant public networkId = hex"89";

  uint256 constant public CHAINID = 137;

}



// File: contracts/root/RootChainStorage.sol



pragma solidity ^0.5.2;











contract RootChainHeader {

    event NewHeaderBlock(

        address indexed proposer,

        uint256 indexed headerBlockId,

        uint256 indexed reward,

        uint256 start,

        uint256 end,

        bytes32 root

    );

    // housekeeping event

    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }

}





contract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {

    bytes32 public heimdallId;

    uint8 public constant VOTE_TYPE = 2;



    uint16 internal constant MAX_DEPOSITS = 10000;

    uint256 public _nextHeaderBlock = MAX_DEPOSITS;

    uint256 internal _blockDepositId = 1;

    mapping(uint256 => HeaderBlock) public headerBlocks;

    Registry internal registry;

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity ^0.5.2;





contract IStakeManager {

    // validator replacement

    function startAuction(uint256 validatorId, uint256 amount) external;



    function confirmAuctionBid(

        uint256 validatorId,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function stake(

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function supportsHistory() external pure returns (bool);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        bytes memory sigs

    ) public returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes memory slashingInfoList) public returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function withdrawalDelay() public view returns (uint256);

}



// File: contracts/root/IRootChain.sol



pragma solidity ^0.5.2;





interface IRootChain {

    function slash() external;



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)

        external;



    function getLastChildBlock() external view returns (uint256);



    function currentHeaderBlock() external view returns (uint256);

}



// File: contracts/root/RootChain.sol



pragma solidity ^0.5.2;

















contract RootChain is RootChainStorage, IRootChain {

    using SafeMath for uint256;

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    modifier onlyDepositManager() {

        require(msg.sender == registry.getDepositManagerAddress(), "UNAUTHORIZED_DEPOSIT_MANAGER_ONLY");

        _;

    }



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {

        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi

            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));

        require(CHAINID == _borChainID, "Invalid bor chain id");



        require(_buildHeaderBlock(proposer, start, end, rootHash), "INCORRECT_HEADER_DATA");



        // check if it is better to keep it in local storage instead

        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());

        uint256 _reward = stakeManager.checkSignatures(

            end.sub(start).add(1),

            /**  

                prefix 01 to data 

                01 represents positive vote on data and 00 is negative vote

                malicious validator can try to send 2/3 on negative vote so 01 is appended

             */

            keccak256(abi.encodePacked(bytes(hex"01"), data)),

            accountHash,

            proposer,

            sigs

        );



        require(_reward != 0, "Invalid checkpoint");

        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);

        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);

        _blockDepositId = 1;

    }



    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {

        depositId = currentHeaderBlock().add(_blockDepositId);

        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)

        _blockDepositId = _blockDepositId.add(numDeposits);

        require(

            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed

            _blockDepositId <= MAX_DEPOSITS,

            "TOO_MANY_DEPOSITS"

        );

    }



    function getLastChildBlock() external view returns (uint256) {

        return headerBlocks[currentHeaderBlock()].end;

    }



    function slash() external {

        //TODO: future implementation

    }



    function currentHeaderBlock() public view returns (uint256) {

        return _nextHeaderBlock.sub(MAX_DEPOSITS);

    }



    function _buildHeaderBlock(

        address proposer,

        uint256 start,

        uint256 end,

        bytes32 rootHash

    ) private returns (bool) {

        uint256 nextChildBlock;

        /*

    The ID of the 1st header block is MAX_DEPOSITS.

    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0

    */

        if (_nextHeaderBlock > MAX_DEPOSITS) {

            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;

        }

        if (nextChildBlock != start) {

            return false;

        }



        HeaderBlock memory headerBlock = HeaderBlock({

            root: rootHash,

            start: nextChildBlock,

            end: end,

            createdAt: now,

            proposer: proposer

        });



        headerBlocks[_nextHeaderBlock] = headerBlock;

        return true;

    }



    // Housekeeping function. @todo remove later

    function setNextHeaderBlock(uint256 _value) public onlyOwner {

        require(_value % MAX_DEPOSITS == 0, "Invalid value");

        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {

            delete headerBlocks[i];

        }

        _nextHeaderBlock = _value;

        _blockDepositId = 1;

        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);

    }



    // Housekeeping function. @todo remove later

    function setHeimdallId(string memory _heimdallId) public onlyOwner {

        heimdallId = keccak256(abi.encodePacked(_heimdallId));

    }

}



// File: contracts/root/stateSyncer/StateSender.sol



pragma solidity ^0.5.2;







contract StateSender is Ownable {

    using SafeMath for uint256;



    uint256 public counter;

    mapping(address => address) public registrations;



    event NewRegistration(

        address indexed user,

        address indexed sender,

        address indexed receiver

    );

    event RegistrationUpdated(

        address indexed user,

        address indexed sender,

        address indexed receiver

    );

    event StateSynced(

        uint256 indexed id,

        address indexed contractAddress,

        bytes data

    );



    modifier onlyRegistered(address receiver) {

        require(registrations[receiver] == msg.sender, "Invalid sender");

        _;

    }



    function syncState(address receiver, bytes calldata data)

        external

        onlyRegistered(receiver)

    {

        counter = counter.add(1);

        emit StateSynced(counter, receiver, data);

    }



    // register new contract for state sync

    function register(address sender, address receiver) public {

        require(

            isOwner() || registrations[receiver] == msg.sender,

            "StateSender.register: Not authorized to register"

        );

        registrations[receiver] = sender;

        if (registrations[receiver] == address(0)) {

            emit NewRegistration(msg.sender, sender, receiver);

        } else {

            emit RegistrationUpdated(msg.sender, sender, receiver);

        }

    }

}



// File: contracts/common/mixin/Lockable.sol



pragma solidity ^0.5.2;





contract Lockable is Governable {

    bool public locked;



    modifier onlyWhenUnlocked() {

        require(!locked, "Is Locked");

        _;

    }



    constructor(address _governance) public Governable(_governance) {}



    function lock() external onlyGovernance {

        locked = true;

    }



    function unlock() external onlyGovernance {

        locked = false;

    }

}



// File: contracts/root/depositManager/DepositManagerStorage.sol



pragma solidity ^0.5.2;















contract DepositManagerHeader {

    event NewDepositBlock(address indexed owner, address indexed token, uint256 amountOrNFTId, uint256 depositBlockId);

    event MaxErc20DepositUpdate(uint256 indexed oldLimit, uint256 indexed newLimit);



    struct DepositBlock {

        bytes32 depositHash;

        uint256 createdAt;

    }

}





contract DepositManagerStorage is ProxyStorage, Lockable, DepositManagerHeader {

    Registry public registry;

    RootChain public rootChain;

    StateSender public stateSender;



    mapping(uint256 => DepositBlock) public deposits;



    address public childChain;

    uint256 public maxErc20Deposit = 100 * (10**18);

}



// File: contracts/common/misc/ERCProxy.sol



/*

 * SPDX-License-Identitifer:    MIT

 */



pragma solidity ^0.5.2;



// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md



interface ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);

    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/misc/DelegateProxy.sol



pragma solidity ^0.5.2;







contract DelegateProxy is ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external view returns (address);



    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas, 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }

}



// File: contracts/common/misc/Proxy.sol



pragma solidity ^0.5.2;









contract Proxy is ProxyStorage, DelegateProxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event OwnerUpdate(address _prevOwner, address _newOwner);



    constructor(address _proxyTo) public {

        updateImplementation(_proxyTo);

    }



    function() external payable {

        // require(currentContract != 0, "If app code has not been set yet, do not call");

        // Todo: filter out some calls or handle in the end fallback

        delegatedFwd(proxyTo, msg.data);

    }



    function implementation() external view returns (address) {

        return proxyTo;

    }



    function updateImplementation(address _newProxyTo) public onlyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");

        emit ProxyUpdated(_newProxyTo, proxyTo);

        proxyTo = _newProxyTo;

    }



    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/depositManager/DepositManagerProxy.sol



pragma solidity ^0.5.2;













contract DepositManagerProxy is Proxy, DepositManagerStorage {

    constructor(

        address _proxyTo,

        address _registry,

        address _rootChain,

        address _governance

    ) public Proxy(_proxyTo) Lockable(_governance) {

        registry = Registry(_registry);

        rootChain = RootChain(_rootChain);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\draft-IERC20Permit.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in

 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].

 *

 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by

 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't

 * need to send a transaction, and thus is not required to hold Ether at all.

 */

interface IERC20Permit {

    /**

     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,

     * given ``owner``'s signed approval.

     *

     * IMPORTANT: The same issues {IERC20-approve} has related to transaction

     * ordering also apply here.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `deadline` must be a timestamp in the future.

     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`

     * over the EIP712-formatted function arguments.

     * - the signature must use ``owner``'s current nonce (see {nonces}).

     *

     * For more information on the signature format, see the

     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP

     * section].

     */

    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external;



    /**

     * @dev Returns the current nonce for `owner`. This value must be

     * included whenever a signature is generated for {permit}.

     *

     * Every successful call to {permit} increases ``owner``'s nonce by one. This

     * prevents a signature from being used multiple times.

     */

    function nonces(address owner) external view returns (uint256);



    /**

     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.

     */

    // solhint-disable-next-line func-name-mixedcase

    function DOMAIN_SEPARATOR() external view returns (bytes32);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ECVerify.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





library ECVerify {

    function ecrecovery(bytes32 hash, bytes memory sig)

        public

        pure

        returns (address)

    {

        bytes32 r;

        bytes32 s;

        uint8 v;



        if (sig.length != 65) {

            return address(0x0);

        }



        assembly {

            r := mload(add(sig, 32))

            s := mload(add(sig, 64))

            v := and(mload(add(sig, 65)), 255)

        }



        // https://github.com/ethereum/go-ethereum/issues/2053

        if (v < 27) {

            v += 27;

        }



        if (v != 27 && v != 28) {

            return address(0x0);

        }



        // get address out of hash and signature

        address result = ecrecover(hash, v, r, s);



        // ecrecover returns zero on error

        require(result != address(0x0));



        return result;

    }



    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)

        public

        pure

        returns (address)

    {

        // get address out of hash and signature

        address result = ecrecover(hash, v, r, s);



        // ecrecover returns zero on error

        require(result != address(0x0), "signature verification failed");



        return result;

    }



    function ecverify(bytes32 hash, bytes memory sig, address signer)

        public

        pure

        returns (bool)

    {

        return signer == ecrecovery(hash, sig);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\EIP1559Burn.sol
File type: .sol
//SPDX-License-Identifier: Apache-2.0

pragma solidity ^0.8.9;



interface IERC20 {

    function withdraw(uint256 amount) external payable;

    function transfer(address to, uint256 value) external returns (bool);

    function balanceOf(address who) external view returns (uint256);

}



interface IERC20Predicate {

    function startExitWithBurntTokens(bytes calldata data) external;

}



interface IWithdrawManager {

    function processExits(address _token) external;

}



contract EIP1559Burn {

    IERC20 public immutable maticRootToken;

    IERC20 public immutable maticChildToken = IERC20(0x0000000000000000000000000000000000001010);

    IWithdrawManager public immutable withdrawManager;

    uint24 public immutable rootChainId;

    uint24 public immutable childChainId;



    constructor(

        IERC20 _maticRootToken,

        IWithdrawManager _withdrawManager,

        uint24 _rootChainId,

        uint24 _childChainId

        ) {

        maticRootToken = _maticRootToken;

        withdrawManager = _withdrawManager;

        rootChainId = _rootChainId;

        childChainId = _childChainId;

    }



    modifier onlyRootChain() {

        require(block.chainid == rootChainId, "ONLY_ROOT");

        _;

    }



    modifier onlyChildChain() {

        require(block.chainid == childChainId, "ONLY_CHILD");

        _;

    }



    receive() external payable {



    }



    function withdraw() external onlyChildChain payable {

        maticChildToken.withdraw{value: address(this).balance}(address(this).balance);

    }



    function initiateExit(IERC20Predicate _erc20Predicate, bytes calldata data) external onlyRootChain {

        _erc20Predicate.startExitWithBurntTokens(data);

    }



    function exit() external onlyRootChain {

        require(gasleft() > 370000, "MORE_GAS_NEEDED"); // WithdrawManager needs 300k, 65k for ERC20 transfer + leeway

        withdrawManager.processExits(address(maticRootToken));

        uint256 tokenBalance = maticRootToken.balanceOf(address(this));

        if (tokenBalance > 0) {

            maticRootToken.transfer(0x000000000000000000000000000000000000dEaD, tokenBalance);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC1155.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC1155.sol";

import "./IERC1155Receiver.sol";

import "./IERC1155MetadataURI.sol";

import "./Address.sol";

import "./Context.sol";

import "./ERC165.sol";



/**

 *

 * @dev Implementation of the basic standard multi-token.

 * See https://eips.ethereum.org/EIPS/eip-1155

 * Originally based on code by Enjin: https://github.com/enjin/erc-1155

 *

 * _Available since v3.1._

 */

contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {

    using Address for address;



    // Mapping from token ID to account balances

    mapping(uint256 => mapping(address => uint256)) private _balances;



    // Mapping from account to operator approvals

    mapping(address => mapping(address => bool)) private _operatorApprovals;



    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json

    string private _uri;



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {

        return

            interfaceId == type(IERC1155).interfaceId ||

            interfaceId == type(IERC1155MetadataURI).interfaceId ||

            super.supportsInterface(interfaceId);

    }



    /**

     * @dev See {IERC1155MetadataURI-uri}.

     *

     * This implementation returns the same URI for *all* token types. It relies

     * on the token type ID substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * Clients calling this function must replace the `\{id\}` substring with the

     * actual token type ID.

     */

    function uri(uint256) public view virtual override returns (string memory) {

        return _uri;

    }



    /**

     * @dev See {IERC1155-balanceOf}.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {

        require(account != address(0), "ERC1155: balance query for the zero address");

        return _balances[id][account];

    }



    /**

     * @dev See {IERC1155-balanceOfBatch}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)

        public

        view

        virtual

        override

        returns (uint256[] memory)

    {

        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");



        uint256[] memory batchBalances = new uint256[](accounts.length);



        for (uint256 i = 0; i < accounts.length; ++i) {

            batchBalances[i] = balanceOf(accounts[i], ids[i]);

        }



        return batchBalances;

    }



    /**

     * @dev See {IERC1155-setApprovalForAll}.

     */

    function setApprovalForAll(address operator, bool approved) public virtual override {

        require(_msgSender() != operator, "ERC1155: setting approval status for self");



        _operatorApprovals[_msgSender()][operator] = approved;

        emit ApprovalForAll(_msgSender(), operator, approved);

    }



    /**

     * @dev See {IERC1155-isApprovedForAll}.

     */

    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {

        return _operatorApprovals[account][operator];

    }



    /**

     * @dev See {IERC1155-safeTransferFrom}.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) public virtual override {

        require(to != address(0), "ERC1155: transfer to the zero address");

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: caller is not owner nor approved"

        );



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);



        uint256 fromBalance = _balances[id][from];

        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");

        _balances[id][from] = fromBalance - amount;

        _balances[id][to] += amount;



        emit TransferSingle(operator, from, to, id, amount);



        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);

    }



    /**

     * @dev See {IERC1155-safeBatchTransferFrom}.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) public virtual override {

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        require(to != address(0), "ERC1155: transfer to the zero address");

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: transfer caller is not owner nor approved"

        );



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; ++i) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 fromBalance = _balances[id][from];

            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");

            _balances[id][from] = fromBalance - amount;

            _balances[id][to] += amount;

        }



        emit TransferBatch(operator, from, to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);

    }



    /**

     * @dev Sets a new URI for all token types, by relying on the token type ID

     * substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * By this mechanism, any occurrence of the `\{id\}` substring in either the

     * URI or any of the amounts in the JSON file at said URI will be replaced by

     * clients with the token type ID.

     *

     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be

     * interpreted by clients as

     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`

     * for token type ID 0x4cce0.

     *

     * See {uri}.

     *

     * Because these URIs cannot be meaningfully represented by the {URI} event,

     * this function emits no events.

     */

    function _setURI(string memory newuri) internal virtual {

        _uri = newuri;

    }



    /**

     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function _mint(

        address account,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        require(account != address(0), "ERC1155: mint to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);



        _balances[id][account] += amount;

        emit TransferSingle(operator, address(0), account, id, amount);



        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function _mintBatch(

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: mint to the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; i++) {

            _balances[ids[i]][to] += amounts[i];

        }



        emit TransferBatch(operator, address(0), to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);

    }



    /**

     * @dev Destroys `amount` tokens of token type `id` from `account`

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens of token type `id`.

     */

    function _burn(

        address account,

        uint256 id,

        uint256 amount

    ) internal virtual {

        require(account != address(0), "ERC1155: burn from the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");



        uint256 accountBalance = _balances[id][account];

        require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");

        _balances[id][account] = accountBalance - amount;



        emit TransferSingle(operator, account, address(0), id, amount);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     */

    function _burnBatch(

        address account,

        uint256[] memory ids,

        uint256[] memory amounts

    ) internal virtual {

        require(account != address(0), "ERC1155: burn from the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, account, address(0), ids, amounts, "");



        for (uint256 i = 0; i < ids.length; i++) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 accountBalance = _balances[id][account];

            require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");

            _balances[id][account] = accountBalance - amount;

        }



        emit TransferBatch(operator, account, address(0), ids, amounts);

    }



    function _setupMetaData(string memory uri_) internal virtual {

        _setURI(uri_);

    }



    /**

     * @dev Hook that is called before any token transfer. This includes minting

     * and burning, as well as batched variants.

     *

     * The same hook is called on both single and batched variants. For single

     * transfers, the length of the `id` and `amount` arrays will be 1.

     *

     * Calling conditions (for each `id` and `amount` pair):

     *

     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * of token type `id` will be  transferred to `to`.

     * - When `from` is zero, `amount` tokens of token type `id` will be minted

     * for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`

     * will be burned.

     * - `from` and `to` are never both zero.

     * - `ids` and `amounts` have the same, non-zero length.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    function _doSafeTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {

                if (response != IERC1155Receiver(to).onERC1155Received.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _doSafeBatchTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (

                bytes4 response

            ) {

                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {

        uint256[] memory array = new uint256[](1);

        array[0] = element;



        return array;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC1155Holder.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./ERC1155Receiver.sol";



/**

 * @dev _Available since v3.1._

 */

contract ERC1155Holder is ERC1155Receiver {

    function onERC1155Received(

        address,

        address,

        uint256,

        uint256,

        bytes memory

    ) public virtual override returns (bytes4) {

        return this.onERC1155Received.selector;

    }



    function onERC1155BatchReceived(

        address,

        address,

        uint256[] memory,

        uint256[] memory,

        bytes memory

    ) public virtual override returns (bytes4) {

        return this.onERC1155BatchReceived.selector;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC1155Predicate.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-11-13

*/



// File: @openzeppelin/contracts/introspection/IERC165.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;





/**

 * @dev Required interface of an ERC1155 compliant contract, as defined in the

 * https://eips.ethereum.org/EIPS/eip-1155[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155 is IERC165 {

    /**

     * @dev Emitted when `value` tokens of token type `id` are transfered from `from` to `to` by `operator`.

     */

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);



    /**

     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all

     * transfers.

     */

    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);



    /**

     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to

     * `approved`.

     */

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);



    /**

     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.

     *

     * If an {URI} event was emitted for `id`, the standard

     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value

     * returned by {IERC1155MetadataURI-uri}.

     */

    event URI(string value, uint256 indexed id);



    /**

     * @dev Returns the amount of tokens of token type `id` owned by `account`.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) external view returns (uint256);



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);



    /**

     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,

     *

     * Emits an {ApprovalForAll} event.

     *

     * Requirements:

     *

     * - `operator` cannot be the caller.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.

     *

     * See {setApprovalForAll}.

     */

    function isApprovedForAll(address account, address operator) external view returns (bool);



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;

}



// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;





/**

 * _Available since v3.1._

 */

interface IERC1155Receiver is IERC165 {



    /**

        @dev Handles the receipt of a single ERC1155 token type. This function is

        called at the end of a `safeTransferFrom` after the balance has been updated.

        To accept the transfer, this must return

        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

        (i.e. 0xf23a6e61, or its own function selector).

        @param operator The address which initiated the transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param id The ID of the token being transferred

        @param value The amount of tokens being transferred

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed

    */

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    )

        external

        returns(bytes4);



    /**

        @dev Handles the receipt of a multiple ERC1155 token types. This function

        is called at the end of a `safeBatchTransferFrom` after the balances have

        been updated. To accept the transfer(s), this must return

        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

        (i.e. 0xbc197c81, or its own function selector).

        @param operator The address which initiated the batch transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param ids An array containing ids of each token being transferred (order and length must match values array)

        @param values An array containing amounts of each token being transferred (order and length must match ids array)

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed

    */

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    )

        external

        returns(bytes4);

}



// File: @openzeppelin/contracts/introspection/ERC165.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;





/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts may inherit from this and call {_registerInterface} to declare

 * their support of an interface.

 */

contract ERC165 is IERC165 {

    /*

     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7

     */

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;



    /**

     * @dev Mapping of interface ids to whether or not it's supported.

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    constructor () internal {

        // Derived contracts need only register support for their own interfaces,

        // we register support for ERC165 itself here

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     *

     * Time complexity O(1), guaranteed to always use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev Registers the contract as an implementer of the interface defined by

     * `interfaceId`. Support of the actual ERC165 interface is automatic and

     * registering its interface id is not required.

     *

     * See {IERC165-supportsInterface}.

     *

     * Requirements:

     *

     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).

     */

    function _registerInterface(bytes4 interfaceId) internal virtual {

        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");

        _supportedInterfaces[interfaceId] = true;

    }

}



// File: @openzeppelin/contracts/token/ERC1155/ERC1155Receiver.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;







/**

 * @dev _Available since v3.1._

 */

abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {

    constructor() public {

        _registerInterface(

            ERC1155Receiver(0).onERC1155Received.selector ^

            ERC1155Receiver(0).onERC1155BatchReceived.selector

        );

    }

}



// File: @openzeppelin/contracts/utils/EnumerableSet.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`

 * (`UintSet`) are supported.

 */

library EnumerableSet {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;



        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            bytes32 lastvalue = set._values[lastIndex];



            // Move the last value to the index where the value to delete is

            set._values[toDeleteIndex] = lastvalue;

            // Update the index for the moved value

            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}



// File: @openzeppelin/contracts/utils/Address.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/GSN/Context.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: @openzeppelin/contracts/access/AccessControl.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context {

    using EnumerableSet for EnumerableSet.AddressSet;

    using Address for address;



    struct RoleData {

        EnumerableSet.AddressSet members;

        bytes32 adminRole;

    }



    mapping (bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view returns (bool) {

        return _roles[role].members.contains(account);

    }



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {

        return _roles[role].members.length();

    }



    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {

        return _roles[role].members.at(index);

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");



        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");



        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (_roles[role].members.add(account)) {

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (_roles[role].members.remove(account)) {

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}



// File: contracts/common/AccessControlMixin.sol



pragma solidity 0.6.6;





contract AccessControlMixin is AccessControl {

    string private _revertMsg;

    function _setupContractId(string memory contractId) internal {

        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));

    }



    modifier only(bytes32 role) {

        require(

            hasRole(role, _msgSender()),

            _revertMsg

        );

        _;

    }

}



// File: contracts/lib/RLPReader.sol



/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol

 */

pragma solidity 0.6.6;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START = 0xb8;

    uint8 constant LIST_SHORT_START = 0xc0;

    uint8 constant LIST_LONG_START = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint256 len;

        uint256 memPtr;

    }



    /*

     * @param item RLP encoded bytes

     */

    function toRlpItem(bytes memory item)

        internal

        pure

        returns (RLPItem memory)

    {

        require(item.length > 0, "RLPReader: INVALID_BYTES_LENGTH");

        uint256 memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

     * @param item RLP encoded list in bytes

     */

    function toList(RLPItem memory item)

        internal

        pure

        returns (RLPItem[] memory)

    {

        require(isList(item), "RLPReader: ITEM_NOT_LIST");



        uint256 items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);

        uint256 listLength = _itemLength(item.memPtr);

        require(listLength == item.len, "RLPReader: LIST_DECODED_LENGTH_MISMATCH");



        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 dataLen;

        for (uint256 i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr);

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        uint8 byte0;

        uint256 memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START) return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory result = new bytes(item.len);



        uint256 ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        require(!isList(item), "RLPReader: DECODING_LIST_AS_ADDRESS");

        // 1 byte for the length prefix

        require(item.len == 21, "RLPReader: INVALID_ADDRESS_LENGTH");



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint256) {

        require(!isList(item), "RLPReader: DECODING_LIST_AS_UINT");

        require(item.len <= 33, "RLPReader: INVALID_UINT_LENGTH");



        uint256 itemLength = _itemLength(item.memPtr);

        require(itemLength == item.len, "RLPReader: UINT_DECODED_LENGTH_MISMATCH");



        uint256 offset = _payloadOffset(item.memPtr);

        uint256 len = item.len - offset;

        uint256 result;

        uint256 memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {

        uint256 itemLength = _itemLength(item.memPtr);

        require(itemLength == item.len, "RLPReader: UINT_STRICT_DECODED_LENGTH_MISMATCH");

        // one byte prefix

        require(item.len == 33, "RLPReader: INVALID_UINT_STRICT_LENGTH");



        uint256 result;

        uint256 memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        uint256 listLength = _itemLength(item.memPtr);

        require(listLength == item.len, "RLPReader: BYTES_DECODED_LENGTH_MISMATCH");

        uint256 offset = _payloadOffset(item.memPtr);



        uint256 len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint256 destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

     * Private Helpers

     */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint256) {

        // add `isList` check if `item` is expected to be passsed without a check from calling function

        // require(isList(item), "RLPReader: NUM_ITEMS_NOT_LIST");



        uint256 count = 0;

        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

            currPtr = currPtr + _itemLength(currPtr); // skip over an item

            require(currPtr <= endPtr, "RLPReader: NUM_ITEMS_DECODED_LENGTH_MISMATCH");

            count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint256 memPtr) private pure returns (uint256) {

        uint256 itemLen;

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) itemLen = 1;

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;

        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte



                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        } else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) return 0;

        else if (

            byte0 < STRING_LONG_START ||

            (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)

        ) return 1;

        else if (byte0 < LIST_SHORT_START)

            // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

     * @param src Pointer to source

     * @param dest Pointer to destination

     * @param len Amount of memory to copy from the source

     */

    function copy(

        uint256 src,

        uint256 dest,

        uint256 len

    ) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint256 mask = 256**(WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: contracts/root/TokenPredicates/ITokenPredicate.sol



pragma solidity 0.6.6;





/// @title Token predicate interface for all pos portal predicates

/// @notice Abstract interface that defines methods for custom predicates

interface ITokenPredicate {



    /**

     * @notice Deposit tokens into pos portal

     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on side chain

     * @param rootToken Token which gets deposited

     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external;



    /**

     * @notice Validates and processes exit while withdraw process

     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.

     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw

     * @param sender Address

     * @param rootToken Token which gets withdrawn

     * @param logRLPList Valid sidechain log for data like amount, token id etc.

     */

    function exitTokens(

        address sender,

        address rootToken,

        bytes calldata logRLPList

    ) external;

}



// File: contracts/common/Initializable.sol



pragma solidity 0.6.6;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        _;

        inited = true;

    }

}



// File: contracts/root/TokenPredicates/ERC1155Predicate.sol



pragma solidity 0.6.6;















contract ERC1155Predicate is ITokenPredicate, ERC1155Receiver, AccessControlMixin, Initializable {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

    bytes32 public constant TOKEN_TYPE = keccak256("ERC1155");



    // keccak256("TransferSingle(address,address,address,uint256,uint256)")

    bytes32 public constant TRANSFER_SINGLE_EVENT_SIG = 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;

    // keccak256("TransferBatch(address,address,address,uint256[],uint256[])")

    bytes32 public constant TRANSFER_BATCH_EVENT_SIG = 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;



    event LockedBatchERC1155(

        address indexed depositor,

        address indexed depositReceiver,

        address indexed rootToken,

        uint256[] ids,

        uint256[] amounts

    );



    constructor() public {}



    function initialize(address _owner) external initializer {

        _setupContractId("ERC1155Predicate");

        _setupRole(DEFAULT_ADMIN_ROLE, _owner);

        _setupRole(MANAGER_ROLE, _owner);

    }



    /**

     * @notice rejects single transfer

     */

    function onERC1155Received(

        address,

        address,

        uint256,

        uint256,

        bytes calldata

    ) external override returns (bytes4) {

        return 0;

    }



    /**

     * @notice accepts batch transfer

     */

    function onERC1155BatchReceived(

        address,

        address,

        uint256[] calldata,

        uint256[] calldata,

        bytes calldata

    ) external override returns (bytes4) {

        return ERC1155Receiver(0).onERC1155BatchReceived.selector;

    }



    /**

     * @notice Lock ERC1155 tokens for deposit, callable only by manager

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on child chain

     * @param rootToken Token which gets deposited

     * @param depositData ABI encoded id array and amount array

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    )

        external

        override

        only(MANAGER_ROLE)

    {

        // forcing batch deposit since supporting both single and batch deposit introduces too much complexity

        (

            uint256[] memory ids,

            uint256[] memory amounts,

            bytes memory data

        ) = abi.decode(depositData, (uint256[], uint256[], bytes));

        emit LockedBatchERC1155(

            depositor,

            depositReceiver,

            rootToken,

            ids,

            amounts

        );

        IERC1155(rootToken).safeBatchTransferFrom(

            depositor,

            address(this),

            ids,

            amounts,

            data

        );

    }



    /**

     * @notice Validates log signature, from and to address

     * then sends the correct tokenId, amount to withdrawer

     * callable only by manager

     * @param rootToken Token which gets withdrawn

     * @param log Valid ERC1155 TransferSingle burn or TransferBatch burn log from child chain

     */

    function exitTokens(

        address,

        address rootToken,

        bytes memory log

    )

        public

        override

        only(MANAGER_ROLE)

    {

        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();

        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics

        bytes memory logData = logRLPList[2].toBytes();



        address withdrawer = address(logTopicRLPList[2].toUint()); // topic2 is from address



        require(

            address(logTopicRLPList[3].toUint()) == address(0), // topic3 is to address

            "ERC1155Predicate: INVALID_RECEIVER"

        );



        if (bytes32(logTopicRLPList[0].toUint()) == TRANSFER_SINGLE_EVENT_SIG) { // topic0 is event sig

            (uint256 id, uint256 amount) = abi.decode(

                logData,

                (uint256, uint256)

            );

            IERC1155(rootToken).safeTransferFrom(

                address(this),

                withdrawer,

                id,

                amount,

                bytes("")

            );

        } else if (bytes32(logTopicRLPList[0].toUint()) == TRANSFER_BATCH_EVENT_SIG) {

            (uint256[] memory ids, uint256[] memory amounts) = abi.decode(

                logData,

                (uint256[], uint256[])

            );

            IERC1155(rootToken).safeBatchTransferFrom(

                address(this),

                withdrawer,

                ids,

                amounts,

                bytes("")

            );

        } else {

            revert("ERC1155Predicate: INVALID_WITHDRAW_SIG");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC1155PredicateProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-08-26

*/



// File: contracts/common/Proxy/IERCProxy.sol



pragma solidity 0.6.6;



interface IERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/Proxy/Proxy.sol



pragma solidity 0.6.6;





abstract contract Proxy is IERCProxy {

    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas(), 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize()



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }



    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external virtual override view returns (address);

}



// File: contracts/common/Proxy/UpgradableProxy.sol



pragma solidity 0.6.6;





contract UpgradableProxy is Proxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event ProxyOwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setProxyOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    fallback() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    receive() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadProxyOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function proxyOwner() external view returns(address) {

        return loadProxyOwner();

    }



    function loadProxyOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external override view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferProxyOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());

        setProxyOwner(newOwner);

    }



    function setProxyOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/TokenPredicates/ERC1155PredicateProxy.sol



pragma solidity 0.6.6;





contract ERC1155PredicateProxy is UpgradableProxy {

    constructor(address _proxyTo)

        public

        UpgradableProxy(_proxyTo)

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC1155Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC1155Receiver.sol";

import "./ERC165.sol";



/**

 * @dev _Available since v3.1._

 */

abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {

        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check

 * for the additional interface id that will be supported. For example:

 *

 * ```solidity

 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);

 * }

 * ```

 *

 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.

 */

abstract contract ERC165 is IERC165 {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IERC165).interfaceId;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {IERC20} from "./IERC20.sol";

import {SafeMath} from "./SafeMath.sol";



/**

 * @dev Implementation of the {IERC20} interface.

 *

 * This implementation is agnostic to the way tokens are created. This means

 * that a supply mechanism has to be added in a derived contract using {_mint}.

 * For a generic mechanism see {ERC20PresetMinterPauser}.

 *

 * TIP: For a detailed writeup see our guide

 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How

 * to implement supply mechanisms].

 *

 * We have followed general OpenZeppelin guidelines: functions revert instead

 * of returning `false` on failure. This behavior is nonetheless conventional

 * and does not conflict with the expectations of ERC20 applications.

 *

 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.

 * This allows applications to reconstruct the allowance for all accounts just

 * by listening to said events. Other implementations of the EIP may not emit

 * these events, as it isn't required by the specification.

 *

 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}

 * functions have been added to mitigate the well-known issues around setting

 * allowances. See {IERC20-approve}.

 */

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping(address => uint256) private _balances;



    mapping(address => mapping(address => uint256)) private _allowances;



    uint256 private _totalSupply;



    string private _name;

    string private _symbol;

    uint8 private _decimals;



    /**

     * @dev Returns the name of the token.

     */

    function name() public view returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5,05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is

     * called.

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view override returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `recipient` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(msg.sender, recipient, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        _approve(msg.sender, spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20}.

     *

     * Requirements:

     *

     * - `sender` and `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     * - the caller must have allowance for ``sender``'s tokens of at least

     * `amount`.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(

            sender,

            msg.sender,

            _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance")

        );

        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        _approve(

            msg.sender,

            spender,

            _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero")

        );

        return true;

    }



    /**

     * @dev Moves tokens `amount` from `sender` to `recipient`.

     *

     * This is internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `sender` cannot be the zero address.

     * - `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     */

    function _transfer(

        address sender,

        address recipient,

        uint256 amount

    ) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.

     *

     * This internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(

        address owner,

        address spender,

        uint256 amount

    ) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    function _setupMetaData(

        string memory name_,

        string memory symbol_,

        uint8 decimals_

    ) internal virtual {

        _name = name_;

        _symbol = symbol_;

        _decimals = decimals_;

    }



    /**

     * @dev Hook that is called before any transfer of tokens. This includes

     * minting and burning.

     *

     * Calling conditions:

     *

     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * will be to transferred to `to`.

     * - when `from` is zero, `amount` tokens will be minted for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.

     * - `from` and `to` are never both zero.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC20Predicate.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-11-13

*/



// File: @openzeppelin/contracts/token/ERC20/IERC20.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: @openzeppelin/contracts/math/SafeMath.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: @openzeppelin/contracts/utils/Address.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



// File: @openzeppelin/contracts/utils/EnumerableSet.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`

 * (`UintSet`) are supported.

 */

library EnumerableSet {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;



        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            bytes32 lastvalue = set._values[lastIndex];



            // Move the last value to the index where the value to delete is

            set._values[toDeleteIndex] = lastvalue;

            // Update the index for the moved value

            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}



// File: @openzeppelin/contracts/GSN/Context.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: @openzeppelin/contracts/access/AccessControl.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context {

    using EnumerableSet for EnumerableSet.AddressSet;

    using Address for address;



    struct RoleData {

        EnumerableSet.AddressSet members;

        bytes32 adminRole;

    }



    mapping (bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view returns (bool) {

        return _roles[role].members.contains(account);

    }



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {

        return _roles[role].members.length();

    }



    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {

        return _roles[role].members.at(index);

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");



        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");



        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (_roles[role].members.add(account)) {

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (_roles[role].members.remove(account)) {

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}



// File: contracts/common/AccessControlMixin.sol



pragma solidity 0.6.6;





contract AccessControlMixin is AccessControl {

    string private _revertMsg;

    function _setupContractId(string memory contractId) internal {

        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));

    }



    modifier only(bytes32 role) {

        require(

            hasRole(role, _msgSender()),

            _revertMsg

        );

        _;

    }

}



// File: contracts/lib/RLPReader.sol



/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol

 */

pragma solidity 0.6.6;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START = 0xb8;

    uint8 constant LIST_SHORT_START = 0xc0;

    uint8 constant LIST_LONG_START = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint256 len;

        uint256 memPtr;

    }



    /*

     * @param item RLP encoded bytes

     */

    function toRlpItem(bytes memory item)

        internal

        pure

        returns (RLPItem memory)

    {

        require(item.length > 0, "RLPReader: INVALID_BYTES_LENGTH");

        uint256 memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

     * @param item RLP encoded list in bytes

     */

    function toList(RLPItem memory item)

        internal

        pure

        returns (RLPItem[] memory)

    {

        require(isList(item), "RLPReader: ITEM_NOT_LIST");



        uint256 items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);

        uint256 listLength = _itemLength(item.memPtr);

        require(listLength == item.len, "RLPReader: LIST_DECODED_LENGTH_MISMATCH");



        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 dataLen;

        for (uint256 i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr);

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        uint8 byte0;

        uint256 memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START) return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory result = new bytes(item.len);



        uint256 ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        require(!isList(item), "RLPReader: DECODING_LIST_AS_ADDRESS");

        // 1 byte for the length prefix

        require(item.len == 21, "RLPReader: INVALID_ADDRESS_LENGTH");



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint256) {

        require(!isList(item), "RLPReader: DECODING_LIST_AS_UINT");

        require(item.len <= 33, "RLPReader: INVALID_UINT_LENGTH");



        uint256 itemLength = _itemLength(item.memPtr);

        require(itemLength == item.len, "RLPReader: UINT_DECODED_LENGTH_MISMATCH");



        uint256 offset = _payloadOffset(item.memPtr);

        uint256 len = item.len - offset;

        uint256 result;

        uint256 memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {

        uint256 itemLength = _itemLength(item.memPtr);

        require(itemLength == item.len, "RLPReader: UINT_STRICT_DECODED_LENGTH_MISMATCH");

        // one byte prefix

        require(item.len == 33, "RLPReader: INVALID_UINT_STRICT_LENGTH");



        uint256 result;

        uint256 memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        uint256 listLength = _itemLength(item.memPtr);

        require(listLength == item.len, "RLPReader: BYTES_DECODED_LENGTH_MISMATCH");

        uint256 offset = _payloadOffset(item.memPtr);



        uint256 len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint256 destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

     * Private Helpers

     */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint256) {

        // add `isList` check if `item` is expected to be passsed without a check from calling function

        // require(isList(item), "RLPReader: NUM_ITEMS_NOT_LIST");



        uint256 count = 0;

        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

            currPtr = currPtr + _itemLength(currPtr); // skip over an item

            require(currPtr <= endPtr, "RLPReader: NUM_ITEMS_DECODED_LENGTH_MISMATCH");

            count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint256 memPtr) private pure returns (uint256) {

        uint256 itemLen;

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) itemLen = 1;

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;

        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte



                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        } else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) return 0;

        else if (

            byte0 < STRING_LONG_START ||

            (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)

        ) return 1;

        else if (byte0 < LIST_SHORT_START)

            // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

     * @param src Pointer to source

     * @param dest Pointer to destination

     * @param len Amount of memory to copy from the source

     */

    function copy(

        uint256 src,

        uint256 dest,

        uint256 len

    ) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint256 mask = 256**(WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: contracts/root/TokenPredicates/ITokenPredicate.sol



pragma solidity 0.6.6;





/// @title Token predicate interface for all pos portal predicates

/// @notice Abstract interface that defines methods for custom predicates

interface ITokenPredicate {



    /**

     * @notice Deposit tokens into pos portal

     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on side chain

     * @param rootToken Token which gets deposited

     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external;



    /**

     * @notice Validates and processes exit while withdraw process

     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.

     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw

     * @param sender Address

     * @param rootToken Token which gets withdrawn

     * @param logRLPList Valid sidechain log for data like amount, token id etc.

     */

    function exitTokens(

        address sender,

        address rootToken,

        bytes calldata logRLPList

    ) external;

}



// File: contracts/common/Initializable.sol



pragma solidity 0.6.6;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        _;

        inited = true;

    }

}



// File: contracts/root/TokenPredicates/ERC20Predicate.sol



pragma solidity 0.6.6;















contract ERC20Predicate is ITokenPredicate, AccessControlMixin, Initializable {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;

    using SafeERC20 for IERC20;



    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

    bytes32 public constant TOKEN_TYPE = keccak256("ERC20");

    bytes32 public constant TRANSFER_EVENT_SIG = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;



    event LockedERC20(

        address indexed depositor,

        address indexed depositReceiver,

        address indexed rootToken,

        uint256 amount

    );



    constructor() public {}



    function initialize(address _owner) external initializer {

        _setupContractId("ERC20Predicate");

        _setupRole(DEFAULT_ADMIN_ROLE, _owner);

        _setupRole(MANAGER_ROLE, _owner);

    }



    /**

     * @notice Lock ERC20 tokens for deposit, callable only by manager

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on child chain

     * @param rootToken Token which gets deposited

     * @param depositData ABI encoded amount

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    )

        external

        override

        only(MANAGER_ROLE)

    {

        uint256 amount = abi.decode(depositData, (uint256));

        emit LockedERC20(depositor, depositReceiver, rootToken, amount);

        IERC20(rootToken).safeTransferFrom(depositor, address(this), amount);

    }



    /**

     * @notice Validates log signature, from and to address

     * then sends the correct amount to withdrawer

     * callable only by manager

     * @param rootToken Token which gets withdrawn

     * @param log Valid ERC20 burn log from child chain

     */

    function exitTokens(

        address,

        address rootToken,

        bytes memory log

    )

        public

        override

        only(MANAGER_ROLE)

    {

        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();

        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics



        require(

            bytes32(logTopicRLPList[0].toUint()) == TRANSFER_EVENT_SIG, // topic0 is event sig

            "ERC20Predicate: INVALID_SIGNATURE"

        );



        address withdrawer = address(logTopicRLPList[1].toUint()); // topic1 is from address



        require(

            address(logTopicRLPList[2].toUint()) == address(0), // topic2 is to address

            "ERC20Predicate: INVALID_RECEIVER"

        );



        IERC20(rootToken).safeTransfer(

            withdrawer,

            logRLPList[2].toUint() // log data field

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC20PredicateBurnOnly.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-08-11

*/



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: contracts/common/lib/BytesLib.sol



pragma solidity ^0.5.2;





library BytesLib {

    function concat(bytes memory _preBytes, bytes memory _postBytes)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;

        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(

                0x40,

                and(

                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),

                    not(31) // Round down to the nearest 32 bytes.

                )

            )

        }

        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start, uint256 _length)

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));

        bytes memory tempBytes;

        assembly {

            switch iszero(_length)

                case 0 {

                    // Get a location of some free memory and store it in tempBytes as

                    // Solidity does for memory variables.

                    tempBytes := mload(0x40)



                    // The first word of the slice result is potentially a partial

                    // word read from the original array. To read it, we calculate

                    // the length of that partial word and start copying that many

                    // bytes into the array. The first word we copy will start with

                    // data we don't care about, but the last `lengthmod` bytes will

                    // land at the beginning of the contents of the new array. When

                    // we're done copying, we overwrite the full first word with

                    // the actual length of the slice.

                    let lengthmod := and(_length, 31)



                    // The multiplication in the next line is necessary

                    // because when slicing multiples of 32 bytes (lengthmod == 0)

                    // the following copy loop was copying the origin's length

                    // and then ending prematurely not copying everything it should.

                    let mc := add(

                        add(tempBytes, lengthmod),

                        mul(0x20, iszero(lengthmod))

                    )

                    let end := add(mc, _length)



                    for {

                        // The multiplication in the next line has the same exact purpose

                        // as the one above.

                        let cc := add(

                            add(

                                add(_bytes, lengthmod),

                                mul(0x20, iszero(lengthmod))

                            ),

                            _start

                        )

                    } lt(mc, end) {

                        mc := add(mc, 0x20)

                        cc := add(cc, 0x20)

                    } {

                        mstore(mc, mload(cc))

                    }



                    mstore(tempBytes, _length)



                    //update free-memory pointer

                    //allocating the array padded to 32 bytes like the compiler does now

                    mstore(0x40, and(add(mc, 31), not(31)))

                }

                //if we want a zero-length slice let's just return a zero-length array

                default {

                    tempBytes := mload(0x40)

                    mstore(0x40, add(tempBytes, 0x20))

                }

        }



        return tempBytes;

    }



    // Pad a bytes array to 32 bytes

    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {

        // may underflow if bytes.length < 32. Hence using SafeMath.sub

        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));

        return concat(newBytes, _bytes);

    }



    function toBytes32(bytes memory b) internal pure returns (bytes32) {

        require(b.length >= 32, "Bytes array should atleast be 32 bytes");

        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {

            out |= bytes32(b[i] & 0xFF) >> (i * 8);

        }

        return out;

    }



    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {

        assembly {

            result := mload(add(b, 32))

        }

    }



    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {

        bytes memory b = new bytes(32);

        for (uint256 i = 0; i < 32; i++) {

            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));

        }

        return b;

    }



    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {

        _ret = new bytes(32);

        assembly {

            mstore(add(_ret, 32), _num)

        }

    }



    function toUint(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (uint256)

    {

        require(_bytes.length >= (_start + 32));

        uint256 tempUint;

        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }

        return tempUint;

    }



    function toAddress(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (address)

    {

        require(_bytes.length >= (_start + 20));

        address tempAddress;

        assembly {

            tempAddress := div(

                mload(add(add(_bytes, 0x20), _start)),

                0x1000000000000000000000000

            )

        }



        return tempAddress;

    }

}



// File: contracts/common/lib/Common.sol



pragma solidity ^0.5.2;





library Common {

    function getV(bytes memory v, uint16 chainId) public pure returns (uint8) {

        if (chainId > 0) {

            return

                uint8(

                    BytesLib.toUint(BytesLib.leftPad(v), 0) - (chainId * 2) - 8

                );

        } else {

            return uint8(BytesLib.toUint(BytesLib.leftPad(v), 0));

        }

    }



    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.

    function isContract(address _addr) public view returns (bool) {

        uint256 length;

        assembly {

            //retrieve the size of the code on target address, this needs assembly

            length := extcodesize(_addr)

        }

        return (length > 0);

    }



    // convert bytes to uint8

    function toUint8(bytes memory _arg) public pure returns (uint8) {

        return uint8(_arg[0]);

    }



    function toUint16(bytes memory _arg) public pure returns (uint16) {

        return (uint16(uint8(_arg[0])) << 8) | uint16(uint8(_arg[1]));

    }

}



// File: openzeppelin-solidity/contracts/math/Math.sol



pragma solidity ^0.5.2;



/**

 * @title Math

 * @dev Assorted math operations

 */

library Math {

    /**

     * @dev Returns the largest of two numbers.

     */

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    /**

     * @dev Returns the smallest of two numbers.

     */

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    /**

     * @dev Calculates the average of two numbers. Since these are integers,

     * averages of an even and odd number cannot be represented, and will be

     * rounded down.

     */

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b) / 2 can overflow, so we distribute

        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

    }

}



// File: contracts/common/lib/RLPEncode.sol



// Library for RLP encoding a list of bytes arrays.

// Modeled after ethereumjs/rlp (https://github.com/ethereumjs/rlp)

// [Very] modified version of Sam Mayo's library.

pragma solidity ^0.5.2;





library RLPEncode {

    // Encode an item (bytes memory)

    function encodeItem(bytes memory self)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory encoded;

        if (self.length == 1 && uint8(self[0] & 0xFF) < 0x80) {

            encoded = new bytes(1);

            encoded = self;

        } else {

            encoded = BytesLib.concat(encodeLength(self.length, 128), self);

        }

        return encoded;

    }



    // Encode a list of items

    function encodeList(bytes[] memory self)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory encoded;

        for (uint256 i = 0; i < self.length; i++) {

            encoded = BytesLib.concat(encoded, encodeItem(self[i]));

        }

        return BytesLib.concat(encodeLength(encoded.length, 192), encoded);

    }



    // Hack to encode nested lists. If you have a list as an item passed here, included

    // pass = true in that index. E.g.

    // [item, list, item] --> pass = [false, true, false]

    // function encodeListWithPasses(bytes[] memory self, bool[] pass) internal pure returns (bytes memory) {

    //   bytes memory encoded;

    //   for (uint i=0; i < self.length; i++) {

    // 		if (pass[i] == true) {

    // 			encoded = BytesLib.concat(encoded, self[i]);

    // 		} else {

    // 			encoded = BytesLib.concat(encoded, encodeItem(self[i]));

    // 		}

    //   }

    //   return BytesLib.concat(encodeLength(encoded.length, 192), encoded);

    // }



    // Generate the prefix for an item or the entire list based on RLP spec

    function encodeLength(uint256 L, uint256 offset)

        internal

        pure

        returns (bytes memory)

    {

        if (L < 56) {

            bytes memory prefix = new bytes(1);

            prefix[0] = bytes1(uint8(L + offset));

            return prefix;

        } else {

            // lenLen is the length of the hex representation of the data length

            uint256 lenLen;

            uint256 i = 0x1;



            while (L / i != 0) {

                lenLen++;

                i *= 0x100;

            }



            bytes memory prefix0 = getLengthBytes(offset + 55 + lenLen);

            bytes memory prefix1 = getLengthBytes(L);

            return BytesLib.concat(prefix0, prefix1);

        }

    }



    function getLengthBytes(uint256 x) internal pure returns (bytes memory b) {

        // Figure out if we need 1 or two bytes to express the length.

        // 1 byte gets us to max 255

        // 2 bytes gets us to max 65535 (no payloads will be larger than this)

        uint256 nBytes = 1;

        if (x > 255) {

            nBytes = 2;

        }



        b = new bytes(nBytes);

        // Encode the length and return it

        for (uint256 i = 0; i < nBytes; i++) {

            b[i] = bytes1(uint8(x / (2**(8 * (nBytes - 1 - i)))));

        }

    }

}



// File: solidity-rlp/contracts/RLPReader.sol



/*

* @author Hamdi Allam hamdi.allam97@gmail.com

* Please reach out with any questions or concerns

*/

pragma solidity ^0.5.0;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param item RLP encoded bytes

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        return item.len - _payloadOffset(item.memPtr);

    }



    /*

    * @param item RLP encoded list in bytes

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        return result == 0 ? false : true;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset;



        uint result;

        uint memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: contracts/common/lib/ExitPayloadReader.sol



pragma solidity 0.5.17;







library ExitPayloadReader {

  using RLPReader for bytes;

  using RLPReader for RLPReader.RLPItem;



  uint8 constant WORD_SIZE = 32;



  struct ExitPayload {

    RLPReader.RLPItem[] data;

  }



  struct Receipt {

    RLPReader.RLPItem[] data;

    bytes raw;

    uint256 logIndex;

  }



  struct Log {

    RLPReader.RLPItem data;

    RLPReader.RLPItem[] list;

  }



  struct LogTopics {

    RLPReader.RLPItem[] data;

  }



  function toExitPayload(bytes memory data)

        internal

        pure

        returns (ExitPayload memory)

    {

        RLPReader.RLPItem[] memory payloadData = data

            .toRlpItem()

            .toList();



        return ExitPayload(payloadData);

    }



    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }



    function getHeaderNumber(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[0].toUint();

    }



    function getBlockProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[1].toBytes();

    }



    function getBlockNumber(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[2].toUint();

    }



    function getBlockTime(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[3].toUint();

    }



    function getTxRoot(ExitPayload memory payload) internal pure returns(bytes32) {

      return bytes32(payload.data[4].toUint());

    }



    function getReceiptRoot(ExitPayload memory payload) internal pure returns(bytes32) {

      return bytes32(payload.data[5].toUint());

    }



    function getReceipt(ExitPayload memory payload) internal pure returns(Receipt memory receipt) {

      receipt.raw = payload.data[6].toBytes();

      RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();



      if (receiptItem.isList()) {

          // legacy tx

          receipt.data = receiptItem.toList();

      } else {

          // pop first byte before parsting receipt

          bytes memory typedBytes = receipt.raw;

          bytes memory result = new bytes(typedBytes.length - 1);

          uint256 srcPtr;

          uint256 destPtr;

          assembly {

              srcPtr := add(33, typedBytes)

              destPtr := add(0x20, result)

          }



          copy(srcPtr, destPtr, result.length);

          receipt.data = result.toRlpItem().toList();

      }



      receipt.logIndex = getReceiptLogIndex(payload);

      return receipt;

    }



    function getReceiptProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[7].toBytes();

    }



    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[8].toBytes();

    }



    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[8].toUint();

    }



    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[9].toUint();

    }



    function getTx(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[10].toBytes();

    }



    function getTxProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[11].toBytes();

    }

    

    // Receipt methods

    function toBytes(Receipt memory receipt) internal pure returns(bytes memory) {

        return receipt.raw;

    }



    function getLog(Receipt memory receipt) internal pure returns(Log memory) {

        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];

        return Log(logData, logData.toList());

    }



    // Log methods

    function getEmitter(Log memory log) internal pure returns(address) {

      return RLPReader.toAddress(log.list[0]);

    }



    function getTopics(Log memory log) internal pure returns(LogTopics memory) {

        return LogTopics(log.list[1].toList());

    }



    function getData(Log memory log) internal pure returns(bytes memory) {

        return log.list[2].toBytes();

    }



    function toRlpBytes(Log memory log) internal pure returns(bytes memory) {

      return log.data.toRlpBytes();

    }



    // LogTopics methods

    function getField(LogTopics memory topics, uint256 index) internal pure returns(RLPReader.RLPItem memory) {

      return topics.data[index];

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/root/depositManager/IDepositManager.sol



pragma solidity ^0.5.2;



interface IDepositManager {

    function depositEther() external payable;

    function transferAssets(

        address _token,

        address _user,

        uint256 _amountOrNFTId

    ) external;

    function depositERC20(address _token, uint256 _amount) external;

    function depositERC721(address _token, uint256 _tokenId) external;

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/misc/ProxyStorage.sol



pragma solidity ^0.5.2;





contract ProxyStorage is Ownable {

    address internal proxyTo;

}



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        _assertGovernance();

        _;

    }



    function _assertGovernance() private view {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

    }

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;









contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: contracts/common/mixin/ChainIdMixin.sol



pragma solidity ^0.5.2;



contract ChainIdMixin {

  bytes constant public networkId = hex"3A99";

  uint256 constant public CHAINID = 15001;

}



// File: contracts/root/RootChainStorage.sol



pragma solidity ^0.5.2;











contract RootChainHeader {

    event NewHeaderBlock(

        address indexed proposer,

        uint256 indexed headerBlockId,

        uint256 indexed reward,

        uint256 start,

        uint256 end,

        bytes32 root

    );

    // housekeeping event

    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }

}





contract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {

    bytes32 public heimdallId;

    uint8 public constant VOTE_TYPE = 2;



    uint16 internal constant MAX_DEPOSITS = 10000;

    uint256 public _nextHeaderBlock = MAX_DEPOSITS;

    uint256 internal _blockDepositId = 1;

    mapping(uint256 => HeaderBlock) public headerBlocks;

    Registry internal registry;

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity 0.5.17;



contract IStakeManager {

    // validator replacement

    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        uint[3][] calldata sigs

    ) external returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes calldata slashingInfoList) external returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function getRegistry() public view returns (address);



    function withdrawalDelay() public view returns (uint256);



    function delegatedAmount(uint256 validatorId) public view returns(uint256);



    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;



    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);



    function delegatorsReward(uint256 validatorId) public view returns(uint256);



    function dethroneAndStake(

        address auctionUser,

        uint256 heimdallFee,

        uint256 validatorId,

        uint256 auctionAmount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;

}



// File: contracts/root/IRootChain.sol



pragma solidity ^0.5.2;





interface IRootChain {

    function slash() external;



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)

        external;

    

    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs)

        external;



    function getLastChildBlock() external view returns (uint256);



    function currentHeaderBlock() external view returns (uint256);

}



// File: contracts/root/RootChain.sol



pragma solidity ^0.5.2;

















contract RootChain is RootChainStorage, IRootChain {

    using SafeMath for uint256;

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    modifier onlyDepositManager() {

        require(msg.sender == registry.getDepositManagerAddress(), "UNAUTHORIZED_DEPOSIT_MANAGER_ONLY");

        _;

    }



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {

        revert();

    }



    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs) external {

        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi

            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));

        require(CHAINID == _borChainID, "Invalid bor chain id");



        require(_buildHeaderBlock(proposer, start, end, rootHash), "INCORRECT_HEADER_DATA");



        // check if it is better to keep it in local storage instead

        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());

        uint256 _reward = stakeManager.checkSignatures(

            end.sub(start).add(1),

            /**  

                prefix 01 to data 

                01 represents positive vote on data and 00 is negative vote

                malicious validator can try to send 2/3 on negative vote so 01 is appended

             */

            keccak256(abi.encodePacked(bytes(hex"01"), data)),

            accountHash,

            proposer,

            sigs

        );



        require(_reward != 0, "Invalid checkpoint");

        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);

        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);

        _blockDepositId = 1;

    }



    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {

        depositId = currentHeaderBlock().add(_blockDepositId);

        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)

        _blockDepositId = _blockDepositId.add(numDeposits);

        require(

            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed

            _blockDepositId <= MAX_DEPOSITS,

            "TOO_MANY_DEPOSITS"

        );

    }



    function getLastChildBlock() external view returns (uint256) {

        return headerBlocks[currentHeaderBlock()].end;

    }



    function slash() external {

        //TODO: future implementation

    }



    function currentHeaderBlock() public view returns (uint256) {

        return _nextHeaderBlock.sub(MAX_DEPOSITS);

    }



    function _buildHeaderBlock(

        address proposer,

        uint256 start,

        uint256 end,

        bytes32 rootHash

    ) private returns (bool) {

        uint256 nextChildBlock;

        /*

    The ID of the 1st header block is MAX_DEPOSITS.

    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0

    */

        if (_nextHeaderBlock > MAX_DEPOSITS) {

            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;

        }

        if (nextChildBlock != start) {

            return false;

        }



        HeaderBlock memory headerBlock = HeaderBlock({

            root: rootHash,

            start: nextChildBlock,

            end: end,

            createdAt: now,

            proposer: proposer

        });



        headerBlocks[_nextHeaderBlock] = headerBlock;

        return true;

    }



    // Housekeeping function. @todo remove later

    function setNextHeaderBlock(uint256 _value) public onlyOwner {

        require(_value % MAX_DEPOSITS == 0, "Invalid value");

        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {

            delete headerBlocks[i];

        }

        _nextHeaderBlock = _value;

        _blockDepositId = 1;

        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);

    }



    // Housekeeping function. @todo remove later

    function setHeimdallId(string memory _heimdallId) public onlyOwner {

        heimdallId = keccak256(abi.encodePacked(_heimdallId));

    }

}



// File: openzeppelin-solidity/contracts/introspection/IERC165.sol



pragma solidity ^0.5.2;



/**

 * @title IERC165

 * @dev https://eips.ethereum.org/EIPS/eip-165

 */

interface IERC165 {

    /**

     * @notice Query if a contract implements an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @dev Interface identification is specified in ERC-165. This function

     * uses less than 30,000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol



pragma solidity ^0.5.2;





/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    function balanceOf(address owner) public view returns (uint256 balance);

    function ownerOf(uint256 tokenId) public view returns (address owner);



    function approve(address to, uint256 tokenId) public;

    function getApproved(uint256 tokenId) public view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) public;

    function isApprovedForAll(address owner, address operator) public view returns (bool);



    function transferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId) public;



    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol



pragma solidity ^0.5.2;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract IERC721Receiver {

    /**

     * @notice Handle the receipt of an NFT

     * @dev The ERC721 smart contract calls this function on the recipient

     * after a `safeTransfer`. This function MUST return the function selector,

     * otherwise the caller will revert the transaction. The selector to be

     * returned can be obtained as `this.onERC721Received.selector`. This

     * function MAY throw to revert and reject the transfer.

     * Note: the ERC721 contract address is always the message sender.

     * @param operator The address which called `safeTransferFrom` function

     * @param from The address which previously owned the token

     * @param tokenId The NFT identifier which is being transferred

     * @param data Additional data with no specified format

     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)

    public returns (bytes4);

}



// File: openzeppelin-solidity/contracts/utils/Address.sol



pragma solidity ^0.5.2;



/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



// File: openzeppelin-solidity/contracts/drafts/Counters.sol



pragma solidity ^0.5.2;





/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids

 *

 * Include with `using Counters for Counters.Counter;`

 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath

 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never

 * directly accessed.

 */

library Counters {

    using SafeMath for uint256;



    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        counter._value += 1;

    }



    function decrement(Counter storage counter) internal {

        counter._value = counter._value.sub(1);

    }

}



// File: openzeppelin-solidity/contracts/introspection/ERC165.sol



pragma solidity ^0.5.2;





/**

 * @title ERC165

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract ERC165 is IERC165 {

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /*

     * 0x01ffc9a7 ===

     *     bytes4(keccak256('supportsInterface(bytes4)'))

     */



    /**

     * @dev a mapping of interface id to whether or not it's supported

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    /**

     * @dev A contract implementing SupportsInterfaceWithLookup

     * implement ERC165 itself

     */

    constructor () internal {

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev implement supportsInterface(bytes4) using a lookup table

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev internal method for registering an interface

     */

    function _registerInterface(bytes4 interfaceId) internal {

        require(interfaceId != 0xffffffff);

        _supportedInterfaces[interfaceId] = true;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol



pragma solidity ^0.5.2;















/**

 * @title ERC721 Non-Fungible Token Standard basic implementation

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721 is ERC165, IERC721 {

    using SafeMath for uint256;

    using Address for address;

    using Counters for Counters.Counter;



    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;



    // Mapping from token ID to owner

    mapping (uint256 => address) private _tokenOwner;



    // Mapping from token ID to approved address

    mapping (uint256 => address) private _tokenApprovals;



    // Mapping from owner to number of owned token

    mapping (address => Counters.Counter) private _ownedTokensCount;



    // Mapping from owner to operator approvals

    mapping (address => mapping (address => bool)) private _operatorApprovals;



    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /*

     * 0x80ac58cd ===

     *     bytes4(keccak256('balanceOf(address)')) ^

     *     bytes4(keccak256('ownerOf(uint256)')) ^

     *     bytes4(keccak256('approve(address,uint256)')) ^

     *     bytes4(keccak256('getApproved(uint256)')) ^

     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^

     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^

     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))

     */



    constructor () public {

        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721);

    }



    /**

     * @dev Gets the balance of the specified address

     * @param owner address to query the balance of

     * @return uint256 representing the amount owned by the passed address

     */

    function balanceOf(address owner) public view returns (uint256) {

        require(owner != address(0));

        return _ownedTokensCount[owner].current();

    }



    /**

     * @dev Gets the owner of the specified token ID

     * @param tokenId uint256 ID of the token to query the owner of

     * @return address currently marked as the owner of the given token ID

     */

    function ownerOf(uint256 tokenId) public view returns (address) {

        address owner = _tokenOwner[tokenId];

        require(owner != address(0));

        return owner;

    }



    /**

     * @dev Approves another address to transfer the given token ID

     * The zero address indicates there is no approved address.

     * There can only be one approved address per token at a given time.

     * Can only be called by the token owner or an approved operator.

     * @param to address to be approved for the given token ID

     * @param tokenId uint256 ID of the token to be approved

     */

    function approve(address to, uint256 tokenId) public {

        address owner = ownerOf(tokenId);

        require(to != owner);

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));



        _tokenApprovals[tokenId] = to;

        emit Approval(owner, to, tokenId);

    }



    /**

     * @dev Gets the approved address for a token ID, or zero if no address set

     * Reverts if the token ID does not exist.

     * @param tokenId uint256 ID of the token to query the approval of

     * @return address currently approved for the given token ID

     */

    function getApproved(uint256 tokenId) public view returns (address) {

        require(_exists(tokenId));

        return _tokenApprovals[tokenId];

    }



    /**

     * @dev Sets or unsets the approval of a given operator

     * An operator is allowed to transfer all tokens of the sender on their behalf

     * @param to operator address to set the approval

     * @param approved representing the status of the approval to be set

     */

    function setApprovalForAll(address to, bool approved) public {

        require(to != msg.sender);

        _operatorApprovals[msg.sender][to] = approved;

        emit ApprovalForAll(msg.sender, to, approved);

    }



    /**

     * @dev Tells whether an operator is approved by a given owner

     * @param owner owner address which you want to query the approval of

     * @param operator operator address which you want to query the approval of

     * @return bool whether the given operator is approved by the given owner

     */

    function isApprovedForAll(address owner, address operator) public view returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    /**

     * @dev Transfers the ownership of a given token ID to another address

     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function transferFrom(address from, address to, uint256 tokenId) public {

        require(_isApprovedOrOwner(msg.sender, tokenId));



        _transferFrom(from, to, tokenId);

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) public {

        safeTransferFrom(from, to, tokenId, "");

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes data to send along with a safe transfer check

     */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {

        transferFrom(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data));

    }



    /**

     * @dev Returns whether the specified token exists

     * @param tokenId uint256 ID of the token to query the existence of

     * @return bool whether the token exists

     */

    function _exists(uint256 tokenId) internal view returns (bool) {

        address owner = _tokenOwner[tokenId];

        return owner != address(0);

    }



    /**

     * @dev Returns whether the given spender can transfer a given token ID

     * @param spender address of the spender to query

     * @param tokenId uint256 ID of the token to be transferred

     * @return bool whether the msg.sender is approved for the given token ID,

     * is an operator of the owner, or is the owner of the token

     */

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {

        address owner = ownerOf(tokenId);

        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));

    }



    /**

     * @dev Internal function to mint a new token

     * Reverts if the given token ID already exists

     * @param to The address that will own the minted token

     * @param tokenId uint256 ID of the token to be minted

     */

    function _mint(address to, uint256 tokenId) internal {

        require(to != address(0));

        require(!_exists(tokenId));



        _tokenOwner[tokenId] = to;

        _ownedTokensCount[to].increment();



        emit Transfer(address(0), to, tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead.

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(address owner, uint256 tokenId) internal {

        require(ownerOf(tokenId) == owner);



        _clearApproval(tokenId);



        _ownedTokensCount[owner].decrement();

        _tokenOwner[tokenId] = address(0);



        emit Transfer(owner, address(0), tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(uint256 tokenId) internal {

        _burn(ownerOf(tokenId), tokenId);

    }



    /**

     * @dev Internal function to transfer ownership of a given token ID to another address.

     * As opposed to transferFrom, this imposes no restrictions on msg.sender.

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _transferFrom(address from, address to, uint256 tokenId) internal {

        require(ownerOf(tokenId) == from);

        require(to != address(0));



        _clearApproval(tokenId);



        _ownedTokensCount[from].decrement();

        _ownedTokensCount[to].increment();



        _tokenOwner[tokenId] = to;



        emit Transfer(from, to, tokenId);

    }



    /**

     * @dev Internal function to invoke `onERC721Received` on a target address

     * The call is not executed if the target address is not a contract

     * @param from address representing the previous owner of the given token ID

     * @param to target address that will receive the tokens

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes optional data to send along with the call

     * @return bool whether the call correctly returned the expected magic value

     */

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)

        internal returns (bool)

    {

        if (!to.isContract()) {

            return true;

        }



        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);

        return (retval == _ERC721_RECEIVED);

    }



    /**

     * @dev Private function to clear current approval of a given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _clearApproval(uint256 tokenId) private {

        if (_tokenApprovals[tokenId] != address(0)) {

            _tokenApprovals[tokenId] = address(0);

        }

    }

}



// File: contracts/root/withdrawManager/ExitNFT.sol



pragma solidity ^0.5.2;







contract ExitNFT is ERC721 {

    Registry internal registry;



    modifier onlyWithdrawManager() {

        require(

            msg.sender == registry.getWithdrawManagerAddress(),

            "UNAUTHORIZED_WITHDRAW_MANAGER_ONLY"

        );

        _;

    }



    constructor(address _registry) public {

        registry = Registry(_registry);

    }



    function mint(address _owner, uint256 _tokenId)

        external

        onlyWithdrawManager

    {

        _mint(_owner, _tokenId);

    }



    function burn(uint256 _tokenId) external onlyWithdrawManager {

        _burn(_tokenId);

    }



    function exists(uint256 tokenId) public view returns (bool) {

        return _exists(tokenId);

    }

}



// File: contracts/root/withdrawManager/WithdrawManagerStorage.sol



pragma solidity ^0.5.2;













contract ExitsDataStructure {

    struct Input {

        address utxoOwner;

        address predicate;

        address token;

    }



    struct PlasmaExit {

        uint256 receiptAmountOrNFTId;

        bytes32 txHash;

        address owner;

        address token;

        bool isRegularExit;

        address predicate;

        // Mapping from age of input to Input

        mapping(uint256 => Input) inputs;

    }

}





contract WithdrawManagerHeader is ExitsDataStructure {

    event Withdraw(uint256 indexed exitId, address indexed user, address indexed token, uint256 amount);



    event ExitStarted(

        address indexed exitor,

        uint256 indexed exitId,

        address indexed token,

        uint256 amount,

        bool isRegularExit

    );



    event ExitUpdated(uint256 indexed exitId, uint256 indexed age, address signer);

    event ExitPeriodUpdate(uint256 indexed oldExitPeriod, uint256 indexed newExitPeriod);



    event ExitCancelled(uint256 indexed exitId);

}





contract WithdrawManagerStorage is ProxyStorage, WithdrawManagerHeader {

    // 0.5 week = 7 * 86400 / 2 = 302400

    uint256 public HALF_EXIT_PERIOD = 302400;



    // Bonded exits collaterized at 0.1 ETH

    uint256 internal constant BOND_AMOUNT = 10**17;



    Registry internal registry;

    RootChain internal rootChain;



    mapping(uint128 => bool) isKnownExit;

    mapping(uint256 => PlasmaExit) public exits;

    // mapping with token => (owner => exitId) keccak(token+owner) keccak(token+owner+tokenId)

    mapping(bytes32 => uint256) public ownerExits;

    mapping(address => address) public exitsQueues;

    ExitNFT public exitNft;



    // ERC721, ERC20 and Weth transfers require 155000, 100000, 52000 gas respectively

    // Processing each exit in a while loop iteration requires ~52000 gas (@todo check if this changed)

    // uint32 constant internal ITERATION_GAS = 52000;



    // So putting an upper limit of 155000 + 52000 + leeway

    uint32 public ON_FINALIZE_GAS_LIMIT = 300000;



    uint256 public exitWindow;

}



// File: contracts/root/predicates/IPredicate.sol



pragma solidity ^0.5.2;

















interface IPredicate {

    /**

   * @notice Verify the deprecation of a state update

   * @param exit ABI encoded PlasmaExit data

   * @param inputUtxo ABI encoded Input UTXO data

   * @param challengeData RLP encoded data of the challenge reference tx that encodes the following fields

   * headerNumber Header block number of which the reference tx was a part of

   * blockProof Proof that the block header (in the child chain) is a leaf in the submitted merkle root

   * blockNumber Block number of which the reference tx is a part of

   * blockTime Reference tx block time

   * blocktxRoot Transactions root of block

   * blockReceiptsRoot Receipts root of block

   * receipt Receipt of the reference transaction

   * receiptProof Merkle proof of the reference receipt

   * branchMask Merkle proof branchMask for the receipt

   * logIndex Log Index to read from the receipt

   * tx Challenge transaction

   * txProof Merkle proof of the challenge tx

   * @return Whether or not the state is deprecated

   */

    function verifyDeprecation(

        bytes calldata exit,

        bytes calldata inputUtxo,

        bytes calldata challengeData

    ) external returns (bool);



    function interpretStateUpdate(bytes calldata state)

        external

        view

        returns (bytes memory);

    function onFinalizeExit(bytes calldata data) external;

}



contract PredicateUtils is ExitsDataStructure, ChainIdMixin {

    using RLPReader for RLPReader.RLPItem;



    // Bonded exits collaterized at 0.1 ETH

    uint256 private constant BOND_AMOUNT = 10**17;



    IWithdrawManager internal withdrawManager;

    IDepositManager internal depositManager;



    modifier onlyWithdrawManager() {

        require(

            msg.sender == address(withdrawManager),

            "ONLY_WITHDRAW_MANAGER"

        );

        _;

    }



    modifier isBondProvided() {

        require(msg.value == BOND_AMOUNT, "Invalid Bond amount");

        _;

    }



    function onFinalizeExit(bytes calldata data) external onlyWithdrawManager {

        (, address token, address exitor, uint256 tokenId) = decodeExitForProcessExit(

            data

        );

        depositManager.transferAssets(token, exitor, tokenId);

    }



    function sendBond() internal {

        address(uint160(address(withdrawManager))).transfer(BOND_AMOUNT);

    }



    function getAddressFromTx(RLPReader.RLPItem[] memory txList)

        internal

        pure

        returns (address signer, bytes32 txHash)

    {

        bytes[] memory rawTx = new bytes[](9);

        for (uint8 i = 0; i <= 5; i++) {

            rawTx[i] = txList[i].toBytes();

        }

        rawTx[6] = networkId;

        rawTx[7] = hex""; // [7] and [8] have something to do with v, r, s values

        rawTx[8] = hex"";



        txHash = keccak256(RLPEncode.encodeList(rawTx));

        signer = ecrecover(

            txHash,

            Common.getV(txList[6].toBytes(), Common.toUint16(networkId)),

            bytes32(txList[7].toUint()),

            bytes32(txList[8].toUint())

        );

    }



    function decodeExit(bytes memory data)

        internal

        pure

        returns (PlasmaExit memory)

    {

        (address owner, address token, uint256 amountOrTokenId, bytes32 txHash, bool isRegularExit) = abi

            .decode(data, (address, address, uint256, bytes32, bool));

        return

            PlasmaExit(

                amountOrTokenId,

                txHash,

                owner,

                token,

                isRegularExit,

                address(0) /* predicate value is not required */

            );

    }



    function decodeExitForProcessExit(bytes memory data)

        internal

        pure

        returns (uint256 exitId, address token, address exitor, uint256 tokenId)

    {

        (exitId, token, exitor, tokenId) = abi.decode(

            data,

            (uint256, address, address, uint256)

        );

    }



    function decodeInputUtxo(bytes memory data)

        internal

        pure

        returns (uint256 age, address signer, address predicate, address token)

    {

        (age, signer, predicate, token) = abi.decode(

            data,

            (uint256, address, address, address)

        );

    }



}



contract IErcPredicate is IPredicate, PredicateUtils {

    enum ExitType {Invalid, OutgoingTransfer, IncomingTransfer, Burnt}



    struct ExitTxData {

        uint256 amountOrToken;

        bytes32 txHash;

        address childToken;

        address signer;

        ExitType exitType;

    }



    struct ReferenceTxData {

        uint256 closingBalance;

        uint256 age;

        address childToken;

        address rootToken;

    }



    uint256 internal constant MAX_LOGS = 10;



    constructor(address _withdrawManager, address _depositManager) public {

        withdrawManager = IWithdrawManager(_withdrawManager);

        depositManager = IDepositManager(_depositManager);

    }

}



// File: contracts/root/predicates/ERC20PredicateBurnOnly.sol



pragma solidity ^0.5.2;























contract ERC20PredicateBurnOnly is IErcPredicate {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;

    using SafeMath for uint256;



    using ExitPayloadReader for bytes;

    using ExitPayloadReader for ExitPayloadReader.ExitPayload;

    using ExitPayloadReader for ExitPayloadReader.Receipt;

    using ExitPayloadReader for ExitPayloadReader.Log;

    using ExitPayloadReader for ExitPayloadReader.LogTopics;



    // keccak256('Withdraw(address,address,uint256,uint256,uint256)')

    bytes32 constant WITHDRAW_EVENT_SIG = 0xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f;



    constructor(

        address _withdrawManager,

        address _depositManager

    ) public IErcPredicate(_withdrawManager, _depositManager) {

    }



    function startExitWithBurntTokens(bytes calldata data) external {

        ExitPayloadReader.ExitPayload memory payload = data.toExitPayload();

        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();

        uint256 logIndex = payload.getReceiptLogIndex();

        require(logIndex < MAX_LOGS, "Supporting a max of 10 logs");

        uint256 age = withdrawManager.verifyInclusion(

            data,

            0, /* offset */

            false /* verifyTxInclusion */

        );

        ExitPayloadReader.Log memory log = receipt.getLog();



        // "address" (contract address that emitted the log) field in the receipt

        address childToken = log.getEmitter();

        ExitPayloadReader.LogTopics memory topics = log.getTopics();

        // now, inputItems[i] refers to i-th (0-based) topic in the topics array

        // event Withdraw(address indexed token, address indexed from, uint256 amountOrTokenId, uint256 input1, uint256 output1)

        require(

            bytes32(topics.getField(0).toUint()) == WITHDRAW_EVENT_SIG,

            "Not a withdraw event signature"

        );

        require(

            msg.sender == address(topics.getField(2).toUint()), // from

            "Withdrawer and burn exit tx do not match"

        );

        address rootToken = address(topics.getField(1).toUint());

        uint256 exitAmount = BytesLib.toUint(log.getData(), 0); // amountOrTokenId

        withdrawManager.addExitToQueue(

            msg.sender,

            childToken,

            rootToken,

            exitAmount,

            bytes32(0x0),

            true, /* isRegularExit */

            age << 1

        );

    }



    function verifyDeprecation(

        bytes calldata exit,

        bytes calldata inputUtxo,

        bytes calldata challengeData

    ) external returns (bool) {}



    function interpretStateUpdate(bytes calldata state)

        external

        view

        returns (bytes memory) {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC20PredicateProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-08-26

*/



// File: contracts/common/Proxy/IERCProxy.sol



pragma solidity 0.6.6;



interface IERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/Proxy/Proxy.sol



pragma solidity 0.6.6;





abstract contract Proxy is IERCProxy {

    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas(), 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize()



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }



    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external virtual override view returns (address);

}



// File: contracts/common/Proxy/UpgradableProxy.sol



pragma solidity 0.6.6;





contract UpgradableProxy is Proxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event ProxyOwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setProxyOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    fallback() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    receive() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadProxyOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function proxyOwner() external view returns(address) {

        return loadProxyOwner();

    }



    function loadProxyOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external override view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferProxyOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());

        setProxyOwner(newOwner);

    }



    function setProxyOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/TokenPredicates/ERC20PredicateProxy.sol



pragma solidity 0.6.6;





contract ERC20PredicateProxy is UpgradableProxy {

    constructor(address _proxyTo)

        public

        UpgradableProxy(_proxyTo)

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC721.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC721.sol";

import "./IERC721Receiver.sol";

import "./IERC721Metadata.sol";

import "./Address.sol";

import "./Context.sol";

import "./Strings.sol";

import "./ERC165.sol";



/**

 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including

 * the Metadata extension, but not including the Enumerable extension, which is available separately as

 * {ERC721Enumerable}.

 */

contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {

    using Address for address;

    using Strings for uint256;



    // Token name

    string private _name;



    // Token symbol

    string private _symbol;



    // Mapping from token ID to owner address

    mapping(uint256 => address) private _owners;



    // Mapping owner address to token count

    mapping(address => uint256) private _balances;



    // Mapping from token ID to approved address

    mapping(uint256 => address) private _tokenApprovals;



    // Mapping from owner to operator approvals

    mapping(address => mapping(address => bool)) private _operatorApprovals;



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {

        return

            interfaceId == type(IERC721).interfaceId ||

            interfaceId == type(IERC721Metadata).interfaceId ||

            super.supportsInterface(interfaceId);

    }



    /**

     * @dev See {IERC721-balanceOf}.

     */

    function balanceOf(address owner) public view virtual override returns (uint256) {

        require(owner != address(0), "ERC721: balance query for the zero address");

        return _balances[owner];

    }



    /**

     * @dev See {IERC721-ownerOf}.

     */

    function ownerOf(uint256 tokenId) public view virtual override returns (address) {

        address owner = _owners[tokenId];

        require(owner != address(0), "ERC721: owner query for nonexistent token");

        return owner;

    }



    /**

     * @dev See {IERC721Metadata-name}.

     */

    function name() public view virtual override returns (string memory) {

        return _name;

    }



    /**

     * @dev See {IERC721Metadata-symbol}.

     */

    function symbol() public view virtual override returns (string memory) {

        return _symbol;

    }



    /**

     * @dev See {IERC721Metadata-tokenURI}.

     */

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {

        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");



        string memory baseURI = _baseURI();

        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";

    }



    /**

     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden

     * in child contracts.

     */

    function _baseURI() internal view virtual returns (string memory) {

        return "";

    }



    /**

     * @dev See {IERC721-approve}.

     */

    function approve(address to, uint256 tokenId) public virtual override {

        address owner = ERC721.ownerOf(tokenId);

        require(to != owner, "ERC721: approval to current owner");



        require(

            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),

            "ERC721: approve caller is not owner nor approved for all"

        );



        _approve(to, tokenId);

        emit Approval(owner, to, tokenId);

    }



    /**

     * @dev See {IERC721-getApproved}.

     */

    function getApproved(uint256 tokenId) public view virtual override returns (address) {

        require(_exists(tokenId), "ERC721: approved query for nonexistent token");



        return _tokenApprovals[tokenId];

    }



    /**

     * @dev See {IERC721-setApprovalForAll}.

     */

    function setApprovalForAll(address operator, bool approved) public virtual override {

        require(operator != _msgSender(), "ERC721: approve to caller");



        _operatorApprovals[_msgSender()][operator] = approved;

        emit ApprovalForAll(_msgSender(), operator, approved);

    }



    /**

     * @dev See {IERC721-isApprovedForAll}.

     */

    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    /**

     * @dev See {IERC721-transferFrom}.

     */

    function transferFrom(

        address from,

        address to,

        uint256 tokenId

    ) public virtual override {

        //solhint-disable-next-line max-line-length

        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");



        _transfer(from, to, tokenId);

    }



    /**

     * @dev See {IERC721-safeTransferFrom}.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId

    ) public virtual override {

        safeTransferFrom(from, to, tokenId, "");

    }



    /**

     * @dev See {IERC721-safeTransferFrom}.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId,

        bytes memory _data

    ) public virtual override {

        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        _safeTransfer(from, to, tokenId, _data);

    }



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * `_data` is additional data, it has no specified format and it is sent in call to `to`.

     *

     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.

     * implement alternative mechanisms to perform token transfer, such as signature-based.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function _safeTransfer(

        address from,

        address to,

        uint256 tokenId,

        bytes memory _data

    ) internal virtual {

        _transfer(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");

    }



    /**

     * @dev Returns whether `tokenId` exists.

     *

     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.

     *

     * Tokens start existing when they are minted (`_mint`),

     * and stop existing when they are burned (`_burn`).

     */

    function _exists(uint256 tokenId) internal view virtual returns (bool) {

        return _owners[tokenId] != address(0);

    }



    /**

     * @dev Returns whether `spender` is allowed to manage `tokenId`.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {

        require(_exists(tokenId), "ERC721: operator query for nonexistent token");

        address owner = ERC721.ownerOf(tokenId);

        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));

    }



    /**

     * @dev Safely mints `tokenId` and transfers it to `to`.

     *

     * Requirements:

     *

     * - `tokenId` must not exist.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function _safeMint(address to, uint256 tokenId) internal virtual {

        _safeMint(to, tokenId, "");

    }



    /**

     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is

     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.

     */

    function _safeMint(

        address to,

        uint256 tokenId,

        bytes memory _data

    ) internal virtual {

        _mint(to, tokenId);

        require(

            _checkOnERC721Received(address(0), to, tokenId, _data),

            "ERC721: transfer to non ERC721Receiver implementer"

        );

    }



    /**

     * @dev Mints `tokenId` and transfers it to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible

     *

     * Requirements:

     *

     * - `tokenId` must not exist.

     * - `to` cannot be the zero address.

     *

     * Emits a {Transfer} event.

     */

    function _mint(address to, uint256 tokenId) internal virtual {

        require(to != address(0), "ERC721: mint to the zero address");

        require(!_exists(tokenId), "ERC721: token already minted");



        _beforeTokenTransfer(address(0), to, tokenId);



        _balances[to] += 1;

        _owners[tokenId] = to;



        emit Transfer(address(0), to, tokenId);

    }



    /**

     * @dev Destroys `tokenId`.

     * The approval is cleared when the token is burned.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     *

     * Emits a {Transfer} event.

     */

    function _burn(uint256 tokenId) internal virtual {

        address owner = ERC721.ownerOf(tokenId);



        _beforeTokenTransfer(owner, address(0), tokenId);



        // Clear approvals

        _approve(address(0), tokenId);



        _balances[owner] -= 1;

        delete _owners[tokenId];



        emit Transfer(owner, address(0), tokenId);

    }



    /**

     * @dev Transfers `tokenId` from `from` to `to`.

     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     *

     * Emits a {Transfer} event.

     */

    function _transfer(

        address from,

        address to,

        uint256 tokenId

    ) internal virtual {

        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");

        require(to != address(0), "ERC721: transfer to the zero address");



        _beforeTokenTransfer(from, to, tokenId);



        // Clear approvals from the previous owner

        _approve(address(0), tokenId);

        emit Approval(ERC721.ownerOf(tokenId), address(0), tokenId);



        _balances[from] -= 1;

        _balances[to] += 1;

        _owners[tokenId] = to;



        emit Transfer(from, to, tokenId);

    }



    /**

     * @dev Approve `to` to operate on `tokenId`

     *

     */

    function _approve(address to, uint256 tokenId) internal virtual {

        _tokenApprovals[tokenId] = to;

    }



    function _setupMetaData(string memory name_, string memory symbol_) internal virtual {

        _name = name_;

        _symbol = symbol_;

    }



    /**

     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.

     * The call is not executed if the target address is not a contract.

     *

     * @param from address representing the previous owner of the given token ID

     * @param to target address that will receive the tokens

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes optional data to send along with the call

     * @return bool whether the call correctly returned the expected magic value

     */

    function _checkOnERC721Received(

        address from,

        address to,

        uint256 tokenId,

        bytes memory _data

    ) private returns (bool) {

        if (to.isContract()) {

            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {

                return retval == IERC721Receiver(to).onERC721Received.selector;

            } catch (bytes memory reason) {

                if (reason.length == 0) {

                    revert("ERC721: transfer to non ERC721Receiver implementer");

                } else {

                    // solhint-disable-next-line no-inline-assembly

                    assembly {

                        revert(add(32, reason), mload(reason))

                    }

                }

            }

        } else {

            return true;

        }

    }



    /**

     * @dev Hook that is called before any token transfer. This includes minting

     * and burning.

     *

     * Calling conditions:

     *

     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be

     * transferred to `to`.

     * - When `from` is zero, `tokenId` will be minted for `to`.

     * - When `to` is zero, ``from``'s `tokenId` will be burned.

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 tokenId

    ) internal virtual {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC721Predicate.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2022-05-05

*/



// File: @openzeppelin/contracts/introspection/IERC165.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: @openzeppelin/contracts/token/ERC721/IERC721.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;





/**

 * @dev Required interface of an ERC721 compliant contract.

 */

interface IERC721 is IERC165 {

    /**

     * @dev Emitted when `tokenId` token is transfered from `from` to `to`.

     */

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.

     */

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.

     */

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of tokens in ``owner``'s account.

     */

    function balanceOf(address owner) external view returns (uint256 balance);



    /**

     * @dev Returns the owner of the `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function ownerOf(uint256 tokenId) external view returns (address owner);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Transfers `tokenId` token from `from` to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Gives permission to `to` to transfer `tokenId` token to another account.

     * The approval is cleared when the token is transferred.

     *

     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.

     *

     * Requirements:

     *

     * - The caller must own the token or be an approved operator.

     * - `tokenId` must exist.

     *

     * Emits an {Approval} event.

     */

    function approve(address to, uint256 tokenId) external;



    /**

     * @dev Returns the account approved for `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function getApproved(uint256 tokenId) external view returns (address operator);



    /**

     * @dev Approve or remove `operator` as an operator for the caller.

     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.

     *

     * Requirements:

     *

     * - The `operator` cannot be the caller.

     *

     * Emits an {ApprovalForAll} event.

     */

    function setApprovalForAll(address operator, bool _approved) external;



    /**

     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.

     *

     * See {setApprovalForAll}

     */

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    /**

      * @dev Safely transfers `tokenId` token from `from` to `to`.

      *

      * Requirements:

      *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

      * - `tokenId` token must exist and be owned by `from`.

      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

      *

      * Emits a {Transfer} event.

      */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

}



// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

interface IERC721Receiver {

    /**

     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}

     * by `operator` from `from`, this function is called.

     *

     * It must return its Solidity selector to confirm the token transfer.

     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.

     *

     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)

    external returns (bytes4);

}



// File: contracts/lib/RLPReader.sol



/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol

 */

pragma solidity 0.6.6;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param the RLP item.

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

     * @param the RLP item.

     * @return (memPtr, len) pair: location of the item's payload in memory.

     */

    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {

        uint offset = _payloadOffset(item.memPtr);

        uint memPtr = item.memPtr + offset;

        uint len = item.len - offset; // data length

        return (memPtr, len);

    }



    /*

    * @param the RLP item.

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        (, uint len) = payloadLocation(item);

        return len;

    }



    /*

    * @param the RLP item containing the encoded list.

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /*

     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.

     * @return keccak256 hash of RLP encoded bytes.

     */

    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        uint256 ptr = item.memPtr;

        uint256 len = item.len;

        bytes32 result;

        assembly {

            result := keccak256(ptr, len)

        }

        return result;

    }



    /*

     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.

     * @return keccak256 hash of the item payload.

     */

    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        (uint memPtr, uint len) = payloadLocation(item);

        bytes32 result;

        assembly {

            result := keccak256(memPtr, len)

        }

        return result;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte except "0x80" is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        // SEE Github Issue #5.

        // Summary: Most commonly used RLP libraries (i.e Geth) will encode

        // "0" as "0x80" instead of as "0". We handle this edge case explicitly

        // here.

        if (result == 0 || result == STRING_SHORT_START) {

            return false;

        } else {

            return true;

        }

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        (uint memPtr, uint len) = payloadLocation(item);



        uint result;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        (uint memPtr, uint len) = payloadLocation(item);

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(memPtr, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        if (len > 0) {

            // left over bytes. Mask is used to remove unwanted bytes from the word

            uint mask = 256 ** (WORD_SIZE - len) - 1;

            assembly {

                let srcpart := and(mload(src), not(mask)) // zero out src

                let destpart := and(mload(dest), mask) // retrieve the bytes

                mstore(dest, or(destpart, srcpart))

            }

        }

    }

}



// File: contracts/root/TokenPredicates/ITokenPredicate.sol



pragma solidity 0.6.6;





/// @title Token predicate interface for all pos portal predicates

/// @notice Abstract interface that defines methods for custom predicates

interface ITokenPredicate {



    /**

     * @notice Deposit tokens into pos portal

     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on side chain

     * @param rootToken Token which gets deposited

     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external;



    /**

     * @notice Validates and processes exit while withdraw process

     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.

     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw

     * @param sender Address

     * @param rootToken Token which gets withdrawn

     * @param logRLPList Valid sidechain log for data like amount, token id etc.

     */

    function exitTokens(

        address sender,

        address rootToken,

        bytes calldata logRLPList

    ) external;

}



// File: contracts/common/Initializable.sol



pragma solidity 0.6.6;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        _;

        inited = true;

    }

}



// File: @openzeppelin/contracts/utils/EnumerableSet.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`

 * (`UintSet`) are supported.

 */

library EnumerableSet {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;



        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            bytes32 lastvalue = set._values[lastIndex];



            // Move the last value to the index where the value to delete is

            set._values[toDeleteIndex] = lastvalue;

            // Update the index for the moved value

            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}



// File: @openzeppelin/contracts/utils/Address.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/GSN/Context.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: @openzeppelin/contracts/access/AccessControl.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context {

    using EnumerableSet for EnumerableSet.AddressSet;

    using Address for address;



    struct RoleData {

        EnumerableSet.AddressSet members;

        bytes32 adminRole;

    }



    mapping (bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view returns (bool) {

        return _roles[role].members.contains(account);

    }



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {

        return _roles[role].members.length();

    }



    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {

        return _roles[role].members.at(index);

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");



        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");



        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (_roles[role].members.add(account)) {

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (_roles[role].members.remove(account)) {

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}



// File: contracts/common/AccessControlMixin.sol



pragma solidity 0.6.6;





contract AccessControlMixin is AccessControl {

    string private _revertMsg;

    function _setupContractId(string memory contractId) internal {

        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));

    }



    modifier only(bytes32 role) {

        require(

            hasRole(role, _msgSender()),

            _revertMsg

        );

        _;

    }

}



// File: contracts/root/TokenPredicates/ERC721Predicate.sol



pragma solidity 0.6.6;















contract ERC721Predicate is ITokenPredicate, AccessControlMixin, Initializable, IERC721Receiver {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

    bytes32 public constant TOKEN_TYPE = keccak256("ERC721");

    // keccak256("Transfer(address,address,uint256)")

    bytes32 public constant TRANSFER_EVENT_SIG = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;



    // limit batching of tokens due to gas limit restrictions

    uint256 public constant BATCH_LIMIT = 20;



    event LockedERC721(

        address indexed depositor,

        address indexed depositReceiver,

        address indexed rootToken,

        uint256 tokenId

    );

    event LockedERC721Batch(

        address indexed depositor,

        address indexed depositReceiver,

        address indexed rootToken,

        uint256[] tokenIds

    );



    event ExitedERC721(

        address indexed exitor,

        address indexed rootToken,

        uint256 tokenId

    );



    event ExitedERC721Batch(

        address indexed exitor,

        address indexed rootToken,

        uint256[] tokenIds

    );



    constructor() public {}



    function initialize(address _owner) external initializer {

        _setupContractId("ERC721Predicate");

        _setupRole(DEFAULT_ADMIN_ROLE, _owner);

        _setupRole(MANAGER_ROLE, _owner);

    }



    /**

     * @notice accepts safe ERC721 transfer

     */

    function onERC721Received(

        address,

        address,

        uint256,

        bytes calldata

    )

        external

        override

        returns (bytes4)

    {

        return IERC721Receiver.onERC721Received.selector;

    }



    /**

     * @notice Lock ERC721 tokens for deposit, callable only by manager

     * @param depositor Address who wants to deposit token

     * @param depositReceiver Address (address) who wants to receive token on child chain

     * @param rootToken Token which gets deposited

     * @param depositData ABI encoded tokenId

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    )

        external

        override

        only(MANAGER_ROLE)

    {

        // deposit single

        if (depositData.length == 32) {

            uint256 tokenId = abi.decode(depositData, (uint256));

            emit LockedERC721(depositor, depositReceiver, rootToken, tokenId);

            IERC721(rootToken).safeTransferFrom(depositor, address(this), tokenId);



        // deposit batch

        } else {

            uint256[] memory tokenIds = abi.decode(depositData, (uint256[]));

            emit LockedERC721Batch(depositor, depositReceiver, rootToken, tokenIds);

            uint256 length = tokenIds.length;

            require(length <= BATCH_LIMIT, "ERC721Predicate: EXCEEDS_BATCH_LIMIT");

            for (uint256 i; i < length; i++) {

                IERC721(rootToken).safeTransferFrom(depositor, address(this), tokenIds[i]);

            }

        }

    }



    /**

     * @notice Validates log signature, from and to address

     * then sends the correct tokenId to withdrawer

     * callable only by manager

     * @param rootToken Token which gets withdrawn

     * @param log Valid ERC721 burn log from child chain

     */

    function exitTokens(

        address,

        address rootToken,

        bytes memory log

    )

        public

        override

        only(MANAGER_ROLE)

    {

        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();

        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics

        address withdrawer = address(logTopicRLPList[1].toUint()); // topic1 is from address



        require(bytes32(logTopicRLPList[0].toUint()) == TRANSFER_EVENT_SIG, "ERC721Predicate: INVALID_SIGNATURE");



        require(

            address(logTopicRLPList[2].toUint()) == address(0), // topic2 is to address

            "ERC721Predicate: INVALID_RECEIVER"

        );



        uint256 tokenId = logTopicRLPList[3].toUint(); // topic3 is tokenId field



        IERC721(rootToken).safeTransferFrom(

            address(this),

            withdrawer,

            tokenId

        );



        emit ExitedERC721(withdrawer, rootToken, tokenId);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC721PredicateBurnOnly.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-08-11

*/



// File: solidity-rlp/contracts/RLPReader.sol



/*

* @author Hamdi Allam hamdi.allam97@gmail.com

* Please reach out with any questions or concerns

*/

pragma solidity ^0.5.0;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param item RLP encoded bytes

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        return item.len - _payloadOffset(item.memPtr);

    }



    /*

    * @param item RLP encoded list in bytes

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        return result == 0 ? false : true;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset;



        uint result;

        uint memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: contracts/common/lib/BytesLib.sol



pragma solidity ^0.5.2;





library BytesLib {

    function concat(bytes memory _preBytes, bytes memory _postBytes)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;

        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(

                0x40,

                and(

                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),

                    not(31) // Round down to the nearest 32 bytes.

                )

            )

        }

        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start, uint256 _length)

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));

        bytes memory tempBytes;

        assembly {

            switch iszero(_length)

                case 0 {

                    // Get a location of some free memory and store it in tempBytes as

                    // Solidity does for memory variables.

                    tempBytes := mload(0x40)



                    // The first word of the slice result is potentially a partial

                    // word read from the original array. To read it, we calculate

                    // the length of that partial word and start copying that many

                    // bytes into the array. The first word we copy will start with

                    // data we don't care about, but the last `lengthmod` bytes will

                    // land at the beginning of the contents of the new array. When

                    // we're done copying, we overwrite the full first word with

                    // the actual length of the slice.

                    let lengthmod := and(_length, 31)



                    // The multiplication in the next line is necessary

                    // because when slicing multiples of 32 bytes (lengthmod == 0)

                    // the following copy loop was copying the origin's length

                    // and then ending prematurely not copying everything it should.

                    let mc := add(

                        add(tempBytes, lengthmod),

                        mul(0x20, iszero(lengthmod))

                    )

                    let end := add(mc, _length)



                    for {

                        // The multiplication in the next line has the same exact purpose

                        // as the one above.

                        let cc := add(

                            add(

                                add(_bytes, lengthmod),

                                mul(0x20, iszero(lengthmod))

                            ),

                            _start

                        )

                    } lt(mc, end) {

                        mc := add(mc, 0x20)

                        cc := add(cc, 0x20)

                    } {

                        mstore(mc, mload(cc))

                    }



                    mstore(tempBytes, _length)



                    //update free-memory pointer

                    //allocating the array padded to 32 bytes like the compiler does now

                    mstore(0x40, and(add(mc, 31), not(31)))

                }

                //if we want a zero-length slice let's just return a zero-length array

                default {

                    tempBytes := mload(0x40)

                    mstore(0x40, add(tempBytes, 0x20))

                }

        }



        return tempBytes;

    }



    // Pad a bytes array to 32 bytes

    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {

        // may underflow if bytes.length < 32. Hence using SafeMath.sub

        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));

        return concat(newBytes, _bytes);

    }



    function toBytes32(bytes memory b) internal pure returns (bytes32) {

        require(b.length >= 32, "Bytes array should atleast be 32 bytes");

        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {

            out |= bytes32(b[i] & 0xFF) >> (i * 8);

        }

        return out;

    }



    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {

        assembly {

            result := mload(add(b, 32))

        }

    }



    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {

        bytes memory b = new bytes(32);

        for (uint256 i = 0; i < 32; i++) {

            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));

        }

        return b;

    }



    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {

        _ret = new bytes(32);

        assembly {

            mstore(add(_ret, 32), _num)

        }

    }



    function toUint(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (uint256)

    {

        require(_bytes.length >= (_start + 32));

        uint256 tempUint;

        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }

        return tempUint;

    }



    function toAddress(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (address)

    {

        require(_bytes.length >= (_start + 20));

        address tempAddress;

        assembly {

            tempAddress := div(

                mload(add(add(_bytes, 0x20), _start)),

                0x1000000000000000000000000

            )

        }



        return tempAddress;

    }

}



// File: contracts/common/lib/Common.sol



pragma solidity ^0.5.2;





library Common {

    function getV(bytes memory v, uint16 chainId) public pure returns (uint8) {

        if (chainId > 0) {

            return

                uint8(

                    BytesLib.toUint(BytesLib.leftPad(v), 0) - (chainId * 2) - 8

                );

        } else {

            return uint8(BytesLib.toUint(BytesLib.leftPad(v), 0));

        }

    }



    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.

    function isContract(address _addr) public view returns (bool) {

        uint256 length;

        assembly {

            //retrieve the size of the code on target address, this needs assembly

            length := extcodesize(_addr)

        }

        return (length > 0);

    }



    // convert bytes to uint8

    function toUint8(bytes memory _arg) public pure returns (uint8) {

        return uint8(_arg[0]);

    }



    function toUint16(bytes memory _arg) public pure returns (uint16) {

        return (uint16(uint8(_arg[0])) << 8) | uint16(uint8(_arg[1]));

    }

}



// File: contracts/common/lib/RLPEncode.sol



// Library for RLP encoding a list of bytes arrays.

// Modeled after ethereumjs/rlp (https://github.com/ethereumjs/rlp)

// [Very] modified version of Sam Mayo's library.

pragma solidity ^0.5.2;





library RLPEncode {

    // Encode an item (bytes memory)

    function encodeItem(bytes memory self)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory encoded;

        if (self.length == 1 && uint8(self[0] & 0xFF) < 0x80) {

            encoded = new bytes(1);

            encoded = self;

        } else {

            encoded = BytesLib.concat(encodeLength(self.length, 128), self);

        }

        return encoded;

    }



    // Encode a list of items

    function encodeList(bytes[] memory self)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory encoded;

        for (uint256 i = 0; i < self.length; i++) {

            encoded = BytesLib.concat(encoded, encodeItem(self[i]));

        }

        return BytesLib.concat(encodeLength(encoded.length, 192), encoded);

    }



    // Hack to encode nested lists. If you have a list as an item passed here, included

    // pass = true in that index. E.g.

    // [item, list, item] --> pass = [false, true, false]

    // function encodeListWithPasses(bytes[] memory self, bool[] pass) internal pure returns (bytes memory) {

    //   bytes memory encoded;

    //   for (uint i=0; i < self.length; i++) {

    // 		if (pass[i] == true) {

    // 			encoded = BytesLib.concat(encoded, self[i]);

    // 		} else {

    // 			encoded = BytesLib.concat(encoded, encodeItem(self[i]));

    // 		}

    //   }

    //   return BytesLib.concat(encodeLength(encoded.length, 192), encoded);

    // }



    // Generate the prefix for an item or the entire list based on RLP spec

    function encodeLength(uint256 L, uint256 offset)

        internal

        pure

        returns (bytes memory)

    {

        if (L < 56) {

            bytes memory prefix = new bytes(1);

            prefix[0] = bytes1(uint8(L + offset));

            return prefix;

        } else {

            // lenLen is the length of the hex representation of the data length

            uint256 lenLen;

            uint256 i = 0x1;



            while (L / i != 0) {

                lenLen++;

                i *= 0x100;

            }



            bytes memory prefix0 = getLengthBytes(offset + 55 + lenLen);

            bytes memory prefix1 = getLengthBytes(L);

            return BytesLib.concat(prefix0, prefix1);

        }

    }



    function getLengthBytes(uint256 x) internal pure returns (bytes memory b) {

        // Figure out if we need 1 or two bytes to express the length.

        // 1 byte gets us to max 255

        // 2 bytes gets us to max 65535 (no payloads will be larger than this)

        uint256 nBytes = 1;

        if (x > 255) {

            nBytes = 2;

        }



        b = new bytes(nBytes);

        // Encode the length and return it

        for (uint256 i = 0; i < nBytes; i++) {

            b[i] = bytes1(uint8(x / (2**(8 * (nBytes - 1 - i)))));

        }

    }

}



// File: contracts/common/lib/ExitPayloadReader.sol



pragma solidity 0.5.17;







library ExitPayloadReader {

  using RLPReader for bytes;

  using RLPReader for RLPReader.RLPItem;



  uint8 constant WORD_SIZE = 32;



  struct ExitPayload {

    RLPReader.RLPItem[] data;

  }



  struct Receipt {

    RLPReader.RLPItem[] data;

    bytes raw;

    uint256 logIndex;

  }



  struct Log {

    RLPReader.RLPItem data;

    RLPReader.RLPItem[] list;

  }



  struct LogTopics {

    RLPReader.RLPItem[] data;

  }



  function toExitPayload(bytes memory data)

        internal

        pure

        returns (ExitPayload memory)

    {

        RLPReader.RLPItem[] memory payloadData = data

            .toRlpItem()

            .toList();



        return ExitPayload(payloadData);

    }



    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }



    function getHeaderNumber(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[0].toUint();

    }



    function getBlockProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[1].toBytes();

    }



    function getBlockNumber(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[2].toUint();

    }



    function getBlockTime(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[3].toUint();

    }



    function getTxRoot(ExitPayload memory payload) internal pure returns(bytes32) {

      return bytes32(payload.data[4].toUint());

    }



    function getReceiptRoot(ExitPayload memory payload) internal pure returns(bytes32) {

      return bytes32(payload.data[5].toUint());

    }



    function getReceipt(ExitPayload memory payload) internal pure returns(Receipt memory receipt) {

      receipt.raw = payload.data[6].toBytes();

      RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();



      if (receiptItem.isList()) {

          // legacy tx

          receipt.data = receiptItem.toList();

      } else {

          // pop first byte before parsting receipt

          bytes memory typedBytes = receipt.raw;

          bytes memory result = new bytes(typedBytes.length - 1);

          uint256 srcPtr;

          uint256 destPtr;

          assembly {

              srcPtr := add(33, typedBytes)

              destPtr := add(0x20, result)

          }



          copy(srcPtr, destPtr, result.length);

          receipt.data = result.toRlpItem().toList();

      }



      receipt.logIndex = getReceiptLogIndex(payload);

      return receipt;

    }



    function getReceiptProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[7].toBytes();

    }



    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[8].toBytes();

    }



    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[8].toUint();

    }



    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[9].toUint();

    }



    function getTx(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[10].toBytes();

    }



    function getTxProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[11].toBytes();

    }

    

    // Receipt methods

    function toBytes(Receipt memory receipt) internal pure returns(bytes memory) {

        return receipt.raw;

    }



    function getLog(Receipt memory receipt) internal pure returns(Log memory) {

        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];

        return Log(logData, logData.toList());

    }



    // Log methods

    function getEmitter(Log memory log) internal pure returns(address) {

      return RLPReader.toAddress(log.list[0]);

    }



    function getTopics(Log memory log) internal pure returns(LogTopics memory) {

        return LogTopics(log.list[1].toList());

    }



    function getData(Log memory log) internal pure returns(bytes memory) {

        return log.list[2].toBytes();

    }



    function toRlpBytes(Log memory log) internal pure returns(bytes memory) {

      return log.data.toRlpBytes();

    }



    // LogTopics methods

    function getField(LogTopics memory topics, uint256 index) internal pure returns(RLPReader.RLPItem memory) {

      return topics.data[index];

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/root/depositManager/IDepositManager.sol



pragma solidity ^0.5.2;



interface IDepositManager {

    function depositEther() external payable;

    function transferAssets(

        address _token,

        address _user,

        uint256 _amountOrNFTId

    ) external;

    function depositERC20(address _token, uint256 _amount) external;

    function depositERC721(address _token, uint256 _tokenId) external;

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/misc/ProxyStorage.sol



pragma solidity ^0.5.2;





contract ProxyStorage is Ownable {

    address internal proxyTo;

}



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        _assertGovernance();

        _;

    }



    function _assertGovernance() private view {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

    }

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;









contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: contracts/common/mixin/ChainIdMixin.sol



pragma solidity ^0.5.2;



contract ChainIdMixin {

  bytes constant public networkId = hex"3A99";

  uint256 constant public CHAINID = 15001;

}



// File: contracts/root/RootChainStorage.sol



pragma solidity ^0.5.2;











contract RootChainHeader {

    event NewHeaderBlock(

        address indexed proposer,

        uint256 indexed headerBlockId,

        uint256 indexed reward,

        uint256 start,

        uint256 end,

        bytes32 root

    );

    // housekeeping event

    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }

}





contract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {

    bytes32 public heimdallId;

    uint8 public constant VOTE_TYPE = 2;



    uint16 internal constant MAX_DEPOSITS = 10000;

    uint256 public _nextHeaderBlock = MAX_DEPOSITS;

    uint256 internal _blockDepositId = 1;

    mapping(uint256 => HeaderBlock) public headerBlocks;

    Registry internal registry;

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity 0.5.17;



contract IStakeManager {

    // validator replacement

    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        uint[3][] calldata sigs

    ) external returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes calldata slashingInfoList) external returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function getRegistry() public view returns (address);



    function withdrawalDelay() public view returns (uint256);



    function delegatedAmount(uint256 validatorId) public view returns(uint256);



    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;



    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);



    function delegatorsReward(uint256 validatorId) public view returns(uint256);



    function dethroneAndStake(

        address auctionUser,

        uint256 heimdallFee,

        uint256 validatorId,

        uint256 auctionAmount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;

}



// File: contracts/root/IRootChain.sol



pragma solidity ^0.5.2;





interface IRootChain {

    function slash() external;



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)

        external;

    

    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs)

        external;



    function getLastChildBlock() external view returns (uint256);



    function currentHeaderBlock() external view returns (uint256);

}



// File: contracts/root/RootChain.sol



pragma solidity ^0.5.2;

















contract RootChain is RootChainStorage, IRootChain {

    using SafeMath for uint256;

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    modifier onlyDepositManager() {

        require(msg.sender == registry.getDepositManagerAddress(), "UNAUTHORIZED_DEPOSIT_MANAGER_ONLY");

        _;

    }



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {

        revert();

    }



    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs) external {

        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi

            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));

        require(CHAINID == _borChainID, "Invalid bor chain id");



        require(_buildHeaderBlock(proposer, start, end, rootHash), "INCORRECT_HEADER_DATA");



        // check if it is better to keep it in local storage instead

        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());

        uint256 _reward = stakeManager.checkSignatures(

            end.sub(start).add(1),

            /**  

                prefix 01 to data 

                01 represents positive vote on data and 00 is negative vote

                malicious validator can try to send 2/3 on negative vote so 01 is appended

             */

            keccak256(abi.encodePacked(bytes(hex"01"), data)),

            accountHash,

            proposer,

            sigs

        );



        require(_reward != 0, "Invalid checkpoint");

        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);

        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);

        _blockDepositId = 1;

    }



    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {

        depositId = currentHeaderBlock().add(_blockDepositId);

        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)

        _blockDepositId = _blockDepositId.add(numDeposits);

        require(

            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed

            _blockDepositId <= MAX_DEPOSITS,

            "TOO_MANY_DEPOSITS"

        );

    }



    function getLastChildBlock() external view returns (uint256) {

        return headerBlocks[currentHeaderBlock()].end;

    }



    function slash() external {

        //TODO: future implementation

    }



    function currentHeaderBlock() public view returns (uint256) {

        return _nextHeaderBlock.sub(MAX_DEPOSITS);

    }



    function _buildHeaderBlock(

        address proposer,

        uint256 start,

        uint256 end,

        bytes32 rootHash

    ) private returns (bool) {

        uint256 nextChildBlock;

        /*

    The ID of the 1st header block is MAX_DEPOSITS.

    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0

    */

        if (_nextHeaderBlock > MAX_DEPOSITS) {

            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;

        }

        if (nextChildBlock != start) {

            return false;

        }



        HeaderBlock memory headerBlock = HeaderBlock({

            root: rootHash,

            start: nextChildBlock,

            end: end,

            createdAt: now,

            proposer: proposer

        });



        headerBlocks[_nextHeaderBlock] = headerBlock;

        return true;

    }



    // Housekeeping function. @todo remove later

    function setNextHeaderBlock(uint256 _value) public onlyOwner {

        require(_value % MAX_DEPOSITS == 0, "Invalid value");

        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {

            delete headerBlocks[i];

        }

        _nextHeaderBlock = _value;

        _blockDepositId = 1;

        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);

    }



    // Housekeeping function. @todo remove later

    function setHeimdallId(string memory _heimdallId) public onlyOwner {

        heimdallId = keccak256(abi.encodePacked(_heimdallId));

    }

}



// File: openzeppelin-solidity/contracts/introspection/IERC165.sol



pragma solidity ^0.5.2;



/**

 * @title IERC165

 * @dev https://eips.ethereum.org/EIPS/eip-165

 */

interface IERC165 {

    /**

     * @notice Query if a contract implements an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @dev Interface identification is specified in ERC-165. This function

     * uses less than 30,000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol



pragma solidity ^0.5.2;





/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    function balanceOf(address owner) public view returns (uint256 balance);

    function ownerOf(uint256 tokenId) public view returns (address owner);



    function approve(address to, uint256 tokenId) public;

    function getApproved(uint256 tokenId) public view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) public;

    function isApprovedForAll(address owner, address operator) public view returns (bool);



    function transferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId) public;



    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol



pragma solidity ^0.5.2;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract IERC721Receiver {

    /**

     * @notice Handle the receipt of an NFT

     * @dev The ERC721 smart contract calls this function on the recipient

     * after a `safeTransfer`. This function MUST return the function selector,

     * otherwise the caller will revert the transaction. The selector to be

     * returned can be obtained as `this.onERC721Received.selector`. This

     * function MAY throw to revert and reject the transfer.

     * Note: the ERC721 contract address is always the message sender.

     * @param operator The address which called `safeTransferFrom` function

     * @param from The address which previously owned the token

     * @param tokenId The NFT identifier which is being transferred

     * @param data Additional data with no specified format

     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)

    public returns (bytes4);

}



// File: openzeppelin-solidity/contracts/utils/Address.sol



pragma solidity ^0.5.2;



/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



// File: openzeppelin-solidity/contracts/drafts/Counters.sol



pragma solidity ^0.5.2;





/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids

 *

 * Include with `using Counters for Counters.Counter;`

 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath

 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never

 * directly accessed.

 */

library Counters {

    using SafeMath for uint256;



    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        counter._value += 1;

    }



    function decrement(Counter storage counter) internal {

        counter._value = counter._value.sub(1);

    }

}



// File: openzeppelin-solidity/contracts/introspection/ERC165.sol



pragma solidity ^0.5.2;





/**

 * @title ERC165

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract ERC165 is IERC165 {

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /*

     * 0x01ffc9a7 ===

     *     bytes4(keccak256('supportsInterface(bytes4)'))

     */



    /**

     * @dev a mapping of interface id to whether or not it's supported

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    /**

     * @dev A contract implementing SupportsInterfaceWithLookup

     * implement ERC165 itself

     */

    constructor () internal {

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev implement supportsInterface(bytes4) using a lookup table

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev internal method for registering an interface

     */

    function _registerInterface(bytes4 interfaceId) internal {

        require(interfaceId != 0xffffffff);

        _supportedInterfaces[interfaceId] = true;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol



pragma solidity ^0.5.2;















/**

 * @title ERC721 Non-Fungible Token Standard basic implementation

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721 is ERC165, IERC721 {

    using SafeMath for uint256;

    using Address for address;

    using Counters for Counters.Counter;



    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;



    // Mapping from token ID to owner

    mapping (uint256 => address) private _tokenOwner;



    // Mapping from token ID to approved address

    mapping (uint256 => address) private _tokenApprovals;



    // Mapping from owner to number of owned token

    mapping (address => Counters.Counter) private _ownedTokensCount;



    // Mapping from owner to operator approvals

    mapping (address => mapping (address => bool)) private _operatorApprovals;



    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /*

     * 0x80ac58cd ===

     *     bytes4(keccak256('balanceOf(address)')) ^

     *     bytes4(keccak256('ownerOf(uint256)')) ^

     *     bytes4(keccak256('approve(address,uint256)')) ^

     *     bytes4(keccak256('getApproved(uint256)')) ^

     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^

     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^

     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))

     */



    constructor () public {

        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721);

    }



    /**

     * @dev Gets the balance of the specified address

     * @param owner address to query the balance of

     * @return uint256 representing the amount owned by the passed address

     */

    function balanceOf(address owner) public view returns (uint256) {

        require(owner != address(0));

        return _ownedTokensCount[owner].current();

    }



    /**

     * @dev Gets the owner of the specified token ID

     * @param tokenId uint256 ID of the token to query the owner of

     * @return address currently marked as the owner of the given token ID

     */

    function ownerOf(uint256 tokenId) public view returns (address) {

        address owner = _tokenOwner[tokenId];

        require(owner != address(0));

        return owner;

    }



    /**

     * @dev Approves another address to transfer the given token ID

     * The zero address indicates there is no approved address.

     * There can only be one approved address per token at a given time.

     * Can only be called by the token owner or an approved operator.

     * @param to address to be approved for the given token ID

     * @param tokenId uint256 ID of the token to be approved

     */

    function approve(address to, uint256 tokenId) public {

        address owner = ownerOf(tokenId);

        require(to != owner);

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));



        _tokenApprovals[tokenId] = to;

        emit Approval(owner, to, tokenId);

    }



    /**

     * @dev Gets the approved address for a token ID, or zero if no address set

     * Reverts if the token ID does not exist.

     * @param tokenId uint256 ID of the token to query the approval of

     * @return address currently approved for the given token ID

     */

    function getApproved(uint256 tokenId) public view returns (address) {

        require(_exists(tokenId));

        return _tokenApprovals[tokenId];

    }



    /**

     * @dev Sets or unsets the approval of a given operator

     * An operator is allowed to transfer all tokens of the sender on their behalf

     * @param to operator address to set the approval

     * @param approved representing the status of the approval to be set

     */

    function setApprovalForAll(address to, bool approved) public {

        require(to != msg.sender);

        _operatorApprovals[msg.sender][to] = approved;

        emit ApprovalForAll(msg.sender, to, approved);

    }



    /**

     * @dev Tells whether an operator is approved by a given owner

     * @param owner owner address which you want to query the approval of

     * @param operator operator address which you want to query the approval of

     * @return bool whether the given operator is approved by the given owner

     */

    function isApprovedForAll(address owner, address operator) public view returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    /**

     * @dev Transfers the ownership of a given token ID to another address

     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function transferFrom(address from, address to, uint256 tokenId) public {

        require(_isApprovedOrOwner(msg.sender, tokenId));



        _transferFrom(from, to, tokenId);

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) public {

        safeTransferFrom(from, to, tokenId, "");

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes data to send along with a safe transfer check

     */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {

        transferFrom(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data));

    }



    /**

     * @dev Returns whether the specified token exists

     * @param tokenId uint256 ID of the token to query the existence of

     * @return bool whether the token exists

     */

    function _exists(uint256 tokenId) internal view returns (bool) {

        address owner = _tokenOwner[tokenId];

        return owner != address(0);

    }



    /**

     * @dev Returns whether the given spender can transfer a given token ID

     * @param spender address of the spender to query

     * @param tokenId uint256 ID of the token to be transferred

     * @return bool whether the msg.sender is approved for the given token ID,

     * is an operator of the owner, or is the owner of the token

     */

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {

        address owner = ownerOf(tokenId);

        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));

    }



    /**

     * @dev Internal function to mint a new token

     * Reverts if the given token ID already exists

     * @param to The address that will own the minted token

     * @param tokenId uint256 ID of the token to be minted

     */

    function _mint(address to, uint256 tokenId) internal {

        require(to != address(0));

        require(!_exists(tokenId));



        _tokenOwner[tokenId] = to;

        _ownedTokensCount[to].increment();



        emit Transfer(address(0), to, tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead.

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(address owner, uint256 tokenId) internal {

        require(ownerOf(tokenId) == owner);



        _clearApproval(tokenId);



        _ownedTokensCount[owner].decrement();

        _tokenOwner[tokenId] = address(0);



        emit Transfer(owner, address(0), tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(uint256 tokenId) internal {

        _burn(ownerOf(tokenId), tokenId);

    }



    /**

     * @dev Internal function to transfer ownership of a given token ID to another address.

     * As opposed to transferFrom, this imposes no restrictions on msg.sender.

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _transferFrom(address from, address to, uint256 tokenId) internal {

        require(ownerOf(tokenId) == from);

        require(to != address(0));



        _clearApproval(tokenId);



        _ownedTokensCount[from].decrement();

        _ownedTokensCount[to].increment();



        _tokenOwner[tokenId] = to;



        emit Transfer(from, to, tokenId);

    }



    /**

     * @dev Internal function to invoke `onERC721Received` on a target address

     * The call is not executed if the target address is not a contract

     * @param from address representing the previous owner of the given token ID

     * @param to target address that will receive the tokens

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes optional data to send along with the call

     * @return bool whether the call correctly returned the expected magic value

     */

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)

        internal returns (bool)

    {

        if (!to.isContract()) {

            return true;

        }



        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);

        return (retval == _ERC721_RECEIVED);

    }



    /**

     * @dev Private function to clear current approval of a given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _clearApproval(uint256 tokenId) private {

        if (_tokenApprovals[tokenId] != address(0)) {

            _tokenApprovals[tokenId] = address(0);

        }

    }

}



// File: contracts/root/withdrawManager/ExitNFT.sol



pragma solidity ^0.5.2;







contract ExitNFT is ERC721 {

    Registry internal registry;



    modifier onlyWithdrawManager() {

        require(

            msg.sender == registry.getWithdrawManagerAddress(),

            "UNAUTHORIZED_WITHDRAW_MANAGER_ONLY"

        );

        _;

    }



    constructor(address _registry) public {

        registry = Registry(_registry);

    }



    function mint(address _owner, uint256 _tokenId)

        external

        onlyWithdrawManager

    {

        _mint(_owner, _tokenId);

    }



    function burn(uint256 _tokenId) external onlyWithdrawManager {

        _burn(_tokenId);

    }



    function exists(uint256 tokenId) public view returns (bool) {

        return _exists(tokenId);

    }

}



// File: contracts/root/withdrawManager/WithdrawManagerStorage.sol



pragma solidity ^0.5.2;













contract ExitsDataStructure {

    struct Input {

        address utxoOwner;

        address predicate;

        address token;

    }



    struct PlasmaExit {

        uint256 receiptAmountOrNFTId;

        bytes32 txHash;

        address owner;

        address token;

        bool isRegularExit;

        address predicate;

        // Mapping from age of input to Input

        mapping(uint256 => Input) inputs;

    }

}





contract WithdrawManagerHeader is ExitsDataStructure {

    event Withdraw(uint256 indexed exitId, address indexed user, address indexed token, uint256 amount);



    event ExitStarted(

        address indexed exitor,

        uint256 indexed exitId,

        address indexed token,

        uint256 amount,

        bool isRegularExit

    );



    event ExitUpdated(uint256 indexed exitId, uint256 indexed age, address signer);

    event ExitPeriodUpdate(uint256 indexed oldExitPeriod, uint256 indexed newExitPeriod);



    event ExitCancelled(uint256 indexed exitId);

}





contract WithdrawManagerStorage is ProxyStorage, WithdrawManagerHeader {

    // 0.5 week = 7 * 86400 / 2 = 302400

    uint256 public HALF_EXIT_PERIOD = 302400;



    // Bonded exits collaterized at 0.1 ETH

    uint256 internal constant BOND_AMOUNT = 10**17;



    Registry internal registry;

    RootChain internal rootChain;



    mapping(uint128 => bool) isKnownExit;

    mapping(uint256 => PlasmaExit) public exits;

    // mapping with token => (owner => exitId) keccak(token+owner) keccak(token+owner+tokenId)

    mapping(bytes32 => uint256) public ownerExits;

    mapping(address => address) public exitsQueues;

    ExitNFT public exitNft;



    // ERC721, ERC20 and Weth transfers require 155000, 100000, 52000 gas respectively

    // Processing each exit in a while loop iteration requires ~52000 gas (@todo check if this changed)

    // uint32 constant internal ITERATION_GAS = 52000;



    // So putting an upper limit of 155000 + 52000 + leeway

    uint32 public ON_FINALIZE_GAS_LIMIT = 300000;



    uint256 public exitWindow;

}



// File: contracts/root/predicates/IPredicate.sol



pragma solidity ^0.5.2;

















interface IPredicate {

    /**

   * @notice Verify the deprecation of a state update

   * @param exit ABI encoded PlasmaExit data

   * @param inputUtxo ABI encoded Input UTXO data

   * @param challengeData RLP encoded data of the challenge reference tx that encodes the following fields

   * headerNumber Header block number of which the reference tx was a part of

   * blockProof Proof that the block header (in the child chain) is a leaf in the submitted merkle root

   * blockNumber Block number of which the reference tx is a part of

   * blockTime Reference tx block time

   * blocktxRoot Transactions root of block

   * blockReceiptsRoot Receipts root of block

   * receipt Receipt of the reference transaction

   * receiptProof Merkle proof of the reference receipt

   * branchMask Merkle proof branchMask for the receipt

   * logIndex Log Index to read from the receipt

   * tx Challenge transaction

   * txProof Merkle proof of the challenge tx

   * @return Whether or not the state is deprecated

   */

    function verifyDeprecation(

        bytes calldata exit,

        bytes calldata inputUtxo,

        bytes calldata challengeData

    ) external returns (bool);



    function interpretStateUpdate(bytes calldata state)

        external

        view

        returns (bytes memory);

    function onFinalizeExit(bytes calldata data) external;

}



contract PredicateUtils is ExitsDataStructure, ChainIdMixin {

    using RLPReader for RLPReader.RLPItem;



    // Bonded exits collaterized at 0.1 ETH

    uint256 private constant BOND_AMOUNT = 10**17;



    IWithdrawManager internal withdrawManager;

    IDepositManager internal depositManager;



    modifier onlyWithdrawManager() {

        require(

            msg.sender == address(withdrawManager),

            "ONLY_WITHDRAW_MANAGER"

        );

        _;

    }



    modifier isBondProvided() {

        require(msg.value == BOND_AMOUNT, "Invalid Bond amount");

        _;

    }



    function onFinalizeExit(bytes calldata data) external onlyWithdrawManager {

        (, address token, address exitor, uint256 tokenId) = decodeExitForProcessExit(

            data

        );

        depositManager.transferAssets(token, exitor, tokenId);

    }



    function sendBond() internal {

        address(uint160(address(withdrawManager))).transfer(BOND_AMOUNT);

    }



    function getAddressFromTx(RLPReader.RLPItem[] memory txList)

        internal

        pure

        returns (address signer, bytes32 txHash)

    {

        bytes[] memory rawTx = new bytes[](9);

        for (uint8 i = 0; i <= 5; i++) {

            rawTx[i] = txList[i].toBytes();

        }

        rawTx[6] = networkId;

        rawTx[7] = hex""; // [7] and [8] have something to do with v, r, s values

        rawTx[8] = hex"";



        txHash = keccak256(RLPEncode.encodeList(rawTx));

        signer = ecrecover(

            txHash,

            Common.getV(txList[6].toBytes(), Common.toUint16(networkId)),

            bytes32(txList[7].toUint()),

            bytes32(txList[8].toUint())

        );

    }



    function decodeExit(bytes memory data)

        internal

        pure

        returns (PlasmaExit memory)

    {

        (address owner, address token, uint256 amountOrTokenId, bytes32 txHash, bool isRegularExit) = abi

            .decode(data, (address, address, uint256, bytes32, bool));

        return

            PlasmaExit(

                amountOrTokenId,

                txHash,

                owner,

                token,

                isRegularExit,

                address(0) /* predicate value is not required */

            );

    }



    function decodeExitForProcessExit(bytes memory data)

        internal

        pure

        returns (uint256 exitId, address token, address exitor, uint256 tokenId)

    {

        (exitId, token, exitor, tokenId) = abi.decode(

            data,

            (uint256, address, address, uint256)

        );

    }



    function decodeInputUtxo(bytes memory data)

        internal

        pure

        returns (uint256 age, address signer, address predicate, address token)

    {

        (age, signer, predicate, token) = abi.decode(

            data,

            (uint256, address, address, address)

        );

    }



}



contract IErcPredicate is IPredicate, PredicateUtils {

    enum ExitType {Invalid, OutgoingTransfer, IncomingTransfer, Burnt}



    struct ExitTxData {

        uint256 amountOrToken;

        bytes32 txHash;

        address childToken;

        address signer;

        ExitType exitType;

    }



    struct ReferenceTxData {

        uint256 closingBalance;

        uint256 age;

        address childToken;

        address rootToken;

    }



    uint256 internal constant MAX_LOGS = 10;



    constructor(address _withdrawManager, address _depositManager) public {

        withdrawManager = IWithdrawManager(_withdrawManager);

        depositManager = IDepositManager(_depositManager);

    }

}



// File: contracts/root/predicates/ERC721PredicateBurnOnly.sol



pragma solidity ^0.5.2;

















contract ERC721PredicateBurnOnly is IErcPredicate {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;

    using SafeMath for uint256;



    using ExitPayloadReader for bytes;

    using ExitPayloadReader for ExitPayloadReader.ExitPayload;

    using ExitPayloadReader for ExitPayloadReader.Receipt;

    using ExitPayloadReader for ExitPayloadReader.Log;

    using ExitPayloadReader for ExitPayloadReader.LogTopics;



    // keccak256('Withdraw(address,address,uint256)')

    bytes32 constant WITHDRAW_EVENT_SIG = 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb;



    constructor(address _withdrawManager, address _depositManager)

        public

        IErcPredicate(_withdrawManager, _depositManager)

    {}



    function verifyDeprecation(

        bytes calldata exit,

        bytes calldata inputUtxo,

        bytes calldata challengeData

    ) external returns (bool) {}



    function interpretStateUpdate(bytes calldata state)

        external

        view

        returns (bytes memory b) {}



    function startExitWithBurntTokens(bytes memory data)

        public

        returns (bytes memory)

    {

        uint256 age = withdrawManager.verifyInclusion(

            data,

            0, /* offset */

            false /* verifyTxInclusion */

        );



        ExitPayloadReader.ExitPayload memory payload = data.toExitPayload();

        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();

        uint256 logIndex = payload.getReceiptLogIndex();

        require(logIndex < MAX_LOGS, "Supporting a max of 10 logs");

        ExitPayloadReader.Log memory log = receipt.getLog();



        // "address" (contract address that emitted the log) field in the receipt

        address childToken = log.getEmitter();

        ExitPayloadReader.LogTopics memory topics = log.getTopics();

        // now, inputItems[i] refers to i-th (0-based) topic in the topics array

        // event Withdraw(address indexed token, address indexed from, uint256 amountOrTokenId, uint256 input1, uint256 output1)

        require(

            bytes32(topics.getField(0).toUint()) == WITHDRAW_EVENT_SIG,

            "Not a withdraw event signature"

        );

        require(

            msg.sender == address(topics.getField(2).toUint()), // from

            "Withdrawer and burn exit tx do not match"

        );

        address rootToken = address(topics.getField(1).toUint());

        uint256 tokenId = BytesLib.toUint(log.getData(), 0);

        uint256 exitId = age << 1;

        withdrawManager.addExitToQueue(

            msg.sender,

            childToken,

            rootToken,

            tokenId,

            bytes32(0x0), /* txHash */

            true, /* isRegularExit */

            exitId

        );

        return abi.encode(rootToken, tokenId, childToken, exitId);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ERC721PredicateProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-08-26

*/



// File: contracts/common/Proxy/IERCProxy.sol



pragma solidity 0.6.6;



interface IERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/Proxy/Proxy.sol



pragma solidity 0.6.6;





abstract contract Proxy is IERCProxy {

    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas(), 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize()



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }



    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external virtual override view returns (address);

}



// File: contracts/common/Proxy/UpgradableProxy.sol



pragma solidity 0.6.6;





contract UpgradableProxy is Proxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event ProxyOwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setProxyOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    fallback() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    receive() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadProxyOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function proxyOwner() external view returns(address) {

        return loadProxyOwner();

    }



    function loadProxyOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external override view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferProxyOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());

        setProxyOwner(newOwner);

    }



    function setProxyOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/TokenPredicates/ERC721PredicateProxy.sol



pragma solidity 0.6.6;





contract ERC721PredicateProxy is UpgradableProxy {

    constructor(address _proxyTo)

        public

        UpgradableProxy(_proxyTo)

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\EtherPredicate.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-09-17

*/



// File: @openzeppelin/contracts/utils/EnumerableSet.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`

 * (`UintSet`) are supported.

 */

library EnumerableSet {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;



        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            bytes32 lastvalue = set._values[lastIndex];



            // Move the last value to the index where the value to delete is

            set._values[toDeleteIndex] = lastvalue;

            // Update the index for the moved value

            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}



// File: @openzeppelin/contracts/utils/Address.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/GSN/Context.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: @openzeppelin/contracts/access/AccessControl.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context {

    using EnumerableSet for EnumerableSet.AddressSet;

    using Address for address;



    struct RoleData {

        EnumerableSet.AddressSet members;

        bytes32 adminRole;

    }



    mapping (bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view returns (bool) {

        return _roles[role].members.contains(account);

    }



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {

        return _roles[role].members.length();

    }



    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {

        return _roles[role].members.at(index);

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");



        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");



        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (_roles[role].members.add(account)) {

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (_roles[role].members.remove(account)) {

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}



// File: contracts/common/AccessControlMixin.sol



pragma solidity 0.6.6;





contract AccessControlMixin is AccessControl {

    string private _revertMsg;

    function _setupContractId(string memory contractId) internal {

        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));

    }



    modifier only(bytes32 role) {

        require(

            hasRole(role, _msgSender()),

            _revertMsg

        );

        _;

    }

}



// File: contracts/lib/RLPReader.sol



/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol

 */

pragma solidity 0.6.6;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param the RLP item.

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

     * @param the RLP item.

     * @return (memPtr, len) pair: location of the item's payload in memory.

     */

    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {

        uint offset = _payloadOffset(item.memPtr);

        uint memPtr = item.memPtr + offset;

        uint len = item.len - offset; // data length

        return (memPtr, len);

    }



    /*

    * @param the RLP item.

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        (, uint len) = payloadLocation(item);

        return len;

    }



    /*

    * @param the RLP item containing the encoded list.

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /*

     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.

     * @return keccak256 hash of RLP encoded bytes.

     */

    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        uint256 ptr = item.memPtr;

        uint256 len = item.len;

        bytes32 result;

        assembly {

            result := keccak256(ptr, len)

        }

        return result;

    }



    /*

     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.

     * @return keccak256 hash of the item payload.

     */

    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        (uint memPtr, uint len) = payloadLocation(item);

        bytes32 result;

        assembly {

            result := keccak256(memPtr, len)

        }

        return result;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte except "0x80" is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        // SEE Github Issue #5.

        // Summary: Most commonly used RLP libraries (i.e Geth) will encode

        // "0" as "0x80" instead of as "0". We handle this edge case explicitly

        // here.

        if (result == 0 || result == STRING_SHORT_START) {

            return false;

        } else {

            return true;

        }

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        (uint memPtr, uint len) = payloadLocation(item);



        uint result;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        (uint memPtr, uint len) = payloadLocation(item);

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(memPtr, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        if (len > 0) {

            // left over bytes. Mask is used to remove unwanted bytes from the word

            uint mask = 256 ** (WORD_SIZE - len) - 1;

            assembly {

                let srcpart := and(mload(src), not(mask)) // zero out src

                let destpart := and(mload(dest), mask) // retrieve the bytes

                mstore(dest, or(destpart, srcpart))

            }

        }

    }

}



// File: contracts/root/TokenPredicates/ITokenPredicate.sol



pragma solidity 0.6.6;





/// @title Token predicate interface for all pos portal predicates

/// @notice Abstract interface that defines methods for custom predicates

interface ITokenPredicate {



    /**

     * @notice Deposit tokens into pos portal

     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on side chain

     * @param rootToken Token which gets deposited

     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external;



    /**

     * @notice Validates and processes exit while withdraw process

     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.

     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw

     * @param sender Address

     * @param rootToken Token which gets withdrawn

     * @param logRLPList Valid sidechain log for data like amount, token id etc.

     */

    function exitTokens(

        address sender,

        address rootToken,

        bytes calldata logRLPList

    ) external;

}



// File: contracts/common/Initializable.sol



pragma solidity 0.6.6;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        _;

        inited = true;

    }

}



// File: contracts/root/TokenPredicates/EtherPredicate.sol



pragma solidity 0.6.6;











contract EtherPredicate is ITokenPredicate, AccessControlMixin, Initializable {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

    bytes32 public constant TOKEN_TYPE = keccak256("Ether");

    bytes32 public constant TRANSFER_EVENT_SIG = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;



    event LockedEther(

        address indexed depositor,

        address indexed depositReceiver,

        uint256 amount

    );



    event ExitedEther(

        address indexed exitor,

        uint256 amount

    );



    constructor() public {}



    function initialize(address _owner) external initializer {

        _setupContractId("EtherPredicate");

        _setupRole(DEFAULT_ADMIN_ROLE, _owner);

        _setupRole(MANAGER_ROLE, _owner);

    }



    /**

     * @notice Receive Ether to lock for deposit, callable only by manager

     */

    receive() external payable only(MANAGER_ROLE) {}



    /**

     * @notice handle ether lock, callable only by manager

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on child chain

     * @param depositData ABI encoded amount

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address,

        bytes calldata depositData

    )

        external

        override

        only(MANAGER_ROLE)

    {

        uint256 amount = abi.decode(depositData, (uint256));

        emit LockedEther(depositor, depositReceiver, amount);

    }



    /**

     * @notice Validates log signature, from and to address

     * then sends the correct amount to withdrawer

     * callable only by manager

     * @param log Valid ERC20 burn log from child chain

     */

    function exitTokens(

        address,

        address,

        bytes memory log

    )

        public

        override

        only(MANAGER_ROLE)

    {

        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();

        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics



        require(

            bytes32(logTopicRLPList[0].toUint()) == TRANSFER_EVENT_SIG, // topic0 is event sig

            "EtherPredicate: INVALID_SIGNATURE"

        );



        address withdrawer = address(logTopicRLPList[1].toUint()); // topic1 is from address



        require(

            address(logTopicRLPList[2].toUint()) == address(0), // topic2 is to address

            "EtherPredicate: INVALID_RECEIVER"

        );



        emit ExitedEther(withdrawer, logRLPList[2].toUint());



        (bool success, /* bytes memory data */) = withdrawer.call{value: logRLPList[2].toUint()}("");

        if (!success) {

            revert("EtherPredicate: ETHER_TRANSFER_FAILED");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\EtherPredicateProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-08-26

*/



// File: contracts/common/Proxy/IERCProxy.sol



pragma solidity 0.6.6;



interface IERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/Proxy/Proxy.sol



pragma solidity 0.6.6;





abstract contract Proxy is IERCProxy {

    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas(), 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize()



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }



    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external virtual override view returns (address);

}



// File: contracts/common/Proxy/UpgradableProxy.sol



pragma solidity 0.6.6;





contract UpgradableProxy is Proxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event ProxyOwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setProxyOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    fallback() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    receive() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadProxyOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function proxyOwner() external view returns(address) {

        return loadProxyOwner();

    }



    function loadProxyOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external override view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferProxyOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());

        setProxyOwner(newOwner);

    }



    function setProxyOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/TokenPredicates/EtherPredicateProxy.sol



pragma solidity 0.6.6;





contract EtherPredicateProxy is UpgradableProxy {

    constructor(address _proxyTo)

        public

        UpgradableProxy(_proxyTo)

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ExitNFT.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





/**

 * @title IERC165

 * @dev https://eips.ethereum.org/EIPS/eip-165

 */

interface IERC165 {

    /**

     * @notice Query if a contract implements an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @dev Interface identification is specified in ERC-165. This function

     * uses less than 30,000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    function balanceOf(address owner) public view returns (uint256 balance);

    function ownerOf(uint256 tokenId) public view returns (address owner);



    function approve(address to, uint256 tokenId) public;

    function getApproved(uint256 tokenId) public view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) public;

    function isApprovedForAll(address owner, address operator) public view returns (bool);



    function transferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId) public;



    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;

}



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract IERC721Receiver {

    /**

     * @notice Handle the receipt of an NFT

     * @dev The ERC721 smart contract calls this function on the recipient

     * after a `safeTransfer`. This function MUST return the function selector,

     * otherwise the caller will revert the transaction. The selector to be

     * returned can be obtained as `this.onERC721Received.selector`. This

     * function MAY throw to revert and reject the transfer.

     * Note: the ERC721 contract address is always the message sender.

     * @param operator The address which called `safeTransferFrom` function

     * @param from The address which previously owned the token

     * @param tokenId The NFT identifier which is being transferred

     * @param data Additional data with no specified format

     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)

    public returns (bytes4);

}



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids

 *

 * Include with `using Counters for Counters.Counter;`

 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath

 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never

 * directly accessed.

 */

library Counters {

    using SafeMath for uint256;



    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        counter._value += 1;

    }



    function decrement(Counter storage counter) internal {

        counter._value = counter._value.sub(1);

    }

}



/**

 * @title ERC165

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract ERC165 is IERC165 {

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /*

     * 0x01ffc9a7 ===

     *     bytes4(keccak256('supportsInterface(bytes4)'))

     */



    /**

     * @dev a mapping of interface id to whether or not it's supported

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    /**

     * @dev A contract implementing SupportsInterfaceWithLookup

     * implement ERC165 itself

     */

    constructor () internal {

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev implement supportsInterface(bytes4) using a lookup table

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev internal method for registering an interface

     */

    function _registerInterface(bytes4 interfaceId) internal {

        require(interfaceId != 0xffffffff);

        _supportedInterfaces[interfaceId] = true;

    }

}



contract ERC721 is ERC165, IERC721 {

    using SafeMath for uint256;

    using Address for address;

    using Counters for Counters.Counter;



    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;



    // Mapping from token ID to owner

    mapping (uint256 => address) private _tokenOwner;



    // Mapping from token ID to approved address

    mapping (uint256 => address) private _tokenApprovals;



    // Mapping from owner to number of owned token

    mapping (address => Counters.Counter) private _ownedTokensCount;



    // Mapping from owner to operator approvals

    mapping (address => mapping (address => bool)) private _operatorApprovals;



    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /*

     * 0x80ac58cd ===

     *     bytes4(keccak256('balanceOf(address)')) ^

     *     bytes4(keccak256('ownerOf(uint256)')) ^

     *     bytes4(keccak256('approve(address,uint256)')) ^

     *     bytes4(keccak256('getApproved(uint256)')) ^

     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^

     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^

     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))

     */



    constructor () public {

        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721);

    }



    /**

     * @dev Gets the balance of the specified address

     * @param owner address to query the balance of

     * @return uint256 representing the amount owned by the passed address

     */

    function balanceOf(address owner) public view returns (uint256) {

        require(owner != address(0));

        return _ownedTokensCount[owner].current();

    }



    /**

     * @dev Gets the owner of the specified token ID

     * @param tokenId uint256 ID of the token to query the owner of

     * @return address currently marked as the owner of the given token ID

     */

    function ownerOf(uint256 tokenId) public view returns (address) {

        address owner = _tokenOwner[tokenId];

        require(owner != address(0));

        return owner;

    }



    /**

     * @dev Approves another address to transfer the given token ID

     * The zero address indicates there is no approved address.

     * There can only be one approved address per token at a given time.

     * Can only be called by the token owner or an approved operator.

     * @param to address to be approved for the given token ID

     * @param tokenId uint256 ID of the token to be approved

     */

    function approve(address to, uint256 tokenId) public {

        address owner = ownerOf(tokenId);

        require(to != owner);

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));



        _tokenApprovals[tokenId] = to;

        emit Approval(owner, to, tokenId);

    }



    /**

     * @dev Gets the approved address for a token ID, or zero if no address set

     * Reverts if the token ID does not exist.

     * @param tokenId uint256 ID of the token to query the approval of

     * @return address currently approved for the given token ID

     */

    function getApproved(uint256 tokenId) public view returns (address) {

        require(_exists(tokenId));

        return _tokenApprovals[tokenId];

    }



    /**

     * @dev Sets or unsets the approval of a given operator

     * An operator is allowed to transfer all tokens of the sender on their behalf

     * @param to operator address to set the approval

     * @param approved representing the status of the approval to be set

     */

    function setApprovalForAll(address to, bool approved) public {

        require(to != msg.sender);

        _operatorApprovals[msg.sender][to] = approved;

        emit ApprovalForAll(msg.sender, to, approved);

    }



    /**

     * @dev Tells whether an operator is approved by a given owner

     * @param owner owner address which you want to query the approval of

     * @param operator operator address which you want to query the approval of

     * @return bool whether the given operator is approved by the given owner

     */

    function isApprovedForAll(address owner, address operator) public view returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    /**

     * @dev Transfers the ownership of a given token ID to another address

     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function transferFrom(address from, address to, uint256 tokenId) public {

        require(_isApprovedOrOwner(msg.sender, tokenId));



        _transferFrom(from, to, tokenId);

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) public {

        safeTransferFrom(from, to, tokenId, "");

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes data to send along with a safe transfer check

     */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {

        transferFrom(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data));

    }



    /**

     * @dev Returns whether the specified token exists

     * @param tokenId uint256 ID of the token to query the existence of

     * @return bool whether the token exists

     */

    function _exists(uint256 tokenId) internal view returns (bool) {

        address owner = _tokenOwner[tokenId];

        return owner != address(0);

    }



    /**

     * @dev Returns whether the given spender can transfer a given token ID

     * @param spender address of the spender to query

     * @param tokenId uint256 ID of the token to be transferred

     * @return bool whether the msg.sender is approved for the given token ID,

     * is an operator of the owner, or is the owner of the token

     */

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {

        address owner = ownerOf(tokenId);

        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));

    }



    /**

     * @dev Internal function to mint a new token

     * Reverts if the given token ID already exists

     * @param to The address that will own the minted token

     * @param tokenId uint256 ID of the token to be minted

     */

    function _mint(address to, uint256 tokenId) internal {

        require(to != address(0));

        require(!_exists(tokenId));



        _tokenOwner[tokenId] = to;

        _ownedTokensCount[to].increment();



        emit Transfer(address(0), to, tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead.

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(address owner, uint256 tokenId) internal {

        require(ownerOf(tokenId) == owner);



        _clearApproval(tokenId);



        _ownedTokensCount[owner].decrement();

        _tokenOwner[tokenId] = address(0);



        emit Transfer(owner, address(0), tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(uint256 tokenId) internal {

        _burn(ownerOf(tokenId), tokenId);

    }



    /**

     * @dev Internal function to transfer ownership of a given token ID to another address.

     * As opposed to transferFrom, this imposes no restrictions on msg.sender.

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _transferFrom(address from, address to, uint256 tokenId) internal {

        require(ownerOf(tokenId) == from);

        require(to != address(0));



        _clearApproval(tokenId);



        _ownedTokensCount[from].decrement();

        _ownedTokensCount[to].increment();



        _tokenOwner[tokenId] = to;



        emit Transfer(from, to, tokenId);

    }



    /**

     * @dev Internal function to invoke `onERC721Received` on a target address

     * The call is not executed if the target address is not a contract

     * @param from address representing the previous owner of the given token ID

     * @param to target address that will receive the tokens

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes optional data to send along with the call

     * @return bool whether the call correctly returned the expected magic value

     */

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)

        internal returns (bool)

    {

        if (!to.isContract()) {

            return true;

        }



        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);

        return (retval == _ERC721_RECEIVED);

    }



    /**

     * @dev Private function to clear current approval of a given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _clearApproval(uint256 tokenId) private {

        if (_tokenApprovals[tokenId] != address(0)) {

            _tokenApprovals[tokenId] = address(0);

        }

    }

}



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

        _;

    }

}



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



contract ExitNFT is ERC721 {

    Registry internal registry;



    modifier onlyWithdrawManager() {

        require(

            msg.sender == registry.getWithdrawManagerAddress(),

            "UNAUTHORIZED_WITHDRAW_MANAGER_ONLY"

        );

        _;

    }



    constructor(address _registry) public {

        registry = Registry(_registry);

    }



    function mint(address _owner, uint256 _tokenId)

        external

        onlyWithdrawManager

    {

        _mint(_owner, _tokenId);

    }



    function burn(uint256 _tokenId) external onlyWithdrawManager {

        _burn(_tokenId);

    }



    function exists(uint256 tokenId) public view returns (bool) {

        return _exists(tokenId);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ExitPayloadReader.sol
File type: .sol
pragma solidity ^0.8.0;



import {RLPReader} from "./RLPReader.sol";



library ExitPayloadReader {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    uint8 constant WORD_SIZE = 32;



    struct ExitPayload {

        RLPReader.RLPItem[] data;

    }



    struct Receipt {

        RLPReader.RLPItem[] data;

        bytes raw;

        uint256 logIndex;

    }



    struct Log {

        RLPReader.RLPItem data;

        RLPReader.RLPItem[] list;

    }



    struct LogTopics {

        RLPReader.RLPItem[] data;

    }



    // copy paste of private copy() from RLPReader to avoid changing of existing contracts

    function copy(

        uint256 src,

        uint256 dest,

        uint256 len

    ) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint256 mask = 256**(WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }



    function toExitPayload(bytes memory data) internal pure returns (ExitPayload memory) {

        RLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();



        return ExitPayload(payloadData);

    }



    function getHeaderNumber(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[0].toUint();

    }



    function getBlockProof(ExitPayload memory payload) internal pure returns (bytes memory) {

        return payload.data[1].toBytes();

    }



    function getBlockNumber(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[2].toUint();

    }



    function getBlockTime(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[3].toUint();

    }



    function getTxRoot(ExitPayload memory payload) internal pure returns (bytes32) {

        return bytes32(payload.data[4].toUint());

    }



    function getReceiptRoot(ExitPayload memory payload) internal pure returns (bytes32) {

        return bytes32(payload.data[5].toUint());

    }



    function getReceipt(ExitPayload memory payload) internal pure returns (Receipt memory receipt) {

        receipt.raw = payload.data[6].toBytes();

        RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();



        if (receiptItem.isList()) {

            // legacy tx

            receipt.data = receiptItem.toList();

        } else {

            // pop first byte before parsting receipt

            bytes memory typedBytes = receipt.raw;

            bytes memory result = new bytes(typedBytes.length - 1);

            uint256 srcPtr;

            uint256 destPtr;

            assembly {

                srcPtr := add(33, typedBytes)

                destPtr := add(0x20, result)

            }



            copy(srcPtr, destPtr, result.length);

            receipt.data = result.toRlpItem().toList();

        }



        receipt.logIndex = getReceiptLogIndex(payload);

        return receipt;

    }



    function getReceiptProof(ExitPayload memory payload) internal pure returns (bytes memory) {

        return payload.data[7].toBytes();

    }



    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns (bytes memory) {

        return payload.data[8].toBytes();

    }



    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[8].toUint();

    }



    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[9].toUint();

    }



    // Receipt methods

    function toBytes(Receipt memory receipt) internal pure returns (bytes memory) {

        return receipt.raw;

    }



    function getLog(Receipt memory receipt) internal pure returns (Log memory) {

        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];

        return Log(logData, logData.toList());

    }



    // Log methods

    function getEmitter(Log memory log) internal pure returns (address) {

        return RLPReader.toAddress(log.list[0]);

    }



    function getTopics(Log memory log) internal pure returns (LogTopics memory) {

        return LogTopics(log.list[1].toList());

    }



    function getData(Log memory log) internal pure returns (bytes memory) {

        return log.list[2].toBytes();

    }



    function toRlpBytes(Log memory log) internal pure returns (bytes memory) {

        return log.data.toRlpBytes();

    }



    // LogTopics methods

    function getField(LogTopics memory topics, uint256 index) internal pure returns (RLPReader.RLPItem memory) {

        return topics.data[index];

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\FxBaseRootTunnel.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {RLPReader} from "../lib/RLPReader.sol";

import {MerklePatriciaProof} from "../lib/MerklePatriciaProof.sol";

import {Merkle} from "../lib/Merkle.sol";

import "../lib/ExitPayloadReader.sol";



interface IFxStateSender {

    function sendMessageToChild(address _receiver, bytes calldata _data) external;

}



contract ICheckpointManager {

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }



    /**

     * @notice mapping of checkpoint header numbers to block details

     * @dev These checkpoints are submited by plasma contracts

     */

    mapping(uint256 => HeaderBlock) public headerBlocks;

}



abstract contract FxBaseRootTunnel {

    using RLPReader for RLPReader.RLPItem;

    using Merkle for bytes32;

    using ExitPayloadReader for bytes;

    using ExitPayloadReader for ExitPayloadReader.ExitPayload;

    using ExitPayloadReader for ExitPayloadReader.Log;

    using ExitPayloadReader for ExitPayloadReader.LogTopics;

    using ExitPayloadReader for ExitPayloadReader.Receipt;



    // keccak256(MessageSent(bytes))

    bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;



    // state sender contract

    IFxStateSender public fxRoot;

    // root chain manager

    ICheckpointManager public checkpointManager;

    // child tunnel contract which receives and sends messages

    address public fxChildTunnel;



    // storage to avoid duplicate exits

    mapping(bytes32 => bool) public processedExits;



    constructor(address _checkpointManager, address _fxRoot) {

        checkpointManager = ICheckpointManager(_checkpointManager);

        fxRoot = IFxStateSender(_fxRoot);

    }



    // set fxChildTunnel if not set already

    function setFxChildTunnel(address _fxChildTunnel) public virtual {

        require(fxChildTunnel == address(0x0), "FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET");

        fxChildTunnel = _fxChildTunnel;

    }



    /**

     * @notice Send bytes message to Child Tunnel

     * @param message bytes message that will be sent to Child Tunnel

     * some message examples -

     *   abi.encode(tokenId);

     *   abi.encode(tokenId, tokenMetadata);

     *   abi.encode(messageType, messageData);

     */

    function _sendMessageToChild(bytes memory message) internal {

        fxRoot.sendMessageToChild(fxChildTunnel, message);

    }



    function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {

        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();



        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();

        uint256 blockNumber = payload.getBlockNumber();

        // checking if exit has already been processed

        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)

        bytes32 exitHash = keccak256(

            abi.encodePacked(

                blockNumber,

                // first 2 nibbles are dropped while generating nibble array

                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)

                // so converting to nibble array and then hashing it

                MerklePatriciaProof._getNibbleArray(branchMaskBytes),

                payload.getReceiptLogIndex()

            )

        );

        require(processedExits[exitHash] == false, "FxRootTunnel: EXIT_ALREADY_PROCESSED");

        processedExits[exitHash] = true;



        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();

        ExitPayloadReader.Log memory log = receipt.getLog();



        // check child tunnel

        require(fxChildTunnel == log.getEmitter(), "FxRootTunnel: INVALID_FX_CHILD_TUNNEL");



        bytes32 receiptRoot = payload.getReceiptRoot();

        // verify receipt inclusion

        require(

            MerklePatriciaProof.verify(receipt.toBytes(), branchMaskBytes, payload.getReceiptProof(), receiptRoot),

            "FxRootTunnel: INVALID_RECEIPT_PROOF"

        );



        // verify checkpoint inclusion

        _checkBlockMembershipInCheckpoint(

            blockNumber,

            payload.getBlockTime(),

            payload.getTxRoot(),

            receiptRoot,

            payload.getHeaderNumber(),

            payload.getBlockProof()

        );



        ExitPayloadReader.LogTopics memory topics = log.getTopics();



        require(

            bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig

            "FxRootTunnel: INVALID_SIGNATURE"

        );



        // received message data

        bytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message

        return message;

    }



    function _checkBlockMembershipInCheckpoint(

        uint256 blockNumber,

        uint256 blockTime,

        bytes32 txRoot,

        bytes32 receiptRoot,

        uint256 headerNumber,

        bytes memory blockProof

    ) private view returns (uint256) {

        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = checkpointManager.headerBlocks(headerNumber);



        require(

            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(

                blockNumber - startBlock,

                headerRoot,

                blockProof

            ),

            "FxRootTunnel: INVALID_HEADER"

        );

        return createdAt;

    }



    /**

     * @notice receive message from  L2 to L1, validated by proof

     * @dev This function verifies if the transaction actually happened on child chain

     *

     * @param inputData RLP encoded data of the reference tx containing following list of fields

     *  0 - headerNumber - Checkpoint header block number containing the reference tx

     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root

     *  2 - blockNumber - Block number containing the reference tx on child chain

     *  3 - blockTime - Reference tx block time

     *  4 - txRoot - Transactions root of block

     *  5 - receiptRoot - Receipts root of block

     *  6 - receipt - Receipt of the reference transaction

     *  7 - receiptProof - Merkle proof of the reference receipt

     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree

     *  9 - receiptLogIndex - Log Index to read from the receipt

     */

    function receiveMessage(bytes memory inputData) public virtual {

        bytes memory message = _validateAndExtractMessage(inputData);

        _processMessageFromChild(message);

    }



    /**

     * @notice Process message received from Child Tunnel

     * @dev function needs to be implemented to handle message as per requirement

     * This is called by onStateReceive function.

     * Since it is called via a system call, any event will not be emitted during its execution.

     * @param message bytes message that was sent from Child Tunnel

     */

    function _processMessageFromChild(bytes memory message) internal virtual;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\FxERC1155RootTunnel.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {ERC1155} from "../../lib/ERC1155.sol";

import {ERC1155Holder} from "../../lib/ERC1155Holder.sol";

import {Create2} from "../../lib/Create2.sol";

import {FxBaseRootTunnel} from "../../tunnel/FxBaseRootTunnel.sol";



contract FxERC1155RootTunnel is FxBaseRootTunnel, Create2, ERC1155Holder {

    bytes32 public constant DEPOSIT = keccak256("DEPOSIT");

    bytes32 public constant DEPOSIT_BATCH = keccak256("DEPOSIT_BATCH");

    bytes32 public constant WITHDRAW = keccak256("WITHDRAW");

    bytes32 public constant WITHDRAW_BATCH = keccak256("WITHDRAW_BATCH");

    bytes32 public constant MAP_TOKEN = keccak256("MAP_TOKEN");



    event TokenMappedERC1155(address indexed rootToken, address indexed childToken);

    event FxWithdrawERC1155(

        address indexed rootToken,

        address indexed childToken,

        address indexed userAddress,

        uint256 id,

        uint256 amount

    );

    event FxDepositERC1155(

        address indexed rootToken,

        address indexed depositor,

        address indexed userAddress,

        uint256 id,

        uint256 amount

    );

    event FxWithdrawBatchERC1155(

        address indexed rootToken,

        address indexed childToken,

        address indexed userAddress,

        uint256[] ids,

        uint256[] amounts

    );

    event FxDepositBatchERC1155(

        address indexed rootToken,

        address indexed userAddress,

        uint256[] ids,

        uint256[] amounts

    );



    mapping(address => address) public rootToChildTokens;

    bytes32 public childTokenTemplateCodeHash;



    constructor(

        address _checkpointManager,

        address _fxRoot,

        address _fxERC1155Token

    ) FxBaseRootTunnel(_checkpointManager, _fxRoot) {

        childTokenTemplateCodeHash = keccak256(minimalProxyCreationCode(_fxERC1155Token));

    }



    function mapToken(address rootToken) public {

        require(rootToChildTokens[rootToken] == address(0x0), "FxERC1155RootTunnel: ALREADY_MAPPED");



        ERC1155 rootTokenContract = ERC1155(rootToken);

        string memory uri = rootTokenContract.uri(0); //token Id?



        // MAP_TOKEN, encode(rootToken,uri)

        bytes memory message = abi.encode(MAP_TOKEN, abi.encode(rootToken, uri));

        _sendMessageToChild(message);



        // compute child token address before deployment using create2

        bytes32 salt = keccak256(abi.encodePacked(rootToken));

        address childToken = computedCreate2Address(salt, childTokenTemplateCodeHash, fxChildTunnel);



        // add into mapped tokens

        rootToChildTokens[rootToken] = childToken;

        emit TokenMappedERC1155(rootToken, childToken);

    }



    function deposit(

        address rootToken,

        address user,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) public {

        // map token if not mapped

        if (rootToChildTokens[rootToken] == address(0x0)) {

            mapToken(rootToken);

        }



        // transfer from depositor to this contract

        ERC1155(rootToken).safeTransferFrom(

            msg.sender, // depositor

            address(this), // manager contract

            id,

            amount,

            data

        );



        // DEPOSIT, encode(rootToken, depositor, user, id, amount, extra data)

        bytes memory message = abi.encode(DEPOSIT, abi.encode(rootToken, msg.sender, user, id, amount, data));

        _sendMessageToChild(message);

        emit FxDepositERC1155(rootToken, msg.sender, user, id, amount);

    }



    function depositBatch(

        address rootToken,

        address user,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) public {

        // map token if not mapped

        if (rootToChildTokens[rootToken] == address(0x0)) {

            mapToken(rootToken);

        }



        // transfer from depositor to this contract

        ERC1155(rootToken).safeBatchTransferFrom(

            msg.sender, // depositor

            address(this), // manager contract

            ids,

            amounts,

            data

        );



        // DEPOSIT_BATCH, encode(rootToken, depositor, user, id, amount, extra data)

        bytes memory message = abi.encode(DEPOSIT_BATCH, abi.encode(rootToken, msg.sender, user, ids, amounts, data));

        _sendMessageToChild(message);

        emit FxDepositBatchERC1155(rootToken, user, ids, amounts);

    }



    function _processMessageFromChild(bytes memory data) internal override {

        (bytes32 syncType, bytes memory syncData) = abi.decode(data, (bytes32, bytes));



        if (syncType == WITHDRAW) {

            _syncWithdraw(syncData);

        } else if (syncType == WITHDRAW_BATCH) {

            _syncBatchWithdraw(syncData);

        } else {

            revert("FxERC1155RootTunnel: INVALID_SYNC_TYPE");

        }

    }



    function _syncWithdraw(bytes memory syncData) internal {

        (address rootToken, address childToken, address user, uint256 id, uint256 amount, bytes memory data) = abi

            .decode(syncData, (address, address, address, uint256, uint256, bytes));

        require(rootToChildTokens[rootToken] == childToken, "FxERC1155RootTunnel: INVALID_MAPPING_ON_EXIT");

        ERC1155(rootToken).safeTransferFrom(address(this), user, id, amount, data);

        emit FxWithdrawERC1155(rootToken, childToken, user, id, amount);

    }



    function _syncBatchWithdraw(bytes memory syncData) internal {

        (

            address rootToken,

            address childToken,

            address user,

            uint256[] memory ids,

            uint256[] memory amounts,

            bytes memory data

        ) = abi.decode(syncData, (address, address, address, uint256[], uint256[], bytes));

        require(rootToChildTokens[rootToken] == childToken, "FxERC1155RootTunnel: INVALID_MAPPING_ON_EXIT");

        ERC1155(rootToken).safeBatchTransferFrom(address(this), user, ids, amounts, data);

        emit FxWithdrawBatchERC1155(rootToken, childToken, user, ids, amounts);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\FxERC20RootTunnel.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {ERC20} from "../../lib/ERC20.sol";

import {Create2} from "../../lib/Create2.sol";

import {IRootChainManager} from "../../lib/IRootChainManager.sol";

import {FxBaseRootTunnel} from "../../tunnel/FxBaseRootTunnel.sol";

import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



/**

 * @title FxERC20RootTunnel

 */

contract FxERC20RootTunnel is FxBaseRootTunnel, Create2 {

    using SafeERC20 for IERC20;

    // maybe DEPOSIT and MAP_TOKEN can be reduced to bytes4

    bytes32 public constant DEPOSIT = keccak256("DEPOSIT");

    bytes32 public constant MAP_TOKEN = keccak256("MAP_TOKEN");

    bytes32 public immutable childTokenTemplateCodeHash;

    IRootChainManager public immutable rootChainManager;



    event TokenMappedERC20(address indexed rootToken, address indexed childToken);

    event FxWithdrawERC20(

        address indexed rootToken,

        address indexed childToken,

        address indexed userAddress,

        uint256 amount

    );

    event FxDepositERC20(

        address indexed rootToken,

        address indexed depositor,

        address indexed userAddress,

        uint256 amount

    );



    mapping(address => address) public rootToChildTokens;



    constructor(

        address _checkpointManager,

        address _fxRoot,

        address _fxERC20Token,

        IRootChainManager _rootChainManager

    ) FxBaseRootTunnel(_checkpointManager, _fxRoot) {

        rootChainManager = _rootChainManager;

        // compute child token template code hash

        childTokenTemplateCodeHash = keccak256(minimalProxyCreationCode(_fxERC20Token));

    }



    /**

     * @notice Map a token to enable its movement via the PoS Portal, callable only by mappers

     * @param rootToken address of token on root chain

     */

    function mapToken(address rootToken) public {

        // check if token is already mapped

        require(rootToChildTokens[rootToken] == address(0x0), "FxERC20RootTunnel: ALREADY_MAPPED");

        require(rootChainManager.rootToChildToken(rootToken) == address(0x0), "FxERC20RootTunnel: MAPPED_ON_POS");



        // name, symbol and decimals

        ERC20 rootTokenContract = ERC20(rootToken);

        string memory name = rootTokenContract.name();

        string memory symbol = rootTokenContract.symbol();

        uint8 decimals = rootTokenContract.decimals();



        // MAP_TOKEN, encode(rootToken, name, symbol, decimals)

        bytes memory message = abi.encode(MAP_TOKEN, abi.encode(rootToken, name, symbol, decimals));

        _sendMessageToChild(message);



        // compute child token address before deployment using create2

        bytes32 salt = keccak256(abi.encodePacked(rootToken));

        address childToken = computedCreate2Address(salt, childTokenTemplateCodeHash, fxChildTunnel);



        // add into mapped tokens

        rootToChildTokens[rootToken] = childToken;

        emit TokenMappedERC20(rootToken, childToken);

    }



    function deposit(

        address rootToken,

        address user,

        uint256 amount,

        bytes memory data

    ) public {

        // map token if not mapped

        if (rootToChildTokens[rootToken] == address(0x0)) {

            mapToken(rootToken);

        }



        // transfer from depositor to this contract

        IERC20(rootToken).safeTransferFrom(

            msg.sender, // depositor

            address(this), // manager contract

            amount

        );



        // DEPOSIT, encode(rootToken, depositor, user, amount, extra data)

        bytes memory message = abi.encode(DEPOSIT, abi.encode(rootToken, msg.sender, user, amount, data));

        _sendMessageToChild(message);

        emit FxDepositERC20(rootToken, msg.sender, user, amount);

    }



    // exit processor

    function _processMessageFromChild(bytes memory data) internal override {

        (address rootToken, address childToken, address to, uint256 amount) = abi.decode(

            data,

            (address, address, address, uint256)

        );

        // validate mapping for root to child

        require(rootToChildTokens[rootToken] == childToken, "FxERC20RootTunnel: INVALID_MAPPING_ON_EXIT");



        // transfer from tokens to

        IERC20(rootToken).safeTransfer(to, amount);

        emit FxWithdrawERC20(rootToken, childToken, to, amount);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\FxERC721RootTunnel.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {ERC721} from "../../lib/ERC721.sol";

import {Create2} from "../../lib/Create2.sol";

import {FxBaseRootTunnel} from "../../tunnel/FxBaseRootTunnel.sol";

import {IERC721Receiver} from "../../lib/IERC721Receiver.sol";



/**

 * @title FxERC721RootTunnel

 */

contract FxERC721RootTunnel is FxBaseRootTunnel, Create2, IERC721Receiver {

    // maybe DEPOSIT and MAP_TOKEN can be reduced to bytes4

    bytes32 public constant DEPOSIT = keccak256("DEPOSIT");

    bytes32 public constant MAP_TOKEN = keccak256("MAP_TOKEN");



    event TokenMappedERC721(address indexed rootToken, address indexed childToken);

    event FxWithdrawERC721(

        address indexed rootToken,

        address indexed childToken,

        address indexed userAddress,

        uint256 id

    );

    event FxDepositERC721(

        address indexed rootToken,

        address indexed depositor,

        address indexed userAddress,

        uint256 id

    );



    mapping(address => address) public rootToChildTokens;

    bytes32 public childTokenTemplateCodeHash;



    constructor(

        address _checkpointManager,

        address _fxRoot,

        address _fxERC721Token

    ) FxBaseRootTunnel(_checkpointManager, _fxRoot) {

        // compute child token template code hash

        childTokenTemplateCodeHash = keccak256(minimalProxyCreationCode(_fxERC721Token));

    }



    function onERC721Received(

        address, /* operator */

        address, /* from */

        uint256, /* tokenId */

        bytes calldata /* data */

    ) external pure override returns (bytes4) {

        return this.onERC721Received.selector;

    }



    /**

     * @notice Map a token to enable its movement via the PoS Portal, callable only by mappers

     * @param rootToken address of token on root chain

     */

    function mapToken(address rootToken) public {

        // check if token is already mapped

        require(rootToChildTokens[rootToken] == address(0x0), "FxERC721RootTunnel: ALREADY_MAPPED");



        // name, symbol

        ERC721 rootTokenContract = ERC721(rootToken);

        string memory name = rootTokenContract.name();

        string memory symbol = rootTokenContract.symbol();



        // MAP_TOKEN, encode(rootToken, name, symbol)

        bytes memory message = abi.encode(MAP_TOKEN, abi.encode(rootToken, name, symbol));

        _sendMessageToChild(message);



        // compute child token address before deployment using create2

        bytes32 salt = keccak256(abi.encodePacked(rootToken));

        address childToken = computedCreate2Address(salt, childTokenTemplateCodeHash, fxChildTunnel);



        // add into mapped tokens

        rootToChildTokens[rootToken] = childToken;

        emit TokenMappedERC721(rootToken, childToken);

    }



    function deposit(

        address rootToken,

        address user,

        uint256 tokenId,

        bytes memory data

    ) public {

        // map token if not mapped

        if (rootToChildTokens[rootToken] == address(0x0)) {

            mapToken(rootToken);

        }



        // transfer from depositor to this contract

        ERC721(rootToken).safeTransferFrom(

            msg.sender, // depositor

            address(this), // manager contract

            tokenId,

            data

        );



        // DEPOSIT, encode(rootToken, depositor, user, tokenId, extra data)

        bytes memory message = abi.encode(DEPOSIT, abi.encode(rootToken, msg.sender, user, tokenId, data));

        _sendMessageToChild(message);

        emit FxDepositERC721(rootToken, msg.sender, user, tokenId);

    }



    // exit processor

    function _processMessageFromChild(bytes memory data) internal override {

        (address rootToken, address childToken, address to, uint256 tokenId, bytes memory syncData) = abi.decode(

            data,

            (address, address, address, uint256, bytes)

        );

        // validate mapping for root to child

        require(rootToChildTokens[rootToken] == childToken, "FxERC721RootTunnel: INVALID_MAPPING_ON_EXIT");



        // transfer from tokens to

        ERC721(rootToken).safeTransferFrom(address(this), to, tokenId, syncData);

        emit FxWithdrawERC721(rootToken, childToken, to, tokenId);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\FxMintableERC1155RootTunnel.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {IFxERC1155} from "../../tokens/IFxERC1155.sol";

import {ERC1155Holder} from "../../lib/ERC1155Holder.sol";

import {Create2} from "../../lib/Create2.sol";

import {FxBaseRootTunnel} from "../../tunnel/FxBaseRootTunnel.sol";

import {Address} from "../../lib/Address.sol";



contract FxMintableERC1155RootTunnel is FxBaseRootTunnel, Create2, ERC1155Holder {

    bytes32 public constant DEPOSIT = keccak256("DEPOSIT");

    bytes32 public constant DEPOSIT_BATCH = keccak256("DEPOSIT_BATCH");

    bytes32 public constant WITHDRAW = keccak256("WITHDRAW");

    bytes32 public constant WITHDRAW_BATCH = keccak256("WITHDRAW_BATCH");



    event TokenMappedMintableERC1155(address indexed rootToken, address indexed childToken);

    event FxWithdrawMintableERC1155(

        address indexed rootToken,

        address indexed childToken,

        address indexed userAddress,

        uint256 id,

        uint256 amount

    );

    event FxDepositMintableERC1155(

        address indexed rootToken,

        address indexed depositor,

        address indexed userAddress,

        uint256 id,

        uint256 amount

    );

    event FxWithdrawBatchMintableERC1155(

        address indexed rootToken,

        address indexed childToken,

        address indexed userAddress,

        uint256[] ids,

        uint256[] amounts

    );

    event FxDepositBatchMintableERC1155(

        address indexed rootToken,

        address indexed userAddress,

        uint256[] ids,

        uint256[] amounts

    );



    mapping(address => address) public rootToChildTokens;

    address public immutable rootTokenTemplate;



    constructor(

        address _checkpointManager,

        address _fxRoot,

        address _rootTokenTemplate

    ) FxBaseRootTunnel(_checkpointManager, _fxRoot) {

        rootTokenTemplate = _rootTokenTemplate;

    }



    function deposit(

        address rootToken,

        address user,

        uint256 id,

        uint256 amount,

        bytes calldata data

    ) public {

        require(rootToChildTokens[rootToken] != address(0x0), "FxMintableERC1155RootTunnel: NO_MAPPING_FOUND");



        // transfer from depositor to this contract

        IFxERC1155(rootToken).safeTransferFrom(

            msg.sender, // depositor

            address(this), // manager contract

            id,

            amount,

            data

        );



        // DEPOSIT, encode(rootToken, depositor, user, id, amount, extra data)

        _sendMessageToChild(abi.encode(DEPOSIT, abi.encode(rootToken, msg.sender, user, id, amount, data)));

        emit FxDepositMintableERC1155(rootToken, msg.sender, user, id, amount);

    }



    function depositBatch(

        address rootToken,

        address user,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) public {

        require(rootToChildTokens[rootToken] != address(0x0), "FxMintableERC1155RootTunnel: NO_MAPPING_FOUND");



        // transfer from depositor to this contract

        IFxERC1155(rootToken).safeBatchTransferFrom(

            msg.sender, // depositor

            address(this), // manager contract

            ids,

            amounts,

            data

        );



        // DEPOSIT_BATCH, encode(rootToken, depositor, user, id, amount, extra data)

        _sendMessageToChild(abi.encode(DEPOSIT_BATCH, abi.encode(rootToken, msg.sender, user, ids, amounts, data)));

        emit FxDepositBatchMintableERC1155(rootToken, user, ids, amounts);

    }



    function _processMessageFromChild(bytes memory data) internal override {

        (bytes32 syncType, bytes memory syncData) = abi.decode(data, (bytes32, bytes));



        if (syncType == WITHDRAW) {

            _syncWithdraw(syncData);

        } else if (syncType == WITHDRAW_BATCH) {

            _syncBatchWithdraw(syncData);

        } else {

            revert("FxMintableERC1155RootTunnel: INVALID_SYNC_TYPE");

        }

    }



    function _syncWithdraw(bytes memory syncData) internal {

        (

            address rootToken,

            address childToken,

            address user,

            uint256 id,

            uint256 amount,

            bytes memory data,

            string memory metadata

        ) = abi.decode(syncData, (address, address, address, uint256, uint256, bytes, string));

        // if root token is not available, create it

        if (!Address.isContract(rootToken) && rootToChildTokens[rootToken] == address(0x0)) {

            _deployRootToken(rootToken, metadata);

        }

        require(rootToChildTokens[rootToken] == childToken, "FxMintableERC1155RootTunnel: INVALID_MAPPING_ON_EXIT");

        IFxERC1155(rootToken).safeTransferFrom(address(this), user, id, amount, data);

        emit FxWithdrawMintableERC1155(rootToken, childToken, user, id, amount);

    }



    function _syncBatchWithdraw(bytes memory syncData) internal {

        (

            address rootToken,

            address childToken,

            address user,

            uint256[] memory ids,

            uint256[] memory amounts,

            bytes memory data,

            string memory metadata

        ) = abi.decode(syncData, (address, address, address, uint256[], uint256[], bytes, string));

        // if root token is not available, create it

        if (!Address.isContract(rootToken) && rootToChildTokens[rootToken] == address(0x0)) {

            _deployRootToken(rootToken, metadata);

        }

        require(rootToChildTokens[rootToken] == childToken, "FxMintableERC1155RootTunnel: INVALID_MAPPING_ON_EXIT");

        IFxERC1155(rootToken).safeBatchTransferFrom(address(this), user, ids, amounts, data);

        emit FxWithdrawBatchMintableERC1155(rootToken, childToken, user, ids, amounts);

    }



    function _deployRootToken(address childToken, string memory uri) internal {

        // deploy new root token

        bytes32 salt = keccak256(abi.encodePacked(childToken));

        address rootToken = createClone(salt, rootTokenTemplate);

        IFxERC1155(rootToken).initialize(address(this), childToken, uri);



        // add into mapped tokens

        rootToChildTokens[rootToken] = childToken;

        emit TokenMappedMintableERC1155(rootToken, childToken);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\FxMintableERC20RootTunnel.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {Create2} from "../../lib/Create2.sol";

import {IFxERC20} from "../../tokens/IFxERC20.sol";

import {FxBaseRootTunnel} from "../../tunnel/FxBaseRootTunnel.sol";

import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import {Address} from "../../lib/Address.sol";



/**

 * @title FxMintableERC20RootTunnel

 */

contract FxMintableERC20RootTunnel is FxBaseRootTunnel, Create2 {

    using SafeERC20 for IERC20;



    bytes32 public constant DEPOSIT = keccak256("DEPOSIT");



    mapping(address => address) public rootToChildTokens;

    address public immutable rootTokenTemplate;



    event FxWithdrawMintableERC20(

        address indexed rootToken,

        address indexed childToken,

        address indexed userAddress,

        uint256 amount

    );

    event FxDepositMintableERC20(

        address indexed rootToken,

        address indexed depositor,

        address indexed userAddress,

        uint256 amount

    );



    constructor(

        address _checkpointManager,

        address _fxRoot,

        address _rootTokenTemplate

    ) FxBaseRootTunnel(_checkpointManager, _fxRoot) {

        rootTokenTemplate = _rootTokenTemplate;

    }



    function deposit(

        address rootToken,

        address user,

        uint256 amount,

        bytes calldata data

    ) public {

        // map token if not mapped

        require(rootToChildTokens[rootToken] != address(0x0), "FxMintableERC20RootTunnel: NO_MAPPING_FOUND");



        // transfer from depositor to this contract

        IERC20(rootToken).safeTransferFrom(

            msg.sender, // depositor

            address(this), // manager contract

            amount

        );



        // DEPOSIT, encode(rootToken, depositor, user, amount, extra data)

        bytes memory message = abi.encode(DEPOSIT, abi.encode(rootToken, msg.sender, user, amount, data));

        _sendMessageToChild(message);



        emit FxDepositMintableERC20(rootToken, msg.sender, user, amount);

    }



    // exit processor

    function _processMessageFromChild(bytes memory data) internal override {

        (address rootToken, address childToken, address to, uint256 amount, bytes memory metaData) = abi.decode(

            data,

            (address, address, address, uint256, bytes)

        );



        // if root token is not available, create it

        if (!Address.isContract(rootToken) && rootToChildTokens[rootToken] == address(0x0)) {

            (string memory name, string memory symbol, uint8 decimals) = abi.decode(metaData, (string, string, uint8));



            address _createdToken = _deployRootToken(childToken, name, symbol, decimals);

            require(_createdToken == rootToken, "FxMintableERC20RootTunnel: ROOT_TOKEN_CREATION_MISMATCH");

        }



        // validate mapping for root to child

        require(rootToChildTokens[rootToken] == childToken, "FxERC20RootTunnel: INVALID_MAPPING_ON_EXIT");



        // check if current balance for token is less than amount,

        // mint remaining amount for this address

        IFxERC20 tokenObj = IFxERC20(rootToken);

        uint256 balanceOf = tokenObj.balanceOf(address(this));

        if (balanceOf < amount) {

            tokenObj.mint(address(this), amount - balanceOf);

        }



        //approve token transfer

        tokenObj.approve(address(this), amount);



        // transfer from tokens

        IERC20(rootToken).safeTransferFrom(address(this), to, amount);



        emit FxWithdrawMintableERC20(rootToken, childToken, to, amount);

    }



    function _deployRootToken(

        address childToken,

        string memory name,

        string memory symbol,

        uint8 decimals

    ) internal returns (address) {

        // deploy new root token

        bytes32 salt = keccak256(abi.encodePacked(childToken));

        address rootToken = createClone(salt, rootTokenTemplate);

        IFxERC20(rootToken).initialize(address(this), childToken, name, symbol, decimals);



        // add into mapped tokens

        rootToChildTokens[rootToken] = childToken;



        return rootToken;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\FxMintableERC721RootTunnel.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {IFxERC721} from "../../tokens/IFxERC721.sol";

import {Create2} from "../../lib/Create2.sol";

import {FxBaseRootTunnel} from "../../tunnel/FxBaseRootTunnel.sol";

import {IERC721Receiver} from "../../lib/IERC721Receiver.sol";

import {Address} from "../../lib/Address.sol";



/**

 * @title FxMintableERC721RootTunnel

 */

contract FxMintableERC721RootTunnel is FxBaseRootTunnel, Create2, IERC721Receiver {

    bytes32 public constant DEPOSIT = keccak256("DEPOSIT");



    event TokenMappedMintableERC721(address indexed rootToken, address indexed childToken);

    event FxWithdrawMintableERC721(

        address indexed rootToken,

        address indexed childToken,

        address indexed userAddress,

        uint256 id

    );

    event FxDepositMintableERC721(

        address indexed rootToken,

        address indexed depositor,

        address indexed userAddress,

        uint256 id

    );



    mapping(address => address) public rootToChildTokens;

    address public immutable rootTokenTemplate;



    constructor(

        address _checkpointManager,

        address _fxRoot,

        address _rootTokenTemplate

    ) FxBaseRootTunnel(_checkpointManager, _fxRoot) {

        rootTokenTemplate = _rootTokenTemplate;

    }



    //

    // External methods

    //



    function deposit(

        address rootToken,

        address user,

        uint256 tokenId,

        bytes calldata data

    ) external {

        require(rootToChildTokens[rootToken] != address(0x0), "FxMintableERC721RootTunnel: NO_MAPPING_FOUND");



        // transfer from depositor to this contract

        IFxERC721(rootToken).safeTransferFrom(

            msg.sender, // depositor

            address(this), // manager contract

            tokenId,

            data

        );



        // DEPOSIT, encode(rootToken, depositor, user, tokenId, extra data)

        _sendMessageToChild(abi.encode(DEPOSIT, abi.encode(rootToken, msg.sender, user, tokenId, data)));

        emit FxDepositMintableERC721(rootToken, msg.sender, user, tokenId);

    }



    function onERC721Received(

        address, /* operator */

        address, /* from */

        uint256, /* tokenId */

        bytes calldata /* data */

    ) external pure override returns (bytes4) {

        return this.onERC721Received.selector;

    }



    //

    // Internal methods

    //



    // exit processor

    function _processMessageFromChild(bytes memory data) internal override {

        (

            address rootToken,

            address childToken,

            address to,

            uint256 tokenId,

            bytes memory syncData,

            bytes memory metadata

        ) = abi.decode(data, (address, address, address, uint256, bytes, bytes));

        // if root token is not available, create it

        if (!Address.isContract(rootToken) && rootToChildTokens[rootToken] == address(0x0)) {

            (string memory name, string memory symbol) = abi.decode(metadata, (string, string));

            address _createdToken = _deployRootToken(childToken, name, symbol);

            require(_createdToken == rootToken, "FxMintableERC721RootTunnel: ROOT_TOKEN_CREATION_MISMATCH");

        }



        // validate mapping for root to child

        require(rootToChildTokens[rootToken] == childToken, "FxMintableERC721RootTunnel: INVALID_MAPPING_ON_EXIT");



        // check if current token has been minted on root chain

        IFxERC721 nft = IFxERC721(rootToken);

        address currentOwner = nft.ownerOf(tokenId);

        if (currentOwner == address(0)) {

            nft.mint(address(this), tokenId, "");

        }



        // transfer from tokens to

        IFxERC721(rootToken).safeTransferFrom(address(this), to, tokenId, syncData);

        emit FxWithdrawMintableERC721(rootToken, childToken, to, tokenId);

    }



    function _deployRootToken(

        address childToken,

        string memory name,

        string memory symbol

    ) internal returns (address) {

        // deploy new root token

        bytes32 salt = keccak256(abi.encodePacked(childToken));

        address rootToken = createClone(salt, rootTokenTemplate);

        IFxERC721(rootToken).initialize(address(this), childToken, name, symbol);



        // add into mapped tokens

        rootToChildTokens[rootToken] = childToken;

        emit TokenMappedMintableERC721(rootToken, childToken);



        return rootToken;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\FxRoot.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-01-17

*/



// SPDX-License-Identifier: MIT

pragma solidity 0.7.3;





interface IStateSender {

    function syncState(address receiver, bytes calldata data) external;

}



interface IFxStateSender {

    function sendMessageToChild(address _receiver, bytes calldata _data) external;

}



/** 

 * @title FxRoot root contract for fx-portal

 */

contract FxRoot is IFxStateSender {

    IStateSender public stateSender;

    address public fxChild;



    constructor(address _stateSender) {

        stateSender = IStateSender(_stateSender);

    }



    function setFxChild(address _fxChild) public {

        require(fxChild == address(0x0));

        fxChild = _fxChild;

    }



    function sendMessageToChild(address _receiver, bytes calldata _data) public override {

        bytes memory data = abi.encode(msg.sender, _receiver, _data);

        stateSender.syncState(fxChild, data);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\Governance.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



contract ProxyStorage is Ownable {

    address internal proxyTo;

}



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



contract Governance is ProxyStorage, IGovernance {

    function update(address target, bytes memory data) public onlyOwner {

        (bool success, ) = target.call(data); /* bytes memory returnData */

        require(success, "Update failed");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\GovernanceProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



contract ProxyStorage is Ownable {

    address internal proxyTo;

}



interface ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);

    function implementation() external view returns (address codeAddr);

}



contract DelegateProxy is ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external view returns (address);



    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas, 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }

}



contract Proxy is ProxyStorage, DelegateProxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event OwnerUpdate(address _prevOwner, address _newOwner);



    constructor(address _proxyTo) public {

        updateImplementation(_proxyTo);

    }



    function() external payable {

        // require(currentContract != 0, "If app code has not been set yet, do not call");

        // Todo: filter out some calls or handle in the end fallback

        delegatedFwd(proxyTo, msg.data);

    }



    function implementation() external view returns (address) {

        return proxyTo;

    }



    function updateImplementation(address _newProxyTo) public onlyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");

        emit ProxyUpdated(_newProxyTo, proxyTo);

        proxyTo = _newProxyTo;

    }



    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



contract GovernanceProxy is Proxy {

    constructor(address _proxyTo) public Proxy(_proxyTo) {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IERC1155.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * @dev Required interface of an ERC1155 compliant contract, as defined in the

 * https://eips.ethereum.org/EIPS/eip-1155[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155 is IERC165 {

    /**

     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.

     */

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);



    /**

     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all

     * transfers.

     */

    event TransferBatch(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256[] ids,

        uint256[] values

    );



    /**

     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to

     * `approved`.

     */

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);



    /**

     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.

     *

     * If an {URI} event was emitted for `id`, the standard

     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value

     * returned by {IERC1155MetadataURI-uri}.

     */

    event URI(string value, uint256 indexed id);



    /**

     * @dev Returns the amount of tokens of token type `id` owned by `account`.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) external view returns (uint256);



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)

        external

        view

        returns (uint256[] memory);



    /**

     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,

     *

     * Emits an {ApprovalForAll} event.

     *

     * Requirements:

     *

     * - `operator` cannot be the caller.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.

     *

     * See {setApprovalForAll}.

     */

    function isApprovedForAll(address account, address operator) external view returns (bool);



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes calldata data

    ) external;



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IERC1155MetadataURI.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC1155.sol";



/**

 * @dev Interface of the optional ERC1155MetadataExtension interface, as defined

 * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155MetadataURI is IERC1155 {

    /**

     * @dev Returns the URI for token type `id`.

     *

     * If the `\{id\}` substring is present in the URI, it must be replaced by

     * clients with the actual token type ID.

     */

    function uri(uint256 id) external view returns (string memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IERC1155Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * _Available since v3.1._

 */

interface IERC1155Receiver is IERC165 {

    /**

        @dev Handles the receipt of a single ERC1155 token type. This function is

        called at the end of a `safeTransferFrom` after the balance has been updated.

        To accept the transfer, this must return

        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

        (i.e. 0xf23a6e61, or its own function selector).

        @param operator The address which initiated the transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param id The ID of the token being transferred

        @param value The amount of tokens being transferred

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed

    */

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    ) external returns (bytes4);



    /**

        @dev Handles the receipt of a multiple ERC1155 token types. This function

        is called at the end of a `safeBatchTransferFrom` after the balances have

        been updated. To accept the transfer(s), this must return

        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

        (i.e. 0xbc197c81, or its own function selector).

        @param operator The address which initiated the batch transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param ids An array containing ids of each token being transferred (order and length must match values array)

        @param values An array containing amounts of each token being transferred (order and length must match ids array)

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed

    */

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    ) external returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IERC721.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * @dev Required interface of an ERC721 compliant contract.

 */

interface IERC721 is IERC165 {

    /**

     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.

     */

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.

     */

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.

     */

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of tokens in ``owner``'s account.

     */

    function balanceOf(address owner) external view returns (uint256 balance);



    /**

     * @dev Returns the owner of the `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function ownerOf(uint256 tokenId) external view returns (address owner);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId

    ) external;



    /**

     * @dev Transfers `tokenId` token from `from` to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address from,

        address to,

        uint256 tokenId

    ) external;



    /**

     * @dev Gives permission to `to` to transfer `tokenId` token to another account.

     * The approval is cleared when the token is transferred.

     *

     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.

     *

     * Requirements:

     *

     * - The caller must own the token or be an approved operator.

     * - `tokenId` must exist.

     *

     * Emits an {Approval} event.

     */

    function approve(address to, uint256 tokenId) external;



    /**

     * @dev Returns the account approved for `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function getApproved(uint256 tokenId) external view returns (address operator);



    /**

     * @dev Approve or remove `operator` as an operator for the caller.

     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.

     *

     * Requirements:

     *

     * - The `operator` cannot be the caller.

     *

     * Emits an {ApprovalForAll} event.

     */

    function setApprovalForAll(address operator, bool _approved) external;



    /**

     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.

     *

     * See {setApprovalForAll}

     */

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId,

        bytes calldata data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IERC721Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC721.sol";



/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

interface IERC721Metadata is IERC721 {

    /**

     * @dev Returns the token collection name.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the token collection symbol.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.

     */

    function tokenURI(uint256 tokenId) external view returns (string memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IERC721Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

interface IERC721Receiver {

    /**

     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}

     * by `operator` from `from`, this function is called.

     *

     * It must return its Solidity selector to confirm the token transfer.

     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.

     *

     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.

     */

    function onERC721Received(

        address operator,

        address from,

        uint256 tokenId,

        bytes calldata data

    ) external returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IFxERC1155.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {IERC1155} from "../lib/IERC1155.sol";



interface IFxERC1155 is IERC1155 {

    function fxManager() external returns (address);



    function initialize(

        address fxManager_,

        address connectedToken_,

        string memory uri_

    ) external;



    function connectedToken() external returns (address);



    function mint(

        address user,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) external;



    function mintBatch(

        address user,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) external;



    function burn(

        address user,

        uint256 id,

        uint256 amount

    ) external;



    function burnBatch(

        address user,

        uint256[] memory ids,

        uint256[] memory amounts

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IFxERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {IERC20} from "../lib/IERC20.sol";



interface IFxERC20 is IERC20 {

    function fxManager() external returns (address);



    function connectedToken() external returns (address);



    function initialize(

        address _fxManager,

        address _connectedToken,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) external;



    function mint(address user, uint256 amount) external;



    function burn(address user, uint256 amount) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IFxERC721.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {IERC721} from "../lib/IERC721.sol";



interface IFxERC721 is IERC721 {

    function fxManager() external returns (address);



    function connectedToken() external returns (address);



    function initialize(

        address _fxManager,

        address _connectedToken,

        string memory _name,

        string memory _symbol

    ) external;



    function mint(

        address user,

        uint256 tokenId,

        bytes memory _data

    ) external;



    function burn(uint256 tokenId) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\IRootChainManager.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



/*

 * @dev Interace to provide a function from Polygon Root Chain Manager

 */

interface IRootChainManager {

    function rootToChildToken(address _rootToken) external returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\Merkle.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



library Merkle {

    function checkMembership(

        bytes32 leaf,

        uint256 index,

        bytes32 rootHash,

        bytes memory proof

    ) internal pure returns (bool) {

        require(proof.length % 32 == 0, "Invalid proof length");

        uint256 proofHeight = proof.length / 32;

        // Proof of size n means, height of the tree is n+1.

        // In a tree of height n+1, max #leafs possible is 2 ^ n

        require(index < 2**proofHeight, "Leaf index is too big");



        bytes32 proofElement;

        bytes32 computedHash = leaf;

        for (uint256 i = 32; i <= proof.length; i += 32) {

            assembly {

                proofElement := mload(add(proof, i))

            }



            if (index % 2 == 0) {

                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));

            } else {

                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));

            }



            index = index / 2;

        }

        return computedHash == rootHash;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\MerklePatriciaProof.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import {RLPReader} from "./RLPReader.sol";



library MerklePatriciaProof {

    /*

     * @dev Verifies a merkle patricia proof.

     * @param value The terminating value in the trie.

     * @param encodedPath The path in the trie leading to value.

     * @param rlpParentNodes The rlp encoded stack of nodes.

     * @param root The root hash of the trie.

     * @return The boolean validity of the proof.

     */

    function verify(

        bytes memory value,

        bytes memory encodedPath,

        bytes memory rlpParentNodes,

        bytes32 root

    ) internal pure returns (bool) {

        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);

        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);



        bytes memory currentNode;

        RLPReader.RLPItem[] memory currentNodeList;



        bytes32 nodeKey = root;

        uint256 pathPtr = 0;



        bytes memory path = _getNibbleArray(encodedPath);

        if (path.length == 0) {

            return false;

        }



        for (uint256 i = 0; i < parentNodes.length; i++) {

            if (pathPtr > path.length) {

                return false;

            }



            currentNode = RLPReader.toRlpBytes(parentNodes[i]);

            if (nodeKey != keccak256(currentNode)) {

                return false;

            }

            currentNodeList = RLPReader.toList(parentNodes[i]);



            if (currentNodeList.length == 17) {

                if (pathPtr == path.length) {

                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {

                        return true;

                    } else {

                        return false;

                    }

                }



                uint8 nextPathNibble = uint8(path[pathPtr]);

                if (nextPathNibble > 16) {

                    return false;

                }

                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));

                pathPtr += 1;

            } else if (currentNodeList.length == 2) {

                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);

                if (pathPtr + traversed == path.length) {

                    //leaf node

                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {

                        return true;

                    } else {

                        return false;

                    }

                }



                //extension node

                if (traversed == 0) {

                    return false;

                }



                pathPtr += traversed;

                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));

            } else {

                return false;

            }

        }

    }



    function _nibblesToTraverse(

        bytes memory encodedPartialPath,

        bytes memory path,

        uint256 pathPtr

    ) private pure returns (uint256) {

        uint256 len = 0;

        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath

        // and slicedPath have elements that are each one hex character (1 nibble)

        bytes memory partialPath = _getNibbleArray(encodedPartialPath);

        bytes memory slicedPath = new bytes(partialPath.length);



        // pathPtr counts nibbles in path

        // partialPath.length is a number of nibbles

        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {

            bytes1 pathNibble = path[i];

            slicedPath[i - pathPtr] = pathNibble;

        }



        if (keccak256(partialPath) == keccak256(slicedPath)) {

            len = partialPath.length;

        } else {

            len = 0;

        }

        return len;

    }



    // bytes b must be hp encoded

    function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {

        bytes memory nibbles = "";

        if (b.length > 0) {

            uint8 offset;

            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));

            if (hpNibble == 1 || hpNibble == 3) {

                nibbles = new bytes(b.length * 2 - 1);

                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);

                nibbles[0] = oddNibble;

                offset = 1;

            } else {

                nibbles = new bytes(b.length * 2 - 2);

                offset = 0;

            }



            for (uint256 i = offset; i < nibbles.length; i++) {

                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);

            }

        }

        return nibbles;

    }



    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {

        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\MintableERC1155Predicate.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2022-02-24

*/



// File: @openzeppelin/contracts/introspection/IERC165.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;





/**

 * @dev Required interface of an ERC1155 compliant contract, as defined in the

 * https://eips.ethereum.org/EIPS/eip-1155[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155 is IERC165 {

    /**

     * @dev Emitted when `value` tokens of token type `id` are transfered from `from` to `to` by `operator`.

     */

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);



    /**

     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all

     * transfers.

     */

    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);



    /**

     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to

     * `approved`.

     */

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);



    /**

     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.

     *

     * If an {URI} event was emitted for `id`, the standard

     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value

     * returned by {IERC1155MetadataURI-uri}.

     */

    event URI(string value, uint256 indexed id);



    /**

     * @dev Returns the amount of tokens of token type `id` owned by `account`.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) external view returns (uint256);



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);



    /**

     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,

     *

     * Emits an {ApprovalForAll} event.

     *

     * Requirements:

     *

     * - `operator` cannot be the caller.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.

     *

     * See {setApprovalForAll}.

     */

    function isApprovedForAll(address account, address operator) external view returns (bool);



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;

}



// File: contracts/root/RootToken/IMintableERC1155.sol



pragma solidity 0.6.6;



interface IMintableERC1155 is IERC1155 {

    /**

     * @notice Creates `amount` tokens of token type `id`, and assigns them to `account`.

     * @dev Should be callable only by MintableERC1155Predicate

     * Make sure minting is done only by this function

     * @param account user address for whom token is being minted

     * @param id token which is being minted

     * @param amount amount of token being minted

     * @param data extra byte data to be accompanied with minted tokens

     */

    function mint(address account, uint256 id, uint256 amount, bytes calldata data) external;



    /**

     * @notice Batched version of singular token minting, where

     * for each token in `ids` respective amount to be minted from `amounts`

     * array, for address `to`.

     * @dev Should be callable only by MintableERC1155Predicate

     * Make sure minting is done only by this function

     * @param to user address for whom token is being minted

     * @param ids tokens which are being minted

     * @param amounts amount of each token being minted

     * @param data extra byte data to be accompanied with minted tokens

     */

    function mintBatch(address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;

}



// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;





/**

 * _Available since v3.1._

 */

interface IERC1155Receiver is IERC165 {



    /**

        @dev Handles the receipt of a single ERC1155 token type. This function is

        called at the end of a `safeTransferFrom` after the balance has been updated.

        To accept the transfer, this must return

        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

        (i.e. 0xf23a6e61, or its own function selector).

        @param operator The address which initiated the transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param id The ID of the token being transferred

        @param value The amount of tokens being transferred

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed

    */

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    )

        external

        returns(bytes4);



    /**

        @dev Handles the receipt of a multiple ERC1155 token types. This function

        is called at the end of a `safeBatchTransferFrom` after the balances have

        been updated. To accept the transfer(s), this must return

        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

        (i.e. 0xbc197c81, or its own function selector).

        @param operator The address which initiated the batch transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param ids An array containing ids of each token being transferred (order and length must match values array)

        @param values An array containing amounts of each token being transferred (order and length must match ids array)

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed

    */

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    )

        external

        returns(bytes4);

}



// File: @openzeppelin/contracts/introspection/ERC165.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;





/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts may inherit from this and call {_registerInterface} to declare

 * their support of an interface.

 */

contract ERC165 is IERC165 {

    /*

     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7

     */

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;



    /**

     * @dev Mapping of interface ids to whether or not it's supported.

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    constructor () internal {

        // Derived contracts need only register support for their own interfaces,

        // we register support for ERC165 itself here

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     *

     * Time complexity O(1), guaranteed to always use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev Registers the contract as an implementer of the interface defined by

     * `interfaceId`. Support of the actual ERC165 interface is automatic and

     * registering its interface id is not required.

     *

     * See {IERC165-supportsInterface}.

     *

     * Requirements:

     *

     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).

     */

    function _registerInterface(bytes4 interfaceId) internal virtual {

        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");

        _supportedInterfaces[interfaceId] = true;

    }

}



// File: @openzeppelin/contracts/token/ERC1155/ERC1155Receiver.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;







/**

 * @dev _Available since v3.1._

 */

abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {

    constructor() public {

        _registerInterface(

            ERC1155Receiver(0).onERC1155Received.selector ^

            ERC1155Receiver(0).onERC1155BatchReceived.selector

        );

    }

}



// File: @openzeppelin/contracts/utils/EnumerableSet.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`

 * (`UintSet`) are supported.

 */

library EnumerableSet {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;



        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            bytes32 lastvalue = set._values[lastIndex];



            // Move the last value to the index where the value to delete is

            set._values[toDeleteIndex] = lastvalue;

            // Update the index for the moved value

            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}



// File: @openzeppelin/contracts/utils/Address.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/GSN/Context.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: @openzeppelin/contracts/access/AccessControl.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context {

    using EnumerableSet for EnumerableSet.AddressSet;

    using Address for address;



    struct RoleData {

        EnumerableSet.AddressSet members;

        bytes32 adminRole;

    }



    mapping (bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view returns (bool) {

        return _roles[role].members.contains(account);

    }



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {

        return _roles[role].members.length();

    }



    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {

        return _roles[role].members.at(index);

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");



        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");



        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (_roles[role].members.add(account)) {

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (_roles[role].members.remove(account)) {

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}



// File: contracts/common/AccessControlMixin.sol



pragma solidity 0.6.6;





contract AccessControlMixin is AccessControl {

    string private _revertMsg;

    function _setupContractId(string memory contractId) internal {

        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));

    }



    modifier only(bytes32 role) {

        require(

            hasRole(role, _msgSender()),

            _revertMsg

        );

        _;

    }

}



// File: contracts/lib/RLPReader.sol



/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol

 */

pragma solidity 0.6.6;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param the RLP item.

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

     * @param the RLP item.

     * @return (memPtr, len) pair: location of the item's payload in memory.

     */

    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {

        uint offset = _payloadOffset(item.memPtr);

        uint memPtr = item.memPtr + offset;

        uint len = item.len - offset; // data length

        return (memPtr, len);

    }



    /*

    * @param the RLP item.

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        (, uint len) = payloadLocation(item);

        return len;

    }



    /*

    * @param the RLP item containing the encoded list.

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /*

     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.

     * @return keccak256 hash of RLP encoded bytes.

     */

    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        uint256 ptr = item.memPtr;

        uint256 len = item.len;

        bytes32 result;

        assembly {

            result := keccak256(ptr, len)

        }

        return result;

    }



    /*

     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.

     * @return keccak256 hash of the item payload.

     */

    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        (uint memPtr, uint len) = payloadLocation(item);

        bytes32 result;

        assembly {

            result := keccak256(memPtr, len)

        }

        return result;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte except "0x80" is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        // SEE Github Issue #5.

        // Summary: Most commonly used RLP libraries (i.e Geth) will encode

        // "0" as "0x80" instead of as "0". We handle this edge case explicitly

        // here.

        if (result == 0 || result == STRING_SHORT_START) {

            return false;

        } else {

            return true;

        }

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        (uint memPtr, uint len) = payloadLocation(item);



        uint result;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        (uint memPtr, uint len) = payloadLocation(item);

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(memPtr, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        if (len > 0) {

            // left over bytes. Mask is used to remove unwanted bytes from the word

            uint mask = 256 ** (WORD_SIZE - len) - 1;

            assembly {

                let srcpart := and(mload(src), not(mask)) // zero out src

                let destpart := and(mload(dest), mask) // retrieve the bytes

                mstore(dest, or(destpart, srcpart))

            }

        }

    }

}



// File: contracts/root/TokenPredicates/ITokenPredicate.sol



pragma solidity 0.6.6;





/// @title Token predicate interface for all pos portal predicates

/// @notice Abstract interface that defines methods for custom predicates

interface ITokenPredicate {



    /**

     * @notice Deposit tokens into pos portal

     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on side chain

     * @param rootToken Token which gets deposited

     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external;



    /**

     * @notice Validates and processes exit while withdraw process

     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.

     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw

     * @param sender Address

     * @param rootToken Token which gets withdrawn

     * @param logRLPList Valid sidechain log for data like amount, token id etc.

     */

    function exitTokens(

        address sender,

        address rootToken,

        bytes calldata logRLPList

    ) external;

}



// File: contracts/common/Initializable.sol



pragma solidity 0.6.6;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        _;

        inited = true;

    }

}



contract MintableERC1155Predicate is

    ITokenPredicate,

    ERC1155Receiver,

    AccessControlMixin,

    Initializable

{

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

    bytes32 public constant TOKEN_TYPE = keccak256("MintableERC1155");



    bytes32 public constant TRANSFER_SINGLE_EVENT_SIG = keccak256(

        "TransferSingle(address,address,address,uint256,uint256)"

    );

    bytes32 public constant TRANSFER_BATCH_EVENT_SIG = keccak256(

        "TransferBatch(address,address,address,uint256[],uint256[])"

    );



    event LockedBatchMintableERC1155(

        address indexed depositor,

        address indexed depositReceiver,

        address indexed rootToken,

        uint256[] ids,

        uint256[] amounts

    );



    constructor() public {}



    function initialize(address _owner) external initializer {

        _setupContractId("MintableERC1155Predicate");

        _setupRole(DEFAULT_ADMIN_ROLE, _owner);

        _setupRole(MANAGER_ROLE, _owner);

    }



    /**

     * @notice rejects single transfer

     */

    function onERC1155Received(

        address,

        address,

        uint256,

        uint256,

        bytes calldata

    ) external override returns (bytes4) {

        return 0;

    }



    /**

     * @notice accepts batch transfer

     */

    function onERC1155BatchReceived(

        address,

        address,

        uint256[] calldata,

        uint256[] calldata,

        bytes calldata

    ) external override returns (bytes4) {

        return ERC1155Receiver(0).onERC1155BatchReceived.selector;

    }



    /**

     * @notice Lock ERC1155 tokens for deposit, callable only by manager

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on child chain

     * @param rootToken Token which gets deposited

     * @param depositData ABI encoded id array and amount array

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external override only(MANAGER_ROLE) {

        // forcing batch deposit since supporting both single and batch deposit introduces too much complexity

        (

            uint256[] memory ids,

            uint256[] memory amounts,

            bytes memory data

        ) = abi.decode(depositData, (uint256[], uint256[], bytes));



        emit LockedBatchMintableERC1155(

            depositor,

            depositReceiver,

            rootToken,

            ids,

            amounts

        );

        IMintableERC1155(rootToken).safeBatchTransferFrom(

            depositor,

            address(this),

            ids,

            amounts,

            data

        );

    }

    

    // Used when attempting to exit with single token, single amount/ id is converted into

    // slice of amounts/ ids

    // Generally size is going to be `1` i.e. single element array, but it's kept generic

    function makeArrayWithValue(uint256 val, uint size) internal pure returns(uint256[] memory) {

        require(

            size > 0,

            "MintableERC1155Predicate: Invalid resulting array length"

        );



        uint256[] memory vals = new uint256[](size);



        for (uint256 i = 0; i < size; i++) {

            vals[i] = val;

        }



        return vals;

    }



    /**

     * @notice Creates an array of `size` by repeating provided address,

     * to be required for passing to batch balance checking function of ERC1155 tokens.

     * @param addr Address to be repeated `size` times in resulting array

     * @param size Size of resulting array

     */

    function makeArrayWithAddress(address addr, uint256 size)

        internal

        pure

        returns (address[] memory)

    {

        require(

            addr != address(0),

            "MintableERC1155Predicate: Invalid address"

        );

        require(

            size > 0,

            "MintableERC1155Predicate: Invalid resulting array length"

        );



        address[] memory addresses = new address[](size);



        for (uint256 i = 0; i < size; i++) {

            addresses[i] = addr;

        }



        return addresses;

    }



    /**

     * @notice Calculates amount of tokens to be minted, by subtracting available

     * token balances from amount of tokens to be exited

     * @param tokenBalances Token balances this contract holds for some ordered token ids

     * @param amountsToBeExited Amount of tokens being exited

     */

    function calculateAmountsToBeMinted(

        uint256[] memory tokenBalances,

        uint256[] memory amountsToBeExited

    ) internal pure returns (uint256[] memory, uint256[] memory, bool) {

        require(

            tokenBalances.length == amountsToBeExited.length,

            "MintableERC1155Predicate: Array length mismatch found"

        );



        // all cells zero initialized

        uint256[] memory toBeMintedAmounts = new uint256[](

            tokenBalances.length

        );

        // all cells zero initialized

        uint256[] memory toBeTransferredAmounts = new uint256[](

            tokenBalances.length

        );

        bool needMintStep;



        // Iteratively calculating amounts of token to be minted/ transferred

        //

        // Please note, in some cases it can be 0, but that will not

        // be a problem, due to implementation of mint/ transfer logic for ERC1155

        for (uint256 i = 0; i < tokenBalances.length; i++) {

            if (tokenBalances[i] < amountsToBeExited[i]) {

                toBeMintedAmounts[i] = amountsToBeExited[i] - tokenBalances[i];

                toBeTransferredAmounts[i] = tokenBalances[i];

                needMintStep = true;

            } else {

                toBeTransferredAmounts[i] = amountsToBeExited[i];

            }

        }



        return (toBeMintedAmounts, toBeTransferredAmounts, needMintStep);

    }



    /**

     * @notice Validates log signature, from and to address

     * then sends the correct tokenId, amount to withdrawer

     * callable only by manager

     * @param rootToken Token which gets withdrawn

     * @param log Valid ERC1155 TransferSingle burn or TransferBatch burn log from child chain

     */

    function exitTokens(

        address,

        address rootToken,

        bytes memory log

    ) public override only(MANAGER_ROLE) {

        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();

        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics

        bytes memory logData = logRLPList[2].toBytes();



        address withdrawer = address(logTopicRLPList[2].toUint()); // topic2 is from address



        require(

            address(logTopicRLPList[3].toUint()) == address(0), // topic3 is to address

            "MintableERC1155Predicate: INVALID_RECEIVER"

        );



        bytes32 eventSig = bytes32(logTopicRLPList[0].toUint());

        if (eventSig == TRANSFER_SINGLE_EVENT_SIG) {

            (uint256 id, uint256 amount) = abi.decode(

                logData,

                (uint256, uint256)

            );



            IMintableERC1155 token = IMintableERC1155(rootToken);



            uint256 balance = token.balanceOf(address(this), id);

            if (balance < amount) {

                token.mint(withdrawer, id, amount - balance, bytes(""));



                token.safeTransferFrom(

                    address(this),

                    withdrawer,

                    id,

                    balance,

                    bytes("")

                );

            } else {

                token.safeTransferFrom(

                    address(this),

                    withdrawer,

                    id,

                    amount,

                    bytes("")

                );

            }

        } else if (eventSig == TRANSFER_BATCH_EVENT_SIG) {

            (uint256[] memory ids, uint256[] memory amounts) = abi.decode(

                logData,

                (uint256[], uint256[])

            );



            IMintableERC1155 token = IMintableERC1155(rootToken);



            uint256[] memory balances = token.balanceOfBatch(makeArrayWithAddress(address(this), ids.length), ids);

            (uint256[] memory toBeMinted, uint256[] memory toBeTransferred, bool needMintStep) = calculateAmountsToBeMinted(balances, amounts);



            if(needMintStep) {

                token.mintBatch(

                    withdrawer,

                    ids,

                    toBeMinted,

                    bytes("")

                );

            }



            token.safeBatchTransferFrom(

                address(this),

                withdrawer,

                ids,

                toBeTransferred,

                bytes("")

            );

        } else {

            revert("MintableERC1155Predicate: INVALID_WITHDRAW_SIG");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\MintableERC1155PredicateProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-02-12

*/



// File: contracts/common/Proxy/IERCProxy.sol



pragma solidity 0.6.6;



interface IERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/Proxy/Proxy.sol



pragma solidity 0.6.6;





abstract contract Proxy is IERCProxy {

    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas(), 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize()



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }



    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external virtual override view returns (address);

}



// File: contracts/common/Proxy/UpgradableProxy.sol



pragma solidity 0.6.6;





contract UpgradableProxy is Proxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event ProxyOwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setProxyOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    fallback() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    receive() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadProxyOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function proxyOwner() external view returns(address) {

        return loadProxyOwner();

    }



    function loadProxyOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external override view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferProxyOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());

        setProxyOwner(newOwner);

    }



    function setProxyOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/TokenPredicates/MintableERC1155PredicateProxy.sol



pragma solidity 0.6.6;





contract MintableERC1155PredicateProxy is UpgradableProxy {

    constructor(address _proxyTo)

        public

        UpgradableProxy(_proxyTo)

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\MintableERC20Predicate.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-09-17

*/



// File: @openzeppelin/contracts/token/ERC20/IERC20.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: @openzeppelin/contracts/math/SafeMath.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: @openzeppelin/contracts/utils/Address.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



// File: contracts/root/RootToken/IMintableERC20.sol



pragma solidity 0.6.6;



interface IMintableERC20 is IERC20 {

    /**

     * @notice called by predicate contract to mint tokens while withdrawing

     * @dev Should be callable only by MintableERC20Predicate

     * Make sure minting is done only by this function

     * @param user user address for whom token is being minted

     * @param amount amount of token being minted

     */

    function mint(address user, uint256 amount) external;

}



// File: @openzeppelin/contracts/utils/EnumerableSet.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`

 * (`UintSet`) are supported.

 */

library EnumerableSet {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;



        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            bytes32 lastvalue = set._values[lastIndex];



            // Move the last value to the index where the value to delete is

            set._values[toDeleteIndex] = lastvalue;

            // Update the index for the moved value

            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}



// File: @openzeppelin/contracts/GSN/Context.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: @openzeppelin/contracts/access/AccessControl.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context {

    using EnumerableSet for EnumerableSet.AddressSet;

    using Address for address;



    struct RoleData {

        EnumerableSet.AddressSet members;

        bytes32 adminRole;

    }



    mapping (bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view returns (bool) {

        return _roles[role].members.contains(account);

    }



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {

        return _roles[role].members.length();

    }



    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {

        return _roles[role].members.at(index);

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");



        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");



        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (_roles[role].members.add(account)) {

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (_roles[role].members.remove(account)) {

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}



// File: contracts/common/AccessControlMixin.sol



pragma solidity 0.6.6;





contract AccessControlMixin is AccessControl {

    string private _revertMsg;

    function _setupContractId(string memory contractId) internal {

        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));

    }



    modifier only(bytes32 role) {

        require(

            hasRole(role, _msgSender()),

            _revertMsg

        );

        _;

    }

}



// File: contracts/lib/RLPReader.sol



/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol

 */

pragma solidity 0.6.6;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param the RLP item.

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

     * @param the RLP item.

     * @return (memPtr, len) pair: location of the item's payload in memory.

     */

    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {

        uint offset = _payloadOffset(item.memPtr);

        uint memPtr = item.memPtr + offset;

        uint len = item.len - offset; // data length

        return (memPtr, len);

    }



    /*

    * @param the RLP item.

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        (, uint len) = payloadLocation(item);

        return len;

    }



    /*

    * @param the RLP item containing the encoded list.

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /*

     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.

     * @return keccak256 hash of RLP encoded bytes.

     */

    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        uint256 ptr = item.memPtr;

        uint256 len = item.len;

        bytes32 result;

        assembly {

            result := keccak256(ptr, len)

        }

        return result;

    }



    /*

     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.

     * @return keccak256 hash of the item payload.

     */

    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        (uint memPtr, uint len) = payloadLocation(item);

        bytes32 result;

        assembly {

            result := keccak256(memPtr, len)

        }

        return result;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte except "0x80" is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        // SEE Github Issue #5.

        // Summary: Most commonly used RLP libraries (i.e Geth) will encode

        // "0" as "0x80" instead of as "0". We handle this edge case explicitly

        // here.

        if (result == 0 || result == STRING_SHORT_START) {

            return false;

        } else {

            return true;

        }

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        (uint memPtr, uint len) = payloadLocation(item);



        uint result;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        (uint memPtr, uint len) = payloadLocation(item);

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(memPtr, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        if (len > 0) {

            // left over bytes. Mask is used to remove unwanted bytes from the word

            uint mask = 256 ** (WORD_SIZE - len) - 1;

            assembly {

                let srcpart := and(mload(src), not(mask)) // zero out src

                let destpart := and(mload(dest), mask) // retrieve the bytes

                mstore(dest, or(destpart, srcpart))

            }

        }

    }

}



// File: contracts/root/TokenPredicates/ITokenPredicate.sol



pragma solidity 0.6.6;





/// @title Token predicate interface for all pos portal predicates

/// @notice Abstract interface that defines methods for custom predicates

interface ITokenPredicate {



    /**

     * @notice Deposit tokens into pos portal

     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on side chain

     * @param rootToken Token which gets deposited

     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external;



    /**

     * @notice Validates and processes exit while withdraw process

     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.

     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw

     * @param sender Address

     * @param rootToken Token which gets withdrawn

     * @param logRLPList Valid sidechain log for data like amount, token id etc.

     */

    function exitTokens(

        address sender,

        address rootToken,

        bytes calldata logRLPList

    ) external;

}



// File: contracts/common/Initializable.sol



pragma solidity 0.6.6;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        _;

        inited = true;

    }

}



// File: contracts/root/TokenPredicates/MintableERC20Predicate.sol



pragma solidity 0.6.6;

















contract MintableERC20Predicate is

    ITokenPredicate,

    AccessControlMixin,

    Initializable

{

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;

    using SafeERC20 for IERC20;



    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

    bytes32 public constant TOKEN_TYPE = keccak256("MintableERC20");

    bytes32 public constant TRANSFER_EVENT_SIG = keccak256(

        "Transfer(address,address,uint256)"

    );



    event LockedMintableERC20(

        address indexed depositor,

        address indexed depositReceiver,

        address indexed rootToken,

        uint256 amount

    );



    constructor() public {}



    function initialize(address _owner) external initializer {

        _setupContractId("MintableERC20Predicate");

        _setupRole(DEFAULT_ADMIN_ROLE, _owner);

        _setupRole(MANAGER_ROLE, _owner);

    }



    /**

     * @notice Lock ERC20 tokens for deposit, callable only by manager

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on child chain

     * @param rootToken Token which gets deposited

     * @param depositData ABI encoded amount

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external override only(MANAGER_ROLE) {



        uint256 amount = abi.decode(depositData, (uint256));

        emit LockedMintableERC20(depositor, depositReceiver, rootToken, amount);



        // Attempt to perform safe transfer from i.e. check function return value

        // using low-level call & revert if didn't succeed

        IERC20(rootToken).safeTransferFrom(depositor, address(this), amount);

    }



    /**

     * @notice Validates log signature, from and to address

     * then sends the correct amount to withdrawer

     * callable only by manager

     * @param rootToken Token which gets withdrawn

     * @param log Valid ERC20 burn log from child chain

     */

    function exitTokens(

        address,

        address rootToken,

        bytes memory log

    ) public override only(MANAGER_ROLE) {

        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();

        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics



        require(

            bytes32(logTopicRLPList[0].toUint()) == TRANSFER_EVENT_SIG, // topic0 is `Transfer` event sig

            "MintableERC20Predicate: INVALID_SIGNATURE"

        );



        address withdrawer = address(logTopicRLPList[1].toUint()); // topic1 is `from` address



        require(

            address(logTopicRLPList[2].toUint()) == address(0), // topic2 is `to` address

            "MintableERC20Predicate: INVALID_RECEIVER"

        );



        IMintableERC20 token = IMintableERC20(rootToken);

        uint256 tokenBalance = token.balanceOf(address(this));

        uint256 amount = logRLPList[2].toUint();



        // Checking whether MintableERC20Predicate has enough balance

        // to transfer `amount` to withdrawer or not

        //

        // If no, it'll mint those extra tokens & transfer `amount`

        // to withdrawer

        if (tokenBalance < amount) {

            token.mint(address(this), amount - tokenBalance);

        }



        // Attempt to perform safe transfer i.e. check function return value

        // using low-level call & revert if didn't succeed

        IERC20(rootToken).safeTransfer(withdrawer, amount);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\MintableERC20PredicateProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-02-12

*/



// File: contracts/common/Proxy/IERCProxy.sol



pragma solidity 0.6.6;



interface IERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/Proxy/Proxy.sol



pragma solidity 0.6.6;





abstract contract Proxy is IERCProxy {

    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas(), 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize()



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }



    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external virtual override view returns (address);

}



// File: contracts/common/Proxy/UpgradableProxy.sol



pragma solidity 0.6.6;





contract UpgradableProxy is Proxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event ProxyOwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setProxyOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    fallback() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    receive() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadProxyOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function proxyOwner() external view returns(address) {

        return loadProxyOwner();

    }



    function loadProxyOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external override view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferProxyOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());

        setProxyOwner(newOwner);

    }



    function setProxyOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/TokenPredicates/MintableERC20PredicateProxy.sol



pragma solidity 0.6.6;





contract MintableERC20PredicateProxy is UpgradableProxy {

    constructor(address _proxyTo)

        public

        UpgradableProxy(_proxyTo)

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\MintableERC721Predicate.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-04-01

*/



// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

interface IERC721Receiver {

    /**

     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}

     * by `operator` from `from`, this function is called.

     *

     * It must return its Solidity selector to confirm the token transfer.

     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.

     *

     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)

    external returns (bytes4);

}



// File: @openzeppelin/contracts/utils/EnumerableSet.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`

 * (`UintSet`) are supported.

 */

library EnumerableSet {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;



        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            bytes32 lastvalue = set._values[lastIndex];



            // Move the last value to the index where the value to delete is

            set._values[toDeleteIndex] = lastvalue;

            // Update the index for the moved value

            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}



// File: @openzeppelin/contracts/utils/Address.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/GSN/Context.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: @openzeppelin/contracts/access/AccessControl.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context {

    using EnumerableSet for EnumerableSet.AddressSet;

    using Address for address;



    struct RoleData {

        EnumerableSet.AddressSet members;

        bytes32 adminRole;

    }



    mapping (bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view returns (bool) {

        return _roles[role].members.contains(account);

    }



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {

        return _roles[role].members.length();

    }



    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {

        return _roles[role].members.at(index);

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");



        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");



        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (_roles[role].members.add(account)) {

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (_roles[role].members.remove(account)) {

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}



// File: contracts/common/AccessControlMixin.sol



pragma solidity 0.6.6;





contract AccessControlMixin is AccessControl {

    string private _revertMsg;

    function _setupContractId(string memory contractId) internal {

        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));

    }



    modifier only(bytes32 role) {

        require(

            hasRole(role, _msgSender()),

            _revertMsg

        );

        _;

    }

}



// File: contracts/lib/RLPReader.sol



/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol

 */

pragma solidity 0.6.6;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START = 0xb8;

    uint8 constant LIST_SHORT_START = 0xc0;

    uint8 constant LIST_LONG_START = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint256 len;

        uint256 memPtr;

    }



    /*

     * @param item RLP encoded bytes

     */

    function toRlpItem(bytes memory item)

        internal

        pure

        returns (RLPItem memory)

    {

        require(item.length > 0, "RLPReader: INVALID_BYTES_LENGTH");

        uint256 memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

     * @param item RLP encoded list in bytes

     */

    function toList(RLPItem memory item)

        internal

        pure

        returns (RLPItem[] memory)

    {

        require(isList(item), "RLPReader: ITEM_NOT_LIST");



        uint256 items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);

        uint256 listLength = _itemLength(item.memPtr);

        require(listLength == item.len, "RLPReader: LIST_DECODED_LENGTH_MISMATCH");



        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 dataLen;

        for (uint256 i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr);

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        uint8 byte0;

        uint256 memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START) return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory result = new bytes(item.len);



        uint256 ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        require(!isList(item), "RLPReader: DECODING_LIST_AS_ADDRESS");

        // 1 byte for the length prefix

        require(item.len == 21, "RLPReader: INVALID_ADDRESS_LENGTH");



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint256) {

        require(!isList(item), "RLPReader: DECODING_LIST_AS_UINT");

        require(item.len <= 33, "RLPReader: INVALID_UINT_LENGTH");



        uint256 itemLength = _itemLength(item.memPtr);

        require(itemLength == item.len, "RLPReader: UINT_DECODED_LENGTH_MISMATCH");



        uint256 offset = _payloadOffset(item.memPtr);

        uint256 len = item.len - offset;

        uint256 result;

        uint256 memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {

        uint256 itemLength = _itemLength(item.memPtr);

        require(itemLength == item.len, "RLPReader: UINT_STRICT_DECODED_LENGTH_MISMATCH");

        // one byte prefix

        require(item.len == 33, "RLPReader: INVALID_UINT_STRICT_LENGTH");



        uint256 result;

        uint256 memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        uint256 listLength = _itemLength(item.memPtr);

        require(listLength == item.len, "RLPReader: BYTES_DECODED_LENGTH_MISMATCH");

        uint256 offset = _payloadOffset(item.memPtr);



        uint256 len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint256 destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

     * Private Helpers

     */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint256) {

        // add `isList` check if `item` is expected to be passsed without a check from calling function

        // require(isList(item), "RLPReader: NUM_ITEMS_NOT_LIST");



        uint256 count = 0;

        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

            currPtr = currPtr + _itemLength(currPtr); // skip over an item

            require(currPtr <= endPtr, "RLPReader: NUM_ITEMS_DECODED_LENGTH_MISMATCH");

            count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint256 memPtr) private pure returns (uint256) {

        uint256 itemLen;

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) itemLen = 1;

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;

        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte



                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        } else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) return 0;

        else if (

            byte0 < STRING_LONG_START ||

            (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)

        ) return 1;

        else if (byte0 < LIST_SHORT_START)

            // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

     * @param src Pointer to source

     * @param dest Pointer to destination

     * @param len Amount of memory to copy from the source

     */

    function copy(

        uint256 src,

        uint256 dest,

        uint256 len

    ) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint256 mask = 256**(WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: @openzeppelin/contracts/introspection/IERC165.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: @openzeppelin/contracts/token/ERC721/IERC721.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;





/**

 * @dev Required interface of an ERC721 compliant contract.

 */

interface IERC721 is IERC165 {

    /**

     * @dev Emitted when `tokenId` token is transfered from `from` to `to`.

     */

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.

     */

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.

     */

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of tokens in ``owner``'s account.

     */

    function balanceOf(address owner) external view returns (uint256 balance);



    /**

     * @dev Returns the owner of the `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function ownerOf(uint256 tokenId) external view returns (address owner);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Transfers `tokenId` token from `from` to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Gives permission to `to` to transfer `tokenId` token to another account.

     * The approval is cleared when the token is transferred.

     *

     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.

     *

     * Requirements:

     *

     * - The caller must own the token or be an approved operator.

     * - `tokenId` must exist.

     *

     * Emits an {Approval} event.

     */

    function approve(address to, uint256 tokenId) external;



    /**

     * @dev Returns the account approved for `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function getApproved(uint256 tokenId) external view returns (address operator);



    /**

     * @dev Approve or remove `operator` as an operator for the caller.

     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.

     *

     * Requirements:

     *

     * - The `operator` cannot be the caller.

     *

     * Emits an {ApprovalForAll} event.

     */

    function setApprovalForAll(address operator, bool _approved) external;



    /**

     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.

     *

     * See {setApprovalForAll}

     */

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    /**

      * @dev Safely transfers `tokenId` token from `from` to `to`.

      *

      * Requirements:

      *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

      * - `tokenId` token must exist and be owned by `from`.

      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

      *

      * Emits a {Transfer} event.

      */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

}



// File: contracts/root/RootToken/IMintableERC721.sol



pragma solidity 0.6.6;



interface IMintableERC721 is IERC721 {

    /**

     * @notice called by predicate contract to mint tokens while withdrawing

     * @dev Should be callable only by MintableERC721Predicate

     * Make sure minting is done only by this function

     * @param user user address for whom token is being minted

     * @param tokenId tokenId being minted

     */

    function mint(address user, uint256 tokenId) external;



    /**

     * @notice called by predicate contract to mint tokens while withdrawing with metadata from L2

     * @dev Should be callable only by MintableERC721Predicate

     * Make sure minting is only done either by this function/ ???

     * @param user user address for whom token is being minted

     * @param tokenId tokenId being minted

     * @param metaData Associated token metadata, to be decoded & set using `setTokenMetadata`

     *

     * Note : If you're interested in taking token metadata from L2 to L1 during exit, you must

     * implement this method

     */

    function mint(address user, uint256 tokenId, bytes calldata metaData) external;



    /**

     * @notice check if token already exists, return true if it does exist

     * @dev this check will be used by the predicate to determine if the token needs to be minted or transfered

     * @param tokenId tokenId being checked

     */

    function exists(uint256 tokenId) external view returns (bool);

}



// File: contracts/root/TokenPredicates/ITokenPredicate.sol



pragma solidity 0.6.6;





/// @title Token predicate interface for all pos portal predicates

/// @notice Abstract interface that defines methods for custom predicates

interface ITokenPredicate {



    /**

     * @notice Deposit tokens into pos portal

     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on side chain

     * @param rootToken Token which gets deposited

     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external;



    /**

     * @notice Validates and processes exit while withdraw process

     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.

     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw

     * @param sender Address

     * @param rootToken Token which gets withdrawn

     * @param logRLPList Valid sidechain log for data like amount, token id etc.

     */

    function exitTokens(

        address sender,

        address rootToken,

        bytes calldata logRLPList

    ) external;

}



// File: contracts/common/Initializable.sol



pragma solidity 0.6.6;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        _;

        inited = true;

    }

}



// File: contracts/root/TokenPredicates/MintableERC721Predicate.sol



pragma solidity 0.6.6;















contract MintableERC721Predicate is ITokenPredicate, AccessControlMixin, Initializable, IERC721Receiver {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    // keccak256("MANAGER_ROLE")

    bytes32 public constant MANAGER_ROLE = 0x241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08;

    // keccak256("MintableERC721")

    bytes32 public constant TOKEN_TYPE = 0xd4392723c111fcb98b073fe55873efb447bcd23cd3e49ec9ea2581930cd01ddc;

    // keccak256("Transfer(address,address,uint256)")

    bytes32 public constant TRANSFER_EVENT_SIG = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;

    // keccak256("WithdrawnBatch(address,uint256[])")

    bytes32 public constant WITHDRAW_BATCH_EVENT_SIG = 0xf871896b17e9cb7a64941c62c188a4f5c621b86800e3d15452ece01ce56073df;

    // keccak256("TransferWithMetadata(address,address,uint256,bytes)")

    bytes32 public constant TRANSFER_WITH_METADATA_EVENT_SIG = 0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14;



    // limit batching of tokens due to gas limit restrictions

    uint256 public constant BATCH_LIMIT = 20;



    event LockedMintableERC721(

        address indexed depositor,

        address indexed depositReceiver,

        address indexed rootToken,

        uint256 tokenId

    );



    event LockedMintableERC721Batch(

        address indexed depositor,

        address indexed depositReceiver,

        address indexed rootToken,

        uint256[] tokenIds

    );



    constructor() public {}



    function initialize(address _owner) external initializer {

        _setupContractId("MintableERC721Predicate");

        _setupRole(DEFAULT_ADMIN_ROLE, _owner);

        _setupRole(MANAGER_ROLE, _owner);

    }



    /**

     * @notice accepts safe ERC721 transfer

     */

    function onERC721Received(

        address,

        address,

        uint256,

        bytes calldata

    )

        external

        override

        returns (bytes4)

    {

        return IERC721Receiver.onERC721Received.selector;

    }



    /**

     * @notice Lock ERC721 token(s) for deposit, callable only by manager

     * @param depositor Address who wants to deposit token

     * @param depositReceiver Address (address) who wants to receive token on child chain

     * @param rootToken Token which gets deposited

     * @param depositData ABI encoded tokenId(s). It's possible to deposit batch of tokens.

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    )

        external

        override

        only(MANAGER_ROLE)

    {



        // Locking single ERC721 token

        if (depositData.length == 32) {



            uint256 tokenId = abi.decode(depositData, (uint256));



            // Emitting event that single token is getting locked in predicate

            emit LockedMintableERC721(depositor, depositReceiver, rootToken, tokenId);



            // Transferring token to this address, which will be

            // released when attempted to be unlocked

            IMintableERC721(rootToken).safeTransferFrom(depositor, address(this), tokenId);



        } else {

            // Locking a set a ERC721 token(s)



            uint256[] memory tokenIds = abi.decode(depositData, (uint256[]));



            // Emitting event that a set of ERC721 tokens are getting lockec

            // in this predicate contract

            emit LockedMintableERC721Batch(depositor, depositReceiver, rootToken, tokenIds);



            // These many tokens are attempted to be deposited

            // by user

            uint256 length = tokenIds.length;

            require(length <= BATCH_LIMIT, "MintableERC721Predicate: EXCEEDS_BATCH_LIMIT");



            // Iteratively trying to transfer ERC721 token

            // to this predicate address

            for (uint256 i; i < length; i++) {



                IMintableERC721(rootToken).safeTransferFrom(depositor, address(this), tokenIds[i]);



            }



        }



    }



    /**

     * @notice Validates log signature, from and to address

     * then checks if token already exists on root chain

     * if token exits then transfers it to withdrawer

     * if token doesn't exit then it is minted

     * callable only by manager

     * @param rootToken Token which gets withdrawn

     * @param log Valid ERC721 burn log from child chain

     */

    function exitTokens(

        address,

        address rootToken,

        bytes memory log

    )

        public

        override

        only(MANAGER_ROLE)

    {

        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();

        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics



        // If it's a simple exit ( with out metadata coming from L2 to L1 )

        if(bytes32(logTopicRLPList[0].toUint()) == TRANSFER_EVENT_SIG) {



            address withdrawer = address(logTopicRLPList[1].toUint()); // topic1 is from address



            require(

                address(logTopicRLPList[2].toUint()) == address(0), // topic2 is to address

                "MintableERC721Predicate: INVALID_RECEIVER"

            );



            IMintableERC721 token = IMintableERC721(rootToken);



            uint256 tokenId = logTopicRLPList[3].toUint(); // topic3 is tokenId field

            if (token.exists(tokenId)) {

                token.safeTransferFrom(

                    address(this),

                    withdrawer,

                    tokenId

                );

            } else {

                token.mint(withdrawer, tokenId);

            }



        } else if (bytes32(logTopicRLPList[0].toUint()) == WITHDRAW_BATCH_EVENT_SIG) { // topic0 is event sig

            // If it's a simple batch exit, where a set of

            // ERC721s were burnt in child chain with event signature

            // looking like `WithdrawnBatch(address indexed user, uint256[] tokenIds);`

            //

            // @note This doesn't allow transfer of metadata cross chain

            // For that check below `else if` block



            address withdrawer = address(logTopicRLPList[1].toUint()); // topic1 is from address



            // RLP encoded tokenId list

            bytes memory logData = logRLPList[2].toBytes();



            (uint256[] memory tokenIds) = abi.decode(logData, (uint256[]));

            uint256 length = tokenIds.length;



            IMintableERC721 token = IMintableERC721(rootToken);



            for (uint256 i; i < length; i++) {



                uint256 tokenId = tokenIds[i];



                // Check if token exists or not

                //

                // If does, transfer token to withdrawer

                if (token.exists(tokenId)) {

                    token.safeTransferFrom(

                        address(this),

                        withdrawer,

                        tokenId

                    );

                } else {

                    // If token was minted on L2

                    // we'll mint it here, on L1, during

                    // exiting from L2

                    token.mint(withdrawer, tokenId);

                }



            }



        } else if (bytes32(logTopicRLPList[0].toUint()) == TRANSFER_WITH_METADATA_EVENT_SIG) { 

            // If this is NFT exit with metadata i.e. URI ???

            //

            // Note: If your token is only minted in L2, you can exit

            // it with metadata. But if it was minted on L1, it'll be

            // simply transferred to withdrawer address. And in that case,

            // it's lot better to exit with `Transfer(address,address,uint256)`

            // i.e. calling `withdraw` method on L2 contract

            // event signature proof, which is defined under first `if` clause

            //

            // If you've called `withdrawWithMetadata`, you should submit

            // proof of event signature `TransferWithMetadata(address,address,uint256,bytes)`



            address withdrawer = address(logTopicRLPList[1].toUint()); // topic1 is from address



            require(

                address(logTopicRLPList[2].toUint()) == address(0), // topic2 is to address

                "MintableERC721Predicate: INVALID_RECEIVER"

            );



            IMintableERC721 token = IMintableERC721(rootToken);



            uint256 tokenId = logTopicRLPList[3].toUint(); // topic3 is tokenId field

            if (token.exists(tokenId)) {

                token.safeTransferFrom(

                    address(this),

                    withdrawer,

                    tokenId

                );

            } else {

                // Minting with metadata received from L2 i.e. emitted

                // by event `TransferWithMetadata` during burning

                bytes memory logData = logRLPList[2].toBytes();

                bytes memory metaData = abi.decode(logData, (bytes));

                

                token.mint(withdrawer, tokenId, metaData);

            }



        } else {

            // Attempting to exit with some event signature from L2, which is

            // not ( yet ) supported by L1 exit manager

            revert("MintableERC721Predicate: INVALID_SIGNATURE");

        }

        

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\MintableERC721PredicateProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-08-26

*/



// File: contracts/common/Proxy/IERCProxy.sol



pragma solidity 0.6.6;



interface IERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/Proxy/Proxy.sol



pragma solidity 0.6.6;





abstract contract Proxy is IERCProxy {

    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas(), 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize()



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }



    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external virtual override view returns (address);

}



// File: contracts/common/Proxy/UpgradableProxy.sol



pragma solidity 0.6.6;





contract UpgradableProxy is Proxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event ProxyOwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setProxyOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    fallback() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    receive() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadProxyOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function proxyOwner() external view returns(address) {

        return loadProxyOwner();

    }



    function loadProxyOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external override view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferProxyOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());

        setProxyOwner(newOwner);

    }



    function setProxyOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/TokenPredicates/MintableERC721PredicateProxy.sol



pragma solidity 0.6.6;





contract MintableERC721PredicateProxy is UpgradableProxy {

    constructor(address _proxyTo)

        public

        UpgradableProxy(_proxyTo)

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\PriorityQueue.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



/**

 * @title PriorityQueue

 * @dev A priority queue implementation.

 */

contract PriorityQueue is Ownable {

    using SafeMath for uint256;



    uint256[] heapList;

    uint256 public currentSize;



    constructor() public {

        heapList = [0];

    }



    /**

  * @dev Inserts an element into the priority queue.

  * @param _priority Priority to insert.

  * @param _value Some additional value.

  */

    function insert(uint256 _priority, uint256 _value) public onlyOwner {

        uint256 element = (_priority << 128) | _value;

        heapList.push(element);

        currentSize = currentSize.add(1);

        _percUp(currentSize);

    }



    /**

  * @dev Returns the top element of the heap.

  * @return The smallest element in the priority queue.

  */

    function getMin() public view returns (uint256, uint256) {

        return _splitElement(heapList[1]);

    }



    /**

  * @dev Deletes the top element of the heap and shifts everything up.

  * @return The smallest element in the priorty queue.

  */

    function delMin() public onlyOwner returns (uint256, uint256) {

        uint256 retVal = heapList[1];

        heapList[1] = heapList[currentSize];

        delete heapList[currentSize];

        currentSize = currentSize.sub(1);

        _percDown(1);

        heapList.length = heapList.length.sub(1);

        return _splitElement(retVal);

    }



    /**

  * @dev Determines the minimum child of a given node in the tree.

  * @param _index Index of the node in the tree.

  * @return The smallest child node.

  */

    function _minChild(uint256 _index) private view returns (uint256) {

        if (_index.mul(2).add(1) > currentSize) {

            return _index.mul(2);

        } else {

            if (heapList[_index.mul(2)] < heapList[_index.mul(2).add(1)]) {

                return _index.mul(2);

            } else {

                return _index.mul(2).add(1);

            }

        }

    }



    /**

   * @dev Bubbles the element at some index up.

   */

    function _percUp(uint256 _index) private {

        uint256 index = _index;

        uint256 j = index;

        uint256 newVal = heapList[index];



        while (newVal < heapList[index.div(2)]) {

            heapList[index] = heapList[index.div(2)];

            index = index.div(2);

        }



        if (index != j) {

            heapList[index] = newVal;

        }

    }



    /**

   * @dev Bubbles the element at some index down.

   */

    function _percDown(uint256 _index) private {

        uint256 index = _index;

        uint256 j = index;

        uint256 newVal = heapList[index];

        uint256 mc = _minChild(index);

        while (mc <= currentSize && newVal > heapList[mc]) {

            heapList[index] = heapList[mc];

            index = mc;

            mc = _minChild(index);

        }



        if (index != j) {

            heapList[index] = newVal;

        }

    }



    /**

   * @dev Split an element into its priority and value.

   * @param _element Element to decode.

   * @return A tuple containing the priority and value.

   */

    function _splitElement(uint256 _element)

        private

        pure

        returns (uint256, uint256)

    {

        uint256 priority = _element >> 128;

        uint256 value = uint256(uint128(_element));

        return (priority, value);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\Registry.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





interface IGovernance {

    function update(address target, bytes calldata data) external;

}



contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

        _;

    }

}



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\RLPEncode.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



library BytesLib {

    function concat(bytes memory _preBytes, bytes memory _postBytes)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;

        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(

                0x40,

                and(

                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),

                    not(31) // Round down to the nearest 32 bytes.

                )

            )

        }

        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start, uint256 _length)

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));

        bytes memory tempBytes;

        assembly {

            switch iszero(_length)

                case 0 {

                    // Get a location of some free memory and store it in tempBytes as

                    // Solidity does for memory variables.

                    tempBytes := mload(0x40)



                    // The first word of the slice result is potentially a partial

                    // word read from the original array. To read it, we calculate

                    // the length of that partial word and start copying that many

                    // bytes into the array. The first word we copy will start with

                    // data we don't care about, but the last `lengthmod` bytes will

                    // land at the beginning of the contents of the new array. When

                    // we're done copying, we overwrite the full first word with

                    // the actual length of the slice.

                    let lengthmod := and(_length, 31)



                    // The multiplication in the next line is necessary

                    // because when slicing multiples of 32 bytes (lengthmod == 0)

                    // the following copy loop was copying the origin's length

                    // and then ending prematurely not copying everything it should.

                    let mc := add(

                        add(tempBytes, lengthmod),

                        mul(0x20, iszero(lengthmod))

                    )

                    let end := add(mc, _length)



                    for {

                        // The multiplication in the next line has the same exact purpose

                        // as the one above.

                        let cc := add(

                            add(

                                add(_bytes, lengthmod),

                                mul(0x20, iszero(lengthmod))

                            ),

                            _start

                        )

                    } lt(mc, end) {

                        mc := add(mc, 0x20)

                        cc := add(cc, 0x20)

                    } {

                        mstore(mc, mload(cc))

                    }



                    mstore(tempBytes, _length)



                    //update free-memory pointer

                    //allocating the array padded to 32 bytes like the compiler does now

                    mstore(0x40, and(add(mc, 31), not(31)))

                }

                //if we want a zero-length slice let's just return a zero-length array

                default {

                    tempBytes := mload(0x40)

                    mstore(0x40, add(tempBytes, 0x20))

                }

        }



        return tempBytes;

    }



    // Pad a bytes array to 32 bytes

    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {

        // may underflow if bytes.length < 32. Hence using SafeMath.sub

        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));

        return concat(newBytes, _bytes);

    }



    function toBytes32(bytes memory b) internal pure returns (bytes32) {

        require(b.length >= 32, "Bytes array should atleast be 32 bytes");

        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {

            out |= bytes32(b[i] & 0xFF) >> (i * 8);

        }

        return out;

    }



    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {

        assembly {

            result := mload(add(b, 32))

        }

    }



    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {

        bytes memory b = new bytes(32);

        for (uint256 i = 0; i < 32; i++) {

            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));

        }

        return b;

    }



    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {

        _ret = new bytes(32);

        assembly {

            mstore(add(_ret, 32), _num)

        }

    }



    function toUint(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (uint256)

    {

        require(_bytes.length >= (_start + 32));

        uint256 tempUint;

        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }

        return tempUint;

    }



    function toAddress(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (address)

    {

        require(_bytes.length >= (_start + 20));

        address tempAddress;

        assembly {

            tempAddress := div(

                mload(add(add(_bytes, 0x20), _start)),

                0x1000000000000000000000000

            )

        }



        return tempAddress;

    }

}



// Library for RLP encoding a list of bytes arrays.

// Modeled after ethereumjs/rlp (https://github.com/ethereumjs/rlp)

// [Very] modified version of Sam Mayo's library.

library RLPEncode {

    // Encode an item (bytes memory)

    function encodeItem(bytes memory self)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory encoded;

        if (self.length == 1 && uint8(self[0] & 0xFF) < 0x80) {

            encoded = new bytes(1);

            encoded = self;

        } else {

            encoded = BytesLib.concat(encodeLength(self.length, 128), self);

        }

        return encoded;

    }



    // Encode a list of items

    function encodeList(bytes[] memory self)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory encoded;

        for (uint256 i = 0; i < self.length; i++) {

            encoded = BytesLib.concat(encoded, encodeItem(self[i]));

        }

        return BytesLib.concat(encodeLength(encoded.length, 192), encoded);

    }



    // Hack to encode nested lists. If you have a list as an item passed here, included

    // pass = true in that index. E.g.

    // [item, list, item] --> pass = [false, true, false]

    // function encodeListWithPasses(bytes[] memory self, bool[] pass) internal pure returns (bytes memory) {

    //   bytes memory encoded;

    //   for (uint i=0; i < self.length; i++) {

    // 		if (pass[i] == true) {

    // 			encoded = BytesLib.concat(encoded, self[i]);

    // 		} else {

    // 			encoded = BytesLib.concat(encoded, encodeItem(self[i]));

    // 		}

    //   }

    //   return BytesLib.concat(encodeLength(encoded.length, 192), encoded);

    // }



    // Generate the prefix for an item or the entire list based on RLP spec

    function encodeLength(uint256 L, uint256 offset)

        internal

        pure

        returns (bytes memory)

    {

        if (L < 56) {

            bytes memory prefix = new bytes(1);

            prefix[0] = bytes1(uint8(L + offset));

            return prefix;

        } else {

            // lenLen is the length of the hex representation of the data length

            uint256 lenLen;

            uint256 i = 0x1;



            while (L / i != 0) {

                lenLen++;

                i *= 0x100;

            }



            bytes memory prefix0 = getLengthBytes(offset + 55 + lenLen);

            bytes memory prefix1 = getLengthBytes(L);

            return BytesLib.concat(prefix0, prefix1);

        }

    }



    function getLengthBytes(uint256 x) internal pure returns (bytes memory b) {

        // Figure out if we need 1 or two bytes to express the length.

        // 1 byte gets us to max 255

        // 2 bytes gets us to max 65535 (no payloads will be larger than this)

        uint256 nBytes = 1;

        if (x > 255) {

            nBytes = 2;

        }



        b = new bytes(nBytes);

        // Encode the length and return it

        for (uint256 i = 0; i < nBytes; i++) {

            b[i] = bytes1(uint8(x / (2**(8 * (nBytes - 1 - i)))));

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\RLPReader.sol
File type: .sol
/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 */

pragma solidity ^0.8.0;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START = 0xb8;

    uint8 constant LIST_SHORT_START = 0xc0;

    uint8 constant LIST_LONG_START = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint256 len;

        uint256 memPtr;

    }



    struct Iterator {

        RLPItem item; // Item that's being iterated over.

        uint256 nextPtr; // Position of the next item in the list.

    }



    /*

     * @dev Returns the next element in the iteration. Reverts if it has not next element.

     * @param self The iterator.

     * @return The next element in the iteration.

     */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint256 ptr = self.nextPtr;

        uint256 itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

     * @dev Returns true if the iteration has more elements.

     * @param self The iterator.

     * @return true if the iteration has more elements.

     */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

     * @param item RLP encoded bytes

     */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint256 memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

     * @dev Create an iterator. Reverts if item is not a list.

     * @param self The RLP item.

     * @return An 'Iterator' over the item.

     */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

     * @param item RLP encoded bytes

     */

    function rlpLen(RLPItem memory item) internal pure returns (uint256) {

        return item.len;

    }



    /*

     * @param item RLP encoded bytes

     */

    function payloadLen(RLPItem memory item) internal pure returns (uint256) {

        return item.len - _payloadOffset(item.memPtr);

    }



    /*

     * @param item RLP encoded list in bytes

     */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint256 items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 dataLen;

        for (uint256 i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr);

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint256 memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START) return false;

        return true;

    }



    /*

     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.

     * @return keccak256 hash of RLP encoded bytes.

     */

    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        uint256 ptr = item.memPtr;

        uint256 len = item.len;

        bytes32 result;

        assembly {

            result := keccak256(ptr, len)

        }

        return result;

    }



    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {

        uint256 offset = _payloadOffset(item.memPtr);

        uint256 memPtr = item.memPtr + offset;

        uint256 len = item.len - offset; // data length

        return (memPtr, len);

    }



    /*

     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.

     * @return keccak256 hash of the item payload.

     */

    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        (uint256 memPtr, uint256 len) = payloadLocation(item);

        bytes32 result;

        assembly {

            result := keccak256(memPtr, len)

        }

        return result;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;



        uint256 ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint256 result;

        uint256 memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        return result == 0 ? false : true;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(uint160(toUint(item)));

    }



    function toUint(RLPItem memory item) internal pure returns (uint256) {

        require(item.len > 0 && item.len <= 33);



        uint256 offset = _payloadOffset(item.memPtr);

        uint256 len = item.len - offset;



        uint256 result;

        uint256 memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {

        // one byte prefix

        require(item.len == 33);



        uint256 result;

        uint256 memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        uint256 offset = _payloadOffset(item.memPtr);

        uint256 len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint256 destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

     * Private Helpers

     */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint256) {

        if (item.len == 0) return 0;



        uint256 count = 0;

        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

            currPtr = currPtr + _itemLength(currPtr); // skip over an item

            count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint256 memPtr) private pure returns (uint256) {

        uint256 itemLen;

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) itemLen = 1;

        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;

        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        } else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;

        else if (byte0 < LIST_SHORT_START)

            // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

     * @param src Pointer to source

     * @param dest Pointer to destination

     * @param len Amount of memory to copy from the source

     */

    function copy(

        uint256 src,

        uint256 dest,

        uint256 len

    ) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        if (len == 0) return;



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint256 mask = 256**(WORD_SIZE - len) - 1;



        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\RootChain.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-03-26

*/



// File: solidity-rlp/contracts/RLPReader.sol



// SPDX-License-Identifier: Apache-2.0



/*

* @author Hamdi Allam hamdi.allam97@gmail.com

* Please reach out with any questions or concerns

*/

pragma solidity >=0.5.0 <0.7.0;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param item RLP encoded bytes

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        return item.len - _payloadOffset(item.memPtr);

    }



    /*

    * @param item RLP encoded list in bytes

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte except "0x80" is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        // SEE Github Issue #5.

        // Summary: Most commonly used RLP libraries (i.e Geth) will encode

        // "0" as "0x80" instead of as "0". We handle this edge case explicitly

        // here.

        if (result == 0 || result == STRING_SHORT_START) {

            return false;

        } else {

            return true;

        }

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset;



        uint result;

        uint memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        _assertGovernance();

        _;

    }



    function _assertGovernance() private view {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;









contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/misc/ProxyStorage.sol



pragma solidity ^0.5.2;





contract ProxyStorage is Ownable {

    address internal proxyTo;

}



// File: contracts/common/mixin/ChainIdMixin.sol



pragma solidity ^0.5.2;



contract ChainIdMixin {

  bytes constant public networkId = hex"89";

  uint256 constant public CHAINID = 137;

}



// File: contracts/root/RootChainStorage.sol



pragma solidity ^0.5.2;











contract RootChainHeader {

    event NewHeaderBlock(

        address indexed proposer,

        uint256 indexed headerBlockId,

        uint256 indexed reward,

        uint256 start,

        uint256 end,

        bytes32 root

    );

    // housekeeping event

    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }

}





contract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {

    bytes32 public heimdallId;

    uint8 public constant VOTE_TYPE = 2;



    uint16 internal constant MAX_DEPOSITS = 10000;

    uint256 public _nextHeaderBlock = MAX_DEPOSITS;

    uint256 internal _blockDepositId = 1;

    mapping(uint256 => HeaderBlock) public headerBlocks;

    Registry internal registry;

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity 0.5.17;



contract IStakeManager {

    // validator replacement

    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        uint[3][] calldata sigs

    ) external returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes calldata slashingInfoList) external returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function getRegistry() public view returns (address);



    function withdrawalDelay() public view returns (uint256);



    function delegatedAmount(uint256 validatorId) public view returns(uint256);



    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;



    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);



    function delegatorsReward(uint256 validatorId) public view returns(uint256);



    function dethroneAndStake(

        address auctionUser,

        uint256 heimdallFee,

        uint256 validatorId,

        uint256 auctionAmount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;

}



// File: contracts/root/IRootChain.sol



pragma solidity ^0.5.2;





interface IRootChain {

    function slash() external;



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)

        external;

    

    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs)

        external;



    function getLastChildBlock() external view returns (uint256);



    function currentHeaderBlock() external view returns (uint256);

}



// File: contracts/root/RootChain.sol



pragma solidity ^0.5.2;

















contract RootChain is RootChainStorage, IRootChain {

    using SafeMath for uint256;

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    modifier onlyDepositManager() {

        require(msg.sender == registry.getDepositManagerAddress(), "UNAUTHORIZED_DEPOSIT_MANAGER_ONLY");

        _;

    }



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {

        revert();

    }



    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs) external {

        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi

            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));

        require(CHAINID == _borChainID, "Invalid bor chain id");



        require(_buildHeaderBlock(proposer, start, end, rootHash), "INCORRECT_HEADER_DATA");



        // check if it is better to keep it in local storage instead

        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());

        uint256 _reward = stakeManager.checkSignatures(

            end.sub(start).add(1),

            /**  

                prefix 01 to data 

                01 represents positive vote on data and 00 is negative vote

                malicious validator can try to send 2/3 on negative vote so 01 is appended

             */

            keccak256(abi.encodePacked(bytes(hex"01"), data)),

            accountHash,

            proposer,

            sigs

        );



        require(_reward != 0, "Invalid checkpoint");

        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);

        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);

        _blockDepositId = 1;

    }



    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {

        depositId = currentHeaderBlock().add(_blockDepositId);

        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)

        _blockDepositId = _blockDepositId.add(numDeposits);

        require(

            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed

            _blockDepositId <= MAX_DEPOSITS,

            "TOO_MANY_DEPOSITS"

        );

    }



    function getLastChildBlock() external view returns (uint256) {

        return headerBlocks[currentHeaderBlock()].end;

    }



    function slash() external {

        //TODO: future implementation

    }



    function currentHeaderBlock() public view returns (uint256) {

        return _nextHeaderBlock.sub(MAX_DEPOSITS);

    }



    function _buildHeaderBlock(

        address proposer,

        uint256 start,

        uint256 end,

        bytes32 rootHash

    ) private returns (bool) {

        uint256 nextChildBlock;

        /*

    The ID of the 1st header block is MAX_DEPOSITS.

    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0

    */

        if (_nextHeaderBlock > MAX_DEPOSITS) {

            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;

        }

        if (nextChildBlock != start) {

            return false;

        }



        HeaderBlock memory headerBlock = HeaderBlock({

            root: rootHash,

            start: nextChildBlock,

            end: end,

            createdAt: now,

            proposer: proposer

        });



        headerBlocks[_nextHeaderBlock] = headerBlock;

        return true;

    }



    // Housekeeping function. @todo remove later

    function setNextHeaderBlock(uint256 _value) public onlyOwner {

        require(_value % MAX_DEPOSITS == 0, "Invalid value");

        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {

            delete headerBlocks[i];

        }

        _nextHeaderBlock = _value;

        _blockDepositId = 1;

        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);

    }



    // Housekeeping function. @todo remove later

    function setHeimdallId(string memory _heimdallId) public onlyOwner {

        heimdallId = keccak256(abi.encodePacked(_heimdallId));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\RootChainManager.sol
File type: .sol
// File: @openzeppelin/contracts/math/SafeMath.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: contracts/root/RootChainManager/IRootChainManager.sol



pragma solidity 0.6.6;



interface IRootChainManager {

    event TokenMapped(

        address indexed rootToken,

        address indexed childToken,

        bytes32 indexed tokenType

    );



    event PredicateRegistered(

        bytes32 indexed tokenType,

        address indexed predicateAddress

    );



    function registerPredicate(bytes32 tokenType, address predicateAddress)

        external;



    function mapToken(

        address rootToken,

        address childToken,

        bytes32 tokenType

    ) external;



    function cleanMapToken(

        address rootToken,

        address childToken

    ) external;



    function remapToken(

        address rootToken,

        address childToken,

        bytes32 tokenType

    ) external;



    function depositEtherFor(address user) external payable;



    function depositFor(

        address user,

        address rootToken,

        bytes calldata depositData

    ) external;



    function exit(bytes calldata inputData) external;

}



// File: contracts/root/StateSender/IStateSender.sol



pragma solidity 0.6.6;



interface IStateSender {

    function syncState(address receiver, bytes calldata data) external;

}



// File: contracts/root/ICheckpointManager.sol



pragma solidity 0.6.6;



contract ICheckpointManager {

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }



    /**

     * @notice mapping of checkpoint header numbers to block details

     * @dev These checkpoints are submited by plasma contracts

     */

    mapping(uint256 => HeaderBlock) public headerBlocks;

}



// File: contracts/root/RootChainManager/RootChainManagerStorage.sol



pragma solidity 0.6.6;







abstract contract RootChainManagerStorage {

    mapping(bytes32 => address) public typeToPredicate;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bytes32) public tokenToType;

    mapping(bytes32 => bool) public processedExits;

    IStateSender internal _stateSender;

    ICheckpointManager internal _checkpointManager;

    address public childChainManagerAddress;

}



// File: contracts/lib/RLPReader.sol



/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol

 */

pragma solidity 0.6.6;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param the RLP item.

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

     * @param the RLP item.

     * @return (memPtr, len) pair: location of the item's payload in memory.

     */

    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {

        uint offset = _payloadOffset(item.memPtr);

        uint memPtr = item.memPtr + offset;

        uint len = item.len - offset; // data length

        return (memPtr, len);

    }



    /*

    * @param the RLP item.

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        (, uint len) = payloadLocation(item);

        return len;

    }



    /*

    * @param the RLP item containing the encoded list.

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr);

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /*

     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.

     * @return keccak256 hash of RLP encoded bytes.

     */

    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        uint256 ptr = item.memPtr;

        uint256 len = item.len;

        bytes32 result;

        assembly {

            result := keccak256(ptr, len)

        }

        return result;

    }



    /*

     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.

     * @return keccak256 hash of the item payload.

     */

    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        (uint memPtr, uint len) = payloadLocation(item);

        bytes32 result;

        assembly {

            result := keccak256(memPtr, len)

        }

        return result;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;



        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte except "0x80" is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        // SEE Github Issue #5.

        // Summary: Most commonly used RLP libraries (i.e Geth) will encode

        // "0" as "0x80" instead of as "0". We handle this edge case explicitly

        // here.

        if (result == 0 || result == STRING_SHORT_START) {

            return false;

        } else {

            return true;

        }

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        (uint memPtr, uint len) = payloadLocation(item);



        uint result;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        (uint memPtr, uint len) = payloadLocation(item);

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(memPtr, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;



        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte



                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        }



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        if (len > 0) {

            // left over bytes. Mask is used to remove unwanted bytes from the word

            uint mask = 256 ** (WORD_SIZE - len) - 1;

            assembly {

                let srcpart := and(mload(src), not(mask)) // zero out src

                let destpart := and(mload(dest), mask) // retrieve the bytes

                mstore(dest, or(destpart, srcpart))

            }

        }

    }

}



// File: contracts/lib/ExitPayloadReader.sol



pragma solidity 0.6.6;





library ExitPayloadReader {

  using RLPReader for bytes;

  using RLPReader for RLPReader.RLPItem;



  uint8 constant WORD_SIZE = 32;



  struct ExitPayload {

    RLPReader.RLPItem[] data;

  }



  struct Receipt {

    RLPReader.RLPItem[] data;

    bytes raw;

    uint256 logIndex;

  }



  struct Log {

    RLPReader.RLPItem data;

    RLPReader.RLPItem[] list;

  }



  struct LogTopics {

    RLPReader.RLPItem[] data;

  }



  // copy paste of private copy() from RLPReader to avoid changing of existing contracts

  function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        if (len == 0) return;



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }



  function toExitPayload(bytes memory data)

        internal

        pure

        returns (ExitPayload memory)

    {

        RLPReader.RLPItem[] memory payloadData = data

            .toRlpItem()

            .toList();



        return ExitPayload(payloadData);

    }



    function getHeaderNumber(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[0].toUint();

    }



    function getBlockProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[1].toBytes();

    }



    function getBlockNumber(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[2].toUint();

    }



    function getBlockTime(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[3].toUint();

    }



    function getTxRoot(ExitPayload memory payload) internal pure returns(bytes32) {

      return bytes32(payload.data[4].toUint());

    }



    function getReceiptRoot(ExitPayload memory payload) internal pure returns(bytes32) {

      return bytes32(payload.data[5].toUint());

    }



    function getReceipt(ExitPayload memory payload) internal pure returns(Receipt memory receipt) {

      receipt.raw = payload.data[6].toBytes();

      RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();



      if (receiptItem.isList()) {

          // legacy tx

          receipt.data = receiptItem.toList();

      } else {

          // pop first byte before parsting receipt

          bytes memory typedBytes = receipt.raw;

          bytes memory result = new bytes(typedBytes.length - 1);

          uint256 srcPtr;

          uint256 destPtr;

          assembly {

              srcPtr := add(33, typedBytes)

              destPtr := add(0x20, result)

          }



          copy(srcPtr, destPtr, result.length);

          receipt.data = result.toRlpItem().toList();

      }



      receipt.logIndex = getReceiptLogIndex(payload);

      return receipt;

    }



    function getReceiptProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[7].toBytes();

    }



    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[8].toBytes();

    }



    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[8].toUint();

    }



    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[9].toUint();

    }



    // Receipt methods

    function toBytes(Receipt memory receipt) internal pure returns(bytes memory) {

        return receipt.raw;

    }



    function getLog(Receipt memory receipt) internal pure returns(Log memory) {

        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];

        return Log(logData, logData.toList());

    }



    // Log methods

    function getEmitter(Log memory log) internal pure returns(address) {

      return RLPReader.toAddress(log.list[0]);

    }



    function getTopics(Log memory log) internal pure returns(LogTopics memory) {

        return LogTopics(log.list[1].toList());

    }



    function getData(Log memory log) internal pure returns(bytes memory) {

        return log.list[2].toBytes();

    }



    function toRlpBytes(Log memory log) internal pure returns(bytes memory) {

      return log.data.toRlpBytes();

    }



    // LogTopics methods

    function getField(LogTopics memory topics, uint256 index) internal pure returns(RLPReader.RLPItem memory) {

      return topics.data[index];

    }

}



// File: contracts/lib/MerklePatriciaProof.sol



/*

 * @title MerklePatriciaVerifier

 * @author Sam Mayo (sammayo888@gmail.com)

 *

 * @dev Library for verifing merkle patricia proofs.

 */

pragma solidity 0.6.6;





library MerklePatriciaProof {

    /*

     * @dev Verifies a merkle patricia proof.

     * @param value The terminating value in the trie.

     * @param encodedPath The path in the trie leading to value.

     * @param rlpParentNodes The rlp encoded stack of nodes.

     * @param root The root hash of the trie.

     * @return The boolean validity of the proof.

     */

    function verify(

        bytes memory value,

        bytes memory encodedPath,

        bytes memory rlpParentNodes,

        bytes32 root

    ) internal pure returns (bool) {

        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);

        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);



        bytes memory currentNode;

        RLPReader.RLPItem[] memory currentNodeList;



        bytes32 nodeKey = root;

        uint256 pathPtr = 0;



        bytes memory path = _getNibbleArray(encodedPath);

        if (path.length == 0) {

            return false;

        }



        for (uint256 i = 0; i < parentNodes.length; i++) {

            if (pathPtr > path.length) {

                return false;

            }



            currentNode = RLPReader.toRlpBytes(parentNodes[i]);

            if (nodeKey != keccak256(currentNode)) {

                return false;

            }

            currentNodeList = RLPReader.toList(parentNodes[i]);



            if (currentNodeList.length == 17) {

                if (pathPtr == path.length) {

                    if (

                        keccak256(RLPReader.toBytes(currentNodeList[16])) ==

                        keccak256(value)

                    ) {

                        return true;

                    } else {

                        return false;

                    }

                }



                uint8 nextPathNibble = uint8(path[pathPtr]);

                if (nextPathNibble > 16) {

                    return false;

                }

                nodeKey = bytes32(

                    RLPReader.toUintStrict(currentNodeList[nextPathNibble])

                );

                pathPtr += 1;

            } else if (currentNodeList.length == 2) {

                uint256 traversed = _nibblesToTraverse(

                    RLPReader.toBytes(currentNodeList[0]),

                    path,

                    pathPtr

                );

                if (pathPtr + traversed == path.length) {

                    //leaf node

                    if (

                        keccak256(RLPReader.toBytes(currentNodeList[1])) ==

                        keccak256(value)

                    ) {

                        return true;

                    } else {

                        return false;

                    }

                }



                //extension node

                if (traversed == 0) {

                    return false;

                }



                pathPtr += traversed;

                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));

            } else {

                return false;

            }

        }

    }



    function _nibblesToTraverse(

        bytes memory encodedPartialPath,

        bytes memory path,

        uint256 pathPtr

    ) private pure returns (uint256) {

        uint256 len = 0;

        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath

        // and slicedPath have elements that are each one hex character (1 nibble)

        bytes memory partialPath = _getNibbleArray(encodedPartialPath);

        bytes memory slicedPath = new bytes(partialPath.length);



        // pathPtr counts nibbles in path

        // partialPath.length is a number of nibbles

        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {

            bytes1 pathNibble = path[i];

            slicedPath[i - pathPtr] = pathNibble;

        }



        if (keccak256(partialPath) == keccak256(slicedPath)) {

            len = partialPath.length;

        } else {

            len = 0;

        }

        return len;

    }



    // bytes b must be hp encoded

    function _getNibbleArray(bytes memory b)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory nibbles = "";

        if (b.length > 0) {

            uint8 offset;

            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));

            if (hpNibble == 1 || hpNibble == 3) {

                nibbles = new bytes(b.length * 2 - 1);

                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);

                nibbles[0] = oddNibble;

                offset = 1;

            } else {

                nibbles = new bytes(b.length * 2 - 2);

                offset = 0;

            }



            for (uint256 i = offset; i < nibbles.length; i++) {

                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);

            }

        }

        return nibbles;

    }



    function _getNthNibbleOfBytes(uint256 n, bytes memory str)

        private

        pure

        returns (bytes1)

    {

        return

            bytes1(

                n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10

            );

    }

}



// File: contracts/lib/Merkle.sol



pragma solidity 0.6.6;



library Merkle {

    function checkMembership(

        bytes32 leaf,

        uint256 index,

        bytes32 rootHash,

        bytes memory proof

    ) internal pure returns (bool) {

        require(proof.length % 32 == 0, "Invalid proof length");

        uint256 proofHeight = proof.length / 32;

        // Proof of size n means, height of the tree is n+1.

        // In a tree of height n+1, max #leafs possible is 2 ^ n

        require(index < 2 ** proofHeight, "Leaf index is too big");



        bytes32 proofElement;

        bytes32 computedHash = leaf;

        for (uint256 i = 32; i <= proof.length; i += 32) {

            assembly {

                proofElement := mload(add(proof, i))

            }



            if (index % 2 == 0) {

                computedHash = keccak256(

                    abi.encodePacked(computedHash, proofElement)

                );

            } else {

                computedHash = keccak256(

                    abi.encodePacked(proofElement, computedHash)

                );

            }



            index = index / 2;

        }

        return computedHash == rootHash;

    }

}



// File: contracts/root/TokenPredicates/ITokenPredicate.sol



pragma solidity 0.6.6;





/// @title Token predicate interface for all pos portal predicates

/// @notice Abstract interface that defines methods for custom predicates

interface ITokenPredicate {



    /**

     * @notice Deposit tokens into pos portal

     * @dev When `depositor` deposits tokens into pos portal, tokens get locked into predicate contract.

     * @param depositor Address who wants to deposit tokens

     * @param depositReceiver Address (address) who wants to receive tokens on side chain

     * @param rootToken Token which gets deposited

     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]

     */

    function lockTokens(

        address depositor,

        address depositReceiver,

        address rootToken,

        bytes calldata depositData

    ) external;



    /**

     * @notice Validates and processes exit while withdraw process

     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.

     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw

     * @param sender Address

     * @param rootToken Token which gets withdrawn

     * @param logRLPList Valid sidechain log for data like amount, token id etc.

     */

    function exitTokens(

        address sender,

        address rootToken,

        bytes calldata logRLPList

    ) external;

}



// File: contracts/common/Initializable.sol



pragma solidity 0.6.6;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        _;

        inited = true;

    }

}



// File: contracts/common/EIP712Base.sol



pragma solidity 0.6.6;





contract EIP712Base is Initializable {

    struct EIP712Domain {

        string name;

        string version;

        address verifyingContract;

        bytes32 salt;

    }



    string constant public ERC712_VERSION = "1";



    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(

        bytes(

            "EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)"

        )

    );

    bytes32 internal domainSeperator;



    // supposed to be called once while initializing.

    // one of the contractsa that inherits this contract follows proxy pattern

    // so it is not possible to do this in a constructor

    function _initializeEIP712(

        string memory name

    )

        internal

        initializer

    {

        _setDomainSeperator(name);

    }



    function _setDomainSeperator(string memory name) internal {

        domainSeperator = keccak256(

            abi.encode(

                EIP712_DOMAIN_TYPEHASH,

                keccak256(bytes(name)),

                keccak256(bytes(ERC712_VERSION)),

                address(this),

                bytes32(getChainId())

            )

        );

    }



    function getDomainSeperator() public view returns (bytes32) {

        return domainSeperator;

    }



    function getChainId() public pure returns (uint256) {

        uint256 id;

        assembly {

            id := chainid()

        }

        return id;

    }



    /**

     * Accept message hash and returns hash message in EIP712 compatible form

     * So that it can be used to recover signer from signature signed using EIP712 formatted data

     * https://eips.ethereum.org/EIPS/eip-712

     * "\\x19" makes the encoding deterministic

     * "\\x01" is the version byte to make it compatible to EIP-191

     */

    function toTypedMessageHash(bytes32 messageHash)

        internal

        view

        returns (bytes32)

    {

        return

            keccak256(

                abi.encodePacked("\x19\x01", getDomainSeperator(), messageHash)

            );

    }

}



// File: contracts/common/NativeMetaTransaction.sol



pragma solidity 0.6.6;







contract NativeMetaTransaction is EIP712Base {

    using SafeMath for uint256;

    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(

        bytes(

            "MetaTransaction(uint256 nonce,address from,bytes functionSignature)"

        )

    );

    event MetaTransactionExecuted(

        address userAddress,

        address payable relayerAddress,

        bytes functionSignature

    );

    mapping(address => uint256) nonces;



    /*

     * Meta transaction structure.

     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas

     * He should call the desired function directly in that case.

     */

    struct MetaTransaction {

        uint256 nonce;

        address from;

        bytes functionSignature;

    }



    function executeMetaTransaction(

        address userAddress,

        bytes memory functionSignature,

        bytes32 sigR,

        bytes32 sigS,

        uint8 sigV

    ) public payable returns (bytes memory) {

        MetaTransaction memory metaTx = MetaTransaction({

            nonce: nonces[userAddress],

            from: userAddress,

            functionSignature: functionSignature

        });



        require(

            verify(userAddress, metaTx, sigR, sigS, sigV),

            "Signer and signature do not match"

        );



        // increase nonce for user (to avoid re-use)

        nonces[userAddress] = nonces[userAddress].add(1);



        emit MetaTransactionExecuted(

            userAddress,

            msg.sender,

            functionSignature

        );



        // Append userAddress and relayer address at the end to extract it from calling context

        (bool success, bytes memory returnData) = address(this).call(

            abi.encodePacked(functionSignature, userAddress)

        );

        require(success, "Function call not successful");



        return returnData;

    }



    function hashMetaTransaction(MetaTransaction memory metaTx)

        internal

        pure

        returns (bytes32)

    {

        return

            keccak256(

                abi.encode(

                    META_TRANSACTION_TYPEHASH,

                    metaTx.nonce,

                    metaTx.from,

                    keccak256(metaTx.functionSignature)

                )

            );

    }



    function getNonce(address user) public view returns (uint256 nonce) {

        nonce = nonces[user];

    }



    function verify(

        address signer,

        MetaTransaction memory metaTx,

        bytes32 sigR,

        bytes32 sigS,

        uint8 sigV

    ) internal view returns (bool) {

        require(signer != address(0), "NativeMetaTransaction: INVALID_SIGNER");

        return

            signer ==

            ecrecover(

                toTypedMessageHash(hashMetaTransaction(metaTx)),

                sigV,

                sigR,

                sigS

            );

    }

}



// File: @openzeppelin/contracts/utils/EnumerableSet.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`

 * (`UintSet`) are supported.

 */

library EnumerableSet {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;



        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping (bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs

            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.



            bytes32 lastvalue = set._values[lastIndex];



            // Move the last value to the index where the value to delete is

            set._values[toDeleteIndex] = lastvalue;

            // Update the index for the moved value

            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   /**

    * @dev Returns the value stored at position `index` in the set. O(1).

    *

    * Note that there are no guarantees on the ordering of values inside the

    * array, and it may change when more values are added or removed.

    *

    * Requirements:

    *

    * - `index` must be strictly less than {length}.

    */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}



// File: @openzeppelin/contracts/utils/Address.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/GSN/Context.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: @openzeppelin/contracts/access/AccessControl.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;









/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context {

    using EnumerableSet for EnumerableSet.AddressSet;

    using Address for address;



    struct RoleData {

        EnumerableSet.AddressSet members;

        bytes32 adminRole;

    }



    mapping (bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view returns (bool) {

        return _roles[role].members.contains(account);

    }



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {

        return _roles[role].members.length();

    }



    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {

        return _roles[role].members.at(index);

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");



        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");



        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (_roles[role].members.add(account)) {

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (_roles[role].members.remove(account)) {

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}



// File: contracts/common/AccessControlMixin.sol



pragma solidity 0.6.6;





contract AccessControlMixin is AccessControl {

    string private _revertMsg;

    function _setupContractId(string memory contractId) internal {

        _revertMsg = string(abi.encodePacked(contractId, ": INSUFFICIENT_PERMISSIONS"));

    }



    modifier only(bytes32 role) {

        require(

            hasRole(role, _msgSender()),

            _revertMsg

        );

        _;

    }

}



// File: contracts/common/ContextMixin.sol



pragma solidity 0.6.6;



abstract contract ContextMixin {

    function msgSender()

        internal

        view

        returns (address payable sender)

    {

        if (msg.sender == address(this)) {

            bytes memory array = msg.data;

            uint256 index = msg.data.length;

            assembly {

                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.

                sender := and(

                    mload(add(array, index)),

                    0xffffffffffffffffffffffffffffffffffffffff

                )

            }

        } else {

            sender = msg.sender;

        }

        return sender;

    }

}



// File: contracts/root/RootChainManager/RootChainManager.sol



pragma solidity 0.6.6;

































contract RootChainManager is

    IRootChainManager,

    Initializable,

    AccessControl, // included to match old storage layout while upgrading

    RootChainManagerStorage, // created to match old storage layout while upgrading

    AccessControlMixin,

    NativeMetaTransaction,

    ContextMixin

{

    using ExitPayloadReader for bytes;

    using ExitPayloadReader for ExitPayloadReader.ExitPayload;

    using ExitPayloadReader for ExitPayloadReader.Log;

    using ExitPayloadReader for ExitPayloadReader.Receipt;



    using Merkle for bytes32;

    using SafeMath for uint256;



    // maybe DEPOSIT and MAP_TOKEN can be reduced to bytes4

    bytes32 public constant DEPOSIT = keccak256("DEPOSIT");

    bytes32 public constant MAP_TOKEN = keccak256("MAP_TOKEN");

    address public constant ETHER_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    bytes32 public constant MAPPER_ROLE = keccak256("MAPPER_ROLE");



    function _msgSender()

        internal

        override

        view

        returns (address payable sender)

    {

        return ContextMixin.msgSender();

    }



    /**

     * @notice Deposit ether by directly sending to the contract

     * The account sending ether receives WETH on child chain

     */

    receive() external payable {

        _depositEtherFor(_msgSender());

    }



    /**

     * @notice Initialize the contract after it has been proxified

     * @dev meant to be called once immediately after deployment

     * @param _owner the account that should be granted admin role

     */

    function initialize(

        address _owner

    )

        external

        initializer

    {

        _initializeEIP712("RootChainManager");

        _setupContractId("RootChainManager");

        _setupRole(DEFAULT_ADMIN_ROLE, _owner);

        _setupRole(MAPPER_ROLE, _owner);

    }



    // adding seperate function setupContractId since initialize is already called with old implementation

    function setupContractId()

        external

        only(DEFAULT_ADMIN_ROLE)

    {

        _setupContractId("RootChainManager");

    }



    // adding seperate function initializeEIP712 since initialize is already called with old implementation

    function initializeEIP712()

        external

        only(DEFAULT_ADMIN_ROLE)

    {

        _setDomainSeperator("RootChainManager");

    }



    /**

     * @notice Set the state sender, callable only by admins

     * @dev This should be the state sender from plasma contracts

     * It is used to send bytes from root to child chain

     * @param newStateSender address of state sender contract

     */

    function setStateSender(address newStateSender)

        external

        only(DEFAULT_ADMIN_ROLE)

    {

        require(newStateSender != address(0), "RootChainManager: BAD_NEW_STATE_SENDER");

        _stateSender = IStateSender(newStateSender);

    }



    /**

     * @notice Get the address of contract set as state sender

     * @return The address of state sender contract

     */

    function stateSenderAddress() external view returns (address) {

        return address(_stateSender);

    }



    /**

     * @notice Set the checkpoint manager, callable only by admins

     * @dev This should be the plasma contract responsible for keeping track of checkpoints

     * @param newCheckpointManager address of checkpoint manager contract

     */

    function setCheckpointManager(address newCheckpointManager)

        external

        only(DEFAULT_ADMIN_ROLE)

    {

        require(newCheckpointManager != address(0), "RootChainManager: BAD_NEW_CHECKPOINT_MANAGER");

        _checkpointManager = ICheckpointManager(newCheckpointManager);

    }



    /**

     * @notice Get the address of contract set as checkpoint manager

     * @return The address of checkpoint manager contract

     */

    function checkpointManagerAddress() external view returns (address) {

        return address(_checkpointManager);

    }



    /**

     * @notice Set the child chain manager, callable only by admins

     * @dev This should be the contract responsible to receive deposit bytes on child chain

     * @param newChildChainManager address of child chain manager contract

     */

    function setChildChainManagerAddress(address newChildChainManager)

        external

        only(DEFAULT_ADMIN_ROLE)

    {

        require(newChildChainManager != address(0x0), "RootChainManager: INVALID_CHILD_CHAIN_ADDRESS");

        childChainManagerAddress = newChildChainManager;

    }



    /**

     * @notice Register a token predicate address against its type, callable only by ADMIN

     * @dev A predicate is a contract responsible to process the token specific logic while locking or exiting tokens

     * @param tokenType bytes32 unique identifier for the token type

     * @param predicateAddress address of token predicate address

     */

    function registerPredicate(bytes32 tokenType, address predicateAddress)

        external

        override

        only(DEFAULT_ADMIN_ROLE)

    {

        typeToPredicate[tokenType] = predicateAddress;

        emit PredicateRegistered(tokenType, predicateAddress);

    }



    /**

     * @notice Map a token to enable its movement via the PoS Portal, callable only by mappers

     * @param rootToken address of token on root chain

     * @param childToken address of token on child chain

     * @param tokenType bytes32 unique identifier for the token type

     */

    function mapToken(

        address rootToken,

        address childToken,

        bytes32 tokenType

    ) external override only(MAPPER_ROLE) {

        // explicit check if token is already mapped to avoid accidental remaps

        require(

            rootToChildToken[rootToken] == address(0) &&

            childToRootToken[childToken] == address(0),

            "RootChainManager: ALREADY_MAPPED"

        );

        _mapToken(rootToken, childToken, tokenType);

    }



    /**

     * @notice Clean polluted token mapping

     * @param rootToken address of token on root chain. Since rename token was introduced later stage,

     * clean method is used to clean pollulated mapping

     */

    function cleanMapToken(

        address rootToken,

        address childToken

    ) external override only(DEFAULT_ADMIN_ROLE) {

        rootToChildToken[rootToken] = address(0);

        childToRootToken[childToken] = address(0);

        tokenToType[rootToken] = bytes32(0);



        emit TokenMapped(rootToken, childToken, tokenToType[rootToken]);

    }



    /**

     * @notice Remap a token that has already been mapped, properly cleans up old mapping

     * Callable only by ADMIN

     * @param rootToken address of token on root chain

     * @param childToken address of token on child chain

     * @param tokenType bytes32 unique identifier for the token type

     */

    function remapToken(

        address rootToken,

        address childToken,

        bytes32 tokenType

    ) external override only(DEFAULT_ADMIN_ROLE) {

        // cleanup old mapping

        address oldChildToken = rootToChildToken[rootToken];

        address oldRootToken = childToRootToken[childToken];



        if (rootToChildToken[oldRootToken] != address(0)) {

            rootToChildToken[oldRootToken] = address(0);

            tokenToType[oldRootToken] = bytes32(0);

        }



        if (childToRootToken[oldChildToken] != address(0)) {

            childToRootToken[oldChildToken] = address(0);

        }



        _mapToken(rootToken, childToken, tokenType);

    }



    function _mapToken(

        address rootToken,

        address childToken,

        bytes32 tokenType

    ) private {

        require(

            typeToPredicate[tokenType] != address(0x0),

            "RootChainManager: TOKEN_TYPE_NOT_SUPPORTED"

        );



        rootToChildToken[rootToken] = childToken;

        childToRootToken[childToken] = rootToken;

        tokenToType[rootToken] = tokenType;



        emit TokenMapped(rootToken, childToken, tokenType);



        bytes memory syncData = abi.encode(rootToken, childToken, tokenType);

        _stateSender.syncState(

            childChainManagerAddress,

            abi.encode(MAP_TOKEN, syncData)

        );

    }



    /**

     * @notice Move ether from root to child chain, accepts ether transfer

     * Keep in mind this ether cannot be used to pay gas on child chain

     * Use Matic tokens deposited using plasma mechanism for that

     * @param user address of account that should receive WETH on child chain

     */

    function depositEtherFor(address user) external override payable {

        _depositEtherFor(user);

    }



    /**

     * @notice Move tokens from root to child chain

     * @dev This mechanism supports arbitrary tokens as long as its predicate has been registered and the token is mapped

     * @param user address of account that should receive this deposit on child chain

     * @param rootToken address of token that is being deposited

     * @param depositData bytes data that is sent to predicate and child token contracts to handle deposit

     */

    function depositFor(

        address user,

        address rootToken,

        bytes calldata depositData

    ) external override {

        require(

            rootToken != ETHER_ADDRESS,

            "RootChainManager: INVALID_ROOT_TOKEN"

        );

        _depositFor(user, rootToken, depositData);

    }



    function _depositEtherFor(address user) private {

        bytes memory depositData = abi.encode(msg.value);

        _depositFor(user, ETHER_ADDRESS, depositData);



        // payable(typeToPredicate[tokenToType[ETHER_ADDRESS]]).transfer(msg.value);

        // transfer doesn't work as expected when receiving contract is proxified so using call

        (bool success, /* bytes memory data */) = typeToPredicate[tokenToType[ETHER_ADDRESS]].call{value: msg.value}("");

        if (!success) {

            revert("RootChainManager: ETHER_TRANSFER_FAILED");

        }

    }



    function _depositFor(

        address user,

        address rootToken,

        bytes memory depositData

    ) private {

        bytes32 tokenType = tokenToType[rootToken];

        require(

            rootToChildToken[rootToken] != address(0x0) &&

               tokenType != 0,

            "RootChainManager: TOKEN_NOT_MAPPED"

        );

        address predicateAddress = typeToPredicate[tokenType];

        require(

            predicateAddress != address(0),

            "RootChainManager: INVALID_TOKEN_TYPE"

        );

        require(

            user != address(0),

            "RootChainManager: INVALID_USER"

        );



        ITokenPredicate(predicateAddress).lockTokens(

            _msgSender(),

            user,

            rootToken,

            depositData

        );

        bytes memory syncData = abi.encode(user, rootToken, depositData);

        _stateSender.syncState(

            childChainManagerAddress,

            abi.encode(DEPOSIT, syncData)

        );

    }



    /**

     * @notice exit tokens by providing proof

     * @dev This function verifies if the transaction actually happened on child chain

     * the transaction log is then sent to token predicate to handle it accordingly

     *

     * @param inputData RLP encoded data of the reference tx containing following list of fields

     *  0 - headerNumber - Checkpoint header block number containing the reference tx

     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root

     *  2 - blockNumber - Block number containing the reference tx on child chain

     *  3 - blockTime - Reference tx block time

     *  4 - txRoot - Transactions root of block

     *  5 - receiptRoot - Receipts root of block

     *  6 - receipt - Receipt of the reference transaction

     *  7 - receiptProof - Merkle proof of the reference receipt

     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree

     *  9 - receiptLogIndex - Log Index to read from the receipt

     */

    function exit(bytes calldata inputData) external override {

        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();



        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();

        // checking if exit has already been processed

        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)

        bytes32 exitHash = keccak256(

            abi.encodePacked(

                payload.getBlockNumber(),

                // first 2 nibbles are dropped while generating nibble array

                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)

                // so converting to nibble array and then hashing it

                MerklePatriciaProof._getNibbleArray(branchMaskBytes),

                payload.getReceiptLogIndex()

            )

        );



        require(

            processedExits[exitHash] == false,

            "RootChainManager: EXIT_ALREADY_PROCESSED"

        );

        processedExits[exitHash] = true;



        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();

        ExitPayloadReader.Log memory log = receipt.getLog();



        // log should be emmited only by the child token

        address rootToken = childToRootToken[log.getEmitter()];

        require(

            rootToken != address(0),

            "RootChainManager: TOKEN_NOT_MAPPED"

        );



        address predicateAddress = typeToPredicate[

            tokenToType[rootToken]

        ];



        // branch mask can be maximum 32 bits

        require(

            payload.getBranchMaskAsUint() &

            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000 ==

            0,

            "RootChainManager: INVALID_BRANCH_MASK"

        );



        // verify receipt inclusion

        require(

            MerklePatriciaProof.verify(

                receipt.toBytes(),

                branchMaskBytes,

                payload.getReceiptProof(),

                payload.getReceiptRoot()

            ),

            "RootChainManager: INVALID_PROOF"

        );



        // verify checkpoint inclusion

        _checkBlockMembershipInCheckpoint(

            payload.getBlockNumber(),

            payload.getBlockTime(),

            payload.getTxRoot(),

            payload.getReceiptRoot(),

            payload.getHeaderNumber(),

            payload.getBlockProof()

        );



        ITokenPredicate(predicateAddress).exitTokens(

            _msgSender(),

            rootToken,

            log.toRlpBytes()

        );

    }



    function _checkBlockMembershipInCheckpoint(

        uint256 blockNumber,

        uint256 blockTime,

        bytes32 txRoot,

        bytes32 receiptRoot,

        uint256 headerNumber,

        bytes memory blockProof

    ) private view returns (uint256) {

        (

            bytes32 headerRoot,

            uint256 startBlock,

            ,

            uint256 createdAt,



        ) = _checkpointManager.headerBlocks(headerNumber);



        require(

            keccak256(

                abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)

            )

                .checkMembership(

                blockNumber.sub(startBlock),

                headerRoot,

                blockProof

            ),

            "RootChainManager: INVALID_HEADER"

        );

        return createdAt;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\RootChainManagerProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-08-26

*/



// File: contracts/common/Proxy/IERCProxy.sol



pragma solidity 0.6.6;



interface IERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/Proxy/Proxy.sol



pragma solidity 0.6.6;





abstract contract Proxy is IERCProxy {

    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas(), 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize()



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }



    function proxyType() external virtual override pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external virtual override view returns (address);

}



// File: contracts/common/Proxy/UpgradableProxy.sol



pragma solidity 0.6.6;





contract UpgradableProxy is Proxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event ProxyOwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setProxyOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    fallback() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    receive() external payable {

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadProxyOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function proxyOwner() external view returns(address) {

        return loadProxyOwner();

    }



    function loadProxyOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external override view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferProxyOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit ProxyOwnerUpdate(newOwner, loadProxyOwner());

        setProxyOwner(newOwner);

    }



    function setProxyOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call{value: msg.value}(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/RootChainManager/RootChainManagerProxy.sol



pragma solidity 0.6.6;





contract RootChainManagerProxy is UpgradableProxy {

    constructor(address _proxyTo)

        public

        UpgradableProxy(_proxyTo)

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\RootChainProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-31

*/



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;





interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        require(msg.sender == address(governance), "Only governance contract is authorized");

        _;

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;





contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;





contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;





/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor() internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/misc/ProxyStorage.sol



pragma solidity ^0.5.2;





contract ProxyStorage is Ownable {

    address internal proxyTo;

}



// File: contracts/common/mixin/ChainIdMixin.sol



pragma solidity ^0.5.2;





contract ChainIdMixin {

    bytes public constant networkId = hex"89";

    uint256 public constant CHAINID = 137;

}



// File: contracts/root/RootChainStorage.sol



pragma solidity ^0.5.2;





contract RootChainHeader {

    event NewHeaderBlock(

        address indexed proposer,

        uint256 indexed headerBlockId,

        uint256 indexed reward,

        uint256 start,

        uint256 end,

        bytes32 root

    );

    // housekeeping event

    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }

}





contract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {

    bytes32 public heimdallId;

    uint8 public constant VOTE_TYPE = 2;



    uint16 internal constant MAX_DEPOSITS = 10000;

    uint256 public _nextHeaderBlock = MAX_DEPOSITS;

    uint256 internal _blockDepositId = 1;

    mapping(uint256 => HeaderBlock) public headerBlocks;

    Registry internal registry;

}



// File: contracts/common/misc/ERCProxy.sol



/*

 * SPDX-License-Identitifer:    MIT

 */



pragma solidity ^0.5.2;





// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md



interface ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/misc/DelegateProxy.sol



pragma solidity ^0.5.2;





contract DelegateProxy is ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external view returns (address);



    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)

            let size := returndatasize



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }

}



// File: contracts/common/misc/Proxy.sol



pragma solidity ^0.5.2;





contract Proxy is ProxyStorage, DelegateProxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event OwnerUpdate(address _prevOwner, address _newOwner);



    constructor(address _proxyTo) public {

        updateImplementation(_proxyTo);

    }



    function() external payable {

        // require(currentContract != 0, "If app code has not been set yet, do not call");

        // Todo: filter out some calls or handle in the end fallback

        delegatedFwd(proxyTo, msg.data);

    }



    function implementation() external view returns (address) {

        return proxyTo;

    }



    function updateImplementation(address _newProxyTo) public onlyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");

        emit ProxyUpdated(_newProxyTo, proxyTo);

        proxyTo = _newProxyTo;

    }



    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/RootChainProxy.sol



pragma solidity ^0.5.2;





contract RootChainProxy is Proxy, RootChainStorage {

    constructor(

        address _proxyTo,

        address _registry,

        string memory _heimdallId

    ) public Proxy(_proxyTo) {

        registry = Registry(_registry);

        heimdallId = keccak256(abi.encodePacked(_heimdallId));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC20.sol";

import "../../../utils/Address.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender) + value;

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        unchecked {

            uint256 oldAllowance = token.allowance(address(this), spender);

            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");

            uint256 newAllowance = oldAllowance - value;

            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

        }

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {

            // Return data is optional

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\SafeMath.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\StakeManager.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2022-11-14

*/



// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.2;



/**

 * @title ERC20 interface

 * @dev see https://eips.ethereum.org/EIPS/eip-20

 */

interface IERC20 {

    function transfer(address to, uint256 value) external returns (bool);



    function approve(address spender, uint256 value) external returns (bool);



    function transferFrom(address from, address to, uint256 value) external returns (bool);



    function totalSupply() external view returns (uint256);



    function balanceOf(address who) external view returns (uint256);



    function allowance(address owner, address spender) external view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: openzeppelin-solidity/contracts/math/Math.sol



pragma solidity ^0.5.2;



/**

 * @title Math

 * @dev Assorted math operations

 */

library Math {

    /**

     * @dev Returns the largest of two numbers.

     */

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    /**

     * @dev Returns the smallest of two numbers.

     */

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    /**

     * @dev Calculates the average of two numbers. Since these are integers,

     * averages of an even and odd number cannot be represented, and will be

     * rounded down.

     */

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b) / 2 can overflow, so we distribute

        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: solidity-rlp/contracts/RLPReader.sol



/*

* @author Hamdi Allam hamdi.allam97@gmail.com

* Please reach out with any questions or concerns

*/

pragma solidity ^0.5.0;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param item RLP encoded bytes

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        return item.len - _payloadOffset(item.memPtr);

    }



    /*

    * @param item RLP encoded list in bytes

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        return result == 0 ? false : true;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset;



        uint result;

        uint memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: contracts/common/lib/BytesLib.sol



pragma solidity ^0.5.2;



library BytesLib {

    function concat(bytes memory _preBytes, bytes memory _postBytes)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;

        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(

                0x40,

                and(

                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),

                    not(31) // Round down to the nearest 32 bytes.

                )

            )

        }

        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start, uint256 _length)

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));

        bytes memory tempBytes;

        assembly {

            switch iszero(_length)

                case 0 {

                    // Get a location of some free memory and store it in tempBytes as

                    // Solidity does for memory variables.

                    tempBytes := mload(0x40)



                    // The first word of the slice result is potentially a partial

                    // word read from the original array. To read it, we calculate

                    // the length of that partial word and start copying that many

                    // bytes into the array. The first word we copy will start with

                    // data we don't care about, but the last `lengthmod` bytes will

                    // land at the beginning of the contents of the new array. When

                    // we're done copying, we overwrite the full first word with

                    // the actual length of the slice.

                    let lengthmod := and(_length, 31)



                    // The multiplication in the next line is necessary

                    // because when slicing multiples of 32 bytes (lengthmod == 0)

                    // the following copy loop was copying the origin's length

                    // and then ending prematurely not copying everything it should.

                    let mc := add(

                        add(tempBytes, lengthmod),

                        mul(0x20, iszero(lengthmod))

                    )

                    let end := add(mc, _length)



                    for {

                        // The multiplication in the next line has the same exact purpose

                        // as the one above.

                        let cc := add(

                            add(

                                add(_bytes, lengthmod),

                                mul(0x20, iszero(lengthmod))

                            ),

                            _start

                        )

                    } lt(mc, end) {

                        mc := add(mc, 0x20)

                        cc := add(cc, 0x20)

                    } {

                        mstore(mc, mload(cc))

                    }



                    mstore(tempBytes, _length)



                    //update free-memory pointer

                    //allocating the array padded to 32 bytes like the compiler does now

                    mstore(0x40, and(add(mc, 31), not(31)))

                }

                //if we want a zero-length slice let's just return a zero-length array

                default {

                    tempBytes := mload(0x40)

                    mstore(0x40, add(tempBytes, 0x20))

                }

        }



        return tempBytes;

    }



    // Pad a bytes array to 32 bytes

    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {

        // may underflow if bytes.length < 32. Hence using SafeMath.sub

        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));

        return concat(newBytes, _bytes);

    }



    function toBytes32(bytes memory b) internal pure returns (bytes32) {

        require(b.length >= 32, "Bytes array should atleast be 32 bytes");

        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {

            out |= bytes32(b[i] & 0xFF) >> (i * 8);

        }

        return out;

    }



    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {

        assembly {

            result := mload(add(b, 32))

        }

    }



    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {

        bytes memory b = new bytes(32);

        for (uint256 i = 0; i < 32; i++) {

            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));

        }

        return b;

    }



    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {

        _ret = new bytes(32);

        assembly {

            mstore(add(_ret, 32), _num)

        }

    }



    function toUint(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (uint256)

    {

        require(_bytes.length >= (_start + 32));

        uint256 tempUint;

        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }

        return tempUint;

    }



    function toAddress(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (address)

    {

        require(_bytes.length >= (_start + 20));

        address tempAddress;

        assembly {

            tempAddress := div(

                mload(add(add(_bytes, 0x20), _start)),

                0x1000000000000000000000000

            )

        }



        return tempAddress;

    }

}



// File: contracts/common/lib/ECVerify.sol



pragma solidity ^0.5.2;





library ECVerify {

    function ecrecovery(bytes32 hash, uint[3] memory sig)

        internal

        pure

        returns (address)

    {

        bytes32 r;

        bytes32 s;

        uint8 v;



        assembly {

            r := mload(sig)

            s := mload(add(sig, 32))

            v := byte(31, mload(add(sig, 64)))

        }



        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            return address(0x0);

        }



        // https://github.com/ethereum/go-ethereum/issues/2053

        if (v < 27) {

            v += 27;

        }



        if (v != 27 && v != 28) {

            return address(0x0);

        }



        // get address out of hash and signature

        address result = ecrecover(hash, v, r, s);



        // ecrecover returns zero on error

        require(result != address(0x0));



        return result;

    }



    function ecrecovery(bytes32 hash, bytes memory sig)

        internal

        pure

        returns (address)

    {

        bytes32 r;

        bytes32 s;

        uint8 v;



        if (sig.length != 65) {

            return address(0x0);

        }



        assembly {

            r := mload(add(sig, 32))

            s := mload(add(sig, 64))

            v := and(mload(add(sig, 65)), 255)

        }



        // https://github.com/ethereum/go-ethereum/issues/2053

        if (v < 27) {

            v += 27;

        }



        if (v != 27 && v != 28) {

            return address(0x0);

        }



        // get address out of hash and signature

        address result = ecrecover(hash, v, r, s);



        // ecrecover returns zero on error

        require(result != address(0x0));



        return result;

    }



    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)

        internal

        pure

        returns (address)

    {

        // get address out of hash and signature

        address result = ecrecover(hash, v, r, s);



        // ecrecover returns zero on error

        require(result != address(0x0), "signature verification failed");



        return result;

    }



    function ecverify(bytes32 hash, bytes memory sig, address signer)

        internal

        pure

        returns (bool)

    {

        return signer == ecrecovery(hash, sig);

    }

}



// File: contracts/common/lib/Merkle.sol



pragma solidity ^0.5.2;



library Merkle {

    function checkMembership(

        bytes32 leaf,

        uint256 index,

        bytes32 rootHash,

        bytes memory proof

    ) internal pure returns (bool) {

        require(proof.length % 32 == 0, "Invalid proof length");

        uint256 proofHeight = proof.length / 32;

        // Proof of size n means, height of the tree is n+1.

        // In a tree of height n+1, max #leafs possible is 2 ^ n

        require(index < 2 ** proofHeight, "Leaf index is too big");



        bytes32 proofElement;

        bytes32 computedHash = leaf;

        for (uint256 i = 32; i <= proof.length; i += 32) {

            assembly {

                proofElement := mload(add(proof, i))

            }



            if (index % 2 == 0) {

                computedHash = keccak256(

                    abi.encodePacked(computedHash, proofElement)

                );

            } else {

                computedHash = keccak256(

                    abi.encodePacked(proofElement, computedHash)

                );

            }



            index = index / 2;

        }

        return computedHash == rootHash;

    }

}



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;



contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        _assertGovernance();

        _;

    }



    function _assertGovernance() private view {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

    }

}



// File: contracts/common/mixin/Lockable.sol



pragma solidity ^0.5.2;



contract Lockable {

    bool public locked;



    modifier onlyWhenUnlocked() {

        _assertUnlocked();

        _;

    }



    function _assertUnlocked() private view {

        require(!locked, "locked");

    }



    function lock() public {

        locked = true;

    }



    function unlock() public {

        locked = false;

    }

}



// File: contracts/common/mixin/GovernanceLockable.sol



pragma solidity ^0.5.2;





contract GovernanceLockable is Lockable, Governable {

    constructor(address governance) public Governable(governance) {}



    function lock() public onlyGovernance {

        super.lock();

    }



    function unlock() public onlyGovernance {

        super.unlock();

    }

}



// File: contracts/common/misc/DelegateProxyForwarder.sol



pragma solidity ^0.5.2;



contract DelegateProxyForwarder {

    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas, 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;





contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity 0.5.17;



contract IStakeManager {

    // validator replacement

    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        uint[3][] calldata sigs

    ) external returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes calldata slashingInfoList) external returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function getRegistry() public view returns (address);



    function withdrawalDelay() public view returns (uint256);



    function delegatedAmount(uint256 validatorId) public view returns(uint256);



    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;



    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);



    function delegatorsReward(uint256 validatorId) public view returns(uint256);



    function dethroneAndStake(

        address auctionUser,

        uint256 heimdallFee,

        uint256 validatorId,

        uint256 auctionAmount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;

}



// File: contracts/staking/validatorShare/IValidatorShare.sol



pragma solidity 0.5.17;



// note this contract interface is only for stakeManager use

contract IValidatorShare {

    function withdrawRewards() public;



    function unstakeClaimTokens() public;



    function getLiquidRewards(address user) public view returns (uint256);

    

    function owner() public view returns (address);



    function restake() public returns(uint256, uint256);



    function unlock() external;



    function lock() external;



    function drain(

        address token,

        address payable destination,

        uint256 amount

    ) external;



    function slash(uint256 valPow, uint256 delegatedAmount, uint256 totalAmountToSlash) external returns (uint256);



    function updateDelegation(bool delegation) external;



    function migrateOut(address user, uint256 amount) external;



    function migrateIn(address user, uint256 amount) external;

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.5.2;





/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * https://eips.ethereum.org/EIPS/eip-20

 * Originally based on code by FirstBlood:

 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 *

 * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for

 * all accounts just by listening to said events. Note that this isn't required by the specification, and other

 * compliant implementations may not do it.

 */

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowed;



    uint256 private _totalSupply;



    /**

     * @dev Total number of tokens in existence

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev Gets the balance of the specified address.

     * @param owner The address to query the balance of.

     * @return A uint256 representing the amount owned by the passed address.

     */

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    /**

     * @dev Function to check the amount of tokens that an owner allowed to a spender.

     * @param owner address The address which owns the funds.

     * @param spender address The address which will spend the funds.

     * @return A uint256 specifying the amount of tokens still available for the spender.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    /**

     * @dev Transfer token to a specified address

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    /**

     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param spender The address which will spend the funds.

     * @param value The amount of tokens to be spent.

     */

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    /**

     * @dev Transfer tokens from one address to another.

     * Note that while this function emits an Approval event, this is not required as per the specification,

     * and other compliant implementations may not emit the event.

     * @param from address The address which you want to send tokens from

     * @param to address The address which you want to transfer to

     * @param value uint256 the amount of tokens to be transferred

     */

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _transfer(from, to, value);

        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));

        return true;

    }



    /**

     * @dev Increase the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To increment

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param addedValue The amount of tokens to increase the allowance by.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Decrease the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param subtractedValue The amount of tokens to decrease the allowance by.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    /**

     * @dev Transfer token for a specified addresses

     * @param from The address to transfer from.

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    /**

     * @dev Internal function that mints an amount of the token and assigns it to

     * an account. This encapsulates the modification of balances such that the

     * proper events are emitted.

     * @param account The account that will receive the created tokens.

     * @param value The amount that will be created.

     */

    function _mint(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account.

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burn(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    /**

     * @dev Approve an address to spend another addresses' tokens.

     * @param owner The address that owns the tokens.

     * @param spender The address that will spend the tokens.

     * @param value The number of tokens that can be spent.

     */

    function _approve(address owner, address spender, uint256 value) internal {

        require(spender != address(0));

        require(owner != address(0));



        _allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account, deducting from the sender's allowance for said account. Uses the

     * internal burn function.

     * Emits an Approval event (reflecting the reduced allowance).

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burnFrom(address account, uint256 value) internal {

        _burn(account, value);

        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));

    }

}



// File: contracts/common/tokens/ERC20NonTradable.sol



pragma solidity ^0.5.2;



contract ERC20NonTradable is ERC20 {

    function _approve(

        address owner,

        address spender,

        uint256 value

    ) internal {

        revert("disabled");

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/staking/StakingInfo.sol



pragma solidity ^0.5.2;







// dummy interface to avoid cyclic dependency

contract IStakeManagerLocal {

    enum Status {Inactive, Active, Locked, Unstaked}



    struct Validator {

        uint256 amount;

        uint256 reward;

        uint256 activationEpoch;

        uint256 deactivationEpoch;

        uint256 jailTime;

        address signer;

        address contractAddress;

        Status status;

    }



    mapping(uint256 => Validator) public validators;

    bytes32 public accountStateRoot;

    uint256 public activeAmount; // delegation amount from validator contract

    uint256 public validatorRewards;



    function currentValidatorSetTotalStake() public view returns (uint256);



    // signer to Validator mapping

    function signerToValidator(address validatorAddress)

        public

        view

        returns (uint256);



    function isValidator(uint256 validatorId) public view returns (bool);

}



contract StakingInfo is Ownable {

    using SafeMath for uint256;

    mapping(uint256 => uint256) public validatorNonce;



    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.

    /// @param signer validator address.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param activationEpoch validator's first epoch as proposer.

    /// @param amount staking amount.

    /// @param total total staking amount.

    /// @param signerPubkey public key of the validator

    event Staked(

        address indexed signer,

        uint256 indexed validatorId,

        uint256 nonce,

        uint256 indexed activationEpoch,

        uint256 amount,

        uint256 total,

        bytes signerPubkey

    );



    /// @dev Emitted when validator unstakes in 'unstakeClaim()'

    /// @param user address of the validator.

    /// @param validatorId unique integer to identify a validator.

    /// @param amount staking amount.

    /// @param total total staking amount.

    event Unstaked(

        address indexed user,

        uint256 indexed validatorId,

        uint256 amount,

        uint256 total

    );



    /// @dev Emitted when validator unstakes in '_unstake()'.

    /// @param user address of the validator.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param deactivationEpoch last epoch for validator.

    /// @param amount staking amount.

    event UnstakeInit(

        address indexed user,

        uint256 indexed validatorId,

        uint256 nonce,

        uint256 deactivationEpoch,

        uint256 indexed amount

    );



    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param oldSigner old address of the validator.

    /// @param newSigner new address of the validator.

    /// @param signerPubkey public key of the validator.

    event SignerChange(

        uint256 indexed validatorId,

        uint256 nonce,

        address indexed oldSigner,

        address indexed newSigner,

        bytes signerPubkey

    );

    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);

    event Jailed(

        uint256 indexed validatorId,

        uint256 indexed exitEpoch,

        address indexed signer

    );

    event UnJailed(uint256 indexed validatorId, address indexed signer);

    event Slashed(uint256 indexed nonce, uint256 indexed amount);

    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);

    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);

    event ProposerBonusChange(

        uint256 newProposerBonus,

        uint256 oldProposerBonus

    );



    event RewardUpdate(uint256 newReward, uint256 oldReward);



    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param newAmount the updated stake amount.

    event StakeUpdate(

        uint256 indexed validatorId,

        uint256 indexed nonce,

        uint256 indexed newAmount

    );

    event ClaimRewards(

        uint256 indexed validatorId,

        uint256 indexed amount,

        uint256 indexed totalAmount

    );

    event StartAuction(

        uint256 indexed validatorId,

        uint256 indexed amount,

        uint256 indexed auctionAmount

    );

    event ConfirmAuction(

        uint256 indexed newValidatorId,

        uint256 indexed oldValidatorId,

        uint256 indexed amount

    );

    event TopUpFee(address indexed user, uint256 indexed fee);

    event ClaimFee(address indexed user, uint256 indexed fee);

    // Delegator events

    event ShareMinted(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens

    );

    event ShareBurned(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens

    );

    event DelegatorClaimedRewards(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed rewards

    );

    event DelegatorRestaked(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed totalStaked

    );

    event DelegatorUnstaked(

        uint256 indexed validatorId,

        address indexed user,

        uint256 amount

    );

    event UpdateCommissionRate(

        uint256 indexed validatorId,

        uint256 indexed newCommissionRate,

        uint256 indexed oldCommissionRate

    );



    Registry public registry;



    modifier onlyValidatorContract(uint256 validatorId) {

        address _contract;

        (, , , , , , _contract, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

        require(_contract == msg.sender,

        "Invalid sender, not validator");

        _;

    }



    modifier StakeManagerOrValidatorContract(uint256 validatorId) {

        address _contract;

        address _stakeManager = registry.getStakeManagerAddress();

        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(

            validatorId

        );

        require(_contract == msg.sender || _stakeManager == msg.sender,

        "Invalid sender, not stake manager or validator contract");

        _;

    }



    modifier onlyStakeManager() {

        require(registry.getStakeManagerAddress() == msg.sender,

        "Invalid sender, not stake manager");

        _;

    }

    modifier onlySlashingManager() {

        require(registry.getSlashingManagerAddress() == msg.sender,

        "Invalid sender, not slashing manager");

        _;

    }



    constructor(address _registry) public {

        registry = Registry(_registry);

    }



    function updateNonce(

        uint256[] calldata validatorIds,

        uint256[] calldata nonces

    ) external onlyOwner {

        require(validatorIds.length == nonces.length, "args length mismatch");



        for (uint256 i = 0; i < validatorIds.length; ++i) {

            validatorNonce[validatorIds[i]] = nonces[i];

        }

    } 



    function logStaked(

        address signer,

        bytes memory signerPubkey,

        uint256 validatorId,

        uint256 activationEpoch,

        uint256 amount,

        uint256 total

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit Staked(

            signer,

            validatorId,

            validatorNonce[validatorId],

            activationEpoch,

            amount,

            total,

            signerPubkey

        );

    }



    function logUnstaked(

        address user,

        uint256 validatorId,

        uint256 amount,

        uint256 total

    ) public onlyStakeManager {

        emit Unstaked(user, validatorId, amount, total);

    }



    function logUnstakeInit(

        address user,

        uint256 validatorId,

        uint256 deactivationEpoch,

        uint256 amount

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit UnstakeInit(

            user,

            validatorId,

            validatorNonce[validatorId],

            deactivationEpoch,

            amount

        );

    }



    function logSignerChange(

        uint256 validatorId,

        address oldSigner,

        address newSigner,

        bytes memory signerPubkey

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit SignerChange(

            validatorId,

            validatorNonce[validatorId],

            oldSigner,

            newSigner,

            signerPubkey

        );

    }



    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)

        public

        onlyStakeManager

    {

        emit Restaked(validatorId, amount, total);

    }



    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)

        public

        onlyStakeManager

    {

        emit Jailed(validatorId, exitEpoch, signer);

    }



    function logUnjailed(uint256 validatorId, address signer)

        public

        onlyStakeManager

    {

        emit UnJailed(validatorId, signer);

    }



    function logSlashed(uint256 nonce, uint256 amount)

        public

        onlySlashingManager

    {

        emit Slashed(nonce, amount);

    }



    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)

        public

        onlyStakeManager

    {

        emit ThresholdChange(newThreshold, oldThreshold);

    }



    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)

        public

        onlyStakeManager

    {

        emit DynastyValueChange(newDynasty, oldDynasty);

    }



    function logProposerBonusChange(

        uint256 newProposerBonus,

        uint256 oldProposerBonus

    ) public onlyStakeManager {

        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);

    }



    function logRewardUpdate(uint256 newReward, uint256 oldReward)

        public

        onlyStakeManager

    {

        emit RewardUpdate(newReward, oldReward);

    }



    function logStakeUpdate(uint256 validatorId)

        public

        StakeManagerOrValidatorContract(validatorId)

    {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit StakeUpdate(

            validatorId,

            validatorNonce[validatorId],

            totalValidatorStake(validatorId)

        );

    }



    function logClaimRewards(

        uint256 validatorId,

        uint256 amount,

        uint256 totalAmount

    ) public onlyStakeManager {

        emit ClaimRewards(validatorId, amount, totalAmount);

    }



    function logStartAuction(

        uint256 validatorId,

        uint256 amount,

        uint256 auctionAmount

    ) public onlyStakeManager {

        emit StartAuction(validatorId, amount, auctionAmount);

    }



    function logConfirmAuction(

        uint256 newValidatorId,

        uint256 oldValidatorId,

        uint256 amount

    ) public onlyStakeManager {

        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);

    }



    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {

        emit TopUpFee(user, fee);

    }



    function logClaimFee(address user, uint256 fee) public onlyStakeManager {

        emit ClaimFee(user, fee);

    }



    function getStakerDetails(uint256 validatorId)

        public

        view

        returns (

            uint256 amount,

            uint256 reward,

            uint256 activationEpoch,

            uint256 deactivationEpoch,

            address signer,

            uint256 _status

        )

    {

        IStakeManagerLocal stakeManager = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        );

        address _contract;

        IStakeManagerLocal.Status status;

        (

            amount,

            reward,

            activationEpoch,

            deactivationEpoch,

            ,

            signer,

            _contract,

            status

        ) = stakeManager.validators(validatorId);

        _status = uint256(status);

        if (_contract != address(0x0)) {

            reward += IStakeManagerLocal(_contract).validatorRewards();

        }

    }



    function totalValidatorStake(uint256 validatorId)

        public

        view

        returns (uint256 validatorStake)

    {

        address contractAddress;

        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

        if (contractAddress != address(0x0)) {

            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();

        }

    }



    function getAccountStateRoot()

        public

        view

        returns (bytes32 accountStateRoot)

    {

        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())

            .accountStateRoot();

    }



    function getValidatorContractAddress(uint256 validatorId)

        public

        view

        returns (address ValidatorContract)

    {

        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

    }



    // validator Share contract logging func

    function logShareMinted(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens

    ) public onlyValidatorContract(validatorId) {

        emit ShareMinted(validatorId, user, amount, tokens);

    }



    function logShareBurned(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens

    ) public onlyValidatorContract(validatorId) {

        emit ShareBurned(validatorId, user, amount, tokens);

    }



    function logDelegatorClaimRewards(

        uint256 validatorId,

        address user,

        uint256 rewards

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorClaimedRewards(validatorId, user, rewards);

    }



    function logDelegatorRestaked(

        uint256 validatorId,

        address user,

        uint256 totalStaked

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorRestaked(validatorId, user, totalStaked);

    }



    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)

        public

        onlyValidatorContract(validatorId)

    {

        emit DelegatorUnstaked(validatorId, user, amount);

    }



    // deprecated

    function logUpdateCommissionRate(

        uint256 validatorId,

        uint256 newCommissionRate,

        uint256 oldCommissionRate

    ) public onlyValidatorContract(validatorId) {

        emit UpdateCommissionRate(

            validatorId,

            newCommissionRate,

            oldCommissionRate

        );

    }

}



// File: contracts/common/mixin/Initializable.sol



pragma solidity ^0.5.2;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        inited = true;

        

        _;

    }

}



// File: contracts/staking/EventsHub.sol



pragma solidity ^0.5.2;





contract IStakeManagerEventsHub {

    struct Validator {

        uint256 amount;

        uint256 reward;

        uint256 activationEpoch;

        uint256 deactivationEpoch;

        uint256 jailTime;

        address signer;

        address contractAddress;

    }



    mapping(uint256 => Validator) public validators;

}



contract EventsHub is Initializable {

    Registry public registry;



    modifier onlyValidatorContract(uint256 validatorId) {

        address _contract;

        (, , , , , , _contract) = IStakeManagerEventsHub(registry.getStakeManagerAddress()).validators(validatorId);

        require(_contract == msg.sender, "not validator");

        _;

    }



    modifier onlyStakeManager() {

        require(registry.getStakeManagerAddress() == msg.sender,

        "Invalid sender, not stake manager");

        _;

    }



    function initialize(Registry _registry) external initializer {

        registry = _registry;

    }



    event ShareBurnedWithId(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens,

        uint256 nonce

    );



    function logShareBurnedWithId(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens,

        uint256 nonce

    ) public onlyValidatorContract(validatorId) {

        emit ShareBurnedWithId(validatorId, user, amount, tokens, nonce);

    }



    event DelegatorUnstakeWithId(

        uint256 indexed validatorId,

        address indexed user,

        uint256 amount,

        uint256 nonce

    );



    function logDelegatorUnstakedWithId(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 nonce

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorUnstakeWithId(validatorId, user, amount, nonce);

    }



    event RewardParams(

        uint256 rewardDecreasePerCheckpoint,

        uint256 maxRewardedCheckpoints,

        uint256 checkpointRewardDelta

    );



    function logRewardParams(

        uint256 rewardDecreasePerCheckpoint,

        uint256 maxRewardedCheckpoints,

        uint256 checkpointRewardDelta

    ) public onlyStakeManager {

        emit RewardParams(rewardDecreasePerCheckpoint, maxRewardedCheckpoints, checkpointRewardDelta);

    }



    event UpdateCommissionRate(

        uint256 indexed validatorId,

        uint256 indexed newCommissionRate,

        uint256 indexed oldCommissionRate

    );



    function logUpdateCommissionRate(

        uint256 validatorId,

        uint256 newCommissionRate,

        uint256 oldCommissionRate

    ) public onlyStakeManager {

        emit UpdateCommissionRate(

            validatorId,

            newCommissionRate,

            oldCommissionRate

        );

    }



    event SharesTransfer(

        uint256 indexed validatorId,

        address indexed from,

        address indexed to,

        uint256 value

    );



    function logSharesTransfer(

        uint256 validatorId,

        address from,

        address to,

        uint256 value

    ) public onlyValidatorContract(validatorId) {

        emit SharesTransfer(validatorId, from, to, value);

    }

}



// File: contracts/common/mixin/OwnableLockable.sol



pragma solidity ^0.5.2;





contract OwnableLockable is Lockable, Ownable {

    function lock() public onlyOwner {

        super.lock();

    }



    function unlock() public onlyOwner {

        super.unlock();

    }

}



// File: contracts/staking/validatorShare/ValidatorShare.sol



pragma solidity 0.5.17;



















contract ValidatorShare is IValidatorShare, ERC20NonTradable, OwnableLockable, Initializable {

    struct DelegatorUnbond {

        uint256 shares;

        uint256 withdrawEpoch;

    }



    uint256 constant EXCHANGE_RATE_PRECISION = 100;

    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares

    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10**29;

    uint256 constant MAX_COMMISION_RATE = 100;

    uint256 constant REWARD_PRECISION = 10**25;



    StakingInfo public stakingLogger;

    IStakeManager public stakeManager;

    uint256 public validatorId;

    uint256 public validatorRewards_deprecated;

    uint256 public commissionRate_deprecated;

    uint256 public lastCommissionUpdate_deprecated;

    uint256 public minAmount;



    uint256 public totalStake_deprecated;

    uint256 public rewardPerShare;

    uint256 public activeAmount;



    bool public delegation;



    uint256 public withdrawPool;

    uint256 public withdrawShares;



    mapping(address => uint256) amountStaked_deprecated; // deprecated, keep for foundation delegators

    mapping(address => DelegatorUnbond) public unbonds;

    mapping(address => uint256) public initalRewardPerShare;



    mapping(address => uint256) public unbondNonces;

    mapping(address => mapping(uint256 => DelegatorUnbond)) public unbonds_new;



    EventsHub public eventsHub;



    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address

    function initialize(

        uint256 _validatorId,

        address _stakingLogger,

        address _stakeManager

    ) external initializer {

        validatorId = _validatorId;

        stakingLogger = StakingInfo(_stakingLogger);

        stakeManager = IStakeManager(_stakeManager);

        _transferOwnership(_stakeManager);

        _getOrCacheEventsHub();



        minAmount = 10**18;

        delegation = true;

    }



    /**

        Public View Methods

    */



    function exchangeRate() public view returns (uint256) {

        uint256 totalShares = totalSupply();

        uint256 precision = _getRatePrecision();

        return totalShares == 0 ? precision : stakeManager.delegatedAmount(validatorId).mul(precision).div(totalShares);

    }



    function getTotalStake(address user) public view returns (uint256, uint256) {

        uint256 shares = balanceOf(user);

        uint256 rate = exchangeRate();

        if (shares == 0) {

            return (0, rate);

        }



        return (rate.mul(shares).div(_getRatePrecision()), rate);

    }



    function withdrawExchangeRate() public view returns (uint256) {

        uint256 precision = _getRatePrecision();

        if (validatorId < 8) {

            // fix of potentially broken withdrawals for future unbonding

            // foundation validators have no slashing enabled and thus we can return default exchange rate

            // because without slashing rate will stay constant

            return precision;

        }



        uint256 _withdrawShares = withdrawShares;

        return _withdrawShares == 0 ? precision : withdrawPool.mul(precision).div(_withdrawShares);

    }



    function getLiquidRewards(address user) public view returns (uint256) {

        return _calculateReward(user, getRewardPerShare());

    }



    function getRewardPerShare() public view returns (uint256) {

        return _calculateRewardPerShareWithRewards(stakeManager.delegatorsReward(validatorId));

    }



    /**

        Public Methods

     */



    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public returns(uint256 amountToDeposit) {

        _withdrawAndTransferReward(msg.sender);

        

        amountToDeposit = _buyShares(_amount, _minSharesToMint, msg.sender);

        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), "deposit failed");

        

        return amountToDeposit;

    }



    function restake() public returns(uint256, uint256) {

        address user = msg.sender;

        uint256 liquidReward = _withdrawReward(user);

        uint256 amountRestaked;



        require(liquidReward >= minAmount, "Too small rewards to restake");



        if (liquidReward != 0) {

            amountRestaked = _buyShares(liquidReward, 0, user);



            if (liquidReward > amountRestaked) {

                // return change to the user

                require(

                    stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, user),

                    "Insufficent rewards"

                );

                stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidReward - amountRestaked);

            }



            (uint256 totalStaked, ) = getTotalStake(user);

            stakingLogger.logDelegatorRestaked(validatorId, user, totalStaked);

        }

        

        return (amountRestaked, liquidReward);

    }



    function sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) public {

        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);



        DelegatorUnbond memory unbond = unbonds[msg.sender];

        unbond.shares = unbond.shares.add(_withdrawPoolShare);

        // refresh undond period

        unbond.withdrawEpoch = stakeManager.epoch();

        unbonds[msg.sender] = unbond;



        StakingInfo logger = stakingLogger;

        logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);

        logger.logStakeUpdate(validatorId);

    }



    function withdrawRewards() public {

        uint256 rewards = _withdrawAndTransferReward(msg.sender);

        require(rewards >= minAmount, "Too small rewards amount");

    }



    function migrateOut(address user, uint256 amount) external onlyOwner {

        _withdrawAndTransferReward(user);

        (uint256 totalStaked, uint256 rate) = getTotalStake(user);

        require(totalStaked >= amount, "Migrating too much");



        uint256 precision = _getRatePrecision();

        uint256 shares = amount.mul(precision).div(rate);

        _burn(user, shares);



        stakeManager.updateValidatorState(validatorId, -int256(amount));

        activeAmount = activeAmount.sub(amount);



        stakingLogger.logShareBurned(validatorId, user, amount, shares);

        stakingLogger.logStakeUpdate(validatorId);

        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);

    }



    function migrateIn(address user, uint256 amount) external onlyOwner {

        _withdrawAndTransferReward(user);

        _buyShares(amount, 0, user);

    }



    function unstakeClaimTokens() public {

        DelegatorUnbond memory unbond = unbonds[msg.sender];

        uint256 amount = _unstakeClaimTokens(unbond);

        delete unbonds[msg.sender];

        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, amount);

    }



    function slash(

        uint256 validatorStake,

        uint256 delegatedAmount,

        uint256 totalAmountToSlash

    ) external onlyOwner returns (uint256) {

        uint256 _withdrawPool = withdrawPool;

        uint256 delegationAmount = delegatedAmount.add(_withdrawPool);

        if (delegationAmount == 0) {

            return 0;

        }

        // total amount to be slashed from delegation pool (active + inactive)

        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(validatorStake.add(delegationAmount));

        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);



        // slash inactive pool

        uint256 stakeSlashed = _amountToSlash.sub(_amountToSlashWithdrawalPool);

        stakeManager.decreaseValidatorDelegatedAmount(validatorId, stakeSlashed);

        activeAmount = activeAmount.sub(stakeSlashed);



        withdrawPool = withdrawPool.sub(_amountToSlashWithdrawalPool);

        return _amountToSlash;

    }



    function updateDelegation(bool _delegation) external onlyOwner {

        delegation = _delegation;

    }



    function drain(

        address token,

        address payable destination,

        uint256 amount

    ) external onlyOwner {

        if (token == address(0x0)) {

            destination.transfer(amount);

        } else {

            require(ERC20(token).transfer(destination, amount), "Drain failed");

        }

    }



    /**

        New shares exit API

     */



    function sellVoucher_new(uint256 claimAmount, uint256 maximumSharesToBurn) public {

        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);



        uint256 unbondNonce = unbondNonces[msg.sender].add(1);



        DelegatorUnbond memory unbond = DelegatorUnbond({

            shares: _withdrawPoolShare,

            withdrawEpoch: stakeManager.epoch()

        });

        unbonds_new[msg.sender][unbondNonce] = unbond;

        unbondNonces[msg.sender] = unbondNonce;



        _getOrCacheEventsHub().logShareBurnedWithId(validatorId, msg.sender, claimAmount, shares, unbondNonce);

        stakingLogger.logStakeUpdate(validatorId);

    }



    function unstakeClaimTokens_new(uint256 unbondNonce) public {

        DelegatorUnbond memory unbond = unbonds_new[msg.sender][unbondNonce];

        uint256 amount = _unstakeClaimTokens(unbond);

        delete unbonds_new[msg.sender][unbondNonce];

        _getOrCacheEventsHub().logDelegatorUnstakedWithId(validatorId, msg.sender, amount, unbondNonce);

    }



    /**

        Private Methods

     */



    function _getOrCacheEventsHub() private returns(EventsHub) {

        EventsHub _eventsHub = eventsHub;

        if (_eventsHub == EventsHub(0x0)) {

            _eventsHub = EventsHub(Registry(stakeManager.getRegistry()).contractMap(keccak256("eventsHub")));

            eventsHub = _eventsHub;

        }

        return _eventsHub;

    }



    function _sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) private returns(uint256, uint256) {

        // first get how much staked in total and compare to target unstake amount

        (uint256 totalStaked, uint256 rate) = getTotalStake(msg.sender);

        require(totalStaked != 0 && totalStaked >= claimAmount, "Too much requested");



        // convert requested amount back to shares

        uint256 precision = _getRatePrecision();

        uint256 shares = claimAmount.mul(precision).div(rate);

        require(shares <= maximumSharesToBurn, "too much slippage");



        _withdrawAndTransferReward(msg.sender);



        _burn(msg.sender, shares);

        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));

        activeAmount = activeAmount.sub(claimAmount);



        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());

        withdrawPool = withdrawPool.add(claimAmount);

        withdrawShares = withdrawShares.add(_withdrawPoolShare);



        return (shares, _withdrawPoolShare);

    }



    function _unstakeClaimTokens(DelegatorUnbond memory unbond) private returns(uint256) {

        uint256 shares = unbond.shares;

        require(

            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,

            "Incomplete withdrawal period"

        );



        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());

        withdrawShares = withdrawShares.sub(shares);

        withdrawPool = withdrawPool.sub(_amount);



        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), "Insufficent rewards");



        return _amount;

    }



    function _getRatePrecision() private view returns (uint256) {

        // if foundation validator, use old precision

        if (validatorId < 8) {

            return EXCHANGE_RATE_PRECISION;

        }



        return EXCHANGE_RATE_HIGH_PRECISION;

    }



    function _calculateRewardPerShareWithRewards(uint256 accumulatedReward) private view returns (uint256) {

        uint256 _rewardPerShare = rewardPerShare;

        if (accumulatedReward != 0) {

            uint256 totalShares = totalSupply();

            

            if (totalShares != 0) {

                _rewardPerShare = _rewardPerShare.add(accumulatedReward.mul(REWARD_PRECISION).div(totalShares));

            }

        }



        return _rewardPerShare;

    }



    function _calculateReward(address user, uint256 _rewardPerShare) private view returns (uint256) {

        uint256 shares = balanceOf(user);

        if (shares == 0) {

            return 0;

        }



        uint256 _initialRewardPerShare = initalRewardPerShare[user];



        if (_initialRewardPerShare == _rewardPerShare) {

            return 0;

        }



        return _rewardPerShare.sub(_initialRewardPerShare).mul(shares).div(REWARD_PRECISION);

    }



    function _withdrawReward(address user) private returns (uint256) {

        uint256 _rewardPerShare = _calculateRewardPerShareWithRewards(

            stakeManager.withdrawDelegatorsReward(validatorId)

        );

        uint256 liquidRewards = _calculateReward(user, _rewardPerShare);

        

        rewardPerShare = _rewardPerShare;

        initalRewardPerShare[user] = _rewardPerShare;

        return liquidRewards;

    }



    function _withdrawAndTransferReward(address user) private returns (uint256) {

        uint256 liquidRewards = _withdrawReward(user);

        if (liquidRewards != 0) {

            require(stakeManager.transferFunds(validatorId, liquidRewards, user), "Insufficent rewards");

            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);

        }

        return liquidRewards;

    }



    function _buyShares(

        uint256 _amount,

        uint256 _minSharesToMint,

        address user

    ) private onlyWhenUnlocked returns (uint256) {

        require(delegation, "Delegation is disabled");



        uint256 rate = exchangeRate();

        uint256 precision = _getRatePrecision();

        uint256 shares = _amount.mul(precision).div(rate);

        require(shares >= _minSharesToMint, "Too much slippage");

        require(unbonds[user].shares == 0, "Ongoing exit");



        _mint(user, shares);



        // clamp amount of tokens in case resulted shares requires less tokens than anticipated

        _amount = rate.mul(shares).div(precision);



        stakeManager.updateValidatorState(validatorId, int256(_amount));

        activeAmount = activeAmount.add(_amount);



        StakingInfo logger = stakingLogger;

        logger.logShareMinted(validatorId, user, _amount, shares);

        logger.logStakeUpdate(validatorId);



        return _amount;

    }



    function _transfer(

        address from,

        address to,

        uint256 value

    ) internal {

        // get rewards for recipient 

        _withdrawAndTransferReward(to);

        // convert rewards to shares

        _withdrawAndTransferReward(from);

        // move shares to recipient

        super._transfer(from, to, value);

        _getOrCacheEventsHub().logSharesTransfer(validatorId, from, to, value);

    }

}



// File: openzeppelin-solidity/contracts/introspection/IERC165.sol



pragma solidity ^0.5.2;



/**

 * @title IERC165

 * @dev https://eips.ethereum.org/EIPS/eip-165

 */

interface IERC165 {

    /**

     * @notice Query if a contract implements an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @dev Interface identification is specified in ERC-165. This function

     * uses less than 30,000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol



pragma solidity ^0.5.2;



/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    function balanceOf(address owner) public view returns (uint256 balance);

    function ownerOf(uint256 tokenId) public view returns (address owner);



    function approve(address to, uint256 tokenId) public;

    function getApproved(uint256 tokenId) public view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) public;

    function isApprovedForAll(address owner, address operator) public view returns (bool);



    function transferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId) public;



    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol



pragma solidity ^0.5.2;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract IERC721Receiver {

    /**

     * @notice Handle the receipt of an NFT

     * @dev The ERC721 smart contract calls this function on the recipient

     * after a `safeTransfer`. This function MUST return the function selector,

     * otherwise the caller will revert the transaction. The selector to be

     * returned can be obtained as `this.onERC721Received.selector`. This

     * function MAY throw to revert and reject the transfer.

     * Note: the ERC721 contract address is always the message sender.

     * @param operator The address which called `safeTransferFrom` function

     * @param from The address which previously owned the token

     * @param tokenId The NFT identifier which is being transferred

     * @param data Additional data with no specified format

     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)

    public returns (bytes4);

}



// File: openzeppelin-solidity/contracts/utils/Address.sol



pragma solidity ^0.5.2;



/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



// File: openzeppelin-solidity/contracts/drafts/Counters.sol



pragma solidity ^0.5.2;



/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids

 *

 * Include with `using Counters for Counters.Counter;`

 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath

 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never

 * directly accessed.

 */

library Counters {

    using SafeMath for uint256;



    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        counter._value += 1;

    }



    function decrement(Counter storage counter) internal {

        counter._value = counter._value.sub(1);

    }

}



// File: openzeppelin-solidity/contracts/introspection/ERC165.sol



pragma solidity ^0.5.2;



/**

 * @title ERC165

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract ERC165 is IERC165 {

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /*

     * 0x01ffc9a7 ===

     *     bytes4(keccak256('supportsInterface(bytes4)'))

     */



    /**

     * @dev a mapping of interface id to whether or not it's supported

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    /**

     * @dev A contract implementing SupportsInterfaceWithLookup

     * implement ERC165 itself

     */

    constructor () internal {

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev implement supportsInterface(bytes4) using a lookup table

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev internal method for registering an interface

     */

    function _registerInterface(bytes4 interfaceId) internal {

        require(interfaceId != 0xffffffff);

        _supportedInterfaces[interfaceId] = true;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol



pragma solidity ^0.5.2;













/**

 * @title ERC721 Non-Fungible Token Standard basic implementation

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721 is ERC165, IERC721 {

    using SafeMath for uint256;

    using Address for address;

    using Counters for Counters.Counter;



    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;



    // Mapping from token ID to owner

    mapping (uint256 => address) private _tokenOwner;



    // Mapping from token ID to approved address

    mapping (uint256 => address) private _tokenApprovals;



    // Mapping from owner to number of owned token

    mapping (address => Counters.Counter) private _ownedTokensCount;



    // Mapping from owner to operator approvals

    mapping (address => mapping (address => bool)) private _operatorApprovals;



    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /*

     * 0x80ac58cd ===

     *     bytes4(keccak256('balanceOf(address)')) ^

     *     bytes4(keccak256('ownerOf(uint256)')) ^

     *     bytes4(keccak256('approve(address,uint256)')) ^

     *     bytes4(keccak256('getApproved(uint256)')) ^

     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^

     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^

     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))

     */



    constructor () public {

        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721);

    }



    /**

     * @dev Gets the balance of the specified address

     * @param owner address to query the balance of

     * @return uint256 representing the amount owned by the passed address

     */

    function balanceOf(address owner) public view returns (uint256) {

        require(owner != address(0));

        return _ownedTokensCount[owner].current();

    }



    /**

     * @dev Gets the owner of the specified token ID

     * @param tokenId uint256 ID of the token to query the owner of

     * @return address currently marked as the owner of the given token ID

     */

    function ownerOf(uint256 tokenId) public view returns (address) {

        address owner = _tokenOwner[tokenId];

        require(owner != address(0));

        return owner;

    }



    /**

     * @dev Approves another address to transfer the given token ID

     * The zero address indicates there is no approved address.

     * There can only be one approved address per token at a given time.

     * Can only be called by the token owner or an approved operator.

     * @param to address to be approved for the given token ID

     * @param tokenId uint256 ID of the token to be approved

     */

    function approve(address to, uint256 tokenId) public {

        address owner = ownerOf(tokenId);

        require(to != owner);

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));



        _tokenApprovals[tokenId] = to;

        emit Approval(owner, to, tokenId);

    }



    /**

     * @dev Gets the approved address for a token ID, or zero if no address set

     * Reverts if the token ID does not exist.

     * @param tokenId uint256 ID of the token to query the approval of

     * @return address currently approved for the given token ID

     */

    function getApproved(uint256 tokenId) public view returns (address) {

        require(_exists(tokenId));

        return _tokenApprovals[tokenId];

    }



    /**

     * @dev Sets or unsets the approval of a given operator

     * An operator is allowed to transfer all tokens of the sender on their behalf

     * @param to operator address to set the approval

     * @param approved representing the status of the approval to be set

     */

    function setApprovalForAll(address to, bool approved) public {

        require(to != msg.sender);

        _operatorApprovals[msg.sender][to] = approved;

        emit ApprovalForAll(msg.sender, to, approved);

    }



    /**

     * @dev Tells whether an operator is approved by a given owner

     * @param owner owner address which you want to query the approval of

     * @param operator operator address which you want to query the approval of

     * @return bool whether the given operator is approved by the given owner

     */

    function isApprovedForAll(address owner, address operator) public view returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    /**

     * @dev Transfers the ownership of a given token ID to another address

     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function transferFrom(address from, address to, uint256 tokenId) public {

        require(_isApprovedOrOwner(msg.sender, tokenId));



        _transferFrom(from, to, tokenId);

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) public {

        safeTransferFrom(from, to, tokenId, "");

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes data to send along with a safe transfer check

     */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {

        transferFrom(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data));

    }



    /**

     * @dev Returns whether the specified token exists

     * @param tokenId uint256 ID of the token to query the existence of

     * @return bool whether the token exists

     */

    function _exists(uint256 tokenId) internal view returns (bool) {

        address owner = _tokenOwner[tokenId];

        return owner != address(0);

    }



    /**

     * @dev Returns whether the given spender can transfer a given token ID

     * @param spender address of the spender to query

     * @param tokenId uint256 ID of the token to be transferred

     * @return bool whether the msg.sender is approved for the given token ID,

     * is an operator of the owner, or is the owner of the token

     */

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {

        address owner = ownerOf(tokenId);

        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));

    }



    /**

     * @dev Internal function to mint a new token

     * Reverts if the given token ID already exists

     * @param to The address that will own the minted token

     * @param tokenId uint256 ID of the token to be minted

     */

    function _mint(address to, uint256 tokenId) internal {

        require(to != address(0));

        require(!_exists(tokenId));



        _tokenOwner[tokenId] = to;

        _ownedTokensCount[to].increment();



        emit Transfer(address(0), to, tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead.

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(address owner, uint256 tokenId) internal {

        require(ownerOf(tokenId) == owner);



        _clearApproval(tokenId);



        _ownedTokensCount[owner].decrement();

        _tokenOwner[tokenId] = address(0);



        emit Transfer(owner, address(0), tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(uint256 tokenId) internal {

        _burn(ownerOf(tokenId), tokenId);

    }



    /**

     * @dev Internal function to transfer ownership of a given token ID to another address.

     * As opposed to transferFrom, this imposes no restrictions on msg.sender.

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _transferFrom(address from, address to, uint256 tokenId) internal {

        require(ownerOf(tokenId) == from);

        require(to != address(0));



        _clearApproval(tokenId);



        _ownedTokensCount[from].decrement();

        _ownedTokensCount[to].increment();



        _tokenOwner[tokenId] = to;



        emit Transfer(from, to, tokenId);

    }



    /**

     * @dev Internal function to invoke `onERC721Received` on a target address

     * The call is not executed if the target address is not a contract

     * @param from address representing the previous owner of the given token ID

     * @param to target address that will receive the tokens

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes optional data to send along with the call

     * @return bool whether the call correctly returned the expected magic value

     */

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)

        internal returns (bool)

    {

        if (!to.isContract()) {

            return true;

        }



        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);

        return (retval == _ERC721_RECEIVED);

    }



    /**

     * @dev Private function to clear current approval of a given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _clearApproval(uint256 tokenId) private {

        if (_tokenApprovals[tokenId] != address(0)) {

            _tokenApprovals[tokenId] = address(0);

        }

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol



pragma solidity ^0.5.2;



/**

 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721Enumerable is IERC721 {

    function totalSupply() public view returns (uint256);

    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);



    function tokenByIndex(uint256 index) public view returns (uint256);

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol



pragma solidity ^0.5.2;







/**

 * @title ERC-721 Non-Fungible Token with optional enumeration extension logic

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {

    // Mapping from owner to list of owned token IDs

    mapping(address => uint256[]) private _ownedTokens;



    // Mapping from token ID to index of the owner tokens list

    mapping(uint256 => uint256) private _ownedTokensIndex;



    // Array with all token ids, used for enumeration

    uint256[] private _allTokens;



    // Mapping from token id to position in the allTokens array

    mapping(uint256 => uint256) private _allTokensIndex;



    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;

    /*

     * 0x780e9d63 ===

     *     bytes4(keccak256('totalSupply()')) ^

     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^

     *     bytes4(keccak256('tokenByIndex(uint256)'))

     */



    /**

     * @dev Constructor function

     */

    constructor () public {

        // register the supported interface to conform to ERC721Enumerable via ERC165

        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);

    }



    /**

     * @dev Gets the token ID at a given index of the tokens list of the requested owner

     * @param owner address owning the tokens list to be accessed

     * @param index uint256 representing the index to be accessed of the requested tokens list

     * @return uint256 token ID at the given index of the tokens list owned by the requested address

     */

    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {

        require(index < balanceOf(owner));

        return _ownedTokens[owner][index];

    }



    /**

     * @dev Gets the total amount of tokens stored by the contract

     * @return uint256 representing the total amount of tokens

     */

    function totalSupply() public view returns (uint256) {

        return _allTokens.length;

    }



    /**

     * @dev Gets the token ID at a given index of all the tokens in this contract

     * Reverts if the index is greater or equal to the total number of tokens

     * @param index uint256 representing the index to be accessed of the tokens list

     * @return uint256 token ID at the given index of the tokens list

     */

    function tokenByIndex(uint256 index) public view returns (uint256) {

        require(index < totalSupply());

        return _allTokens[index];

    }



    /**

     * @dev Internal function to transfer ownership of a given token ID to another address.

     * As opposed to transferFrom, this imposes no restrictions on msg.sender.

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _transferFrom(address from, address to, uint256 tokenId) internal {

        super._transferFrom(from, to, tokenId);



        _removeTokenFromOwnerEnumeration(from, tokenId);



        _addTokenToOwnerEnumeration(to, tokenId);

    }



    /**

     * @dev Internal function to mint a new token

     * Reverts if the given token ID already exists

     * @param to address the beneficiary that will own the minted token

     * @param tokenId uint256 ID of the token to be minted

     */

    function _mint(address to, uint256 tokenId) internal {

        super._mint(to, tokenId);



        _addTokenToOwnerEnumeration(to, tokenId);



        _addTokenToAllTokensEnumeration(tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(address owner, uint256 tokenId) internal {

        super._burn(owner, tokenId);



        _removeTokenFromOwnerEnumeration(owner, tokenId);

        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund

        _ownedTokensIndex[tokenId] = 0;



        _removeTokenFromAllTokensEnumeration(tokenId);

    }



    /**

     * @dev Gets the list of token IDs of the requested owner

     * @param owner address owning the tokens

     * @return uint256[] List of token IDs owned by the requested address

     */

    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {

        return _ownedTokens[owner];

    }



    /**

     * @dev Private function to add a token to this extension's ownership-tracking data structures.

     * @param to address representing the new owner of the given token ID

     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address

     */

    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {

        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;

        _ownedTokens[to].push(tokenId);

    }



    /**

     * @dev Private function to add a token to this extension's token tracking data structures.

     * @param tokenId uint256 ID of the token to be added to the tokens list

     */

    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {

        _allTokensIndex[tokenId] = _allTokens.length;

        _allTokens.push(tokenId);

    }



    /**

     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that

     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for

     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).

     * This has O(1) time complexity, but alters the order of the _ownedTokens array.

     * @param from address representing the previous owner of the given token ID

     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address

     */

    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {

        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and

        // then delete the last slot (swap and pop).



        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);

        uint256 tokenIndex = _ownedTokensIndex[tokenId];



        // When the token to delete is the last token, the swap operation is unnecessary

        if (tokenIndex != lastTokenIndex) {

            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];



            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token

            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index

        }



        // This also deletes the contents at the last position of the array

        _ownedTokens[from].length--;



        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by

        // lastTokenId, or just over the end of the array if the token was the last one).

    }



    /**

     * @dev Private function to remove a token from this extension's token tracking data structures.

     * This has O(1) time complexity, but alters the order of the _allTokens array.

     * @param tokenId uint256 ID of the token to be removed from the tokens list

     */

    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {

        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and

        // then delete the last slot (swap and pop).



        uint256 lastTokenIndex = _allTokens.length.sub(1);

        uint256 tokenIndex = _allTokensIndex[tokenId];



        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so

        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding

        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)

        uint256 lastTokenId = _allTokens[lastTokenIndex];



        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token

        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index



        // This also deletes the contents at the last position of the array

        _allTokens.length--;

        _allTokensIndex[tokenId] = 0;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol



pragma solidity ^0.5.2;



/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721Metadata is IERC721 {

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function tokenURI(uint256 tokenId) external view returns (string memory);

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol



pragma solidity ^0.5.2;







contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {

    // Token name

    string private _name;



    // Token symbol

    string private _symbol;



    // Optional mapping for token URIs

    mapping(uint256 => string) private _tokenURIs;



    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;

    /*

     * 0x5b5e139f ===

     *     bytes4(keccak256('name()')) ^

     *     bytes4(keccak256('symbol()')) ^

     *     bytes4(keccak256('tokenURI(uint256)'))

     */



    /**

     * @dev Constructor function

     */

    constructor (string memory name, string memory symbol) public {

        _name = name;

        _symbol = symbol;



        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721_METADATA);

    }



    /**

     * @dev Gets the token name

     * @return string representing the token name

     */

    function name() external view returns (string memory) {

        return _name;

    }



    /**

     * @dev Gets the token symbol

     * @return string representing the token symbol

     */

    function symbol() external view returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns an URI for a given token ID

     * Throws if the token ID does not exist. May return an empty string.

     * @param tokenId uint256 ID of the token to query

     */

    function tokenURI(uint256 tokenId) external view returns (string memory) {

        require(_exists(tokenId));

        return _tokenURIs[tokenId];

    }



    /**

     * @dev Internal function to set the token URI for a given token

     * Reverts if the token ID does not exist

     * @param tokenId uint256 ID of the token to set its URI

     * @param uri string URI to assign

     */

    function _setTokenURI(uint256 tokenId, string memory uri) internal {

        require(_exists(tokenId));

        _tokenURIs[tokenId] = uri;

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned by the msg.sender

     */

    function _burn(address owner, uint256 tokenId) internal {

        super._burn(owner, tokenId);



        // Clear metadata (if any)

        if (bytes(_tokenURIs[tokenId]).length != 0) {

            delete _tokenURIs[tokenId];

        }

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol



pragma solidity ^0.5.2;







/**

 * @title Full ERC721 Token

 * This implementation includes all the required and some optional functionality of the ERC721 standard

 * Moreover, it includes approve all functionality using operator terminology

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {

    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {

        // solhint-disable-previous-line no-empty-blocks

    }

}



// File: contracts/staking/stakeManager/StakingNFT.sol



pragma solidity ^0.5.2;





contract StakingNFT is ERC721Full, Ownable {

    constructor(string memory name, string memory symbol)

        public

        ERC721Full(name, symbol)

    {

        // solhint-disable-previous-line no-empty-blocks

    }



    function mint(address to, uint256 tokenId) public onlyOwner {

        require(

            balanceOf(to) == 0,

            "Validators MUST NOT own multiple stake position"

        );

        _mint(to, tokenId);

    }



    function burn(uint256 tokenId) public onlyOwner {

        _burn(tokenId);

    }



    function _transferFrom(address from, address to, uint256 tokenId) internal {

        require(

            balanceOf(to) == 0,

            "Validators MUST NOT own multiple stake position"

        );

        super._transferFrom(from, to, tokenId);

    }

}



// File: contracts/common/misc/ERCProxy.sol



/*

 * SPDX-License-Identitifer:    MIT

 */



pragma solidity ^0.5.2;



// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md



interface ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);

    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/misc/DelegateProxy.sol



pragma solidity ^0.5.2;





contract DelegateProxy is ERCProxy, DelegateProxyForwarder {

    function proxyType() external pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external view returns (address);

}



// File: contracts/common/misc/UpgradableProxy.sol



pragma solidity ^0.5.2;



contract UpgradableProxy is DelegateProxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event OwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    function() external payable {

        // require(currentContract != 0, "If app code has not been set yet, do not call");

        // Todo: filter out some calls or handle in the end fallback

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function owner() external view returns(address) {

        return loadOwner();

    }



    function loadOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit OwnerUpdate(newOwner, loadOwner());

        setOwner(newOwner);

    }



    function setOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call.value(msg.value)(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

}



// File: contracts/staking/validatorShare/ValidatorShareProxy.sol



pragma solidity ^0.5.2;





contract ValidatorShareProxy is UpgradableProxy {

    constructor(address _registry) public UpgradableProxy(_registry) {}



    function loadImplementation() internal view returns (address) {

        return Registry(super.loadImplementation()).getValidatorShareAddress();

    }

}



// File: contracts/staking/validatorShare/ValidatorShareFactory.sol



pragma solidity ^0.5.2;





contract ValidatorShareFactory {

    /**

    - factory to create new validatorShare contracts

   */

    function create(uint256 validatorId, address loggerAddress, address registry) public returns (address) {

        ValidatorShareProxy proxy = new ValidatorShareProxy(registry);



        proxy.transferOwnership(msg.sender);



        address proxyAddr = address(proxy);

        (bool success, bytes memory data) = proxyAddr.call.gas(gasleft())(

            abi.encodeWithSelector(

                ValidatorShare(proxyAddr).initialize.selector, 

                validatorId, 

                loggerAddress, 

                msg.sender

            )

        );

        require(success, string(data));



        return proxyAddr;

    }

}



// File: contracts/common/mixin/RootChainable.sol



pragma solidity ^0.5.2;



/**

 * @title RootChainable

 */

contract RootChainable is Ownable {

    address public rootChain;



    // Rootchain changed

    event RootChainChanged(

        address indexed previousRootChain,

        address indexed newRootChain

    );



    // only root chain

    modifier onlyRootChain() {

        require(msg.sender == rootChain);

        _;

    }



    /**

   * @dev Allows the current owner to change root chain address.

   * @param newRootChain The address to new rootchain.

   */

    function changeRootChain(address newRootChain) public onlyOwner {

        require(newRootChain != address(0));

        emit RootChainChanged(rootChain, newRootChain);

        rootChain = newRootChain;

    }

}



// File: contracts/staking/stakeManager/StakeManagerStorage.sol



pragma solidity 0.5.17;













contract StakeManagerStorage is GovernanceLockable, RootChainable {

    enum Status {Inactive, Active, Locked, Unstaked}



    struct Auction {

        uint256 amount;

        uint256 startEpoch;

        address user;

        bool acceptDelegation;

        bytes signerPubkey;

    }



    struct State {

        uint256 amount;

        uint256 stakerCount;

    }



    struct StateChange {

        int256 amount;

        int256 stakerCount;

    }



    struct Validator {

        uint256 amount;

        uint256 reward;

        uint256 activationEpoch;

        uint256 deactivationEpoch;

        uint256 jailTime;

        address signer;

        address contractAddress;

        Status status;

        uint256 commissionRate;

        uint256 lastCommissionUpdate;

        uint256 delegatorsReward;

        uint256 delegatedAmount;

        uint256 initialRewardPerStake;

    }



    uint256 constant MAX_COMMISION_RATE = 100;

    uint256 constant MAX_PROPOSER_BONUS = 100;

    uint256 constant REWARD_PRECISION = 10**25;

    uint256 internal constant INCORRECT_VALIDATOR_ID = 2**256 - 1;

    uint256 internal constant INITIALIZED_AMOUNT = 1;



    IERC20 public token;

    address public registry;

    StakingInfo public logger;

    StakingNFT public NFTContract;

    ValidatorShareFactory public validatorShareFactory;

    uint256 public WITHDRAWAL_DELAY; // unit: epoch

    uint256 public currentEpoch;



    // genesis/governance variables

    uint256 public dynasty; // unit: epoch 50 days

    uint256 public CHECKPOINT_REWARD; // update via governance

    uint256 public minDeposit; // in ERC20 token

    uint256 public minHeimdallFee; // in ERC20 token

    uint256 public checkPointBlockInterval;

    uint256 public signerUpdateLimit;



    uint256 public validatorThreshold; //128

    uint256 public totalStaked;

    uint256 public NFTCounter;

    uint256 public totalRewards;

    uint256 public totalRewardsLiquidated;

    uint256 public auctionPeriod; // 1 week in epochs

    uint256 public proposerBonus; // 10 % of total rewards

    bytes32 public accountStateRoot;

    // Stop validator auction for some time when updating dynasty value

    uint256 public replacementCoolDown;

    bool public delegationEnabled;



    mapping(uint256 => Validator) public validators;

    mapping(address => uint256) public signerToValidator;

    // current epoch stake power and stakers count

    State public validatorState;

    mapping(uint256 => StateChange) public validatorStateChanges;



    mapping(address => uint256) public userFeeExit;

    //Ongoing auctions for validatorId

    mapping(uint256 => Auction) public validatorAuction;

    // validatorId to last signer update epoch

    mapping(uint256 => uint256) public latestSignerUpdateEpoch;



    uint256 public totalHeimdallFee;

}



// File: contracts/staking/stakeManager/StakeManagerStorageExtension.sol



pragma solidity 0.5.17;



contract StakeManagerStorageExtension {

    address public eventsHub;

    uint256 public rewardPerStake;

    address public extensionCode;

    address[] public signers;



    uint256 constant CHK_REWARD_PRECISION = 100;

    uint256 public prevBlockInterval;

    // how much less reward per skipped checkpoint, 0 - 100%

    uint256 public rewardDecreasePerCheckpoint;

    // how many checkpoints to reward

    uint256 public maxRewardedCheckpoints;

    // increase / decrease value for faster or slower checkpoints, 0 - 100%

    uint256 public checkpointRewardDelta;

}



// File: contracts/staking/stakeManager/StakeManagerExtension.sol



pragma solidity 0.5.17;























contract StakeManagerExtension is StakeManagerStorage, Initializable, StakeManagerStorageExtension {

    using SafeMath for uint256;



    constructor() public GovernanceLockable(address(0x0)) {}



    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool _acceptDelegation,

        bytes calldata _signerPubkey

    ) external {

        uint256 currentValidatorAmount = validators[validatorId].amount;



        require(

            validators[validatorId].deactivationEpoch == 0 && currentValidatorAmount != 0,

            "Invalid validator for an auction"

        );

        uint256 senderValidatorId = signerToValidator[msg.sender];

        // make sure that signer wasn't used already

        require(

            NFTContract.balanceOf(msg.sender) == 0 && // existing validators can't bid

                senderValidatorId != INCORRECT_VALIDATOR_ID,

            "Already used address"

        );



        uint256 _currentEpoch = currentEpoch;

        uint256 _replacementCoolDown = replacementCoolDown;

        // when dynasty period is updated validators are in cooldown period

        require(_replacementCoolDown == 0 || _replacementCoolDown <= _currentEpoch, "Cooldown period");

        // (auctionPeriod--dynasty)--(auctionPeriod--dynasty)--(auctionPeriod--dynasty)

        // if it's auctionPeriod then will get residue smaller then auctionPeriod

        // from (CurrentPeriod of validator )%(auctionPeriod--dynasty)

        // make sure that its `auctionPeriod` window

        // dynasty = 30, auctionPeriod = 7, activationEpoch = 1, currentEpoch = 39

        // residue 1 = (39-1)% (7+30), if residue <= auctionPeriod it's `auctionPeriod`



        require(

            (_currentEpoch.sub(validators[validatorId].activationEpoch) % dynasty.add(auctionPeriod)) < auctionPeriod,

            "Invalid auction period"

        );



        uint256 perceivedStake = currentValidatorAmount;

        perceivedStake = perceivedStake.add(validators[validatorId].delegatedAmount);



        Auction storage auction = validatorAuction[validatorId];

        uint256 currentAuctionAmount = auction.amount;



        perceivedStake = Math.max(perceivedStake, currentAuctionAmount);



        require(perceivedStake < amount, "Must bid higher");

        require(token.transferFrom(msg.sender, address(this), amount), "Transfer failed");



        //replace prev auction

        if (currentAuctionAmount != 0) {

            require(token.transfer(auction.user, currentAuctionAmount), "Bid return failed");

        }



        // create new auction

        auction.amount = amount;

        auction.user = msg.sender;

        auction.acceptDelegation = _acceptDelegation;

        auction.signerPubkey = _signerPubkey;



        logger.logStartAuction(validatorId, currentValidatorAmount, amount);

    }



    function confirmAuctionBid(

        uint256 validatorId,

        uint256 heimdallFee, /** for new validator */

        IStakeManager stakeManager

    ) external {

        Auction storage auction = validatorAuction[validatorId];

        address auctionUser = auction.user;



        require(

            msg.sender == auctionUser || NFTContract.tokenOfOwnerByIndex(msg.sender, 0) == validatorId,

            "Only bidder can confirm"

        );



        uint256 _currentEpoch = currentEpoch;

        require(

            _currentEpoch.sub(auction.startEpoch) % auctionPeriod.add(dynasty) >= auctionPeriod,

            "Not allowed before auctionPeriod"

        );

        require(auction.user != address(0x0), "Invalid auction");



        uint256 validatorAmount = validators[validatorId].amount;

        uint256 perceivedStake = validatorAmount;

        uint256 auctionAmount = auction.amount;



        perceivedStake = perceivedStake.add(validators[validatorId].delegatedAmount);



        // validator is last auctioner

        if (perceivedStake >= auctionAmount && validators[validatorId].deactivationEpoch == 0) {

            require(token.transfer(auctionUser, auctionAmount), "Bid return failed");

            //cleanup auction data

            auction.startEpoch = _currentEpoch;

            logger.logConfirmAuction(validatorId, validatorId, validatorAmount);

        } else {

            stakeManager.dethroneAndStake(

                auctionUser, 

                heimdallFee,

                validatorId,

                auctionAmount,

                auction.acceptDelegation,

                auction.signerPubkey

            );

        }

        uint256 startEpoch = auction.startEpoch;

        delete validatorAuction[validatorId];

        validatorAuction[validatorId].startEpoch = startEpoch;

    }



    function migrateValidatorsData(uint256 validatorIdFrom, uint256 validatorIdTo) external {       

        for (uint256 i = validatorIdFrom; i < validatorIdTo; ++i) {

            ValidatorShare contractAddress = ValidatorShare(validators[i].contractAddress);

            if (contractAddress != ValidatorShare(0)) {

                // move validator rewards out from ValidatorShare contract

                validators[i].reward = contractAddress.validatorRewards_deprecated().add(INITIALIZED_AMOUNT);

                validators[i].delegatedAmount = contractAddress.activeAmount();

                validators[i].commissionRate = contractAddress.commissionRate_deprecated();

            } else {

                validators[i].reward = validators[i].reward.add(INITIALIZED_AMOUNT);

            }



            validators[i].delegatorsReward = INITIALIZED_AMOUNT;

        }

    }



    function updateCheckpointRewardParams(

        uint256 _rewardDecreasePerCheckpoint,

        uint256 _maxRewardedCheckpoints,

        uint256 _checkpointRewardDelta

    ) external {

        require(_maxRewardedCheckpoints.mul(_rewardDecreasePerCheckpoint) <= CHK_REWARD_PRECISION);

        require(_checkpointRewardDelta <= CHK_REWARD_PRECISION);



        rewardDecreasePerCheckpoint = _rewardDecreasePerCheckpoint;

        maxRewardedCheckpoints = _maxRewardedCheckpoints;

        checkpointRewardDelta = _checkpointRewardDelta;



        _getOrCacheEventsHub().logRewardParams(_rewardDecreasePerCheckpoint, _maxRewardedCheckpoints, _checkpointRewardDelta);

    }



    function updateCommissionRate(uint256 validatorId, uint256 newCommissionRate) external {

        uint256 _epoch = currentEpoch;

        uint256 _lastCommissionUpdate = validators[validatorId].lastCommissionUpdate;



        require( // withdrawalDelay == dynasty

            (_lastCommissionUpdate.add(WITHDRAWAL_DELAY) <= _epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate

            "Cooldown"

        );



        require(newCommissionRate <= MAX_COMMISION_RATE, "Incorrect value");

        _getOrCacheEventsHub().logUpdateCommissionRate(validatorId, newCommissionRate, validators[validatorId].commissionRate);

        validators[validatorId].commissionRate = newCommissionRate;

        validators[validatorId].lastCommissionUpdate = _epoch;

    }



    function _getOrCacheEventsHub() private returns(EventsHub) {

        EventsHub _eventsHub = EventsHub(eventsHub);

        if (_eventsHub == EventsHub(0x0)) {

            _eventsHub = EventsHub(Registry(registry).contractMap(keccak256("eventsHub")));

            eventsHub = address(_eventsHub);

        }

        return _eventsHub;

    }

}



// File: contracts/staking/stakeManager/StakeManager.sol



pragma solidity 0.5.17;









































contract StakeManager is

    StakeManagerStorage,

    Initializable,

    IStakeManager,

    DelegateProxyForwarder,

    StakeManagerStorageExtension

{

    using SafeMath for uint256;

    using Merkle for bytes32;

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    struct UnsignedValidatorsContext {

        uint256 unsignedValidatorIndex;

        uint256 validatorIndex;

        uint256[] unsignedValidators;

        address[] validators;

        uint256 totalValidators;

    }



    struct UnstakedValidatorsContext {

        uint256 deactivationEpoch;

        uint256[] deactivatedValidators;

        uint256 validatorIndex;

    }



    modifier onlyStaker(uint256 validatorId) {

        _assertStaker(validatorId);

        _;

    }



    function _assertStaker(uint256 validatorId) private view {

        require(NFTContract.ownerOf(validatorId) == msg.sender);

    }



    modifier onlyDelegation(uint256 validatorId) {

        _assertDelegation(validatorId);

        _;

    }



    function _assertDelegation(uint256 validatorId) private view {

        require(validators[validatorId].contractAddress == msg.sender, "Invalid contract address");

    }



    constructor() public GovernanceLockable(address(0x0)) initializer {}



    function initialize(

        address _registry,

        address _rootchain,

        address _token,

        address _NFTContract,

        address _stakingLogger,

        address _validatorShareFactory,

        address _governance,

        address _owner,

        address _extensionCode

    ) external initializer {

        require(isContract(_extensionCode), "auction impl incorrect");

        extensionCode = _extensionCode;

        governance = IGovernance(_governance);

        registry = _registry;

        rootChain = _rootchain;

        token = IERC20(_token);

        NFTContract = StakingNFT(_NFTContract);

        logger = StakingInfo(_stakingLogger);

        validatorShareFactory = ValidatorShareFactory(_validatorShareFactory);

        _transferOwnership(_owner);



        WITHDRAWAL_DELAY = (2**13); // unit: epoch

        currentEpoch = 1;

        dynasty = 886; // unit: epoch 50 days

        CHECKPOINT_REWARD = 20188 * (10**18); // update via governance

        minDeposit = (10**18); // in ERC20 token

        minHeimdallFee = (10**18); // in ERC20 token

        checkPointBlockInterval = 1024;

        signerUpdateLimit = 100;



        validatorThreshold = 7; //128

        NFTCounter = 1;

        auctionPeriod = (2**13) / 4; // 1 week in epochs

        proposerBonus = 10; // 10 % of total rewards

        delegationEnabled = true;

    }



    function isOwner() public view returns (bool) {

        address _owner;

        bytes32 position = keccak256("matic.network.proxy.owner");

        assembly {

            _owner := sload(position)

        }

        return msg.sender == _owner;

    }



    /**

        Public View Methods

     */



    function getRegistry() public view returns (address) {

        return registry;

    }



    /**

        @dev Owner of validator slot NFT

     */

    function ownerOf(uint256 tokenId) public view returns (address) {

        return NFTContract.ownerOf(tokenId);

    }



    function epoch() public view returns (uint256) {

        return currentEpoch;

    }



    function withdrawalDelay() public view returns (uint256) {

        return WITHDRAWAL_DELAY;

    }



    function validatorStake(uint256 validatorId) public view returns (uint256) {

        return validators[validatorId].amount;

    }



    function getValidatorId(address user) public view returns (uint256) {

        return NFTContract.tokenOfOwnerByIndex(user, 0);

    }



    function delegatedAmount(uint256 validatorId) public view returns (uint256) {

        return validators[validatorId].delegatedAmount;

    }



    function delegatorsReward(uint256 validatorId) public view returns (uint256) {

        uint256 _delegatorsReward;

        if (validators[validatorId].deactivationEpoch == 0) {

            (, _delegatorsReward) = _evaluateValidatorAndDelegationReward(validatorId);

        }

        return validators[validatorId].delegatorsReward.add(_delegatorsReward).sub(INITIALIZED_AMOUNT);

    }



    function validatorReward(uint256 validatorId) public view returns (uint256) {

        uint256 _validatorReward;

        if (validators[validatorId].deactivationEpoch == 0) {

            (_validatorReward, ) = _evaluateValidatorAndDelegationReward(validatorId);

        }

        return validators[validatorId].reward.add(_validatorReward).sub(INITIALIZED_AMOUNT);

    }



    function currentValidatorSetSize() public view returns (uint256) {

        return validatorState.stakerCount;

    }



    function currentValidatorSetTotalStake() public view returns (uint256) {

        return validatorState.amount;

    }



    function getValidatorContract(uint256 validatorId) public view returns (address) {

        return validators[validatorId].contractAddress;

    }



    function isValidator(uint256 validatorId) public view returns (bool) {

        return

            _isValidator(

                validators[validatorId].status,

                validators[validatorId].amount,

                validators[validatorId].deactivationEpoch,

                currentEpoch

            );

    }



    /**

        Governance Methods

     */



    function setDelegationEnabled(bool enabled) public onlyGovernance {

        delegationEnabled = enabled;

    }



    // Housekeeping function. @todo remove later

    function forceUnstake(uint256 validatorId) external onlyGovernance {

        _unstake(validatorId, currentEpoch);

    }



    function setCurrentEpoch(uint256 _currentEpoch) external onlyGovernance {

        currentEpoch = _currentEpoch;

    }



    function setStakingToken(address _token) public onlyGovernance {

        require(_token != address(0x0));

        token = IERC20(_token);

    }



    /**

        @dev Change the number of validators required to allow a passed header root

     */

    function updateValidatorThreshold(uint256 newThreshold) public onlyGovernance {

        require(newThreshold != 0);

        logger.logThresholdChange(newThreshold, validatorThreshold);

        validatorThreshold = newThreshold;

    }



    function updateCheckPointBlockInterval(uint256 _blocks) public onlyGovernance {

        require(_blocks != 0);

        checkPointBlockInterval = _blocks;

    }



    function updateCheckpointReward(uint256 newReward) public onlyGovernance {

        require(newReward != 0);

        logger.logRewardUpdate(newReward, CHECKPOINT_REWARD);

        CHECKPOINT_REWARD = newReward;

    }



    function updateCheckpointRewardParams(

        uint256 _rewardDecreasePerCheckpoint,

        uint256 _maxRewardedCheckpoints,

        uint256 _checkpointRewardDelta

    ) public onlyGovernance {

        delegatedFwd(

            extensionCode,

            abi.encodeWithSelector(

                StakeManagerExtension(extensionCode).updateCheckpointRewardParams.selector,

                _rewardDecreasePerCheckpoint,

                _maxRewardedCheckpoints,

                _checkpointRewardDelta

            )

        );

    }



    // New implementation upgrade



    function migrateValidatorsData(uint256 validatorIdFrom, uint256 validatorIdTo) public onlyOwner {

        delegatedFwd(

            extensionCode,

            abi.encodeWithSelector(

                StakeManagerExtension(extensionCode).migrateValidatorsData.selector,

                validatorIdFrom,

                validatorIdTo

            )

        );

    }



    function insertSigners(address[] memory _signers) public onlyOwner {

        signers = _signers;

    }



    /**

        @dev Users must exit before this update or all funds may get lost

     */

    function updateValidatorContractAddress(uint256 validatorId, address newContractAddress) public onlyGovernance {

        require(IValidatorShare(newContractAddress).owner() == address(this));

        validators[validatorId].contractAddress = newContractAddress;

    }



    function updateDynastyValue(uint256 newDynasty) public onlyGovernance {

        require(newDynasty > 0);

        logger.logDynastyValueChange(newDynasty, dynasty);

        dynasty = newDynasty;

        WITHDRAWAL_DELAY = newDynasty;

        auctionPeriod = newDynasty.div(4);

        replacementCoolDown = currentEpoch.add(auctionPeriod);

    }



    // Housekeeping function. @todo remove later

    function stopAuctions(uint256 forNCheckpoints) public onlyGovernance {

        replacementCoolDown = currentEpoch.add(forNCheckpoints);

    }



    function updateProposerBonus(uint256 newProposerBonus) public onlyGovernance {

        logger.logProposerBonusChange(newProposerBonus, proposerBonus);

        require(newProposerBonus <= MAX_PROPOSER_BONUS, "too big");

        proposerBonus = newProposerBonus;

    }



    function updateSignerUpdateLimit(uint256 _limit) public onlyGovernance {

        signerUpdateLimit = _limit;

    }



    function updateMinAmounts(uint256 _minDeposit, uint256 _minHeimdallFee) public onlyGovernance {

        minDeposit = _minDeposit;

        minHeimdallFee = _minHeimdallFee;

    }



    function drainValidatorShares(

        uint256 validatorId,

        address tokenAddr,

        address payable destination,

        uint256 amount

    ) external onlyGovernance {

        address contractAddr = validators[validatorId].contractAddress;

        require(contractAddr != address(0x0));

        IValidatorShare(contractAddr).drain(tokenAddr, destination, amount);

    }



    function drain(address destination, uint256 amount) external onlyGovernance {

        _transferToken(destination, amount);

    }



    function reinitialize(

        address _NFTContract,

        address _stakingLogger,

        address _validatorShareFactory,

        address _extensionCode

    ) external onlyGovernance {

        require(isContract(_extensionCode));

        eventsHub = address(0x0);

        extensionCode = _extensionCode;

        NFTContract = StakingNFT(_NFTContract);

        logger = StakingInfo(_stakingLogger);

        validatorShareFactory = ValidatorShareFactory(_validatorShareFactory);

    }



    /**

        Public Methods

     */



    function topUpForFee(address user, uint256 heimdallFee) public onlyWhenUnlocked {

        _transferAndTopUp(user, msg.sender, heimdallFee, 0);

    }



    function claimFee(

        uint256 accumFeeAmount,

        uint256 index,

        bytes memory proof

    ) public {

        //Ignoring other params because rewards' distribution is on chain

        require(

            keccak256(abi.encode(msg.sender, accumFeeAmount)).checkMembership(index, accountStateRoot, proof),

            "Wrong acc proof"

        );

        uint256 withdrawAmount = accumFeeAmount.sub(userFeeExit[msg.sender]);

        _claimFee(msg.sender, withdrawAmount);

        userFeeExit[msg.sender] = accumFeeAmount;

        _transferToken(msg.sender, withdrawAmount);

    }



    function totalStakedFor(address user) external view returns (uint256) {

        if (user == address(0x0) || NFTContract.balanceOf(user) == 0) {

            return 0;

        }

        return validators[NFTContract.tokenOfOwnerByIndex(user, 0)].amount;

    }



    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool _acceptDelegation,

        bytes calldata _signerPubkey

    ) external onlyWhenUnlocked {

        delegatedFwd(

            extensionCode,

            abi.encodeWithSelector(

                StakeManagerExtension(extensionCode).startAuction.selector,

                validatorId,

                amount,

                _acceptDelegation,

                _signerPubkey

            )

        );

    }



    function confirmAuctionBid(

        uint256 validatorId,

        uint256 heimdallFee /** for new validator */

    ) external onlyWhenUnlocked {

        delegatedFwd(

            extensionCode,

            abi.encodeWithSelector(

                StakeManagerExtension(extensionCode).confirmAuctionBid.selector,

                validatorId,

                heimdallFee,

                address(this)

            )

        );

    }



    function dethroneAndStake(

        address auctionUser,

        uint256 heimdallFee,

        uint256 validatorId,

        uint256 auctionAmount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external {

        require(msg.sender == address(this), "not allowed");

        // dethrone

        _transferAndTopUp(auctionUser, auctionUser, heimdallFee, 0);

        _unstake(validatorId, currentEpoch);



        uint256 newValidatorId = _stakeFor(auctionUser, auctionAmount, acceptDelegation, signerPubkey);

        logger.logConfirmAuction(newValidatorId, validatorId, auctionAmount);

    }



    function unstake(uint256 validatorId) external onlyStaker(validatorId) {

        require(validatorAuction[validatorId].amount == 0);



        Status status = validators[validatorId].status;

        require(

            validators[validatorId].activationEpoch > 0 &&

                validators[validatorId].deactivationEpoch == 0 &&

                (status == Status.Active || status == Status.Locked)

        );



        uint256 exitEpoch = currentEpoch.add(1); // notice period

        _unstake(validatorId, exitEpoch);

    }



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool) {

        require(

            validators[validatorId].contractAddress == msg.sender ||

                Registry(registry).getSlashingManagerAddress() == msg.sender,

            "not allowed"

        );

        return token.transfer(delegator, amount);

    }



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external onlyDelegation(validatorId) returns (bool) {

        return token.transferFrom(delegator, address(this), amount);

    }



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public onlyWhenUnlocked {

        require(currentValidatorSetSize() < validatorThreshold, "no more slots");

        require(amount >= minDeposit, "not enough deposit");

        _transferAndTopUp(user, msg.sender, heimdallFee, amount);

        _stakeFor(user, amount, acceptDelegation, signerPubkey);

    }



    function unstakeClaim(uint256 validatorId) public onlyStaker(validatorId) {

        uint256 deactivationEpoch = validators[validatorId].deactivationEpoch;

        // can only claim stake back after WITHDRAWAL_DELAY

        require(

            deactivationEpoch > 0 &&

                deactivationEpoch.add(WITHDRAWAL_DELAY) <= currentEpoch &&

                validators[validatorId].status != Status.Unstaked

        );



        uint256 amount = validators[validatorId].amount;

        uint256 newTotalStaked = totalStaked.sub(amount);

        totalStaked = newTotalStaked;



        // claim last checkpoint reward if it was signed by validator

        _liquidateRewards(validatorId, msg.sender);



        NFTContract.burn(validatorId);



        validators[validatorId].amount = 0;

        validators[validatorId].jailTime = 0;

        validators[validatorId].signer = address(0);



        signerToValidator[validators[validatorId].signer] = INCORRECT_VALIDATOR_ID;

        validators[validatorId].status = Status.Unstaked;



        _transferToken(msg.sender, amount);

        logger.logUnstaked(msg.sender, validatorId, amount, newTotalStaked);

    }



    function restake(

        uint256 validatorId,

        uint256 amount,

        bool stakeRewards

    ) public onlyWhenUnlocked onlyStaker(validatorId) {

        require(validators[validatorId].deactivationEpoch == 0, "No restaking");



        if (amount > 0) {

            _transferTokenFrom(msg.sender, address(this), amount);

        }



        _updateRewards(validatorId);



        if (stakeRewards) {

            amount = amount.add(validators[validatorId].reward).sub(INITIALIZED_AMOUNT);

            validators[validatorId].reward = INITIALIZED_AMOUNT;

        }



        uint256 newTotalStaked = totalStaked.add(amount);

        totalStaked = newTotalStaked;

        validators[validatorId].amount = validators[validatorId].amount.add(amount);



        updateTimeline(int256(amount), 0, 0);



        logger.logStakeUpdate(validatorId);

        logger.logRestaked(validatorId, validators[validatorId].amount, newTotalStaked);

    }



    function withdrawRewards(uint256 validatorId) public onlyStaker(validatorId) {

        _updateRewards(validatorId);

        _liquidateRewards(validatorId, msg.sender);

    }



    function migrateDelegation(

        uint256 fromValidatorId,

        uint256 toValidatorId,

        uint256 amount

    ) public {

        // allow to move to any non-foundation node

        require(toValidatorId > 7, "Invalid migration");

        IValidatorShare(validators[fromValidatorId].contractAddress).migrateOut(msg.sender, amount);

        IValidatorShare(validators[toValidatorId].contractAddress).migrateIn(msg.sender, amount);

    }



    function updateValidatorState(uint256 validatorId, int256 amount) public onlyDelegation(validatorId) {

        if (amount > 0) {

            // deposit during shares purchase

            require(delegationEnabled, "Delegation is disabled");

        }



        uint256 deactivationEpoch = validators[validatorId].deactivationEpoch;



        if (deactivationEpoch == 0) { // modify timeline only if validator didn't unstake

            updateTimeline(amount, 0, 0);

        } else if (deactivationEpoch > currentEpoch) { // validator just unstaked, need to wait till next checkpoint

            revert("unstaking");

        }

        



        if (amount >= 0) {

            increaseValidatorDelegatedAmount(validatorId, uint256(amount));

        } else {

            decreaseValidatorDelegatedAmount(validatorId, uint256(amount * -1));

        }

    }



    function increaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) private {

        validators[validatorId].delegatedAmount = validators[validatorId].delegatedAmount.add(amount);

    }



    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public onlyDelegation(validatorId) {

        validators[validatorId].delegatedAmount = validators[validatorId].delegatedAmount.sub(amount);

    }



    function updateSigner(uint256 validatorId, bytes memory signerPubkey) public onlyStaker(validatorId) {

        address signer = _getAndAssertSigner(signerPubkey);

        uint256 _currentEpoch = currentEpoch;

        require(_currentEpoch >= latestSignerUpdateEpoch[validatorId].add(signerUpdateLimit), "Not allowed");



        address currentSigner = validators[validatorId].signer;

        // update signer event

        logger.logSignerChange(validatorId, currentSigner, signer, signerPubkey);

        

        if (validators[validatorId].deactivationEpoch == 0) { 

            // didn't unstake, swap signer in the list

            _removeSigner(currentSigner);

            _insertSigner(signer);

        }



        signerToValidator[currentSigner] = INCORRECT_VALIDATOR_ID;

        signerToValidator[signer] = validatorId;

        validators[validatorId].signer = signer;



        // reset update time to current time

        latestSignerUpdateEpoch[validatorId] = _currentEpoch;

    }



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        uint256[3][] calldata sigs

    ) external onlyRootChain returns (uint256) {

        uint256 _currentEpoch = currentEpoch;

        uint256 signedStakePower;

        address lastAdd;

        uint256 totalStakers = validatorState.stakerCount;



        UnsignedValidatorsContext memory unsignedCtx;

        unsignedCtx.unsignedValidators = new uint256[](signers.length + totalStakers);

        unsignedCtx.validators = signers;

        unsignedCtx.validatorIndex = 0;

        unsignedCtx.totalValidators = signers.length;



        UnstakedValidatorsContext memory unstakeCtx;

        unstakeCtx.deactivatedValidators = new uint256[](signers.length + totalStakers);



        for (uint256 i = 0; i < sigs.length; ++i) {

            address signer = ECVerify.ecrecovery(voteHash, sigs[i]);



            if (signer == lastAdd) {

                // if signer signs twice, just skip this signature

                continue;

            }



            if (signer < lastAdd) {

                // if signatures are out of order - break out, it is not possible to keep track of unsigned validators

                break;

            }



            uint256 validatorId = signerToValidator[signer];

            uint256 amount = validators[validatorId].amount;

            Status status = validators[validatorId].status;

            unstakeCtx.deactivationEpoch = validators[validatorId].deactivationEpoch;



            if (_isValidator(status, amount, unstakeCtx.deactivationEpoch, _currentEpoch)) {

                lastAdd = signer;



                signedStakePower = signedStakePower.add(validators[validatorId].delegatedAmount).add(amount);



                if (unstakeCtx.deactivationEpoch != 0) {

                    // this validator not a part of signers list anymore

                    unstakeCtx.deactivatedValidators[unstakeCtx.validatorIndex] = validatorId;

                    unstakeCtx.validatorIndex++;

                } else {

                    unsignedCtx = _fillUnsignedValidators(unsignedCtx, signer);

                }

            } else if (status == Status.Locked) {

                // TODO fix double unsignedValidators appearance

                // make sure that jailed validator doesn't get his rewards too

                unsignedCtx.unsignedValidators[unsignedCtx.unsignedValidatorIndex] = validatorId;

                unsignedCtx.unsignedValidatorIndex++;

                unsignedCtx.validatorIndex++;

            }

        }



        // find the rest of validators without signature

        unsignedCtx = _fillUnsignedValidators(unsignedCtx, address(0));



        return

            _increaseRewardAndAssertConsensus(

                blockInterval,

                proposer,

                signedStakePower,

                stateRoot,

                unsignedCtx.unsignedValidators,

                unsignedCtx.unsignedValidatorIndex,

                unstakeCtx.deactivatedValidators,

                unstakeCtx.validatorIndex

            );

    }



    function updateCommissionRate(uint256 validatorId, uint256 newCommissionRate) external onlyStaker(validatorId) {

        _updateRewards(validatorId);



        delegatedFwd(

            extensionCode,

            abi.encodeWithSelector(

                StakeManagerExtension(extensionCode).updateCommissionRate.selector,

                validatorId,

                newCommissionRate

            )

        );

    }



    function withdrawDelegatorsReward(uint256 validatorId) public onlyDelegation(validatorId) returns (uint256) {

        _updateRewards(validatorId);



        uint256 totalReward = validators[validatorId].delegatorsReward.sub(INITIALIZED_AMOUNT);

        validators[validatorId].delegatorsReward = INITIALIZED_AMOUNT;

        return totalReward;

    }



    function slash(bytes calldata _slashingInfoList) external returns (uint256) {

        require(Registry(registry).getSlashingManagerAddress() == msg.sender, "Not slash manager");



        RLPReader.RLPItem[] memory slashingInfoList = _slashingInfoList.toRlpItem().toList();

        int256 valJailed;

        uint256 jailedAmount;

        uint256 totalAmount;

        uint256 i;



        for (; i < slashingInfoList.length; i++) {

            RLPReader.RLPItem[] memory slashData = slashingInfoList[i].toList();



            uint256 validatorId = slashData[0].toUint();

            _updateRewards(validatorId);



            uint256 _amount = slashData[1].toUint();

            totalAmount = totalAmount.add(_amount);



            address delegationContract = validators[validatorId].contractAddress;

            if (delegationContract != address(0x0)) {

                uint256 delSlashedAmount =

                    IValidatorShare(delegationContract).slash(

                        validators[validatorId].amount,

                        validators[validatorId].delegatedAmount,

                        _amount

                    );

                _amount = _amount.sub(delSlashedAmount);

            }



            uint256 validatorStakeSlashed = validators[validatorId].amount.sub(_amount);

            validators[validatorId].amount = validatorStakeSlashed;



            if (validatorStakeSlashed == 0) {

                _unstake(validatorId, currentEpoch);

            } else if (slashData[2].toBoolean()) {

                jailedAmount = jailedAmount.add(_jail(validatorId, 1));

                valJailed++;

            }

        }



        //update timeline

        updateTimeline(-int256(totalAmount.add(jailedAmount)), -valJailed, 0);



        return totalAmount;

    }



    function unjail(uint256 validatorId) public onlyStaker(validatorId) {

        require(validators[validatorId].status == Status.Locked, "Not jailed");

        require(validators[validatorId].deactivationEpoch == 0, "Already unstaking");



        uint256 _currentEpoch = currentEpoch;

        require(validators[validatorId].jailTime <= _currentEpoch, "Incomplete jail period");



        uint256 amount = validators[validatorId].amount;

        require(amount >= minDeposit);



        address delegationContract = validators[validatorId].contractAddress;

        if (delegationContract != address(0x0)) {

            IValidatorShare(delegationContract).unlock();

        }



        // undo timeline so that validator is normal validator

        updateTimeline(int256(amount.add(validators[validatorId].delegatedAmount)), 1, 0);



        validators[validatorId].status = Status.Active;



        address signer = validators[validatorId].signer;

        logger.logUnjailed(validatorId, signer);

    }



    function updateTimeline(

        int256 amount,

        int256 stakerCount,

        uint256 targetEpoch

    ) internal {

        if (targetEpoch == 0) {

            // update total stake and validator count

            if (amount > 0) {

                validatorState.amount = validatorState.amount.add(uint256(amount));

            } else if (amount < 0) {

                validatorState.amount = validatorState.amount.sub(uint256(amount * -1));

            }



            if (stakerCount > 0) {

                validatorState.stakerCount = validatorState.stakerCount.add(uint256(stakerCount));

            } else if (stakerCount < 0) {

                validatorState.stakerCount = validatorState.stakerCount.sub(uint256(stakerCount * -1));

            }

        } else {

            validatorStateChanges[targetEpoch].amount += amount;

            validatorStateChanges[targetEpoch].stakerCount += stakerCount;

        }

    }



    function updateValidatorDelegation(bool delegation) external {

        uint256 validatorId = signerToValidator[msg.sender];

        require(

            _isValidator(

                validators[validatorId].status,

                validators[validatorId].amount,

                validators[validatorId].deactivationEpoch,

                currentEpoch

            ),

            "not validator"

        );



        address contractAddr = validators[validatorId].contractAddress;

        require(contractAddr != address(0x0), "Delegation is disabled");



        IValidatorShare(contractAddr).updateDelegation(delegation);

    }



    /**

        Private Methods

     */



    function _getAndAssertSigner(bytes memory pub) private view returns (address) {

        require(pub.length == 64, "not pub");

        address signer = address(uint160(uint256(keccak256(pub))));

        require(signer != address(0) && signerToValidator[signer] == 0, "Invalid signer");

        return signer;

    }



    function _isValidator(

        Status status,

        uint256 amount,

        uint256 deactivationEpoch,

        uint256 _currentEpoch

    ) private pure returns (bool) {

        return (amount > 0 && (deactivationEpoch == 0 || deactivationEpoch > _currentEpoch) && status == Status.Active);

    }



    function _fillUnsignedValidators(UnsignedValidatorsContext memory context, address signer)

        private

        view

        returns(UnsignedValidatorsContext memory)

    {

        while (context.validatorIndex < context.totalValidators && context.validators[context.validatorIndex] != signer) {

            context.unsignedValidators[context.unsignedValidatorIndex] = signerToValidator[context.validators[context.validatorIndex]];

            context.unsignedValidatorIndex++;

            context.validatorIndex++;

        }



        context.validatorIndex++;

        return context;

    }



    function _calculateCheckpointReward(

        uint256 blockInterval,

        uint256 signedStakePower,

        uint256 currentTotalStake

    ) internal returns (uint256) {

        // checkpoint rewards are based on BlockInterval multiplied on `CHECKPOINT_REWARD`

        // for bigger checkpoints reward is reduced by rewardDecreasePerCheckpoint for each subsequent interval



        // for smaller checkpoints

        // if interval is 50% of checkPointBlockInterval then reward R is half of `CHECKPOINT_REWARD`

        // and then stakePower is 90% of currentValidatorSetTotalStake then final reward is 90% of R



        uint256 targetBlockInterval = checkPointBlockInterval;

        uint256 ckpReward = CHECKPOINT_REWARD;

        uint256 fullIntervals = Math.min(blockInterval / targetBlockInterval, maxRewardedCheckpoints);



        // only apply to full checkpoints

        if (fullIntervals > 0 && fullIntervals != prevBlockInterval) {

            if (prevBlockInterval != 0) {

                // give more reward for faster and less for slower checkpoint

                uint256 delta = (ckpReward * checkpointRewardDelta / CHK_REWARD_PRECISION);

                

                if (prevBlockInterval > fullIntervals) {

                    // checkpoint is faster

                    ckpReward += delta;

                } else {

                    ckpReward -= delta;

                }

            }

            

            prevBlockInterval = fullIntervals;

        }



        uint256 reward;



        if (blockInterval > targetBlockInterval) {

            // count how many full intervals

            uint256 _rewardDecreasePerCheckpoint = rewardDecreasePerCheckpoint;



            // calculate reward for full intervals

            reward = ckpReward.mul(fullIntervals).sub(ckpReward.mul(((fullIntervals - 1) * fullIntervals / 2).mul(_rewardDecreasePerCheckpoint)).div(CHK_REWARD_PRECISION));

            // adjust block interval, in case last interval is not full

            blockInterval = blockInterval.sub(fullIntervals.mul(targetBlockInterval));

            // adjust checkpoint reward by the amount it suppose to decrease

            ckpReward = ckpReward.sub(ckpReward.mul(fullIntervals).mul(_rewardDecreasePerCheckpoint).div(CHK_REWARD_PRECISION));

        }



        // give proportionally less for the rest

        reward = reward.add(blockInterval.mul(ckpReward).div(targetBlockInterval));

        reward = reward.mul(signedStakePower).div(currentTotalStake);

        return reward;

    }



    function _increaseRewardAndAssertConsensus(

        uint256 blockInterval,

        address proposer,

        uint256 signedStakePower,

        bytes32 stateRoot,

        uint256[] memory unsignedValidators,

        uint256 totalUnsignedValidators,

        uint256[] memory deactivatedValidators,

        uint256 totalDeactivatedValidators

    ) private returns (uint256) {

        uint256 currentTotalStake = validatorState.amount;

        require(signedStakePower >= currentTotalStake.mul(2).div(3).add(1), "2/3+1 non-majority!");



        uint256 reward = _calculateCheckpointReward(blockInterval, signedStakePower, currentTotalStake);



        uint256 _proposerBonus = reward.mul(proposerBonus).div(MAX_PROPOSER_BONUS);

        uint256 proposerId = signerToValidator[proposer];



        Validator storage _proposer = validators[proposerId];

        _proposer.reward = _proposer.reward.add(_proposerBonus);



        // update stateMerkleTree root for accounts balance on heimdall chain

        accountStateRoot = stateRoot;



        uint256 newRewardPerStake =

            rewardPerStake.add(reward.sub(_proposerBonus).mul(REWARD_PRECISION).div(signedStakePower));



        // evaluate rewards for validator who did't sign and set latest reward per stake to new value to avoid them from getting new rewards.

        _updateValidatorsRewards(unsignedValidators, totalUnsignedValidators, newRewardPerStake);



        // distribute rewards between signed validators

        rewardPerStake = newRewardPerStake;



        // evaluate rewards for unstaked validators to ensure they get the reward for signing during their deactivationEpoch

        _updateValidatorsRewards(deactivatedValidators, totalDeactivatedValidators, newRewardPerStake);



        _finalizeCommit();

        return reward;

    }



    function _updateValidatorsRewards(

        uint256[] memory unsignedValidators,

        uint256 totalUnsignedValidators,

        uint256 newRewardPerStake

    ) private {

        uint256 currentRewardPerStake = rewardPerStake;

        for (uint256 i = 0; i < totalUnsignedValidators; ++i) {

            _updateRewardsAndCommit(unsignedValidators[i], currentRewardPerStake, newRewardPerStake);

        }

    }



    function _updateRewardsAndCommit(

        uint256 validatorId,

        uint256 currentRewardPerStake,

        uint256 newRewardPerStake

    ) private {

        uint256 deactivationEpoch = validators[validatorId].deactivationEpoch;

        if (deactivationEpoch != 0 && currentEpoch >= deactivationEpoch) {

            return;

        }



        uint256 initialRewardPerStake = validators[validatorId].initialRewardPerStake;



        // attempt to save gas in case if rewards were updated previosuly

        if (initialRewardPerStake < currentRewardPerStake) {

            uint256 validatorsStake = validators[validatorId].amount;

            uint256 delegatedAmount = validators[validatorId].delegatedAmount;

            if (delegatedAmount > 0) {

                uint256 combinedStakePower = validatorsStake.add(delegatedAmount);

                _increaseValidatorRewardWithDelegation(

                    validatorId,

                    validatorsStake,

                    delegatedAmount,

                    _getEligibleValidatorReward(

                        validatorId,

                        combinedStakePower,

                        currentRewardPerStake,

                        initialRewardPerStake

                    )

                );

            } else {

                _increaseValidatorReward(

                    validatorId,

                    _getEligibleValidatorReward(

                        validatorId,

                        validatorsStake,

                        currentRewardPerStake,

                        initialRewardPerStake

                    )

                );

            }

        }



        if (newRewardPerStake > initialRewardPerStake) {

            validators[validatorId].initialRewardPerStake = newRewardPerStake;

        }

    }



    function _updateRewards(uint256 validatorId) private {

        _updateRewardsAndCommit(validatorId, rewardPerStake, rewardPerStake);

    }



    function _getEligibleValidatorReward(

        uint256 validatorId,

        uint256 validatorStakePower,

        uint256 currentRewardPerStake,

        uint256 initialRewardPerStake

    ) private pure returns (uint256) {

        uint256 eligibleReward = currentRewardPerStake - initialRewardPerStake;

        return eligibleReward.mul(validatorStakePower).div(REWARD_PRECISION);

    }



    function _increaseValidatorReward(uint256 validatorId, uint256 reward) private {

        if (reward > 0) {

            validators[validatorId].reward = validators[validatorId].reward.add(reward);

        }

    }



    function _increaseValidatorRewardWithDelegation(

        uint256 validatorId,

        uint256 validatorsStake,

        uint256 delegatedAmount,

        uint256 reward

    ) private {

        uint256 combinedStakePower = delegatedAmount.add(validatorsStake);

        (uint256 validatorReward, uint256 delegatorsReward) =

            _getValidatorAndDelegationReward(validatorId, validatorsStake, reward, combinedStakePower);



        if (delegatorsReward > 0) {

            validators[validatorId].delegatorsReward = validators[validatorId].delegatorsReward.add(delegatorsReward);

        }



        if (validatorReward > 0) {

            validators[validatorId].reward = validators[validatorId].reward.add(validatorReward);

        }

    }



    function _getValidatorAndDelegationReward(

        uint256 validatorId,

        uint256 validatorsStake,

        uint256 reward,

        uint256 combinedStakePower

    ) internal view returns (uint256, uint256) {

        if (combinedStakePower == 0) {

            return (0, 0);

        }



        uint256 validatorReward = validatorsStake.mul(reward).div(combinedStakePower);



        // add validator commission from delegation reward

        uint256 commissionRate = validators[validatorId].commissionRate;

        if (commissionRate > 0) {

            validatorReward = validatorReward.add(

                reward.sub(validatorReward).mul(commissionRate).div(MAX_COMMISION_RATE)

            );

        }



        uint256 delegatorsReward = reward.sub(validatorReward);

        return (validatorReward, delegatorsReward);

    }



    function _evaluateValidatorAndDelegationReward(uint256 validatorId)

        private

        view

        returns (uint256 validatorReward, uint256 delegatorsReward)

    {

        uint256 validatorsStake = validators[validatorId].amount;

        uint256 combinedStakePower = validatorsStake.add(validators[validatorId].delegatedAmount);

        uint256 eligibleReward = rewardPerStake - validators[validatorId].initialRewardPerStake;

        return

            _getValidatorAndDelegationReward(

                validatorId,

                validatorsStake,

                eligibleReward.mul(combinedStakePower).div(REWARD_PRECISION),

                combinedStakePower

            );

    }



    function _jail(uint256 validatorId, uint256 jailCheckpoints) internal returns (uint256) {

        address delegationContract = validators[validatorId].contractAddress;

        if (delegationContract != address(0x0)) {

            IValidatorShare(delegationContract).lock();

        }



        uint256 _currentEpoch = currentEpoch;

        validators[validatorId].jailTime = _currentEpoch.add(jailCheckpoints);

        validators[validatorId].status = Status.Locked;

        logger.logJailed(validatorId, _currentEpoch, validators[validatorId].signer);

        return validators[validatorId].amount.add(validators[validatorId].delegatedAmount);

    }



    function _stakeFor(

        address user,

        uint256 amount,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) internal returns (uint256) {

        address signer = _getAndAssertSigner(signerPubkey);

        uint256 _currentEpoch = currentEpoch;

        uint256 validatorId = NFTCounter;

        StakingInfo _logger = logger;



        uint256 newTotalStaked = totalStaked.add(amount);

        totalStaked = newTotalStaked;



        validators[validatorId] = Validator({

            reward: INITIALIZED_AMOUNT,

            amount: amount,

            activationEpoch: _currentEpoch,

            deactivationEpoch: 0,

            jailTime: 0,

            signer: signer,

            contractAddress: acceptDelegation

                ? validatorShareFactory.create(validatorId, address(_logger), registry)

                : address(0x0),

            status: Status.Active,

            commissionRate: 0,

            lastCommissionUpdate: 0,

            delegatorsReward: INITIALIZED_AMOUNT,

            delegatedAmount: 0,

            initialRewardPerStake: rewardPerStake

        });



        latestSignerUpdateEpoch[validatorId] = _currentEpoch;

        NFTContract.mint(user, validatorId);



        signerToValidator[signer] = validatorId;

        updateTimeline(int256(amount), 1, 0);

        // no Auctions for 1 dynasty

        validatorAuction[validatorId].startEpoch = _currentEpoch;

        _logger.logStaked(signer, signerPubkey, validatorId, _currentEpoch, amount, newTotalStaked);

        NFTCounter = validatorId.add(1);



        _insertSigner(signer);



        return validatorId;

    }



    function _unstake(uint256 validatorId, uint256 exitEpoch) internal {

        // TODO: if validators unstake and slashed to 0, he will be forced to unstake again

        // must think how to handle it correctly

        _updateRewards(validatorId);



        uint256 amount = validators[validatorId].amount;

        address validator = ownerOf(validatorId);



        validators[validatorId].deactivationEpoch = exitEpoch;



        // unbond all delegators in future

        int256 delegationAmount = int256(validators[validatorId].delegatedAmount);



        address delegationContract = validators[validatorId].contractAddress;

        if (delegationContract != address(0)) {

            IValidatorShare(delegationContract).lock();

        }



        _removeSigner(validators[validatorId].signer);

        _liquidateRewards(validatorId, validator);



        uint256 targetEpoch = exitEpoch <= currentEpoch ? 0 : exitEpoch;

        updateTimeline(-(int256(amount) + delegationAmount), -1, targetEpoch);



        logger.logUnstakeInit(validator, validatorId, exitEpoch, amount);

    }



    function _finalizeCommit() internal {

        uint256 _currentEpoch = currentEpoch;

        uint256 nextEpoch = _currentEpoch.add(1);



        StateChange memory changes = validatorStateChanges[nextEpoch];

        updateTimeline(changes.amount, changes.stakerCount, 0);



        delete validatorStateChanges[_currentEpoch];



        currentEpoch = nextEpoch;

    }



    function _liquidateRewards(uint256 validatorId, address validatorUser) private {

        uint256 reward = validators[validatorId].reward.sub(INITIALIZED_AMOUNT);

        totalRewardsLiquidated = totalRewardsLiquidated.add(reward);

        validators[validatorId].reward = INITIALIZED_AMOUNT;

        _transferToken(validatorUser, reward);

        logger.logClaimRewards(validatorId, reward, totalRewardsLiquidated);

    }



    function _transferToken(address destination, uint256 amount) private {

        require(token.transfer(destination, amount), "transfer failed");

    }



    function _transferTokenFrom(

        address from,

        address destination,

        uint256 amount

    ) private {

        require(token.transferFrom(from, destination, amount), "transfer from failed");

    }



    function _transferAndTopUp(

        address user,

        address from,

        uint256 fee,

        uint256 additionalAmount

    ) private {

        require(fee >= minHeimdallFee, "fee too small");

        _transferTokenFrom(from, address(this), fee.add(additionalAmount));

        totalHeimdallFee = totalHeimdallFee.add(fee);

        logger.logTopUpFee(user, fee);

    }



    function _claimFee(address user, uint256 amount) private {

        totalHeimdallFee = totalHeimdallFee.sub(amount);

        logger.logClaimFee(user, amount);

    }



    function _insertSigner(address newSigner) internal {

        signers.push(newSigner);



        uint lastIndex = signers.length - 1;

        uint i = lastIndex;

        for (; i > 0; --i) {

            address signer = signers[i - 1];

            if (signer < newSigner) {

                break;

            }

            signers[i] = signer;

        }



        if (i != lastIndex) {

            signers[i] = newSigner;

        }

    }



    function _removeSigner(address signerToDelete) internal {

        uint256 totalSigners = signers.length;

        address swapSigner = signers[totalSigners - 1];

        delete signers[totalSigners - 1];



        // bubble last element to the beginning until target signer is met

        for (uint256 i = totalSigners - 1; i > 0; --i) {

            if (swapSigner == signerToDelete) {

                break;

            }



            (swapSigner, signers[i - 1]) = (signers[i - 1], swapSigner);

        }



        signers.length = totalSigners - 1;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\StakeManagerProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-06-30

*/



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

// File: contracts/common/misc/ERCProxy.sol



/*

 * SPDX-License-Identitifer:    MIT

 */



pragma solidity ^0.5.2;



// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md



interface ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);

    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/misc/DelegateProxy.sol



pragma solidity ^0.5.2;







contract DelegateProxy is ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external view returns (address);



    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas, 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }

}



// File: contracts/common/misc/UpgradableProxy.sol



pragma solidity ^0.5.2;





contract UpgradableProxy is DelegateProxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event OwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    function() external payable {

        // require(currentContract != 0, "If app code has not been set yet, do not call");

        // Todo: filter out some calls or handle in the end fallback

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function owner() external view returns(address) {

        return loadOwner();

    }



    function loadOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit OwnerUpdate(newOwner, loadOwner());

        setOwner(newOwner);

    }



    function setOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call.value(msg.value)(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/staking/stakeManager/StakeManagerProxy.sol



pragma solidity ^0.5.2;





contract StakeManagerProxy is UpgradableProxy {

    constructor(address _proxyTo) public UpgradableProxy(_proxyTo) {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\StakingInfo.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-06-30

*/



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

        _;

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;









contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/lib/BytesLib.sol



pragma solidity ^0.5.2;





library BytesLib {

    function concat(bytes memory _preBytes, bytes memory _postBytes)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;

        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(

                0x40,

                and(

                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),

                    not(31) // Round down to the nearest 32 bytes.

                )

            )

        }

        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start, uint256 _length)

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));

        bytes memory tempBytes;

        assembly {

            switch iszero(_length)

                case 0 {

                    // Get a location of some free memory and store it in tempBytes as

                    // Solidity does for memory variables.

                    tempBytes := mload(0x40)



                    // The first word of the slice result is potentially a partial

                    // word read from the original array. To read it, we calculate

                    // the length of that partial word and start copying that many

                    // bytes into the array. The first word we copy will start with

                    // data we don't care about, but the last `lengthmod` bytes will

                    // land at the beginning of the contents of the new array. When

                    // we're done copying, we overwrite the full first word with

                    // the actual length of the slice.

                    let lengthmod := and(_length, 31)



                    // The multiplication in the next line is necessary

                    // because when slicing multiples of 32 bytes (lengthmod == 0)

                    // the following copy loop was copying the origin's length

                    // and then ending prematurely not copying everything it should.

                    let mc := add(

                        add(tempBytes, lengthmod),

                        mul(0x20, iszero(lengthmod))

                    )

                    let end := add(mc, _length)



                    for {

                        // The multiplication in the next line has the same exact purpose

                        // as the one above.

                        let cc := add(

                            add(

                                add(_bytes, lengthmod),

                                mul(0x20, iszero(lengthmod))

                            ),

                            _start

                        )

                    } lt(mc, end) {

                        mc := add(mc, 0x20)

                        cc := add(cc, 0x20)

                    } {

                        mstore(mc, mload(cc))

                    }



                    mstore(tempBytes, _length)



                    //update free-memory pointer

                    //allocating the array padded to 32 bytes like the compiler does now

                    mstore(0x40, and(add(mc, 31), not(31)))

                }

                //if we want a zero-length slice let's just return a zero-length array

                default {

                    tempBytes := mload(0x40)

                    mstore(0x40, add(tempBytes, 0x20))

                }

        }



        return tempBytes;

    }



    // Pad a bytes array to 32 bytes

    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {

        // may underflow if bytes.length < 32. Hence using SafeMath.sub

        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));

        return concat(newBytes, _bytes);

    }



    function toBytes32(bytes memory b) internal pure returns (bytes32) {

        require(b.length >= 32, "Bytes array should atleast be 32 bytes");

        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {

            out |= bytes32(b[i] & 0xFF) >> (i * 8);

        }

        return out;

    }



    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {

        assembly {

            result := mload(add(b, 32))

        }

    }



    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {

        bytes memory b = new bytes(32);

        for (uint256 i = 0; i < 32; i++) {

            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));

        }

        return b;

    }



    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {

        _ret = new bytes(32);

        assembly {

            mstore(add(_ret, 32), _num)

        }

    }



    function toUint(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (uint256)

    {

        require(_bytes.length >= (_start + 32));

        uint256 tempUint;

        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }

        return tempUint;

    }



    function toAddress(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (address)

    {

        require(_bytes.length >= (_start + 20));

        address tempAddress;

        assembly {

            tempAddress := div(

                mload(add(add(_bytes, 0x20), _start)),

                0x1000000000000000000000000

            )

        }



        return tempAddress;

    }

}



// File: contracts/common/lib/ECVerify.sol



pragma solidity ^0.5.2;





library ECVerify {

    function ecrecovery(bytes32 hash, bytes memory sig)

        public

        pure

        returns (address)

    {

        bytes32 r;

        bytes32 s;

        uint8 v;



        if (sig.length != 65) {

            return address(0x0);

        }



        assembly {

            r := mload(add(sig, 32))

            s := mload(add(sig, 64))

            v := and(mload(add(sig, 65)), 255)

        }



        // https://github.com/ethereum/go-ethereum/issues/2053

        if (v < 27) {

            v += 27;

        }



        if (v != 27 && v != 28) {

            return address(0x0);

        }



        // get address out of hash and signature

        address result = ecrecover(hash, v, r, s);



        // ecrecover returns zero on error

        require(result != address(0x0));



        return result;

    }



    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)

        public

        pure

        returns (address)

    {

        // get address out of hash and signature

        address result = ecrecover(hash, v, r, s);



        // ecrecover returns zero on error

        require(result != address(0x0), "signature verification failed");



        return result;

    }



    function ecverify(bytes32 hash, bytes memory sig, address signer)

        public

        pure

        returns (bool)

    {

        return signer == ecrecovery(hash, sig);

    }

}



// File: contracts/staking/StakingInfo.sol



pragma solidity ^0.5.2;















// dummy interface to avoid cyclic dependency

contract IStakeManagerLocal {

    enum Status {Inactive, Active, Locked, Unstaked}



    struct Validator {

        uint256 amount;

        uint256 reward;

        uint256 activationEpoch;

        uint256 deactivationEpoch;

        uint256 jailTime;

        address signer;

        address contractAddress;

        Status status;

    }



    mapping(uint256 => Validator) public validators;

    bytes32 public accountStateRoot;

    uint256 public activeAmount; // delegation amount from validator contract

    uint256 public validatorRewards;



    function currentValidatorSetTotalStake() public view returns (uint256);



    // signer to Validator mapping

    function signerToValidator(address validatorAddress)

        public

        view

        returns (uint256);



    function isValidator(uint256 validatorId) public view returns (bool);

}





contract StakingInfo is Ownable {

    using SafeMath for uint256;

    mapping(uint256 => uint256) public validatorNonce;



    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.

    /// @param signer validator address.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param activationEpoch validator's first epoch as proposer.

    /// @param amount staking amount.

    /// @param total total staking amount.

    /// @param signerPubkey public key of the validator

    event Staked(

        address indexed signer,

        uint256 indexed validatorId,

        uint256 nonce,

        uint256 indexed activationEpoch,

        uint256 amount,

        uint256 total,

        bytes signerPubkey

    );



    /// @dev Emitted when validator unstakes in 'unstakeClaim()'

    /// @param user address of the validator.

    /// @param validatorId unique integer to identify a validator.

    /// @param amount staking amount.

    /// @param total total staking amount.

    event Unstaked(

        address indexed user,

        uint256 indexed validatorId,

        uint256 amount,

        uint256 total

    );



    /// @dev Emitted when validator unstakes in '_unstake()'.

    /// @param user address of the validator.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param deactivationEpoch last epoch for validator.

    /// @param amount staking amount.

    event UnstakeInit(

        address indexed user,

        uint256 indexed validatorId,

        uint256 nonce,

        uint256 deactivationEpoch,

        uint256 indexed amount

    );



    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param oldSigner old address of the validator.

    /// @param newSigner new address of the validator.

    /// @param signerPubkey public key of the validator.

    event SignerChange(

        uint256 indexed validatorId,

        uint256 nonce,

        address indexed oldSigner,

        address indexed newSigner,

        bytes signerPubkey

    );

    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);

    event Jailed(

        uint256 indexed validatorId,

        uint256 indexed exitEpoch,

        address indexed signer

    );

    event UnJailed(uint256 indexed validatorId, address indexed signer);

    event Slashed(uint256 indexed nonce, uint256 indexed amount);

    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);

    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);

    event ProposerBonusChange(

        uint256 newProposerBonus,

        uint256 oldProposerBonus

    );



    event RewardUpdate(uint256 newReward, uint256 oldReward);



    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param newAmount the updated stake amount.

    event StakeUpdate(

        uint256 indexed validatorId,

        uint256 indexed nonce,

        uint256 indexed newAmount

    );

    event ClaimRewards(

        uint256 indexed validatorId,

        uint256 indexed amount,

        uint256 indexed totalAmount

    );

    event StartAuction(

        uint256 indexed validatorId,

        uint256 indexed amount,

        uint256 indexed auctionAmount

    );

    event ConfirmAuction(

        uint256 indexed newValidatorId,

        uint256 indexed oldValidatorId,

        uint256 indexed amount

    );

    event TopUpFee(address indexed user, uint256 indexed fee);

    event ClaimFee(address indexed user, uint256 indexed fee);

    // Delegator events

    event ShareMinted(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens

    );

    event ShareBurned(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens

    );

    event DelegatorClaimedRewards(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed rewards

    );

    event DelegatorRestaked(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed totalStaked

    );

    event DelegatorUnstaked(

        uint256 indexed validatorId,

        address indexed user,

        uint256 amount

    );

    event UpdateCommissionRate(

        uint256 indexed validatorId,

        uint256 indexed newCommissionRate,

        uint256 indexed oldCommissionRate

    );



    Registry public registry;



    modifier onlyValidatorContract(uint256 validatorId) {

        address _contract;

        (, , , , , , _contract, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

        require(_contract == msg.sender,

        "Invalid sender, not validator");

        _;

    }



    modifier StakeManagerOrValidatorContract(uint256 validatorId) {

        address _contract;

        address _stakeManager = registry.getStakeManagerAddress();

        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(

            validatorId

        );

        require(_contract == msg.sender || _stakeManager == msg.sender,

        "Invalid sender, not stake manager or validator contract");

        _;

    }



    modifier onlyStakeManager() {

        require(registry.getStakeManagerAddress() == msg.sender,

        "Invalid sender, not stake manager");

        _;

    }

    modifier onlySlashingManager() {

        require(registry.getSlashingManagerAddress() == msg.sender,

        "Invalid sender, not slashing manager");

        _;

    }



    constructor(address _registry) public {

        registry = Registry(_registry);

    }



    function updateNonce(

        uint256[] calldata validatorIds,

        uint256[] calldata nonces

    ) external onlyOwner {

        require(validatorIds.length == nonces.length, "args length mismatch");



        for (uint256 i = 0; i < validatorIds.length; ++i) {

            validatorNonce[validatorIds[i]] = nonces[i];

        }

    } 



    function logStaked(

        address signer,

        bytes memory signerPubkey,

        uint256 validatorId,

        uint256 activationEpoch,

        uint256 amount,

        uint256 total

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit Staked(

            signer,

            validatorId,

            validatorNonce[validatorId],

            activationEpoch,

            amount,

            total,

            signerPubkey

        );

    }



    function logUnstaked(

        address user,

        uint256 validatorId,

        uint256 amount,

        uint256 total

    ) public onlyStakeManager {

        emit Unstaked(user, validatorId, amount, total);

    }



    function logUnstakeInit(

        address user,

        uint256 validatorId,

        uint256 deactivationEpoch,

        uint256 amount

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit UnstakeInit(

            user,

            validatorId,

            validatorNonce[validatorId],

            deactivationEpoch,

            amount

        );

    }



    function logSignerChange(

        uint256 validatorId,

        address oldSigner,

        address newSigner,

        bytes memory signerPubkey

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit SignerChange(

            validatorId,

            validatorNonce[validatorId],

            oldSigner,

            newSigner,

            signerPubkey

        );

    }



    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)

        public

        onlyStakeManager

    {

        emit Restaked(validatorId, amount, total);

    }



    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)

        public

        onlyStakeManager

    {

        emit Jailed(validatorId, exitEpoch, signer);

    }



    function logUnjailed(uint256 validatorId, address signer)

        public

        onlyStakeManager

    {

        emit UnJailed(validatorId, signer);

    }



    function logSlashed(uint256 nonce, uint256 amount)

        public

        onlySlashingManager

    {

        emit Slashed(nonce, amount);

    }



    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)

        public

        onlyStakeManager

    {

        emit ThresholdChange(newThreshold, oldThreshold);

    }



    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)

        public

        onlyStakeManager

    {

        emit DynastyValueChange(newDynasty, oldDynasty);

    }



    function logProposerBonusChange(

        uint256 newProposerBonus,

        uint256 oldProposerBonus

    ) public onlyStakeManager {

        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);

    }



    function logRewardUpdate(uint256 newReward, uint256 oldReward)

        public

        onlyStakeManager

    {

        emit RewardUpdate(newReward, oldReward);

    }



    function logStakeUpdate(uint256 validatorId)

        public

        StakeManagerOrValidatorContract(validatorId)

    {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit StakeUpdate(

            validatorId,

            validatorNonce[validatorId],

            totalValidatorStake(validatorId)

        );

    }



    function logClaimRewards(

        uint256 validatorId,

        uint256 amount,

        uint256 totalAmount

    ) public onlyStakeManager {

        emit ClaimRewards(validatorId, amount, totalAmount);

    }



    function logStartAuction(

        uint256 validatorId,

        uint256 amount,

        uint256 auctionAmount

    ) public onlyStakeManager {

        emit StartAuction(validatorId, amount, auctionAmount);

    }



    function logConfirmAuction(

        uint256 newValidatorId,

        uint256 oldValidatorId,

        uint256 amount

    ) public onlyStakeManager {

        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);

    }



    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {

        emit TopUpFee(user, fee);

    }



    function logClaimFee(address user, uint256 fee) public onlyStakeManager {

        emit ClaimFee(user, fee);

    }



    function getStakerDetails(uint256 validatorId)

        public

        view

        returns (

            uint256 amount,

            uint256 reward,

            uint256 activationEpoch,

            uint256 deactivationEpoch,

            address signer,

            uint256 _status

        )

    {

        IStakeManagerLocal stakeManager = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        );

        address _contract;

        IStakeManagerLocal.Status status;

        (

            amount,

            reward,

            activationEpoch,

            deactivationEpoch,

            ,

            signer,

            _contract,

            status

        ) = stakeManager.validators(validatorId);

        _status = uint256(status);

        if (_contract != address(0x0)) {

            reward += IStakeManagerLocal(_contract).validatorRewards();

        }

    }



    function totalValidatorStake(uint256 validatorId)

        public

        view

        returns (uint256 validatorStake)

    {

        address contractAddress;

        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

        if (contractAddress != address(0x0)) {

            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();

        }

    }



    function getAccountStateRoot()

        public

        view

        returns (bytes32 accountStateRoot)

    {

        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())

            .accountStateRoot();

    }



    function getValidatorContractAddress(uint256 validatorId)

        public

        view

        returns (address ValidatorContract)

    {

        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

    }



    // validator Share contract logging func

    function logShareMinted(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens

    ) public onlyValidatorContract(validatorId) {

        emit ShareMinted(validatorId, user, amount, tokens);

    }



    function logShareBurned(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens

    ) public onlyValidatorContract(validatorId) {

        emit ShareBurned(validatorId, user, amount, tokens);

    }



    function logDelegatorClaimRewards(

        uint256 validatorId,

        address user,

        uint256 rewards

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorClaimedRewards(validatorId, user, rewards);

    }



    function logDelegatorRestaked(

        uint256 validatorId,

        address user,

        uint256 totalStaked

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorRestaked(validatorId, user, totalStaked);

    }



    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)

        public

        onlyValidatorContract(validatorId)

    {

        emit DelegatorUnstaked(validatorId, user, amount);

    }



    function logUpdateCommissionRate(

        uint256 validatorId,

        uint256 newCommissionRate,

        uint256 oldCommissionRate

    ) public onlyValidatorContract(validatorId) {

        emit UpdateCommissionRate(

            validatorId,

            newCommissionRate,

            oldCommissionRate

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\StakingNFT.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-10-01

*/



// File: openzeppelin-solidity/contracts/introspection/IERC165.sol



pragma solidity ^0.5.2;



/**

 * @title IERC165

 * @dev https://eips.ethereum.org/EIPS/eip-165

 */

interface IERC165 {

    /**

     * @notice Query if a contract implements an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @dev Interface identification is specified in ERC-165. This function

     * uses less than 30,000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol



pragma solidity ^0.5.2;





/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    function balanceOf(address owner) public view returns (uint256 balance);

    function ownerOf(uint256 tokenId) public view returns (address owner);



    function approve(address to, uint256 tokenId) public;

    function getApproved(uint256 tokenId) public view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) public;

    function isApprovedForAll(address owner, address operator) public view returns (bool);



    function transferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId) public;



    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol



pragma solidity ^0.5.2;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract IERC721Receiver {

    /**

     * @notice Handle the receipt of an NFT

     * @dev The ERC721 smart contract calls this function on the recipient

     * after a `safeTransfer`. This function MUST return the function selector,

     * otherwise the caller will revert the transaction. The selector to be

     * returned can be obtained as `this.onERC721Received.selector`. This

     * function MAY throw to revert and reject the transfer.

     * Note: the ERC721 contract address is always the message sender.

     * @param operator The address which called `safeTransferFrom` function

     * @param from The address which previously owned the token

     * @param tokenId The NFT identifier which is being transferred

     * @param data Additional data with no specified format

     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)

    public returns (bytes4);

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: openzeppelin-solidity/contracts/utils/Address.sol



pragma solidity ^0.5.2;



/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



// File: openzeppelin-solidity/contracts/drafts/Counters.sol



pragma solidity ^0.5.2;





/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids

 *

 * Include with `using Counters for Counters.Counter;`

 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath

 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never

 * directly accessed.

 */

library Counters {

    using SafeMath for uint256;



    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        counter._value += 1;

    }



    function decrement(Counter storage counter) internal {

        counter._value = counter._value.sub(1);

    }

}



// File: openzeppelin-solidity/contracts/introspection/ERC165.sol



pragma solidity ^0.5.2;





/**

 * @title ERC165

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract ERC165 is IERC165 {

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /*

     * 0x01ffc9a7 ===

     *     bytes4(keccak256('supportsInterface(bytes4)'))

     */



    /**

     * @dev a mapping of interface id to whether or not it's supported

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    /**

     * @dev A contract implementing SupportsInterfaceWithLookup

     * implement ERC165 itself

     */

    constructor () internal {

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev implement supportsInterface(bytes4) using a lookup table

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev internal method for registering an interface

     */

    function _registerInterface(bytes4 interfaceId) internal {

        require(interfaceId != 0xffffffff);

        _supportedInterfaces[interfaceId] = true;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol



pragma solidity ^0.5.2;















/**

 * @title ERC721 Non-Fungible Token Standard basic implementation

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721 is ERC165, IERC721 {

    using SafeMath for uint256;

    using Address for address;

    using Counters for Counters.Counter;



    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;



    // Mapping from token ID to owner

    mapping (uint256 => address) private _tokenOwner;



    // Mapping from token ID to approved address

    mapping (uint256 => address) private _tokenApprovals;



    // Mapping from owner to number of owned token

    mapping (address => Counters.Counter) private _ownedTokensCount;



    // Mapping from owner to operator approvals

    mapping (address => mapping (address => bool)) private _operatorApprovals;



    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /*

     * 0x80ac58cd ===

     *     bytes4(keccak256('balanceOf(address)')) ^

     *     bytes4(keccak256('ownerOf(uint256)')) ^

     *     bytes4(keccak256('approve(address,uint256)')) ^

     *     bytes4(keccak256('getApproved(uint256)')) ^

     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^

     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^

     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))

     */



    constructor () public {

        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721);

    }



    /**

     * @dev Gets the balance of the specified address

     * @param owner address to query the balance of

     * @return uint256 representing the amount owned by the passed address

     */

    function balanceOf(address owner) public view returns (uint256) {

        require(owner != address(0));

        return _ownedTokensCount[owner].current();

    }



    /**

     * @dev Gets the owner of the specified token ID

     * @param tokenId uint256 ID of the token to query the owner of

     * @return address currently marked as the owner of the given token ID

     */

    function ownerOf(uint256 tokenId) public view returns (address) {

        address owner = _tokenOwner[tokenId];

        require(owner != address(0));

        return owner;

    }



    /**

     * @dev Approves another address to transfer the given token ID

     * The zero address indicates there is no approved address.

     * There can only be one approved address per token at a given time.

     * Can only be called by the token owner or an approved operator.

     * @param to address to be approved for the given token ID

     * @param tokenId uint256 ID of the token to be approved

     */

    function approve(address to, uint256 tokenId) public {

        address owner = ownerOf(tokenId);

        require(to != owner);

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));



        _tokenApprovals[tokenId] = to;

        emit Approval(owner, to, tokenId);

    }



    /**

     * @dev Gets the approved address for a token ID, or zero if no address set

     * Reverts if the token ID does not exist.

     * @param tokenId uint256 ID of the token to query the approval of

     * @return address currently approved for the given token ID

     */

    function getApproved(uint256 tokenId) public view returns (address) {

        require(_exists(tokenId));

        return _tokenApprovals[tokenId];

    }



    /**

     * @dev Sets or unsets the approval of a given operator

     * An operator is allowed to transfer all tokens of the sender on their behalf

     * @param to operator address to set the approval

     * @param approved representing the status of the approval to be set

     */

    function setApprovalForAll(address to, bool approved) public {

        require(to != msg.sender);

        _operatorApprovals[msg.sender][to] = approved;

        emit ApprovalForAll(msg.sender, to, approved);

    }



    /**

     * @dev Tells whether an operator is approved by a given owner

     * @param owner owner address which you want to query the approval of

     * @param operator operator address which you want to query the approval of

     * @return bool whether the given operator is approved by the given owner

     */

    function isApprovedForAll(address owner, address operator) public view returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    /**

     * @dev Transfers the ownership of a given token ID to another address

     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function transferFrom(address from, address to, uint256 tokenId) public {

        require(_isApprovedOrOwner(msg.sender, tokenId));



        _transferFrom(from, to, tokenId);

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) public {

        safeTransferFrom(from, to, tokenId, "");

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes data to send along with a safe transfer check

     */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {

        transferFrom(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data));

    }



    /**

     * @dev Returns whether the specified token exists

     * @param tokenId uint256 ID of the token to query the existence of

     * @return bool whether the token exists

     */

    function _exists(uint256 tokenId) internal view returns (bool) {

        address owner = _tokenOwner[tokenId];

        return owner != address(0);

    }



    /**

     * @dev Returns whether the given spender can transfer a given token ID

     * @param spender address of the spender to query

     * @param tokenId uint256 ID of the token to be transferred

     * @return bool whether the msg.sender is approved for the given token ID,

     * is an operator of the owner, or is the owner of the token

     */

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {

        address owner = ownerOf(tokenId);

        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));

    }



    /**

     * @dev Internal function to mint a new token

     * Reverts if the given token ID already exists

     * @param to The address that will own the minted token

     * @param tokenId uint256 ID of the token to be minted

     */

    function _mint(address to, uint256 tokenId) internal {

        require(to != address(0));

        require(!_exists(tokenId));



        _tokenOwner[tokenId] = to;

        _ownedTokensCount[to].increment();



        emit Transfer(address(0), to, tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead.

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(address owner, uint256 tokenId) internal {

        require(ownerOf(tokenId) == owner);



        _clearApproval(tokenId);



        _ownedTokensCount[owner].decrement();

        _tokenOwner[tokenId] = address(0);



        emit Transfer(owner, address(0), tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(uint256 tokenId) internal {

        _burn(ownerOf(tokenId), tokenId);

    }



    /**

     * @dev Internal function to transfer ownership of a given token ID to another address.

     * As opposed to transferFrom, this imposes no restrictions on msg.sender.

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _transferFrom(address from, address to, uint256 tokenId) internal {

        require(ownerOf(tokenId) == from);

        require(to != address(0));



        _clearApproval(tokenId);



        _ownedTokensCount[from].decrement();

        _ownedTokensCount[to].increment();



        _tokenOwner[tokenId] = to;



        emit Transfer(from, to, tokenId);

    }



    /**

     * @dev Internal function to invoke `onERC721Received` on a target address

     * The call is not executed if the target address is not a contract

     * @param from address representing the previous owner of the given token ID

     * @param to target address that will receive the tokens

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes optional data to send along with the call

     * @return bool whether the call correctly returned the expected magic value

     */

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)

        internal returns (bool)

    {

        if (!to.isContract()) {

            return true;

        }



        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);

        return (retval == _ERC721_RECEIVED);

    }



    /**

     * @dev Private function to clear current approval of a given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _clearApproval(uint256 tokenId) private {

        if (_tokenApprovals[tokenId] != address(0)) {

            _tokenApprovals[tokenId] = address(0);

        }

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol



pragma solidity ^0.5.2;





/**

 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721Enumerable is IERC721 {

    function totalSupply() public view returns (uint256);

    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);



    function tokenByIndex(uint256 index) public view returns (uint256);

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol



pragma solidity ^0.5.2;









/**

 * @title ERC-721 Non-Fungible Token with optional enumeration extension logic

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {

    // Mapping from owner to list of owned token IDs

    mapping(address => uint256[]) private _ownedTokens;



    // Mapping from token ID to index of the owner tokens list

    mapping(uint256 => uint256) private _ownedTokensIndex;



    // Array with all token ids, used for enumeration

    uint256[] private _allTokens;



    // Mapping from token id to position in the allTokens array

    mapping(uint256 => uint256) private _allTokensIndex;



    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;

    /*

     * 0x780e9d63 ===

     *     bytes4(keccak256('totalSupply()')) ^

     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^

     *     bytes4(keccak256('tokenByIndex(uint256)'))

     */



    /**

     * @dev Constructor function

     */

    constructor () public {

        // register the supported interface to conform to ERC721Enumerable via ERC165

        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);

    }



    /**

     * @dev Gets the token ID at a given index of the tokens list of the requested owner

     * @param owner address owning the tokens list to be accessed

     * @param index uint256 representing the index to be accessed of the requested tokens list

     * @return uint256 token ID at the given index of the tokens list owned by the requested address

     */

    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {

        require(index < balanceOf(owner));

        return _ownedTokens[owner][index];

    }



    /**

     * @dev Gets the total amount of tokens stored by the contract

     * @return uint256 representing the total amount of tokens

     */

    function totalSupply() public view returns (uint256) {

        return _allTokens.length;

    }



    /**

     * @dev Gets the token ID at a given index of all the tokens in this contract

     * Reverts if the index is greater or equal to the total number of tokens

     * @param index uint256 representing the index to be accessed of the tokens list

     * @return uint256 token ID at the given index of the tokens list

     */

    function tokenByIndex(uint256 index) public view returns (uint256) {

        require(index < totalSupply());

        return _allTokens[index];

    }



    /**

     * @dev Internal function to transfer ownership of a given token ID to another address.

     * As opposed to transferFrom, this imposes no restrictions on msg.sender.

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _transferFrom(address from, address to, uint256 tokenId) internal {

        super._transferFrom(from, to, tokenId);



        _removeTokenFromOwnerEnumeration(from, tokenId);



        _addTokenToOwnerEnumeration(to, tokenId);

    }



    /**

     * @dev Internal function to mint a new token

     * Reverts if the given token ID already exists

     * @param to address the beneficiary that will own the minted token

     * @param tokenId uint256 ID of the token to be minted

     */

    function _mint(address to, uint256 tokenId) internal {

        super._mint(to, tokenId);



        _addTokenToOwnerEnumeration(to, tokenId);



        _addTokenToAllTokensEnumeration(tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(address owner, uint256 tokenId) internal {

        super._burn(owner, tokenId);



        _removeTokenFromOwnerEnumeration(owner, tokenId);

        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund

        _ownedTokensIndex[tokenId] = 0;



        _removeTokenFromAllTokensEnumeration(tokenId);

    }



    /**

     * @dev Gets the list of token IDs of the requested owner

     * @param owner address owning the tokens

     * @return uint256[] List of token IDs owned by the requested address

     */

    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {

        return _ownedTokens[owner];

    }



    /**

     * @dev Private function to add a token to this extension's ownership-tracking data structures.

     * @param to address representing the new owner of the given token ID

     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address

     */

    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {

        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;

        _ownedTokens[to].push(tokenId);

    }



    /**

     * @dev Private function to add a token to this extension's token tracking data structures.

     * @param tokenId uint256 ID of the token to be added to the tokens list

     */

    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {

        _allTokensIndex[tokenId] = _allTokens.length;

        _allTokens.push(tokenId);

    }



    /**

     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that

     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for

     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).

     * This has O(1) time complexity, but alters the order of the _ownedTokens array.

     * @param from address representing the previous owner of the given token ID

     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address

     */

    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {

        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and

        // then delete the last slot (swap and pop).



        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);

        uint256 tokenIndex = _ownedTokensIndex[tokenId];



        // When the token to delete is the last token, the swap operation is unnecessary

        if (tokenIndex != lastTokenIndex) {

            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];



            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token

            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index

        }



        // This also deletes the contents at the last position of the array

        _ownedTokens[from].length--;



        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by

        // lastTokenId, or just over the end of the array if the token was the last one).

    }



    /**

     * @dev Private function to remove a token from this extension's token tracking data structures.

     * This has O(1) time complexity, but alters the order of the _allTokens array.

     * @param tokenId uint256 ID of the token to be removed from the tokens list

     */

    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {

        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and

        // then delete the last slot (swap and pop).



        uint256 lastTokenIndex = _allTokens.length.sub(1);

        uint256 tokenIndex = _allTokensIndex[tokenId];



        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so

        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding

        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)

        uint256 lastTokenId = _allTokens[lastTokenIndex];



        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token

        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index



        // This also deletes the contents at the last position of the array

        _allTokens.length--;

        _allTokensIndex[tokenId] = 0;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol



pragma solidity ^0.5.2;





/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721Metadata is IERC721 {

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function tokenURI(uint256 tokenId) external view returns (string memory);

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol



pragma solidity ^0.5.2;









contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {

    // Token name

    string private _name;



    // Token symbol

    string private _symbol;



    // Optional mapping for token URIs

    mapping(uint256 => string) private _tokenURIs;



    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;

    /*

     * 0x5b5e139f ===

     *     bytes4(keccak256('name()')) ^

     *     bytes4(keccak256('symbol()')) ^

     *     bytes4(keccak256('tokenURI(uint256)'))

     */



    /**

     * @dev Constructor function

     */

    constructor (string memory name, string memory symbol) public {

        _name = name;

        _symbol = symbol;



        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721_METADATA);

    }



    /**

     * @dev Gets the token name

     * @return string representing the token name

     */

    function name() external view returns (string memory) {

        return _name;

    }



    /**

     * @dev Gets the token symbol

     * @return string representing the token symbol

     */

    function symbol() external view returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns an URI for a given token ID

     * Throws if the token ID does not exist. May return an empty string.

     * @param tokenId uint256 ID of the token to query

     */

    function tokenURI(uint256 tokenId) external view returns (string memory) {

        require(_exists(tokenId));

        return _tokenURIs[tokenId];

    }



    /**

     * @dev Internal function to set the token URI for a given token

     * Reverts if the token ID does not exist

     * @param tokenId uint256 ID of the token to set its URI

     * @param uri string URI to assign

     */

    function _setTokenURI(uint256 tokenId, string memory uri) internal {

        require(_exists(tokenId));

        _tokenURIs[tokenId] = uri;

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned by the msg.sender

     */

    function _burn(address owner, uint256 tokenId) internal {

        super._burn(owner, tokenId);



        // Clear metadata (if any)

        if (bytes(_tokenURIs[tokenId]).length != 0) {

            delete _tokenURIs[tokenId];

        }

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol



pragma solidity ^0.5.2;









/**

 * @title Full ERC721 Token

 * This implementation includes all the required and some optional functionality of the ERC721 standard

 * Moreover, it includes approve all functionality using operator terminology

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {

    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {

        // solhint-disable-previous-line no-empty-blocks

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/staking/stakeManager/StakingNFT.sol



pragma solidity ^0.5.2;









contract StakingNFT is ERC721Full, Ownable {

    constructor(string memory name, string memory symbol)

        public

        ERC721Full(name, symbol)

    {

        // solhint-disable-previous-line no-empty-blocks

    }



    function mint(address to, uint256 tokenId) public onlyOwner {

        require(

            balanceOf(to) == 0,

            "Validators MUST NOT own multiple stake position"

        );

        _mint(to, tokenId);

    }



    function burn(uint256 tokenId) public onlyOwner {

        _burn(tokenId);

    }



    function _transferFrom(address from, address to, uint256 tokenId) internal {

        require(

            balanceOf(to) == 0,

            "Validators MUST NOT own multiple stake position"

        );

        super._transferFrom(from, to, tokenId);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\StateSender.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-30

*/



/**

Matic network contracts

*/



pragma solidity ^0.5.2;





contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



contract StateSender is Ownable {

    using SafeMath for uint256;



    uint256 public counter;

    mapping(address => address) public registrations;



    event NewRegistration(

        address indexed user,

        address indexed sender,

        address indexed receiver

    );

    event RegistrationUpdated(

        address indexed user,

        address indexed sender,

        address indexed receiver

    );

    event StateSynced(

        uint256 indexed id,

        address indexed contractAddress,

        bytes data

    );



    modifier onlyRegistered(address receiver) {

        require(registrations[receiver] == msg.sender, "Invalid sender");

        _;

    }



    function syncState(address receiver, bytes calldata data)

        external

        onlyRegistered(receiver)

    {

        counter = counter.add(1);

        emit StateSynced(counter, receiver, data);

    }



    // register new contract for state sync

    function register(address sender, address receiver) public {

        require(

            isOwner() || registrations[receiver] == msg.sender,

            "StateSender.register: Not authorized to register"

        );

        registrations[receiver] = sender;

        if (registrations[receiver] == address(0)) {

            emit NewRegistration(msg.sender, sender, receiver);

        } else {

            emit RegistrationUpdated(msg.sender, sender, receiver);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\Strings.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev String operations.

 */

library Strings {

    bytes16 private constant alphabet = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = alphabet[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ValidatorShare.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-03-26

*/



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        _assertGovernance();

        _;

    }



    function _assertGovernance() private view {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;









contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.2;



/**

 * @title ERC20 interface

 * @dev see https://eips.ethereum.org/EIPS/eip-20

 */

interface IERC20 {

    function transfer(address to, uint256 value) external returns (bool);



    function approve(address spender, uint256 value) external returns (bool);



    function transferFrom(address from, address to, uint256 value) external returns (bool);



    function totalSupply() external view returns (uint256);



    function balanceOf(address who) external view returns (uint256);



    function allowance(address owner, address spender) external view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.5.2;







/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * https://eips.ethereum.org/EIPS/eip-20

 * Originally based on code by FirstBlood:

 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 *

 * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for

 * all accounts just by listening to said events. Note that this isn't required by the specification, and other

 * compliant implementations may not do it.

 */

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowed;



    uint256 private _totalSupply;



    /**

     * @dev Total number of tokens in existence

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev Gets the balance of the specified address.

     * @param owner The address to query the balance of.

     * @return A uint256 representing the amount owned by the passed address.

     */

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    /**

     * @dev Function to check the amount of tokens that an owner allowed to a spender.

     * @param owner address The address which owns the funds.

     * @param spender address The address which will spend the funds.

     * @return A uint256 specifying the amount of tokens still available for the spender.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    /**

     * @dev Transfer token to a specified address

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    /**

     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param spender The address which will spend the funds.

     * @param value The amount of tokens to be spent.

     */

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    /**

     * @dev Transfer tokens from one address to another.

     * Note that while this function emits an Approval event, this is not required as per the specification,

     * and other compliant implementations may not emit the event.

     * @param from address The address which you want to send tokens from

     * @param to address The address which you want to tr vbmansfer to

     * @param value uint256 the amount of tokens to be transferred

     */

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _transfer(from, to, value);

        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));

        return true;

    }



    /**

     * @dev Increase the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To increment

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param addedValue The amount of tokens to increase the allowance by.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Decrease the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param subtractedValue The amount of tokens to decrease the allowance by.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    /**

     * @dev Transfer token for a specified addresses

     * @param from The address to transfer from.

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    /**

     * @dev Internal function that mints an amount of the token and assigns it to

     * an account. This encapsulates the modification of balances such that the

     * proper events are emitted.

     * @param account The account that will receive the created tokens.

     * @param value The amount that will be created.

     */

    function _mint(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account.

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burn(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    /**

     * @dev Approve an address to spend another addresses' tokens.

     * @param owner The address that owns the tokens.

     * @param spender The address that will spend the tokens.

     * @param value The number of tokens that can be spent.

     */

    function _approve(address owner, address spender, uint256 value) internal {

        require(spender != address(0));

        require(owner != address(0));



        _allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account, deducting from the sender's allowance for said account. Uses the

     * internal burn function.

     * Emits an Approval event (reflecting the reduced allowance).

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burnFrom(address account, uint256 value) internal {

        _burn(account, value);

        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));

    }

}



// File: contracts/common/tokens/ERC20NonTradable.sol



pragma solidity ^0.5.2;





contract ERC20NonTradable is ERC20 {

    function _approve(

        address owner,

        address spender,

        uint256 value

    ) internal {

        revert("disabled");

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/staking/StakingInfo.sol



pragma solidity ^0.5.2;











// dummy interface to avoid cyclic dependency

contract IStakeManagerLocal {

    enum Status {Inactive, Active, Locked, Unstaked}



    struct Validator {

        uint256 amount;

        uint256 reward;

        uint256 activationEpoch;

        uint256 deactivationEpoch;

        uint256 jailTime;

        address signer;

        address contractAddress;

        Status status;

    }



    mapping(uint256 => Validator) public validators;

    bytes32 public accountStateRoot;

    uint256 public activeAmount; // delegation amount from validator contract

    uint256 public validatorRewards;



    function currentValidatorSetTotalStake() public view returns (uint256);



    // signer to Validator mapping

    function signerToValidator(address validatorAddress)

        public

        view

        returns (uint256);



    function isValidator(uint256 validatorId) public view returns (bool);

}



contract StakingInfo is Ownable {

    using SafeMath for uint256;

    mapping(uint256 => uint256) public validatorNonce;



    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.

    /// @param signer validator address.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param activationEpoch validator's first epoch as proposer.

    /// @param amount staking amount.

    /// @param total total staking amount.

    /// @param signerPubkey public key of the validator

    event Staked(

        address indexed signer,

        uint256 indexed validatorId,

        uint256 nonce,

        uint256 indexed activationEpoch,

        uint256 amount,

        uint256 total,

        bytes signerPubkey

    );



    /// @dev Emitted when validator unstakes in 'unstakeClaim()'

    /// @param user address of the validator.

    /// @param validatorId unique integer to identify a validator.

    /// @param amount staking amount.

    /// @param total total staking amount.

    event Unstaked(

        address indexed user,

        uint256 indexed validatorId,

        uint256 amount,

        uint256 total

    );



    /// @dev Emitted when validator unstakes in '_unstake()'.

    /// @param user address of the validator.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param deactivationEpoch last epoch for validator.

    /// @param amount staking amount.

    event UnstakeInit(

        address indexed user,

        uint256 indexed validatorId,

        uint256 nonce,

        uint256 deactivationEpoch,

        uint256 indexed amount

    );



    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param oldSigner old address of the validator.

    /// @param newSigner new address of the validator.

    /// @param signerPubkey public key of the validator.

    event SignerChange(

        uint256 indexed validatorId,

        uint256 nonce,

        address indexed oldSigner,

        address indexed newSigner,

        bytes signerPubkey

    );

    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);

    event Jailed(

        uint256 indexed validatorId,

        uint256 indexed exitEpoch,

        address indexed signer

    );

    event UnJailed(uint256 indexed validatorId, address indexed signer);

    event Slashed(uint256 indexed nonce, uint256 indexed amount);

    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);

    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);

    event ProposerBonusChange(

        uint256 newProposerBonus,

        uint256 oldProposerBonus

    );



    event RewardUpdate(uint256 newReward, uint256 oldReward);



    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param newAmount the updated stake amount.

    event StakeUpdate(

        uint256 indexed validatorId,

        uint256 indexed nonce,

        uint256 indexed newAmount

    );

    event ClaimRewards(

        uint256 indexed validatorId,

        uint256 indexed amount,

        uint256 indexed totalAmount

    );

    event StartAuction(

        uint256 indexed validatorId,

        uint256 indexed amount,

        uint256 indexed auctionAmount

    );

    event ConfirmAuction(

        uint256 indexed newValidatorId,

        uint256 indexed oldValidatorId,

        uint256 indexed amount

    );

    event TopUpFee(address indexed user, uint256 indexed fee);

    event ClaimFee(address indexed user, uint256 indexed fee);

    // Delegator events

    event ShareMinted(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens

    );

    event ShareBurned(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens

    );

    event DelegatorClaimedRewards(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed rewards

    );

    event DelegatorRestaked(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed totalStaked

    );

    event DelegatorUnstaked(

        uint256 indexed validatorId,

        address indexed user,

        uint256 amount

    );

    event UpdateCommissionRate(

        uint256 indexed validatorId,

        uint256 indexed newCommissionRate,

        uint256 indexed oldCommissionRate

    );



    Registry public registry;



    modifier onlyValidatorContract(uint256 validatorId) {

        address _contract;

        (, , , , , , _contract, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

        require(_contract == msg.sender,

        "Invalid sender, not validator");

        _;

    }



    modifier StakeManagerOrValidatorContract(uint256 validatorId) {

        address _contract;

        address _stakeManager = registry.getStakeManagerAddress();

        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(

            validatorId

        );

        require(_contract == msg.sender || _stakeManager == msg.sender,

        "Invalid sender, not stake manager or validator contract");

        _;

    }



    modifier onlyStakeManager() {

        require(registry.getStakeManagerAddress() == msg.sender,

        "Invalid sender, not stake manager");

        _;

    }

    modifier onlySlashingManager() {

        require(registry.getSlashingManagerAddress() == msg.sender,

        "Invalid sender, not slashing manager");

        _;

    }



    constructor(address _registry) public {

        registry = Registry(_registry);

    }



    function updateNonce(

        uint256[] calldata validatorIds,

        uint256[] calldata nonces

    ) external onlyOwner {

        require(validatorIds.length == nonces.length, "args length mismatch");



        for (uint256 i = 0; i < validatorIds.length; ++i) {

            validatorNonce[validatorIds[i]] = nonces[i];

        }

    } 



    function logStaked(

        address signer,

        bytes memory signerPubkey,

        uint256 validatorId,

        uint256 activationEpoch,

        uint256 amount,

        uint256 total

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit Staked(

            signer,

            validatorId,

            validatorNonce[validatorId],

            activationEpoch,

            amount,

            total,

            signerPubkey

        );

    }



    function logUnstaked(

        address user,

        uint256 validatorId,

        uint256 amount,

        uint256 total

    ) public onlyStakeManager {

        emit Unstaked(user, validatorId, amount, total);

    }



    function logUnstakeInit(

        address user,

        uint256 validatorId,

        uint256 deactivationEpoch,

        uint256 amount

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit UnstakeInit(

            user,

            validatorId,

            validatorNonce[validatorId],

            deactivationEpoch,

            amount

        );

    }



    function logSignerChange(

        uint256 validatorId,

        address oldSigner,

        address newSigner,

        bytes memory signerPubkey

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit SignerChange(

            validatorId,

            validatorNonce[validatorId],

            oldSigner,

            newSigner,

            signerPubkey

        );

    }



    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)

        public

        onlyStakeManager

    {

        emit Restaked(validatorId, amount, total);

    }



    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)

        public

        onlyStakeManager

    {

        emit Jailed(validatorId, exitEpoch, signer);

    }



    function logUnjailed(uint256 validatorId, address signer)

        public

        onlyStakeManager

    {

        emit UnJailed(validatorId, signer);

    }



    function logSlashed(uint256 nonce, uint256 amount)

        public

        onlySlashingManager

    {

        emit Slashed(nonce, amount);

    }



    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)

        public

        onlyStakeManager

    {

        emit ThresholdChange(newThreshold, oldThreshold);

    }



    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)

        public

        onlyStakeManager

    {

        emit DynastyValueChange(newDynasty, oldDynasty);

    }



    function logProposerBonusChange(

        uint256 newProposerBonus,

        uint256 oldProposerBonus

    ) public onlyStakeManager {

        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);

    }



    function logRewardUpdate(uint256 newReward, uint256 oldReward)

        public

        onlyStakeManager

    {

        emit RewardUpdate(newReward, oldReward);

    }



    function logStakeUpdate(uint256 validatorId)

        public

        StakeManagerOrValidatorContract(validatorId)

    {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit StakeUpdate(

            validatorId,

            validatorNonce[validatorId],

            totalValidatorStake(validatorId)

        );

    }



    function logClaimRewards(

        uint256 validatorId,

        uint256 amount,

        uint256 totalAmount

    ) public onlyStakeManager {

        emit ClaimRewards(validatorId, amount, totalAmount);

    }



    function logStartAuction(

        uint256 validatorId,

        uint256 amount,

        uint256 auctionAmount

    ) public onlyStakeManager {

        emit StartAuction(validatorId, amount, auctionAmount);

    }



    function logConfirmAuction(

        uint256 newValidatorId,

        uint256 oldValidatorId,

        uint256 amount

    ) public onlyStakeManager {

        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);

    }



    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {

        emit TopUpFee(user, fee);

    }



    function logClaimFee(address user, uint256 fee) public onlyStakeManager {

        emit ClaimFee(user, fee);

    }



    function getStakerDetails(uint256 validatorId)

        public

        view

        returns (

            uint256 amount,

            uint256 reward,

            uint256 activationEpoch,

            uint256 deactivationEpoch,

            address signer,

            uint256 _status

        )

    {

        IStakeManagerLocal stakeManager = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        );

        address _contract;

        IStakeManagerLocal.Status status;

        (

            amount,

            reward,

            activationEpoch,

            deactivationEpoch,

            ,

            signer,

            _contract,

            status

        ) = stakeManager.validators(validatorId);

        _status = uint256(status);

        if (_contract != address(0x0)) {

            reward += IStakeManagerLocal(_contract).validatorRewards();

        }

    }



    function totalValidatorStake(uint256 validatorId)

        public

        view

        returns (uint256 validatorStake)

    {

        address contractAddress;

        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

        if (contractAddress != address(0x0)) {

            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();

        }

    }



    function getAccountStateRoot()

        public

        view

        returns (bytes32 accountStateRoot)

    {

        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())

            .accountStateRoot();

    }



    function getValidatorContractAddress(uint256 validatorId)

        public

        view

        returns (address ValidatorContract)

    {

        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

    }



    // validator Share contract logging func

    function logShareMinted(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens

    ) public onlyValidatorContract(validatorId) {

        emit ShareMinted(validatorId, user, amount, tokens);

    }



    function logShareBurned(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens

    ) public onlyValidatorContract(validatorId) {

        emit ShareBurned(validatorId, user, amount, tokens);

    }



    function logDelegatorClaimRewards(

        uint256 validatorId,

        address user,

        uint256 rewards

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorClaimedRewards(validatorId, user, rewards);

    }



    function logDelegatorRestaked(

        uint256 validatorId,

        address user,

        uint256 totalStaked

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorRestaked(validatorId, user, totalStaked);

    }



    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)

        public

        onlyValidatorContract(validatorId)

    {

        emit DelegatorUnstaked(validatorId, user, amount);

    }



    // deprecated

    function logUpdateCommissionRate(

        uint256 validatorId,

        uint256 newCommissionRate,

        uint256 oldCommissionRate

    ) public onlyValidatorContract(validatorId) {

        emit UpdateCommissionRate(

            validatorId,

            newCommissionRate,

            oldCommissionRate

        );

    }

}



// File: contracts/common/mixin/Initializable.sol



pragma solidity ^0.5.2;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        inited = true;

        

        _;

    }

}



// File: contracts/staking/EventsHub.sol



pragma solidity ^0.5.2;







contract IStakeManagerEventsHub {

    struct Validator {

        uint256 amount;

        uint256 reward;

        uint256 activationEpoch;

        uint256 deactivationEpoch;

        uint256 jailTime;

        address signer;

        address contractAddress;

    }



    mapping(uint256 => Validator) public validators;

}



contract EventsHub is Initializable {

    Registry public registry;



    modifier onlyValidatorContract(uint256 validatorId) {

        address _contract;

        (, , , , , , _contract) = IStakeManagerEventsHub(registry.getStakeManagerAddress()).validators(validatorId);

        require(_contract == msg.sender, "not validator");

        _;

    }



    modifier onlyStakeManager() {

        require(registry.getStakeManagerAddress() == msg.sender,

        "Invalid sender, not stake manager");

        _;

    }



    function initialize(Registry _registry) external initializer {

        registry = _registry;

    }



    event ShareBurnedWithId(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens,

        uint256 nonce

    );



    function logShareBurnedWithId(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens,

        uint256 nonce

    ) public onlyValidatorContract(validatorId) {

        emit ShareBurnedWithId(validatorId, user, amount, tokens, nonce);

    }



    event DelegatorUnstakeWithId(

        uint256 indexed validatorId,

        address indexed user,

        uint256 amount,

        uint256 nonce

    );



    function logDelegatorUnstakedWithId(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 nonce

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorUnstakeWithId(validatorId, user, amount, nonce);

    }



    event RewardParams(

        uint256 rewardDecreasePerCheckpoint,

        uint256 maxRewardedCheckpoints,

        uint256 checkpointRewardDelta

    );



    function logRewardParams(

        uint256 rewardDecreasePerCheckpoint,

        uint256 maxRewardedCheckpoints,

        uint256 checkpointRewardDelta

    ) public onlyStakeManager {

        emit RewardParams(rewardDecreasePerCheckpoint, maxRewardedCheckpoints, checkpointRewardDelta);

    }



    event UpdateCommissionRate(

        uint256 indexed validatorId,

        uint256 indexed newCommissionRate,

        uint256 indexed oldCommissionRate

    );



    function logUpdateCommissionRate(

        uint256 validatorId,

        uint256 newCommissionRate,

        uint256 oldCommissionRate

    ) public onlyStakeManager {

        emit UpdateCommissionRate(

            validatorId,

            newCommissionRate,

            oldCommissionRate

        );

    }

}



// File: contracts/common/mixin/Lockable.sol



pragma solidity ^0.5.2;



contract Lockable {

    bool public locked;



    modifier onlyWhenUnlocked() {

        _assertUnlocked();

        _;

    }



    function _assertUnlocked() private view {

        require(!locked, "locked");

    }



    function lock() public {

        locked = true;

    }



    function unlock() public {

        locked = false;

    }

}



// File: contracts/common/mixin/OwnableLockable.sol



pragma solidity ^0.5.2;







contract OwnableLockable is Lockable, Ownable {

    function lock() public onlyOwner {

        super.lock();

    }



    function unlock() public onlyOwner {

        super.unlock();

    }

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity 0.5.17;



contract IStakeManager {

    // validator replacement

    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        uint[3][] calldata sigs

    ) external returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes calldata slashingInfoList) external returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function getRegistry() public view returns (address);



    function withdrawalDelay() public view returns (uint256);



    function delegatedAmount(uint256 validatorId) public view returns(uint256);



    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;



    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);



    function delegatorsReward(uint256 validatorId) public view returns(uint256);



    function dethroneAndStake(

        address auctionUser,

        uint256 heimdallFee,

        uint256 validatorId,

        uint256 auctionAmount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;

}



// File: contracts/staking/validatorShare/IValidatorShare.sol



pragma solidity 0.5.17;



// note this contract interface is only for stakeManager use

contract IValidatorShare {

    function withdrawRewards() public;



    function unstakeClaimTokens() public;



    function getLiquidRewards(address user) public view returns (uint256);

    

    function owner() public view returns (address);



    function restake() public returns(uint256, uint256);



    function unlock() external;



    function lock() external;



    function drain(

        address token,

        address payable destination,

        uint256 amount

    ) external;



    function slash(uint256 valPow, uint256 delegatedAmount, uint256 totalAmountToSlash) external returns (uint256);



    function updateDelegation(bool delegation) external;



    function migrateOut(address user, uint256 amount) external;



    function migrateIn(address user, uint256 amount) external;

}



// File: contracts/staking/validatorShare/ValidatorShare.sol



pragma solidity 0.5.17;





















contract ValidatorShare is IValidatorShare, ERC20NonTradable, OwnableLockable, Initializable {

    struct DelegatorUnbond {

        uint256 shares;

        uint256 withdrawEpoch;

    }



    uint256 constant EXCHANGE_RATE_PRECISION = 100;

    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares

    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10**29;

    uint256 constant MAX_COMMISION_RATE = 100;

    uint256 constant REWARD_PRECISION = 10**25;



    StakingInfo public stakingLogger;

    IStakeManager public stakeManager;

    uint256 public validatorId;

    uint256 public validatorRewards_deprecated;

    uint256 public commissionRate_deprecated;

    uint256 public lastCommissionUpdate_deprecated;

    uint256 public minAmount;



    uint256 public totalStake_deprecated;

    uint256 public rewardPerShare;

    uint256 public activeAmount;



    bool public delegation;



    uint256 public withdrawPool;

    uint256 public withdrawShares;



    mapping(address => uint256) amountStaked_deprecated; // deprecated, keep for foundation delegators

    mapping(address => DelegatorUnbond) public unbonds;

    mapping(address => uint256) public initalRewardPerShare;



    mapping(address => uint256) public unbondNonces;

    mapping(address => mapping(uint256 => DelegatorUnbond)) public unbonds_new;



    EventsHub public eventsHub;



    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address

    function initialize(

        uint256 _validatorId,

        address _stakingLogger,

        address _stakeManager

    ) external initializer {

        validatorId = _validatorId;

        stakingLogger = StakingInfo(_stakingLogger);

        stakeManager = IStakeManager(_stakeManager);

        _transferOwnership(_stakeManager);

        _getOrCacheEventsHub();



        minAmount = 10**18;

        delegation = true;

    }



    /**

        Public View Methods

    */



    function exchangeRate() public view returns (uint256) {

        uint256 totalShares = totalSupply();

        uint256 precision = _getRatePrecision();

        return totalShares == 0 ? precision : stakeManager.delegatedAmount(validatorId).mul(precision).div(totalShares);

    }



    function getTotalStake(address user) public view returns (uint256, uint256) {

        uint256 shares = balanceOf(user);

        uint256 rate = exchangeRate();

        if (shares == 0) {

            return (0, rate);

        }



        return (rate.mul(shares).div(_getRatePrecision()), rate);

    }



    function withdrawExchangeRate() public view returns (uint256) {

        uint256 precision = _getRatePrecision();

        if (validatorId < 8) {

            // fix of potentially broken withdrawals for future unbonding

            // foundation validators have no slashing enabled and thus we can return default exchange rate

            // because without slashing rate will stay constant

            return precision;

        }



        uint256 _withdrawShares = withdrawShares;

        return _withdrawShares == 0 ? precision : withdrawPool.mul(precision).div(_withdrawShares);

    }



    function getLiquidRewards(address user) public view returns (uint256) {

        return _calculateReward(user, getRewardPerShare());

    }



    function getRewardPerShare() public view returns (uint256) {

        return _calculateRewardPerShareWithRewards(stakeManager.delegatorsReward(validatorId));

    }



    /**

        Public Methods

     */



    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public returns(uint256 amountToDeposit) {

        _withdrawAndTransferReward(msg.sender);

        

        amountToDeposit = _buyShares(_amount, _minSharesToMint, msg.sender);

        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), "deposit failed");

        

        return amountToDeposit;

    }



    function restake() public returns(uint256, uint256) {

        address user = msg.sender;

        uint256 liquidReward = _withdrawReward(user);

        uint256 amountRestaked;



        require(liquidReward >= minAmount, "Too small rewards to restake");



        if (liquidReward != 0) {

            amountRestaked = _buyShares(liquidReward, 0, user);



            if (liquidReward > amountRestaked) {

                // return change to the user

                require(

                    stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, user),

                    "Insufficent rewards"

                );

                stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidReward - amountRestaked);

            }



            (uint256 totalStaked, ) = getTotalStake(user);

            stakingLogger.logDelegatorRestaked(validatorId, user, totalStaked);

        }

        

        return (amountRestaked, liquidReward);

    }



    function sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) public {

        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);



        DelegatorUnbond memory unbond = unbonds[msg.sender];

        unbond.shares = unbond.shares.add(_withdrawPoolShare);

        // refresh undond period

        unbond.withdrawEpoch = stakeManager.epoch();

        unbonds[msg.sender] = unbond;



        StakingInfo logger = stakingLogger;

        logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);

        logger.logStakeUpdate(validatorId);

    }



    function withdrawRewards() public {

        uint256 rewards = _withdrawAndTransferReward(msg.sender);

        require(rewards >= minAmount, "Too small rewards amount");

    }



    function migrateOut(address user, uint256 amount) external onlyOwner {

        _withdrawAndTransferReward(user);

        (uint256 totalStaked, uint256 rate) = getTotalStake(user);

        require(totalStaked >= amount, "Migrating too much");



        uint256 precision = _getRatePrecision();

        uint256 shares = amount.mul(precision).div(rate);

        _burn(user, shares);



        stakeManager.updateValidatorState(validatorId, -int256(amount));

        activeAmount = activeAmount.sub(amount);



        stakingLogger.logShareBurned(validatorId, user, amount, shares);

        stakingLogger.logStakeUpdate(validatorId);

        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);

    }



    function migrateIn(address user, uint256 amount) external onlyOwner {

        _withdrawAndTransferReward(user);

        _buyShares(amount, 0, user);

    }



    function unstakeClaimTokens() public {

        DelegatorUnbond memory unbond = unbonds[msg.sender];

        uint256 amount = _unstakeClaimTokens(unbond);

        delete unbonds[msg.sender];

        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, amount);

    }



    function slash(

        uint256 validatorStake,

        uint256 delegatedAmount,

        uint256 totalAmountToSlash

    ) external onlyOwner returns (uint256) {

        uint256 _withdrawPool = withdrawPool;

        uint256 delegationAmount = delegatedAmount.add(_withdrawPool);

        if (delegationAmount == 0) {

            return 0;

        }

        // total amount to be slashed from delegation pool (active + inactive)

        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(validatorStake.add(delegationAmount));

        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);



        // slash inactive pool

        uint256 stakeSlashed = _amountToSlash.sub(_amountToSlashWithdrawalPool);

        stakeManager.decreaseValidatorDelegatedAmount(validatorId, stakeSlashed);

        activeAmount = activeAmount.sub(stakeSlashed);



        withdrawPool = withdrawPool.sub(_amountToSlashWithdrawalPool);

        return _amountToSlash;

    }



    function updateDelegation(bool _delegation) external onlyOwner {

        delegation = _delegation;

    }



    function drain(

        address token,

        address payable destination,

        uint256 amount

    ) external onlyOwner {

        if (token == address(0x0)) {

            destination.transfer(amount);

        } else {

            require(ERC20(token).transfer(destination, amount), "Drain failed");

        }

    }



    /**

        New shares exit API

     */



    function sellVoucher_new(uint256 claimAmount, uint256 maximumSharesToBurn) public {

        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);



        uint256 unbondNonce = unbondNonces[msg.sender].add(1);



        DelegatorUnbond memory unbond = DelegatorUnbond({

            shares: _withdrawPoolShare,

            withdrawEpoch: stakeManager.epoch()

        });

        unbonds_new[msg.sender][unbondNonce] = unbond;

        unbondNonces[msg.sender] = unbondNonce;



        _getOrCacheEventsHub().logShareBurnedWithId(validatorId, msg.sender, claimAmount, shares, unbondNonce);

        stakingLogger.logStakeUpdate(validatorId);

    }



    function unstakeClaimTokens_new(uint256 unbondNonce) public {

        DelegatorUnbond memory unbond = unbonds_new[msg.sender][unbondNonce];

        uint256 amount = _unstakeClaimTokens(unbond);

        delete unbonds_new[msg.sender][unbondNonce];

        _getOrCacheEventsHub().logDelegatorUnstakedWithId(validatorId, msg.sender, amount, unbondNonce);

    }



    /**

        Private Methods

     */



    function _getOrCacheEventsHub() private returns(EventsHub) {

        EventsHub _eventsHub = eventsHub;

        if (_eventsHub == EventsHub(0x0)) {

            _eventsHub = EventsHub(Registry(stakeManager.getRegistry()).contractMap(keccak256("eventsHub")));

            eventsHub = _eventsHub;

        }

        return _eventsHub;

    }



    function _sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) private returns(uint256, uint256) {

        // first get how much staked in total and compare to target unstake amount

        (uint256 totalStaked, uint256 rate) = getTotalStake(msg.sender);

        require(totalStaked != 0 && totalStaked >= claimAmount, "Too much requested");



        // convert requested amount back to shares

        uint256 precision = _getRatePrecision();

        uint256 shares = claimAmount.mul(precision).div(rate);

        require(shares <= maximumSharesToBurn, "too much slippage");



        _withdrawAndTransferReward(msg.sender);



        _burn(msg.sender, shares);

        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));

        activeAmount = activeAmount.sub(claimAmount);



        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());

        withdrawPool = withdrawPool.add(claimAmount);

        withdrawShares = withdrawShares.add(_withdrawPoolShare);



        return (shares, _withdrawPoolShare);

    }



    function _unstakeClaimTokens(DelegatorUnbond memory unbond) private returns(uint256) {

        uint256 shares = unbond.shares;

        require(

            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,

            "Incomplete withdrawal period"

        );



        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());

        withdrawShares = withdrawShares.sub(shares);

        withdrawPool = withdrawPool.sub(_amount);



        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), "Insufficent rewards");



        return _amount;

    }



    function _getRatePrecision() private view returns (uint256) {

        // if foundation validator, use old precision

        if (validatorId < 8) {

            return EXCHANGE_RATE_PRECISION;

        }



        return EXCHANGE_RATE_HIGH_PRECISION;

    }



    function _calculateRewardPerShareWithRewards(uint256 accumulatedReward) private view returns (uint256) {

        uint256 _rewardPerShare = rewardPerShare;

        if (accumulatedReward != 0) {

            uint256 totalShares = totalSupply();

            

            if (totalShares != 0) {

                _rewardPerShare = _rewardPerShare.add(accumulatedReward.mul(REWARD_PRECISION).div(totalShares));

            }

        }



        return _rewardPerShare;

    }



    function _calculateReward(address user, uint256 _rewardPerShare) private view returns (uint256) {

        uint256 shares = balanceOf(user);

        if (shares == 0) {

            return 0;

        }



        uint256 _initialRewardPerShare = initalRewardPerShare[user];



        if (_initialRewardPerShare == _rewardPerShare) {

            return 0;

        }



        return _rewardPerShare.sub(_initialRewardPerShare).mul(shares).div(REWARD_PRECISION);

    }



    function _withdrawReward(address user) private returns (uint256) {

        uint256 _rewardPerShare = _calculateRewardPerShareWithRewards(

            stakeManager.withdrawDelegatorsReward(validatorId)

        );

        uint256 liquidRewards = _calculateReward(user, _rewardPerShare);

        

        rewardPerShare = _rewardPerShare;

        initalRewardPerShare[user] = _rewardPerShare;

        return liquidRewards;

    }



    function _withdrawAndTransferReward(address user) private returns (uint256) {

        uint256 liquidRewards = _withdrawReward(user);

        if (liquidRewards != 0) {

            require(stakeManager.transferFunds(validatorId, liquidRewards, user), "Insufficent rewards");

            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);

        }

        return liquidRewards;

    }



    function _buyShares(

        uint256 _amount,

        uint256 _minSharesToMint,

        address user

    ) private onlyWhenUnlocked returns (uint256) {

        require(delegation, "Delegation is disabled");



        uint256 rate = exchangeRate();

        uint256 precision = _getRatePrecision();

        uint256 shares = _amount.mul(precision).div(rate);

        require(shares >= _minSharesToMint, "Too much slippage");

        require(unbonds[user].shares == 0, "Ongoing exit");



        _mint(user, shares);



        // clamp amount of tokens in case resulted shares requires less tokens than anticipated

        _amount = rate.mul(shares).div(precision);



        stakeManager.updateValidatorState(validatorId, int256(_amount));

        activeAmount = activeAmount.add(_amount);



        StakingInfo logger = stakingLogger;

        logger.logShareMinted(validatorId, user, _amount, shares);

        logger.logStakeUpdate(validatorId);



        return _amount;

    }



    function _transfer(

        address from,

        address to,

        uint256 value

    ) internal {

        // get rewards for recipient 

        _withdrawAndTransferReward(to);

        // convert rewards to shares

        _withdrawAndTransferReward(from);

        // move shares to recipient

        super._transfer(from, to, value);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\ValidatorShareFactory.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-10-01

*/



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/misc/ProxyStorage.sol



pragma solidity ^0.5.2;





contract ProxyStorage is Ownable {

    address internal proxyTo;

}



// File: contracts/common/misc/ERCProxy.sol



/*

 * SPDX-License-Identitifer:    MIT

 */



pragma solidity ^0.5.2;



// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md



interface ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);

    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/misc/DelegateProxy.sol



pragma solidity ^0.5.2;







contract DelegateProxy is ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external view returns (address);



    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(

                sub(gas, 10000),

                _dst,

                add(_calldata, 0x20),

                mload(_calldata),

                0,

                0

            )

            let size := returndatasize



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }

}



// File: contracts/common/misc/UpgradableProxy.sol



pragma solidity ^0.5.2;





contract UpgradableProxy is DelegateProxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event OwnerUpdate(address _new, address _old);



    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");

    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");



    constructor(address _proxyTo) public {

        setOwner(msg.sender);

        setImplementation(_proxyTo);

    }



    function() external payable {

        // require(currentContract != 0, "If app code has not been set yet, do not call");

        // Todo: filter out some calls or handle in the end fallback

        delegatedFwd(loadImplementation(), msg.data);

    }



    modifier onlyProxyOwner() {

        require(loadOwner() == msg.sender, "NOT_OWNER");

        _;

    }



    function owner() external view returns(address) {

        return loadOwner();

    }



    function loadOwner() internal view returns(address) {

        address _owner;

        bytes32 position = OWNER_SLOT;

        assembly {

            _owner := sload(position)

        }

        return _owner;

    }



    function implementation() external view returns (address) {

        return loadImplementation();

    }



    function loadImplementation() internal view returns(address) {

        address _impl;

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            _impl := sload(position)

        }

        return _impl;

    }



    function transferOwnership(address newOwner) public onlyProxyOwner {

        require(newOwner != address(0), "ZERO_ADDRESS");

        emit OwnerUpdate(newOwner, loadOwner());

        setOwner(newOwner);

    }



    function setOwner(address newOwner) private {

        bytes32 position = OWNER_SLOT;

        assembly {

            sstore(position, newOwner)

        }

    }



    function updateImplementation(address _newProxyTo) public onlyProxyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");



        emit ProxyUpdated(_newProxyTo, loadImplementation());

        

        setImplementation(_newProxyTo);

    }



    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {

        updateImplementation(_newProxyTo);



        (bool success, bytes memory returnData) = address(this).call.value(msg.value)(data);

        require(success, string(returnData));

    }



    function setImplementation(address _newProxyTo) private {

        bytes32 position = IMPLEMENTATION_SLOT;

        assembly {

            sstore(position, _newProxyTo)

        }

    }

    

    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

        _;

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;









contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: contracts/staking/validatorShare/ValidatorShareProxy.sol



pragma solidity ^0.5.2;







contract ValidatorShareProxy is UpgradableProxy {

    constructor(address _registry) public UpgradableProxy(_registry) {}



    function loadImplementation() internal view returns (address) {

        return Registry(super.loadImplementation()).getValidatorShareAddress();

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.2;



/**

 * @title ERC20 interface

 * @dev see https://eips.ethereum.org/EIPS/eip-20

 */

interface IERC20 {

    function transfer(address to, uint256 value) external returns (bool);



    function approve(address spender, uint256 value) external returns (bool);



    function transferFrom(address from, address to, uint256 value) external returns (bool);



    function totalSupply() external view returns (uint256);



    function balanceOf(address who) external view returns (uint256);



    function allowance(address owner, address spender) external view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.5.2;







/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * https://eips.ethereum.org/EIPS/eip-20

 * Originally based on code by FirstBlood:

 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 *

 * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for

 * all accounts just by listening to said events. Note that this isn't required by the specification, and other

 * compliant implementations may not do it.

 */

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowed;



    uint256 private _totalSupply;



    /**

     * @dev Total number of tokens in existence

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev Gets the balance of the specified address.

     * @param owner The address to query the balance of.

     * @return A uint256 representing the amount owned by the passed address.

     */

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    /**

     * @dev Function to check the amount of tokens that an owner allowed to a spender.

     * @param owner address The address which owns the funds.

     * @param spender address The address which will spend the funds.

     * @return A uint256 specifying the amount of tokens still available for the spender.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    /**

     * @dev Transfer token to a specified address

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    /**

     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param spender The address which will spend the funds.

     * @param value The amount of tokens to be spent.

     */

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    /**

     * @dev Transfer tokens from one address to another.

     * Note that while this function emits an Approval event, this is not required as per the specification,

     * and other compliant implementations may not emit the event.

     * @param from address The address which you want to send tokens from

     * @param to address The address which you want to transfer to

     * @param value uint256 the amount of tokens to be transferred

     */

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _transfer(from, to, value);

        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));

        return true;

    }



    /**

     * @dev Increase the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To increment

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param addedValue The amount of tokens to increase the allowance by.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Decrease the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param subtractedValue The amount of tokens to decrease the allowance by.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    /**

     * @dev Transfer token for a specified addresses

     * @param from The address to transfer from.

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    /**

     * @dev Internal function that mints an amount of the token and assigns it to

     * an account. This encapsulates the modification of balances such that the

     * proper events are emitted.

     * @param account The account that will receive the created tokens.

     * @param value The amount that will be created.

     */

    function _mint(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account.

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burn(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    /**

     * @dev Approve an address to spend another addresses' tokens.

     * @param owner The address that owns the tokens.

     * @param spender The address that will spend the tokens.

     * @param value The number of tokens that can be spent.

     */

    function _approve(address owner, address spender, uint256 value) internal {

        require(spender != address(0));

        require(owner != address(0));



        _allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account, deducting from the sender's allowance for said account. Uses the

     * internal burn function.

     * Emits an Approval event (reflecting the reduced allowance).

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burnFrom(address account, uint256 value) internal {

        _burn(account, value);

        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));

    }

}



// File: contracts/common/tokens/ERC20NonTransferable.sol



pragma solidity ^0.5.2;





contract ERC20NonTransferable is ERC20 {

    function _transfer(

        address from,

        address to,

        uint256 value

    ) internal {

        revert("Disabled");

    }

}



// File: contracts/common/lib/BytesLib.sol



pragma solidity ^0.5.2;





library BytesLib {

    function concat(bytes memory _preBytes, bytes memory _postBytes)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;

        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(

                0x40,

                and(

                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),

                    not(31) // Round down to the nearest 32 bytes.

                )

            )

        }

        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start, uint256 _length)

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));

        bytes memory tempBytes;

        assembly {

            switch iszero(_length)

                case 0 {

                    // Get a location of some free memory and store it in tempBytes as

                    // Solidity does for memory variables.

                    tempBytes := mload(0x40)



                    // The first word of the slice result is potentially a partial

                    // word read from the original array. To read it, we calculate

                    // the length of that partial word and start copying that many

                    // bytes into the array. The first word we copy will start with

                    // data we don't care about, but the last `lengthmod` bytes will

                    // land at the beginning of the contents of the new array. When

                    // we're done copying, we overwrite the full first word with

                    // the actual length of the slice.

                    let lengthmod := and(_length, 31)



                    // The multiplication in the next line is necessary

                    // because when slicing multiples of 32 bytes (lengthmod == 0)

                    // the following copy loop was copying the origin's length

                    // and then ending prematurely not copying everything it should.

                    let mc := add(

                        add(tempBytes, lengthmod),

                        mul(0x20, iszero(lengthmod))

                    )

                    let end := add(mc, _length)



                    for {

                        // The multiplication in the next line has the same exact purpose

                        // as the one above.

                        let cc := add(

                            add(

                                add(_bytes, lengthmod),

                                mul(0x20, iszero(lengthmod))

                            ),

                            _start

                        )

                    } lt(mc, end) {

                        mc := add(mc, 0x20)

                        cc := add(cc, 0x20)

                    } {

                        mstore(mc, mload(cc))

                    }



                    mstore(tempBytes, _length)



                    //update free-memory pointer

                    //allocating the array padded to 32 bytes like the compiler does now

                    mstore(0x40, and(add(mc, 31), not(31)))

                }

                //if we want a zero-length slice let's just return a zero-length array

                default {

                    tempBytes := mload(0x40)

                    mstore(0x40, add(tempBytes, 0x20))

                }

        }



        return tempBytes;

    }



    // Pad a bytes array to 32 bytes

    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {

        // may underflow if bytes.length < 32. Hence using SafeMath.sub

        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));

        return concat(newBytes, _bytes);

    }



    function toBytes32(bytes memory b) internal pure returns (bytes32) {

        require(b.length >= 32, "Bytes array should atleast be 32 bytes");

        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {

            out |= bytes32(b[i] & 0xFF) >> (i * 8);

        }

        return out;

    }



    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {

        assembly {

            result := mload(add(b, 32))

        }

    }



    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {

        bytes memory b = new bytes(32);

        for (uint256 i = 0; i < 32; i++) {

            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));

        }

        return b;

    }



    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {

        _ret = new bytes(32);

        assembly {

            mstore(add(_ret, 32), _num)

        }

    }



    function toUint(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (uint256)

    {

        require(_bytes.length >= (_start + 32));

        uint256 tempUint;

        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }

        return tempUint;

    }



    function toAddress(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (address)

    {

        require(_bytes.length >= (_start + 20));

        address tempAddress;

        assembly {

            tempAddress := div(

                mload(add(add(_bytes, 0x20), _start)),

                0x1000000000000000000000000

            )

        }



        return tempAddress;

    }

}



// File: contracts/common/lib/ECVerify.sol



pragma solidity ^0.5.2;





library ECVerify {

    function ecrecovery(bytes32 hash, bytes memory sig)

        public

        pure

        returns (address)

    {

        bytes32 r;

        bytes32 s;

        uint8 v;



        if (sig.length != 65) {

            return address(0x0);

        }



        assembly {

            r := mload(add(sig, 32))

            s := mload(add(sig, 64))

            v := and(mload(add(sig, 65)), 255)

        }



        // https://github.com/ethereum/go-ethereum/issues/2053

        if (v < 27) {

            v += 27;

        }



        if (v != 27 && v != 28) {

            return address(0x0);

        }



        // get address out of hash and signature

        address result = ecrecover(hash, v, r, s);



        // ecrecover returns zero on error

        require(result != address(0x0));



        return result;

    }



    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)

        public

        pure

        returns (address)

    {

        // get address out of hash and signature

        address result = ecrecover(hash, v, r, s);



        // ecrecover returns zero on error

        require(result != address(0x0), "signature verification failed");



        return result;

    }



    function ecverify(bytes32 hash, bytes memory sig, address signer)

        public

        pure

        returns (bool)

    {

        return signer == ecrecovery(hash, sig);

    }

}



// File: contracts/staking/StakingInfo.sol



pragma solidity ^0.5.2;















// dummy interface to avoid cyclic dependency

contract IStakeManagerLocal {

    enum Status {Inactive, Active, Locked, Unstaked}



    struct Validator {

        uint256 amount;

        uint256 reward;

        uint256 activationEpoch;

        uint256 deactivationEpoch;

        uint256 jailTime;

        address signer;

        address contractAddress;

        Status status;

    }



    mapping(uint256 => Validator) public validators;

    bytes32 public accountStateRoot;

    uint256 public activeAmount; // delegation amount from validator contract

    uint256 public validatorRewards;



    function currentValidatorSetTotalStake() public view returns (uint256);



    // signer to Validator mapping

    function signerToValidator(address validatorAddress)

        public

        view

        returns (uint256);



    function isValidator(uint256 validatorId) public view returns (bool);

}





contract StakingInfo is Ownable {

    using SafeMath for uint256;

    mapping(uint256 => uint256) public validatorNonce;



    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.

    /// @param signer validator address.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param activationEpoch validator's first epoch as proposer.

    /// @param amount staking amount.

    /// @param total total staking amount.

    /// @param signerPubkey public key of the validator

    event Staked(

        address indexed signer,

        uint256 indexed validatorId,

        uint256 nonce,

        uint256 indexed activationEpoch,

        uint256 amount,

        uint256 total,

        bytes signerPubkey

    );



    /// @dev Emitted when validator unstakes in 'unstakeClaim()'

    /// @param user address of the validator.

    /// @param validatorId unique integer to identify a validator.

    /// @param amount staking amount.

    /// @param total total staking amount.

    event Unstaked(

        address indexed user,

        uint256 indexed validatorId,

        uint256 amount,

        uint256 total

    );



    /// @dev Emitted when validator unstakes in '_unstake()'.

    /// @param user address of the validator.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param deactivationEpoch last epoch for validator.

    /// @param amount staking amount.

    event UnstakeInit(

        address indexed user,

        uint256 indexed validatorId,

        uint256 nonce,

        uint256 deactivationEpoch,

        uint256 indexed amount

    );



    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param oldSigner old address of the validator.

    /// @param newSigner new address of the validator.

    /// @param signerPubkey public key of the validator.

    event SignerChange(

        uint256 indexed validatorId,

        uint256 nonce,

        address indexed oldSigner,

        address indexed newSigner,

        bytes signerPubkey

    );

    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);

    event Jailed(

        uint256 indexed validatorId,

        uint256 indexed exitEpoch,

        address indexed signer

    );

    event UnJailed(uint256 indexed validatorId, address indexed signer);

    event Slashed(uint256 indexed nonce, uint256 indexed amount);

    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);

    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);

    event ProposerBonusChange(

        uint256 newProposerBonus,

        uint256 oldProposerBonus

    );



    event RewardUpdate(uint256 newReward, uint256 oldReward);



    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().

    /// @param validatorId unique integer to identify a validator.

    /// @param nonce to synchronize the events in heimdal.

    /// @param newAmount the updated stake amount.

    event StakeUpdate(

        uint256 indexed validatorId,

        uint256 indexed nonce,

        uint256 indexed newAmount

    );

    event ClaimRewards(

        uint256 indexed validatorId,

        uint256 indexed amount,

        uint256 indexed totalAmount

    );

    event StartAuction(

        uint256 indexed validatorId,

        uint256 indexed amount,

        uint256 indexed auctionAmount

    );

    event ConfirmAuction(

        uint256 indexed newValidatorId,

        uint256 indexed oldValidatorId,

        uint256 indexed amount

    );

    event TopUpFee(address indexed user, uint256 indexed fee);

    event ClaimFee(address indexed user, uint256 indexed fee);

    // Delegator events

    event ShareMinted(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens

    );

    event ShareBurned(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed amount,

        uint256 tokens

    );

    event DelegatorClaimedRewards(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed rewards

    );

    event DelegatorRestaked(

        uint256 indexed validatorId,

        address indexed user,

        uint256 indexed totalStaked

    );

    event DelegatorUnstaked(

        uint256 indexed validatorId,

        address indexed user,

        uint256 amount

    );

    event UpdateCommissionRate(

        uint256 indexed validatorId,

        uint256 indexed newCommissionRate,

        uint256 indexed oldCommissionRate

    );



    Registry public registry;



    modifier onlyValidatorContract(uint256 validatorId) {

        address _contract;

        (, , , , , , _contract, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

        require(_contract == msg.sender,

        "Invalid sender, not validator");

        _;

    }



    modifier StakeManagerOrValidatorContract(uint256 validatorId) {

        address _contract;

        address _stakeManager = registry.getStakeManagerAddress();

        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(

            validatorId

        );

        require(_contract == msg.sender || _stakeManager == msg.sender,

        "Invalid sender, not stake manager or validator contract");

        _;

    }



    modifier onlyStakeManager() {

        require(registry.getStakeManagerAddress() == msg.sender,

        "Invalid sender, not stake manager");

        _;

    }

    modifier onlySlashingManager() {

        require(registry.getSlashingManagerAddress() == msg.sender,

        "Invalid sender, not slashing manager");

        _;

    }



    constructor(address _registry) public {

        registry = Registry(_registry);

    }



    function updateNonce(

        uint256[] calldata validatorIds,

        uint256[] calldata nonces

    ) external onlyOwner {

        require(validatorIds.length == nonces.length, "args length mismatch");



        for (uint256 i = 0; i < validatorIds.length; ++i) {

            validatorNonce[validatorIds[i]] = nonces[i];

        }

    } 



    function logStaked(

        address signer,

        bytes memory signerPubkey,

        uint256 validatorId,

        uint256 activationEpoch,

        uint256 amount,

        uint256 total

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit Staked(

            signer,

            validatorId,

            validatorNonce[validatorId],

            activationEpoch,

            amount,

            total,

            signerPubkey

        );

    }



    function logUnstaked(

        address user,

        uint256 validatorId,

        uint256 amount,

        uint256 total

    ) public onlyStakeManager {

        emit Unstaked(user, validatorId, amount, total);

    }



    function logUnstakeInit(

        address user,

        uint256 validatorId,

        uint256 deactivationEpoch,

        uint256 amount

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit UnstakeInit(

            user,

            validatorId,

            validatorNonce[validatorId],

            deactivationEpoch,

            amount

        );

    }



    function logSignerChange(

        uint256 validatorId,

        address oldSigner,

        address newSigner,

        bytes memory signerPubkey

    ) public onlyStakeManager {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit SignerChange(

            validatorId,

            validatorNonce[validatorId],

            oldSigner,

            newSigner,

            signerPubkey

        );

    }



    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)

        public

        onlyStakeManager

    {

        emit Restaked(validatorId, amount, total);

    }



    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)

        public

        onlyStakeManager

    {

        emit Jailed(validatorId, exitEpoch, signer);

    }



    function logUnjailed(uint256 validatorId, address signer)

        public

        onlyStakeManager

    {

        emit UnJailed(validatorId, signer);

    }



    function logSlashed(uint256 nonce, uint256 amount)

        public

        onlySlashingManager

    {

        emit Slashed(nonce, amount);

    }



    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)

        public

        onlyStakeManager

    {

        emit ThresholdChange(newThreshold, oldThreshold);

    }



    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)

        public

        onlyStakeManager

    {

        emit DynastyValueChange(newDynasty, oldDynasty);

    }



    function logProposerBonusChange(

        uint256 newProposerBonus,

        uint256 oldProposerBonus

    ) public onlyStakeManager {

        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);

    }



    function logRewardUpdate(uint256 newReward, uint256 oldReward)

        public

        onlyStakeManager

    {

        emit RewardUpdate(newReward, oldReward);

    }



    function logStakeUpdate(uint256 validatorId)

        public

        StakeManagerOrValidatorContract(validatorId)

    {

        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);

        emit StakeUpdate(

            validatorId,

            validatorNonce[validatorId],

            totalValidatorStake(validatorId)

        );

    }



    function logClaimRewards(

        uint256 validatorId,

        uint256 amount,

        uint256 totalAmount

    ) public onlyStakeManager {

        emit ClaimRewards(validatorId, amount, totalAmount);

    }



    function logStartAuction(

        uint256 validatorId,

        uint256 amount,

        uint256 auctionAmount

    ) public onlyStakeManager {

        emit StartAuction(validatorId, amount, auctionAmount);

    }



    function logConfirmAuction(

        uint256 newValidatorId,

        uint256 oldValidatorId,

        uint256 amount

    ) public onlyStakeManager {

        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);

    }



    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {

        emit TopUpFee(user, fee);

    }



    function logClaimFee(address user, uint256 fee) public onlyStakeManager {

        emit ClaimFee(user, fee);

    }



    function getStakerDetails(uint256 validatorId)

        public

        view

        returns (

            uint256 amount,

            uint256 reward,

            uint256 activationEpoch,

            uint256 deactivationEpoch,

            address signer,

            uint256 _status

        )

    {

        IStakeManagerLocal stakeManager = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        );

        address _contract;

        IStakeManagerLocal.Status status;

        (

            amount,

            reward,

            activationEpoch,

            deactivationEpoch,

            ,

            signer,

            _contract,

            status

        ) = stakeManager.validators(validatorId);

        _status = uint256(status);

        if (_contract != address(0x0)) {

            reward += IStakeManagerLocal(_contract).validatorRewards();

        }

    }



    function totalValidatorStake(uint256 validatorId)

        public

        view

        returns (uint256 validatorStake)

    {

        address contractAddress;

        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

        if (contractAddress != address(0x0)) {

            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();

        }

    }



    function getAccountStateRoot()

        public

        view

        returns (bytes32 accountStateRoot)

    {

        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())

            .accountStateRoot();

    }



    function getValidatorContractAddress(uint256 validatorId)

        public

        view

        returns (address ValidatorContract)

    {

        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(

            registry.getStakeManagerAddress()

        )

            .validators(validatorId);

    }



    // validator Share contract logging func

    function logShareMinted(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens

    ) public onlyValidatorContract(validatorId) {

        emit ShareMinted(validatorId, user, amount, tokens);

    }



    function logShareBurned(

        uint256 validatorId,

        address user,

        uint256 amount,

        uint256 tokens

    ) public onlyValidatorContract(validatorId) {

        emit ShareBurned(validatorId, user, amount, tokens);

    }



    function logDelegatorClaimRewards(

        uint256 validatorId,

        address user,

        uint256 rewards

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorClaimedRewards(validatorId, user, rewards);

    }



    function logDelegatorRestaked(

        uint256 validatorId,

        address user,

        uint256 totalStaked

    ) public onlyValidatorContract(validatorId) {

        emit DelegatorRestaked(validatorId, user, totalStaked);

    }



    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)

        public

        onlyValidatorContract(validatorId)

    {

        emit DelegatorUnstaked(validatorId, user, amount);

    }



    function logUpdateCommissionRate(

        uint256 validatorId,

        uint256 newCommissionRate,

        uint256 oldCommissionRate

    ) public onlyValidatorContract(validatorId) {

        emit UpdateCommissionRate(

            validatorId,

            newCommissionRate,

            oldCommissionRate

        );

    }

}



// File: contracts/common/mixin/Lockable.sol



pragma solidity ^0.5.2;



contract Lockable {

    bool public locked;



    modifier onlyWhenUnlocked() {

        _assertUnlocked();

        _;

    }



    function _assertUnlocked() private view {

        require(!locked, "locked");

    }



    function lock() public {

        locked = true;

    }



    function unlock() public {

        locked = false;

    }

}



// File: contracts/common/mixin/OwnableLockable.sol



pragma solidity ^0.5.2;







contract OwnableLockable is Lockable, Ownable {

    function lock() public onlyOwner {

        super.lock();

    }



    function unlock() public onlyOwner {

        super.unlock();

    }

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity ^0.5.2;





contract IStakeManager {

    // validator replacement

    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function stake(

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        bytes memory sigs

    ) public returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes memory slashingInfoList) public returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function withdrawalDelay() public view returns (uint256);

}



// File: contracts/staking/validatorShare/IValidatorShare.sol



pragma solidity ^0.5.2;



// note this contract interface is only for stakeManager use

contract IValidatorShare {

    function withdrawRewardsValidator() external returns (uint256);



    function addProposerBonus(uint256 _rewards, uint256 valStake) public;



    function withdrawRewards() public;



    function unstakeClaimTokens() public;



    function getLiquidRewards(address user) public view returns (uint256);

    

    function getActiveAmount() external view returns (uint256);



    function owner() public view returns (address);



    function restake() public;



    function updateRewards(

        uint256 _reward,

        uint256 _totalStake,

        uint256 validatorStake

    ) external returns (uint256);



    function unlockContract() external returns (uint256);



    function lockContract() external returns (uint256);



    function drain(

        address token,

        address payable destination,

        uint256 amount

    ) external;



    function slash(uint256 valPow, uint256 totalAmountToSlash) external returns (uint256);



    function updateDelegation(bool delegation) external;

}



// File: contracts/common/mixin/Initializable.sol



pragma solidity ^0.5.2;



contract Initializable {

    bool inited = false;



    modifier initializer() {

        require(!inited, "already inited");

        inited = true;

        

        _;

    }

}



// File: contracts/staking/validatorShare/ValidatorShare.sol



pragma solidity ^0.5.2;

















contract ValidatorShare is IValidatorShare, ERC20NonTransferable, OwnableLockable, Initializable {

    struct Delegator {

        uint256 shares;

        uint256 withdrawEpoch;

    }



    uint256 constant EXCHANGE_RATE_PRECISION = 100;

    uint256 constant MAX_COMMISION_RATE = 100;

    uint256 constant REWARD_PRECISION = 10**25;



    StakingInfo public stakingLogger;

    IStakeManager public stakeManager;

    uint256 public validatorId;

    uint256 public validatorRewards;

    uint256 public commissionRate;

    //last checkpoint where validator updated commission rate

    uint256 public lastCommissionUpdate;

    uint256 public minAmount = 10**18;



    uint256 public totalStake;

    uint256 public rewardPerShare;

    uint256 public activeAmount;

    bool public delegation = true;



    uint256 public withdrawPool;

    uint256 public withdrawShares;



    mapping(address => uint256) public amountStaked;

    mapping(address => Delegator) public delegators;

    mapping(address => uint256) public initalRewardPerShare;



    modifier onlyValidator() {

        require(stakeManager.ownerOf(validatorId) == msg.sender, "not validator");

        _;

    }



    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address

    function initialize(uint256 _validatorId, address _stakingLogger, address _stakeManager) external initializer  {

        validatorId = _validatorId;

        stakingLogger = StakingInfo(_stakingLogger);

        stakeManager = IStakeManager(_stakeManager);

        _transferOwnership(_stakeManager);



        minAmount = 10**18;

        delegation = true;

    }



    function updateCommissionRate(uint256 newCommissionRate) external onlyValidator {

        uint256 epoch = stakeManager.epoch();

        uint256 _lastCommissionUpdate = lastCommissionUpdate;



        require( // withdrawalDelay == dynasty

            (_lastCommissionUpdate.add(stakeManager.withdrawalDelay()) <= epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate

            "Commission rate update cooldown period"

        );



        require(newCommissionRate <= MAX_COMMISION_RATE, "Commission rate should be in range of 0-100");

        stakingLogger.logUpdateCommissionRate(validatorId, newCommissionRate, commissionRate);

        commissionRate = newCommissionRate;

        lastCommissionUpdate = epoch;

    }



    function updateRewards(uint256 reward, uint256 checkpointStakePower, uint256 validatorStake)

        external

        onlyOwner

        returns (uint256)

    {

        /**

        restaking is simply buying more shares of pool

        but those needs to be nonswapable/transferrable(to prevent https://en.wikipedia.org/wiki/Tragedy_of_the_commons)



        - calculate rewards for validator stake + delgation

        - keep the validator rewards aside

        - take the commission out

        - add rewards to pool rewards

        - returns total active stake for validator

        */

        uint256 combinedStakePower = validatorStake.add(activeAmount); // validator + delegation stake power

        uint256 rewards = combinedStakePower.mul(reward).div(checkpointStakePower);



        _updateRewards(rewards, validatorStake, combinedStakePower);

        return combinedStakePower;

    }



    function addProposerBonus(uint256 rewards, uint256 validatorStake) public onlyOwner {

        uint256 combinedStakePower = validatorStake.add(activeAmount);

        _updateRewards(rewards, validatorStake, combinedStakePower);

    }



    function _updateRewards(uint256 rewards, uint256 validatorStake, uint256 combinedStakePower) internal {

        uint256 _validatorRewards = validatorStake.mul(rewards).div(combinedStakePower);



        // add validator commission from delegation rewards

        if (commissionRate > 0) {

            _validatorRewards = _validatorRewards.add(

                rewards.sub(_validatorRewards).mul(commissionRate).div(MAX_COMMISION_RATE)

            );

        }



        validatorRewards = validatorRewards.add(_validatorRewards);



        uint256 delegatorsRewards = rewards.sub(_validatorRewards);

        uint256 totalShares = totalSupply();

        if (totalShares > 0) {

            rewardPerShare = rewardPerShare.add(

                delegatorsRewards.mul(REWARD_PRECISION).div(totalShares)

            );

        }

    }



    function withdrawRewardsValidator() external onlyOwner returns (uint256) {

        uint256 _validatorRewards = validatorRewards;

        validatorRewards = 0;

        return _validatorRewards;

    }



    function exchangeRate() public view returns (uint256) {

        uint256 totalShares = totalSupply();

        return

            totalShares == 0

                ? EXCHANGE_RATE_PRECISION

                : activeAmount.mul(EXCHANGE_RATE_PRECISION).div(totalShares);

    }



    function withdrawExchangeRate() public view returns (uint256) {

        uint256 _withdrawShares = withdrawShares;

        return

            _withdrawShares == 0

                ? EXCHANGE_RATE_PRECISION

                : withdrawPool.mul(EXCHANGE_RATE_PRECISION).div(_withdrawShares);

    }



    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public {

        _withdrawAndTransferReward();

        uint256 amountToDeposit = _buyShares(_amount, _minSharesToMint);

        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), "deposit failed");

    }



    function restake() public {

        uint256 liquidReward = _withdrawReward(msg.sender);

        require(liquidReward >= minAmount, "Too small rewards to restake");



        _buyShares(liquidReward, 0);



        stakingLogger.logDelegatorRestaked(validatorId, msg.sender, amountStaked[msg.sender]);

    }



    function _buyShares(uint256 _amount, uint256 _minSharesToMint) private onlyWhenUnlocked returns(uint256) {

        require(delegation, "Delegation is disabled");



        uint256 rate = exchangeRate();

        uint256 shares = _amount.mul(EXCHANGE_RATE_PRECISION).div(rate);

        require(shares >= _minSharesToMint, "Too much slippage");

        require(delegators[msg.sender].shares == 0, "Ongoing exit");



        _mint(msg.sender, shares);



        _amount = _amount.sub(_amount % rate.mul(shares).div(EXCHANGE_RATE_PRECISION));



        totalStake = totalStake.add(_amount);

        amountStaked[msg.sender] = amountStaked[msg.sender].add(_amount);



        activeAmount = activeAmount.add(_amount);

        stakeManager.updateValidatorState(validatorId, int256(_amount));



        StakingInfo logger = stakingLogger;

        logger.logShareMinted(validatorId, msg.sender, _amount, shares);

        logger.logStakeUpdate(validatorId);



        return _amount;

    }



    function sellVoucher(uint256 _minClaimAmount) public {

        uint256 shares = balanceOf(msg.sender);

        require(shares > 0, "Zero balance");



        uint256 rate = exchangeRate();

        uint256 _amount = rate.mul(shares).div(EXCHANGE_RATE_PRECISION);

        require(_amount >= _minClaimAmount, "Too much slippage");



        _withdrawAndTransferReward();

        _burn(msg.sender, shares);

        stakeManager.updateValidatorState(validatorId, -int256(_amount));



        activeAmount = activeAmount.sub(_amount);

        uint256 _withdrawPoolShare = _amount.mul(EXCHANGE_RATE_PRECISION).div(withdrawExchangeRate());



        withdrawPool = withdrawPool.add(_amount);

        withdrawShares = withdrawShares.add(_withdrawPoolShare);

        delegators[msg.sender] = Delegator({shares: _withdrawPoolShare, withdrawEpoch: stakeManager.epoch()});

        amountStaked[msg.sender] = 0;



        StakingInfo logger = stakingLogger;

        logger.logShareBurned(validatorId, msg.sender, _amount, shares);

        logger.logStakeUpdate(validatorId);

    }



    function _withdrawReward(address user) private returns(uint256) {

        uint256 liquidRewards = getLiquidRewards(user);

        initalRewardPerShare[user] = rewardPerShare;

        return liquidRewards;

    }



    function _withdrawAndTransferReward() private returns(uint256) {

        uint256 liquidRewards = _withdrawReward(msg.sender);

        if (liquidRewards > 0) {

            require(stakeManager.transferFunds(validatorId, liquidRewards, msg.sender), "Insufficent rewards");

            stakingLogger.logDelegatorClaimRewards(validatorId, msg.sender, liquidRewards);

        }

        return liquidRewards;

    }



    function withdrawRewards() public {

        uint256 rewards = _withdrawAndTransferReward();

        require(rewards >= minAmount, "Too small rewards amount");

    }



    function getLiquidRewards(address user) public view returns (uint256) {

        uint256 shares = balanceOf(user);

        if (shares == 0) {

            return 0;

        }



        return rewardPerShare.sub(initalRewardPerShare[user]).mul(shares).div(REWARD_PRECISION);

    }



    function unstakeClaimTokens() public {

        Delegator storage delegator = delegators[msg.sender];



        uint256 shares = delegator.shares;

        require(

            delegator.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,

            "Incomplete withdrawal period"

        );



        uint256 _amount = withdrawExchangeRate().mul(shares).div(EXCHANGE_RATE_PRECISION);

        withdrawShares = withdrawShares.sub(shares);

        withdrawPool = withdrawPool.sub(_amount);



        totalStake = totalStake.sub(_amount);



        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), "Insufficent rewards");

        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, _amount);

        delete delegators[msg.sender];

    }



    function slash(uint256 valPow, uint256 totalAmountToSlash) external onlyOwner returns (uint256) {

        uint256 _withdrawPool = withdrawPool;

        uint256 delegationAmount = activeAmount.add(_withdrawPool);

        if (delegationAmount == 0) {

            return 0;

        }

        // total amount to be slashed from delegation pool (active + inactive)

        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(valPow.add(delegationAmount));

        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);



        // slash inactive pool

        withdrawPool = _withdrawPool.sub(_amountToSlashWithdrawalPool);

        activeAmount = activeAmount.sub(_amountToSlash.sub(_amountToSlashWithdrawalPool));

        return _amountToSlash;

    }



    function updateDelegation(bool _delegation) external onlyOwner {

        delegation = _delegation;

    }



    function drain(

        address token,

        address payable destination,

        uint256 amount

    ) external onlyOwner {

        if (token == address(0x0)) {

            destination.transfer(amount);

        } else {

            require(ERC20(token).transfer(destination, amount), "Drain failed");

        }

    }



    function getActiveAmount() external view returns(uint256) {

        return activeAmount;

    }



    function unlockContract() external onlyOwner returns (uint256) {

        unlock();

        return activeAmount;

    }



    function lockContract() external onlyOwner returns (uint256) {

        lock();

        return activeAmount;

    }

}



// File: contracts/staking/validatorShare/ValidatorShareFactory.sol



pragma solidity ^0.5.2;







contract ValidatorShareFactory {

    /**

    - factory to create new validatorShare contracts

   */

    function create(uint256 validatorId, address loggerAddress, address registry) public returns (address) {

        ValidatorShareProxy proxy = new ValidatorShareProxy(registry);



        proxy.transferOwnership(msg.sender);



        address proxyAddr = address(proxy);

        (bool success, bytes memory data) = proxyAddr.call.gas(gasleft())(

            abi.encodeWithSelector(

                ValidatorShare(proxyAddr).initialize.selector, 

                validatorId, 

                loggerAddress, 

                msg.sender

            )

        );

        require(success, string(data));



        return proxyAddr;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\WithdrawManager.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-10-07

*/



// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.2;



/**

 * @title ERC20 interface

 * @dev see https://eips.ethereum.org/EIPS/eip-20

 */

interface IERC20 {

    function transfer(address to, uint256 value) external returns (bool);



    function approve(address spender, uint256 value) external returns (bool);



    function transferFrom(address from, address to, uint256 value) external returns (bool);



    function totalSupply() external view returns (uint256);



    function balanceOf(address who) external view returns (uint256);



    function allowance(address owner, address spender) external view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.5.2;







/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * https://eips.ethereum.org/EIPS/eip-20

 * Originally based on code by FirstBlood:

 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 *

 * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for

 * all accounts just by listening to said events. Note that this isn't required by the specification, and other

 * compliant implementations may not do it.

 */

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowed;



    uint256 private _totalSupply;



    /**

     * @dev Total number of tokens in existence

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev Gets the balance of the specified address.

     * @param owner The address to query the balance of.

     * @return A uint256 representing the amount owned by the passed address.

     */

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    /**

     * @dev Function to check the amount of tokens that an owner allowed to a spender.

     * @param owner address The address which owns the funds.

     * @param spender address The address which will spend the funds.

     * @return A uint256 specifying the amount of tokens still available for the spender.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    /**

     * @dev Transfer token to a specified address

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    /**

     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param spender The address which will spend the funds.

     * @param value The amount of tokens to be spent.

     */

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    /**

     * @dev Transfer tokens from one address to another.

     * Note that while this function emits an Approval event, this is not required as per the specification,

     * and other compliant implementations may not emit the event.

     * @param from address The address which you want to send tokens from

     * @param to address The address which you want to transfer to

     * @param value uint256 the amount of tokens to be transferred

     */

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _transfer(from, to, value);

        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));

        return true;

    }



    /**

     * @dev Increase the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To increment

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param addedValue The amount of tokens to increase the allowance by.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Decrease the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param subtractedValue The amount of tokens to decrease the allowance by.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    /**

     * @dev Transfer token for a specified addresses

     * @param from The address to transfer from.

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    /**

     * @dev Internal function that mints an amount of the token and assigns it to

     * an account. This encapsulates the modification of balances such that the

     * proper events are emitted.

     * @param account The account that will receive the created tokens.

     * @param value The amount that will be created.

     */

    function _mint(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account.

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burn(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    /**

     * @dev Approve an address to spend another addresses' tokens.

     * @param owner The address that owns the tokens.

     * @param spender The address that will spend the tokens.

     * @param value The number of tokens that can be spent.

     */

    function _approve(address owner, address spender, uint256 value) internal {

        require(spender != address(0));

        require(owner != address(0));



        _allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account, deducting from the sender's allowance for said account. Uses the

     * internal burn function.

     * Emits an Approval event (reflecting the reduced allowance).

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burnFrom(address account, uint256 value) internal {

        _burn(account, value);

        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));

    }

}



// File: openzeppelin-solidity/contracts/introspection/IERC165.sol



pragma solidity ^0.5.2;



/**

 * @title IERC165

 * @dev https://eips.ethereum.org/EIPS/eip-165

 */

interface IERC165 {

    /**

     * @notice Query if a contract implements an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @dev Interface identification is specified in ERC-165. This function

     * uses less than 30,000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol



pragma solidity ^0.5.2;





/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    function balanceOf(address owner) public view returns (uint256 balance);

    function ownerOf(uint256 tokenId) public view returns (address owner);



    function approve(address to, uint256 tokenId) public;

    function getApproved(uint256 tokenId) public view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) public;

    function isApprovedForAll(address owner, address operator) public view returns (bool);



    function transferFrom(address from, address to, uint256 tokenId) public;

    function safeTransferFrom(address from, address to, uint256 tokenId) public;



    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol



pragma solidity ^0.5.2;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract IERC721Receiver {

    /**

     * @notice Handle the receipt of an NFT

     * @dev The ERC721 smart contract calls this function on the recipient

     * after a `safeTransfer`. This function MUST return the function selector,

     * otherwise the caller will revert the transaction. The selector to be

     * returned can be obtained as `this.onERC721Received.selector`. This

     * function MAY throw to revert and reject the transfer.

     * Note: the ERC721 contract address is always the message sender.

     * @param operator The address which called `safeTransferFrom` function

     * @param from The address which previously owned the token

     * @param tokenId The NFT identifier which is being transferred

     * @param data Additional data with no specified format

     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)

    public returns (bytes4);

}



// File: openzeppelin-solidity/contracts/utils/Address.sol



pragma solidity ^0.5.2;



/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



// File: openzeppelin-solidity/contracts/drafts/Counters.sol



pragma solidity ^0.5.2;





/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids

 *

 * Include with `using Counters for Counters.Counter;`

 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath

 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never

 * directly accessed.

 */

library Counters {

    using SafeMath for uint256;



    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        counter._value += 1;

    }



    function decrement(Counter storage counter) internal {

        counter._value = counter._value.sub(1);

    }

}



// File: openzeppelin-solidity/contracts/introspection/ERC165.sol



pragma solidity ^0.5.2;





/**

 * @title ERC165

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract ERC165 is IERC165 {

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /*

     * 0x01ffc9a7 ===

     *     bytes4(keccak256('supportsInterface(bytes4)'))

     */



    /**

     * @dev a mapping of interface id to whether or not it's supported

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    /**

     * @dev A contract implementing SupportsInterfaceWithLookup

     * implement ERC165 itself

     */

    constructor () internal {

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev implement supportsInterface(bytes4) using a lookup table

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev internal method for registering an interface

     */

    function _registerInterface(bytes4 interfaceId) internal {

        require(interfaceId != 0xffffffff);

        _supportedInterfaces[interfaceId] = true;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol



pragma solidity ^0.5.2;















/**

 * @title ERC721 Non-Fungible Token Standard basic implementation

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721 is ERC165, IERC721 {

    using SafeMath for uint256;

    using Address for address;

    using Counters for Counters.Counter;



    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;



    // Mapping from token ID to owner

    mapping (uint256 => address) private _tokenOwner;



    // Mapping from token ID to approved address

    mapping (uint256 => address) private _tokenApprovals;



    // Mapping from owner to number of owned token

    mapping (address => Counters.Counter) private _ownedTokensCount;



    // Mapping from owner to operator approvals

    mapping (address => mapping (address => bool)) private _operatorApprovals;



    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /*

     * 0x80ac58cd ===

     *     bytes4(keccak256('balanceOf(address)')) ^

     *     bytes4(keccak256('ownerOf(uint256)')) ^

     *     bytes4(keccak256('approve(address,uint256)')) ^

     *     bytes4(keccak256('getApproved(uint256)')) ^

     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^

     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^

     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))

     */



    constructor () public {

        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721);

    }



    /**

     * @dev Gets the balance of the specified address

     * @param owner address to query the balance of

     * @return uint256 representing the amount owned by the passed address

     */

    function balanceOf(address owner) public view returns (uint256) {

        require(owner != address(0));

        return _ownedTokensCount[owner].current();

    }



    /**

     * @dev Gets the owner of the specified token ID

     * @param tokenId uint256 ID of the token to query the owner of

     * @return address currently marked as the owner of the given token ID

     */

    function ownerOf(uint256 tokenId) public view returns (address) {

        address owner = _tokenOwner[tokenId];

        require(owner != address(0));

        return owner;

    }



    /**

     * @dev Approves another address to transfer the given token ID

     * The zero address indicates there is no approved address.

     * There can only be one approved address per token at a given time.

     * Can only be called by the token owner or an approved operator.

     * @param to address to be approved for the given token ID

     * @param tokenId uint256 ID of the token to be approved

     */

    function approve(address to, uint256 tokenId) public {

        address owner = ownerOf(tokenId);

        require(to != owner);

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));



        _tokenApprovals[tokenId] = to;

        emit Approval(owner, to, tokenId);

    }



    /**

     * @dev Gets the approved address for a token ID, or zero if no address set

     * Reverts if the token ID does not exist.

     * @param tokenId uint256 ID of the token to query the approval of

     * @return address currently approved for the given token ID

     */

    function getApproved(uint256 tokenId) public view returns (address) {

        require(_exists(tokenId));

        return _tokenApprovals[tokenId];

    }



    /**

     * @dev Sets or unsets the approval of a given operator

     * An operator is allowed to transfer all tokens of the sender on their behalf

     * @param to operator address to set the approval

     * @param approved representing the status of the approval to be set

     */

    function setApprovalForAll(address to, bool approved) public {

        require(to != msg.sender);

        _operatorApprovals[msg.sender][to] = approved;

        emit ApprovalForAll(msg.sender, to, approved);

    }



    /**

     * @dev Tells whether an operator is approved by a given owner

     * @param owner owner address which you want to query the approval of

     * @param operator operator address which you want to query the approval of

     * @return bool whether the given operator is approved by the given owner

     */

    function isApprovedForAll(address owner, address operator) public view returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    /**

     * @dev Transfers the ownership of a given token ID to another address

     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function transferFrom(address from, address to, uint256 tokenId) public {

        require(_isApprovedOrOwner(msg.sender, tokenId));



        _transferFrom(from, to, tokenId);

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) public {

        safeTransferFrom(from, to, tokenId, "");

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes data to send along with a safe transfer check

     */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {

        transferFrom(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data));

    }



    /**

     * @dev Returns whether the specified token exists

     * @param tokenId uint256 ID of the token to query the existence of

     * @return bool whether the token exists

     */

    function _exists(uint256 tokenId) internal view returns (bool) {

        address owner = _tokenOwner[tokenId];

        return owner != address(0);

    }



    /**

     * @dev Returns whether the given spender can transfer a given token ID

     * @param spender address of the spender to query

     * @param tokenId uint256 ID of the token to be transferred

     * @return bool whether the msg.sender is approved for the given token ID,

     * is an operator of the owner, or is the owner of the token

     */

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {

        address owner = ownerOf(tokenId);

        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));

    }



    /**

     * @dev Internal function to mint a new token

     * Reverts if the given token ID already exists

     * @param to The address that will own the minted token

     * @param tokenId uint256 ID of the token to be minted

     */

    function _mint(address to, uint256 tokenId) internal {

        require(to != address(0));

        require(!_exists(tokenId));



        _tokenOwner[tokenId] = to;

        _ownedTokensCount[to].increment();



        emit Transfer(address(0), to, tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead.

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(address owner, uint256 tokenId) internal {

        require(ownerOf(tokenId) == owner);



        _clearApproval(tokenId);



        _ownedTokensCount[owner].decrement();

        _tokenOwner[tokenId] = address(0);



        emit Transfer(owner, address(0), tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(uint256 tokenId) internal {

        _burn(ownerOf(tokenId), tokenId);

    }



    /**

     * @dev Internal function to transfer ownership of a given token ID to another address.

     * As opposed to transferFrom, this imposes no restrictions on msg.sender.

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _transferFrom(address from, address to, uint256 tokenId) internal {

        require(ownerOf(tokenId) == from);

        require(to != address(0));



        _clearApproval(tokenId);



        _ownedTokensCount[from].decrement();

        _ownedTokensCount[to].increment();



        _tokenOwner[tokenId] = to;



        emit Transfer(from, to, tokenId);

    }



    /**

     * @dev Internal function to invoke `onERC721Received` on a target address

     * The call is not executed if the target address is not a contract

     * @param from address representing the previous owner of the given token ID

     * @param to target address that will receive the tokens

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes optional data to send along with the call

     * @return bool whether the call correctly returned the expected magic value

     */

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)

        internal returns (bool)

    {

        if (!to.isContract()) {

            return true;

        }



        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);

        return (retval == _ERC721_RECEIVED);

    }



    /**

     * @dev Private function to clear current approval of a given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _clearApproval(uint256 tokenId) private {

        if (_tokenApprovals[tokenId] != address(0)) {

            _tokenApprovals[tokenId] = address(0);

        }

    }

}



// File: openzeppelin-solidity/contracts/math/Math.sol



pragma solidity ^0.5.2;



/**

 * @title Math

 * @dev Assorted math operations

 */

library Math {

    /**

     * @dev Returns the largest of two numbers.

     */

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    /**

     * @dev Returns the smallest of two numbers.

     */

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    /**

     * @dev Calculates the average of two numbers. Since these are integers,

     * averages of an even and odd number cannot be represented, and will be

     * rounded down.

     */

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b) / 2 can overflow, so we distribute

        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

    }

}



// File: solidity-rlp/contracts/RLPReader.sol



/*

* @author Hamdi Allam hamdi.allam97@gmail.com

* Please reach out with any questions or concerns

*/

pragma solidity ^0.5.0;



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START  = 0xb8;

    uint8 constant LIST_SHORT_START   = 0xc0;

    uint8 constant LIST_LONG_START    = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint len;

        uint memPtr;

    }



    struct Iterator {

        RLPItem item;   // Item that's being iterated over.

        uint nextPtr;   // Position of the next item in the list.

    }



    /*

    * @dev Returns the next element in the iteration. Reverts if it has not next element.

    * @param self The iterator.

    * @return The next element in the iteration.

    */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint ptr = self.nextPtr;

        uint itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

    * @dev Returns true if the iteration has more elements.

    * @param self The iterator.

    * @return true if the iteration has more elements.

    */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

    * @dev Create an iterator. Reverts if item is not a list.

    * @param self The RLP item.

    * @return An 'Iterator' over the item.

    */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

    * @param item RLP encoded bytes

    */

    function rlpLen(RLPItem memory item) internal pure returns (uint) {

        return item.len;

    }



    /*

    * @param item RLP encoded bytes

    */

    function payloadLen(RLPItem memory item) internal pure returns (uint) {

        return item.len - _payloadOffset(item.memPtr);

    }



    /*

    * @param item RLP encoded list in bytes

    */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint dataLen;

        for (uint i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr); 

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START)

            return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        

        uint ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint result;

        uint memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        return result == 0 ? false : true;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint) {

        require(item.len > 0 && item.len <= 33);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset;



        uint result;

        uint memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint) {

        // one byte prefix

        require(item.len == 33);



        uint result;

        uint memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        uint offset = _payloadOffset(item.memPtr);

        uint len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

    * Private Helpers

    */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint) {

        if (item.len == 0) return 0;



        uint count = 0;

        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

           currPtr = currPtr + _itemLength(currPtr); // skip over an item

           count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint memPtr) private pure returns (uint) {

        uint itemLen;

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START)

            itemLen = 1;

        

        else if (byte0 < STRING_LONG_START)

            itemLen = byte0 - STRING_SHORT_START + 1;



        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte

                

                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } 



        else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint memPtr) private pure returns (uint) {

        uint byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) 

            return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))

            return 1;

        else if (byte0 < LIST_SHORT_START)  // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else

            return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

    * @param src Pointer to source

    * @param dest Pointer to destination

    * @param len Amount of memory to copy from the source

    */

    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: contracts/common/lib/Merkle.sol



pragma solidity ^0.5.2;



library Merkle {

    function checkMembership(

        bytes32 leaf,

        uint256 index,

        bytes32 rootHash,

        bytes memory proof

    ) internal pure returns (bool) {

        require(proof.length % 32 == 0, "Invalid proof length");

        uint256 proofHeight = proof.length / 32;

        // Proof of size n means, height of the tree is n+1.

        // In a tree of height n+1, max #leafs possible is 2 ^ n

        require(index < 2 ** proofHeight, "Leaf index is too big");



        bytes32 proofElement;

        bytes32 computedHash = leaf;

        for (uint256 i = 32; i <= proof.length; i += 32) {

            assembly {

                proofElement := mload(add(proof, i))

            }



            if (index % 2 == 0) {

                computedHash = keccak256(

                    abi.encodePacked(computedHash, proofElement)

                );

            } else {

                computedHash = keccak256(

                    abi.encodePacked(proofElement, computedHash)

                );

            }



            index = index / 2;

        }

        return computedHash == rootHash;

    }

}



// File: contracts/common/lib/MerklePatriciaProof.sol



/*

 * @title MerklePatriciaVerifier

 * @author Sam Mayo (sammayo888@gmail.com)

 *

 * @dev Library for verifing merkle patricia proofs.

 */

pragma solidity ^0.5.2;





library MerklePatriciaProof {

    /*

   * @dev Verifies a merkle patricia proof.

   * @param value The terminating value in the trie.

   * @param encodedPath The path in the trie leading to value.

   * @param rlpParentNodes The rlp encoded stack of nodes.

   * @param root The root hash of the trie.

   * @return The boolean validity of the proof.

   */

    function verify(

        bytes memory value,

        bytes memory encodedPath,

        bytes memory rlpParentNodes,

        bytes32 root

    ) internal pure returns (bool) {

        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);

        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);



        bytes memory currentNode;

        RLPReader.RLPItem[] memory currentNodeList;



        bytes32 nodeKey = root;

        uint256 pathPtr = 0;



        bytes memory path = _getNibbleArray(encodedPath);

        if (path.length == 0) {

            return false;

        }



        for (uint256 i = 0; i < parentNodes.length; i++) {

            if (pathPtr > path.length) {

                return false;

            }



            currentNode = RLPReader.toRlpBytes(parentNodes[i]);

            if (nodeKey != keccak256(currentNode)) {

                return false;

            }

            currentNodeList = RLPReader.toList(parentNodes[i]);



            if (currentNodeList.length == 17) {

                if (pathPtr == path.length) {

                    if (

                        keccak256(RLPReader.toBytes(currentNodeList[16])) ==

                        keccak256(value)

                    ) {

                        return true;

                    } else {

                        return false;

                    }

                }



                uint8 nextPathNibble = uint8(path[pathPtr]);

                if (nextPathNibble > 16) {

                    return false;

                }

                nodeKey = bytes32(

                    RLPReader.toUintStrict(currentNodeList[nextPathNibble])

                );

                pathPtr += 1;

            } else if (currentNodeList.length == 2) {

                uint256 traversed = _nibblesToTraverse(

                    RLPReader.toBytes(currentNodeList[0]),

                    path,

                    pathPtr

                );

                if (pathPtr + traversed == path.length) {

                    //leaf node

                    if (

                        keccak256(RLPReader.toBytes(currentNodeList[1])) ==

                        keccak256(value)

                    ) {

                        return true;

                    } else {

                        return false;

                    }

                }



                //extension node

                if (traversed == 0) {

                    return false;

                }



                pathPtr += traversed;

                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));

            } else {

                return false;

            }

        }

    }



    function _nibblesToTraverse(

        bytes memory encodedPartialPath,

        bytes memory path,

        uint256 pathPtr

    ) private pure returns (uint256) {

        uint256 len;

        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath

        // and slicedPath have elements that are each one hex character (1 nibble)

        bytes memory partialPath = _getNibbleArray(encodedPartialPath);

        bytes memory slicedPath = new bytes(partialPath.length);



        // pathPtr counts nibbles in path

        // partialPath.length is a number of nibbles

        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {

            bytes1 pathNibble = path[i];

            slicedPath[i - pathPtr] = pathNibble;

        }



        if (keccak256(partialPath) == keccak256(slicedPath)) {

            len = partialPath.length;

        } else {

            len = 0;

        }

        return len;

    }



    // bytes b must be hp encoded

    function _getNibbleArray(bytes memory b)

        private

        pure

        returns (bytes memory)

    {

        bytes memory nibbles;

        if (b.length > 0) {

            uint8 offset;

            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));

            if (hpNibble == 1 || hpNibble == 3) {

                nibbles = new bytes(b.length * 2 - 1);

                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);

                nibbles[0] = oddNibble;

                offset = 1;

            } else {

                nibbles = new bytes(b.length * 2 - 2);

                offset = 0;

            }



            for (uint256 i = offset; i < nibbles.length; i++) {

                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);

            }

        }

        return nibbles;

    }



    function _getNthNibbleOfBytes(uint256 n, bytes memory str)

        private

        pure

        returns (bytes1)

    {

        return

            bytes1(

                n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10

            );

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/lib/PriorityQueue.sol



pragma solidity ^0.5.2;







/**

 * @title PriorityQueue

 * @dev A priority queue implementation.

 */

contract PriorityQueue is Ownable {

    using SafeMath for uint256;



    uint256[] heapList;

    uint256 public currentSize;



    constructor() public {

        heapList = [0];

    }



    /**

  * @dev Inserts an element into the priority queue.

  * @param _priority Priority to insert.

  * @param _value Some additional value.

  */

    function insert(uint256 _priority, uint256 _value) public onlyOwner {

        uint256 element = (_priority << 128) | _value;

        heapList.push(element);

        currentSize = currentSize.add(1);

        _percUp(currentSize);

    }



    /**

  * @dev Returns the top element of the heap.

  * @return The smallest element in the priority queue.

  */

    function getMin() public view returns (uint256, uint256) {

        return _splitElement(heapList[1]);

    }



    /**

  * @dev Deletes the top element of the heap and shifts everything up.

  * @return The smallest element in the priorty queue.

  */

    function delMin() public onlyOwner returns (uint256, uint256) {

        uint256 retVal = heapList[1];

        heapList[1] = heapList[currentSize];

        delete heapList[currentSize];

        currentSize = currentSize.sub(1);

        _percDown(1);

        heapList.length = heapList.length.sub(1);

        return _splitElement(retVal);

    }



    /**

  * @dev Determines the minimum child of a given node in the tree.

  * @param _index Index of the node in the tree.

  * @return The smallest child node.

  */

    function _minChild(uint256 _index) private view returns (uint256) {

        if (_index.mul(2).add(1) > currentSize) {

            return _index.mul(2);

        } else {

            if (heapList[_index.mul(2)] < heapList[_index.mul(2).add(1)]) {

                return _index.mul(2);

            } else {

                return _index.mul(2).add(1);

            }

        }

    }



    /**

   * @dev Bubbles the element at some index up.

   */

    function _percUp(uint256 _index) private {

        uint256 index = _index;

        uint256 j = index;

        uint256 newVal = heapList[index];



        while (newVal < heapList[index.div(2)]) {

            heapList[index] = heapList[index.div(2)];

            index = index.div(2);

        }



        if (index != j) {

            heapList[index] = newVal;

        }

    }



    /**

   * @dev Bubbles the element at some index down.

   */

    function _percDown(uint256 _index) private {

        uint256 index = _index;

        uint256 j = index;

        uint256 newVal = heapList[index];

        uint256 mc = _minChild(index);

        while (mc <= currentSize && newVal > heapList[mc]) {

            heapList[index] = heapList[mc];

            index = mc;

            mc = _minChild(index);

        }



        if (index != j) {

            heapList[index] = newVal;

        }

    }



    /**

   * @dev Split an element into its priority and value.

   * @param _element Element to decode.

   * @return A tuple containing the priority and value.

   */

    function _splitElement(uint256 _element)

        private

        pure

        returns (uint256, uint256)

    {

        uint256 priority = _element >> 128;

        uint256 value = uint256(uint128(_element));

        return (priority, value);

    }

}



// File: contracts/common/lib/BytesLib.sol



pragma solidity ^0.5.2;





library BytesLib {

    function concat(bytes memory _preBytes, bytes memory _postBytes)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;

        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(

                0x40,

                and(

                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),

                    not(31) // Round down to the nearest 32 bytes.

                )

            )

        }

        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start, uint256 _length)

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));

        bytes memory tempBytes;

        assembly {

            switch iszero(_length)

                case 0 {

                    // Get a location of some free memory and store it in tempBytes as

                    // Solidity does for memory variables.

                    tempBytes := mload(0x40)



                    // The first word of the slice result is potentially a partial

                    // word read from the original array. To read it, we calculate

                    // the length of that partial word and start copying that many

                    // bytes into the array. The first word we copy will start with

                    // data we don't care about, but the last `lengthmod` bytes will

                    // land at the beginning of the contents of the new array. When

                    // we're done copying, we overwrite the full first word with

                    // the actual length of the slice.

                    let lengthmod := and(_length, 31)



                    // The multiplication in the next line is necessary

                    // because when slicing multiples of 32 bytes (lengthmod == 0)

                    // the following copy loop was copying the origin's length

                    // and then ending prematurely not copying everything it should.

                    let mc := add(

                        add(tempBytes, lengthmod),

                        mul(0x20, iszero(lengthmod))

                    )

                    let end := add(mc, _length)



                    for {

                        // The multiplication in the next line has the same exact purpose

                        // as the one above.

                        let cc := add(

                            add(

                                add(_bytes, lengthmod),

                                mul(0x20, iszero(lengthmod))

                            ),

                            _start

                        )

                    } lt(mc, end) {

                        mc := add(mc, 0x20)

                        cc := add(cc, 0x20)

                    } {

                        mstore(mc, mload(cc))

                    }



                    mstore(tempBytes, _length)



                    //update free-memory pointer

                    //allocating the array padded to 32 bytes like the compiler does now

                    mstore(0x40, and(add(mc, 31), not(31)))

                }

                //if we want a zero-length slice let's just return a zero-length array

                default {

                    tempBytes := mload(0x40)

                    mstore(0x40, add(tempBytes, 0x20))

                }

        }



        return tempBytes;

    }



    // Pad a bytes array to 32 bytes

    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {

        // may underflow if bytes.length < 32. Hence using SafeMath.sub

        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));

        return concat(newBytes, _bytes);

    }



    function toBytes32(bytes memory b) internal pure returns (bytes32) {

        require(b.length >= 32, "Bytes array should atleast be 32 bytes");

        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {

            out |= bytes32(b[i] & 0xFF) >> (i * 8);

        }

        return out;

    }



    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {

        assembly {

            result := mload(add(b, 32))

        }

    }



    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {

        bytes memory b = new bytes(32);

        for (uint256 i = 0; i < 32; i++) {

            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));

        }

        return b;

    }



    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {

        _ret = new bytes(32);

        assembly {

            mstore(add(_ret, 32), _num)

        }

    }



    function toUint(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (uint256)

    {

        require(_bytes.length >= (_start + 32));

        uint256 tempUint;

        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }

        return tempUint;

    }



    function toAddress(bytes memory _bytes, uint256 _start)

        internal

        pure

        returns (address)

    {

        require(_bytes.length >= (_start + 20));

        address tempAddress;

        assembly {

            tempAddress := div(

                mload(add(add(_bytes, 0x20), _start)),

                0x1000000000000000000000000

            )

        }



        return tempAddress;

    }

}



// File: contracts/common/lib/ExitPayloadReader.sol



pragma solidity 0.5.17;







library ExitPayloadReader {

  using RLPReader for bytes;

  using RLPReader for RLPReader.RLPItem;



  uint8 constant WORD_SIZE = 32;



  struct ExitPayload {

    RLPReader.RLPItem[] data;

  }



  struct Receipt {

    RLPReader.RLPItem[] data;

    bytes raw;

    uint256 logIndex;

  }



  struct Log {

    RLPReader.RLPItem data;

    RLPReader.RLPItem[] list;

  }



  struct LogTopics {

    RLPReader.RLPItem[] data;

  }



  function toExitPayload(bytes memory data)

        internal

        pure

        returns (ExitPayload memory)

    {

        RLPReader.RLPItem[] memory payloadData = data

            .toRlpItem()

            .toList();



        return ExitPayload(payloadData);

    }



    function copy(uint src, uint dest, uint len) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint mask = 256 ** (WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }



    function getHeaderNumber(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[0].toUint();

    }



    function getBlockProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[1].toBytes();

    }



    function getBlockNumber(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[2].toUint();

    }



    function getBlockTime(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[3].toUint();

    }



    function getTxRoot(ExitPayload memory payload) internal pure returns(bytes32) {

      return bytes32(payload.data[4].toUint());

    }



    function getReceiptRoot(ExitPayload memory payload) internal pure returns(bytes32) {

      return bytes32(payload.data[5].toUint());

    }



    function getReceipt(ExitPayload memory payload) internal pure returns(Receipt memory receipt) {

      receipt.raw = payload.data[6].toBytes();

      RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();



      if (receiptItem.isList()) {

          // legacy tx

          receipt.data = receiptItem.toList();

      } else {

          // pop first byte before parsting receipt

          bytes memory typedBytes = receipt.raw;

          bytes memory result = new bytes(typedBytes.length - 1);

          uint256 srcPtr;

          uint256 destPtr;

          assembly {

              srcPtr := add(33, typedBytes)

              destPtr := add(0x20, result)

          }



          copy(srcPtr, destPtr, result.length);

          receipt.data = result.toRlpItem().toList();

      }



      receipt.logIndex = getReceiptLogIndex(payload);

      return receipt;

    }



    function getReceiptProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[7].toBytes();

    }



    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[8].toBytes();

    }



    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[8].toUint();

    }



    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns(uint256) {

      return payload.data[9].toUint();

    }



    function getTx(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[10].toBytes();

    }



    function getTxProof(ExitPayload memory payload) internal pure returns(bytes memory) {

      return payload.data[11].toBytes();

    }

    

    // Receipt methods

    function toBytes(Receipt memory receipt) internal pure returns(bytes memory) {

        return receipt.raw;

    }



    function getLog(Receipt memory receipt) internal pure returns(Log memory) {

        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];

        return Log(logData, logData.toList());

    }



    // Log methods

    function getEmitter(Log memory log) internal pure returns(address) {

      return RLPReader.toAddress(log.list[0]);

    }



    function getTopics(Log memory log) internal pure returns(LogTopics memory) {

        return LogTopics(log.list[1].toList());

    }



    function getData(Log memory log) internal pure returns(bytes memory) {

        return log.list[2].toBytes();

    }



    function toRlpBytes(Log memory log) internal pure returns(bytes memory) {

      return log.data.toRlpBytes();

    }



    // LogTopics methods

    function getField(LogTopics memory topics, uint256 index) internal pure returns(RLPReader.RLPItem memory) {

      return topics.data[index];

    }

}



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;



interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        _assertGovernance();

        _;

    }



    function _assertGovernance() private view {

        require(

            msg.sender == address(governance),

            "Only governance contract is authorized"

        );

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;



contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;









contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: contracts/root/withdrawManager/ExitNFT.sol



pragma solidity ^0.5.2;







contract ExitNFT is ERC721 {

    Registry internal registry;



    modifier onlyWithdrawManager() {

        require(

            msg.sender == registry.getWithdrawManagerAddress(),

            "UNAUTHORIZED_WITHDRAW_MANAGER_ONLY"

        );

        _;

    }



    constructor(address _registry) public {

        registry = Registry(_registry);

    }



    function mint(address _owner, uint256 _tokenId)

        external

        onlyWithdrawManager

    {

        _mint(_owner, _tokenId);

    }



    function burn(uint256 _tokenId) external onlyWithdrawManager {

        _burn(_tokenId);

    }



    function exists(uint256 tokenId) public view returns (bool) {

        return _exists(tokenId);

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Holder.sol



pragma solidity ^0.5.2;





contract ERC721Holder is IERC721Receiver {

    function onERC721Received(address, address, uint256, bytes memory) public returns (bytes4) {

        return this.onERC721Received.selector;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol



pragma solidity ^0.5.2;









/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        require((value == 0) || (token.allowance(address(this), spender) == 0));

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must equal true).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves.



        // A Solidity high level call has three parts:

        //  1. The target address is checked to verify it contains contract code

        //  2. The call itself is made, and success asserted

        //  3. The return value is decoded, which in turn checks the size of the returned data.



        require(address(token).isContract());



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success);



        if (returndata.length > 0) { // Return data is optional

            require(abi.decode(returndata, (bool)));

        }

    }

}



// File: contracts/common/tokens/WETH.sol



pragma solidity ^0.5.2;





contract WETH is ERC20 {

    event Deposit(address indexed dst, uint256 wad);

    event Withdrawal(address indexed src, uint256 wad);



    function deposit() public payable;



    function withdraw(uint256 wad) public;



    function withdraw(uint256 wad, address user) public;

}



// File: contracts/root/depositManager/IDepositManager.sol



pragma solidity ^0.5.2;



interface IDepositManager {

    function depositEther() external payable;

    function transferAssets(

        address _token,

        address _user,

        uint256 _amountOrNFTId

    ) external;

    function depositERC20(address _token, uint256 _amount) external;

    function depositERC721(address _token, uint256 _tokenId) external;

}



// File: contracts/common/misc/ProxyStorage.sol



pragma solidity ^0.5.2;





contract ProxyStorage is Ownable {

    address internal proxyTo;

}



// File: contracts/common/mixin/ChainIdMixin.sol



pragma solidity ^0.5.2;



contract ChainIdMixin {

  bytes constant public networkId = hex"89";

  uint256 constant public CHAINID = 137;

}



// File: contracts/root/RootChainStorage.sol



pragma solidity ^0.5.2;











contract RootChainHeader {

    event NewHeaderBlock(

        address indexed proposer,

        uint256 indexed headerBlockId,

        uint256 indexed reward,

        uint256 start,

        uint256 end,

        bytes32 root

    );

    // housekeeping event

    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }

}





contract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {

    bytes32 public heimdallId;

    uint8 public constant VOTE_TYPE = 2;



    uint16 internal constant MAX_DEPOSITS = 10000;

    uint256 public _nextHeaderBlock = MAX_DEPOSITS;

    uint256 internal _blockDepositId = 1;

    mapping(uint256 => HeaderBlock) public headerBlocks;

    Registry internal registry;

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity 0.5.17;



contract IStakeManager {

    // validator replacement

    function startAuction(

        uint256 validatorId,

        uint256 amount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        uint[3][] calldata sigs

    ) external returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes calldata slashingInfoList) external returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function getRegistry() public view returns (address);



    function withdrawalDelay() public view returns (uint256);



    function delegatedAmount(uint256 validatorId) public view returns(uint256);



    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;



    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);



    function delegatorsReward(uint256 validatorId) public view returns(uint256);



    function dethroneAndStake(

        address auctionUser,

        uint256 heimdallFee,

        uint256 validatorId,

        uint256 auctionAmount,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;

}



// File: contracts/root/IRootChain.sol



pragma solidity ^0.5.2;





interface IRootChain {

    function slash() external;



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)

        external;

    

    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs)

        external;



    function getLastChildBlock() external view returns (uint256);



    function currentHeaderBlock() external view returns (uint256);

}



// File: contracts/root/RootChain.sol



pragma solidity ^0.5.2;

















contract RootChain is RootChainStorage, IRootChain {

    using SafeMath for uint256;

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    modifier onlyDepositManager() {

        require(msg.sender == registry.getDepositManagerAddress(), "UNAUTHORIZED_DEPOSIT_MANAGER_ONLY");

        _;

    }



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {

        revert();

    }



    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs) external {

        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi

            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));

        require(CHAINID == _borChainID, "Invalid bor chain id");



        require(_buildHeaderBlock(proposer, start, end, rootHash), "INCORRECT_HEADER_DATA");



        // check if it is better to keep it in local storage instead

        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());

        uint256 _reward = stakeManager.checkSignatures(

            end.sub(start).add(1),

            /**  

                prefix 01 to data 

                01 represents positive vote on data and 00 is negative vote

                malicious validator can try to send 2/3 on negative vote so 01 is appended

             */

            keccak256(abi.encodePacked(bytes(hex"01"), data)),

            accountHash,

            proposer,

            sigs

        );



        require(_reward != 0, "Invalid checkpoint");

        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);

        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);

        _blockDepositId = 1;

    }



    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {

        depositId = currentHeaderBlock().add(_blockDepositId);

        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)

        _blockDepositId = _blockDepositId.add(numDeposits);

        require(

            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed

            _blockDepositId <= MAX_DEPOSITS,

            "TOO_MANY_DEPOSITS"

        );

    }



    function getLastChildBlock() external view returns (uint256) {

        return headerBlocks[currentHeaderBlock()].end;

    }



    function slash() external {

        //TODO: future implementation

    }



    function currentHeaderBlock() public view returns (uint256) {

        return _nextHeaderBlock.sub(MAX_DEPOSITS);

    }



    function _buildHeaderBlock(

        address proposer,

        uint256 start,

        uint256 end,

        bytes32 rootHash

    ) private returns (bool) {

        uint256 nextChildBlock;

        /*

    The ID of the 1st header block is MAX_DEPOSITS.

    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0

    */

        if (_nextHeaderBlock > MAX_DEPOSITS) {

            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;

        }

        if (nextChildBlock != start) {

            return false;

        }



        HeaderBlock memory headerBlock = HeaderBlock({

            root: rootHash,

            start: nextChildBlock,

            end: end,

            createdAt: now,

            proposer: proposer

        });



        headerBlocks[_nextHeaderBlock] = headerBlock;

        return true;

    }



    // Housekeeping function. @todo remove later

    function setNextHeaderBlock(uint256 _value) public onlyOwner {

        require(_value % MAX_DEPOSITS == 0, "Invalid value");

        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {

            delete headerBlocks[i];

        }

        _nextHeaderBlock = _value;

        _blockDepositId = 1;

        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);

    }



    // Housekeeping function. @todo remove later

    function setHeimdallId(string memory _heimdallId) public onlyOwner {

        heimdallId = keccak256(abi.encodePacked(_heimdallId));

    }

}



// File: contracts/root/stateSyncer/StateSender.sol



pragma solidity ^0.5.2;







contract StateSender is Ownable {

    using SafeMath for uint256;



    uint256 public counter;

    mapping(address => address) public registrations;



    event NewRegistration(

        address indexed user,

        address indexed sender,

        address indexed receiver

    );

    event RegistrationUpdated(

        address indexed user,

        address indexed sender,

        address indexed receiver

    );

    event StateSynced(

        uint256 indexed id,

        address indexed contractAddress,

        bytes data

    );



    modifier onlyRegistered(address receiver) {

        require(registrations[receiver] == msg.sender, "Invalid sender");

        _;

    }



    function syncState(address receiver, bytes calldata data)

        external

        onlyRegistered(receiver)

    {

        counter = counter.add(1);

        emit StateSynced(counter, receiver, data);

    }



    // register new contract for state sync

    function register(address sender, address receiver) public {

        require(

            isOwner() || registrations[receiver] == msg.sender,

            "StateSender.register: Not authorized to register"

        );

        registrations[receiver] = sender;

        if (registrations[receiver] == address(0)) {

            emit NewRegistration(msg.sender, sender, receiver);

        } else {

            emit RegistrationUpdated(msg.sender, sender, receiver);

        }

    }

}



// File: contracts/common/mixin/Lockable.sol



pragma solidity ^0.5.2;



contract Lockable {

    bool public locked;



    modifier onlyWhenUnlocked() {

        _assertUnlocked();

        _;

    }



    function _assertUnlocked() private view {

        require(!locked, "locked");

    }



    function lock() public {

        locked = true;

    }



    function unlock() public {

        locked = false;

    }

}



// File: contracts/common/mixin/GovernanceLockable.sol



pragma solidity ^0.5.2;







contract GovernanceLockable is Lockable, Governable {

    constructor(address governance) public Governable(governance) {}



    function lock() public onlyGovernance {

        super.lock();

    }



    function unlock() public onlyGovernance {

        super.unlock();

    }

}



// File: contracts/root/depositManager/DepositManagerStorage.sol



pragma solidity ^0.5.2;















contract DepositManagerHeader {

    event NewDepositBlock(address indexed owner, address indexed token, uint256 amountOrNFTId, uint256 depositBlockId);

    event MaxErc20DepositUpdate(uint256 indexed oldLimit, uint256 indexed newLimit);



    struct DepositBlock {

        bytes32 depositHash;

        uint256 createdAt;

    }

}





contract DepositManagerStorage is ProxyStorage, GovernanceLockable, DepositManagerHeader {

    Registry public registry;

    RootChain public rootChain;

    StateSender public stateSender;



    mapping(uint256 => DepositBlock) public deposits;



    address public childChain;

    uint256 public maxErc20Deposit = 100 * (10**18);

}



// File: contracts/root/depositManager/DepositManager.sol



pragma solidity ^0.5.2;





























contract DepositManager is DepositManagerStorage, IDepositManager, ERC721Holder {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    modifier isTokenMapped(address _token) {

        require(registry.isTokenMapped(_token), "TOKEN_NOT_SUPPORTED");

        _;

    }



    modifier isPredicateAuthorized() {

        require(uint8(registry.predicates(msg.sender)) != 0, "Not a valid predicate");

        _;

    }



    constructor() public GovernanceLockable(address(0x0)) {}



    // deposit ETH by sending to this contract

    function() external payable {

        depositEther();

    }



    function updateMaxErc20Deposit(uint256 maxDepositAmount) public onlyGovernance {

        require(maxDepositAmount != 0);

        emit MaxErc20DepositUpdate(maxErc20Deposit, maxDepositAmount);

        maxErc20Deposit = maxDepositAmount;

    }



    function transferAssets(

        address _token,

        address _user,

        uint256 _amountOrNFTId

    ) external isPredicateAuthorized {

        address wethToken = registry.getWethTokenAddress();

        if (registry.isERC721(_token)) {

            IERC721(_token).transferFrom(address(this), _user, _amountOrNFTId);

        } else if (_token == wethToken) {

            WETH t = WETH(_token);

            t.withdraw(_amountOrNFTId, _user);

        } else {

            require(IERC20(_token).transfer(_user, _amountOrNFTId), "TRANSFER_FAILED");

        }

    }



    function depositERC20(address _token, uint256 _amount) external {

        depositERC20ForUser(_token, msg.sender, _amount);

    }



    function depositERC721(address _token, uint256 _tokenId) external {

        depositERC721ForUser(_token, msg.sender, _tokenId);

    }



    function depositBulk(

        address[] calldata _tokens,

        uint256[] calldata _amountOrTokens,

        address _user

    )

        external

        onlyWhenUnlocked // unlike other deposit functions, depositBulk doesn't invoke _safeCreateDepositBlock

    {

        require(_tokens.length == _amountOrTokens.length, "Invalid Input");

        uint256 depositId = rootChain.updateDepositId(_tokens.length);

        Registry _registry = registry;



        for (uint256 i = 0; i < _tokens.length; i++) {

            // will revert if token is not mapped

            if (_registry.isTokenMappedAndIsErc721(_tokens[i])) {

                _safeTransferERC721(msg.sender, _tokens[i], _amountOrTokens[i]);

            } else {

                IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amountOrTokens[i]);

            }



            _createDepositBlock(_user, _tokens[i], _amountOrTokens[i], depositId);

            depositId = depositId.add(1);

        }

    }



    /**

     * @dev Caches childChain and stateSender (frequently used variables) from registry

     */

    function updateChildChainAndStateSender() public {

        (address _childChain, address _stateSender) = registry.getChildChainAndStateSender();

        require(

            _stateSender != address(stateSender) || _childChain != childChain,

            "Atleast one of stateSender or childChain address should change"

        );

        childChain = _childChain;

        stateSender = StateSender(_stateSender);

    }



    function depositERC20ForUser(

        address _token,

        address _user,

        uint256 _amount

    ) public {

        require(_amount <= maxErc20Deposit, "exceed maximum deposit amount");

        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        _safeCreateDepositBlock(_user, _token, _amount);

    }



    function depositERC721ForUser(

        address _token,

        address _user,

        uint256 _tokenId

    ) public {

        require(registry.isTokenMappedAndIsErc721(_token), "not erc721");



        _safeTransferERC721(msg.sender, _token, _tokenId);

        _safeCreateDepositBlock(_user, _token, _tokenId);

    }



    // @todo: write depositEtherForUser

    function depositEther() public payable {

        address wethToken = registry.getWethTokenAddress();

        WETH t = WETH(wethToken);

        t.deposit.value(msg.value)();

        _safeCreateDepositBlock(msg.sender, wethToken, msg.value);

    }



    function _safeCreateDepositBlock(

        address _user,

        address _token,

        uint256 _amountOrToken

    ) internal onlyWhenUnlocked isTokenMapped(_token) {

        _createDepositBlock(

            _user,

            _token,

            _amountOrToken,

            rootChain.updateDepositId(1) /* returns _depositId */

        );

    }



    function _createDepositBlock(

        address _user,

        address _token,

        uint256 _amountOrToken,

        uint256 _depositId

    ) internal {

        deposits[_depositId] = DepositBlock(keccak256(abi.encodePacked(_user, _token, _amountOrToken)), now);

        stateSender.syncState(childChain, abi.encode(_user, _token, _amountOrToken, _depositId));

        emit NewDepositBlock(_user, _token, _amountOrToken, _depositId);

    }



    // Housekeeping function. @todo remove later

    function updateRootChain(address _rootChain) public onlyOwner {

        rootChain = RootChain(_rootChain);

    }



    function _safeTransferERC721(address _user, address _token, uint256 _tokenId) private {

        IERC721(_token).safeTransferFrom(_user, address(this), _tokenId);

    }

}



// File: contracts/common/lib/Common.sol



pragma solidity ^0.5.2;





library Common {

    function getV(bytes memory v, uint16 chainId) public pure returns (uint8) {

        if (chainId > 0) {

            return

                uint8(

                    BytesLib.toUint(BytesLib.leftPad(v), 0) - (chainId * 2) - 8

                );

        } else {

            return uint8(BytesLib.toUint(BytesLib.leftPad(v), 0));

        }

    }



    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.

    function isContract(address _addr) public view returns (bool) {

        uint256 length;

        assembly {

            //retrieve the size of the code on target address, this needs assembly

            length := extcodesize(_addr)

        }

        return (length > 0);

    }



    // convert bytes to uint8

    function toUint8(bytes memory _arg) public pure returns (uint8) {

        return uint8(_arg[0]);

    }



    function toUint16(bytes memory _arg) public pure returns (uint16) {

        return (uint16(uint8(_arg[0])) << 8) | uint16(uint8(_arg[1]));

    }

}



// File: contracts/common/lib/RLPEncode.sol



// Library for RLP encoding a list of bytes arrays.

// Modeled after ethereumjs/rlp (https://github.com/ethereumjs/rlp)

// [Very] modified version of Sam Mayo's library.

pragma solidity ^0.5.2;





library RLPEncode {

    // Encode an item (bytes memory)

    function encodeItem(bytes memory self)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory encoded;

        if (self.length == 1 && uint8(self[0] & 0xFF) < 0x80) {

            encoded = new bytes(1);

            encoded = self;

        } else {

            encoded = BytesLib.concat(encodeLength(self.length, 128), self);

        }

        return encoded;

    }



    // Encode a list of items

    function encodeList(bytes[] memory self)

        internal

        pure

        returns (bytes memory)

    {

        bytes memory encoded;

        for (uint256 i = 0; i < self.length; i++) {

            encoded = BytesLib.concat(encoded, encodeItem(self[i]));

        }

        return BytesLib.concat(encodeLength(encoded.length, 192), encoded);

    }



    // Hack to encode nested lists. If you have a list as an item passed here, included

    // pass = true in that index. E.g.

    // [item, list, item] --> pass = [false, true, false]

    // function encodeListWithPasses(bytes[] memory self, bool[] pass) internal pure returns (bytes memory) {

    //   bytes memory encoded;

    //   for (uint i=0; i < self.length; i++) {

    // 		if (pass[i] == true) {

    // 			encoded = BytesLib.concat(encoded, self[i]);

    // 		} else {

    // 			encoded = BytesLib.concat(encoded, encodeItem(self[i]));

    // 		}

    //   }

    //   return BytesLib.concat(encodeLength(encoded.length, 192), encoded);

    // }



    // Generate the prefix for an item or the entire list based on RLP spec

    function encodeLength(uint256 L, uint256 offset)

        internal

        pure

        returns (bytes memory)

    {

        if (L < 56) {

            bytes memory prefix = new bytes(1);

            prefix[0] = bytes1(uint8(L + offset));

            return prefix;

        } else {

            // lenLen is the length of the hex representation of the data length

            uint256 lenLen;

            uint256 i = 0x1;



            while (L / i != 0) {

                lenLen++;

                i *= 0x100;

            }



            bytes memory prefix0 = getLengthBytes(offset + 55 + lenLen);

            bytes memory prefix1 = getLengthBytes(L);

            return BytesLib.concat(prefix0, prefix1);

        }

    }



    function getLengthBytes(uint256 x) internal pure returns (bytes memory b) {

        // Figure out if we need 1 or two bytes to express the length.

        // 1 byte gets us to max 255

        // 2 bytes gets us to max 65535 (no payloads will be larger than this)

        uint256 nBytes = 1;

        if (x > 255) {

            nBytes = 2;

        }



        b = new bytes(nBytes);

        // Encode the length and return it

        for (uint256 i = 0; i < nBytes; i++) {

            b[i] = bytes1(uint8(x / (2**(8 * (nBytes - 1 - i)))));

        }

    }

}



// File: contracts/root/withdrawManager/WithdrawManagerStorage.sol



pragma solidity ^0.5.2;













contract ExitsDataStructure {

    struct Input {

        address utxoOwner;

        address predicate;

        address token;

    }



    struct PlasmaExit {

        uint256 receiptAmountOrNFTId;

        bytes32 txHash;

        address owner;

        address token;

        bool isRegularExit;

        address predicate;

        // Mapping from age of input to Input

        mapping(uint256 => Input) inputs;

    }

}





contract WithdrawManagerHeader is ExitsDataStructure {

    event Withdraw(uint256 indexed exitId, address indexed user, address indexed token, uint256 amount);



    event ExitStarted(

        address indexed exitor,

        uint256 indexed exitId,

        address indexed token,

        uint256 amount,

        bool isRegularExit

    );



    event ExitUpdated(uint256 indexed exitId, uint256 indexed age, address signer);

    event ExitPeriodUpdate(uint256 indexed oldExitPeriod, uint256 indexed newExitPeriod);



    event ExitCancelled(uint256 indexed exitId);

}





contract WithdrawManagerStorage is ProxyStorage, WithdrawManagerHeader {

    // 0.5 week = 7 * 86400 / 2 = 302400

    uint256 public HALF_EXIT_PERIOD = 302400;



    // Bonded exits collaterized at 0.1 ETH

    uint256 internal constant BOND_AMOUNT = 10**17;



    Registry internal registry;

    RootChain internal rootChain;



    mapping(uint128 => bool) isKnownExit;

    mapping(uint256 => PlasmaExit) public exits;

    // mapping with token => (owner => exitId) keccak(token+owner) keccak(token+owner+tokenId)

    mapping(bytes32 => uint256) public ownerExits;

    mapping(address => address) public exitsQueues;

    ExitNFT public exitNft;



    // ERC721, ERC20 and Weth transfers require 155000, 100000, 52000 gas respectively

    // Processing each exit in a while loop iteration requires ~52000 gas (@todo check if this changed)

    // uint32 constant internal ITERATION_GAS = 52000;



    // So putting an upper limit of 155000 + 52000 + leeway

    uint32 public ON_FINALIZE_GAS_LIMIT = 300000;



    uint256 public exitWindow;

}



// File: contracts/root/predicates/IPredicate.sol



pragma solidity ^0.5.2;

















interface IPredicate {

    /**

   * @notice Verify the deprecation of a state update

   * @param exit ABI encoded PlasmaExit data

   * @param inputUtxo ABI encoded Input UTXO data

   * @param challengeData RLP encoded data of the challenge reference tx that encodes the following fields

   * headerNumber Header block number of which the reference tx was a part of

   * blockProof Proof that the block header (in the child chain) is a leaf in the submitted merkle root

   * blockNumber Block number of which the reference tx is a part of

   * blockTime Reference tx block time

   * blocktxRoot Transactions root of block

   * blockReceiptsRoot Receipts root of block

   * receipt Receipt of the reference transaction

   * receiptProof Merkle proof of the reference receipt

   * branchMask Merkle proof branchMask for the receipt

   * logIndex Log Index to read from the receipt

   * tx Challenge transaction

   * txProof Merkle proof of the challenge tx

   * @return Whether or not the state is deprecated

   */

    function verifyDeprecation(

        bytes calldata exit,

        bytes calldata inputUtxo,

        bytes calldata challengeData

    ) external returns (bool);



    function interpretStateUpdate(bytes calldata state)

        external

        view

        returns (bytes memory);

    function onFinalizeExit(bytes calldata data) external;

}



contract PredicateUtils is ExitsDataStructure, ChainIdMixin {

    using RLPReader for RLPReader.RLPItem;



    // Bonded exits collaterized at 0.1 ETH

    uint256 private constant BOND_AMOUNT = 10**17;



    IWithdrawManager internal withdrawManager;

    IDepositManager internal depositManager;



    modifier onlyWithdrawManager() {

        require(

            msg.sender == address(withdrawManager),

            "ONLY_WITHDRAW_MANAGER"

        );

        _;

    }



    modifier isBondProvided() {

        require(msg.value == BOND_AMOUNT, "Invalid Bond amount");

        _;

    }



    function onFinalizeExit(bytes calldata data) external onlyWithdrawManager {

        (, address token, address exitor, uint256 tokenId) = decodeExitForProcessExit(

            data

        );

        depositManager.transferAssets(token, exitor, tokenId);

    }



    function sendBond() internal {

        address(uint160(address(withdrawManager))).transfer(BOND_AMOUNT);

    }



    function getAddressFromTx(RLPReader.RLPItem[] memory txList)

        internal

        pure

        returns (address signer, bytes32 txHash)

    {

        bytes[] memory rawTx = new bytes[](9);

        for (uint8 i = 0; i <= 5; i++) {

            rawTx[i] = txList[i].toBytes();

        }

        rawTx[6] = networkId;

        rawTx[7] = hex""; // [7] and [8] have something to do with v, r, s values

        rawTx[8] = hex"";



        txHash = keccak256(RLPEncode.encodeList(rawTx));

        signer = ecrecover(

            txHash,

            Common.getV(txList[6].toBytes(), Common.toUint16(networkId)),

            bytes32(txList[7].toUint()),

            bytes32(txList[8].toUint())

        );

    }



    function decodeExit(bytes memory data)

        internal

        pure

        returns (PlasmaExit memory)

    {

        (address owner, address token, uint256 amountOrTokenId, bytes32 txHash, bool isRegularExit) = abi

            .decode(data, (address, address, uint256, bytes32, bool));

        return

            PlasmaExit(

                amountOrTokenId,

                txHash,

                owner,

                token,

                isRegularExit,

                address(0) /* predicate value is not required */

            );

    }



    function decodeExitForProcessExit(bytes memory data)

        internal

        pure

        returns (uint256 exitId, address token, address exitor, uint256 tokenId)

    {

        (exitId, token, exitor, tokenId) = abi.decode(

            data,

            (uint256, address, address, uint256)

        );

    }



    function decodeInputUtxo(bytes memory data)

        internal

        pure

        returns (uint256 age, address signer, address predicate, address token)

    {

        (age, signer, predicate, token) = abi.decode(

            data,

            (uint256, address, address, address)

        );

    }



}



contract IErcPredicate is IPredicate, PredicateUtils {

    enum ExitType {Invalid, OutgoingTransfer, IncomingTransfer, Burnt}



    struct ExitTxData {

        uint256 amountOrToken;

        bytes32 txHash;

        address childToken;

        address signer;

        ExitType exitType;

    }



    struct ReferenceTxData {

        uint256 closingBalance;

        uint256 age;

        address childToken;

        address rootToken;

    }



    uint256 internal constant MAX_LOGS = 10;



    constructor(address _withdrawManager, address _depositManager) public {

        withdrawManager = IWithdrawManager(_withdrawManager);

        depositManager = IDepositManager(_depositManager);

    }

}



// File: contracts/root/withdrawManager/WithdrawManager.sol



pragma solidity ^0.5.2;



































contract WithdrawManager is WithdrawManagerStorage, IWithdrawManager {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;

    using Merkle for bytes32;



    using ExitPayloadReader for bytes;

    using ExitPayloadReader for ExitPayloadReader.ExitPayload;

    using ExitPayloadReader for ExitPayloadReader.Receipt;

    using ExitPayloadReader for ExitPayloadReader.Log;

    using ExitPayloadReader for ExitPayloadReader.LogTopics;



    modifier isBondProvided() {

        require(msg.value == BOND_AMOUNT, "Invalid Bond amount");

        _;

    }



    modifier isPredicateAuthorized() {

        require(registry.predicates(msg.sender) != Registry.Type.Invalid, "PREDICATE_NOT_AUTHORIZED");

        _;

    }



    modifier checkPredicateAndTokenMapping(address rootToken) {

        Registry.Type _type = registry.predicates(msg.sender);

        require(registry.rootToChildToken(rootToken) != address(0x0), "rootToken not supported");

        if (_type == Registry.Type.ERC20) {

            require(registry.isERC721(rootToken) == false, "Predicate supports only ERC20 tokens");

        } else if (_type == Registry.Type.ERC721) {

            require(registry.isERC721(rootToken) == true, "Predicate supports only ERC721 tokens");

        } else if (_type == Registry.Type.Custom) {} else {

            revert("PREDICATE_NOT_AUTHORIZED");

        }

        _;

    }



    /**

     * @dev Receive bond for bonded exits

     */

    function() external payable {}



    function createExitQueue(address token) external {

        require(msg.sender == address(registry), "UNAUTHORIZED_REGISTRY_ONLY");

        exitsQueues[token] = address(new PriorityQueue());

    }



    /**

     During coverage tests verifyInclusion fails co compile with "stack too deep" error.

     */

    struct VerifyInclusionVars {

        uint256 headerNumber;

        uint256 blockNumber;

        uint256 createdAt;

        uint256 branchMask;

        bytes32 txRoot;

        bytes32 receiptRoot;

        bytes branchMaskBytes;

    }



    /**

     * @dev Verify the inclusion of the receipt in the checkpoint

     * @param data RLP encoded data of the reference tx(s) that encodes the following fields for each tx

     * headerNumber Header block number of which the reference tx was a part of

     * blockProof Proof that the block header (in the child chain) is a leaf in the submitted merkle root

     * blockNumber Block number of which the reference tx is a part of

     * blockTime Reference tx block time

     * blocktxRoot Transactions root of block

     * blockReceiptsRoot Receipts root of block

     * receipt Receipt of the reference transaction

     * receiptProof Merkle proof of the reference receipt

     * branchMask Merkle proof branchMask for the receipt

     * logIndex Log Index to read from the receipt

     * @param offset offset in the data array

     * @param verifyTxInclusion Whether to also verify the inclusion of the raw tx in the txRoot

     * @return ageOfInput Measure of the position of the receipt and the log in the child chain

     */

    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    )

        external

        view

        returns (

            uint256 /* ageOfInput */

        )

    {

        ExitPayloadReader.ExitPayload memory payload = data.toExitPayload();

        VerifyInclusionVars memory vars;



        vars.headerNumber = payload.getHeaderNumber();

        vars.branchMaskBytes = payload.getBranchMaskAsBytes();

        require(vars.branchMaskBytes[0] == 0, "incorrect mask");

        vars.txRoot = payload.getTxRoot();

        vars.receiptRoot = payload.getReceiptRoot();

        require(

            MerklePatriciaProof.verify(

                payload.getReceipt().toBytes(),

                vars.branchMaskBytes,

                payload.getReceiptProof(),

                vars.receiptRoot

            ),

            "INVALID_RECEIPT_MERKLE_PROOF"

        );



        if (verifyTxInclusion) {

            require(

                MerklePatriciaProof.verify(

                    payload.getTx(),

                    vars.branchMaskBytes,

                    payload.getTxProof(), 

                    vars.txRoot

                ),

                "INVALID_TX_MERKLE_PROOF"

            );

        }



        vars.blockNumber = payload.getBlockNumber();

        vars.createdAt = checkBlockMembershipInCheckpoint(

            vars.blockNumber,

            payload.getBlockTime(),

            vars.txRoot,

            vars.receiptRoot,

            vars.headerNumber,

            payload.getBlockProof()

        );



        vars.branchMask = payload.getBranchMaskAsUint();

        require(

            vars.branchMask & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000 == 0,

            "Branch mask should be 32 bits"

        );

        // ageOfInput is denoted as

        // 1 reserve bit (see last 2 lines in comment)

        // 128 bits for exitableAt timestamp

        // 95 bits for child block number

        // 32 bits for receiptPos + logIndex * MAX_LOGS + oIndex

        // In predicates, the exitId will be evaluated by shifting the ageOfInput left by 1 bit

        // (Only in erc20Predicate) Last bit is to differentiate whether the sender or receiver of the in-flight tx is starting an exit

        return (getExitableAt(vars.createdAt) << 127) | (vars.blockNumber << 32) | vars.branchMask;

    }



    function startExitWithDepositedTokens(

        uint256 depositId,

        address token,

        uint256 amountOrToken

    ) external payable isBondProvided {

        // (bytes32 depositHash, uint256 createdAt) = getDepositManager().deposits(depositId);

        // require(keccak256(abi.encodePacked(msg.sender, token, amountOrToken)) == depositHash, "UNAUTHORIZED_EXIT");

        // uint256 ageOfInput = getExitableAt(createdAt) << 127 | (depositId % 10000 /* MAX_DEPOSITS */);

        // uint256 exitId = ageOfInput << 1;

        // address predicate = registry.isTokenMappedAndGetPredicate(token);

        // _addExitToQueue(

        //     msg.sender,

        //     token,

        //     amountOrToken,

        //     bytes32(0), /* txHash */

        //     false, /* isRegularExit */

        //     exitId,

        //     predicate

        // );

        // _addInput(

        //     exitId,

        //     ageOfInput,

        //     msg.sender, /* utxoOwner */

        //     predicate,

        //     token

        // );

    }



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external checkPredicateAndTokenMapping(rootToken) {

        require(registry.rootToChildToken(rootToken) == childToken, "INVALID_ROOT_TO_CHILD_TOKEN_MAPPING");

        _addExitToQueue(exitor, rootToken, exitAmountOrTokenId, txHash, isRegularExit, priority, msg.sender);

    }



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external {

        PlasmaExit storage exit = exits[exitId];

        Input storage input = exit.inputs[inputId];

        require(exit.owner != address(0x0) && input.utxoOwner != address(0x0), "Invalid exit or input id");

        require(registry.predicates(adjudicatorPredicate) != Registry.Type.Invalid, "INVALID_PREDICATE");

        require(

            IPredicate(adjudicatorPredicate).verifyDeprecation(

                encodeExit(exit),

                encodeInputUtxo(inputId, input),

                challengeData

            ),

            "Challenge failed"

        );

        // In the call to burn(exitId), there is an implicit check that prevents challenging the same exit twice

        ExitNFT(exitNft).burn(exitId);



        // Send bond amount to challenger

        msg.sender.send(BOND_AMOUNT);



        // delete exits[exitId];

        emit ExitCancelled(exitId);

    }



    function processExits(address _token) public {

        uint256 exitableAt;

        uint256 exitId;



        PriorityQueue exitQueue = PriorityQueue(exitsQueues[_token]);



        while (exitQueue.currentSize() > 0 && gasleft() > ON_FINALIZE_GAS_LIMIT) {

            (exitableAt, exitId) = exitQueue.getMin();

            exitId = (exitableAt << 128) | exitId;

            PlasmaExit memory currentExit = exits[exitId];



            // Stop processing exits if the exit that is next is queue is still in its challenge period

            if (exitableAt > block.timestamp) return;



            exitQueue.delMin();

            // If the exitNft was deleted as a result of a challenge, skip processing this exit

            if (!exitNft.exists(exitId)) continue;

            address exitor = exitNft.ownerOf(exitId);

            exits[exitId].owner = exitor;

            exitNft.burn(exitId);

            // If finalizing a particular exit is reverting, it will block any following exits from being processed.

            // Hence, call predicate.onFinalizeExit in a revertless manner.

            // (bool success, bytes memory result) =

            currentExit.predicate.call(

                abi.encodeWithSignature("onFinalizeExit(bytes)", encodeExitForProcessExit(exitId))

            );



            emit Withdraw(exitId, exitor, _token, currentExit.receiptAmountOrNFTId);



            if (!currentExit.isRegularExit) {

                // return the bond amount if this was a MoreVp style exit

                address(uint160(exitor)).send(BOND_AMOUNT);

            }

        }

    }



    function processExitsBatch(address[] calldata _tokens) external {

        for (uint256 i = 0; i < _tokens.length; i++) {

            processExits(_tokens[i]);

        }

    }



    /**

     * @dev Add a state update (UTXO style input) to an exit

     * @param exitId Exit ID

     * @param age age of the UTXO style input

     * @param utxoOwner User for whom the input acts as a proof-of-funds

     * (alternate expression) User who could have potentially spent this UTXO

     * @param token Token (Think of it like Utxo color)

     */

    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external isPredicateAuthorized {

        PlasmaExit storage exitObject = exits[exitId];

        require(exitObject.owner != address(0x0), "INVALID_EXIT_ID");

        _addInput(

            exitId,

            age,

            utxoOwner,

            /* predicate */

            msg.sender,

            token

        );

    }



    function _addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address predicate,

        address token

    ) internal {

        exits[exitId].inputs[age] = Input(utxoOwner, predicate, token);

        emit ExitUpdated(exitId, age, utxoOwner);

    }



    function encodeExit(PlasmaExit storage exit) internal view returns (bytes memory) {

        return

            abi.encode(

                exit.owner,

                registry.rootToChildToken(exit.token),

                exit.receiptAmountOrNFTId,

                exit.txHash,

                exit.isRegularExit

            );

    }



    function encodeExitForProcessExit(uint256 exitId) internal view returns (bytes memory) {

        PlasmaExit storage exit = exits[exitId];

        return abi.encode(exitId, exit.token, exit.owner, exit.receiptAmountOrNFTId);

    }



    function encodeInputUtxo(uint256 age, Input storage input) internal view returns (bytes memory) {

        return abi.encode(age, input.utxoOwner, input.predicate, registry.rootToChildToken(input.token));

    }



    function _addExitToQueue(

        address exitor,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 exitId,

        address predicate

    ) internal {

        require(exits[exitId].token == address(0x0), "EXIT_ALREADY_EXISTS");

        exits[exitId] = PlasmaExit(

            exitAmountOrTokenId,

            txHash,

            exitor,

            rootToken,

            isRegularExit,

            predicate

        );

        PlasmaExit storage _exitObject = exits[exitId];



        bytes32 key = getKey(_exitObject.token, _exitObject.owner, _exitObject.receiptAmountOrNFTId);



        if (isRegularExit) {

            require(!isKnownExit[uint128(exitId)], "KNOWN_EXIT");

            isKnownExit[uint128(exitId)] = true;

        } else {

            // a user cannot start 2 MoreVP exits for the same erc20 token or nft

            require(ownerExits[key] == 0, "EXIT_ALREADY_IN_PROGRESS");

            ownerExits[key] = exitId;

        }



        PriorityQueue queue = PriorityQueue(exitsQueues[_exitObject.token]);



        // Way priority queue is implemented is such that it expects 2 uint256 params with most significant 128 bits masked out

        // This is a workaround to split exitId, which otherwise is conclusive in itself

        // exitId >> 128 gives 128 most significant bits

        // uint256(uint128(exitId)) gives 128 least significant bits

        // @todo Fix this mess

        queue.insert(exitId >> 128, uint256(uint128(exitId)));



        // create exit nft

        exitNft.mint(_exitObject.owner, exitId);

        emit ExitStarted(exitor, exitId, rootToken, exitAmountOrTokenId, isRegularExit);

    }



    function checkBlockMembershipInCheckpoint(

        uint256 blockNumber,

        uint256 blockTime,

        bytes32 txRoot,

        bytes32 receiptRoot,

        uint256 headerNumber,

        bytes memory blockProof

    )

        internal

        view

        returns (

            uint256 /* createdAt */

        )

    {

        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = rootChain.headerBlocks(headerNumber);

        require(

            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(

                blockNumber - startBlock,

                headerRoot,

                blockProof

            ),

            "WITHDRAW_BLOCK_NOT_A_PART_OF_SUBMITTED_HEADER"

        );

        return createdAt;

    }



    function getKey(

        address token,

        address exitor,

        uint256 amountOrToken

    ) internal view returns (bytes32 key) {

        if (registry.isERC721(token)) {

            key = keccak256(abi.encodePacked(token, exitor, amountOrToken));

        } else {

            // validate amount

            require(amountOrToken > 0, "CANNOT_EXIT_ZERO_AMOUNTS");

            key = keccak256(abi.encodePacked(token, exitor));

        }

    }



    function getDepositManager() internal view returns (DepositManager) {

        return DepositManager(address(uint160(registry.getDepositManagerAddress())));

    }



    function getExitableAt(uint256 createdAt) internal view returns (uint256) {

        return Math.max(createdAt + 2 * HALF_EXIT_PERIOD, now + HALF_EXIT_PERIOD);

    }



    // Housekeeping function. @todo remove later

    function updateExitPeriod(uint256 halfExitPeriod) public onlyOwner {

        emit ExitPeriodUpdate(HALF_EXIT_PERIOD, halfExitPeriod);

        HALF_EXIT_PERIOD = halfExitPeriod;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Polygon Bridge\contracts\WithdrawManagerProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-31

*/



// File: contracts/common/governance/IGovernance.sol



pragma solidity ^0.5.2;





interface IGovernance {

    function update(address target, bytes calldata data) external;

}



// File: contracts/common/governance/Governable.sol



pragma solidity ^0.5.2;





contract Governable {

    IGovernance public governance;



    constructor(address _governance) public {

        governance = IGovernance(_governance);

    }



    modifier onlyGovernance() {

        require(msg.sender == address(governance), "Only governance contract is authorized");

        _;

    }

}



// File: contracts/root/withdrawManager/IWithdrawManager.sol



pragma solidity ^0.5.2;





contract IWithdrawManager {

    function createExitQueue(address token) external;



    function verifyInclusion(

        bytes calldata data,

        uint8 offset,

        bool verifyTxInclusion

    ) external view returns (uint256 age);



    function addExitToQueue(

        address exitor,

        address childToken,

        address rootToken,

        uint256 exitAmountOrTokenId,

        bytes32 txHash,

        bool isRegularExit,

        uint256 priority

    ) external;



    function addInput(

        uint256 exitId,

        uint256 age,

        address utxoOwner,

        address token

    ) external;



    function challengeExit(

        uint256 exitId,

        uint256 inputId,

        bytes calldata challengeData,

        address adjudicatorPredicate

    ) external;

}



// File: contracts/common/Registry.sol



pragma solidity ^0.5.2;





contract Registry is Governable {

    // @todo hardcode constants

    bytes32 private constant WETH_TOKEN = keccak256("wethToken");

    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");

    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");

    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");

    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");

    bytes32 private constant CHILD_CHAIN = keccak256("childChain");

    bytes32 private constant STATE_SENDER = keccak256("stateSender");

    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");



    address public erc20Predicate;

    address public erc721Predicate;



    mapping(bytes32 => address) public contractMap;

    mapping(address => address) public rootToChildToken;

    mapping(address => address) public childToRootToken;

    mapping(address => bool) public proofValidatorContracts;

    mapping(address => bool) public isERC721;



    enum Type {Invalid, ERC20, ERC721, Custom}

    struct Predicate {

        Type _type;

    }

    mapping(address => Predicate) public predicates;



    event TokenMapped(address indexed rootToken, address indexed childToken);

    event ProofValidatorAdded(address indexed validator, address indexed from);

    event ProofValidatorRemoved(address indexed validator, address indexed from);

    event PredicateAdded(address indexed predicate, address indexed from);

    event PredicateRemoved(address indexed predicate, address indexed from);

    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);



    constructor(address _governance) public Governable(_governance) {}



    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {

        emit ContractMapUpdated(_key, contractMap[_key], _address);

        contractMap[_key] = _address;

    }



    /**

     * @dev Map root token to child token

     * @param _rootToken Token address on the root chain

     * @param _childToken Token address on the child chain

     * @param _isERC721 Is the token being mapped ERC721

     */

    function mapToken(

        address _rootToken,

        address _childToken,

        bool _isERC721

    ) external onlyGovernance {

        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");

        rootToChildToken[_rootToken] = _childToken;

        childToRootToken[_childToken] = _rootToken;

        isERC721[_rootToken] = _isERC721;

        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);

        emit TokenMapped(_rootToken, _childToken);

    }



    function addErc20Predicate(address predicate) public onlyGovernance {

        require(predicate != address(0x0), "Can not add null address as predicate");

        erc20Predicate = predicate;

        addPredicate(predicate, Type.ERC20);

    }



    function addErc721Predicate(address predicate) public onlyGovernance {

        erc721Predicate = predicate;

        addPredicate(predicate, Type.ERC721);

    }



    function addPredicate(address predicate, Type _type) public onlyGovernance {

        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");

        predicates[predicate]._type = _type;

        emit PredicateAdded(predicate, msg.sender);

    }



    function removePredicate(address predicate) public onlyGovernance {

        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");

        delete predicates[predicate];

        emit PredicateRemoved(predicate, msg.sender);

    }



    function getValidatorShareAddress() public view returns (address) {

        return contractMap[VALIDATOR_SHARE];

    }



    function getWethTokenAddress() public view returns (address) {

        return contractMap[WETH_TOKEN];

    }



    function getDepositManagerAddress() public view returns (address) {

        return contractMap[DEPOSIT_MANAGER];

    }



    function getStakeManagerAddress() public view returns (address) {

        return contractMap[STAKE_MANAGER];

    }



    function getSlashingManagerAddress() public view returns (address) {

        return contractMap[SLASHING_MANAGER];

    }



    function getWithdrawManagerAddress() public view returns (address) {

        return contractMap[WITHDRAW_MANAGER];

    }



    function getChildChainAndStateSender() public view returns (address, address) {

        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);

    }



    function isTokenMapped(address _token) public view returns (bool) {

        return rootToChildToken[_token] != address(0x0);

    }



    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {

        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");

        return isERC721[_token];

    }



    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {

        if (isTokenMappedAndIsErc721(_token)) {

            return erc721Predicate;

        }

        return erc20Predicate;

    }



    function isChildTokenErc721(address childToken) public view returns (bool) {

        address rootToken = childToRootToken[childToken];

        require(rootToken != address(0x0), "Child token is not mapped");

        return isERC721[rootToken];

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;





/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor() internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/common/misc/ProxyStorage.sol



pragma solidity ^0.5.2;





contract ProxyStorage is Ownable {

    address internal proxyTo;

}



// File: contracts/common/misc/ERCProxy.sol



/*

 * SPDX-License-Identitifer:    MIT

 */



pragma solidity ^0.5.2;





// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md



interface ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId);



    function implementation() external view returns (address codeAddr);

}



// File: contracts/common/misc/DelegateProxy.sol



pragma solidity ^0.5.2;





contract DelegateProxy is ERCProxy {

    function proxyType() external pure returns (uint256 proxyTypeId) {

        // Upgradeable proxy

        proxyTypeId = 2;

    }



    function implementation() external view returns (address);



    function delegatedFwd(address _dst, bytes memory _calldata) internal {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)

            let size := returndatasize



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.

            // if the call returned error data, forward it

            switch result

                case 0 {

                    revert(ptr, size)

                }

                default {

                    return(ptr, size)

                }

        }

    }

}



// File: contracts/common/misc/Proxy.sol



pragma solidity ^0.5.2;





contract Proxy is ProxyStorage, DelegateProxy {

    event ProxyUpdated(address indexed _new, address indexed _old);

    event OwnerUpdate(address _prevOwner, address _newOwner);



    constructor(address _proxyTo) public {

        updateImplementation(_proxyTo);

    }



    function() external payable {

        // require(currentContract != 0, "If app code has not been set yet, do not call");

        // Todo: filter out some calls or handle in the end fallback

        delegatedFwd(proxyTo, msg.data);

    }



    function implementation() external view returns (address) {

        return proxyTo;

    }



    function updateImplementation(address _newProxyTo) public onlyOwner {

        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");

        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");

        emit ProxyUpdated(_newProxyTo, proxyTo);

        proxyTo = _newProxyTo;

    }



    function isContract(address _target) internal view returns (bool) {

        if (_target == address(0)) {

            return false;

        }



        uint256 size;

        assembly {

            size := extcodesize(_target)

        }

        return size > 0;

    }

}



// File: solidity-rlp/contracts/RLPReader.sol



/*

 * @author Hamdi Allam hamdi.allam97@gmail.com

 * Please reach out with any questions or concerns

 */

pragma solidity ^0.5.0;





library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START = 0xb8;

    uint8 constant LIST_SHORT_START = 0xc0;

    uint8 constant LIST_LONG_START = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint256 len;

        uint256 memPtr;

    }



    struct Iterator {

        RLPItem item; // Item that's being iterated over.

        uint256 nextPtr; // Position of the next item in the list.

    }



    /*

     * @dev Returns the next element in the iteration. Reverts if it has not next element.

     * @param self The iterator.

     * @return The next element in the iteration.

     */

    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));



        uint256 ptr = self.nextPtr;

        uint256 itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;



        return RLPItem(itemLength, ptr);

    }



    /*

     * @dev Returns true if the iteration has more elements.

     * @param self The iterator.

     * @return true if the iteration has more elements.

     */

    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    /*

     * @param item RLP encoded bytes

     */

    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint256 memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }



        return RLPItem(item.length, memPtr);

    }



    /*

     * @dev Create an iterator. Reverts if item is not a list.

     * @param self The RLP item.

     * @return An 'Iterator' over the item.

     */

    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));



        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    /*

     * @param item RLP encoded bytes

     */

    function rlpLen(RLPItem memory item) internal pure returns (uint256) {

        return item.len;

    }



    /*

     * @param item RLP encoded bytes

     */

    function payloadLen(RLPItem memory item) internal pure returns (uint256) {

        return item.len - _payloadOffset(item.memPtr);

    }



    /*

     * @param item RLP encoded list in bytes

     */

    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));



        uint256 items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);



        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 dataLen;

        for (uint256 i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr);

            memPtr = memPtr + dataLen;

        }



        return result;

    }



    // @return indicator whether encoded payload is a list. negate this function call for isData.

    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint256 memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START) return false;

        return true;

    }



    /** RLPItem conversions into data types **/



    // @returns raw rlp encoding in bytes

    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;



        uint256 ptr;

        assembly {

            ptr := add(0x20, result)

        }



        copy(item.memPtr, ptr, item.len);

        return result;

    }



    // any non-zero byte is considered true

    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint256 result;

        uint256 memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        return result == 0 ? false : true;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        // 1 byte for the length prefix

        require(item.len == 21);



        return address(toUint(item));

    }



    function toUint(RLPItem memory item) internal pure returns (uint256) {

        require(item.len > 0 && item.len <= 33);



        uint256 offset = _payloadOffset(item.memPtr);

        uint256 len = item.len - offset;



        uint256 result;

        uint256 memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)



            // shfit to the correct location if neccesary

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }



        return result;

    }



    // enforces 32 byte length

    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {

        // one byte prefix

        require(item.len == 33);



        uint256 result;

        uint256 memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }



        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);



        uint256 offset = _payloadOffset(item.memPtr);

        uint256 len = item.len - offset; // data length

        bytes memory result = new bytes(len);



        uint256 destPtr;

        assembly {

            destPtr := add(0x20, result)

        }



        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    /*

     * Private Helpers

     */



    // @return number of payload items inside an encoded list.

    function numItems(RLPItem memory item) private pure returns (uint256) {

        if (item.len == 0) return 0;



        uint256 count = 0;

        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

            currPtr = currPtr + _itemLength(currPtr); // skip over an item

            count++;

        }



        return count;

    }



    // @return entire rlp item byte length

    function _itemLength(uint256 memPtr) private pure returns (uint256) {

        uint256 itemLen;

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) itemLen = 1;

        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;

        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is

                memPtr := add(memPtr, 1) // skip over the first byte



                /* 32 byte word size */

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len

                itemLen := add(dataLen, add(byteLen, 1))

            }

        } else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)



                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }



        return itemLen;

    }



    // @return number of bytes until the data

    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < STRING_SHORT_START) return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;

        else if (byte0 < LIST_SHORT_START)

            // being explicit

            return byte0 - (STRING_LONG_START - 1) + 1;

        else return byte0 - (LIST_LONG_START - 1) + 1;

    }



    /*

     * @param src Pointer to source

     * @param dest Pointer to destination

     * @param len Amount of memory to copy from the source

     */

    function copy(

        uint256 src,

        uint256 dest,

        uint256 len

    ) private pure {

        if (len == 0) return;



        // copy as many word sizes as possible

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }



            src += WORD_SIZE;

            dest += WORD_SIZE;

        }



        // left over bytes. Mask is used to remove unwanted bytes from the word

        uint256 mask = 256**(WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask)) // zero out src

            let destpart := and(mload(dest), mask) // retrieve the bytes

            mstore(dest, or(destpart, srcpart))

        }

    }

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;





/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: contracts/common/mixin/ChainIdMixin.sol



pragma solidity ^0.5.2;





contract ChainIdMixin {

    bytes public constant networkId = hex"89";

    uint256 public constant CHAINID = 137;

}



// File: contracts/root/RootChainStorage.sol



pragma solidity ^0.5.2;





contract RootChainHeader {

    event NewHeaderBlock(

        address indexed proposer,

        uint256 indexed headerBlockId,

        uint256 indexed reward,

        uint256 start,

        uint256 end,

        bytes32 root

    );

    // housekeeping event

    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }

}





contract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {

    bytes32 public heimdallId;

    uint8 public constant VOTE_TYPE = 2;



    uint16 internal constant MAX_DEPOSITS = 10000;

    uint256 public _nextHeaderBlock = MAX_DEPOSITS;

    uint256 internal _blockDepositId = 1;

    mapping(uint256 => HeaderBlock) public headerBlocks;

    Registry internal registry;

}



// File: contracts/staking/stakeManager/IStakeManager.sol



pragma solidity ^0.5.2;





contract IStakeManager {

    // validator replacement

    function startAuction(uint256 validatorId, uint256 amount) external;



    function confirmAuctionBid(

        uint256 validatorId,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function transferFunds(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function delegationDeposit(

        uint256 validatorId,

        uint256 amount,

        address delegator

    ) external returns (bool);



    function stake(

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes calldata signerPubkey

    ) external;



    function unstake(uint256 validatorId) external;



    function totalStakedFor(address addr) external view returns (uint256);



    function supportsHistory() external pure returns (bool);



    function stakeFor(

        address user,

        uint256 amount,

        uint256 heimdallFee,

        bool acceptDelegation,

        bytes memory signerPubkey

    ) public;



    function checkSignatures(

        uint256 blockInterval,

        bytes32 voteHash,

        bytes32 stateRoot,

        address proposer,

        bytes memory sigs

    ) public returns (uint256);



    function updateValidatorState(uint256 validatorId, int256 amount) public;



    function ownerOf(uint256 tokenId) public view returns (address);



    function slash(bytes memory slashingInfoList) public returns (uint256);



    function validatorStake(uint256 validatorId) public view returns (uint256);



    function epoch() public view returns (uint256);



    function withdrawalDelay() public view returns (uint256);

}



// File: contracts/root/IRootChain.sol



pragma solidity ^0.5.2;





interface IRootChain {

    function slash() external;



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external;



    function getLastChildBlock() external view returns (uint256);



    function currentHeaderBlock() external view returns (uint256);

}



// File: contracts/root/RootChain.sol



pragma solidity ^0.5.2;





contract RootChain is RootChainStorage, IRootChain {

    using SafeMath for uint256;

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    modifier onlyDepositManager() {

        require(msg.sender == registry.getDepositManagerAddress(), "UNAUTHORIZED_DEPOSIT_MANAGER_ONLY");

        _;

    }



    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {

        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi

            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));

        require(CHAINID == _borChainID, "Invalid bor chain id");



        require(_buildHeaderBlock(proposer, start, end, rootHash), "INCORRECT_HEADER_DATA");



        // check if it is better to keep it in local storage instead

        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());

        uint256 _reward = stakeManager.checkSignatures(

            end.sub(start).add(1),

            /**  

                prefix 01 to data 

                01 represents positive vote on data and 00 is negative vote

                malicious validator can try to send 2/3 on negative vote so 01 is appended

             */

            keccak256(abi.encodePacked(bytes(hex"01"), data)),

            accountHash,

            proposer,

            sigs

        );



        require(_reward != 0, "Invalid checkpoint");

        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);

        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);

        _blockDepositId = 1;

    }



    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {

        depositId = currentHeaderBlock().add(_blockDepositId);

        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)

        _blockDepositId = _blockDepositId.add(numDeposits);

        require(

            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed

            _blockDepositId <= MAX_DEPOSITS,

            "TOO_MANY_DEPOSITS"

        );

    }



    function getLastChildBlock() external view returns (uint256) {

        return headerBlocks[currentHeaderBlock()].end;

    }



    function slash() external {

        //TODO: future implementation

    }



    function currentHeaderBlock() public view returns (uint256) {

        return _nextHeaderBlock.sub(MAX_DEPOSITS);

    }



    function _buildHeaderBlock(

        address proposer,

        uint256 start,

        uint256 end,

        bytes32 rootHash

    ) private returns (bool) {

        uint256 nextChildBlock;

        /*

    The ID of the 1st header block is MAX_DEPOSITS.

    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0

    */

        if (_nextHeaderBlock > MAX_DEPOSITS) {

            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;

        }

        if (nextChildBlock != start) {

            return false;

        }



        HeaderBlock memory headerBlock = HeaderBlock({

            root: rootHash,

            start: nextChildBlock,

            end: end,

            createdAt: now,

            proposer: proposer

        });



        headerBlocks[_nextHeaderBlock] = headerBlock;

        return true;

    }



    // Housekeeping function. @todo remove later

    function setNextHeaderBlock(uint256 _value) public onlyOwner {

        require(_value % MAX_DEPOSITS == 0, "Invalid value");

        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {

            delete headerBlocks[i];

        }

        _nextHeaderBlock = _value;

        _blockDepositId = 1;

        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);

    }



    // Housekeeping function. @todo remove later

    function setHeimdallId(string memory _heimdallId) public onlyOwner {

        heimdallId = keccak256(abi.encodePacked(_heimdallId));

    }

}



// File: openzeppelin-solidity/contracts/introspection/IERC165.sol



pragma solidity ^0.5.2;





/**

 * @title IERC165

 * @dev https://eips.ethereum.org/EIPS/eip-165

 */

interface IERC165 {

    /**

     * @notice Query if a contract implements an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @dev Interface identification is specified in ERC-165. This function

     * uses less than 30,000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol



pragma solidity ^0.5.2;





/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    function balanceOf(address owner) public view returns (uint256 balance);



    function ownerOf(uint256 tokenId) public view returns (address owner);



    function approve(address to, uint256 tokenId) public;



    function getApproved(uint256 tokenId) public view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) public;



    function isApprovedForAll(address owner, address operator) public view returns (bool);



    function transferFrom(

        address from,

        address to,

        uint256 tokenId

    ) public;



    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId

    ) public;



    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId,

        bytes memory data

    ) public;

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol



pragma solidity ^0.5.2;





/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract IERC721Receiver {

    /**

     * @notice Handle the receipt of an NFT

     * @dev The ERC721 smart contract calls this function on the recipient

     * after a `safeTransfer`. This function MUST return the function selector,

     * otherwise the caller will revert the transaction. The selector to be

     * returned can be obtained as `this.onERC721Received.selector`. This

     * function MAY throw to revert and reject the transfer.

     * Note: the ERC721 contract address is always the message sender.

     * @param operator The address which called `safeTransferFrom` function

     * @param from The address which previously owned the token

     * @param tokenId The NFT identifier which is being transferred

     * @param data Additional data with no specified format

     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

     */

    function onERC721Received(

        address operator,

        address from,

        uint256 tokenId,

        bytes memory data

    ) public returns (bytes4);

}



// File: openzeppelin-solidity/contracts/utils/Address.sol



pragma solidity ^0.5.2;





/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }

}



// File: openzeppelin-solidity/contracts/drafts/Counters.sol



pragma solidity ^0.5.2;





/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids

 *

 * Include with `using Counters for Counters.Counter;`

 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath

 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never

 * directly accessed.

 */

library Counters {

    using SafeMath for uint256;



    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        counter._value += 1;

    }



    function decrement(Counter storage counter) internal {

        counter._value = counter._value.sub(1);

    }

}



// File: openzeppelin-solidity/contracts/introspection/ERC165.sol



pragma solidity ^0.5.2;





/**

 * @title ERC165

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract ERC165 is IERC165 {

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /*

     * 0x01ffc9a7 ===

     *     bytes4(keccak256('supportsInterface(bytes4)'))

     */



    /**

     * @dev a mapping of interface id to whether or not it's supported

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    /**

     * @dev A contract implementing SupportsInterfaceWithLookup

     * implement ERC165 itself

     */

    constructor() internal {

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev implement supportsInterface(bytes4) using a lookup table

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev internal method for registering an interface

     */

    function _registerInterface(bytes4 interfaceId) internal {

        require(interfaceId != 0xffffffff);

        _supportedInterfaces[interfaceId] = true;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol



pragma solidity ^0.5.2;





/**

 * @title ERC721 Non-Fungible Token Standard basic implementation

 * @dev see https://eips.ethereum.org/EIPS/eip-721

 */

contract ERC721 is ERC165, IERC721 {

    using SafeMath for uint256;

    using Address for address;

    using Counters for Counters.Counter;



    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;



    // Mapping from token ID to owner

    mapping(uint256 => address) private _tokenOwner;



    // Mapping from token ID to approved address

    mapping(uint256 => address) private _tokenApprovals;



    // Mapping from owner to number of owned token

    mapping(address => Counters.Counter) private _ownedTokensCount;



    // Mapping from owner to operator approvals

    mapping(address => mapping(address => bool)) private _operatorApprovals;



    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;



    /*

     * 0x80ac58cd ===

     *     bytes4(keccak256('balanceOf(address)')) ^

     *     bytes4(keccak256('ownerOf(uint256)')) ^

     *     bytes4(keccak256('approve(address,uint256)')) ^

     *     bytes4(keccak256('getApproved(uint256)')) ^

     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^

     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^

     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^

     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))

     */



    constructor() public {

        // register the supported interfaces to conform to ERC721 via ERC165

        _registerInterface(_INTERFACE_ID_ERC721);

    }



    /**

     * @dev Gets the balance of the specified address

     * @param owner address to query the balance of

     * @return uint256 representing the amount owned by the passed address

     */

    function balanceOf(address owner) public view returns (uint256) {

        require(owner != address(0));

        return _ownedTokensCount[owner].current();

    }



    /**

     * @dev Gets the owner of the specified token ID

     * @param tokenId uint256 ID of the token to query the owner of

     * @return address currently marked as the owner of the given token ID

     */

    function ownerOf(uint256 tokenId) public view returns (address) {

        address owner = _tokenOwner[tokenId];

        require(owner != address(0));

        return owner;

    }



    /**

     * @dev Approves another address to transfer the given token ID

     * The zero address indicates there is no approved address.

     * There can only be one approved address per token at a given time.

     * Can only be called by the token owner or an approved operator.

     * @param to address to be approved for the given token ID

     * @param tokenId uint256 ID of the token to be approved

     */

    function approve(address to, uint256 tokenId) public {

        address owner = ownerOf(tokenId);

        require(to != owner);

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));



        _tokenApprovals[tokenId] = to;

        emit Approval(owner, to, tokenId);

    }



    /**

     * @dev Gets the approved address for a token ID, or zero if no address set

     * Reverts if the token ID does not exist.

     * @param tokenId uint256 ID of the token to query the approval of

     * @return address currently approved for the given token ID

     */

    function getApproved(uint256 tokenId) public view returns (address) {

        require(_exists(tokenId));

        return _tokenApprovals[tokenId];

    }



    /**

     * @dev Sets or unsets the approval of a given operator

     * An operator is allowed to transfer all tokens of the sender on their behalf

     * @param to operator address to set the approval

     * @param approved representing the status of the approval to be set

     */

    function setApprovalForAll(address to, bool approved) public {

        require(to != msg.sender);

        _operatorApprovals[msg.sender][to] = approved;

        emit ApprovalForAll(msg.sender, to, approved);

    }



    /**

     * @dev Tells whether an operator is approved by a given owner

     * @param owner owner address which you want to query the approval of

     * @param operator operator address which you want to query the approval of

     * @return bool whether the given operator is approved by the given owner

     */

    function isApprovedForAll(address owner, address operator) public view returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    /**

     * @dev Transfers the ownership of a given token ID to another address

     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function transferFrom(

        address from,

        address to,

        uint256 tokenId

    ) public {

        require(_isApprovedOrOwner(msg.sender, tokenId));



        _transferFrom(from, to, tokenId);

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId

    ) public {

        safeTransferFrom(from, to, tokenId, "");

    }



    /**

     * @dev Safely transfers the ownership of a given token ID to another address

     * If the target address is a contract, it must implement `onERC721Received`,

     * which is called upon a safe transfer, and return the magic value

     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

     * the transfer is reverted.

     * Requires the msg.sender to be the owner, approved, or operator

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes data to send along with a safe transfer check

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId,

        bytes memory _data

    ) public {

        transferFrom(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data));

    }



    /**

     * @dev Returns whether the specified token exists

     * @param tokenId uint256 ID of the token to query the existence of

     * @return bool whether the token exists

     */

    function _exists(uint256 tokenId) internal view returns (bool) {

        address owner = _tokenOwner[tokenId];

        return owner != address(0);

    }



    /**

     * @dev Returns whether the given spender can transfer a given token ID

     * @param spender address of the spender to query

     * @param tokenId uint256 ID of the token to be transferred

     * @return bool whether the msg.sender is approved for the given token ID,

     * is an operator of the owner, or is the owner of the token

     */

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {

        address owner = ownerOf(tokenId);

        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));

    }



    /**

     * @dev Internal function to mint a new token

     * Reverts if the given token ID already exists

     * @param to The address that will own the minted token

     * @param tokenId uint256 ID of the token to be minted

     */

    function _mint(address to, uint256 tokenId) internal {

        require(to != address(0));

        require(!_exists(tokenId));



        _tokenOwner[tokenId] = to;

        _ownedTokensCount[to].increment();



        emit Transfer(address(0), to, tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * Deprecated, use _burn(uint256) instead.

     * @param owner owner of the token to burn

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(address owner, uint256 tokenId) internal {

        require(ownerOf(tokenId) == owner);



        _clearApproval(tokenId);



        _ownedTokensCount[owner].decrement();

        _tokenOwner[tokenId] = address(0);



        emit Transfer(owner, address(0), tokenId);

    }



    /**

     * @dev Internal function to burn a specific token

     * Reverts if the token does not exist

     * @param tokenId uint256 ID of the token being burned

     */

    function _burn(uint256 tokenId) internal {

        _burn(ownerOf(tokenId), tokenId);

    }



    /**

     * @dev Internal function to transfer ownership of a given token ID to another address.

     * As opposed to transferFrom, this imposes no restrictions on msg.sender.

     * @param from current owner of the token

     * @param to address to receive the ownership of the given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _transferFrom(

        address from,

        address to,

        uint256 tokenId

    ) internal {

        require(ownerOf(tokenId) == from);

        require(to != address(0));



        _clearApproval(tokenId);



        _ownedTokensCount[from].decrement();

        _ownedTokensCount[to].increment();



        _tokenOwner[tokenId] = to;



        emit Transfer(from, to, tokenId);

    }



    /**

     * @dev Internal function to invoke `onERC721Received` on a target address

     * The call is not executed if the target address is not a contract

     * @param from address representing the previous owner of the given token ID

     * @param to target address that will receive the tokens

     * @param tokenId uint256 ID of the token to be transferred

     * @param _data bytes optional data to send along with the call

     * @return bool whether the call correctly returned the expected magic value

     */

    function _checkOnERC721Received(

        address from,

        address to,

        uint256 tokenId,

        bytes memory _data

    ) internal returns (bool) {

        if (!to.isContract()) {

            return true;

        }



        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);

        return (retval == _ERC721_RECEIVED);

    }



    /**

     * @dev Private function to clear current approval of a given token ID

     * @param tokenId uint256 ID of the token to be transferred

     */

    function _clearApproval(uint256 tokenId) private {

        if (_tokenApprovals[tokenId] != address(0)) {

            _tokenApprovals[tokenId] = address(0);

        }

    }

}



// File: contracts/root/withdrawManager/ExitNFT.sol



pragma solidity ^0.5.2;





contract ExitNFT is ERC721 {

    Registry internal registry;



    modifier onlyWithdrawManager() {

        require(msg.sender == registry.getWithdrawManagerAddress(), "UNAUTHORIZED_WITHDRAW_MANAGER_ONLY");

        _;

    }



    constructor(address _registry) public {

        registry = Registry(_registry);

    }



    function mint(address _owner, uint256 _tokenId) external onlyWithdrawManager {

        _mint(_owner, _tokenId);

    }



    function burn(uint256 _tokenId) external onlyWithdrawManager {

        _burn(_tokenId);

    }



    function exists(uint256 tokenId) public view returns (bool) {

        return _exists(tokenId);

    }

}



// File: contracts/root/withdrawManager/WithdrawManagerStorage.sol



pragma solidity ^0.5.2;





contract ExitsDataStructure {

    struct Input {

        address utxoOwner;

        address predicate;

        address token;

    }



    struct PlasmaExit {

        uint256 receiptAmountOrNFTId;

        bytes32 txHash;

        address owner;

        address token;

        bool isRegularExit;

        address predicate;

        // Mapping from age of input to Input

        mapping(uint256 => Input) inputs;

    }

}





contract WithdrawManagerHeader is ExitsDataStructure {

    event Withdraw(uint256 indexed exitId, address indexed user, address indexed token, uint256 amount);



    event ExitStarted(

        address indexed exitor,

        uint256 indexed exitId,

        address indexed token,

        uint256 amount,

        bool isRegularExit

    );



    event ExitUpdated(uint256 indexed exitId, uint256 indexed age, address signer);

    event ExitPeriodUpdate(uint256 indexed oldExitPeriod, uint256 indexed newExitPeriod);



    event ExitCancelled(uint256 indexed exitId);

}





contract WithdrawManagerStorage is ProxyStorage, WithdrawManagerHeader {

    // 0.5 week = 7 * 86400 / 2 = 302400

    uint256 public HALF_EXIT_PERIOD = 302400;



    // Bonded exits collaterized at 0.1 ETH

    uint256 internal constant BOND_AMOUNT = 10**17;



    Registry internal registry;

    RootChain internal rootChain;



    mapping(uint128 => bool) isKnownExit;

    mapping(uint256 => PlasmaExit) public exits;

    // mapping with token => (owner => exitId) keccak(token+owner) keccak(token+owner+tokenId)

    mapping(bytes32 => uint256) public ownerExits;

    mapping(address => address) public exitsQueues;

    ExitNFT public exitNft;



    // ERC721, ERC20 and Weth transfers require 155000, 100000, 52000 gas respectively

    // Processing each exit in a while loop iteration requires ~52000 gas (@todo check if this changed)

    // uint32 constant internal ITERATION_GAS = 52000;



    // So putting an upper limit of 155000 + 52000 + leeway

    uint32 public ON_FINALIZE_GAS_LIMIT = 300000;



    uint256 public exitWindow;

}



// File: contracts/root/withdrawManager/WithdrawManagerProxy.sol



pragma solidity ^0.5.2;





contract WithdrawManagerProxy is Proxy, WithdrawManagerStorage {

    constructor(

        address _proxyTo,

        address _registry,

        address _rootChain,

        address _exitNft

    ) public Proxy(_proxyTo) {

        registry = Registry(_registry);

        rootChain = RootChain(_rootChain);

        exitNft = ExitNFT(_exitNft);

    }

}

--------------------------------------------------
File End
--------------------------------------------------

Folder Structure
--------------------------------------------------
contracts/
    Address.sol
    AddressAliasHelper.sol
    BondManager.sol
    CanonicalTransactionChain.sol
    ChainStorageContainer.sol
    Context.sol
    ContextUpgradeable.sol
    CrossDomainEnabled.sol
    ERC165Checker.sol
    IBondManager.sol
    ICanonicalTransactionChain.sol
    IChainStorageContainer.sol
    ICrossDomainMessenger.sol
    IERC165.sol
    IERC20.sol
    iL1ChugSplashDeployer.sol
    IL1CrossDomainMessenger.sol
    IL1ERC20Bridge.sol
    IL1StandardBridge.sol
    IL2ERC20Bridge.sol
    IL2StandardERC20.sol
    iMVM_DiscountOracle.sol
    iMVM_L2ChainManagerOnL1.sol
    Initializable.sol
    iOVM_SequencerFeeVault.sol
    IStateCommitmentChain.sol
    L1ChugSplashProxy.sol
    L1CrossDomainMessenger.sol
    L1StandardBridge.sol
    L2StandardBridge.sol
    Lib_AddressManager.sol
    Lib_AddressResolver.sol
    Lib_Buffer.sol
    Lib_Bytes32Utils.sol
    Lib_BytesUtils.sol
    Lib_CrossDomainUtils.sol
    Lib_DefaultValues.sol
    Lib_MerkleTrie.sol
    Lib_OVMCodec.sol
    Lib_PredeployAddresses.sol
    Lib_ResolvedDelegateProxy.sol
    Lib_RLPReader.sol
    Lib_RLPWriter.sol
    Lib_SecureMerkleTrie.sol
    MVM_CanonicalTransaction.sol
    MVM_L2ChainManagerOnL1.sol
    MVM_Verifier.sol
    OVM_GasPriceOracle.sol
    Ownable.sol
    OwnableUpgradeable.sol
    PausableUpgradeable.sol
    ReentrancyGuardUpgradeable.sol
    SafeERC20.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\AddressAliasHelper.sol
File type: .sol
// SPDX-License-Identifier: Apache-2.0



/*

 * Copyright 2019-2021, Offchain Labs, Inc.

 *

 * Licensed under the Apache License, Version 2.0 (the "License");

 * you may not use this file except in compliance with the License.

 * You may obtain a copy of the License at

 *

 *    http://www.apache.org/licenses/LICENSE-2.0

 *

 * Unless required by applicable law or agreed to in writing, software

 * distributed under the License is distributed on an "AS IS" BASIS,

 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

 * See the License for the specific language governing permissions and

 * limitations under the License.

 */



pragma solidity ^0.8.7;



library AddressAliasHelper {

    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);



    /// @notice Utility function that converts the address in the L1 that submitted a tx to

    /// the inbox to the msg.sender viewed in the L2

    /// @param l1Address the address in the L1 that triggered the tx to L2

    /// @return l2Address L2 address as viewed in msg.sender

    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {

        unchecked {

            l2Address = address(uint160(l1Address) + offset);

        }

    }



    /// @notice Utility function that converts the msg.sender viewed in the L2 to the

    /// address in the L1 that submitted a tx to the inbox

    /// @param l2Address L2 address as viewed in msg.sender

    /// @return l1Address the address in the L1 that triggered the tx to L2

    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {

        unchecked {

            l1Address = address(uint160(l2Address) - offset);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\BondManager.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Interface Imports */

import { IBondManager } from "./IBondManager.sol";



/* Contract Imports */

import { Lib_AddressResolver } from "../../libraries/resolver/Lib_AddressResolver.sol";



/**

 * @title BondManager

 * @dev This contract is, for now, a stub of the "real" BondManager that does nothing but

 * allow the "OVM_Proposer" to submit state root batches.

 *

 * Runtime target: EVM

 */

contract BondManager is IBondManager, Lib_AddressResolver {

    /**

     * @param _libAddressManager Address of the Address Manager.

     */

    constructor(address _libAddressManager) Lib_AddressResolver(_libAddressManager) {}



    /**

     * Checks whether a given address is properly collateralized and can perform actions within

     * the system.

     * @param _who Address to check.

     * @return true if the address is properly collateralized, false otherwise.

     */

    function isCollateralized(address _who) public view returns (bool) {

        // Only authenticate sequencer to submit state root batches.

        return _who == resolve("OVM_Proposer");

    }

    

    function isCollateralizedByChainId(

        uint256 _chainId,

        address _who,

        address _prop

    ) override public view returns (bool) {

        require(_who==_prop,"sender must the proposer!");

        return true;

        //return bonds[_who].state == State.COLLATERALIZED;

    }

    

    function registerSequencerByChainId(

        uint256 _chainId,

        address _sequencer,

        address _proposer

    ) public {

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\CanonicalTransactionChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { AddressAliasHelper } from "../../standards/AddressAliasHelper.sol";

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";

import { Lib_AddressResolver } from "../../libraries/resolver/Lib_AddressResolver.sol";



/* Interface Imports */

import { ICanonicalTransactionChain } from "./ICanonicalTransactionChain.sol";

import { IChainStorageContainer } from "./IChainStorageContainer.sol";



/**

 * @title CanonicalTransactionChain

 * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions

 * which must be applied to the rollup state. It defines the ordering of rollup transactions by

 * writing them to the 'CTC:batches' instance of the Chain Storage Container.

 * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the

 * Sequencer will eventually append it to the rollup state.

 *

 * Runtime target: EVM

 */

contract CanonicalTransactionChain is ICanonicalTransactionChain, Lib_AddressResolver {

    /*************

     * Constants *

     *************/



    // L2 tx gas-related

    uint256 public constant MIN_ROLLUP_TX_GAS = 100000;

    uint256 public constant MAX_ROLLUP_TX_SIZE = 50000;



    // The approximate cost of calling the enqueue function

    uint256 public enqueueGasCost;

    // The ratio of the cost of L1 gas to the cost of L2 gas

    uint256 public l2GasDiscountDivisor;

    // The amount of L2 gas which can be forwarded to L2 without spam prevention via 'gas burn'.

    // Calculated as the product of l2GasDiscountDivisor * enqueueGasCost.

    // See comments in enqueue() for further detail.

    uint256 public enqueueL2GasPrepaid;

    //default l2 chain id

    uint256 constant public DEFAULT_CHAINID = 1088;



    // Encoding-related (all in bytes)

    uint256 internal constant BATCH_CONTEXT_SIZE = 16;

    uint256 internal constant BATCH_CONTEXT_LENGTH_POS = 12;

    uint256 internal constant BATCH_CONTEXT_START_POS = 15;

    uint256 internal constant TX_DATA_HEADER_SIZE = 3;

    uint256 internal constant BYTES_TILL_TX_DATA = 65;



    /*************

     * Variables *

     *************/



    uint256 public maxTransactionGasLimit;



    /***************

     * Queue State *

     ***************/



    mapping(uint256=>uint40) private _nextQueueIndex; // index of the first queue element not yet included

    mapping(uint256=>Lib_OVMCodec.QueueElement[]) queueElements;



    /***************

     * Constructor *

     ***************/



    constructor(

        address _libAddressManager,

        uint256 _maxTransactionGasLimit,

        uint256 _l2GasDiscountDivisor,

        uint256 _enqueueGasCost

    ) Lib_AddressResolver(_libAddressManager)

    {

        maxTransactionGasLimit = _maxTransactionGasLimit;

        l2GasDiscountDivisor = _l2GasDiscountDivisor;

        enqueueGasCost = _enqueueGasCost;

        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;

    }



    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Modifier to enforce that, if configured, only the Burn Admin may

     * successfully call a method.

     */

    modifier onlyBurnAdmin() {

        require(msg.sender == libAddressManager.owner(), "Only callable by the Burn Admin.");

        _;

    }



    /*******************************

     * Authorized Setter Functions *

     *******************************/



    /**

     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.

     * The value of enqueueL2GasPrepaid is immediately updated as well.

     */

    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost)

        external

        onlyBurnAdmin

    {

        enqueueGasCost = _enqueueGasCost;

        l2GasDiscountDivisor = _l2GasDiscountDivisor;

        // See the comment in enqueue() for the rationale behind this formula.

        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;



        emit L2GasParamsUpdated(l2GasDiscountDivisor, enqueueGasCost, enqueueL2GasPrepaid);

    }



    /********************

     * Public Functions *

     ********************/



    /**

     * Accesses the batch storage container.

     * @return Reference to the batch storage container.

     */

    function batches() public view returns (IChainStorageContainer) {

        return IChainStorageContainer(resolve("ChainStorageContainer-CTC-batches"));

    }



    /**

     * Accesses the queue storage container.

     * @return Reference to the queue storage container.

     */

    function queue() public view returns (IChainStorageContainer) {

        return IChainStorageContainer(resolve("ChainStorageContainer-CTC-queue"));

    }



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements() public view returns (uint256 _totalElements) {

        (uint40 totalElements, , , ) = _getBatchExtraData();

        return uint256(totalElements);

    }



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches() public view returns (uint256 _totalBatches) {

        return batches().length();

    }



    /**

     * Returns the index of the next element to be enqueued.

     * @return Index for the next queue element.

     */

    function getNextQueueIndex() public view returns (uint40) {

        return _nextQueueIndex[DEFAULT_CHAINID];

    }



    /**

     * Returns the timestamp of the last transaction.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestamp() public view returns (uint40) {

        (, , uint40 lastTimestamp, ) = _getBatchExtraData();

        return lastTimestamp;

    }



    /**

     * Returns the blocknumber of the last transaction.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumber() public view returns (uint40) {

        (, , , uint40 lastBlockNumber) = _getBatchExtraData();

        return lastBlockNumber;

    }



    /**

     * Gets the queue element at a particular index.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElement(uint256 _index)

        public

        view

        returns (Lib_OVMCodec.QueueElement memory _element)

    {

        return queueElements[DEFAULT_CHAINID][_index];

    }



    /**

     * Get the number of queue elements which have not yet been included.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElements() public view returns (uint40) {

        return uint40(queueElements[DEFAULT_CHAINID].length) - _nextQueueIndex[DEFAULT_CHAINID];

    }



    /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @return Length of the queue.

     */

    function getQueueLength() public view returns (uint40) {

        return uint40(queueElements[DEFAULT_CHAINID].length);

    }



    /**

     * Adds a transaction to the queue.

     * @param _target Target L2 contract to send the transaction to.

     * @param _gasLimit Gas limit for the enqueued L2 transaction.

     * @param _data Transaction data.

     */

    function enqueue(

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    ) external {

        enqueueByChainId(DEFAULT_CHAINID, _target, _gasLimit, _data);

    }



    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatch() external {

        uint40 shouldStartAtElement;

        uint24 totalElementsToAppend;

        uint24 numContexts;

        assembly {

            shouldStartAtElement := shr(216, calldataload(4))

            totalElementsToAppend := shr(232, calldataload(9))

            numContexts := shr(232, calldataload(12))

        }



        require(

            shouldStartAtElement == getTotalElements(),

            "Actual batch start index does not match expected start index."

        );



        require(

            msg.sender == resolve("OVM_Sequencer"),

            "Function can only be called by the Sequencer."

        );



        uint40 nextTransactionPtr = uint40(

            BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts

        );



        require(msg.data.length >= nextTransactionPtr, "Not enough BatchContexts provided.");



        // Counter for number of sequencer transactions appended so far.

        uint32 numSequencerTransactions = 0;



        // Cache the _nextQueueIndex storage variable to a temporary stack variable.

        // This is safe as long as nothing reads or writes to the storage variable

        // until it is updated by the temp variable.

        uint40 nextQueueIndex = _nextQueueIndex[DEFAULT_CHAINID];



        BatchContext memory curContext;

        for (uint32 i = 0; i < numContexts; i++) {

            BatchContext memory nextContext = _getBatchContext(i);



            // Now we can update our current context.

            curContext = nextContext;



            // Process sequencer transactions first.

            numSequencerTransactions += uint32(curContext.numSequencedTransactions);



            // Now process any subsequent queue transactions.

            nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);

        }



        require(

            nextQueueIndex <= queueElements[DEFAULT_CHAINID].length,

            "Attempted to append more elements than are available in the queue."

        );



        // Generate the required metadata that we need to append this batch

        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;

        uint40 blockTimestamp;

        uint40 blockNumber;

        if (curContext.numSubsequentQueueTransactions == 0) {

            // The last element is a sequencer tx, therefore pull timestamp and block number from

            // the last context.

            blockTimestamp = uint40(curContext.timestamp);

            blockNumber = uint40(curContext.blockNumber);

        } else {

            // The last element is a queue tx, therefore pull timestamp and block number from the

            // queue element.

            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at

            // least one queue element. We increment nextQueueIndex after processing each queue

            // element, so the index of the last element we processed is nextQueueIndex - 1.

            Lib_OVMCodec.QueueElement memory lastElement = queueElements[DEFAULT_CHAINID][nextQueueIndex - 1];



            blockTimestamp = lastElement.timestamp;

            blockNumber = lastElement.blockNumber;

        }



        // Cache the previous blockhash to ensure all transaction data can be retrieved efficiently.

        _appendBatch(

            blockhash(block.number - 1),

            totalElementsToAppend,

            numQueuedTransactions,

            blockTimestamp,

            blockNumber

        );



        emit SequencerBatchAppended(

            nextQueueIndex - numQueuedTransactions,

            numQueuedTransactions,

            getTotalElements(),

            DEFAULT_CHAINID

        );



        // Update the _nextQueueIndex storage variable.

        _nextQueueIndex[DEFAULT_CHAINID] = nextQueueIndex;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Returns the BatchContext located at a particular index.

     * @param _index The index of the BatchContext

     * @return The BatchContext at the specified index.

     */

    function _getBatchContext(uint256 _index) internal pure returns (BatchContext memory) {

        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;

        uint256 numSequencedTransactions;

        uint256 numSubsequentQueueTransactions;

        uint256 ctxTimestamp;

        uint256 ctxBlockNumber;



        assembly {

            numSequencedTransactions := shr(232, calldataload(contextPtr))

            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))

            ctxTimestamp := shr(216, calldataload(add(contextPtr, 6)))

            ctxBlockNumber := shr(216, calldataload(add(contextPtr, 11)))

        }



        return

            BatchContext({

                numSequencedTransactions: numSequencedTransactions,

                numSubsequentQueueTransactions: numSubsequentQueueTransactions,

                timestamp: ctxTimestamp,

                blockNumber: ctxBlockNumber

            });

    }



    /**

     * Parses the batch context from the extra data.

     * @return Total number of elements submitted.

     * @return Index of the next queue element.

     */

    function _getBatchExtraData()

        internal

        view

        returns (

            uint40,

            uint40,

            uint40,

            uint40

        )

    {

        bytes27 extraData = batches().getGlobalMetadata();



        uint40 totalElements;

        uint40 nextQueueIndex;

        uint40 lastTimestamp;

        uint40 lastBlockNumber;



        // solhint-disable max-line-length

        assembly {

            extraData := shr(40, extraData)

            totalElements := and(

                extraData,

                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF

            )

            nextQueueIndex := shr(

                40,

                and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000)

            )

            lastTimestamp := shr(

                80,

                and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000)

            )

            lastBlockNumber := shr(

                120,

                and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000)

            )

        }

        // solhint-enable max-line-length



        return (totalElements, nextQueueIndex, lastTimestamp, lastBlockNumber);

    }



    /**

     * Encodes the batch context for the extra data.

     * @param _totalElements Total number of elements submitted.

     * @param _nextQueueIdx Index of the next queue element.

     * @param _timestamp Timestamp for the last batch.

     * @param _blockNumber Block number of the last batch.

     * @return Encoded batch context.

     */

    function _makeBatchExtraData(

        uint40 _totalElements,

        uint40 _nextQueueIdx,

        uint40 _timestamp,

        uint40 _blockNumber

    ) internal pure returns (bytes27) {

        bytes27 extraData;

        assembly {

            extraData := _totalElements

            extraData := or(extraData, shl(40, _nextQueueIdx))

            extraData := or(extraData, shl(80, _timestamp))

            extraData := or(extraData, shl(120, _blockNumber))

            extraData := shl(40, extraData)

        }



        return extraData;

    }



    /**

     * Inserts a batch into the chain of batches.

     * @param _transactionRoot Root of the transaction tree for this batch.

     * @param _batchSize Number of elements in the batch.

     * @param _numQueuedTransactions Number of queue transactions in the batch.

     * @param _timestamp The latest batch timestamp.

     * @param _blockNumber The latest batch blockNumber.

     */

    function _appendBatch(

        bytes32 _transactionRoot,

        uint256 _batchSize,

        uint256 _numQueuedTransactions,

        uint40 _timestamp,

        uint40 _blockNumber

    ) internal {

        IChainStorageContainer batchesRef = batches();

        (uint40 totalElements, uint40 nextQueueIndex, , ) = _getBatchExtraData();



        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({

            batchIndex: batchesRef.length(),

            batchRoot: _transactionRoot,

            batchSize: _batchSize,

            prevTotalElements: totalElements,

            extraData: hex""

        });



        emit TransactionBatchAppended(

            DEFAULT_CHAINID,

            header.batchIndex,

            header.batchRoot,

            header.batchSize,

            header.prevTotalElements,

            header.extraData

        );



        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);

        bytes27 latestBatchContext = _makeBatchExtraData(

            totalElements + uint40(header.batchSize),

            nextQueueIndex + uint40(_numQueuedTransactions),

            _timestamp,

            _blockNumber

        );



        batchesRef.push(batchHeaderHash, latestBatchContext);

    }

    

    //added chain id for public function



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElementsByChainId(uint256 _chainId)

        override

        public

        view

        returns (

            uint256 _totalElements

        )

    {

        (uint40 totalElements,,,) = _getBatchExtraDataByChainId(_chainId);

        return uint256(totalElements);

    }



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatchesByChainId(uint256 _chainId)

        override

        public

        view

        returns (

            uint256 _totalBatches

        )

    {

        return batches().lengthByChainId(_chainId);

    }



    /**

     * Returns the index of the next element to be enqueued.

     * @return Index for the next queue element.

     */

    function getNextQueueIndexByChainId(uint256 _chainId)

        override

        public

        view

        returns (

            uint40

        )

    {

        (,uint40 nextQueueIndex,,) = _getBatchExtraDataByChainId(_chainId);

        return nextQueueIndex;

    }



    /**

     * Returns the timestamp of the last transaction.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestampByChainId(uint256 _chainId)

        override

        public

        view

        returns (

            uint40

        )

    {

        (,,uint40 lastTimestamp,) = _getBatchExtraDataByChainId(_chainId);

        return lastTimestamp;

    }



    /**

     * Returns the blocknumber of the last transaction.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumberByChainId(uint256 _chainId)

        override

        public

        view

        returns (

            uint40

        )

    {

        (,,,uint40 lastBlockNumber) = _getBatchExtraDataByChainId(_chainId);

        return lastBlockNumber;

    }



    /**

     * Gets the queue element at a particular index.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElementByChainId(

        uint256 _chainId,

        uint256 _index

    )

        override

        public

        view

        returns (

            Lib_OVMCodec.QueueElement memory _element

        )

    {

        return queueElements[_chainId][_index];

    }



    /**

     * Get the number of queue elements which have not yet been included.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElementsByChainId(

        uint256 _chainId

        )

        override

        public

        view

        returns (

            uint40

        )

    {

        return uint40(queueElements[_chainId].length) - _nextQueueIndex[_chainId];

    }



   /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @return Length of the queue.

     */

    function getQueueLengthByChainId(

        uint256 _chainId

        )

        override

        public

        view

        returns (

            uint40

        )

    {

        return uint40(queueElements[_chainId].length);

    }



    /**

     * Adds a transaction to the queue.

     * @param _target Target L2 contract to send the transaction to.

     * @param _gasLimit Gas limit for the enqueued L2 transaction.

     * @param _data Transaction data.

     */

    function enqueueByChainId(

        uint256 _chainId,

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    )

        override

        public

    {

        require(msg.sender == resolve("Proxy__OVM_L1CrossDomainMessenger"),

                "only the cross domain messenger can enqueue");

                

        require(

            _data.length <= MAX_ROLLUP_TX_SIZE,

            "Transaction data size exceeds maximum for rollup transaction."

        );



        require(

            _gasLimit <= maxTransactionGasLimit,

            "Transaction gas limit exceeds maximum for rollup transaction."

        );



        require(

            _gasLimit >= MIN_ROLLUP_TX_GAS,

            "Transaction gas limit too low to enqueue."

        );

        

        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a

        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.

        // We can safely ignore this for EOAs because they're guaranteed to have the same "code"

        // (i.e. no code at all). This also makes it possible for users to interact with contracts

        // on L2 even when the Sequencer is down.

        address sender;

        if (msg.sender == tx.origin) {

            sender = msg.sender;

        } else {

            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);

        }



        bytes32 transactionHash = keccak256(

            abi.encode(

                sender,

                _target,

                _gasLimit,

                _data

            )

        );

        

        queueElements[_chainId].push(

            Lib_OVMCodec.QueueElement({

                transactionHash: transactionHash,

                timestamp: uint40(block.timestamp),

                blockNumber: uint40(block.number)

            })

        );



        // The underlying queue data structure stores 2 elements

        // per insertion, so to get the real queue length we need

        // to divide by 2 and subtract 1.

        uint256 queueIndex = queueElements[_chainId].length - 1;

        emit TransactionEnqueued(

            _chainId,

            sender,

            _target,

            _gasLimit,

            _data,

            queueIndex,

            block.timestamp

        );

    }

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {

        if (_i == 0) {

            return "0";

        }

        uint j = _i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len;

        while (_i != 0) {

            k = k-1;

            uint8 temp = (48 + uint8(_i - _i / 10 * 10));

            bytes1 b1 = bytes1(temp);

            bstr[k] = b1;

            _i /= 10;

        }

        return string(bstr);

    }

    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatchByChainId()

        override

        public

    {

        uint256 _chainId;

        uint40 shouldStartAtElement;

        uint24 totalElementsToAppend;

        uint24 numContexts;

        assembly {

            _chainId              := calldataload(4)

            shouldStartAtElement  := shr(216, calldataload(36))

            totalElementsToAppend := shr(232, calldataload(41))

            numContexts           := shr(232, calldataload(44))

        }



        require(

            shouldStartAtElement == getTotalElementsByChainId(_chainId),

            "Actual batch start index does not match expected start index."

        );

        

        require(

            msg.sender == resolve(string(abi.encodePacked(uint2str(_chainId),"_MVM_Sequencer"))),

            "Function can only be called by the Sequencer."

        );



        require(

            numContexts > 0,

            "Must provide at least one batch context."

        );



        require(

            totalElementsToAppend > 0,

            "Must append at least one element."

        );





        uint40 nextTransactionPtr = uint40(

            BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts

        );



        require(

            msg.data.length >= nextTransactionPtr,

            "Not enough BatchContexts provided."

        );

        

        // Cache the _nextQueueIndex storage variable to a temporary stack variable.

        // This is safe as long as nothing reads or writes to the storage variable

        // until it is updated by the temp variable.

        uint40 nextQueueIndex = _nextQueueIndex[_chainId];



        // Counter for number of sequencer transactions appended so far.

        uint32 numSequencerTransactions = 0;



        BatchContext memory curContext;

        for (uint32 i = 0; i < numContexts; i++) {

            BatchContext memory nextContext = _getBatchContextByChainId(0,_chainId,i);



            // Now we can update our current context.

            curContext = nextContext;

	        // Process sequencer transactions first.

	        numSequencerTransactions += uint32(curContext.numSequencedTransactions);

	        

	        // Now process any subsequent queue transactions.

            nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);

        }



        require(

            nextQueueIndex <= queueElements[_chainId].length,

            "Attempted to append more elements than are available in the queue."

        );



        // Generate the required metadata that we need to append this batch

        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;

        uint40 blockTimestamp;

        uint40 blockNumber;

        if (curContext.numSubsequentQueueTransactions == 0) {

            // The last element is a sequencer tx, therefore pull timestamp and block number from

            // the last context.

            blockTimestamp = uint40(curContext.timestamp);

            blockNumber = uint40(curContext.blockNumber);

        } else {

            // The last element is a queue tx, therefore pull timestamp and block number from the

            // queue element.

            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at

            // least one queue element. We increment nextQueueIndex after processing each queue

            // element, so the index of the last element we processed is nextQueueIndex - 1.

            Lib_OVMCodec.QueueElement memory lastElement = queueElements[_chainId][nextQueueIndex - 1];



            blockTimestamp = lastElement.timestamp;

            blockNumber = lastElement.blockNumber;

        }



        // For efficiency reasons getMerkleRoot modifies the `leaves` argument in place

        // while calculating the root hash therefore any arguments passed to it must not

        // be used again afterwards

        _appendBatchByChainId(

    	    _chainId,

            blockhash(block.number - 1),

            totalElementsToAppend,

            numQueuedTransactions,

            blockTimestamp,

            blockNumber

        );



        emit SequencerBatchAppended(

            _chainId,

            nextQueueIndex - numQueuedTransactions,

            numQueuedTransactions,

            getTotalElementsByChainId(_chainId)

        );

        

        // Update the _nextQueueIndex storage variable.

        _nextQueueIndex[_chainId] = nextQueueIndex;

    }





    /**********************

     * Internal Functions *

     **********************/



    /**

     * Returns the BatchContext located at a particular index.

     * @param _index The index of the BatchContext

     * @return The BatchContext at the specified index.

     */

    function _getBatchContextByChainId(

        uint256 _ptrStart,

        uint256 _chainId,

        uint256 _index

    )

        internal

        pure

        returns (

            BatchContext memory

        )

    {

        uint256 contextPtr = _ptrStart + 32 + 15 + _index * BATCH_CONTEXT_SIZE;

        uint256 numSequencedTransactions;

        uint256 numSubsequentQueueTransactions;

        uint256 ctxTimestamp;

        uint256 ctxBlockNumber;



        assembly {

            numSequencedTransactions       := shr(232, calldataload(contextPtr))

            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))

            ctxTimestamp                   := shr(216, calldataload(add(contextPtr, 6)))

            ctxBlockNumber                 := shr(216, calldataload(add(contextPtr, 11)))

        }



        return BatchContext({

            numSequencedTransactions: numSequencedTransactions,

            numSubsequentQueueTransactions: numSubsequentQueueTransactions,

            timestamp: ctxTimestamp,

            blockNumber: ctxBlockNumber

        });

    }



    /**

     * Parses the batch context from the extra data.

     * @return Total number of elements submitted.

     * @return Index of the next queue element.

     */

    function _getBatchExtraDataByChainId(

        uint256 _chainId

        )

        internal

        view

        returns (

            uint40,

            uint40,

            uint40,

            uint40

        )

    {

        bytes27 extraData = batches().getGlobalMetadataByChainId(_chainId);



        uint40 totalElements;

        uint40 nextQueueIndex;

        uint40 lastTimestamp;

        uint40 lastBlockNumber;

        assembly {

            extraData       :=  shr(40, extraData)

            totalElements   :=  and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)

            nextQueueIndex  :=  shr(40, and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000))

            lastTimestamp   :=  shr(80, and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000))

            lastBlockNumber :=  shr(120, and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000))

        }



        return (

            totalElements,

            nextQueueIndex,

            lastTimestamp,

            lastBlockNumber

        );

    }



    /**

     * Encodes the batch context for the extra data.

     * @param _totalElements Total number of elements submitted.

     * @param _nextQueueIdx Index of the next queue element.

     * @param _timestamp Timestamp for the last batch.

     * @param _blockNumber Block number of the last batch.

     * @return Encoded batch context.

     */

    function _makeBatchExtraDataByChainId(

        uint256 _chainId,

        uint40 _totalElements,

        uint40 _nextQueueIdx,

        uint40 _timestamp,

        uint40 _blockNumber

    )

        internal

        pure

        returns (

            bytes27

        )

    {

        bytes27 extraData;

        assembly {

            extraData := _totalElements

            extraData := or(extraData, shl(40, _nextQueueIdx))

            extraData := or(extraData, shl(80, _timestamp))

            extraData := or(extraData, shl(120, _blockNumber))

            extraData := shl(40, extraData)

        }



        return extraData;

    }



    /**

     * Inserts a batch into the chain of batches.

     * @param _transactionRoot Root of the transaction tree for this batch.

     * @param _batchSize Number of elements in the batch.

     * @param _numQueuedTransactions Number of queue transactions in the batch.

     * @param _timestamp The latest batch timestamp.

     * @param _blockNumber The latest batch blockNumber.

     */

    function _appendBatchByChainId(

        uint256 _chainId,

        bytes32 _transactionRoot,

        uint256 _batchSize,

        uint256 _numQueuedTransactions,

        uint40 _timestamp,

        uint40 _blockNumber

    )

        internal

    {

	    IChainStorageContainer batchesRef = batches();

        (uint40 totalElements, uint40 nextQueueIndex, , ) = _getBatchExtraDataByChainId(_chainId);



        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({

            batchIndex: batchesRef.lengthByChainId(_chainId),

            batchRoot: _transactionRoot,

            batchSize: _batchSize,

            prevTotalElements: totalElements,

            extraData: hex""

        });



        emit TransactionBatchAppended(

            _chainId,

            header.batchIndex,

            header.batchRoot,

            header.batchSize,

            header.prevTotalElements,

            header.extraData

        );



        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);

        bytes27 latestBatchContext = _makeBatchExtraDataByChainId(

            _chainId,

            totalElements + uint40(header.batchSize),

            nextQueueIndex + uint40(_numQueuedTransactions),

            _timestamp,

            _blockNumber

        );



        batchesRef.pushByChainId(_chainId,batchHeaderHash, latestBatchContext);

    }



    modifier onlyManager() {

        require(

            msg.sender == resolve("MVM_SuperManager"),

            "ChainStorageContainer: Function can only be called by the owner."

        );

        _;

    }



    function pushQueueByChainId(

        uint256 _chainId,

        Lib_OVMCodec.QueueElement calldata _object

    )

        override

        public

        onlyManager

    {

        queueElements[_chainId].push(_object);

        emit QueuePushed(msg.sender,_chainId,_object);

    }



    function setQueueByChainId(

        uint256 _chainId,

        uint256 _index,

        Lib_OVMCodec.QueueElement calldata _object

    )

        override

        public

        onlyManager

    {

        queueElements[_chainId][_index] = _object;

        emit QueueSetted(msg.sender,_chainId,_index,_object);

    }



    function setBatchGlobalMetadataByChainId(

        uint256 _chainId,

        bytes27 _globalMetadata

    )

        override

        public

        onlyManager

    {

        batches().setGlobalMetadataByChainId(_chainId,_globalMetadata);

        emit BatchesGlobalMetadataSet(msg.sender,_chainId,_globalMetadata);

    }



    function getBatchGlobalMetadataByChainId(uint256 _chainId)

        override

        public

        view

        returns (

            bytes27

        )

    {

        return batches().getGlobalMetadataByChainId(_chainId);

    }



    function lengthBatchByChainId(uint256 _chainId)

        override

        public

        view

        returns (

            uint256

        )

    {

        return batches().lengthByChainId(_chainId);

    }



    function pushBatchByChainId(

        uint256 _chainId,

        bytes32 _object,

        bytes27 _globalMetadata

    )

        override

        public

        onlyManager

    {

        batches().pushByChainId(_chainId,_object,_globalMetadata);

        emit BatchPushed(msg.sender,_chainId,_object,_globalMetadata);

    }



    function setBatchByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes32 _object

    )

        override

        public

        onlyManager

    {

        batches().setByChainId(_chainId,_index,_object);

        emit BatchSetted(msg.sender,_chainId,_index,_object);

    }



    function getBatchByChainId(

        uint256 _chainId,

        uint256 _index

    )

        override

        public

        view

        returns (

            bytes32

        )

    {

        return batches().getByChainId(_chainId,_index);

    }



    function deleteBatchElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    )

        override

        public

        onlyManager

    {

        batches().deleteElementsAfterInclusiveByChainId(

            _chainId,

            _index,

            _globalMetadata

        );

        emit BatchElementDeleted(msg.sender,_chainId,_index,_globalMetadata);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\ChainStorageContainer.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_Buffer } from "../../libraries/utils/Lib_Buffer.sol";

import { Lib_AddressResolver } from "../../libraries/resolver/Lib_AddressResolver.sol";



/* Interface Imports */

import { IChainStorageContainer } from "./IChainStorageContainer.sol";



/**

 * @title ChainStorageContainer

 * @dev The Chain Storage Container provides its owner contract with read, write and delete

 * functionality. This provides gas efficiency gains by enabling it to overwrite storage slots which

 * can no longer be used in a fraud proof due to the fraud window having passed, and the associated

 * chain state or transactions being finalized.

 * Three distinct Chain Storage Containers will be deployed on Layer 1:

 * 1. Stores transaction batches for the Canonical Transaction Chain

 * 2. Stores queued transactions for the Canonical Transaction Chain

 * 3. Stores chain state batches for the State Commitment Chain

 *

 * Runtime target: EVM

 */

contract ChainStorageContainer is IChainStorageContainer, Lib_AddressResolver {

    /*************

     * Libraries *

     *************/



    using Lib_Buffer for Lib_Buffer.Buffer;



    /**************

     *  constant  *

     **************/

    uint256 constant public DEFAULT_CHAINID = 1088;

    

    

    /*************

     * Variables *

     *************/



    string public owner;

    mapping(uint256=>Lib_Buffer.Buffer) internal buffers;



    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Address Manager.

     * @param _owner Name of the contract that owns this container (will be resolved later).

     */

    constructor(address _libAddressManager, string memory _owner)

        Lib_AddressResolver(_libAddressManager)

    {

        owner = _owner;

    }



    /**********************

     * Function Modifiers *

     **********************/



    modifier onlyOwner() {

        require(

            msg.sender == resolve(owner),

            "ChainStorageContainer: Function can only be called by the owner."

        );

        _;

    }



    /********************

     * Public Functions *

     ********************/



    /**

     * @inheritdoc IChainStorageContainer

     */

    function setGlobalMetadata(bytes27 _globalMetadata) public onlyOwner {

        return setGlobalMetadataByChainId(DEFAULT_CHAINID,_globalMetadata);

    }

    

    function setByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes32 _object

    )

        override

        public

        onlyOwner

    {

        buffers[_chainId].set(_index, _object);

    }

    

    /**

     * @inheritdoc IChainStorageContainer

     */

    function setGlobalMetadataByChainId(

        uint256 _chainId,

        bytes27 _globalMetadata

    )

        override

        public

        onlyOwner

    {

        return buffers[_chainId].setExtraData(_globalMetadata);

    }

    

    /**

     * @inheritdoc IChainStorageContainer

     */

    function getGlobalMetadata() public view returns (bytes27) {

        return getGlobalMetadataByChainId(DEFAULT_CHAINID);

    }

    

    function getGlobalMetadataByChainId(uint256 _chainId)

        override

        public

        view

        returns (

            bytes27

        )

    {

        return buffers[_chainId].getExtraData();

    }



    /**

     * @inheritdoc IChainStorageContainer

     */

    function length() public view returns (uint256) {

        return lengthByChainId(DEFAULT_CHAINID);

    }

    

    function lengthByChainId(uint256 _chainId)

        override

        public

        view

        returns (

            uint256

        )

    {

        return uint256(buffers[_chainId].getLength());

    }



    /**

     * @inheritdoc IChainStorageContainer

     */

    function push(bytes32 _object) public onlyOwner {

        pushByChainId(DEFAULT_CHAINID,_object);

    }

    

    function pushByChainId(

        uint256 _chainId,

        bytes32 _object

    )

        override

        public

        onlyOwner

    {

        buffers[_chainId].push(_object);

    }



    /**

     * @inheritdoc IChainStorageContainer

     */

    function push(bytes32 _object, bytes27 _globalMetadata) public onlyOwner {

        pushByChainId(DEFAULT_CHAINID,_object,_globalMetadata);

    }

    

    function pushByChainId(

        uint256 _chainId,

        bytes32 _object,

        bytes27 _globalMetadata

    )

        override

        public

        onlyOwner

    {

        buffers[_chainId].push(_object, _globalMetadata);

    }



    /**

     * @inheritdoc IChainStorageContainer

     */

    function get(uint256 _index) public view returns (bytes32) {

        return getByChainId(DEFAULT_CHAINID,_index);

    }

    

    function getByChainId(

        uint256 _chainId,

        uint256 _index

    )

        override

        public

        view

        returns (

            bytes32

        )

    {

        return buffers[_chainId].get(uint40(_index));

    }



    /**

     * @inheritdoc IChainStorageContainer

     */

    function deleteElementsAfterInclusive(uint256 _index) public onlyOwner {

        deleteElementsAfterInclusiveByChainId(DEFAULT_CHAINID,_index);

    }

    

    function deleteElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index

    )

        override

        public

        onlyOwner

    {

        buffers[_chainId].deleteElementsAfterInclusive(

            uint40(_index)

        );

    }



    /**

     * @inheritdoc IChainStorageContainer

     */

    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata)

        public

        onlyOwner

    {

        deleteElementsAfterInclusiveByChainId(DEFAULT_CHAINID,_index,_globalMetadata);

    }

    

    function deleteElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    )

        override

        public

        onlyOwner

    {

        buffers[_chainId].deleteElementsAfterInclusive(

            uint40(_index),

            _globalMetadata

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\ContextUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;

import "../proxy/utils/Initializable.sol";



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract ContextUpgradeable is Initializable {

    function __Context_init() internal initializer {

        __Context_init_unchained();

    }



    function __Context_init_unchained() internal initializer {

    }

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

    uint256[50] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\CrossDomainEnabled.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/* Interface Imports */

import { ICrossDomainMessenger } from "./ICrossDomainMessenger.sol";



/**

 * @title CrossDomainEnabled

 * @dev Helper contract for contracts performing cross-domain communications

 *

 * Compiler used: defined by inheriting contract

 * Runtime target: defined by inheriting contract

 */

contract CrossDomainEnabled {

    /*************

     * Variables *

     *************/



    // Messenger contract used to send and recieve messages from the other domain.

    address public messenger;





    /***************

     * Constructor *

     ***************/



    /**

     * @param _messenger Address of the CrossDomainMessenger on the current layer.

     */

    constructor(address _messenger) {

        messenger = _messenger;

    }



    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Enforces that the modified function is only callable by a specific cross-domain account.

     * @param _sourceDomainAccount The only account on the originating domain which is

     *  authenticated to call this function.

     */

    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {

        require(

            msg.sender == address(getCrossDomainMessenger()),

            "OVM_XCHAIN: messenger contract unauthenticated"

        );



        require(

            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,

            "OVM_XCHAIN: wrong sender of cross-domain message"

        );



        _;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Gets the messenger, usually from storage. This function is exposed in case a child contract

     * needs to override.

     * @return The address of the cross-domain messenger contract which should be used.

     */

    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {

        return ICrossDomainMessenger(messenger);

    }



    /**q

     * Sends a message to an account on another domain

     * @param _crossDomainTarget The intended recipient on the destination domain

     * @param _message The data to send to the target (usually calldata to a function with

     *  `onlyFromCrossDomainAccount()`)

     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.

     */

    function sendCrossDomainMessage(

        address _crossDomainTarget,

        uint32 _gasLimit,

        bytes memory _message,

        uint256 fee

    )

        internal

    {

        getCrossDomainMessenger().sendMessage{value:fee}(_crossDomainTarget, _message, _gasLimit);

    }



    /**

     * @notice Sends a message to an account on another domain

     * @param _chainId L2 chain id.

     * @param _crossDomainTarget The intended recipient on the destination domain

     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.

     * @param _message The data to send to the target (usually calldata to a function with `onlyFromCrossDomainAccount()`)

     */

    function sendCrossDomainMessageViaChainId(

        uint256 _chainId,

        address _crossDomainTarget,

        uint32 _gasLimit,

        bytes memory _message,

        uint256 fee

    ) internal {

        getCrossDomainMessenger().sendMessageViaChainId{value:fee}(_chainId, _crossDomainTarget, _message, _gasLimit);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\ERC165Checker.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * @dev Library used to query support of an interface declared via {IERC165}.

 *

 * Note that these functions return the actual result of the query: they do not

 * `revert` if an interface is not supported. It is up to the caller to decide

 * what to do in these cases.

 */

library ERC165Checker {

    // As per the EIP-165 spec, no interface should ever match 0xffffffff

    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;



    /**

     * @dev Returns true if `account` supports the {IERC165} interface,

     */

    function supportsERC165(address account) internal view returns (bool) {

        // Any contract that implements ERC165 must explicitly indicate support of

        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid

        return

            _supportsERC165Interface(account, type(IERC165).interfaceId) &&

            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);

    }



    /**

     * @dev Returns true if `account` supports the interface defined by

     * `interfaceId`. Support for {IERC165} itself is queried automatically.

     *

     * See {IERC165-supportsInterface}.

     */

    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {

        // query support of both ERC165 as per the spec and support of _interfaceId

        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);

    }



    /**

     * @dev Returns a boolean array where each value corresponds to the

     * interfaces passed in and whether they're supported or not. This allows

     * you to batch check interfaces for a contract where your expectation

     * is that some interfaces may not be supported.

     *

     * See {IERC165-supportsInterface}.

     *

     * _Available since v3.4._

     */

    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)

        internal

        view

        returns (bool[] memory)

    {

        // an array of booleans corresponding to interfaceIds and whether they're supported or not

        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);



        // query support of ERC165 itself

        if (supportsERC165(account)) {

            // query support of each interface in interfaceIds

            for (uint256 i = 0; i < interfaceIds.length; i++) {

                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);

            }

        }



        return interfaceIdsSupported;

    }



    /**

     * @dev Returns true if `account` supports all the interfaces defined in

     * `interfaceIds`. Support for {IERC165} itself is queried automatically.

     *

     * Batch-querying can lead to gas savings by skipping repeated checks for

     * {IERC165} support.

     *

     * See {IERC165-supportsInterface}.

     */

    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {

        // query support of ERC165 itself

        if (!supportsERC165(account)) {

            return false;

        }



        // query support of each interface in _interfaceIds

        for (uint256 i = 0; i < interfaceIds.length; i++) {

            if (!_supportsERC165Interface(account, interfaceIds[i])) {

                return false;

            }

        }



        // all interfaces supported

        return true;

    }



    /**

     * @notice Query if a contract implements an interface, does not check ERC165 support

     * @param account The address of the contract to query for support of an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @return true if the contract at account indicates support of the interface with

     * identifier interfaceId, false otherwise

     * @dev Assumes that account contains a contract that supports ERC165, otherwise

     * the behavior of this method is undefined. This precondition can be checked

     * with {supportsERC165}.

     * Interface identification is specified in ERC-165.

     */

    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {

        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);

        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);

        if (result.length < 32) return false;

        return success && abi.decode(result, (bool));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IBondManager.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title IBondManager

 */

interface IBondManager {

    /********************

     * Public Functions *

     ********************/



    function isCollateralized(address _who) external view returns (bool);

    function isCollateralizedByChainId(

        uint256 _chainId,

        address _who,

        address _prop

    ) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\ICanonicalTransactionChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/* Interface Imports */

import { IChainStorageContainer } from "./IChainStorageContainer.sol";



/**

 * @title ICanonicalTransactionChain

 */

interface ICanonicalTransactionChain {

    /**********

     * Events *

     **********/

    event QueueGlobalMetadataSet(

        address _sender,

        uint256 _chainId,

        bytes27 _globalMetadata

    );

    

    event QueuePushed(

        address _sender,

        uint256 _chainId,

        Lib_OVMCodec.QueueElement _object

    );



    event QueueSetted(

        address _sender,

        uint256 _chainId,

        uint256 _index,

        Lib_OVMCodec.QueueElement _object

    );



    event QueueElementDeleted(

        address _sender,

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    );



    event BatchesGlobalMetadataSet(

        address _sender,

        uint256 _chainId,

        bytes27 _globalMetadata

    );

    

    event BatchPushed(

        address _sender,

        uint256 _chainId,

        bytes32 _object,

        bytes27 _globalMetadata

    );



    event BatchSetted(

        address _sender,

        uint256 _chainId,

        uint256 _index,

        bytes32 _object

    );



    event BatchElementDeleted(

        address _sender,

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    );



    event L2GasParamsUpdated(

        uint256 l2GasDiscountDivisor,

        uint256 enqueueGasCost,

        uint256 enqueueL2GasPrepaid

    );



    event TransactionEnqueued(

        uint256 _chainId,

        address indexed _l1TxOrigin,

        address indexed _target,

        uint256 _gasLimit,

        bytes _data,

        uint256 indexed _queueIndex,

        uint256 _timestamp

    );



    event QueueBatchAppended(

        uint256 _chainId,

        uint256 _startingQueueIndex,

        uint256 _numQueueElements,

        uint256 _totalElements

    );



    event SequencerBatchAppended(

        uint256 _chainId,

        uint256 _startingQueueIndex,

        uint256 _numQueueElements,

        uint256 _totalElements

    );



    event TransactionBatchAppended(

        uint256 _chainId,

        uint256 indexed _batchIndex,

        bytes32 _batchRoot,

        uint256 _batchSize,

        uint256 _prevTotalElements,

        bytes _extraData

    );



    /***********

     * Structs *

     ***********/



    struct BatchContext {

        uint256 numSequencedTransactions;

        uint256 numSubsequentQueueTransactions;

        uint256 timestamp;

        uint256 blockNumber;

    }



    /*******************************

     * Authorized Setter Functions *

     *******************************/



    /**

     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.

     * The value of enqueueL2GasPrepaid is immediately updated as well.

     */

    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost) external;



    /********************

     * Public Functions *

     ********************/



    /**

     * Accesses the batch storage container.

     * @return Reference to the batch storage container.

     */

    function batches() external view returns (IChainStorageContainer);



    /**

     * Accesses the queue storage container.

     * @return Reference to the queue storage container.

     */

    function queue() external view returns (IChainStorageContainer);



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements() external view returns (uint256 _totalElements);



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches() external view returns (uint256 _totalBatches);



    /**

     * Returns the index of the next element to be enqueued.

     * @return Index for the next queue element.

     */

    function getNextQueueIndex() external view returns (uint40);



    /**

     * Gets the queue element at a particular index.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElement(uint256 _index)

        external

        view

        returns (Lib_OVMCodec.QueueElement memory _element);



    /**

     * Returns the timestamp of the last transaction.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestamp() external view returns (uint40);



    /**

     * Returns the blocknumber of the last transaction.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumber() external view returns (uint40);



    /**

     * Get the number of queue elements which have not yet been included.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElements() external view returns (uint40);



    /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @return Length of the queue.

     */

    function getQueueLength() external view returns (uint40);



    /**

     * Adds a transaction to the queue.

     * @param _target Target contract to send the transaction to.

     * @param _gasLimit Gas limit for the given transaction.

     * @param _data Transaction data.

     */

    function enqueue(

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    ) external;



    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatch(

        // uint40 _shouldStartAtElement,

        // uint24 _totalElementsToAppend,

        // BatchContext[] _contexts,

        // bytes[] _transactionDataFields

    )

        external;

        

    //added chain id function

    

    /**

     * Retrieves the total number of elements submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElementsByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint256 _totalElements

        );



    /**

     * Retrieves the total number of batches submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatchesByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint256 _totalBatches

        );



    /**

     * Returns the index of the next element to be enqueued.

     * @param _chainId identity for the l2 chain.

     * @return Index for the next queue element.

     */

    function getNextQueueIndexByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );



    /**

     * Gets the queue element at a particular index.

     * @param _chainId identity for the l2 chain.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElementByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external

        view

        returns (

            Lib_OVMCodec.QueueElement memory _element

        );



    /**

     * Returns the timestamp of the last transaction.

     * @param _chainId identity for the l2 chain.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestampByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );



    /**

     * Returns the blocknumber of the last transaction.

     * @param _chainId identity for the l2 chain.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumberByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );



    /**

     * Get the number of queue elements which have not yet been included.

     * @param _chainId identity for the l2 chain.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElementsByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );



    /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @param _chainId identity for the l2 chain.

     * @return Length of the queue.

     */

    function getQueueLengthByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );





    /**

     * Adds a transaction to the queue.

     * @param _chainId identity for the l2 chain.

     * @param _target Target contract to send the transaction to.

     * @param _gasLimit Gas limit for the given transaction.

     * @param _data Transaction data.

     */

    function enqueueByChainId(

        uint256 _chainId,

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    )

        external;

        

    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _chainId identity for the l2 chain.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatchByChainId(

        // uint256 _chainId,

        // uint40 _shouldStartAtElement,

        // uint24 _totalElementsToAppend,

        // BatchContext[] _contexts,

        // bytes[] _transactionDataFields

    )

        external;

    

    function pushQueueByChainId(

        uint256 _chainId,

        Lib_OVMCodec.QueueElement calldata _object

    )

        external;



    function setQueueByChainId(

        uint256 _chainId,

        uint256 _index,

        Lib_OVMCodec.QueueElement calldata _object

    )

        external;



    function setBatchGlobalMetadataByChainId(

        uint256 _chainId,

        bytes27 _globalMetadata

    )

        external;

    

    function getBatchGlobalMetadataByChainId(uint256 _chainId)

        external

        view

        returns (

            bytes27

        );

        

    function lengthBatchByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256

        );

        

    function pushBatchByChainId(

        uint256 _chainId,

        bytes32 _object,

        bytes27 _globalMetadata

    )

        external;

    

    function setBatchByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes32 _object

    )

        external;

        

    function getBatchByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external

        view

        returns (

            bytes32

        );

        

    function deleteBatchElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    )

        external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IChainStorageContainer.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title IChainStorageContainer

 */

interface IChainStorageContainer {

    /********************

     * Public Functions *

     ********************/



    /**

     * Sets the container's global metadata field. We're using `bytes27` here because we use five

     * bytes to maintain the length of the underlying data structure, meaning we have an extra

     * 27 bytes to store arbitrary data.

     * @param _globalMetadata New global metadata to set.

     */

    function setGlobalMetadata(bytes27 _globalMetadata) external;



    /**

     * Retrieves the container's global metadata field.

     * @return Container global metadata field.

     */

    function getGlobalMetadata() external view returns (bytes27);



    /**

     * Retrieves the number of objects stored in the container.

     * @return Number of objects in the container.

     */

    function length() external view returns (uint256);



    /**

     * Pushes an object into the container.

     * @param _object A 32 byte value to insert into the container.

     */

    function push(bytes32 _object) external;



    /**

     * Pushes an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _object A 32 byte value to insert into the container.

     * @param _globalMetadata New global metadata for the container.

     */

    function push(bytes32 _object, bytes27 _globalMetadata) external;



    /**

     * Set an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _index position.

     * @param _object A 32 byte value to insert into the container.

     */  

    function setByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes32 _object

    )

        external;

        

    /**

     * Retrieves an object from the container.

     * @param _index Index of the particular object to access.

     * @return 32 byte object value.

     */

    function get(uint256 _index) external view returns (bytes32);



    /**

     * Removes all objects after and including a given index.

     * @param _index Object index to delete from.

     */

    function deleteElementsAfterInclusive(uint256 _index) external;



    /**

     * Removes all objects after and including a given index. Also allows setting the global

     * metadata field.

     * @param _index Object index to delete from.

     * @param _globalMetadata New global metadata for the container.

     */

    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;



    /**

     * Sets the container's global metadata field. We're using `bytes27` here because we use five

     * bytes to maintain the length of the underlying data structure, meaning we have an extra

     * 27 bytes to store arbitrary data.

     * @param _chainId identity for the l2 chain.

     * @param _globalMetadata New global metadata to set.

     */

    function setGlobalMetadataByChainId(

        uint256 _chainId,

        bytes27 _globalMetadata

    )

        external;



    /**

     * Retrieves the container's global metadata field.

     * @param _chainId identity for the l2 chain.

     * @return Container global metadata field.

     */

    function getGlobalMetadataByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            bytes27

        );



    /**

     * Retrieves the number of objects stored in the container.

     * @param _chainId identity for the l2 chain.

     * @return Number of objects in the container.

     */

    function lengthByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint256

        );



    /**

     * Pushes an object into the container.

     * @param _chainId identity for the l2 chain.

     * @param _object A 32 byte value to insert into the container.

     */

    function pushByChainId(

        uint256 _chainId,

        bytes32 _object

    )

        external;



    /**

     * Pushes an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _chainId identity for the l2 chain.

     * @param _object A 32 byte value to insert into the container.

     * @param _globalMetadata New global metadata for the container.

     */

    function pushByChainId(

        uint256 _chainId,

        bytes32 _object,

        bytes27 _globalMetadata

    )

        external;



    /**

     * Retrieves an object from the container.

     * @param _chainId identity for the l2 chain.

     * @param _index Index of the particular object to access.

     * @return 32 byte object value.

     */

    function getByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external

        view

        returns (

            bytes32

        );



    /**

     * Removes all objects after and including a given index.

     * @param _chainId identity for the l2 chain.

     * @param _index Object index to delete from.

     */

    function deleteElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external;

        

    /**

     * Removes all objects after and including a given index. Also allows setting the global

     * metadata field.

     * @param _chainId identity for the l2 chain.

     * @param _index Object index to delete from.

     * @param _globalMetadata New global metadata for the container.

     */

    function deleteElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    )

        external;

        

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\ICrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title ICrossDomainMessenger

 */

interface ICrossDomainMessenger {

    /**********

     * Events *

     **********/



    event SentMessage(

        address indexed target,

        address sender,

        bytes message,

        uint256 messageNonce,

        uint256 gasLimit,

        uint256 chainId

    );

    event RelayedMessage(bytes32 indexed msgHash);

    event FailedRelayedMessage(bytes32 indexed msgHash);



    /*************

     * Variables *

     *************/



    function xDomainMessageSender() external view returns (address);



    /********************

     * Public Functions *

     ********************/

    

    /**

     * Sends a cross domain message to the target messenger.

     * @param _target Target contract address.

     * @param _message Message to send to the target.

     * @param _gasLimit Gas limit for the provided message.

     */

    function sendMessage(

        address _target,

        bytes calldata _message,

        uint32 _gasLimit

    ) external payable;





    /**

     * Sends a cross domain message to the target messenger.

     * @param _chainId L2 chain id.

     * @param _target Target contract address.

     * @param _message Message to send to the target.

     * @param _gasLimit Gas limit for the provided message.

     */

    function sendMessageViaChainId(

        uint256 _chainId,

        address _target,

        bytes calldata _message,

        uint32 _gasLimit

    ) external payable;



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\iL1ChugSplashDeployer.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title iL1ChugSplashDeployer

 */

interface iL1ChugSplashDeployer {

    function isUpgrading() external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IL1CrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";



/* Interface Imports */

import { ICrossDomainMessenger } from "../../libraries/bridge/ICrossDomainMessenger.sol";



/**

 * @title IL1CrossDomainMessenger

 */

interface IL1CrossDomainMessenger is ICrossDomainMessenger {

    /*******************

     * Data Structures *

     *******************/



    struct L2MessageInclusionProof {

        bytes32 stateRoot;

        Lib_OVMCodec.ChainBatchHeader stateRootBatchHeader;

        Lib_OVMCodec.ChainInclusionProof stateRootProof;

        bytes stateTrieWitness;

        bytes storageTrieWitness;

    }



    /********************

     * Public Functions *

     ********************/



    /**

     * Relays a cross domain message to a contract.

     * @param _target Target contract address.

     * @param _sender Message sender address.

     * @param _message Message to send to the target.

     * @param _messageNonce Nonce for the provided message.

     * @param _proof Inclusion proof for the given message.

     */

    function relayMessage(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _messageNonce,

        L2MessageInclusionProof memory _proof

    ) external;



    /**

     * Replays a cross domain message to the target messenger.

     * @param _target Target contract address.

     * @param _sender Original sender address.

     * @param _message Message to send to the target.

     * @param _queueIndex CTC Queue index for the message to replay.

     * @param _oldGasLimit Original gas limit used to send the message.

     * @param _newGasLimit New gas limit to be used for this message.

     */

    function replayMessage(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _queueIndex,

        uint32 _oldGasLimit,

        uint32 _newGasLimit

    ) external payable;



    /**

     * Relays a cross domain message to a contract with L2 chain id.

     * @param _chainId L2 chain id.

     * @param _target Target contract address.

     * @param _sender Message sender address.

     * @param _message Message to send to the target.

     * @param _messageNonce Nonce for the provided message.

     * @param _proof Inclusion proof for the given message.

     */

    function relayMessageViaChainId(

        uint256 _chainId,

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _messageNonce,

        L2MessageInclusionProof memory _proof

    ) external;



    /**

     * Replays a cross domain message to the target messenger with L2 chain id.

     * @param _chainId L2 chain id.

     * @param _target Target contract address.

     * @param _sender Original sender address.

     * @param _message Message to send to the target.

     * @param _oldGasLimit Original gas limit used to send the message.

     * @param _newGasLimit New gas limit to be used for this message.

     */

    function replayMessageViaChainId(

        uint256 _chainId,

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _queueIndex,

        uint32 _oldGasLimit,

        uint32 _newGasLimit

    ) external payable;



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IL1ERC20Bridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title IL1ERC20Bridge

 */

interface IL1ERC20Bridge {

    /**********

     * Events *

     **********/



    event ERC20DepositInitiated(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event ERC20WithdrawalFinalized(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event ERC20ChainID(uint256 _chainid);

    

    /********************

     * Public Functions *

     ********************/



    /**

     * @dev get the address of the corresponding L2 bridge contract.

     * @return Address of the corresponding L2 bridge contract.

     */

    function l2TokenBridge() external returns (address);



    /**

     * @dev deposit an amount of the ERC20 to the caller's balance on L2.

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _amount Amount of the ERC20 to deposit

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20(

        address _l1Token,

        address _l2Token,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external;



    /**

     * @dev deposit an amount of ERC20 to a recipient's balance on L2.

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _to L2 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20To(

        address _l1Token,

        address _l2Token,

        address _to,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external;

    

    /**

     * @dev deposit an amount of the ERC20 to the caller's balance on L2.

     * @param _chainid chainid

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _amount Amount of the ERC20 to deposit

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20ByChainId (

        uint256 _chainid,

        address _l1Token,

        address _l2Token,

        uint _amount,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external payable;



    /**

     * @dev deposit an amount of ERC20 to a recipient's balance on L2.

     * @param _chainid chainid

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _to L2 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20ToByChainId (

        uint256 _chainid,

        address _l1Token,

        address _l2Token,

        address _to,

        uint _amount,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external payable;

    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the

     * L1 ERC20 token.

     * This call will fail if the initialized withdrawal from L2 has not been finalized.

     *

     * @param _l1Token Address of L1 token to finalizeWithdrawal for.

     * @param _l2Token Address of L2 token where withdrawal was initiated.

     * @param _from L2 address initiating the transfer.

     * @param _to L1 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _data Data provided by the sender on L2. This data is provided

     *   solely as a convenience for external contracts. Aside from enforcing a maximum

     *   length, these contracts provide no guarantees about its content.

     */

    function finalizeERC20Withdrawal(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external;

    

    /**

     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the

     * L1 ERC20 token.

     * This call will fail if the initialized withdrawal from L2 has not been finalized.

     *

     * @param _chainid chainid

     * @param _l1Token Address of L1 token to finalizeWithdrawal for.

     * @param _l2Token Address of L2 token where withdrawal was initiated.

     * @param _from L2 address initiating the transfer.

     * @param _to L1 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _data Data provided by the sender on L2. This data is provided

     *   solely as a convenience for external contracts. Aside from enforcing a maximum

     *   length, these contracts provide no guarantees about its content.

     */    

     function finalizeERC20WithdrawalByChainId (

        uint256 _chainid,

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint _amount,

        bytes calldata _data

    )

        external;

    /**

     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the

     * L1 ERC20 token.

     * This call will fail if the initialized withdrawal from L2 has not been finalized.

     *

     * @param _chainid chainid

     * @param _from L2 address initiating the transfer.

     * @param _to L1 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _data Data provided by the sender on L2. This data is provided

     *   solely as a convenience for external contracts. Aside from enforcing a maximum

     *   length, these contracts provide no guarantees about its content.

     */    

    function finalizeMetisWithdrawalByChainId (

        uint256 _chainid,

        address _from,

        address _to,

        uint _amount,

        bytes calldata _data

    )

        external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IL1StandardBridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



import "./IL1ERC20Bridge.sol";



/**

 * @title IL1StandardBridge

 */

interface IL1StandardBridge is IL1ERC20Bridge {

    /**********

     * Events *

     **********/

    event ETHDepositInitiated(

        address indexed _from,

        address indexed _to,

        uint256 _amount,

        bytes _data,

        uint256 chainId

    );



    event ETHWithdrawalFinalized(

        address indexed _from,

        address indexed _to,

        uint256 _amount,

        bytes _data,

        uint256 chainId

    );



    /********************

     * Public Functions *

     ********************/



    /**

     * @dev Deposit an amount of the ETH to the caller's balance on L2.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;



    /**

     * @dev Deposit an amount of ETH to a recipient's balance on L2.

     * @param _to L2 address to credit the withdrawal to.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositETHTo(

        address _to,

        uint32 _l2Gas,

        bytes calldata _data

    ) external payable;

    

    

    function depositETHByChainId (

        uint256 _chainId,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external

        payable;

        

    function depositETHToByChainId (

        uint256 _chainId,

        address _to,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external

        payable;



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the

     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called

     * before the withdrawal is finalized.

     * @param _from L2 address initiating the transfer.

     * @param _to L1 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function finalizeETHWithdrawal(

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external;

    

    function finalizeETHWithdrawalByChainId (

        uint256 _chainId,

        address _from,

        address _to,

        uint _amount,

        bytes calldata _data

    )

        external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IL2ERC20Bridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title IL2ERC20Bridge

 */

interface IL2ERC20Bridge {

    /**********

     * Events *

     **********/



    event WithdrawalInitiated(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event DepositFinalized(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event DepositFailed(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    /********************

     * Public Functions *

     ********************/



    /**

     * @dev get the address of the corresponding L1 bridge contract.

     * @return Address of the corresponding L1 bridge contract.

     */

    function l1TokenBridge() external returns (address);



    /**

     * @dev initiate a withdraw of some tokens to the caller's account on L1

     * @param _l2Token Address of L2 token where withdrawal was initiated.

     * @param _amount Amount of the token to withdraw.

     * param _l1Gas Unused, but included for potential forward compatibility considerations.

     * @param _data Optional data to forward to L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function withdraw(

        address _l2Token,

        uint256 _amount,

        uint32 _l1Gas,

        bytes calldata _data

    ) external payable;



    /**

     * @dev initiate a withdraw of some token to a recipient's account on L1.

     * @param _l2Token Address of L2 token where withdrawal is initiated.

     * @param _to L1 adress to credit the withdrawal to.

     * @param _amount Amount of the token to withdraw.

     * param _l1Gas Unused, but included for potential forward compatibility considerations.

     * @param _data Optional data to forward to L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function withdrawTo(

        address _l2Token,

        address _to,

        uint256 _amount,

        uint32 _l1Gas,

        bytes calldata _data

    ) external payable;



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this

     * L2 token. This call will fail if it did not originate from a corresponding deposit in

     * L1StandardTokenBridge.

     * @param _l1Token Address for the l1 token this is called with

     * @param _l2Token Address for the l2 token this is called with

     * @param _from Account to pull the deposit from on L2.

     * @param _to Address to receive the withdrawal at

     * @param _amount Amount of the token to withdraw

     * @param _data Data provider by the sender on L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function finalizeDeposit(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IL2StandardERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";



interface IL2StandardERC20 is IERC20, IERC165 {

    function l1Token() external returns (address);



    function mint(address _to, uint256 _amount) external;



    function burn(address _from, uint256 _amount) external;



    event Mint(address indexed _account, uint256 _amount);

    event Burn(address indexed _account, uint256 _amount);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\iMVM_DiscountOracle.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



interface iMVM_DiscountOracle{



    function setDiscount(

        uint256 _discount

    ) external;

    

    function setMinL2Gas(

        uint256 _minL2Gas

    ) external;

    

    function setWhitelistedXDomainSender(

        address _sender,

        bool _isWhitelisted

    ) external;

    

    function isXDomainSenderAllowed(

        address _sender

    ) view external returns(bool);

    

    function setAllowAllXDomainSenders(

        bool _allowAllXDomainSenders

    ) external;

    

    function getMinL2Gas() view external returns(uint256);

    function getDiscount() view external returns(uint256);

    function processL2SeqGas(address sender, uint256 _chainId) external payable;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\iMVM_L2ChainManagerOnL1.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

pragma experimental ABIEncoderV2;



/* Interface Imports */



/* External Imports */



/**

 * @title MVM_L2ChainManagerOnL1

 * @dev if want support multi l2 chain on l1,it should add a manager to desc 

 * how many l2 chain now ,and dispatch the l2 chain id to make it is unique.

 *

 * Compiler used: solc

 * Runtime target: EVM

 */

interface iMVM_L2ChainManagerOnL1 {



    event SwitchSeq (uint256 chainid, address wallet, address manager);

    event PushConfig (uint256 chainid, bytes configs);

   

    

    /********************

     * Public Functions *

     ********************/

    function switchSequencer(uint256 _chainId, address wallet, address manager) external payable;

    function pushConfig(uint256 _chainId, bytes calldata configs) external payable;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Initializable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed

 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an

 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer

 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.

 *

 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as

 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.

 *

 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure

 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.

 */

abstract contract Initializable {

    /**

     * @dev Indicates that the contract has been initialized.

     */

    bool private _initialized;



    /**

     * @dev Indicates that the contract is in the process of being initialized.

     */

    bool private _initializing;



    /**

     * @dev Modifier to protect an initializer function from being invoked twice.

     */

    modifier initializer() {

        require(_initializing || !_initialized, "Initializable: contract is already initialized");



        bool isTopLevelCall = !_initializing;

        if (isTopLevelCall) {

            _initializing = true;

            _initialized = true;

        }



        _;



        if (isTopLevelCall) {

            _initializing = false;

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\iOVM_SequencerFeeVault.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_PredeployAddresses } from "../../libraries/constants/Lib_PredeployAddresses.sol";



/* Contract Imports */

import { L2StandardBridge } from "../messaging/L2StandardBridge.sol";

import { CrossDomainEnabled } from "../../libraries/bridge/CrossDomainEnabled.sol";



/**

 * @title OVM_SequencerFeeVault

 * @dev Simple holding contract for fees paid to the Sequencer. Likely to be replaced in the future

 * but "good enough for now".

 */

interface iOVM_SequencerFeeVault {

    /*************

     * Constants *

     *************/



    event ChainSwitch (address l1Wallet, address l2Manager);

    event ConfigChange(bytes config);



    /********************

     * Public Functions *

     ********************/



    function withdraw(uint256 amount) external payable;

    

    function finalizeChainSwitch(address _FeeWallet, address _L2Manager) external;

    

    function finalizeChainConfig(bytes calldata config) external;

    function send(address payable to, uint256 amount) external;

    

    function sendBatch(address payable[] calldata tos, uint256[] calldata amounts) external;

    function getL2Manager() view external returns(address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\IStateCommitmentChain.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/* Library Imports */

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";

import { IChainStorageContainer } from "./IChainStorageContainer.sol";



/**

 * @title IStateCommitmentChain

 */

interface IStateCommitmentChain {

    /**********

     * Events *

     **********/



    event StateBatchAppended(

        uint256 _chainId,

        uint256 indexed _batchIndex,

        bytes32 _batchRoot,

        uint256 _batchSize,

        uint256 _prevTotalElements,

        bytes _extraData

    );



    event StateBatchDeleted(

        uint256 _chainId,

        uint256 indexed _batchIndex,

        bytes32 _batchRoot

    );





    /********************

     * Public Functions *

     ********************/

    

    function batches() external view returns (IChainStorageContainer);

    

    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements() external view returns (uint256 _totalElements);



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches() external view returns (uint256 _totalBatches);



    /**

     * Retrieves the timestamp of the last batch submitted by the sequencer.

     * @return _lastSequencerTimestamp Last sequencer batch timestamp.

     */

    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);



    /**

     * Appends a batch of state roots to the chain.

     * @param _batch Batch of state roots.

     * @param _shouldStartAtElement Index of the element at which this batch should start.

     */

    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;



    /**

     * Deletes all state roots after (and including) a given batch.

     * @param _batchHeader Header of the batch to start deleting from.

     */

    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) external;



    /**

     * Verifies a batch inclusion proof.

     * @param _element Hash of the element to verify a proof for.

     * @param _batchHeader Header of the batch in which the element was included.

     * @param _proof Merkle inclusion proof for the element.

     */

    function verifyStateCommitment(

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    ) external view returns (bool _verified);



    /**

     * Checks whether a given batch is still inside its fraud proof window.

     * @param _batchHeader Header of the batch to check.

     * @return _inside Whether or not the batch is inside the fraud proof window.

     */

    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)

        external

        view

        returns (

            bool _inside

        );

        

        

        

     /********************

     * chain id added func *

     ********************/



    /**

     * Retrieves the total number of elements submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElementsByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256 _totalElements

        );



    /**

     * Retrieves the total number of batches submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatchesByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256 _totalBatches

        );



    /**

     * Retrieves the timestamp of the last batch submitted by the sequencer.

     * @param _chainId identity for the l2 chain.

     * @return _lastSequencerTimestamp Last sequencer batch timestamp.

     */

    function getLastSequencerTimestampByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256 _lastSequencerTimestamp

        );

        

    /**

     * Appends a batch of state roots to the chain.

     * @param _chainId identity for the l2 chain.

     * @param _batch Batch of state roots.

     * @param _shouldStartAtElement Index of the element at which this batch should start.

     */

    function appendStateBatchByChainId(

        uint256 _chainId,

        bytes32[] calldata _batch,

        uint256 _shouldStartAtElement,

        string calldata proposer

    )

        external;



    /**

     * Deletes all state roots after (and including) a given batch.

     * @param _chainId identity for the l2 chain.

     * @param _batchHeader Header of the batch to start deleting from.

     */

    function deleteStateBatchByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        external;



    /**

     * Verifies a batch inclusion proof.

     * @param _chainId identity for the l2 chain.

     * @param _element Hash of the element to verify a proof for.

     * @param _batchHeader Header of the batch in which the element was included.

     * @param _proof Merkle inclusion proof for the element.

     */

    function verifyStateCommitmentByChainId(

        uint256 _chainId,

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    )

        external

        view

        returns (

            bool _verified

        );



    /**

     * Checks whether a given batch is still inside its fraud proof window.

     * @param _chainId identity for the l2 chain.

     * @param _batchHeader Header of the batch to check.

     * @return _inside Whether or not the batch is inside the fraud proof window.

     */

    function insideFraudProofWindowByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        external

        view

        returns (

            bool _inside

        );

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\L1ChugSplashProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



import { iL1ChugSplashDeployer } from "./interfaces/iL1ChugSplashDeployer.sol";



/**

 * @title L1ChugSplashProxy

 * @dev Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added

 * functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty!

 *

 * Note for future developers: do NOT make anything in this contract 'public' unless you know what

 * you're doing. Anything public can potentially have a function signature that conflicts with a

 * signature attached to the implementation contract. Public functions SHOULD always have the

 * 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that

 * modifier. And there almost certainly is not a good reason to not have that modifier. Beware!

 */

contract L1ChugSplashProxy {



    /*************

     * Constants *

     *************/



    // "Magic" prefix. When prepended to some arbitrary bytecode and used to create a contract, the

    // appended bytecode will be deployed as given.

    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;



    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)

    bytes32 internal constant IMPLEMENTATION_KEY =

        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)

    bytes32 internal constant OWNER_KEY =

        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



    /***************

     * Constructor *

     ***************/



    /**

     * @param _owner Address of the initial contract owner.

     */

    constructor(address _owner) {

        _setOwner(_owner);

    }



    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Blocks a function from being called when the parent signals that the system should be paused

     * via an isUpgrading function.

     */

    modifier onlyWhenNotPaused() {

        address owner = _getOwner();



        // We do a low-level call because there's no guarantee that the owner actually *is* an

        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and

        // it turns out that it isn't the right type of contract.

        (bool success, bytes memory returndata) = owner.staticcall(

            abi.encodeWithSelector(iL1ChugSplashDeployer.isUpgrading.selector)

        );



        // If the call was unsuccessful then we assume that there's no "isUpgrading" method and we

        // can just continue as normal. We also expect that the return value is exactly 32 bytes

        // long. If this isn't the case then we can safely ignore the result.

        if (success && returndata.length == 32) {

            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the

            // case that the isUpgrading function returned something other than 0 or 1. But we only

            // really care about the case where this value is 0 (= false).

            uint256 ret = abi.decode(returndata, (uint256));

            require(ret == 0, "L1ChugSplashProxy: system is currently being upgraded");

        }



        _;

    }



    /**

     * Makes a proxy call instead of triggering the given function when the caller is either the

     * owner or the zero address. Caller can only ever be the zero address if this function is

     * being called off-chain via eth_call, which is totally fine and can be convenient for

     * client-side tooling. Avoids situations where the proxy and implementation share a sighash

     * and the proxy function ends up being called instead of the implementation one.

     *

     * Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If there's a

     * way for someone to send a transaction with msg.sender == address(0) in any real context then

     * we have much bigger problems. Primary reason to include this additional allowed sender is

     * because the owner address can be changed dynamically and we do not want clients to have to

     * keep track of the current owner in order to make an eth_call that doesn't trigger the

     * proxied contract.

     */

    modifier proxyCallIfNotOwner() {

        if (msg.sender == _getOwner() || msg.sender == address(0)) {

            _;

        } else {

            // This WILL halt the call frame on completion.

            _doProxyCall();

        }

    }





    /*********************

     * Fallback Function *

     *********************/



    fallback() external payable {

        // Proxy call by default.

        _doProxyCall();

    }





    /********************

     * Public Functions *

     ********************/



    /**

     * Sets the code that should be running behind this proxy. Note that this scheme is a bit

     * different from the standard proxy scheme where one would typically deploy the code

     * separately and then set the implementation address. We're doing it this way because it gives

     * us a lot more freedom on the client side. Can only be triggered by the contract owner.

     * @param _code New contract code to run inside this contract.

     */

    function setCode(bytes memory _code) public proxyCallIfNotOwner {

        // Get the code hash of the current implementation.

        address implementation = _getImplementation();



        // If the code hash matches the new implementation then we return early.

        if (keccak256(_code) == _getAccountCodeHash(implementation)) {

            return;

        }



        // Create the deploycode by appending the magic prefix.

        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);



        // Deploy the code and set the new implementation address.

        address newImplementation;

        assembly {

            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))

        }



        // Check that the code was actually deployed correctly. I'm not sure if you can ever

        // actually fail this check. Should only happen if the contract creation from above runs

        // out of gas but this parent execution thread does NOT run out of gas. Seems like we

        // should be doing this check anyway though.

        require(

            _getAccountCodeHash(newImplementation) == keccak256(_code),

            "L1ChugSplashProxy: code was not correctly deployed."

        );



        _setImplementation(newImplementation);

    }



    /**

     * Modifies some storage slot within the proxy contract. Gives us a lot of power to perform

     * upgrades in a more transparent way. Only callable by the owner.

     * @param _key Storage key to modify.

     * @param _value New value for the storage key.

     */

    function setStorage(bytes32 _key, bytes32 _value) public proxyCallIfNotOwner {

        assembly {

            sstore(_key, _value)

        }

    }



    /**

     * Changes the owner of the proxy contract. Only callable by the owner.

     * @param _owner New owner of the proxy contract.

     */

    function setOwner(address _owner) public proxyCallIfNotOwner {

        _setOwner(_owner);

    }



    /**

     * Queries the owner of the proxy contract. Can only be called by the owner OR by making an

     * eth_call and setting the "from" address to address(0).

     * @return Owner address.

     */

    function getOwner() public proxyCallIfNotOwner returns (address) {

        return _getOwner();

    }



    /**

     * Queries the implementation address. Can only be called by the owner OR by making an

     * eth_call and setting the "from" address to address(0).

     * @return Implementation address.

     */

    function getImplementation() public proxyCallIfNotOwner returns (address) {

        return _getImplementation();

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Sets the implementation address.

     * @param _implementation New implementation address.

     */

    function _setImplementation(address _implementation) internal {

        assembly {

            sstore(IMPLEMENTATION_KEY, _implementation)

        }

    }



    /**

     * Queries the implementation address.

     * @return Implementation address.

     */

    function _getImplementation() internal view returns (address) {

        address implementation;

        assembly {

            implementation := sload(IMPLEMENTATION_KEY)

        }

        return implementation;

    }



    /**

     * Changes the owner of the proxy contract.

     * @param _owner New owner of the proxy contract.

     */

    function _setOwner(address _owner) internal {

        assembly {

            sstore(OWNER_KEY, _owner)

        }

    }



    /**

     * Queries the owner of the proxy contract.

     * @return Owner address.

     */

    function _getOwner() internal view returns (address) {

        address owner;

        assembly {

            owner := sload(OWNER_KEY)

        }

        return owner;

    }



    /**

     * Gets the code hash for a given account.

     * @param _account Address of the account to get a code hash for.

     * @return Code hash for the account.

     */

    function _getAccountCodeHash(address _account) internal view returns (bytes32) {

        bytes32 codeHash;

        assembly {

            codeHash := extcodehash(_account)

        }

        return codeHash;

    }



    /**

     * Performs the proxy call via a delegatecall.

     */

    function _doProxyCall() internal onlyWhenNotPaused {

        address implementation = _getImplementation();



        require(implementation != address(0), "L1ChugSplashProxy: implementation is not set yet");



        assembly {

            // Copy calldata into memory at 0x0....calldatasize.

            calldatacopy(0x0, 0x0, calldatasize())



            // Perform the delegatecall, make sure to pass all available gas.

            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)



            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*

            // overwrite the calldata that we just copied into memory but that doesn't really

            // matter because we'll be returning in a second anyway.

            returndatacopy(0x0, 0x0, returndatasize())



            // Success == 0 means a revert. We'll revert too and pass the data up.

            if iszero(success) {

                revert(0x0, returndatasize())

            }



            // Otherwise we'll just return and pass the data up.

            return(0x0, returndatasize())

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\L1CrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { AddressAliasHelper } from "../../standards/AddressAliasHelper.sol";

import { Lib_AddressResolver } from "../../libraries/resolver/Lib_AddressResolver.sol";

import { Lib_OVMCodec } from "../../libraries/codec/Lib_OVMCodec.sol";

import { Lib_AddressManager } from "../../libraries/resolver/Lib_AddressManager.sol";

import { Lib_SecureMerkleTrie } from "../../libraries/trie/Lib_SecureMerkleTrie.sol";

import { Lib_DefaultValues } from "../../libraries/constants/Lib_DefaultValues.sol";

import { Lib_PredeployAddresses } from "../../libraries/constants/Lib_PredeployAddresses.sol";

import { Lib_CrossDomainUtils } from "../../libraries/bridge/Lib_CrossDomainUtils.sol";



/* Interface Imports */

import { IL1CrossDomainMessenger } from "./IL1CrossDomainMessenger.sol";

import { ICanonicalTransactionChain } from "../rollup/ICanonicalTransactionChain.sol";

import { IStateCommitmentChain } from "../rollup/IStateCommitmentChain.sol";

import { iMVM_DiscountOracle } from "../../MVM/iMVM_DiscountOracle.sol";



/* External Imports */

import {

    OwnableUpgradeable

} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

import {

    PausableUpgradeable

} from "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";

import {

    ReentrancyGuardUpgradeable

} from "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";



/**

 * @title L1CrossDomainMessenger

 * @dev The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages

 * from L2 onto L1. In the event that a message sent from L1 to L2 is rejected for exceeding the L2

 * epoch gas limit, it can be resubmitted via this contract's replay function.

 *

 * Runtime target: EVM

 */

contract L1CrossDomainMessenger is

    IL1CrossDomainMessenger,

    Lib_AddressResolver,

    OwnableUpgradeable,

    PausableUpgradeable,

    ReentrancyGuardUpgradeable

{

    /**********

     * Events *

     **********/



    event MessageBlocked(bytes32 indexed _xDomainCalldataHash);



    event MessageAllowed(bytes32 indexed _xDomainCalldataHash);



    /**********************

     * Contract Variables *

     **********************/



    mapping(bytes32 => bool) public blockedMessages;

    mapping(bytes32 => bool) public relayedMessages;

    mapping(bytes32 => bool) public successfulMessages;



    address internal xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;

    uint256 constant DEFAULT_CHAINID = 1088;



    /***************

     * Constructor *

     ***************/



    /**

     * This contract is intended to be behind a delegate proxy.

     * We pass the zero address to the address resolver just to satisfy the constructor.

     * We still need to set this value in initialize().

     */

    constructor() Lib_AddressResolver(address(0)) {}



    /********************

     * Public Functions *

     ********************/



    /**

     * @param _libAddressManager Address of the Address Manager.

     */

    function initialize(address _libAddressManager) public initializer {

        require(

            address(libAddressManager) == address(0),

            "L1CrossDomainMessenger already intialized."

        );

        libAddressManager = Lib_AddressManager(_libAddressManager);

        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;



        // Initialize upgradable OZ contracts

        __Context_init_unchained(); // Context is a dependency for both Ownable and Pausable

        __Ownable_init_unchained();

        __Pausable_init_unchained();

        __ReentrancyGuard_init_unchained();

    }



    /**

     * Pause relaying.

     */

    function pause() external onlyOwner {

        _pause();

    }



    /**

     * Block a message.

     * @param _xDomainCalldataHash Hash of the message to block.

     */

    function blockMessage(bytes32 _xDomainCalldataHash) external onlyOwner {

        blockedMessages[_xDomainCalldataHash] = true;

        emit MessageBlocked(_xDomainCalldataHash);

    }



    /**

     * Allow a message.

     * @param _xDomainCalldataHash Hash of the message to block.

     */

    function allowMessage(bytes32 _xDomainCalldataHash) external onlyOwner {

        blockedMessages[_xDomainCalldataHash] = false;

        emit MessageAllowed(_xDomainCalldataHash);

    }



    function xDomainMessageSender() public view returns (address) {

        require(

            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,

            "xDomainMessageSender is not set"

        );

        return xDomainMsgSender;

    }



    /**

     * Sends a cross domain message to the target messenger.

     * @param _target Target contract address.

     * @param _message Message to send to the target.

     * @param _gasLimit Gas limit for the provided message.

     */

    function sendMessage(

        address _target,

        bytes memory _message,

        uint32 _gasLimit

    ) public payable {

        

        iMVM_DiscountOracle oracle = iMVM_DiscountOracle(resolve('MVM_DiscountOracle'));

        // this function will check against the whitelist and take the fee

        oracle.processL2SeqGas{value:msg.value}(msg.sender, DEFAULT_CHAINID);

        

        address ovmCanonicalTransactionChain = resolve("CanonicalTransactionChain");

        // Use the CTC queue length as nonce

        uint40 nonce = ICanonicalTransactionChain(ovmCanonicalTransactionChain).getQueueLength();



        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(

            _target,

            msg.sender,

            _message,

            nonce

        );



        _sendXDomainMessage(ovmCanonicalTransactionChain, xDomainCalldata, _gasLimit);



        emit SentMessage(_target, msg.sender, _message, nonce, _gasLimit, DEFAULT_CHAINID);

    }

    

    /**

     * Sends a cross domain message to the target messenger.

     * @param _chainId L2 chain id.

     * @param _target Target contract address.

     * @param _message Message to send to the target.

     * @param _gasLimit Gas limit for the provided message.

     */

    function sendMessageViaChainId(

        uint256 _chainId,

        address _target,

        bytes memory _message,

        uint32 _gasLimit

    )

        override

        payable

        public

    {

    

        iMVM_DiscountOracle oracle = iMVM_DiscountOracle(resolve('MVM_DiscountOracle'));

        

        // this function will check against the whitelist and take the fee

        oracle.processL2SeqGas{value:msg.value}(msg.sender, _chainId);

        

        address ovmCanonicalTransactionChain = resolve("CanonicalTransactionChain");

        

        // Use the CTC queue length as nonce

        uint40 nonce = ICanonicalTransactionChain(ovmCanonicalTransactionChain).getQueueLengthByChainId(_chainId);



        bytes memory xDomainCalldataRaw = Lib_CrossDomainUtils.encodeXDomainCalldata(

            _target,

            msg.sender,

            _message,

            nonce

        );

        

        _sendXDomainMessageViaChainId(

            _chainId,

            ovmCanonicalTransactionChain,

            xDomainCalldataRaw,

            _gasLimit

        );

        emit SentMessage(_target, msg.sender, _message, nonce, _gasLimit, _chainId);

    }



    /**

     * Relays a cross domain message to a contract.

     * @inheritdoc IL1CrossDomainMessenger

     */

    function relayMessage(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _messageNonce,

        L2MessageInclusionProof memory _proof

    ) public nonReentrant whenNotPaused {

        relayMessageViaChainId(DEFAULT_CHAINID, _target, _sender,

                               _message, _messageNonce, _proof);

    }



    /**

     * Replays a cross domain message to the target messenger.

     * @inheritdoc IL1CrossDomainMessenger

     */

    function replayMessage(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _queueIndex,

        uint32 _oldGasLimit,

        uint32 _newGasLimit

    ) public payable{

        replayMessageViaChainId(DEFAULT_CHAINID, _target, _sender, _message,

                                _queueIndex, _oldGasLimit, _newGasLimit);

    }

    

    function relayMessageViaChainId(

        uint256 _chainId,

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _messageNonce,

        L2MessageInclusionProof memory _proof

    )

        override

        public

        nonReentrant

        whenNotPaused

    {

        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(

            _target,

            _sender,

            _message,

            _messageNonce

        );

        require(

            _verifyXDomainMessageByChainId(

                _chainId,

                xDomainCalldata,

                _proof

            ) == true,

            "Provided message could not be verified."

        );



        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);



        require(

            successfulMessages[xDomainCalldataHash] == false,

            "Provided message has already been received."

        );



        require(

            blockedMessages[xDomainCalldataHash] == false,

            "Provided message has been blocked."

        );



        require(

            _target != resolve("CanonicalTransactionChain"),

            "Cannot send L2->L1 messages to L1 system contracts."

        );



        xDomainMsgSender = _sender;

        (bool success, ) = _target.call(_message);

        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;



        // Mark the message as received if the call was successful. Ensures that a message can be

        // relayed multiple times in the case that the call reverted.

        if (success == true) {

            successfulMessages[xDomainCalldataHash] = true;

            emit RelayedMessage(xDomainCalldataHash);

        } else {

            emit FailedRelayedMessage(xDomainCalldataHash);

        }



        // Store an identifier that can be used to prove that the given message was relayed by some

        // user. Gives us an easy way to pay relayers for their work.

        bytes32 relayId = keccak256(

            abi.encodePacked(

                xDomainCalldata,

                msg.sender,

                block.number

            )

        );

        relayedMessages[relayId] = true;

    }

    /**

     * Replays a cross domain message to the target messenger.

     * 

     */

    function replayMessageViaChainId(

        uint256 _chainId,

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _queueIndex,

        uint32 _oldGasLimit,

        uint32 _newGasLimit

    )

        override

        public

        payable

    {



        // Verify that the message is in the queue:

        address canonicalTransactionChain = resolve("CanonicalTransactionChain");

        Lib_OVMCodec.QueueElement memory element =

            ICanonicalTransactionChain(canonicalTransactionChain).getQueueElementByChainId(_chainId, _queueIndex);

        

        //Compute the calldata that was originally used to send the message.

        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(

            _target,

            _sender,

            _message,

            _queueIndex

        );



        // Compute the transactionHash

        bytes32 transactionHash = keccak256(

            abi.encode(

                AddressAliasHelper.applyL1ToL2Alias(address(this)),

                Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,

                _oldGasLimit,

                xDomainCalldata

            )

        );



        require(

            transactionHash == element.transactionHash,

            "Provided message has not been enqueued."

        );





        _sendXDomainMessageViaChainId(

            _chainId,

            canonicalTransactionChain,

            xDomainCalldata,

            _newGasLimit

        );

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Verifies that the given message is valid.

     * @param _xDomainCalldata Calldata to verify.

     * @param _proof Inclusion proof for the message.

     * @return Whether or not the provided message is valid.

     */

    function _verifyXDomainMessage(

        bytes memory _xDomainCalldata,

        L2MessageInclusionProof memory _proof

    ) internal view returns (bool) {

        return (_verifyStateRootProof(_proof) && _verifyStorageProof(_xDomainCalldata, _proof));

    }



    /**

     * Verifies that the state root within an inclusion proof is valid.

     * @param _proof Message inclusion proof.

     * @return Whether or not the provided proof is valid.

     */

    function _verifyStateRootProof(L2MessageInclusionProof memory _proof)

        internal

        view

        returns (bool)

    {

        IStateCommitmentChain ovmStateCommitmentChain = IStateCommitmentChain(

            resolve("StateCommitmentChain")

        );



        return (ovmStateCommitmentChain.insideFraudProofWindow(_proof.stateRootBatchHeader) ==

            false &&

            ovmStateCommitmentChain.verifyStateCommitment(

                _proof.stateRoot,

                _proof.stateRootBatchHeader,

                _proof.stateRootProof

            ));

    }



    /**

     * Verifies that the storage proof within an inclusion proof is valid.

     * @param _xDomainCalldata Encoded message calldata.

     * @param _proof Message inclusion proof.

     * @return Whether or not the provided proof is valid.

     */

    function _verifyStorageProof(

        bytes memory _xDomainCalldata,

        L2MessageInclusionProof memory _proof

    ) internal pure returns (bool) {

        bytes32 storageKey = keccak256(

            abi.encodePacked(

                keccak256(

                    abi.encodePacked(

                        _xDomainCalldata,

                        Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER

                    )

                ),

                uint256(0)

            )

        );



        (bool exists, bytes memory encodedMessagePassingAccount) = Lib_SecureMerkleTrie.get(

            abi.encodePacked(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER),

            _proof.stateTrieWitness,

            _proof.stateRoot

        );



        require(

            exists == true,

            "Message passing predeploy has not been initialized or invalid proof provided."

        );



        Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(

            encodedMessagePassingAccount

        );



        return

            Lib_SecureMerkleTrie.verifyInclusionProof(

                abi.encodePacked(storageKey),

                abi.encodePacked(uint8(1)),

                _proof.storageTrieWitness,

                account.storageRoot

            );

    }



    /**

     * Sends a cross domain message.

     * @param _canonicalTransactionChain Address of the CanonicalTransactionChain instance.

     * @param _message Message to send.

     * @param _gasLimit OVM gas limit for the message.

     */

    function _sendXDomainMessage(

        address _canonicalTransactionChain,

        bytes memory _message,

        uint256 _gasLimit

    ) internal {

        ICanonicalTransactionChain(_canonicalTransactionChain).enqueue(

            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,

            _gasLimit,

            _message

        );

    }

    /**

     * Verifies that the given message is valid.

     * @param _xDomainCalldata Calldata to verify.

     * @param _proof Inclusion proof for the message.

     * @return Whether or not the provided message is valid.

     */

    function _verifyXDomainMessageByChainId(

        uint256 _chainId,

        bytes memory _xDomainCalldata,

        L2MessageInclusionProof memory _proof

    )

        internal

        view

        returns (

            bool

        )

    {

        return (

            _verifyStateRootProofByChainId(_chainId, _proof)

            && _verifyStorageProofByChainId(_chainId, _xDomainCalldata, _proof)

        );

    }



    /**

     * Verifies that the state root within an inclusion proof is valid.

     * @param _proof Message inclusion proof.

     * @return Whether or not the provided proof is valid.

     */

    function _verifyStateRootProofByChainId(

        uint256 _chainId,

        L2MessageInclusionProof memory _proof

    )

        internal

        view

        returns (

            bool

        )

    {

        IStateCommitmentChain ovmStateCommitmentChain = IStateCommitmentChain(

            resolve("StateCommitmentChain")

        );



        return (

            ovmStateCommitmentChain.insideFraudProofWindowByChainId(_chainId, _proof.stateRootBatchHeader) == false

            && ovmStateCommitmentChain.verifyStateCommitmentByChainId(

                _chainId,

                _proof.stateRoot,

                _proof.stateRootBatchHeader,

                _proof.stateRootProof

            )

        );

    }



    /**

     * Verifies that the storage proof within an inclusion proof is valid.

     * @param _xDomainCalldata Encoded message calldata.

     * @param _proof Message inclusion proof.

     * @return Whether or not the provided proof is valid.

     */

    function _verifyStorageProofByChainId(

        uint256 _chainId,

        bytes memory _xDomainCalldata,

        L2MessageInclusionProof memory _proof

    )

        internal

        view

        returns (

            bool

        )

    {

        bytes32 storageKey = keccak256(

            abi.encodePacked(

                keccak256(

                    abi.encodePacked(

                        _xDomainCalldata,

                        Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER

                    )

                ),

                uint256(0)

            )

        );



        (bool exists, bytes memory encodedMessagePassingAccount) = Lib_SecureMerkleTrie.get(

            abi.encodePacked(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER),

            _proof.stateTrieWitness,

            _proof.stateRoot

        );



        require(

            exists == true,

            "Message passing predeploy has not been initialized or invalid proof provided."

        );

        

        Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(

            encodedMessagePassingAccount

        );



        return

            Lib_SecureMerkleTrie.verifyInclusionProof(

                abi.encodePacked(storageKey),

                abi.encodePacked(uint8(1)),

                _proof.storageTrieWitness,

                account.storageRoot

            );

    }



    /**

     * Sends a cross domain message via chain id.

     * @param _chainId L2 chain id.

     * @param _message Message to send.

     * @param _gasLimit OVM gas limit for the message.

     */

    function _sendXDomainMessageViaChainId(

        uint256 _chainId,

        address _canonicalTransactionChain,

        bytes memory _message,

        uint256 _gasLimit

    )

        internal

    {

        ICanonicalTransactionChain(_canonicalTransactionChain).enqueueByChainId(

            _chainId,

            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,

            _gasLimit,

            _message

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\L1StandardBridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Interface Imports */

import { IL1StandardBridge } from "./IL1StandardBridge.sol";

import { IL1ERC20Bridge } from "./IL1ERC20Bridge.sol";

import { IL2ERC20Bridge } from "../../L2/messaging/IL2ERC20Bridge.sol";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";



/* Library Imports */

import { CrossDomainEnabled } from "../../libraries/bridge/CrossDomainEnabled.sol";

import { Lib_PredeployAddresses } from "../../libraries/constants/Lib_PredeployAddresses.sol";

import { Address } from "@openzeppelin/contracts/utils/Address.sol";

import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import { iMVM_DiscountOracle } from "../../MVM/iMVM_DiscountOracle.sol";

import { Lib_AddressManager } from "../../libraries/resolver/Lib_AddressManager.sol";



/**

 * @title L1StandardBridge

 * @dev The L1 ETH and ERC20 Bridge is a contract which stores deposited L1 funds and standard

 * tokens that are in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits

 * and listening to it for newly finalized withdrawals.

 *

 * Runtime target: EVM

 */

contract L1StandardBridge is IL1StandardBridge, CrossDomainEnabled {

    using SafeERC20 for IERC20;



    /********************************

     * External Contract References *

     ********************************/



    address public l2TokenBridge;

    address public metis;

    address public addressmgr;



    // Maps L1 token to chainid to L2 token to balance of the L1 token deposited

    mapping(address => mapping (uint256 => mapping (address => uint256))) public deposits;



    

    uint256 constant public DEFAULT_CHAINID = 1088;



    /***************

     * Constructor *

     ***************/



    // This contract lives behind a proxy, so the constructor parameters will go unused.

    constructor() CrossDomainEnabled(address(0)) {}



    /******************

     * Initialization *

     ******************/



    /**

     * @param _l1messenger L1 Messenger address being used for cross-chain communications.

     * @param _l2TokenBridge L2 standard bridge address.

     */

    function initialize(

        address _l1messenger,

        address _l2TokenBridge,

        address _metis,

        address _addressmgr

    )

        public

    {

        require(messenger == address(0), "Contract has already been initialized.");

        messenger = _l1messenger;

        l2TokenBridge = _l2TokenBridge;

        metis = _metis;

        addressmgr = _addressmgr;

    }



    /**************

     * Depositing *

     **************/



    /** @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious

     *  contract via initcode, but it takes care of the user error we want to avoid.

     */

    modifier onlyEOA() {

        // Used to stop deposits from contracts (avoid accidentally lost tokens)

        require(!Address.isContract(msg.sender), "Account not EOA");

        _;

    }



    /**

     * @dev do not accept no data call

     */

    //receive() external payable onlyEOA {

    //    _initiateETHDeposit(msg.sender, msg.sender, 200_000, bytes(""));

    //}



    /**

     * @inheritdoc IL1StandardBridge

     */

    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable onlyEOA {

        _initiateETHDeposit(msg.sender, msg.sender, _l2Gas, _data);

    }

    

    function depositETHByChainId(

        uint256 _chainId,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external

        override

        payable

        onlyEOA()

    {

        _initiateETHDepositByChainId(

            _chainId,

            msg.sender,

            msg.sender,

            _l2Gas,

            _data

        );

    }



    /**

     * @inheritdoc IL1StandardBridge

     */

    function depositETHTo(

        address _to,

        uint32 _l2Gas,

        bytes calldata _data

    ) external payable {

        _initiateETHDeposit(msg.sender, _to, _l2Gas, _data);

    }

    

    function depositETHToByChainId(

        uint256 _chainId,

        address _to,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external

        override

        payable

    {

        _initiateETHDepositByChainId(

            _chainId,

            msg.sender,

            _to,

            _l2Gas,

            _data

        );

    }



    /**

     * @dev Performs the logic for deposits by storing the ETH and informing the L2 ETH Gateway of

     * the deposit.

     * @param _from Account to pull the deposit from on L1.

     * @param _to Account to give the deposit to on L2.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function _initiateETHDeposit(

        address _from,

        address _to,

        uint32 _l2Gas,

        bytes memory _data

    ) internal {

        _initiateETHDepositByChainId(DEFAULT_CHAINID, _from, _to, _l2Gas, _data);

    }

    

    function _initiateETHDepositByChainId(

        uint256 _chainId,

        address _from,

        address _to,

        uint32 _l2Gas,

        bytes memory _data

    )

        internal

    {

    

        iMVM_DiscountOracle oracle = iMVM_DiscountOracle(Lib_AddressManager(addressmgr).getAddress('MVM_DiscountOracle'));

        uint32 mingas = uint32(oracle.getMinL2Gas());

        if (_l2Gas < mingas) {

            _l2Gas = mingas;

        }

        uint256 fee = _l2Gas * oracle.getDiscount();

        

        require(fee <= msg.value, string(abi.encodePacked("insufficient fee supplied. send at least ", uint2str(fee))));

        // Construct calldata for finalizeDeposit call

        bytes memory message =

            abi.encodeWithSelector(

                IL2ERC20Bridge.finalizeDeposit.selector,

                address(0),

                Lib_PredeployAddresses.OVM_ETH,

                _from,

                _to,

                msg.value - fee,

                _data

            );

        

        // Send calldata into L2

        sendCrossDomainMessageViaChainId(

            _chainId,

            l2TokenBridge,

            _l2Gas,

            message,

            fee  // only send the supplied fees over (obviously)

        );



        emit ETHDepositInitiated(_from, _to, msg.value, _data, _chainId);

    }



    /**

     * @inheritdoc IL1ERC20Bridge

     */

    function depositERC20(

        address _l1Token,

        address _l2Token,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external virtual onlyEOA {

        _initiateERC20DepositByChainId(DEFAULT_CHAINID, _l1Token, _l2Token, msg.sender, msg.sender, _amount, _l2Gas, _data);

    }



    /**

     * @inheritdoc IL1ERC20Bridge

     */

    function depositERC20To(

        address _l1Token,

        address _l2Token,

        address _to,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external virtual {

        _initiateERC20DepositByChainId(DEFAULT_CHAINID, _l1Token, _l2Token, msg.sender, _to, _amount, _l2Gas, _data);

    }

    function depositERC20ByChainId(

        uint256 _chainid,

        address _l1Token,

        address _l2Token,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external

        override

        virtual

        payable

        onlyEOA()

    {

        _initiateERC20DepositByChainId(_chainid, _l1Token, _l2Token, msg.sender, msg.sender, _amount, _l2Gas, _data);

    }

    

    function depositERC20ToByChainId(

        uint256 _chainid,

        address _l1Token,

        address _l2Token,

        address _to,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    )

        external

        override

        payable

        virtual

    {

        _initiateERC20DepositByChainId(_chainid, _l1Token, _l2Token, msg.sender, _to, _amount, _l2Gas, _data);

    }



    /**

     * @dev Performs the logic for deposits by informing the L2 Deposited Token

     * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)

     *

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _from Account to pull the deposit from on L1

     * @param _to Account to give the deposit to on L2

     * @param _amount Amount of the ERC20 to deposit.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function _initiateERC20Deposit(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) internal {

        _initiateERC20DepositByChainId(DEFAULT_CHAINID, _l1Token, _l2Token, _from, _to, _amount, _l2Gas, _data);

    }

    

    function _initiateERC20DepositByChainId(

        uint256 _chainId,

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    )

        internal

    {

        iMVM_DiscountOracle oracle = iMVM_DiscountOracle(Lib_AddressManager(addressmgr).getAddress('MVM_DiscountOracle'));

        

        // stack too deep. so no more local variables

        if (_l2Gas < uint32(oracle.getMinL2Gas())) {

            _l2Gas = uint32(oracle.getMinL2Gas());

        }

        

        require(_l2Gas * oracle.getDiscount() <= msg.value, 

                string(abi.encodePacked("insufficient fee supplied. send at least ", uint2str(_l2Gas * oracle.getDiscount()))));

        

        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future

        // withdrawals. safeTransferFrom also checks if the contract has code, so this will fail if

        // _from is an EOA or address(0).

        IERC20(_l1Token).safeTransferFrom(

            _from,

            address(this),

            _amount

        );

        

        bytes memory message;

        if (_l1Token == metis) {

            // Construct calldata for finalizeDeposit call

          _l2Token = Lib_PredeployAddresses.MVM_COINBASE;

          message =

            abi.encodeWithSelector(

                IL2ERC20Bridge.finalizeDeposit.selector,

                address(0),

                Lib_PredeployAddresses.MVM_COINBASE,

                _from,

                _to,

                _amount,

                _data

            );

            

        } else {

          // Construct calldata for finalizeDeposit call

          message =

            abi.encodeWithSelector(

                IL2ERC20Bridge.finalizeDeposit.selector,

                _l1Token,

                _l2Token,

                _from,

                _to,

                _amount,

                _data

            );

        }



        // Send calldata into L2

        sendCrossDomainMessageViaChainId(

            _chainId,

            l2TokenBridge,

            _l2Gas,

            message,

            msg.value  //send all values as fees to cover l2 tx cost

        );

        

        deposits[_l1Token][_chainId][_l2Token] = deposits[_l1Token][_chainId][_l2Token] + (_amount);



        emit ERC20ChainID(_chainId);

        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _data);

        

    }



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @inheritdoc IL1StandardBridge

     */

    function finalizeETHWithdrawal(

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external onlyFromCrossDomainAccount(l2TokenBridge) {

        (bool success, ) = _to.call{ value: _amount }(new bytes(0));

        require(success, "TransferHelper::safeTransferETH: ETH transfer failed");



        emit ETHWithdrawalFinalized(_from, _to, _amount, _data, DEFAULT_CHAINID);

    }

    

    function finalizeETHWithdrawalByChainId(

        uint256 _chainid,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    )

        external

        override

        onlyFromCrossDomainAccount(l2TokenBridge)

    {

        (bool success, ) = _to.call{value: _amount}(new bytes(0));

        require(success, "TransferHelper::safeTransferETH: ETH transfer failed");



        emit ETHWithdrawalFinalized(_from, _to, _amount, _data, _chainid);

    }

    

    function finalizeMetisWithdrawalByChainId(

        uint256 _chainid,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    )

        external

        override

        onlyFromCrossDomainAccount(l2TokenBridge)

    {

        _finalizeERC20WithdrawalByChainId(_chainid, metis, Lib_PredeployAddresses.MVM_COINBASE, _from, _to, _amount, _data);

    }



    /**

     * @inheritdoc IL1ERC20Bridge

     */

    function finalizeERC20Withdrawal(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external onlyFromCrossDomainAccount(l2TokenBridge) {

        _finalizeERC20WithdrawalByChainId(DEFAULT_CHAINID, _l1Token, _l2Token, _from, _to, _amount, _data);

    }

    

    function finalizeERC20WithdrawalByChainId(

        uint256 _chainid,

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    )

        external

        override

        onlyFromCrossDomainAccount(l2TokenBridge)

    {

        _finalizeERC20WithdrawalByChainId(_chainid, _l1Token, _l2Token, _from, _to, _amount, _data);

    }

    

    function _finalizeERC20WithdrawalByChainId(

        uint256 _chainid,

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    )

        internal

    {

        deposits[_l1Token][_chainid][_l2Token] = deposits[_l1Token][_chainid][_l2Token] - _amount;



        // When a withdrawal is finalized on L1, the L1 Bridge transfers the funds to the withdrawer

        IERC20(_l1Token).safeTransfer(_to, _amount);



        emit ERC20ChainID(_chainid);

        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);

        

    }



    /*****************************

     * Temporary - Migrating ETH *

     *****************************/



    /**

     * @dev Adds ETH balance to the account. This is meant to allow for ETH

     * to be migrated from an old gateway to a new gateway.

     * NOTE: This is left for one upgrade only so we are able to receive the migrated ETH from the

     * old contract

     */

    function donateETH() external payable {}

    

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {

        if (_i == 0) {

            return "0";

        }

        uint j = _i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len;

        while (_i != 0) {

            k = k-1;

            uint8 temp = (48 + uint8(_i - _i / 10 * 10));

            bytes1 b1 = bytes1(temp);

            bstr[k] = b1;

            _i /= 10;

        }

        return string(bstr);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\L2StandardBridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Interface Imports */

import { IL1StandardBridge } from "../../L1/messaging/IL1StandardBridge.sol";

import { IL1ERC20Bridge } from "../../L1/messaging/IL1ERC20Bridge.sol";

import { IL2ERC20Bridge } from "./IL2ERC20Bridge.sol";



/* Library Imports */

import { ERC165Checker } from "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";

import { CrossDomainEnabled } from "../../libraries/bridge/CrossDomainEnabled.sol";

import { Lib_PredeployAddresses } from "../../libraries/constants/Lib_PredeployAddresses.sol";



/* Contract Imports */

import { IL2StandardERC20 } from "../../standards/IL2StandardERC20.sol";

import { OVM_GasPriceOracle } from "../predeploys/OVM_GasPriceOracle.sol";



/**

 * @title L2StandardBridge

 * @dev The L2 Standard bridge is a contract which works together with the L1 Standard bridge to

 * enable ETH and ERC20 transitions between L1 and L2.

 * This contract acts as a minter for new tokens when it hears about deposits into the L1 Standard

 * bridge.

 * This contract also acts as a burner of the tokens intended for withdrawal, informing the L1

 * bridge to release L1 funds.

 */

contract L2StandardBridge is IL2ERC20Bridge, CrossDomainEnabled {

    /********************************

     * External Contract References *

     ********************************/



    address public l1TokenBridge;



    /***************

     * Constructor *

     ***************/



    /**

     * @param _l2CrossDomainMessenger Cross-domain messenger used by this contract.

     * @param _l1TokenBridge Address of the L1 bridge deployed to the main chain.

     */

    constructor(address _l2CrossDomainMessenger, address _l1TokenBridge)

        CrossDomainEnabled(_l2CrossDomainMessenger)

    {

        l1TokenBridge = _l1TokenBridge;

    }

    

    function getChainID() internal view returns (uint256) {

        uint256 id;

        assembly {

            id := chainid()

        }

        return id;

    }



    /***************

     * Withdrawing *

     ***************/



    /**

     * @inheritdoc IL2ERC20Bridge

     */

    function withdraw(

        address _l2Token,

        uint256 _amount,

        uint32 _l1Gas,

        bytes calldata _data

    ) external payable virtual {

        _initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _l1Gas, _data);

    }

    

    function withdrawMetis(

        uint256 _amount,

        uint32 _l1Gas,

        bytes calldata _data

    ) external payable virtual {

        _initiateWithdrawal(Lib_PredeployAddresses.MVM_COINBASE, msg.sender, msg.sender, _amount, _l1Gas, _data);

    }



    /**

     * @inheritdoc IL2ERC20Bridge

     */

    function withdrawTo(

        address _l2Token,

        address _to,

        uint256 _amount,

        uint32 _l1Gas,

        bytes calldata _data

    ) external payable virtual {

        _initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _l1Gas, _data);

    }

    

    function withdrawMetisTo(

        address _to,

        uint256 _amount,

        uint32 _l1Gas,

        bytes calldata _data

    ) external payable virtual {

        _initiateWithdrawal(Lib_PredeployAddresses.MVM_COINBASE, msg.sender, _to, _amount, _l1Gas, _data);

    }



    /**

     * @dev Performs the logic for deposits by storing the token and informing the L2 token Gateway

     * of the deposit.

     * @param _l2Token Address of L2 token where withdrawal was initiated.

     * @param _from Account to pull the deposit from on L2.

     * @param _to Account to give the withdrawal to on L1.

     * @param _amount Amount of the token to withdraw.

     * param _l1Gas Unused, but included for potential forward compatibility considerations.

     * @param _data Optional data to forward to L1. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function _initiateWithdrawal(

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        uint32 _l1Gas,

        bytes calldata _data

    ) internal {

        uint256 minL1Gas = OVM_GasPriceOracle(Lib_PredeployAddresses.OVM_GASPRICE_ORACLE).minErc20BridgeCost();

        

        // require minimum gas unless, the metis manager is the sender

        require (msg.value >= minL1Gas ||

                    _from == Lib_PredeployAddresses.SEQUENCER_FEE_WALLET, 

                 string(abi.encodePacked("insufficient withdrawal fee supplied. need at least ", uint2str(minL1Gas))));

        

        // When a withdrawal is initiated, we burn the withdrawer's funds to prevent subsequent L2

        // usage

        IL2StandardERC20(_l2Token).burn(msg.sender, _amount);



        // Construct calldata for l1TokenBridge.finalizeERC20Withdrawal(_to, _amount)

        address l1Token = IL2StandardERC20(_l2Token).l1Token();

        bytes memory message;



        if (_l2Token == Lib_PredeployAddresses.OVM_ETH) {

            message = abi.encodeWithSelector(

                        IL1StandardBridge.finalizeETHWithdrawalByChainId.selector,

                        getChainID(),

                        _from,

                        _to,

                        _amount,

                        _data

                    );

        } else if (_l2Token == Lib_PredeployAddresses.MVM_COINBASE) {

            message = abi.encodeWithSelector(

                        IL1ERC20Bridge.finalizeMetisWithdrawalByChainId.selector,

                        getChainID(),

                        _from,

                        _to,

                        _amount,

                        _data

                    );

        } else {

            message = abi.encodeWithSelector(

                        IL1ERC20Bridge.finalizeERC20WithdrawalByChainId.selector,

                        getChainID(),

                        l1Token,

                        _l2Token,

                        _from,

                        _to,

                        _amount,

                        _data

                    );

        }



        // Send message up to L1 bridge

        sendCrossDomainMessage(

            l1TokenBridge,

            _l1Gas,

            message,

            msg.value  // send all value as fees to cover relayer cost

        );



        emit WithdrawalInitiated(l1Token, _l2Token, msg.sender, _to, _amount, _data);

    }



    /************************************

     * Cross-chain Function: Depositing *

     ************************************/



    /**

     * @inheritdoc IL2ERC20Bridge

     */

    function finalizeDeposit(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external virtual onlyFromCrossDomainAccount(l1TokenBridge) {

        // Check the target token is compliant and

        // verify the deposited token on L1 matches the L2 deposited token representation here

        if (

            ERC165Checker.supportsInterface(_l2Token, 0x1d1d8b63) &&

            _l1Token == IL2StandardERC20(_l2Token).l1Token()

        ) {

            // When a deposit is finalized, we credit the account on L2 with the same amount of

            // tokens.

            IL2StandardERC20(_l2Token).mint(_to, _amount);

            emit DepositFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);

        } else {

            // disable because the mechanism is incompatible with the new xdomain fee structure.

            

            // Either the L2 token which is being deposited-into disagrees about the correct address

            // of its L1 token, or does not support the correct interface.

            // This should only happen if there is a  malicious L2 token, or if a user somehow

            // specified the wrong L2 token address to deposit into.

            // In either case, we stop the process here and construct a withdrawal

            // message so that users can get their funds out in some cases.

            // There is no way to prevent malicious token contracts altogether, but this does limit

            // user error and mitigate some forms of malicious contract behavior.

            //bytes memory message = abi.encodeWithSelector(

            //    iOVM_L1ERC20Bridge.finalizeERC20Withdrawal.selector,

            //    _l1Token,

            //    _l2Token,

            //    _to,   // switched the _to and _from here to bounce back the deposit to the sender

            //    _from,

            //    _amount,

            //    _data

            //);



            // Send message up to L1 bridge

            //sendCrossDomainMessage(

            //    l1TokenBridge,

            //    0,

            //    message,

            //    0 

            //);

            emit DepositFailed(_l1Token, _l2Token, _from, _to, _amount, _data);



        }

    }

    

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {

        if (_i == 0) {

            return "0";

        }

        uint j = _i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len;

        while (_i != 0) {

            k = k-1;

            uint8 temp = (48 + uint8(_i - _i / 10 * 10));

            bytes1 b1 = bytes1(temp);

            bstr[k] = b1;

            _i /= 10;

        }

        return string(bstr);

    }

    

    

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_AddressManager.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* External Imports */

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";



/**

 * @title Lib_AddressManager

 */

contract Lib_AddressManager is Ownable {

    /**********

     * Events *

     **********/



    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);



    /*************

     * Variables *

     *************/



    mapping(bytes32 => address) private addresses;



    /********************

     * Public Functions *

     ********************/



    /**

     * Changes the address associated with a particular name.

     * @param _name String name to associate an address with.

     * @param _address Address to associate with the name.

     */

    function setAddress(string memory _name, address _address) external onlyOwner {

        bytes32 nameHash = _getNameHash(_name);

        address oldAddress = addresses[nameHash];

        addresses[nameHash] = _address;



        emit AddressSet(_name, _address, oldAddress);

    }



    /**

     * Retrieves the address associated with a given name.

     * @param _name Name to retrieve an address for.

     * @return Address associated with the given name.

     */

    function getAddress(string memory _name) external view returns (address) {

        return addresses[_getNameHash(_name)];

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Computes the hash of a name.

     * @param _name Name to compute a hash for.

     * @return Hash of the given name.

     */

    function _getNameHash(string memory _name) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked(_name));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_AddressResolver.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_AddressManager } from "./Lib_AddressManager.sol";



/**

 * @title Lib_AddressResolver

 */

abstract contract Lib_AddressResolver {

    /*************

     * Variables *

     *************/



    Lib_AddressManager public libAddressManager;



    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Lib_AddressManager.

     */

    constructor(address _libAddressManager) {

        libAddressManager = Lib_AddressManager(_libAddressManager);

    }



    /********************

     * Public Functions *

     ********************/



    /**

     * Resolves the address associated with a given name.

     * @param _name Name to resolve an address for.

     * @return Address associated with the given name.

     */

    function resolve(string memory _name) public view returns (address) {

        return libAddressManager.getAddress(_name);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_Buffer.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_Buffer

 * @dev This library implements a bytes32 storage array with some additional gas-optimized

 * functionality. In particular, it encodes its length as a uint40, and tightly packs this with an

 * overwritable "extra data" field so we can store more information with a single SSTORE.

 */

library Lib_Buffer {

    /*************

     * Libraries *

     *************/



    using Lib_Buffer for Buffer;



    /***********

     * Structs *

     ***********/



    struct Buffer {

        bytes32 context;

        mapping(uint256 => bytes32) buf;

    }



    struct BufferContext {

        // Stores the length of the array. Uint40 is way more elements than we'll ever reasonably

        // need in an array and we get an extra 27 bytes of extra data to play with.

        uint40 length;

        // Arbitrary extra data that can be modified whenever the length is updated. Useful for

        // squeezing out some gas optimizations.

        bytes27 extraData;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Pushes a single element to the buffer.

     * @param _self Buffer to access.

     * @param _value Value to push to the buffer.

     * @param _extraData Global extra data.

     */

    function push(

        Buffer storage _self,

        bytes32 _value,

        bytes27 _extraData

    ) internal {

        BufferContext memory ctx = _self.getContext();



        _self.buf[ctx.length] = _value;



        // Bump the global index and insert our extra data, then save the context.

        ctx.length++;

        ctx.extraData = _extraData;

        _self.setContext(ctx);

    }



    /**

     * Pushes a single element to the buffer.

     * @param _self Buffer to access.

     * @param _value Value to push to the buffer.

     */

    function push(Buffer storage _self, bytes32 _value) internal {

        BufferContext memory ctx = _self.getContext();



        _self.push(_value, ctx.extraData);

    }



    /**

     * Retrieves an element from the buffer.

     * @param _self Buffer to access.

     * @param _index Element index to retrieve.

     * @return Value of the element at the given index.

     */

    function get(Buffer storage _self, uint256 _index) internal view returns (bytes32) {

        BufferContext memory ctx = _self.getContext();



        require(_index < ctx.length, "Index out of bounds.");



        return _self.buf[_index];

    }



    /**

     * Deletes all elements after (and including) a given index.

     * @param _self Buffer to access.

     * @param _index Index of the element to delete from (inclusive).

     * @param _extraData Optional global extra data.

     */

    function deleteElementsAfterInclusive(

        Buffer storage _self,

        uint40 _index,

        bytes27 _extraData

    ) internal {

        BufferContext memory ctx = _self.getContext();



        require(_index < ctx.length, "Index out of bounds.");



        // Set our length and extra data, save the context.

        ctx.length = _index;

        ctx.extraData = _extraData;

        _self.setContext(ctx);

    }



    /**

     * Deletes all elements after (and including) a given index.

     * @param _self Buffer to access.

     * @param _index Index of the element to delete from (inclusive).

     */

    function deleteElementsAfterInclusive(Buffer storage _self, uint40 _index) internal {

        BufferContext memory ctx = _self.getContext();

        _self.deleteElementsAfterInclusive(_index, ctx.extraData);

    }



    /**

     * Retrieves the current global index.

     * @param _self Buffer to access.

     * @return Current global index.

     */

    function getLength(Buffer storage _self) internal view returns (uint40) {

        BufferContext memory ctx = _self.getContext();

        return ctx.length;

    }



    /**

     * Changes current global extra data.

     * @param _self Buffer to access.

     * @param _extraData New global extra data.

     */

    function setExtraData(Buffer storage _self, bytes27 _extraData) internal {

        BufferContext memory ctx = _self.getContext();

        ctx.extraData = _extraData;

        _self.setContext(ctx);

    }



    /**

     * Retrieves the current global extra data.

     * @param _self Buffer to access.

     * @return Current global extra data.

     */

    function getExtraData(Buffer storage _self) internal view returns (bytes27) {

        BufferContext memory ctx = _self.getContext();

        return ctx.extraData;

    }



    /**

     * Sets the current buffer context.

     * @param _self Buffer to access.

     * @param _ctx Current buffer context.

     */

    function setContext(Buffer storage _self, BufferContext memory _ctx) internal {

        bytes32 context;

        uint40 length = _ctx.length;

        bytes27 extraData = _ctx.extraData;

        assembly {

            context := length

            context := or(context, extraData)

        }



        if (_self.context != context) {

            _self.context = context;

        }

    }



    /**

     * Retrieves the current buffer context.

     * @param _self Buffer to access.

     * @return Current buffer context.

     */

    function getContext(Buffer storage _self) internal view returns (BufferContext memory) {

        bytes32 context = _self.context;

        uint40 length;

        bytes27 extraData;

        assembly {

            length := and(

                context,

                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF

            )

            extraData := and(

                context,

                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000

            )

        }



        return BufferContext({ length: length, extraData: extraData });

    }

    

    /**

     * set elements for a given index.

     * @param _self Buffer to access.

     * @param _index Index of the element to set.

     * @param _value value to set

     */

    function set(

        Buffer storage _self,

        uint256 _index,

        bytes32 _value

    )

        internal

    {

        _self.buf[_index] = _value;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_Bytes32Utils.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_Byte32Utils

 */

library Lib_Bytes32Utils {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to "true."

     * @param _in Input bytes32 value.

     * @return Bytes32 as a boolean.

     */

    function toBool(bytes32 _in) internal pure returns (bool) {

        return _in != 0;

    }



    /**

     * Converts a boolean to a bytes32 value.

     * @param _in Input boolean value.

     * @return Boolean as a bytes32.

     */

    function fromBool(bool _in) internal pure returns (bytes32) {

        return bytes32(uint256(_in ? 1 : 0));

    }



    /**

     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.

     * @param _in Input bytes32 value.

     * @return Bytes32 as an address.

     */

    function toAddress(bytes32 _in) internal pure returns (address) {

        return address(uint160(uint256(_in)));

    }



    /**

     * Converts an address to a bytes32.

     * @param _in Input address value.

     * @return Address as a bytes32.

     */

    function fromAddress(address _in) internal pure returns (bytes32) {

        return bytes32(uint256(uint160(_in)));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_BytesUtils.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_BytesUtils

 */

library Lib_BytesUtils {

    /**********************

     * Internal Functions *

     **********************/



    function slice(

        bytes memory _bytes,

        uint256 _start,

        uint256 _length

    ) internal pure returns (bytes memory) {

        require(_length + 31 >= _length, "slice_overflow");

        require(_start + _length >= _start, "slice_overflow");

        require(_bytes.length >= _start + _length, "slice_outOfBounds");



        bytes memory tempBytes;



        assembly {

            switch iszero(_length)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                let lengthmod := and(_length, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, _length)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, _length)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                //zero out the 32 bytes slice we are about to return

                //we need to do it because Solidity does not garbage collect

                mstore(tempBytes, 0)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {

        if (_start >= _bytes.length) {

            return bytes("");

        }



        return slice(_bytes, _start, _bytes.length - _start);

    }



    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {

        if (_bytes.length < 32) {

            bytes32 ret;

            assembly {

                ret := mload(add(_bytes, 32))

            }

            return ret;

        }



        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes

    }



    function toUint256(bytes memory _bytes) internal pure returns (uint256) {

        return uint256(toBytes32(_bytes));

    }



    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {

        bytes memory nibbles = new bytes(_bytes.length * 2);



        for (uint256 i = 0; i < _bytes.length; i++) {

            nibbles[i * 2] = _bytes[i] >> 4;

            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);

        }



        return nibbles;

    }



    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {

        bytes memory ret = new bytes(_bytes.length / 2);



        for (uint256 i = 0; i < ret.length; i++) {

            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);

        }



        return ret;

    }



    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {

        return keccak256(_bytes) == keccak256(_other);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_CrossDomainUtils.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_RLPReader } from "../rlp/Lib_RLPReader.sol";



/**

 * @title Lib_CrossDomainUtils

 */

library Lib_CrossDomainUtils {

    /**

     * Generates the correct cross domain calldata for a message.

     * @param _target Target contract address.

     * @param _sender Message sender address.

     * @param _message Message to send to the target.

     * @param _messageNonce Nonce for the provided message.

     * @return ABI encoded cross domain calldata.

     */

    function encodeXDomainCalldata(

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _messageNonce

    ) internal pure returns (bytes memory) {

        return

            abi.encodeWithSignature(

                "relayMessage(address,address,bytes,uint256)",

                _target,

                _sender,

                _message,

                _messageNonce

            );

    }

    

    /**

     * Generates the correct cross domain calldata for a message.

     * @param _chainId L2 chain id.

     * @param _target Target contract address.

     * @param _sender Message sender address.

     * @param _message Message to send to the target.

     * @param _messageNonce Nonce for the provided message.

     * @return ABI encoded cross domain calldata.

     */

    function encodeXDomainCalldataViaChainId(

        uint256 _chainId,

        address _target,

        address _sender,

        bytes memory _message,

        uint256 _messageNonce

    )

        internal

        pure

        returns (

            bytes memory

        )

    {

        return abi.encodeWithSignature(

            "relayMessageViaChainId(uint256,address,address,bytes,uint256)",

            _chainId,

            _target,

            _sender,

            _message,

            _messageNonce

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_DefaultValues.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_DefaultValues

 */

library Lib_DefaultValues {

    // The default x-domain message sender being set to a non-zero value makes

    // deployment a bit more expensive, but in exchange the refund on every call to

    // `relayMessage` by the L1 and L2 messengers will be higher.

    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_MerkleTrie.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_BytesUtils } from "../utils/Lib_BytesUtils.sol";

import { Lib_RLPReader } from "../rlp/Lib_RLPReader.sol";

import { Lib_RLPWriter } from "../rlp/Lib_RLPWriter.sol";



/**

 * @title Lib_MerkleTrie

 */

library Lib_MerkleTrie {

    /*******************

     * Data Structures *

     *******************/



    enum NodeType {

        BranchNode,

        ExtensionNode,

        LeafNode

    }



    struct TrieNode {

        bytes encoded;

        Lib_RLPReader.RLPItem[] decoded;

    }



    /**********************

     * Contract Constants *

     **********************/



    // TREE_RADIX determines the number of elements per branch node.

    uint256 constant TREE_RADIX = 16;

    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.

    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;

    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.

    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;



    // Prefixes are prepended to the `path` within a leaf or extension node and

    // allow us to differentiate between the two node types. `ODD` or `EVEN` is

    // determined by the number of nibbles within the unprefixed `path`. If the

    // number of nibbles if even, we need to insert an extra padding nibble so

    // the resulting prefixed `path` has an even number of nibbles.

    uint8 constant PREFIX_EXTENSION_EVEN = 0;

    uint8 constant PREFIX_EXTENSION_ODD = 1;

    uint8 constant PREFIX_LEAF_EVEN = 2;

    uint8 constant PREFIX_LEAF_ODD = 3;



    // Just a utility constant. RLP represents `NULL` as 0x80.

    bytes1 constant RLP_NULL = bytes1(0x80);

    bytes constant RLP_NULL_BYTES = hex"80";

    bytes32 internal constant KECCAK256_RLP_NULL_BYTES = keccak256(RLP_NULL_BYTES);



    /**********************

     * Internal Functions *

     **********************/



    /**

     * @notice Verifies a proof that a given key/value pair is present in the

     * Merkle trie.

     * @param _key Key of the node to search for, as a hex string.

     * @param _value Value of the node to search for, as a hex string.

     * @param _proof Merkle trie inclusion proof for the desired node. Unlike

     * traditional Merkle trees, this proof is executed top-down and consists

     * of a list of RLP-encoded nodes that make a path down to the target node.

     * @param _root Known root of the Merkle trie. Used to verify that the

     * included proof is correctly constructed.

     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.

     */

    function verifyInclusionProof(

        bytes memory _key,

        bytes memory _value,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bool _verified) {

        (bool exists, bytes memory value) = get(_key, _proof, _root);



        return (exists && Lib_BytesUtils.equal(_value, value));

    }



    /**

     * @notice Updates a Merkle trie and returns a new root hash.

     * @param _key Key of the node to update, as a hex string.

     * @param _value Value of the node to update, as a hex string.

     * @param _proof Merkle trie inclusion proof for the node *nearest* the

     * target node. If the key exists, we can simply update the value.

     * Otherwise, we need to modify the trie to handle the new k/v pair.

     * @param _root Known root of the Merkle trie. Used to verify that the

     * included proof is correctly constructed.

     * @return _updatedRoot Root hash of the newly constructed trie.

     */

    function update(

        bytes memory _key,

        bytes memory _value,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bytes32 _updatedRoot) {

        // Special case when inserting the very first node.

        if (_root == KECCAK256_RLP_NULL_BYTES) {

            return getSingleNodeRootHash(_key, _value);

        }



        TrieNode[] memory proof = _parseProof(_proof);

        (uint256 pathLength, bytes memory keyRemainder, ) = _walkNodePath(proof, _key, _root);

        TrieNode[] memory newPath = _getNewPath(proof, pathLength, _key, keyRemainder, _value);



        return _getUpdatedTrieRoot(newPath, _key);

    }



    /**

     * @notice Retrieves the value associated with a given key.

     * @param _key Key to search for, as hex bytes.

     * @param _proof Merkle trie inclusion proof for the key.

     * @param _root Known root of the Merkle trie.

     * @return _exists Whether or not the key exists.

     * @return _value Value of the key if it exists.

     */

    function get(

        bytes memory _key,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bool _exists, bytes memory _value) {

        TrieNode[] memory proof = _parseProof(_proof);

        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(

            proof,

            _key,

            _root

        );



        bool exists = keyRemainder.length == 0;



        require(exists || isFinalNode, "Provided proof is invalid.");



        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes("");



        return (exists, value);

    }



    /**

     * Computes the root hash for a trie with a single node.

     * @param _key Key for the single node.

     * @param _value Value for the single node.

     * @return _updatedRoot Hash of the trie.

     */

    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)

        internal

        pure

        returns (bytes32 _updatedRoot)

    {

        return keccak256(_makeLeafNode(Lib_BytesUtils.toNibbles(_key), _value).encoded);

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * @notice Walks through a proof using a provided key.

     * @param _proof Inclusion proof to walk through.

     * @param _key Key to use for the walk.

     * @param _root Known root of the trie.

     * @return _pathLength Length of the final path

     * @return _keyRemainder Portion of the key remaining after the walk.

     * @return _isFinalNode Whether or not we've hit a dead end.

     */

    function _walkNodePath(

        TrieNode[] memory _proof,

        bytes memory _key,

        bytes32 _root

    )

        private

        pure

        returns (

            uint256 _pathLength,

            bytes memory _keyRemainder,

            bool _isFinalNode

        )

    {

        uint256 pathLength = 0;

        bytes memory key = Lib_BytesUtils.toNibbles(_key);



        bytes32 currentNodeID = _root;

        uint256 currentKeyIndex = 0;

        uint256 currentKeyIncrement = 0;

        TrieNode memory currentNode;



        // Proof is top-down, so we start at the first element (root).

        for (uint256 i = 0; i < _proof.length; i++) {

            currentNode = _proof[i];

            currentKeyIndex += currentKeyIncrement;



            // Keep track of the proof elements we actually need.

            // It's expensive to resize arrays, so this simply reduces gas costs.

            pathLength += 1;



            if (currentKeyIndex == 0) {

                // First proof element is always the root node.

                require(keccak256(currentNode.encoded) == currentNodeID, "Invalid root hash");

            } else if (currentNode.encoded.length >= 32) {

                // Nodes 32 bytes or larger are hashed inside branch nodes.

                require(

                    keccak256(currentNode.encoded) == currentNodeID,

                    "Invalid large internal hash"

                );

            } else {

                // Nodes smaller than 31 bytes aren't hashed.

                require(

                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,

                    "Invalid internal node hash"

                );

            }



            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {

                if (currentKeyIndex == key.length) {

                    // We've hit the end of the key

                    // meaning the value should be within this branch node.

                    break;

                } else {

                    // We're not at the end of the key yet.

                    // Figure out what the next node ID should be and continue.

                    uint8 branchKey = uint8(key[currentKeyIndex]);

                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];

                    currentNodeID = _getNodeID(nextNode);

                    currentKeyIncrement = 1;

                    continue;

                }

            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {

                bytes memory path = _getNodePath(currentNode);

                uint8 prefix = uint8(path[0]);

                uint8 offset = 2 - (prefix % 2);

                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);

                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);

                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);



                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {

                    if (

                        pathRemainder.length == sharedNibbleLength &&

                        keyRemainder.length == sharedNibbleLength

                    ) {

                        // The key within this leaf matches our key exactly.

                        // Increment the key index to reflect that we have no remainder.

                        currentKeyIndex += sharedNibbleLength;

                    }



                    // We've hit a leaf node, so our next node should be NULL.

                    currentNodeID = bytes32(RLP_NULL);

                    break;

                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {

                    if (sharedNibbleLength != pathRemainder.length) {

                        // Our extension node is not identical to the remainder.

                        // We've hit the end of this path

                        // updates will need to modify this extension.

                        currentNodeID = bytes32(RLP_NULL);

                        break;

                    } else {

                        // Our extension shares some nibbles.

                        // Carry on to the next node.

                        currentNodeID = _getNodeID(currentNode.decoded[1]);

                        currentKeyIncrement = sharedNibbleLength;

                        continue;

                    }

                } else {

                    revert("Received a node with an unknown prefix");

                }

            } else {

                revert("Received an unparseable node.");

            }

        }



        // If our node ID is NULL, then we're at a dead end.

        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);

        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);

    }



    /**

     * @notice Creates new nodes to support a k/v pair insertion into a given Merkle trie path.

     * @param _path Path to the node nearest the k/v pair.

     * @param _pathLength Length of the path. Necessary because the provided path may include

     *  additional nodes (e.g., it comes directly from a proof) and we can't resize in-memory

     *  arrays without costly duplication.

     * @param _key Full original key.

     * @param _keyRemainder Portion of the initial key that must be inserted into the trie.

     * @param _value Value to insert at the given key.

     * @return _newPath A new path with the inserted k/v pair and extra supporting nodes.

     */

    function _getNewPath(

        TrieNode[] memory _path,

        uint256 _pathLength,

        bytes memory _key,

        bytes memory _keyRemainder,

        bytes memory _value

    ) private pure returns (TrieNode[] memory _newPath) {

        bytes memory keyRemainder = _keyRemainder;



        // Most of our logic depends on the status of the last node in the path.

        TrieNode memory lastNode = _path[_pathLength - 1];

        NodeType lastNodeType = _getNodeType(lastNode);



        // Create an array for newly created nodes.

        // We need up to three new nodes, depending on the contents of the last node.

        // Since array resizing is expensive, we'll keep track of the size manually.

        // We're using an explicit `totalNewNodes += 1` after insertions for clarity.

        TrieNode[] memory newNodes = new TrieNode[](3);

        uint256 totalNewNodes = 0;



        // solhint-disable-next-line max-line-length

        // Reference: https://github.com/ethereumjs/merkle-patricia-tree/blob/c0a10395aab37d42c175a47114ebfcbd7efcf059/src/baseTrie.ts#L294-L313

        bool matchLeaf = false;

        if (lastNodeType == NodeType.LeafNode) {

            uint256 l = 0;

            if (_path.length > 0) {

                for (uint256 i = 0; i < _path.length - 1; i++) {

                    if (_getNodeType(_path[i]) == NodeType.BranchNode) {

                        l++;

                    } else {

                        l += _getNodeKey(_path[i]).length;

                    }

                }

            }



            if (

                _getSharedNibbleLength(

                    _getNodeKey(lastNode),

                    Lib_BytesUtils.slice(Lib_BytesUtils.toNibbles(_key), l)

                ) ==

                _getNodeKey(lastNode).length &&

                keyRemainder.length == 0

            ) {

                matchLeaf = true;

            }

        }



        if (matchLeaf) {

            // We've found a leaf node with the given key.

            // Simply need to update the value of the node to match.

            newNodes[totalNewNodes] = _makeLeafNode(_getNodeKey(lastNode), _value);

            totalNewNodes += 1;

        } else if (lastNodeType == NodeType.BranchNode) {

            if (keyRemainder.length == 0) {

                // We've found a branch node with the given key.

                // Simply need to update the value of the node to match.

                newNodes[totalNewNodes] = _editBranchValue(lastNode, _value);

                totalNewNodes += 1;

            } else {

                // We've found a branch node, but it doesn't contain our key.

                // Reinsert the old branch for now.

                newNodes[totalNewNodes] = lastNode;

                totalNewNodes += 1;

                // Create a new leaf node, slicing our remainder since the first byte points

                // to our branch node.

                newNodes[totalNewNodes] = _makeLeafNode(

                    Lib_BytesUtils.slice(keyRemainder, 1),

                    _value

                );

                totalNewNodes += 1;

            }

        } else {

            // Our last node is either an extension node or a leaf node with a different key.

            bytes memory lastNodeKey = _getNodeKey(lastNode);

            uint256 sharedNibbleLength = _getSharedNibbleLength(lastNodeKey, keyRemainder);



            if (sharedNibbleLength != 0) {

                // We've got some shared nibbles between the last node and our key remainder.

                // We'll need to insert an extension node that covers these shared nibbles.

                bytes memory nextNodeKey = Lib_BytesUtils.slice(lastNodeKey, 0, sharedNibbleLength);

                newNodes[totalNewNodes] = _makeExtensionNode(nextNodeKey, _getNodeHash(_value));

                totalNewNodes += 1;



                // Cut down the keys since we've just covered these shared nibbles.

                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, sharedNibbleLength);

                keyRemainder = Lib_BytesUtils.slice(keyRemainder, sharedNibbleLength);

            }



            // Create an empty branch to fill in.

            TrieNode memory newBranch = _makeEmptyBranchNode();



            if (lastNodeKey.length == 0) {

                // Key remainder was larger than the key for our last node.

                // The value within our last node is therefore going to be shifted into

                // a branch value slot.

                newBranch = _editBranchValue(newBranch, _getNodeValue(lastNode));

            } else {

                // Last node key was larger than the key remainder.

                // We're going to modify some index of our branch.

                uint8 branchKey = uint8(lastNodeKey[0]);

                // Move on to the next nibble.

                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, 1);



                if (lastNodeType == NodeType.LeafNode) {

                    // We're dealing with a leaf node.

                    // We'll modify the key and insert the old leaf node into the branch index.

                    TrieNode memory modifiedLastNode = _makeLeafNode(

                        lastNodeKey,

                        _getNodeValue(lastNode)

                    );

                    newBranch = _editBranchIndex(

                        newBranch,

                        branchKey,

                        _getNodeHash(modifiedLastNode.encoded)

                    );

                } else if (lastNodeKey.length != 0) {

                    // We're dealing with a shrinking extension node.

                    // We need to modify the node to decrease the size of the key.

                    TrieNode memory modifiedLastNode = _makeExtensionNode(

                        lastNodeKey,

                        _getNodeValue(lastNode)

                    );

                    newBranch = _editBranchIndex(

                        newBranch,

                        branchKey,

                        _getNodeHash(modifiedLastNode.encoded)

                    );

                } else {

                    // We're dealing with an unnecessary extension node.

                    // We're going to delete the node entirely.

                    // Simply insert its current value into the branch index.

                    newBranch = _editBranchIndex(newBranch, branchKey, _getNodeValue(lastNode));

                }

            }



            if (keyRemainder.length == 0) {

                // We've got nothing left in the key remainder.

                // Simply insert the value into the branch value slot.

                newBranch = _editBranchValue(newBranch, _value);

                // Push the branch into the list of new nodes.

                newNodes[totalNewNodes] = newBranch;

                totalNewNodes += 1;

            } else {

                // We've got some key remainder to work with.

                // We'll be inserting a leaf node into the trie.

                // First, move on to the next nibble.

                keyRemainder = Lib_BytesUtils.slice(keyRemainder, 1);

                // Push the branch into the list of new nodes.

                newNodes[totalNewNodes] = newBranch;

                totalNewNodes += 1;

                // Push a new leaf node for our k/v pair.

                newNodes[totalNewNodes] = _makeLeafNode(keyRemainder, _value);

                totalNewNodes += 1;

            }

        }



        // Finally, join the old path with our newly created nodes.

        // Since we're overwriting the last node in the path, we use `_pathLength - 1`.

        return _joinNodeArrays(_path, _pathLength - 1, newNodes, totalNewNodes);

    }



    /**

     * @notice Computes the trie root from a given path.

     * @param _nodes Path to some k/v pair.

     * @param _key Key for the k/v pair.

     * @return _updatedRoot Root hash for the updated trie.

     */

    function _getUpdatedTrieRoot(TrieNode[] memory _nodes, bytes memory _key)

        private

        pure

        returns (bytes32 _updatedRoot)

    {

        bytes memory key = Lib_BytesUtils.toNibbles(_key);



        // Some variables to keep track of during iteration.

        TrieNode memory currentNode;

        NodeType currentNodeType;

        bytes memory previousNodeHash;



        // Run through the path backwards to rebuild our root hash.

        for (uint256 i = _nodes.length; i > 0; i--) {

            // Pick out the current node.

            currentNode = _nodes[i - 1];

            currentNodeType = _getNodeType(currentNode);



            if (currentNodeType == NodeType.LeafNode) {

                // Leaf nodes are already correctly encoded.

                // Shift the key over to account for the nodes key.

                bytes memory nodeKey = _getNodeKey(currentNode);

                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);

            } else if (currentNodeType == NodeType.ExtensionNode) {

                // Shift the key over to account for the nodes key.

                bytes memory nodeKey = _getNodeKey(currentNode);

                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);



                // If this node is the last element in the path, it'll be correctly encoded

                // and we can skip this part.

                if (previousNodeHash.length > 0) {

                    // Re-encode the node based on the previous node.

                    currentNode = _editExtensionNodeValue(currentNode, previousNodeHash);

                }

            } else if (currentNodeType == NodeType.BranchNode) {

                // If this node is the last element in the path, it'll be correctly encoded

                // and we can skip this part.

                if (previousNodeHash.length > 0) {

                    // Re-encode the node based on the previous node.

                    uint8 branchKey = uint8(key[key.length - 1]);

                    key = Lib_BytesUtils.slice(key, 0, key.length - 1);

                    currentNode = _editBranchIndex(currentNode, branchKey, previousNodeHash);

                }

            }



            // Compute the node hash for the next iteration.

            previousNodeHash = _getNodeHash(currentNode.encoded);

        }



        // Current node should be the root at this point.

        // Simply return the hash of its encoding.

        return keccak256(currentNode.encoded);

    }



    /**

     * @notice Parses an RLP-encoded proof into something more useful.

     * @param _proof RLP-encoded proof to parse.

     * @return _parsed Proof parsed into easily accessible structs.

     */

    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {

        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);

        TrieNode[] memory proof = new TrieNode[](nodes.length);



        for (uint256 i = 0; i < nodes.length; i++) {

            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);

            proof[i] = TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });

        }



        return proof;

    }



    /**

     * @notice Picks out the ID for a node. Node ID is referred to as the

     * "hash" within the specification, but nodes < 32 bytes are not actually

     * hashed.

     * @param _node Node to pull an ID for.

     * @return _nodeID ID for the node, depending on the size of its contents.

     */

    function _getNodeID(Lib_RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {

        bytes memory nodeID;



        if (_node.length < 32) {

            // Nodes smaller than 32 bytes are RLP encoded.

            nodeID = Lib_RLPReader.readRawBytes(_node);

        } else {

            // Nodes 32 bytes or larger are hashed.

            nodeID = Lib_RLPReader.readBytes(_node);

        }



        return Lib_BytesUtils.toBytes32(nodeID);

    }



    /**

     * @notice Gets the path for a leaf or extension node.

     * @param _node Node to get a path for.

     * @return _path Node path, converted to an array of nibbles.

     */

    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {

        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));

    }



    /**

     * @notice Gets the key for a leaf or extension node. Keys are essentially

     * just paths without any prefix.

     * @param _node Node to get a key for.

     * @return _key Node key, converted to an array of nibbles.

     */

    function _getNodeKey(TrieNode memory _node) private pure returns (bytes memory _key) {

        return _removeHexPrefix(_getNodePath(_node));

    }



    /**

     * @notice Gets the path for a node.

     * @param _node Node to get a value for.

     * @return _value Node value, as hex bytes.

     */

    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {

        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);

    }



    /**

     * @notice Computes the node hash for an encoded node. Nodes < 32 bytes

     * are not hashed, all others are keccak256 hashed.

     * @param _encoded Encoded node to hash.

     * @return _hash Hash of the encoded node. Simply the input if < 32 bytes.

     */

    function _getNodeHash(bytes memory _encoded) private pure returns (bytes memory _hash) {

        if (_encoded.length < 32) {

            return _encoded;

        } else {

            return abi.encodePacked(keccak256(_encoded));

        }

    }



    /**

     * @notice Determines the type for a given node.

     * @param _node Node to determine a type for.

     * @return _type Type of the node; BranchNode/ExtensionNode/LeafNode.

     */

    function _getNodeType(TrieNode memory _node) private pure returns (NodeType _type) {

        if (_node.decoded.length == BRANCH_NODE_LENGTH) {

            return NodeType.BranchNode;

        } else if (_node.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {

            bytes memory path = _getNodePath(_node);

            uint8 prefix = uint8(path[0]);



            if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {

                return NodeType.LeafNode;

            } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {

                return NodeType.ExtensionNode;

            }

        }



        revert("Invalid node type");

    }



    /**

     * @notice Utility; determines the number of nibbles shared between two

     * nibble arrays.

     * @param _a First nibble array.

     * @param _b Second nibble array.

     * @return _shared Number of shared nibbles.

     */

    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)

        private

        pure

        returns (uint256 _shared)

    {

        uint256 i = 0;

        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {

            i++;

        }

        return i;

    }



    /**

     * @notice Utility; converts an RLP-encoded node into our nice struct.

     * @param _raw RLP-encoded node to convert.

     * @return _node Node as a TrieNode struct.

     */

    function _makeNode(bytes[] memory _raw) private pure returns (TrieNode memory _node) {

        bytes memory encoded = Lib_RLPWriter.writeList(_raw);



        return TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });

    }



    /**

     * @notice Utility; converts an RLP-decoded node into our nice struct.

     * @param _items RLP-decoded node to convert.

     * @return _node Node as a TrieNode struct.

     */

    function _makeNode(Lib_RLPReader.RLPItem[] memory _items)

        private

        pure

        returns (TrieNode memory _node)

    {

        bytes[] memory raw = new bytes[](_items.length);

        for (uint256 i = 0; i < _items.length; i++) {

            raw[i] = Lib_RLPReader.readRawBytes(_items[i]);

        }

        return _makeNode(raw);

    }



    /**

     * @notice Creates a new extension node.

     * @param _key Key for the extension node, unprefixed.

     * @param _value Value for the extension node.

     * @return _node New extension node with the given k/v pair.

     */

    function _makeExtensionNode(bytes memory _key, bytes memory _value)

        private

        pure

        returns (TrieNode memory _node)

    {

        bytes[] memory raw = new bytes[](2);

        bytes memory key = _addHexPrefix(_key, false);

        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));

        raw[1] = Lib_RLPWriter.writeBytes(_value);

        return _makeNode(raw);

    }



    /**

     * Creates a new extension node with the same key but a different value.

     * @param _node Extension node to copy and modify.

     * @param _value New value for the extension node.

     * @return New node with the same key and different value.

     */

    function _editExtensionNodeValue(TrieNode memory _node, bytes memory _value)

        private

        pure

        returns (TrieNode memory)

    {

        bytes[] memory raw = new bytes[](2);

        bytes memory key = _addHexPrefix(_getNodeKey(_node), false);

        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));

        if (_value.length < 32) {

            raw[1] = _value;

        } else {

            raw[1] = Lib_RLPWriter.writeBytes(_value);

        }

        return _makeNode(raw);

    }



    /**

     * @notice Creates a new leaf node.

     * @dev This function is essentially identical to `_makeExtensionNode`.

     * Although we could route both to a single method with a flag, it's

     * more gas efficient to keep them separate and duplicate the logic.

     * @param _key Key for the leaf node, unprefixed.

     * @param _value Value for the leaf node.

     * @return _node New leaf node with the given k/v pair.

     */

    function _makeLeafNode(bytes memory _key, bytes memory _value)

        private

        pure

        returns (TrieNode memory _node)

    {

        bytes[] memory raw = new bytes[](2);

        bytes memory key = _addHexPrefix(_key, true);

        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));

        raw[1] = Lib_RLPWriter.writeBytes(_value);

        return _makeNode(raw);

    }



    /**

     * @notice Creates an empty branch node.

     * @return _node Empty branch node as a TrieNode struct.

     */

    function _makeEmptyBranchNode() private pure returns (TrieNode memory _node) {

        bytes[] memory raw = new bytes[](BRANCH_NODE_LENGTH);

        for (uint256 i = 0; i < raw.length; i++) {

            raw[i] = RLP_NULL_BYTES;

        }

        return _makeNode(raw);

    }



    /**

     * @notice Modifies the value slot for a given branch.

     * @param _branch Branch node to modify.

     * @param _value Value to insert into the branch.

     * @return _updatedNode Modified branch node.

     */

    function _editBranchValue(TrieNode memory _branch, bytes memory _value)

        private

        pure

        returns (TrieNode memory _updatedNode)

    {

        bytes memory encoded = Lib_RLPWriter.writeBytes(_value);

        _branch.decoded[_branch.decoded.length - 1] = Lib_RLPReader.toRLPItem(encoded);

        return _makeNode(_branch.decoded);

    }



    /**

     * @notice Modifies a slot at an index for a given branch.

     * @param _branch Branch node to modify.

     * @param _index Slot index to modify.

     * @param _value Value to insert into the slot.

     * @return _updatedNode Modified branch node.

     */

    function _editBranchIndex(

        TrieNode memory _branch,

        uint8 _index,

        bytes memory _value

    ) private pure returns (TrieNode memory _updatedNode) {

        bytes memory encoded = _value.length < 32 ? _value : Lib_RLPWriter.writeBytes(_value);

        _branch.decoded[_index] = Lib_RLPReader.toRLPItem(encoded);

        return _makeNode(_branch.decoded);

    }



    /**

     * @notice Utility; adds a prefix to a key.

     * @param _key Key to prefix.

     * @param _isLeaf Whether or not the key belongs to a leaf.

     * @return _prefixedKey Prefixed key.

     */

    function _addHexPrefix(bytes memory _key, bool _isLeaf)

        private

        pure

        returns (bytes memory _prefixedKey)

    {

        uint8 prefix = _isLeaf ? uint8(0x02) : uint8(0x00);

        uint8 offset = uint8(_key.length % 2);

        bytes memory prefixed = new bytes(2 - offset);

        prefixed[0] = bytes1(prefix + offset);

        return abi.encodePacked(prefixed, _key);

    }



    /**

     * @notice Utility; removes a prefix from a path.

     * @param _path Path to remove the prefix from.

     * @return _unprefixedKey Unprefixed key.

     */

    function _removeHexPrefix(bytes memory _path)

        private

        pure

        returns (bytes memory _unprefixedKey)

    {

        if (uint8(_path[0]) % 2 == 0) {

            return Lib_BytesUtils.slice(_path, 2);

        } else {

            return Lib_BytesUtils.slice(_path, 1);

        }

    }



    /**

     * @notice Utility; combines two node arrays. Array lengths are required

     * because the actual lengths may be longer than the filled lengths.

     * Array resizing is extremely costly and should be avoided.

     * @param _a First array to join.

     * @param _aLength Length of the first array.

     * @param _b Second array to join.

     * @param _bLength Length of the second array.

     * @return _joined Combined node array.

     */

    function _joinNodeArrays(

        TrieNode[] memory _a,

        uint256 _aLength,

        TrieNode[] memory _b,

        uint256 _bLength

    ) private pure returns (TrieNode[] memory _joined) {

        TrieNode[] memory ret = new TrieNode[](_aLength + _bLength);



        // Copy elements from the first array.

        for (uint256 i = 0; i < _aLength; i++) {

            ret[i] = _a[i];

        }



        // Copy elements from the second array.

        for (uint256 i = 0; i < _bLength; i++) {

            ret[i + _aLength] = _b[i];

        }



        return ret;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_OVMCodec.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_RLPReader } from "../rlp/Lib_RLPReader.sol";

import { Lib_RLPWriter } from "../rlp/Lib_RLPWriter.sol";

import { Lib_BytesUtils } from "../utils/Lib_BytesUtils.sol";

import { Lib_Bytes32Utils } from "../utils/Lib_Bytes32Utils.sol";



/**

 * @title Lib_OVMCodec

 */

library Lib_OVMCodec {

    /*********

     * Enums *

     *********/



    enum QueueOrigin {

        SEQUENCER_QUEUE,

        L1TOL2_QUEUE

    }



    /***********

     * Structs *

     ***********/



    struct EVMAccount {

        uint256 nonce;

        uint256 balance;

        bytes32 storageRoot;

        bytes32 codeHash;

    }



    struct ChainBatchHeader {

        uint256 batchIndex;

        bytes32 batchRoot;

        uint256 batchSize;

        uint256 prevTotalElements;

        bytes extraData;

    }



    struct ChainInclusionProof {

        uint256 index;

        bytes32[] siblings;

    }



    struct Transaction {

        uint256 timestamp;

        uint256 blockNumber;

        QueueOrigin l1QueueOrigin;

        address l1TxOrigin;

        address entrypoint;

        uint256 gasLimit;

        bytes data;

    }



    struct TransactionChainElement {

        bool isSequenced;

        uint256 queueIndex; // QUEUED TX ONLY

        uint256 timestamp; // SEQUENCER TX ONLY

        uint256 blockNumber; // SEQUENCER TX ONLY

        bytes txData; // SEQUENCER TX ONLY

    }



    struct QueueElement {

        bytes32 transactionHash;

        uint40 timestamp;

        uint40 blockNumber;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Encodes a standard OVM transaction.

     * @param _transaction OVM transaction to encode.

     * @return Encoded transaction bytes.

     */

    function encodeTransaction(Transaction memory _transaction)

        internal

        pure

        returns (bytes memory)

    {

        return

            abi.encodePacked(

                _transaction.timestamp,

                _transaction.blockNumber,

                _transaction.l1QueueOrigin,

                _transaction.l1TxOrigin,

                _transaction.entrypoint,

                _transaction.gasLimit,

                _transaction.data

            );

    }



    /**

     * Hashes a standard OVM transaction.

     * @param _transaction OVM transaction to encode.

     * @return Hashed transaction

     */

    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {

        return keccak256(encodeTransaction(_transaction));

    }



    /**

     * @notice Decodes an RLP-encoded account state into a useful struct.

     * @param _encoded RLP-encoded account state.

     * @return Account state struct.

     */

    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {

        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);



        return

            EVMAccount({

                nonce: Lib_RLPReader.readUint256(accountState[0]),

                balance: Lib_RLPReader.readUint256(accountState[1]),

                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),

                codeHash: Lib_RLPReader.readBytes32(accountState[3])

            });

    }



    /**

     * Calculates a hash for a given batch header.

     * @param _batchHeader Header to hash.

     * @return Hash of the header.

     */

    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)

        internal

        pure

        returns (bytes32)

    {

        return

            keccak256(

                abi.encode(

                    _batchHeader.batchRoot,

                    _batchHeader.batchSize,

                    _batchHeader.prevTotalElements,

                    _batchHeader.extraData

                )

            );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_PredeployAddresses.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_PredeployAddresses

 */

library Lib_PredeployAddresses {

    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;

    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;

    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;

    address internal constant MVM_CHAIN_CONFIG = 0x4200000000000000000000000000000000000005;

    address internal constant OVM_ETH = 0x420000000000000000000000000000000000000A;

    address internal constant MVM_COINBASE = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;

    address internal constant L2_CROSS_DOMAIN_MESSENGER =

        0x4200000000000000000000000000000000000007;

    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;

    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;

    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;

    address payable internal constant SEQUENCER_FEE_WALLET = payable(0x4200000000000000000000000000000000000011);

    address internal constant L2_STANDARD_TOKEN_FACTORY =

        0x4200000000000000000000000000000000000012;

    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;

    address internal constant OVM_GASPRICE_ORACLE = 0x420000000000000000000000000000000000000F;

    

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_ResolvedDelegateProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_AddressManager } from "./Lib_AddressManager.sol";



/**

 * @title Lib_ResolvedDelegateProxy

 */

contract Lib_ResolvedDelegateProxy {

    /*************

     * Variables *

     *************/



    // Using mappings to store fields to avoid overwriting storage slots in the

    // implementation contract. For example, instead of storing these fields at

    // storage slot `0` & `1`, they are stored at `keccak256(key + slot)`.

    // See: https://solidity.readthedocs.io/en/v0.7.0/internals/layout_in_storage.html

    // NOTE: Do not use this code in your own contract system.

    //      There is a known flaw in this contract, and we will remove it from the repository

    //      in the near future. Due to the very limited way that we are using it, this flaw is

    //      not an issue in our system.

    mapping(address => string) private implementationName;

    mapping(address => Lib_AddressManager) private addressManager;



    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Lib_AddressManager.

     * @param _implementationName implementationName of the contract to proxy to.

     */

    constructor(address _libAddressManager, string memory _implementationName) {

        addressManager[address(this)] = Lib_AddressManager(_libAddressManager);

        implementationName[address(this)] = _implementationName;

    }



    /*********************

     * Fallback Function *

     *********************/



    fallback() external payable {

        address target = addressManager[address(this)].getAddress(

            (implementationName[address(this)])

        );



        require(target != address(0), "Target address must be initialized.");



        (bool success, bytes memory returndata) = target.delegatecall(msg.data);



        if (success == true) {

            assembly {

                return(add(returndata, 0x20), mload(returndata))

            }

        } else {

            assembly {

                revert(add(returndata, 0x20), mload(returndata))

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_RLPReader.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_RLPReader

 * @dev Adapted from "RLPReader" by Hamdi Allam (hamdi.allam97@gmail.com).

 */

library Lib_RLPReader {

    /*************

     * Constants *

     *************/



    uint256 internal constant MAX_LIST_LENGTH = 32;



    /*********

     * Enums *

     *********/



    enum RLPItemType {

        DATA_ITEM,

        LIST_ITEM

    }



    /***********

     * Structs *

     ***********/



    struct RLPItem {

        uint256 length;

        uint256 ptr;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Converts bytes to a reference to memory position and length.

     * @param _in Input bytes to convert.

     * @return Output memory reference.

     */

    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {

        uint256 ptr;

        assembly {

            ptr := add(_in, 32)

        }



        return RLPItem({ length: _in.length, ptr: ptr });

    }



    /**

     * Reads an RLP list value into a list of RLP items.

     * @param _in RLP list value.

     * @return Decoded RLP list items.

     */

    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {

        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);



        require(itemType == RLPItemType.LIST_ITEM, "Invalid RLP list value.");



        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by

        // writing to the length. Since we can't know the number of RLP items without looping over

        // the entire input, we'd have to loop twice to accurately size this array. It's easier to

        // simply set a reasonable maximum list length and decrease the size before we finish.

        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);



        uint256 itemCount = 0;

        uint256 offset = listOffset;

        while (offset < _in.length) {

            require(itemCount < MAX_LIST_LENGTH, "Provided RLP list exceeds max list length.");



            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(

                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })

            );



            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });



            itemCount += 1;

            offset += itemOffset + itemLength;

        }



        // Decrease the array size to match the actual item count.

        assembly {

            mstore(out, itemCount)

        }



        return out;

    }



    /**

     * Reads an RLP list value into a list of RLP items.

     * @param _in RLP list value.

     * @return Decoded RLP list items.

     */

    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {

        return readList(toRLPItem(_in));

    }



    /**

     * Reads an RLP bytes value into bytes.

     * @param _in RLP bytes value.

     * @return Decoded bytes.

     */

    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {

        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);



        require(itemType == RLPItemType.DATA_ITEM, "Invalid RLP bytes value.");



        return _copy(_in.ptr, itemOffset, itemLength);

    }



    /**

     * Reads an RLP bytes value into bytes.

     * @param _in RLP bytes value.

     * @return Decoded bytes.

     */

    function readBytes(bytes memory _in) internal pure returns (bytes memory) {

        return readBytes(toRLPItem(_in));

    }



    /**

     * Reads an RLP string value into a string.

     * @param _in RLP string value.

     * @return Decoded string.

     */

    function readString(RLPItem memory _in) internal pure returns (string memory) {

        return string(readBytes(_in));

    }



    /**

     * Reads an RLP string value into a string.

     * @param _in RLP string value.

     * @return Decoded string.

     */

    function readString(bytes memory _in) internal pure returns (string memory) {

        return readString(toRLPItem(_in));

    }



    /**

     * Reads an RLP bytes32 value into a bytes32.

     * @param _in RLP bytes32 value.

     * @return Decoded bytes32.

     */

    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {

        require(_in.length <= 33, "Invalid RLP bytes32 value.");



        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);



        require(itemType == RLPItemType.DATA_ITEM, "Invalid RLP bytes32 value.");



        uint256 ptr = _in.ptr + itemOffset;

        bytes32 out;

        assembly {

            out := mload(ptr)



            // Shift the bytes over to match the item size.

            if lt(itemLength, 32) {

                out := div(out, exp(256, sub(32, itemLength)))

            }

        }



        return out;

    }



    /**

     * Reads an RLP bytes32 value into a bytes32.

     * @param _in RLP bytes32 value.

     * @return Decoded bytes32.

     */

    function readBytes32(bytes memory _in) internal pure returns (bytes32) {

        return readBytes32(toRLPItem(_in));

    }



    /**

     * Reads an RLP uint256 value into a uint256.

     * @param _in RLP uint256 value.

     * @return Decoded uint256.

     */

    function readUint256(RLPItem memory _in) internal pure returns (uint256) {

        return uint256(readBytes32(_in));

    }



    /**

     * Reads an RLP uint256 value into a uint256.

     * @param _in RLP uint256 value.

     * @return Decoded uint256.

     */

    function readUint256(bytes memory _in) internal pure returns (uint256) {

        return readUint256(toRLPItem(_in));

    }



    /**

     * Reads an RLP bool value into a bool.

     * @param _in RLP bool value.

     * @return Decoded bool.

     */

    function readBool(RLPItem memory _in) internal pure returns (bool) {

        require(_in.length == 1, "Invalid RLP boolean value.");



        uint256 ptr = _in.ptr;

        uint256 out;

        assembly {

            out := byte(0, mload(ptr))

        }



        require(out == 0 || out == 1, "Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1");



        return out != 0;

    }



    /**

     * Reads an RLP bool value into a bool.

     * @param _in RLP bool value.

     * @return Decoded bool.

     */

    function readBool(bytes memory _in) internal pure returns (bool) {

        return readBool(toRLPItem(_in));

    }



    /**

     * Reads an RLP address value into a address.

     * @param _in RLP address value.

     * @return Decoded address.

     */

    function readAddress(RLPItem memory _in) internal pure returns (address) {

        if (_in.length == 1) {

            return address(0);

        }



        require(_in.length == 21, "Invalid RLP address value.");



        return address(uint160(readUint256(_in)));

    }



    /**

     * Reads an RLP address value into a address.

     * @param _in RLP address value.

     * @return Decoded address.

     */

    function readAddress(bytes memory _in) internal pure returns (address) {

        return readAddress(toRLPItem(_in));

    }



    /**

     * Reads the raw bytes of an RLP item.

     * @param _in RLP item to read.

     * @return Raw RLP bytes.

     */

    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {

        return _copy(_in);

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Decodes the length of an RLP item.

     * @param _in RLP item to decode.

     * @return Offset of the encoded data.

     * @return Length of the encoded data.

     * @return RLP item type (LIST_ITEM or DATA_ITEM).

     */

    function _decodeLength(RLPItem memory _in)

        private

        pure

        returns (

            uint256,

            uint256,

            RLPItemType

        )

    {

        require(_in.length > 0, "RLP item cannot be null.");



        uint256 ptr = _in.ptr;

        uint256 prefix;

        assembly {

            prefix := byte(0, mload(ptr))

        }



        if (prefix <= 0x7f) {

            // Single byte.



            return (0, 1, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xb7) {

            // Short string.



            uint256 strLen = prefix - 0x80;



            require(_in.length > strLen, "Invalid RLP short string.");



            return (1, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xbf) {

            // Long string.

            uint256 lenOfStrLen = prefix - 0xb7;



            require(_in.length > lenOfStrLen, "Invalid RLP long string length.");



            uint256 strLen;

            assembly {

                // Pick out the string length.

                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))

            }



            require(_in.length > lenOfStrLen + strLen, "Invalid RLP long string.");



            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xf7) {

            // Short list.

            uint256 listLen = prefix - 0xc0;



            require(_in.length > listLen, "Invalid RLP short list.");



            return (1, listLen, RLPItemType.LIST_ITEM);

        } else {

            // Long list.

            uint256 lenOfListLen = prefix - 0xf7;



            require(_in.length > lenOfListLen, "Invalid RLP long list length.");



            uint256 listLen;

            assembly {

                // Pick out the list length.

                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))

            }



            require(_in.length > lenOfListLen + listLen, "Invalid RLP long list.");



            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);

        }

    }



    /**

     * Copies the bytes from a memory location.

     * @param _src Pointer to the location to read from.

     * @param _offset Offset to start reading from.

     * @param _length Number of bytes to read.

     * @return Copied bytes.

     */

    function _copy(

        uint256 _src,

        uint256 _offset,

        uint256 _length

    ) private pure returns (bytes memory) {

        bytes memory out = new bytes(_length);

        if (out.length == 0) {

            return out;

        }



        uint256 src = _src + _offset;

        uint256 dest;

        assembly {

            dest := add(out, 32)

        }



        // Copy over as many complete words as we can.

        for (uint256 i = 0; i < _length / 32; i++) {

            assembly {

                mstore(dest, mload(src))

            }



            src += 32;

            dest += 32;

        }



        // Pick out the remaining bytes.

        uint256 mask;

        unchecked {

            mask = 256**(32 - (_length % 32)) - 1;

        }



        assembly {

            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))

        }

        return out;

    }



    /**

     * Copies an RLP item into bytes.

     * @param _in RLP item to copy.

     * @return Copied bytes.

     */

    function _copy(RLPItem memory _in) private pure returns (bytes memory) {

        return _copy(_in.ptr, 0, _in.length);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_RLPWriter.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_RLPWriter

 * @author Bakaoh (with modifications)

 */

library Lib_RLPWriter {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * RLP encodes a byte string.

     * @param _in The byte string to encode.

     * @return The RLP encoded string in bytes.

     */

    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {

        bytes memory encoded;



        if (_in.length == 1 && uint8(_in[0]) < 128) {

            encoded = _in;

        } else {

            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);

        }



        return encoded;

    }



    /**

     * RLP encodes a list of RLP encoded byte byte strings.

     * @param _in The list of RLP encoded byte strings.

     * @return The RLP encoded list of items in bytes.

     */

    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {

        bytes memory list = _flatten(_in);

        return abi.encodePacked(_writeLength(list.length, 192), list);

    }



    /**

     * RLP encodes a string.

     * @param _in The string to encode.

     * @return The RLP encoded string in bytes.

     */

    function writeString(string memory _in) internal pure returns (bytes memory) {

        return writeBytes(bytes(_in));

    }



    /**

     * RLP encodes an address.

     * @param _in The address to encode.

     * @return The RLP encoded address in bytes.

     */

    function writeAddress(address _in) internal pure returns (bytes memory) {

        return writeBytes(abi.encodePacked(_in));

    }



    /**

     * RLP encodes a uint.

     * @param _in The uint256 to encode.

     * @return The RLP encoded uint256 in bytes.

     */

    function writeUint(uint256 _in) internal pure returns (bytes memory) {

        return writeBytes(_toBinary(_in));

    }



    /**

     * RLP encodes a bool.

     * @param _in The bool to encode.

     * @return The RLP encoded bool in bytes.

     */

    function writeBool(bool _in) internal pure returns (bytes memory) {

        bytes memory encoded = new bytes(1);

        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));

        return encoded;

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.

     * @param _len The length of the string or the payload.

     * @param _offset 128 if item is string, 192 if item is list.

     * @return RLP encoded bytes.

     */

    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {

        bytes memory encoded;



        if (_len < 56) {

            encoded = new bytes(1);

            encoded[0] = bytes1(uint8(_len) + uint8(_offset));

        } else {

            uint256 lenLen;

            uint256 i = 1;

            while (_len / i != 0) {

                lenLen++;

                i *= 256;

            }



            encoded = new bytes(lenLen + 1);

            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);

            for (i = 1; i <= lenLen; i++) {

                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));

            }

        }



        return encoded;

    }



    /**

     * Encode integer in big endian binary form with no leading zeroes.

     * @notice TODO: This should be optimized with assembly to save gas costs.

     * @param _x The integer to encode.

     * @return RLP encoded bytes.

     */

    function _toBinary(uint256 _x) private pure returns (bytes memory) {

        bytes memory b = abi.encodePacked(_x);



        uint256 i = 0;

        for (; i < 32; i++) {

            if (b[i] != 0) {

                break;

            }

        }



        bytes memory res = new bytes(32 - i);

        for (uint256 j = 0; j < res.length; j++) {

            res[j] = b[i++];

        }



        return res;

    }



    /**

     * Copies a piece of memory to another location.

     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.

     * @param _dest Destination location.

     * @param _src Source location.

     * @param _len Length of memory to copy.

     */

    function _memcpy(

        uint256 _dest,

        uint256 _src,

        uint256 _len

    ) private pure {

        uint256 dest = _dest;

        uint256 src = _src;

        uint256 len = _len;



        for (; len >= 32; len -= 32) {

            assembly {

                mstore(dest, mload(src))

            }

            dest += 32;

            src += 32;

        }



        uint256 mask;

        unchecked {

            mask = 256**(32 - len) - 1;

        }

        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }

    }



    /**

     * Flattens a list of byte strings into one byte string.

     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.

     * @param _list List of byte strings to flatten.

     * @return The flattened byte string.

     */

    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {

        if (_list.length == 0) {

            return new bytes(0);

        }



        uint256 len;

        uint256 i = 0;

        for (; i < _list.length; i++) {

            len += _list[i].length;

        }



        bytes memory flattened = new bytes(len);

        uint256 flattenedPtr;

        assembly {

            flattenedPtr := add(flattened, 0x20)

        }



        for (i = 0; i < _list.length; i++) {

            bytes memory item = _list[i];



            uint256 listPtr;

            assembly {

                listPtr := add(item, 0x20)

            }



            _memcpy(flattenedPtr, listPtr, item.length);

            flattenedPtr += _list[i].length;

        }



        return flattened;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Lib_SecureMerkleTrie.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* Library Imports */

import { Lib_MerkleTrie } from "./Lib_MerkleTrie.sol";



/**

 * @title Lib_SecureMerkleTrie

 */

library Lib_SecureMerkleTrie {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * @notice Verifies a proof that a given key/value pair is present in the

     * Merkle trie.

     * @param _key Key of the node to search for, as a hex string.

     * @param _value Value of the node to search for, as a hex string.

     * @param _proof Merkle trie inclusion proof for the desired node. Unlike

     * traditional Merkle trees, this proof is executed top-down and consists

     * of a list of RLP-encoded nodes that make a path down to the target node.

     * @param _root Known root of the Merkle trie. Used to verify that the

     * included proof is correctly constructed.

     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.

     */

    function verifyInclusionProof(

        bytes memory _key,

        bytes memory _value,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bool _verified) {

        bytes memory key = _getSecureKey(_key);

        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);

    }



    /**

     * @notice Updates a Merkle trie and returns a new root hash.

     * @param _key Key of the node to update, as a hex string.

     * @param _value Value of the node to update, as a hex string.

     * @param _proof Merkle trie inclusion proof for the node *nearest* the

     * target node. If the key exists, we can simply update the value.

     * Otherwise, we need to modify the trie to handle the new k/v pair.

     * @param _root Known root of the Merkle trie. Used to verify that the

     * included proof is correctly constructed.

     * @return _updatedRoot Root hash of the newly constructed trie.

     */

    function update(

        bytes memory _key,

        bytes memory _value,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bytes32 _updatedRoot) {

        bytes memory key = _getSecureKey(_key);

        return Lib_MerkleTrie.update(key, _value, _proof, _root);

    }



    /**

     * @notice Retrieves the value associated with a given key.

     * @param _key Key to search for, as hex bytes.

     * @param _proof Merkle trie inclusion proof for the key.

     * @param _root Known root of the Merkle trie.

     * @return _exists Whether or not the key exists.

     * @return _value Value of the key if it exists.

     */

    function get(

        bytes memory _key,

        bytes memory _proof,

        bytes32 _root

    ) internal pure returns (bool _exists, bytes memory _value) {

        bytes memory key = _getSecureKey(_key);

        return Lib_MerkleTrie.get(key, _proof, _root);

    }



    /**

     * Computes the root hash for a trie with a single node.

     * @param _key Key for the single node.

     * @param _value Value for the single node.

     * @return _updatedRoot Hash of the trie.

     */

    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)

        internal

        pure

        returns (bytes32 _updatedRoot)

    {

        bytes memory key = _getSecureKey(_key);

        return Lib_MerkleTrie.getSingleNodeRootHash(key, _value);

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Computes the secure counterpart to a key.

     * @param _key Key to get a secure key from.

     * @return _secureKey Secure version of the key.

     */

    function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {

        return abi.encodePacked(keccak256(_key));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\MVM_CanonicalTransaction.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2022-04-12

*/



// Sources flattened with hardhat v2.6.1 https://hardhat.org



// File @openzeppelin/contracts/utils/Context.sol@v4.3.2



// : MIT



pragma solidity ^0.8.0;



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}





// File @openzeppelin/contracts/access/Ownable.sol@v4.3.2



// : MIT



pragma solidity ^0.8.0;



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _setOwner(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _setOwner(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _setOwner(newOwner);

    }



    function _setOwner(address newOwner) private {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}





// File contracts/libraries/resolver/Lib_AddressManager.sol



// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* External Imports */



/**

 * @title Lib_AddressManager

 */

contract Lib_AddressManager is Ownable {

    /**********

     * Events *

     **********/



    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);



    /*************

     * Variables *

     *************/



    mapping(bytes32 => address) private addresses;



    /********************

     * Public Functions *

     ********************/



    /**

     * Changes the address associated with a particular name.

     * @param _name String name to associate an address with.

     * @param _address Address to associate with the name.

     */

    function setAddress(string memory _name, address _address) external onlyOwner {

        bytes32 nameHash = _getNameHash(_name);

        address oldAddress = addresses[nameHash];

        addresses[nameHash] = _address;



        emit AddressSet(_name, _address, oldAddress);

    }



    /**

     * Retrieves the address associated with a given name.

     * @param _name Name to retrieve an address for.

     * @return Address associated with the given name.

     */

    function getAddress(string memory _name) external view returns (address) {

        return addresses[_getNameHash(_name)];

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Computes the hash of a name.

     * @param _name Name to compute a hash for.

     * @return Hash of the given name.

     */

    function _getNameHash(string memory _name) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked(_name));

    }

}





// File contracts/libraries/resolver/Lib_AddressResolver.sol



// : MIT

pragma solidity ^0.8.9;



/* Library Imports */



/**

 * @title Lib_AddressResolver

 */

abstract contract Lib_AddressResolver {

    /*************

     * Variables *

     *************/



    Lib_AddressManager public libAddressManager;



    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Lib_AddressManager.

     */

    constructor(address _libAddressManager) {

        libAddressManager = Lib_AddressManager(_libAddressManager);

    }



    /********************

     * Public Functions *

     ********************/



    /**

     * Resolves the address associated with a given name.

     * @param _name Name to resolve an address for.

     * @return Address associated with the given name.

     */

    function resolve(string memory _name) public view returns (address) {

        return libAddressManager.getAddress(_name);

    }

}





// File contracts/MVM/iMVM_CanonicalTransaction.sol



// : MIT

pragma solidity ^0.8.9;



/* Contract Imports */



/* External Imports */



/**

 * @title ICanonicalTransactionChain

 */

interface iMVM_CanonicalTransaction {

    /*********

     * Enums *

     *********/



    enum STAKESTATUS {

        INIT,

        SEQ_SET,

        VERIFIER_SET,

        PAYBACK

    }



    /**********

     * Events *

     **********/



    event VerifierStake(

        address _sender,

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber,

        uint256 _amount

    );



    // default : stakeAmount=0, verified=true, sequencer=true

    // sequencer response for stake: stakeAmount>0, verified=true, sequencer=true

    // verifier response for stake timeout: stakeAmount>0, verified=false, sequencer=false

    event SetBatchTxData(

        address _sender,

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber,

        uint256 _stakeAmount,

        bool _verified,

        bool _sequencer

    );



    event AppendBatchElement (

        uint256 _chainId,

        uint256 _batchIndex,

        uint40 _shouldStartAtElement,

        uint24 _totalElementsToAppend,

        uint256 _txBatchSize,

        uint256 _txBatchTime,

        bytes32 _root

    );



    /***********

     * Structs *

     ***********/



    // locker the same sender for 30 min

    struct TxDataSlice {

        address sender;

        uint256 blockNumber;

        uint256 batchIndex;

        uint256 timestamp;

        bytes txData;

        bool verified;

    }



    struct TxDataRequestStake {

        address sender;

        uint256 blockNumber;

        uint256 batchIndex;

        uint256 timestamp;

        uint256 endtime;

        uint256 amount;

        STAKESTATUS status;

    }



    struct BatchElement {

        uint40 shouldStartAtElement;

        uint24 totalElementsToAppend;

        uint256 txBatchSize;

        uint256 txBatchTime; // sequencer client encode timestamp(ms)

        bytes32 root; // merkle hash root with [hash(txDataBytes + blockNumber)]

        uint256 timestamp; // block timestamp

    }



    /*******************************

     * Authorized Setter Functions *

     *******************************/



    /**

     * Sets address's chain id.

     * @param _address contract address.

     * @param _chainId chain id.

     */

    // function setAddressChainId(address _address, uint256 _chainId) external;



    /**

     * Gets address's chain id.

     */

    // function getAddressChainId(address _address) external view returns (uint256);



    /**

     * Sets the verifier stake base cost of ETH.

     * @param _stakeBaseCost Stake base cost for verifier.

     */

    function setStakeBaseCost(uint256 _stakeBaseCost) external;



    /**

     * Gets the verifier stake base cost of ETH.

     */

    function getStakeBaseCost() external view returns (uint256);



    /**

     * Sets the verifier stake unit cost of ETH.

     * @param _stakeUnitCost Stake cost for verifier.

     */

    function setStakeUnitCost(uint256 _stakeUnitCost) external;



    /**

     * Gets the verifier stake unit cost of ETH for per storage unit.

     */

    function getStakeUnitCost() external view returns (uint256);



    /**

     * Gets the verifier stake cost of ETH by batch index.

     */

    function getStakeCostByBatch(uint256 _chainId, uint256 _batchIndex) external view returns (uint256);



    /**

     * Sets batch transaction data slice size per submit.

     * @param _size Slice size of batch transaction data.

     */

    function setTxDataSliceSize(uint256 _size) external;



    /**

     * Gets batch transaction data slice size per submit.

     */

    function getTxDataSliceSize() external view returns (uint256);



    /**

     * Sets batch size per batch.

     * @param _size Batch size of batch.

     */

    function setTxBatchSize(uint256 _size) external;



    /**

     * Gets batch size per batch.

     */

    function getTxBatchSize() external view returns (uint256);



    /**

     * Sets slice count per batch transaction data.

     * @param _count Slice count per batch transaction data.

     */

    function setTxDataSliceCount(uint256 _count) external;



    /**

     * Gets slice count per batch transaction data.

     */

    function getTxDataSliceCount() external view returns (uint256);



    /**

     * Sets seconds can submit transaction data after staking.

     * @param _seconds Seconds the Sequencer can sumbit transaction data after verifier staking.

     */

    function setStakeSeqSeconds(uint256 _seconds) external;



    /**

     * Gets seconds can submit transaction data after staking.

     * @return Seconds the Sequencer can sumbit transaction data after verifier staking.

     */

    function getStakeSeqSeconds() external view returns (uint256);



    function isWhiteListed(address _verifier) external view returns(bool);



    // add the verifier to the whitelist

    function setWhiteList(address _verifier, bool _allowed) external;



    // allow everyone to be the verifier

    function disableWhiteList() external;



    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     */

    function appendSequencerBatchByChainId() external;



    /**

     * Sets batch tx data for stake.

     * @param _chainId chain id.

     * @param _batchIndex batch index of CTC.

     * @param _blockNumber slice index.

     * @param _data tx data hex.

    */

    function setBatchTxDataForStake(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber, bytes memory _data, uint256 _leafIndex, uint256 _totalLeaves, bytes32[] memory _proof) external;



    /**

     * Sets batch tx data for verifier.

     * @param _chainId chain id.

     * @param _batchIndex batch index of CTC.

     * @param _blockNumber slice index.

     * @param _data tx data hex.

    */

    function setBatchTxDataForVerifier(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber, bytes memory _data) external;



    /**

     * Gets batch tx data.

     * @param _chainId chain id.

     * @param _batchIndex batch index of CTC.

     * @param _blockNumber block number.

     * @return txData

     * @return verified

    */

    function getBatchTxData(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber) external view returns (bytes memory txData, bool verified);



    function checkBatchTxHash(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber, bytes memory _data) external view returns (bytes32 txHash, bool verified);



    function setBatchTxDataVerified(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber, bool _verified) external;



    /**

     * Stake by verifier.

     * @param _chainId chain id.

     * @param _batchIndex batch index of CTC.

     * @param _blockNumber block number.

    */

    function verifierStake(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber) external payable;



    /**

     * Withdraw stake by verifier.

     * @param _chainId chain id.

     * @param _batchIndex batch index of CTC.

     * @param _blockNumber block number.

    */

    function withdrawStake(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber) external;



}





// File contracts/libraries/rlp/Lib_RLPReader.sol



// : MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_RLPReader

 * @dev Adapted from "RLPReader" by Hamdi Allam (hamdi.allam97@gmail.com).

 */

library Lib_RLPReader {

    /*************

     * Constants *

     *************/



    uint256 internal constant MAX_LIST_LENGTH = 32;



    /*********

     * Enums *

     *********/



    enum RLPItemType {

        DATA_ITEM,

        LIST_ITEM

    }



    /***********

     * Structs *

     ***********/



    struct RLPItem {

        uint256 length;

        uint256 ptr;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Converts bytes to a reference to memory position and length.

     * @param _in Input bytes to convert.

     * @return Output memory reference.

     */

    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {

        uint256 ptr;

        assembly {

            ptr := add(_in, 32)

        }



        return RLPItem({ length: _in.length, ptr: ptr });

    }



    /**

     * Reads an RLP list value into a list of RLP items.

     * @param _in RLP list value.

     * @return Decoded RLP list items.

     */

    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {

        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);



        require(itemType == RLPItemType.LIST_ITEM, "Invalid RLP list value.");



        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by

        // writing to the length. Since we can't know the number of RLP items without looping over

        // the entire input, we'd have to loop twice to accurately size this array. It's easier to

        // simply set a reasonable maximum list length and decrease the size before we finish.

        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);



        uint256 itemCount = 0;

        uint256 offset = listOffset;

        while (offset < _in.length) {

            require(itemCount < MAX_LIST_LENGTH, "Provided RLP list exceeds max list length.");



            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(

                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })

            );



            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });



            itemCount += 1;

            offset += itemOffset + itemLength;

        }



        // Decrease the array size to match the actual item count.

        assembly {

            mstore(out, itemCount)

        }



        return out;

    }



    /**

     * Reads an RLP list value into a list of RLP items.

     * @param _in RLP list value.

     * @return Decoded RLP list items.

     */

    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {

        return readList(toRLPItem(_in));

    }



    /**

     * Reads an RLP bytes value into bytes.

     * @param _in RLP bytes value.

     * @return Decoded bytes.

     */

    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {

        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);



        require(itemType == RLPItemType.DATA_ITEM, "Invalid RLP bytes value.");



        return _copy(_in.ptr, itemOffset, itemLength);

    }



    /**

     * Reads an RLP bytes value into bytes.

     * @param _in RLP bytes value.

     * @return Decoded bytes.

     */

    function readBytes(bytes memory _in) internal pure returns (bytes memory) {

        return readBytes(toRLPItem(_in));

    }



    /**

     * Reads an RLP string value into a string.

     * @param _in RLP string value.

     * @return Decoded string.

     */

    function readString(RLPItem memory _in) internal pure returns (string memory) {

        return string(readBytes(_in));

    }



    /**

     * Reads an RLP string value into a string.

     * @param _in RLP string value.

     * @return Decoded string.

     */

    function readString(bytes memory _in) internal pure returns (string memory) {

        return readString(toRLPItem(_in));

    }



    /**

     * Reads an RLP bytes32 value into a bytes32.

     * @param _in RLP bytes32 value.

     * @return Decoded bytes32.

     */

    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {

        require(_in.length <= 33, "Invalid RLP bytes32 value.");



        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);



        require(itemType == RLPItemType.DATA_ITEM, "Invalid RLP bytes32 value.");



        uint256 ptr = _in.ptr + itemOffset;

        bytes32 out;

        assembly {

            out := mload(ptr)



            // Shift the bytes over to match the item size.

            if lt(itemLength, 32) {

                out := div(out, exp(256, sub(32, itemLength)))

            }

        }



        return out;

    }



    /**

     * Reads an RLP bytes32 value into a bytes32.

     * @param _in RLP bytes32 value.

     * @return Decoded bytes32.

     */

    function readBytes32(bytes memory _in) internal pure returns (bytes32) {

        return readBytes32(toRLPItem(_in));

    }



    /**

     * Reads an RLP uint256 value into a uint256.

     * @param _in RLP uint256 value.

     * @return Decoded uint256.

     */

    function readUint256(RLPItem memory _in) internal pure returns (uint256) {

        return uint256(readBytes32(_in));

    }



    /**

     * Reads an RLP uint256 value into a uint256.

     * @param _in RLP uint256 value.

     * @return Decoded uint256.

     */

    function readUint256(bytes memory _in) internal pure returns (uint256) {

        return readUint256(toRLPItem(_in));

    }



    /**

     * Reads an RLP bool value into a bool.

     * @param _in RLP bool value.

     * @return Decoded bool.

     */

    function readBool(RLPItem memory _in) internal pure returns (bool) {

        require(_in.length == 1, "Invalid RLP boolean value.");



        uint256 ptr = _in.ptr;

        uint256 out;

        assembly {

            out := byte(0, mload(ptr))

        }



        require(out == 0 || out == 1, "Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1");



        return out != 0;

    }



    /**

     * Reads an RLP bool value into a bool.

     * @param _in RLP bool value.

     * @return Decoded bool.

     */

    function readBool(bytes memory _in) internal pure returns (bool) {

        return readBool(toRLPItem(_in));

    }



    /**

     * Reads an RLP address value into a address.

     * @param _in RLP address value.

     * @return Decoded address.

     */

    function readAddress(RLPItem memory _in) internal pure returns (address) {

        if (_in.length == 1) {

            return address(0);

        }



        require(_in.length == 21, "Invalid RLP address value.");



        return address(uint160(readUint256(_in)));

    }



    /**

     * Reads an RLP address value into a address.

     * @param _in RLP address value.

     * @return Decoded address.

     */

    function readAddress(bytes memory _in) internal pure returns (address) {

        return readAddress(toRLPItem(_in));

    }



    /**

     * Reads the raw bytes of an RLP item.

     * @param _in RLP item to read.

     * @return Raw RLP bytes.

     */

    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {

        return _copy(_in);

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Decodes the length of an RLP item.

     * @param _in RLP item to decode.

     * @return Offset of the encoded data.

     * @return Length of the encoded data.

     * @return RLP item type (LIST_ITEM or DATA_ITEM).

     */

    function _decodeLength(RLPItem memory _in)

        private

        pure

        returns (

            uint256,

            uint256,

            RLPItemType

        )

    {

        require(_in.length > 0, "RLP item cannot be null.");



        uint256 ptr = _in.ptr;

        uint256 prefix;

        assembly {

            prefix := byte(0, mload(ptr))

        }



        if (prefix <= 0x7f) {

            // Single byte.



            return (0, 1, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xb7) {

            // Short string.



            uint256 strLen = prefix - 0x80;



            require(_in.length > strLen, "Invalid RLP short string.");



            return (1, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xbf) {

            // Long string.

            uint256 lenOfStrLen = prefix - 0xb7;



            require(_in.length > lenOfStrLen, "Invalid RLP long string length.");



            uint256 strLen;

            assembly {

                // Pick out the string length.

                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))

            }



            require(_in.length > lenOfStrLen + strLen, "Invalid RLP long string.");



            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xf7) {

            // Short list.

            uint256 listLen = prefix - 0xc0;



            require(_in.length > listLen, "Invalid RLP short list.");



            return (1, listLen, RLPItemType.LIST_ITEM);

        } else {

            // Long list.

            uint256 lenOfListLen = prefix - 0xf7;



            require(_in.length > lenOfListLen, "Invalid RLP long list length.");



            uint256 listLen;

            assembly {

                // Pick out the list length.

                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))

            }



            require(_in.length > lenOfListLen + listLen, "Invalid RLP long list.");



            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);

        }

    }



    /**

     * Copies the bytes from a memory location.

     * @param _src Pointer to the location to read from.

     * @param _offset Offset to start reading from.

     * @param _length Number of bytes to read.

     * @return Copied bytes.

     */

    function _copy(

        uint256 _src,

        uint256 _offset,

        uint256 _length

    ) private pure returns (bytes memory) {

        bytes memory out = new bytes(_length);

        if (out.length == 0) {

            return out;

        }



        uint256 src = _src + _offset;

        uint256 dest;

        assembly {

            dest := add(out, 32)

        }



        // Copy over as many complete words as we can.

        for (uint256 i = 0; i < _length / 32; i++) {

            assembly {

                mstore(dest, mload(src))

            }



            src += 32;

            dest += 32;

        }



        // Pick out the remaining bytes.

        uint256 mask;

        unchecked {

            mask = 256**(32 - (_length % 32)) - 1;

        }



        assembly {

            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))

        }

        return out;

    }



    /**

     * Copies an RLP item into bytes.

     * @param _in RLP item to copy.

     * @return Copied bytes.

     */

    function _copy(RLPItem memory _in) private pure returns (bytes memory) {

        return _copy(_in.ptr, 0, _in.length);

    }

}





// File contracts/libraries/rlp/Lib_RLPWriter.sol



// : MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_RLPWriter

 * @author Bakaoh (with modifications)

 */

library Lib_RLPWriter {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * RLP encodes a byte string.

     * @param _in The byte string to encode.

     * @return The RLP encoded string in bytes.

     */

    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {

        bytes memory encoded;



        if (_in.length == 1 && uint8(_in[0]) < 128) {

            encoded = _in;

        } else {

            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);

        }



        return encoded;

    }



    /**

     * RLP encodes a list of RLP encoded byte byte strings.

     * @param _in The list of RLP encoded byte strings.

     * @return The RLP encoded list of items in bytes.

     */

    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {

        bytes memory list = _flatten(_in);

        return abi.encodePacked(_writeLength(list.length, 192), list);

    }



    /**

     * RLP encodes a string.

     * @param _in The string to encode.

     * @return The RLP encoded string in bytes.

     */

    function writeString(string memory _in) internal pure returns (bytes memory) {

        return writeBytes(bytes(_in));

    }



    /**

     * RLP encodes an address.

     * @param _in The address to encode.

     * @return The RLP encoded address in bytes.

     */

    function writeAddress(address _in) internal pure returns (bytes memory) {

        return writeBytes(abi.encodePacked(_in));

    }



    /**

     * RLP encodes a uint.

     * @param _in The uint256 to encode.

     * @return The RLP encoded uint256 in bytes.

     */

    function writeUint(uint256 _in) internal pure returns (bytes memory) {

        return writeBytes(_toBinary(_in));

    }



    /**

     * RLP encodes a bool.

     * @param _in The bool to encode.

     * @return The RLP encoded bool in bytes.

     */

    function writeBool(bool _in) internal pure returns (bytes memory) {

        bytes memory encoded = new bytes(1);

        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));

        return encoded;

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.

     * @param _len The length of the string or the payload.

     * @param _offset 128 if item is string, 192 if item is list.

     * @return RLP encoded bytes.

     */

    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {

        bytes memory encoded;



        if (_len < 56) {

            encoded = new bytes(1);

            encoded[0] = bytes1(uint8(_len) + uint8(_offset));

        } else {

            uint256 lenLen;

            uint256 i = 1;

            while (_len / i != 0) {

                lenLen++;

                i *= 256;

            }



            encoded = new bytes(lenLen + 1);

            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);

            for (i = 1; i <= lenLen; i++) {

                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));

            }

        }



        return encoded;

    }



    /**

     * Encode integer in big endian binary form with no leading zeroes.

     * @notice TODO: This should be optimized with assembly to save gas costs.

     * @param _x The integer to encode.

     * @return RLP encoded bytes.

     */

    function _toBinary(uint256 _x) private pure returns (bytes memory) {

        bytes memory b = abi.encodePacked(_x);



        uint256 i = 0;

        for (; i < 32; i++) {

            if (b[i] != 0) {

                break;

            }

        }



        bytes memory res = new bytes(32 - i);

        for (uint256 j = 0; j < res.length; j++) {

            res[j] = b[i++];

        }



        return res;

    }



    /**

     * Copies a piece of memory to another location.

     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.

     * @param _dest Destination location.

     * @param _src Source location.

     * @param _len Length of memory to copy.

     */

    function _memcpy(

        uint256 _dest,

        uint256 _src,

        uint256 _len

    ) private pure {

        uint256 dest = _dest;

        uint256 src = _src;

        uint256 len = _len;



        for (; len >= 32; len -= 32) {

            assembly {

                mstore(dest, mload(src))

            }

            dest += 32;

            src += 32;

        }



        uint256 mask;

        unchecked {

            mask = 256**(32 - len) - 1;

        }

        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }

    }



    /**

     * Flattens a list of byte strings into one byte string.

     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.

     * @param _list List of byte strings to flatten.

     * @return The flattened byte string.

     */

    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {

        if (_list.length == 0) {

            return new bytes(0);

        }



        uint256 len;

        uint256 i = 0;

        for (; i < _list.length; i++) {

            len += _list[i].length;

        }



        bytes memory flattened = new bytes(len);

        uint256 flattenedPtr;

        assembly {

            flattenedPtr := add(flattened, 0x20)

        }



        for (i = 0; i < _list.length; i++) {

            bytes memory item = _list[i];



            uint256 listPtr;

            assembly {

                listPtr := add(item, 0x20)

            }



            _memcpy(flattenedPtr, listPtr, item.length);

            flattenedPtr += _list[i].length;

        }



        return flattened;

    }

}





// File contracts/libraries/utils/Lib_BytesUtils.sol



// : MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_BytesUtils

 */

library Lib_BytesUtils {

    /**********************

     * Internal Functions *

     **********************/



    function slice(

        bytes memory _bytes,

        uint256 _start,

        uint256 _length

    ) internal pure returns (bytes memory) {

        require(_length + 31 >= _length, "slice_overflow");

        require(_start + _length >= _start, "slice_overflow");

        require(_bytes.length >= _start + _length, "slice_outOfBounds");



        bytes memory tempBytes;



        assembly {

            switch iszero(_length)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                let lengthmod := and(_length, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, _length)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, _length)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                //zero out the 32 bytes slice we are about to return

                //we need to do it because Solidity does not garbage collect

                mstore(tempBytes, 0)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {

        if (_start >= _bytes.length) {

            return bytes("");

        }



        return slice(_bytes, _start, _bytes.length - _start);

    }



    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {

        if (_bytes.length < 32) {

            bytes32 ret;

            assembly {

                ret := mload(add(_bytes, 32))

            }

            return ret;

        }



        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes

    }



    function toUint256(bytes memory _bytes) internal pure returns (uint256) {

        return uint256(toBytes32(_bytes));

    }



    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {

        bytes memory nibbles = new bytes(_bytes.length * 2);



        for (uint256 i = 0; i < _bytes.length; i++) {

            nibbles[i * 2] = _bytes[i] >> 4;

            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);

        }



        return nibbles;

    }



    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {

        bytes memory ret = new bytes(_bytes.length / 2);



        for (uint256 i = 0; i < ret.length; i++) {

            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);

        }



        return ret;

    }



    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {

        return keccak256(_bytes) == keccak256(_other);

    }

}





// File contracts/libraries/utils/Lib_Bytes32Utils.sol



// : MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_Byte32Utils

 */

library Lib_Bytes32Utils {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to "true."

     * @param _in Input bytes32 value.

     * @return Bytes32 as a boolean.

     */

    function toBool(bytes32 _in) internal pure returns (bool) {

        return _in != 0;

    }



    /**

     * Converts a boolean to a bytes32 value.

     * @param _in Input boolean value.

     * @return Boolean as a bytes32.

     */

    function fromBool(bool _in) internal pure returns (bytes32) {

        return bytes32(uint256(_in ? 1 : 0));

    }



    /**

     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.

     * @param _in Input bytes32 value.

     * @return Bytes32 as an address.

     */

    function toAddress(bytes32 _in) internal pure returns (address) {

        return address(uint160(uint256(_in)));

    }



    /**

     * Converts an address to a bytes32.

     * @param _in Input address value.

     * @return Address as a bytes32.

     */

    function fromAddress(address _in) internal pure returns (bytes32) {

        return bytes32(uint256(uint160(_in)));

    }

}





// File contracts/libraries/codec/Lib_OVMCodec.sol



// : MIT

pragma solidity ^0.8.9;



/* Library Imports */









/**

 * @title Lib_OVMCodec

 */

library Lib_OVMCodec {

    /*********

     * Enums *

     *********/



    enum QueueOrigin {

        SEQUENCER_QUEUE,

        L1TOL2_QUEUE

    }



    /***********

     * Structs *

     ***********/



    struct EVMAccount {

        uint256 nonce;

        uint256 balance;

        bytes32 storageRoot;

        bytes32 codeHash;

    }



    struct ChainBatchHeader {

        uint256 batchIndex;

        bytes32 batchRoot;

        uint256 batchSize;

        uint256 prevTotalElements;

        bytes extraData;

    }



    struct ChainInclusionProof {

        uint256 index;

        bytes32[] siblings;

    }



    struct Transaction {

        uint256 timestamp;

        uint256 blockNumber;

        QueueOrigin l1QueueOrigin;

        address l1TxOrigin;

        address entrypoint;

        uint256 gasLimit;

        bytes data;

    }



    struct TransactionChainElement {

        bool isSequenced;

        uint256 queueIndex; // QUEUED TX ONLY

        uint256 timestamp; // SEQUENCER TX ONLY

        uint256 blockNumber; // SEQUENCER TX ONLY

        bytes txData; // SEQUENCER TX ONLY

    }



    struct QueueElement {

        bytes32 transactionHash;

        uint40 timestamp;

        uint40 blockNumber;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Encodes a standard OVM transaction.

     * @param _transaction OVM transaction to encode.

     * @return Encoded transaction bytes.

     */

    function encodeTransaction(Transaction memory _transaction)

        internal

        pure

        returns (bytes memory)

    {

        return

            abi.encodePacked(

                _transaction.timestamp,

                _transaction.blockNumber,

                _transaction.l1QueueOrigin,

                _transaction.l1TxOrigin,

                _transaction.entrypoint,

                _transaction.gasLimit,

                _transaction.data

            );

    }



    /**

     * Hashes a standard OVM transaction.

     * @param _transaction OVM transaction to encode.

     * @return Hashed transaction

     */

    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {

        return keccak256(encodeTransaction(_transaction));

    }



    /**

     * @notice Decodes an RLP-encoded account state into a useful struct.

     * @param _encoded RLP-encoded account state.

     * @return Account state struct.

     */

    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {

        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);



        return

            EVMAccount({

                nonce: Lib_RLPReader.readUint256(accountState[0]),

                balance: Lib_RLPReader.readUint256(accountState[1]),

                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),

                codeHash: Lib_RLPReader.readBytes32(accountState[3])

            });

    }



    /**

     * Calculates a hash for a given batch header.

     * @param _batchHeader Header to hash.

     * @return Hash of the header.

     */

    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)

        internal

        pure

        returns (bytes32)

    {

        return

            keccak256(

                abi.encode(

                    _batchHeader.batchRoot,

                    _batchHeader.batchSize,

                    _batchHeader.prevTotalElements,

                    _batchHeader.extraData

                )

            );

    }

}





// File contracts/L1/rollup/IChainStorageContainer.sol



// : MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title IChainStorageContainer

 */

interface IChainStorageContainer {

    /********************

     * Public Functions *

     ********************/



    /**

     * Sets the container's global metadata field. We're using `bytes27` here because we use five

     * bytes to maintain the length of the underlying data structure, meaning we have an extra

     * 27 bytes to store arbitrary data.

     * @param _globalMetadata New global metadata to set.

     */

    function setGlobalMetadata(bytes27 _globalMetadata) external;



    /**

     * Retrieves the container's global metadata field.

     * @return Container global metadata field.

     */

    function getGlobalMetadata() external view returns (bytes27);



    /**

     * Retrieves the number of objects stored in the container.

     * @return Number of objects in the container.

     */

    function length() external view returns (uint256);



    /**

     * Pushes an object into the container.

     * @param _object A 32 byte value to insert into the container.

     */

    function push(bytes32 _object) external;



    /**

     * Pushes an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _object A 32 byte value to insert into the container.

     * @param _globalMetadata New global metadata for the container.

     */

    function push(bytes32 _object, bytes27 _globalMetadata) external;



    /**

     * Set an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _index position.

     * @param _object A 32 byte value to insert into the container.

     */  

    function setByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes32 _object

    )

        external;

        

    /**

     * Retrieves an object from the container.

     * @param _index Index of the particular object to access.

     * @return 32 byte object value.

     */

    function get(uint256 _index) external view returns (bytes32);



    /**

     * Removes all objects after and including a given index.

     * @param _index Object index to delete from.

     */

    function deleteElementsAfterInclusive(uint256 _index) external;



    /**

     * Removes all objects after and including a given index. Also allows setting the global

     * metadata field.

     * @param _index Object index to delete from.

     * @param _globalMetadata New global metadata for the container.

     */

    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;



    /**

     * Sets the container's global metadata field. We're using `bytes27` here because we use five

     * bytes to maintain the length of the underlying data structure, meaning we have an extra

     * 27 bytes to store arbitrary data.

     * @param _chainId identity for the l2 chain.

     * @param _globalMetadata New global metadata to set.

     */

    function setGlobalMetadataByChainId(

        uint256 _chainId,

        bytes27 _globalMetadata

    )

        external;



    /**

     * Retrieves the container's global metadata field.

     * @param _chainId identity for the l2 chain.

     * @return Container global metadata field.

     */

    function getGlobalMetadataByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            bytes27

        );



    /**

     * Retrieves the number of objects stored in the container.

     * @param _chainId identity for the l2 chain.

     * @return Number of objects in the container.

     */

    function lengthByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint256

        );



    /**

     * Pushes an object into the container.

     * @param _chainId identity for the l2 chain.

     * @param _object A 32 byte value to insert into the container.

     */

    function pushByChainId(

        uint256 _chainId,

        bytes32 _object

    )

        external;



    /**

     * Pushes an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _chainId identity for the l2 chain.

     * @param _object A 32 byte value to insert into the container.

     * @param _globalMetadata New global metadata for the container.

     */

    function pushByChainId(

        uint256 _chainId,

        bytes32 _object,

        bytes27 _globalMetadata

    )

        external;



    /**

     * Retrieves an object from the container.

     * @param _chainId identity for the l2 chain.

     * @param _index Index of the particular object to access.

     * @return 32 byte object value.

     */

    function getByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external

        view

        returns (

            bytes32

        );



    /**

     * Removes all objects after and including a given index.

     * @param _chainId identity for the l2 chain.

     * @param _index Object index to delete from.

     */

    function deleteElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external;

        

    /**

     * Removes all objects after and including a given index. Also allows setting the global

     * metadata field.

     * @param _chainId identity for the l2 chain.

     * @param _index Object index to delete from.

     * @param _globalMetadata New global metadata for the container.

     */

    function deleteElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    )

        external;

        

}





// File contracts/L1/rollup/ICanonicalTransactionChain.sol



// : MIT

pragma solidity >0.5.0 <0.9.0;



/* Library Imports */



/* Interface Imports */



/**

 * @title ICanonicalTransactionChain

 */

interface ICanonicalTransactionChain {

    /**********

     * Events *

     **********/

    event QueueGlobalMetadataSet(

        address _sender,

        uint256 _chainId,

        bytes27 _globalMetadata

    );

    

    event QueuePushed(

        address _sender,

        uint256 _chainId,

        Lib_OVMCodec.QueueElement _object

    );



    event QueueSetted(

        address _sender,

        uint256 _chainId,

        uint256 _index,

        Lib_OVMCodec.QueueElement _object

    );



    event QueueElementDeleted(

        address _sender,

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    );



    event BatchesGlobalMetadataSet(

        address _sender,

        uint256 _chainId,

        bytes27 _globalMetadata

    );

    

    event BatchPushed(

        address _sender,

        uint256 _chainId,

        bytes32 _object,

        bytes27 _globalMetadata

    );



    event BatchSetted(

        address _sender,

        uint256 _chainId,

        uint256 _index,

        bytes32 _object

    );



    event BatchElementDeleted(

        address _sender,

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    );



    event L2GasParamsUpdated(

        uint256 l2GasDiscountDivisor,

        uint256 enqueueGasCost,

        uint256 enqueueL2GasPrepaid

    );



    event TransactionEnqueued(

        uint256 _chainId,

        address indexed _l1TxOrigin,

        address indexed _target,

        uint256 _gasLimit,

        bytes _data,

        uint256 indexed _queueIndex,

        uint256 _timestamp

    );



    event QueueBatchAppended(

        uint256 _chainId,

        uint256 _startingQueueIndex,

        uint256 _numQueueElements,

        uint256 _totalElements

    );



    event SequencerBatchAppended(

        uint256 _chainId,

        uint256 _startingQueueIndex,

        uint256 _numQueueElements,

        uint256 _totalElements

    );



    event TransactionBatchAppended(

        uint256 _chainId,

        uint256 indexed _batchIndex,

        bytes32 _batchRoot,

        uint256 _batchSize,

        uint256 _prevTotalElements,

        bytes _extraData

    );



    /***********

     * Structs *

     ***********/



    struct BatchContext {

        uint256 numSequencedTransactions;

        uint256 numSubsequentQueueTransactions;

        uint256 timestamp;

        uint256 blockNumber;

    }



    /*******************************

     * Authorized Setter Functions *

     *******************************/



    /**

     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.

     * The value of enqueueL2GasPrepaid is immediately updated as well.

     */

    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost) external;



    /********************

     * Public Functions *

     ********************/



    /**

     * Accesses the batch storage container.

     * @return Reference to the batch storage container.

     */

    function batches() external view returns (IChainStorageContainer);



    /**

     * Accesses the queue storage container.

     * @return Reference to the queue storage container.

     */

    function queue() external view returns (IChainStorageContainer);



    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements() external view returns (uint256 _totalElements);



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches() external view returns (uint256 _totalBatches);



    /**

     * Returns the index of the next element to be enqueued.

     * @return Index for the next queue element.

     */

    function getNextQueueIndex() external view returns (uint40);



    /**

     * Gets the queue element at a particular index.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElement(uint256 _index)

        external

        view

        returns (Lib_OVMCodec.QueueElement memory _element);



    /**

     * Returns the timestamp of the last transaction.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestamp() external view returns (uint40);



    /**

     * Returns the blocknumber of the last transaction.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumber() external view returns (uint40);



    /**

     * Get the number of queue elements which have not yet been included.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElements() external view returns (uint40);



    /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @return Length of the queue.

     */

    function getQueueLength() external view returns (uint40);



    /**

     * Adds a transaction to the queue.

     * @param _target Target contract to send the transaction to.

     * @param _gasLimit Gas limit for the given transaction.

     * @param _data Transaction data.

     */

    function enqueue(

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    ) external;



    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatch(

        // uint40 _shouldStartAtElement,

        // uint24 _totalElementsToAppend,

        // BatchContext[] _contexts,

        // bytes[] _transactionDataFields

    )

        external;

        

    //added chain id function

    

    /**

     * Retrieves the total number of elements submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElementsByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint256 _totalElements

        );



    /**

     * Retrieves the total number of batches submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatchesByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint256 _totalBatches

        );



    /**

     * Returns the index of the next element to be enqueued.

     * @param _chainId identity for the l2 chain.

     * @return Index for the next queue element.

     */

    function getNextQueueIndexByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );



    /**

     * Gets the queue element at a particular index.

     * @param _chainId identity for the l2 chain.

     * @param _index Index of the queue element to access.

     * @return _element Queue element at the given index.

     */

    function getQueueElementByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external

        view

        returns (

            Lib_OVMCodec.QueueElement memory _element

        );



    /**

     * Returns the timestamp of the last transaction.

     * @param _chainId identity for the l2 chain.

     * @return Timestamp for the last transaction.

     */

    function getLastTimestampByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );



    /**

     * Returns the blocknumber of the last transaction.

     * @param _chainId identity for the l2 chain.

     * @return Blocknumber for the last transaction.

     */

    function getLastBlockNumberByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );



    /**

     * Get the number of queue elements which have not yet been included.

     * @param _chainId identity for the l2 chain.

     * @return Number of pending queue elements.

     */

    function getNumPendingQueueElementsByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );



    /**

     * Retrieves the length of the queue, including

     * both pending and canonical transactions.

     * @param _chainId identity for the l2 chain.

     * @return Length of the queue.

     */

    function getQueueLengthByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint40

        );





    /**

     * Adds a transaction to the queue.

     * @param _chainId identity for the l2 chain.

     * @param _target Target contract to send the transaction to.

     * @param _gasLimit Gas limit for the given transaction.

     * @param _data Transaction data.

     */

    function enqueueByChainId(

        uint256 _chainId,

        address _target,

        uint256 _gasLimit,

        bytes memory _data

    )

        external;

        

    /**

     * Allows the sequencer to append a batch of transactions.

     * @dev This function uses a custom encoding scheme for efficiency reasons.

     * .param _chainId identity for the l2 chain.

     * .param _shouldStartAtElement Specific batch we expect to start appending to.

     * .param _totalElementsToAppend Total number of batch elements we expect to append.

     * .param _contexts Array of batch contexts.

     * .param _transactionDataFields Array of raw transaction data.

     */

    function appendSequencerBatchByChainId(

        // uint256 _chainId,

        // uint40 _shouldStartAtElement,

        // uint24 _totalElementsToAppend,

        // BatchContext[] _contexts,

        // bytes[] _transactionDataFields

    )

        external;

    

    function pushQueueByChainId(

        uint256 _chainId,

        Lib_OVMCodec.QueueElement calldata _object

    )

        external;



    function setQueueByChainId(

        uint256 _chainId,

        uint256 _index,

        Lib_OVMCodec.QueueElement calldata _object

    )

        external;



    function setBatchGlobalMetadataByChainId(

        uint256 _chainId,

        bytes27 _globalMetadata

    )

        external;

    

    function getBatchGlobalMetadataByChainId(uint256 _chainId)

        external

        view

        returns (

            bytes27

        );

        

    function lengthBatchByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256

        );

        

    function pushBatchByChainId(

        uint256 _chainId,

        bytes32 _object,

        bytes27 _globalMetadata

    )

        external;

    

    function setBatchByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes32 _object

    )

        external;

        

    function getBatchByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external

        view

        returns (

            bytes32

        );

        

    function deleteBatchElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    )

        external;

}





// File contracts/libraries/utils/Lib_MerkleTree.sol



// : MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_MerkleTree

 * @author River Keefer

 */

library Lib_MerkleTree {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number

     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.

     * If you do not know the original length of elements for the tree you are verifying, then

     * this may allow empty leaves past _elements.length to pass a verification check down the line.

     * Note that the _elements argument is modified, therefore it must not be used again afterwards

     * @param _elements Array of hashes from which to generate a merkle root.

     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).

     */

    function getMerkleRoot(bytes32[] memory _elements) internal pure returns (bytes32) {

        require(_elements.length > 0, "Lib_MerkleTree: Must provide at least one leaf hash.");



        if (_elements.length == 1) {

            return _elements[0];

        }



        uint256[16] memory defaults = [

            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,

            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,

            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,

            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,

            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,

            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,

            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,

            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,

            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,

            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,

            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,

            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,

            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,

            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,

            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,

            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10

        ];



        // Reserve memory space for our hashes.

        bytes memory buf = new bytes(64);



        // We'll need to keep track of left and right siblings.

        bytes32 leftSibling;

        bytes32 rightSibling;



        // Number of non-empty nodes at the current depth.

        uint256 rowSize = _elements.length;



        // Current depth, counting from 0 at the leaves

        uint256 depth = 0;



        // Common sub-expressions

        uint256 halfRowSize; // rowSize / 2

        bool rowSizeIsOdd; // rowSize % 2 == 1



        while (rowSize > 1) {

            halfRowSize = rowSize / 2;

            rowSizeIsOdd = rowSize % 2 == 1;



            for (uint256 i = 0; i < halfRowSize; i++) {

                leftSibling = _elements[(2 * i)];

                rightSibling = _elements[(2 * i) + 1];

                assembly {

                    mstore(add(buf, 32), leftSibling)

                    mstore(add(buf, 64), rightSibling)

                }



                _elements[i] = keccak256(buf);

            }



            if (rowSizeIsOdd) {

                leftSibling = _elements[rowSize - 1];

                rightSibling = bytes32(defaults[depth]);

                assembly {

                    mstore(add(buf, 32), leftSibling)

                    mstore(add(buf, 64), rightSibling)

                }



                _elements[halfRowSize] = keccak256(buf);

            }



            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);

            depth++;

        }



        return _elements[0];

    }



    /**

     * Verifies a merkle branch for the given leaf hash.  Assumes the original length

     * of leaves generated is a known, correct input, and does not return true for indices

     * extending past that index (even if _siblings would be otherwise valid.)

     * @param _root The Merkle root to verify against.

     * @param _leaf The leaf hash to verify inclusion of.

     * @param _index The index in the tree of this leaf.

     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0

     * (bottom of the tree).

     * @param _totalLeaves The total number of leaves originally passed into.

     * @return Whether or not the merkle branch and leaf passes verification.

     */

    function verify(

        bytes32 _root,

        bytes32 _leaf,

        uint256 _index,

        bytes32[] memory _siblings,

        uint256 _totalLeaves

    ) internal pure returns (bool) {

        require(_totalLeaves > 0, "Lib_MerkleTree: Total leaves must be greater than zero.");



        require(_index < _totalLeaves, "Lib_MerkleTree: Index out of bounds.");



        require(

            _siblings.length == _ceilLog2(_totalLeaves),

            "Lib_MerkleTree: Total siblings does not correctly correspond to total leaves."

        );



        bytes32 computedRoot = _leaf;



        for (uint256 i = 0; i < _siblings.length; i++) {

            if ((_index & 1) == 1) {

                computedRoot = keccak256(abi.encodePacked(_siblings[i], computedRoot));

            } else {

                computedRoot = keccak256(abi.encodePacked(computedRoot, _siblings[i]));

            }



            _index >>= 1;

        }



        return _root == computedRoot;

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Calculates the integer ceiling of the log base 2 of an input.

     * @param _in Unsigned input to calculate the log.

     * @return ceil(log_base_2(_in))

     */

    function _ceilLog2(uint256 _in) private pure returns (uint256) {

        require(_in > 0, "Lib_MerkleTree: Cannot compute ceil(log_2) of 0.");



        if (_in == 1) {

            return 0;

        }



        // Find the highest set bit (will be floor(log_2)).

        // Borrowed with <3 from https://github.com/ethereum/solidity-examples

        uint256 val = _in;

        uint256 highest = 0;

        for (uint256 i = 128; i >= 1; i >>= 1) {

            if (val & (((uint256(1) << i) - 1) << i) != 0) {

                highest += i;

                val >>= i;

            }

        }



        // Increment by one if this is not a perfect logarithm.

        if ((uint256(1) << highest) != _in) {

            highest += 1;

        }



        return highest;

    }

}





// File contracts/L1/rollup/IStateCommitmentChain.sol



// : MIT

pragma solidity >0.5.0 <0.9.0;



/* Library Imports */





/**

 * @title IStateCommitmentChain

 */

interface IStateCommitmentChain {

    /**********

     * Events *

     **********/



    event StateBatchAppended(

        uint256 _chainId,

        uint256 indexed _batchIndex,

        bytes32 _batchRoot,

        uint256 _batchSize,

        uint256 _prevTotalElements,

        bytes _extraData

    );



    event StateBatchDeleted(

        uint256 _chainId,

        uint256 indexed _batchIndex,

        bytes32 _batchRoot

    );





    /********************

     * Public Functions *

     ********************/

    

    function batches() external view returns (IChainStorageContainer);

    

    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements() external view returns (uint256 _totalElements);



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches() external view returns (uint256 _totalBatches);



    /**

     * Retrieves the timestamp of the last batch submitted by the sequencer.

     * @return _lastSequencerTimestamp Last sequencer batch timestamp.

     */

    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);



    /**

     * Appends a batch of state roots to the chain.

     * @param _batch Batch of state roots.

     * @param _shouldStartAtElement Index of the element at which this batch should start.

     */

    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;



    /**

     * Deletes all state roots after (and including) a given batch.

     * @param _batchHeader Header of the batch to start deleting from.

     */

    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) external;



    /**

     * Verifies a batch inclusion proof.

     * @param _element Hash of the element to verify a proof for.

     * @param _batchHeader Header of the batch in which the element was included.

     * @param _proof Merkle inclusion proof for the element.

     */

    function verifyStateCommitment(

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    ) external view returns (bool _verified);



    /**

     * Checks whether a given batch is still inside its fraud proof window.

     * @param _batchHeader Header of the batch to check.

     * @return _inside Whether or not the batch is inside the fraud proof window.

     */

    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)

        external

        view

        returns (

            bool _inside

        );

        

        

        

     /********************

     * chain id added func *

     ********************/



    /**

     * Retrieves the total number of elements submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElementsByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256 _totalElements

        );



    /**

     * Retrieves the total number of batches submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatchesByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256 _totalBatches

        );



    /**

     * Retrieves the timestamp of the last batch submitted by the sequencer.

     * @param _chainId identity for the l2 chain.

     * @return _lastSequencerTimestamp Last sequencer batch timestamp.

     */

    function getLastSequencerTimestampByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256 _lastSequencerTimestamp

        );

        

    /**

     * Appends a batch of state roots to the chain.

     * @param _chainId identity for the l2 chain.

     * @param _batch Batch of state roots.

     * @param _shouldStartAtElement Index of the element at which this batch should start.

     */

    function appendStateBatchByChainId(

        uint256 _chainId,

        bytes32[] calldata _batch,

        uint256 _shouldStartAtElement,

        string calldata proposer

    )

        external;



    /**

     * Deletes all state roots after (and including) a given batch.

     * @param _chainId identity for the l2 chain.

     * @param _batchHeader Header of the batch to start deleting from.

     */

    function deleteStateBatchByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        external;



    /**

     * Verifies a batch inclusion proof.

     * @param _chainId identity for the l2 chain.

     * @param _element Hash of the element to verify a proof for.

     * @param _batchHeader Header of the batch in which the element was included.

     * @param _proof Merkle inclusion proof for the element.

     */

    function verifyStateCommitmentByChainId(

        uint256 _chainId,

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    )

        external

        view

        returns (

            bool _verified

        );



    /**

     * Checks whether a given batch is still inside its fraud proof window.

     * @param _chainId identity for the l2 chain.

     * @param _batchHeader Header of the batch to check.

     * @return _inside Whether or not the batch is inside the fraud proof window.

     */

    function insideFraudProofWindowByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        external

        view

        returns (

            bool _inside

        );

}





// File contracts/L1/verification/IBondManager.sol



// : MIT

pragma solidity ^0.8.9;



/**

 * @title IBondManager

 */

interface IBondManager {

    /********************

     * Public Functions *

     ********************/



    function isCollateralized(address _who) external view returns (bool);

    function isCollateralizedByChainId(

        uint256 _chainId,

        address _who,

        address _prop

    ) external view returns (bool);

}





// File contracts/L1/rollup/StateCommitmentChain.sol



// : MIT

pragma solidity ^0.8.9;



/* Library Imports */







/* Interface Imports */









/**

 * @title StateCommitmentChain

 * @dev The State Commitment Chain (SCC) contract contains a list of proposed state roots which

 * Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC).

 * Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique

 * state root calculated off-chain by applying the canonical transactions one by one.

 *

 * Runtime target: EVM

 */

contract StateCommitmentChain is IStateCommitmentChain, Lib_AddressResolver {



    /*************

     * Constants *

     *************/



    uint256 public FRAUD_PROOF_WINDOW;

    uint256 public SEQUENCER_PUBLISH_WINDOW;

    

    

    uint256 public DEFAULT_CHAINID = 1088;





    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Address Manager.

     */

    constructor(

        address _libAddressManager,

        uint256 _fraudProofWindow,

        uint256 _sequencerPublishWindow

    )

        Lib_AddressResolver(_libAddressManager)

    {

        FRAUD_PROOF_WINDOW = _fraudProofWindow;

        SEQUENCER_PUBLISH_WINDOW = _sequencerPublishWindow;

    }

    

    function setFraudProofWindow (uint256 window) public {

        require (msg.sender == resolve("METIS_MANAGER"), "now allowed");

        FRAUD_PROOF_WINDOW = window;

    }



    /********************

     * Public Functions *

     ********************/



    /**

     * Accesses the batch storage container.

     * @return Reference to the batch storage container.

     */

    function batches() public view returns (IChainStorageContainer) {

        return IChainStorageContainer(resolve("ChainStorageContainer-SCC-batches"));

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function getTotalElements() public view returns (uint256 _totalElements) {

        return getTotalElementsByChainId(DEFAULT_CHAINID);

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function getTotalBatches() public view returns (uint256 _totalBatches) {

        return getTotalBatchesByChainId(DEFAULT_CHAINID);

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function getLastSequencerTimestamp() public view returns (uint256 _lastSequencerTimestamp) {

        return getLastSequencerTimestampByChainId(DEFAULT_CHAINID);

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function appendStateBatch(bytes32[] memory _batch, uint256 _shouldStartAtElement) public {

        require (1==0, "don't use");

        //appendStateBatchByChainId(DEFAULT_CHAINID, _batch, _shouldStartAtElement, "1088_MVM_Proposer");

    }

    

    /**

     * @inheritdoc IStateCommitmentChain

     */

    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) public {

        deleteStateBatchByChainId(DEFAULT_CHAINID, _batchHeader);

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function verifyStateCommitment(

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    ) public view returns (bool) {

        return verifyStateCommitmentByChainId(DEFAULT_CHAINID, _element, _batchHeader, _proof);

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)

        public

        view

        returns (bool _inside)

    {

        (uint256 timestamp, ) = abi.decode(_batchHeader.extraData, (uint256, address));



        require(timestamp != 0, "Batch header timestamp cannot be zero");

        return (timestamp + FRAUD_PROOF_WINDOW) > block.timestamp;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Parses the batch context from the extra data.

     * @return Total number of elements submitted.

     * @return Timestamp of the last batch submitted by the sequencer.

     */

    function _getBatchExtraData() internal view returns (uint40, uint40) {

        bytes27 extraData = batches().getGlobalMetadata();



        // solhint-disable max-line-length

        uint40 totalElements;

        uint40 lastSequencerTimestamp;

        assembly {

            extraData := shr(40, extraData)

            totalElements := and(

                extraData,

                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF

            )

            lastSequencerTimestamp := shr(

                40,

                and(extraData, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000)

            )

        }

        // solhint-enable max-line-length



        return (totalElements, lastSequencerTimestamp);

    }



    /**

     * Encodes the batch context for the extra data.

     * @param _totalElements Total number of elements submitted.

     * @param _lastSequencerTimestamp Timestamp of the last batch submitted by the sequencer.

     * @return Encoded batch context.

     */

    function _makeBatchExtraData(uint40 _totalElements, uint40 _lastSequencerTimestamp)

        internal

        pure

        returns (bytes27)

    {

        bytes27 extraData;

        assembly {

            extraData := _totalElements

            extraData := or(extraData, shl(40, _lastSequencerTimestamp))

            extraData := shl(40, extraData)

        }



        return extraData;

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function getTotalElementsByChainId(

        uint256 _chainId

        )

        override

        public

        view

        returns (

            uint256 _totalElements

        )

    {

        (uint40 totalElements, ) = _getBatchExtraDataByChainId(_chainId);

        return uint256(totalElements);

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function getTotalBatchesByChainId(

        uint256 _chainId

        )

        override

        public

        view

        returns (

            uint256 _totalBatches

        )

    {

        return batches().lengthByChainId(_chainId);

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function getLastSequencerTimestampByChainId(

        uint256 _chainId

        )

        override

        public

        view

        returns (

            uint256 _lastSequencerTimestamp

        )

    {

        (, uint40 lastSequencerTimestamp) = _getBatchExtraDataByChainId(_chainId);

        return uint256(lastSequencerTimestamp);

    }

    

    /**

     * @inheritdoc IStateCommitmentChain

     */

    function appendStateBatchByChainId(

        uint256 _chainId,

        bytes32[] calldata _batch,

        uint256 _shouldStartAtElement,

        string calldata proposer

    )

        override

        public

    {

        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the

        // publication of batches by some other user.

        require(

            _shouldStartAtElement == getTotalElementsByChainId(_chainId),

            "Actual batch start index does not match expected start index."

        );

        

        address proposerAddr = resolve(proposer);



        // Proposers must have previously staked at the BondManager

        require(

            IBondManager(resolve("BondManager")).isCollateralizedByChainId(_chainId,msg.sender,proposerAddr),

            "Proposer does not have enough collateral posted"

        );



        require(

            _batch.length > 0,

            "Cannot submit an empty state batch."

        );



        require(

            getTotalElementsByChainId(_chainId) + _batch.length <= ICanonicalTransactionChain(resolve("CanonicalTransactionChain")).getTotalElementsByChainId(_chainId),

            "Number of state roots cannot exceed the number of canonical transactions."

        );



        // Pass the block's timestamp and the publisher of the data

        // to be used in the fraud proofs

        _appendBatchByChainId(

            _chainId,

            _batch,

            abi.encode(block.timestamp, msg.sender),

            proposerAddr

        );

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function deleteStateBatchByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        override

        public

    {

        require(

            msg.sender == resolve(

              string(abi.encodePacked(uint2str(_chainId),"_MVM_FraudVerifier"))),

            "State batches can only be deleted by the MVM_FraudVerifier."

        );



        require(

            _isValidBatchHeaderByChainId(_chainId,_batchHeader),

            "Invalid batch header."

        );



        require(

            insideFraudProofWindowByChainId(_chainId,_batchHeader),

            "State batches can only be deleted within the fraud proof window."

        );



        _deleteBatchByChainId(_chainId,_batchHeader);

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function verifyStateCommitmentByChainId(

        uint256 _chainId,

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    )

        override

        public

        view

        returns (

            bool

        )

    {

        require(

            _isValidBatchHeaderByChainId(_chainId,_batchHeader),

            "Invalid batch header."

        );



        require(

            Lib_MerkleTree.verify(

                _batchHeader.batchRoot,

                _element,

                _proof.index,

                _proof.siblings,

                _batchHeader.batchSize

            ),

            "Invalid inclusion proof."

        );



        return true;

    }



    /**

     * @inheritdoc IStateCommitmentChain

     */

    function insideFraudProofWindowByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        override

        public

        view

        returns (

            bool _inside

        )

    {

        (uint256 timestamp,) = abi.decode(

            _batchHeader.extraData,

            (uint256, address)

        );



        require(

            timestamp != 0,

            "Batch header timestamp cannot be zero"

        );

        return timestamp + FRAUD_PROOF_WINDOW > block.timestamp;

    }

    



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Parses the batch context from the extra data.

     * @return Total number of elements submitted.

     * @return Timestamp of the last batch submitted by the sequencer.

     */

    function _getBatchExtraDataByChainId(

        uint256 _chainId

        )

        internal

        view

        returns (

            uint40,

            uint40

        )

    {

        bytes27 extraData = batches().getGlobalMetadataByChainId(_chainId);



        uint40 totalElements;

        uint40 lastSequencerTimestamp;

        assembly {

            extraData              := shr(40, extraData)

            totalElements          :=         and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)

            lastSequencerTimestamp := shr(40, and(extraData, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))

        }



        return (

            totalElements,

            lastSequencerTimestamp

        );

    }



    /**

     * Encodes the batch context for the extra data.

     * @param _totalElements Total number of elements submitted.

     * @param _lastSequencerTimestamp Timestamp of the last batch submitted by the sequencer.

     * @return Encoded batch context.

     */

    function _makeBatchExtraDataByChainId(

        uint256 _chainId,

        uint40 _totalElements,

        uint40 _lastSequencerTimestamp

    )

        internal

        pure

        returns (

            bytes27

        )

    {

        bytes27 extraData;

        assembly {

            extraData := _totalElements

            extraData := or(extraData, shl(40, _lastSequencerTimestamp))

            extraData := shl(40, extraData)

        }



        return extraData;

    }



    /**

     * Appends a batch to the chain.

     * @param _batch Elements within the batch.

     * @param _extraData Any extra data to append to the batch.

     */

    function _appendBatchByChainId(

        uint256 _chainId,

        bytes32[] memory _batch,

        bytes memory _extraData,

        address proposer

    )

        internal

    {

        (uint40 totalElements, uint40 lastSequencerTimestamp) = _getBatchExtraDataByChainId(_chainId);



        if (msg.sender == proposer) {

            lastSequencerTimestamp = uint40(block.timestamp);

        } else {

            // We keep track of the last batch submitted by the sequencer so there's a window in

            // which only the sequencer can publish state roots. A window like this just reduces

            // the chance of "system breaking" state roots being published while we're still in

            // testing mode. This window should be removed or significantly reduced in the future.

            require(

                lastSequencerTimestamp + SEQUENCER_PUBLISH_WINDOW < block.timestamp,

                "Cannot publish state roots within the sequencer publication window."

            );

        }



        // For efficiency reasons getMerkleRoot modifies the `_batch` argument in place

        // while calculating the root hash therefore any arguments passed to it must not

        // be used again afterwards

        Lib_OVMCodec.ChainBatchHeader memory batchHeader = Lib_OVMCodec.ChainBatchHeader({

            batchIndex: getTotalBatchesByChainId(_chainId),

            batchRoot: Lib_MerkleTree.getMerkleRoot(_batch),

            batchSize: _batch.length,

            prevTotalElements: totalElements,

            extraData: _extraData

        });



        emit StateBatchAppended(

            _chainId,

            batchHeader.batchIndex,

            batchHeader.batchRoot,

            batchHeader.batchSize,

            batchHeader.prevTotalElements,

            batchHeader.extraData

        );



        batches().pushByChainId(

            _chainId,

            Lib_OVMCodec.hashBatchHeader(batchHeader),

            _makeBatchExtraDataByChainId(

                _chainId,

                uint40(batchHeader.prevTotalElements + batchHeader.batchSize),

                lastSequencerTimestamp

            )

        );

    }



    /**

     * Removes a batch and all subsequent batches from the chain.

     * @param _batchHeader Header of the batch to remove.

     */

    function _deleteBatchByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        internal

    {

        require(

            _batchHeader.batchIndex < batches().lengthByChainId(_chainId),

            "Invalid batch index."

        );



        require(

            _isValidBatchHeaderByChainId(_chainId,_batchHeader),

            "Invalid batch header."

        );



        batches().deleteElementsAfterInclusiveByChainId(

            _chainId,

            _batchHeader.batchIndex,

            _makeBatchExtraDataByChainId(

                _chainId,

                uint40(_batchHeader.prevTotalElements),

                0

            )

        );



        emit StateBatchDeleted(

            _chainId,

            _batchHeader.batchIndex,

            _batchHeader.batchRoot

        );

    }



    /**

     * Checks that a batch header matches the stored hash for the given index.

     * @param _batchHeader Batch header to validate.

     * @return Whether or not the header matches the stored one.

     */

    function _isValidBatchHeaderByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        internal

        view

        returns (

            bool

        )

    {

        return Lib_OVMCodec.hashBatchHeader(_batchHeader) == batches().getByChainId(_chainId,_batchHeader.batchIndex);

    }

    

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {

        if (_i == 0) {

            return "0";

        }

        uint j = _i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len;

        while (_i != 0) {

            k = k-1;

            uint8 temp = (48 + uint8(_i - _i / 10 * 10));

            bytes1 b1 = bytes1(temp);

            bstr[k] = b1;

            _i /= 10;

        }

        return string(bstr);

    }

}





// File contracts/MVM/MVM_CanonicalTransaction.sol



// : MIT

pragma solidity ^0.8.9;



/* Library Imports */



/* Interface Imports */











contract MVM_CanonicalTransaction is iMVM_CanonicalTransaction, Lib_AddressResolver{

    /*************

     * Constants *

     *************/



    string constant public CONFIG_OWNER_KEY = "METIS_MANAGER";



    // lock seconds when begin to submit batch tx data slice

    uint256 constant public TXDATA_SUBMIT_TIMEOUT = 1800;



    /*************

     * Variables *

     *************/



    // submit tx data slice size (in bytes)

    uint256 public txDataSliceSize;

    // stake duration seconds for sequencer submit batch tx data

    uint256 public stakeSeqSeconds;

    // verifier stake base cost for a batch tx data requirement (in ETH)

    uint256 public stakeBaseCost;

    // submit tx data slice count (a whole tx batch)

    uint256 public txDataSliceCount;

    // submit tx batch size (in bytes)

    uint256 public txBatchSize;

    // verifier stake unit cost for a batch tx data requirement (in ETH)

    uint256 public stakeUnitCost;



    bool useWhiteList;



    /***************

     * Queue State *

     ***************/



    // white list

    mapping (address => bool) public whitelist;



    // mapping(address => uint256) private addressChains;



    // verifier stakes statistic

    mapping(address => uint256) private verifierStakes;



    // batch element information for validation queue

    mapping(uint256 => mapping(uint256 => BatchElement)) queueBatchElement;



    // tx data request stake queue

    mapping(uint256 => mapping(uint256 => TxDataRequestStake)) queueTxDataRequestStake;



    // tx data for verification queue

    mapping(uint256 => mapping(uint256 => TxDataSlice)) queueTxData;



    /***************

     * Constructor *

     ***************/



    constructor() Lib_AddressResolver(address(0)) {}



    /**********************

     * Function Modifiers *

     **********************/



    modifier onlyManager {

        require(

            msg.sender == resolve(CONFIG_OWNER_KEY),

            "MVM_CanonicalTransaction: Function can only be called by the METIS_MANAGER."

        );

        _;

    }



    modifier onlyWhitelisted {

        require(isWhiteListed(msg.sender), "only whitelisted verifiers can call");

        _;

    }



    /********************

     * Public Functions *

     ********************/

    /**

    receive() external payable {

        // msg.sender

        if (msg.sender == resolve('MVM_DiscountOracle')) {

            uint256 _chainId = getAddressChainId(msg.sender);

            if (_chainId > 0) {

                address _to = resolve(string(abi.encodePacked(uint2str(_chainId),"_MVM_Sequencer_Wrapper")));

                if (_to != address(0) && _to != address(this)) {

                    _to.call{value: msg.value}("");

                }

            }

        }

    }



    function setAddressChainId(address _address, uint256 _chainId)  override public onlyManager {

        require(_address != address(0), "address not available");

        require(_chainId > 0, "chainId not available");

        require(addressChains[_address] != _chainId, "no change");

        addressChains[_address] = _chainId;

    }



    function getAddressChainId(address _address) override public view returns (uint256) {

        return addressChains[_address];

    }

    */



    function setStakeBaseCost(uint256 _stakeBaseCost) override public onlyManager {

        // 1e16 = 0.01 ether

        // require(_stakeBaseCost >= 1e16, "stake base cost should gte 1e16");

        stakeBaseCost = _stakeBaseCost;

    }



    function getStakeBaseCost() override public view returns (uint256) {

        return stakeBaseCost;

    }



    function setStakeUnitCost(uint256 _stakeUnitCost) override public onlyManager {

        // 1e16 = 0.01 ether

        stakeUnitCost = _stakeUnitCost;

    }



    function getStakeUnitCost() override public view returns (uint256) {

        return stakeUnitCost;

    }



    function getStakeCostByBatch(uint256 _chainId, uint256 _batchIndex) override public view returns (uint256) {

        require(stakeBaseCost > 0, "stake base cost not config yet");

        require(queueBatchElement[_chainId][_batchIndex].txBatchTime > 0, "batch element does not exist");

        return stakeBaseCost + queueBatchElement[_chainId][_batchIndex].txBatchSize * stakeUnitCost;

    }



    function setTxDataSliceSize(uint256 _size) override public onlyManager {

        require(_size > 0, "slice size should gt 0");

        require(_size != txDataSliceSize, "slice size has not changed");

        txDataSliceSize = _size;

    }



    function getTxDataSliceSize() override public view returns (uint256) {

        return txDataSliceSize;

    }



    function setTxDataSliceCount(uint256 _count) override public onlyManager {

        require(_count > 0, "slice count should gt 0");

        require(_count != txDataSliceCount, "slice count has not changed");

        txDataSliceCount = _count;

    }



    function getTxDataSliceCount() override public view returns (uint256) {

        return txDataSliceCount;

    }



    function setTxBatchSize(uint256 _size) override public onlyManager {

        require(_size > 0, "batch size should gt 0");

        require(_size != txBatchSize, "batch size has not changed");

        txBatchSize = _size;

    }



    function getTxBatchSize() override public view returns (uint256) {

        return txBatchSize;

    }



    function setStakeSeqSeconds(uint256 _seconds) override public onlyManager {

        require(_seconds > 0, "seconds should gt 0");

        require(_seconds != stakeSeqSeconds, "seconds has not changed");

        stakeSeqSeconds = _seconds;

    }



    function getStakeSeqSeconds() override public view returns (uint256) {

        return stakeSeqSeconds;

    }



    function isWhiteListed(address _verifier) override public view returns(bool){

        return !useWhiteList || whitelist[_verifier];

    }



    function setWhiteList(address _verifier, bool _allowed) override public onlyManager {

        whitelist[_verifier] = _allowed;

        useWhiteList = true;

    }



    function disableWhiteList() override public onlyManager {

        useWhiteList = false;

    }



    function appendSequencerBatchByChainId() override public {

        uint256 _chainId;

        uint40 shouldStartAtElement;

        uint24 totalElementsToAppend;

        uint24 numContexts;

        uint256 batchTime;

        uint256 _dataSize;

        uint256 txSize;

        bytes32 root;

        assembly {

            _dataSize             := calldatasize()

            _chainId              := calldataload(4)

            shouldStartAtElement  := shr(216, calldataload(36))

            totalElementsToAppend := shr(232, calldataload(41))

            numContexts           := shr(232, calldataload(44))

        }

        require(

            msg.sender == resolve(string(abi.encodePacked(uint2str(_chainId),"_MVM_Sequencer_Wrapper"))),

            "Function can only be called by the Sequencer."

        );

        uint256 posTs =  47 + 16 * numContexts;

        if (_dataSize > posTs) {

            // when tx count = 0, there is no hash!

            // string len: [13]{milliseconds}-[1]{0}-[8]{sizeOfData}-[64]{hash}-[64]{root}

            uint256 posTxSize = 7 + posTs;

            uint256 posRoot =  11 + posTs;

            assembly {

                batchTime := shr(204, calldataload(posTs))

                txSize := shr(224, calldataload(posTxSize))

                root := calldataload(posRoot)

            }



            // check batch size

            require(txSize / 2 <= txBatchSize, "size of tx data is too large");

        }



        address ctc = resolve("CanonicalTransactionChain");

        IChainStorageContainer batchesRef = ICanonicalTransactionChain(ctc).batches();

        uint256 batchIndex = batchesRef.lengthByChainId(_chainId);

        {

            // ctc call

            (bool success, bytes memory result) = ctc.call(msg.data);

            if (success == false) {

                assembly {

                    let ptr := mload(0x40)

                    let size := returndatasize()

                    returndatacopy(ptr, 0, size)

                    revert(ptr, size)

                }

            }

        }



        // save

        queueBatchElement[_chainId][batchIndex] = BatchElement({

            shouldStartAtElement:  shouldStartAtElement,

            totalElementsToAppend: totalElementsToAppend,

            txBatchSize:           txSize,

            txBatchTime:           batchTime,

            root:                  root,

            timestamp:             block.timestamp

        });



        emit AppendBatchElement(

            _chainId,

            batchIndex,

            shouldStartAtElement,

            totalElementsToAppend,

            txSize,

            batchTime,

            root

        );

    }



    function setBatchTxDataForStake(

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber,

        bytes memory _data,

        uint256 _leafIndex,

        uint256 _totalLeaves,

        bytes32[] memory _proof

    )

        override

        public

    {

        require(

            msg.sender == resolve(string(abi.encodePacked(uint2str(_chainId),"_MVM_Sequencer_Wrapper"))),

            "Function can only be called by the Sequencer."

        );

        // check stake

        require(queueTxDataRequestStake[_chainId][_blockNumber].timestamp > 0, "there is no stake for this block number");

        require(queueTxDataRequestStake[_chainId][_blockNumber].batchIndex == _batchIndex, "incorrect batch index");

        require(queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT, "not allowed to submit");

        // sequencer can submit at any time

        // require(queueTxDataRequestStake[_chainId][_blockNumber].endtime >= block.timestamp, "can not submit out of sequencer submit protection");



        _setBatchTxData(_chainId, _batchIndex, _blockNumber, _data, _leafIndex, _totalLeaves,  _proof,  true);



        if (queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT) {

            require(

                queueTxDataRequestStake[_chainId][_blockNumber].amount <= verifierStakes[queueTxDataRequestStake[_chainId][_blockNumber].sender],

                "insufficient stake"

            );

            require(

                queueTxDataRequestStake[_chainId][_blockNumber].amount <= address(this).balance,

                "insufficient balance"

            );

            queueTxDataRequestStake[_chainId][_blockNumber].status = STAKESTATUS.SEQ_SET;

            if (queueTxDataRequestStake[_chainId][_blockNumber].amount > 0){

                verifierStakes[queueTxDataRequestStake[_chainId][_blockNumber].sender] -= queueTxDataRequestStake[_chainId][_blockNumber].amount;

                // transfer from contract to sender ETHER and record

                (bool success, ) = payable(msg.sender).call{value: queueTxDataRequestStake[_chainId][_blockNumber].amount}("");

                require(success, "insufficient balance");

                queueTxDataRequestStake[_chainId][_blockNumber].amount = 0;

            }

        }



        emit SetBatchTxData(

            msg.sender,

            _chainId,

            _batchIndex,

            _blockNumber,

            queueTxDataRequestStake[_chainId][_blockNumber].amount,

            true,

            true

        );

    }



    function setBatchTxDataForVerifier(

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber,

        bytes memory _data

    )

        override

        public

    {

         require(

            msg.sender != resolve(string(abi.encodePacked(uint2str(_chainId),"_MVM_Sequencer_Wrapper"))),

            "Function can not be called by the Sequencer."

        );

        // check stake

        require(queueTxDataRequestStake[_chainId][_blockNumber].timestamp > 0, "there is no stake for this block number");

        require(queueTxDataRequestStake[_chainId][_blockNumber].batchIndex == _batchIndex, "incorrect batch index");

        // require(queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT, "not allowed to submit");

        // require(queueTxDataRequestStake[_chainId][_blockNumber].sender == msg.sender, "can not submit with other's stake");

        require(queueTxDataRequestStake[_chainId][_blockNumber].endtime < block.timestamp, "can not submit during sequencer submit protection");

        if (queueTxDataRequestStake[_chainId][_blockNumber].sender != msg.sender) {

            // other verifier can submit in double window times

            require(queueTxDataRequestStake[_chainId][_blockNumber].endtime + stakeSeqSeconds < block.timestamp, "can not submit during staker submit protection");

        }



        _setBatchTxData(_chainId, _batchIndex, _blockNumber, _data, 0, 0, new bytes32[](0), false);



        if (queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT) {

            queueTxDataRequestStake[_chainId][_blockNumber].status = STAKESTATUS.VERIFIER_SET;



            address claimer = queueTxDataRequestStake[_chainId][_blockNumber].sender;

            if (queueTxDataRequestStake[_chainId][_blockNumber].amount <= verifierStakes[claimer] && queueTxDataRequestStake[_chainId][_blockNumber].amount > 0) {

                require(

                    queueTxDataRequestStake[_chainId][_blockNumber].amount <= address(this).balance,

                    "insufficient balance"

                );

                verifierStakes[claimer] -= queueTxDataRequestStake[_chainId][_blockNumber].amount;

                // transfer from contract to sender ETHER and record

                (bool success, ) = payable(claimer).call{value: queueTxDataRequestStake[_chainId][_blockNumber].amount}("");

                require(success, "insufficient balance");

                queueTxDataRequestStake[_chainId][_blockNumber].amount = 0;

            }

        }



        emit SetBatchTxData(

            msg.sender,

            _chainId,

            _batchIndex,

            _blockNumber,

            queueTxDataRequestStake[_chainId][_blockNumber].amount,

            false,

            false

        );

    }



    function _setBatchTxData(

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber,

        bytes memory _data,

        uint256 _leafIndex,

        uint256 _totalLeaves,

        bytes32[] memory _proof,

        bool _requireVerify

    )

        internal

    {

        require(_data.length > 0, "empty data");

        // check queue BatchElement

        require(queueBatchElement[_chainId][_batchIndex].txBatchTime > 0, "batch element does not exist");

        require(queueBatchElement[_chainId][_batchIndex].totalElementsToAppend > 0, "batch total element to append should not be zero");

       

        // sequencer protect

        if (queueTxData[_chainId][_blockNumber].timestamp > 0) {

            require(queueTxData[_chainId][_blockNumber].verified == false, "tx data verified");

            if (queueTxData[_chainId][_blockNumber].sender != msg.sender) {

                require(queueTxData[_chainId][_blockNumber].timestamp + TXDATA_SUBMIT_TIMEOUT > block.timestamp, "in submitting");



                // change sumbitter

                queueTxData[_chainId][_blockNumber].sender = msg.sender;

                queueTxData[_chainId][_blockNumber].blockNumber = _blockNumber;

                queueTxData[_chainId][_blockNumber].batchIndex = _batchIndex;

                queueTxData[_chainId][_blockNumber].timestamp = block.timestamp;

                queueTxData[_chainId][_blockNumber].txData = _data;

                queueTxData[_chainId][_blockNumber].verified = false;

            }

            else {

                queueTxData[_chainId][_blockNumber].txData = _data;

                // verified restore to false

                queueTxData[_chainId][_blockNumber].verified = false;

            }

        }

        else {

            queueTxData[_chainId][_blockNumber] = TxDataSlice({

                sender:         msg.sender,

                blockNumber:    _blockNumber,

                batchIndex:    _batchIndex,

                timestamp:      block.timestamp,

                txData:         _data,

                verified:       false

            });

        }

        if (_requireVerify) {

            bytes32 currLeaf = keccak256(abi.encodePacked(_blockNumber, _data));

            bool verified = Lib_MerkleTree.verify(queueBatchElement[_chainId][_batchIndex].root, currLeaf, _leafIndex, _proof, _totalLeaves);

            require(verified == true, "tx data verify failed");



            // save verified status

            queueTxData[_chainId][_blockNumber].verified = true;

        }

    }



    function getBatchTxData(

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber

    )

        override

        external

        view

        returns (

            bytes memory txData,

            bool verified

        )

    {

        require(queueTxData[_chainId][_blockNumber].timestamp != 0, "tx data does not exist");

        require(queueTxData[_chainId][_blockNumber].batchIndex == _batchIndex, "incorrect batch index");

        return (

            queueTxData[_chainId][_blockNumber].txData,

            queueTxData[_chainId][_blockNumber].verified

        );

    }



    function checkBatchTxHash(

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber,

        bytes memory _data

    )

        override

        external

        view

        returns (

            bytes32 txHash,

            bool verified

        )

    {

        require(queueTxData[_chainId][_blockNumber].timestamp != 0, "tx data does not exist");

        require(queueTxData[_chainId][_blockNumber].batchIndex == _batchIndex, "incorrect batch index");

        return (

            keccak256(abi.encodePacked(_blockNumber, _data)),

            queueTxData[_chainId][_blockNumber].verified

        );

    }



    function setBatchTxDataVerified(

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber,

        bool _verified

    )

        override

        public

        onlyManager

    {

        require(queueTxData[_chainId][_blockNumber].timestamp != 0, "tx data does not exist");

        require(queueTxData[_chainId][_blockNumber].batchIndex == _batchIndex, "incorrect batch index");

        require(queueTxData[_chainId][_blockNumber].verified != _verified, "verified status not change");



        queueTxData[_chainId][_blockNumber].verified = _verified;

    }



    function verifierStake(

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber

    )

        override

        public

        payable

        onlyWhitelisted

    {

        uint256 _amount = msg.value;

        uint256 stakeCost = getStakeCostByBatch(_chainId, _batchIndex);

        require(stakeBaseCost > 0, "stake base cost not config yet");

        require(stakeCost == _amount, "stake cost incorrect");

        require(stakeSeqSeconds > 0, "sequencer submit seconds not config yet");

        // check queue BatchElement

        require(queueBatchElement[_chainId][_batchIndex].txBatchTime > 0, "batch element does not exist");

        // check block number in batch range, block number = index + 1

        require(queueBatchElement[_chainId][_batchIndex].totalElementsToAppend + queueBatchElement[_chainId][_batchIndex].shouldStartAtElement >= _blockNumber && queueBatchElement[_chainId][_batchIndex].shouldStartAtElement < _blockNumber, "block number is not in this batch");

        if (queueTxDataRequestStake[_chainId][_blockNumber].timestamp > 0) {

            require(queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.PAYBACK, "there is a stake for this batch index");

        }



        //check window

        StateCommitmentChain stateChain = StateCommitmentChain(resolve("StateCommitmentChain"));

        require(queueBatchElement[_chainId][_batchIndex].timestamp + stateChain.FRAUD_PROOF_WINDOW() > block.timestamp, "the batch is outside of the fraud proof window");



        queueTxDataRequestStake[_chainId][_blockNumber] = TxDataRequestStake({

            sender:      msg.sender,

            blockNumber: _blockNumber,

            batchIndex:  _batchIndex,

            timestamp:   block.timestamp,

            endtime:     block.timestamp + stakeSeqSeconds,

            amount:      _amount,

            status:      STAKESTATUS.INIT

        });

        verifierStakes[msg.sender] += _amount;



        emit VerifierStake(msg.sender, _chainId, _batchIndex, _blockNumber, _amount);

    }



    function withdrawStake(

        uint256 _chainId,

        uint256 _batchIndex,

        uint256 _blockNumber

    )

        override

        public

    {

        require(queueTxDataRequestStake[_chainId][_blockNumber].timestamp > 0, "there is no stake for this batch index");

        require(queueTxDataRequestStake[_chainId][_blockNumber].amount > 0, "stake amount is zero");

        require(queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT, "withdrawals are not allowed");

        require(queueTxDataRequestStake[_chainId][_blockNumber].sender == msg.sender, "can not withdraw other's stake");

        require(queueTxDataRequestStake[_chainId][_blockNumber].endtime < block.timestamp, "can not withdraw during submit protection");

        require(queueTxDataRequestStake[_chainId][_blockNumber].amount <= verifierStakes[msg.sender], "insufficient stake");



        require(

            queueTxDataRequestStake[_chainId][_blockNumber].amount <= address(this).balance,

            "insufficient balance"

        );

        queueTxDataRequestStake[_chainId][_blockNumber].status = STAKESTATUS.PAYBACK;

        verifierStakes[msg.sender] -= queueTxDataRequestStake[_chainId][_blockNumber].amount;

        // transfer from contract to sender ETHER and record

        (bool success, ) = payable(msg.sender).call{value: queueTxDataRequestStake[_chainId][_blockNumber].amount}("");

        require(success, "insufficient balance");

        queueTxDataRequestStake[_chainId][_blockNumber].amount = 0;

    }



    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {

        if (_i == 0) {

            return "0";

        }

        uint j = _i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len;

        while (_i != 0) {

            k = k-1;

            uint8 temp = (48 + uint8(_i - _i / 10 * 10));

            bytes1 b1 = bytes1(temp);

            bstr[k] = b1;

            _i /= 10;

        }

        return string(bstr);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\MVM_L2ChainManagerOnL1.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

pragma experimental ABIEncoderV2;



/* Library Imports */

import { CrossDomainEnabled } from "../libraries/bridge/CrossDomainEnabled.sol";

import { Lib_PredeployAddresses } from "../libraries/constants/Lib_PredeployAddresses.sol";

import { Lib_AddressManager } from "../libraries/resolver/Lib_AddressManager.sol";

import { iOVM_SequencerFeeVault } from "../L2/predeploys/iOVM_SequencerFeeVault.sol";

import { iMVM_L2ChainManagerOnL1 } from "./iMVM_L2ChainManagerOnL1.sol";

import { iMVM_DiscountOracle } from "./iMVM_DiscountOracle.sol";

/* Interface Imports */



/* External Imports */



/**

 * @title MVM_L2ChainManagerOnL1

 * @dev if want support multi l2 chain on l1,it should add a manager to desc 

 * how many l2 chain now ,and dispatch the l2 chain id to make it is unique.

 *

 * Compiler used: solc

 * Runtime target: EVM

 */

contract MVM_L2ChainManagerOnL1 is iMVM_L2ChainManagerOnL1, CrossDomainEnabled {

 

    /*************

     * Constants *

     *************/

    string constant public CONFIG_OWNER_KEY = "METIS_MANAGER";

    

    /*************

     * Variables *

     *************/

    address public addressmgr;

    // chainid => sequencer

    mapping (uint256 => address) squencers;

    

    // chainid => configs (unused for now);

    mapping (uint256 => bytes) configs;

    

    /***************

     * Constructor *

     ***************/

    // This contract lives behind a proxy, so the constructor parameters will go unused.

    constructor() CrossDomainEnabled(address(0)) {}



    

    /**********************

     * Function Modifiers *

     **********************/



    modifier onlyManager() {

        require(

            msg.sender == Lib_AddressManager(addressmgr).getAddress(CONFIG_OWNER_KEY),

            "MVM_L2ChainManagerOnL1: Function can only be called by the METIS_MANAGER."

        );

        _;

    }



    /********************

     * Public Functions *

     ********************/

    function switchSequencer(uint256 _chainId, address wallet, address manager) public onlyManager payable {

            

        bytes memory message =

            abi.encodeWithSelector(

                iOVM_SequencerFeeVault.finalizeChainSwitch.selector,

                wallet,

                manager

            );

        

        // Send calldata into L2

        sendCrossDomainMessageViaChainId(

            _chainId,

            Lib_PredeployAddresses.SEQUENCER_FEE_WALLET,

            uint32(1_000_000_000),

            message,

            msg.value

        );



        emit SwitchSeq(_chainId, wallet, manager);

    }

    

    function pushConfig(uint256 _chainId, bytes calldata _configs) public payable {

        bytes memory message =

            abi.encodeWithSelector(

                iOVM_SequencerFeeVault.finalizeChainConfig.selector,

                _configs

            );

            

        // Send calldata into L2

        sendCrossDomainMessageViaChainId(

            _chainId,

            Lib_PredeployAddresses.SEQUENCER_FEE_WALLET,

            uint32(1_000_000_000),

            message,

            msg.value

        );

        

        emit PushConfig(_chainId, _configs);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\MVM_Verifier.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2022-04-27

*/



// Sources flattened with hardhat v2.6.1 https://hardhat.org



// File @openzeppelin/contracts/utils/Context.sol@v4.3.2



//  SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}





// File @openzeppelin/contracts/access/Ownable.sol@v4.3.2



//   MIT



pragma solidity ^0.8.0;



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _setOwner(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _setOwner(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _setOwner(newOwner);

    }



    function _setOwner(address newOwner) private {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}





// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.2



//   MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}





// File contracts/MVM/iMVM_DiscountOracle.sol



//   MIT

pragma solidity ^0.8.9;



interface iMVM_DiscountOracle{



    function setDiscount(

        uint256 _discount

    ) external;

    

    function setMinL2Gas(

        uint256 _minL2Gas

    ) external;

    

    function setWhitelistedXDomainSender(

        address _sender,

        bool _isWhitelisted

    ) external;

    

    function isXDomainSenderAllowed(

        address _sender

    ) view external returns(bool);

    

    function setAllowAllXDomainSenders(

        bool _allowAllXDomainSenders

    ) external;

    

    function getMinL2Gas() view external returns(uint256);

    function getDiscount() view external returns(uint256);

    function processL2SeqGas(address sender, uint256 _chainId) external payable;

}





// File contracts/libraries/resolver/Lib_AddressManager.sol



//   MIT

pragma solidity ^0.8.9;



/* External Imports */



/**

 * @title Lib_AddressManager

 */

contract Lib_AddressManager is Ownable {

    /**********

     * Events *

     **********/



    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);



    /*************

     * Variables *

     *************/



    mapping(bytes32 => address) private addresses;



    /********************

     * Public Functions *

     ********************/



    /**

     * Changes the address associated with a particular name.

     * @param _name String name to associate an address with.

     * @param _address Address to associate with the name.

     */

    function setAddress(string memory _name, address _address) external onlyOwner {

        bytes32 nameHash = _getNameHash(_name);

        address oldAddress = addresses[nameHash];

        addresses[nameHash] = _address;



        emit AddressSet(_name, _address, oldAddress);

    }



    /**

     * Retrieves the address associated with a given name.

     * @param _name Name to retrieve an address for.

     * @return Address associated with the given name.

     */

    function getAddress(string memory _name) external view returns (address) {

        return addresses[_getNameHash(_name)];

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Computes the hash of a name.

     * @param _name Name to compute a hash for.

     * @return Hash of the given name.

     */

    function _getNameHash(string memory _name) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked(_name));

    }

}





// File contracts/libraries/resolver/Lib_AddressResolver.sol



//   MIT

pragma solidity ^0.8.9;



/* Library Imports */



/**

 * @title Lib_AddressResolver

 */

abstract contract Lib_AddressResolver {

    /*************

     * Variables *

     *************/



    Lib_AddressManager public libAddressManager;



    /***************

     * Constructor *

     ***************/



    /**

     * @param _libAddressManager Address of the Lib_AddressManager.

     */

    constructor(address _libAddressManager) {

        libAddressManager = Lib_AddressManager(_libAddressManager);

    }



    /********************

     * Public Functions *

     ********************/



    /**

     * Resolves the address associated with a given name.

     * @param _name Name to resolve an address for.

     * @return Address associated with the given name.

     */

    function resolve(string memory _name) public view returns (address) {

        return libAddressManager.getAddress(_name);

    }

}





// File contracts/libraries/rlp/Lib_RLPReader.sol



//   MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_RLPReader

 * @dev Adapted from "RLPReader" by Hamdi Allam (hamdi.allam97@gmail.com).

 */

library Lib_RLPReader {

    /*************

     * Constants *

     *************/



    uint256 internal constant MAX_LIST_LENGTH = 32;



    /*********

     * Enums *

     *********/



    enum RLPItemType {

        DATA_ITEM,

        LIST_ITEM

    }



    /***********

     * Structs *

     ***********/



    struct RLPItem {

        uint256 length;

        uint256 ptr;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Converts bytes to a reference to memory position and length.

     * @param _in Input bytes to convert.

     * @return Output memory reference.

     */

    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {

        uint256 ptr;

        assembly {

            ptr := add(_in, 32)

        }



        return RLPItem({ length: _in.length, ptr: ptr });

    }



    /**

     * Reads an RLP list value into a list of RLP items.

     * @param _in RLP list value.

     * @return Decoded RLP list items.

     */

    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {

        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);



        require(itemType == RLPItemType.LIST_ITEM, "Invalid RLP list value.");



        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by

        // writing to the length. Since we can't know the number of RLP items without looping over

        // the entire input, we'd have to loop twice to accurately size this array. It's easier to

        // simply set a reasonable maximum list length and decrease the size before we finish.

        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);



        uint256 itemCount = 0;

        uint256 offset = listOffset;

        while (offset < _in.length) {

            require(itemCount < MAX_LIST_LENGTH, "Provided RLP list exceeds max list length.");



            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(

                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })

            );



            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });



            itemCount += 1;

            offset += itemOffset + itemLength;

        }



        // Decrease the array size to match the actual item count.

        assembly {

            mstore(out, itemCount)

        }



        return out;

    }



    /**

     * Reads an RLP list value into a list of RLP items.

     * @param _in RLP list value.

     * @return Decoded RLP list items.

     */

    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {

        return readList(toRLPItem(_in));

    }



    /**

     * Reads an RLP bytes value into bytes.

     * @param _in RLP bytes value.

     * @return Decoded bytes.

     */

    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {

        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);



        require(itemType == RLPItemType.DATA_ITEM, "Invalid RLP bytes value.");



        return _copy(_in.ptr, itemOffset, itemLength);

    }



    /**

     * Reads an RLP bytes value into bytes.

     * @param _in RLP bytes value.

     * @return Decoded bytes.

     */

    function readBytes(bytes memory _in) internal pure returns (bytes memory) {

        return readBytes(toRLPItem(_in));

    }



    /**

     * Reads an RLP string value into a string.

     * @param _in RLP string value.

     * @return Decoded string.

     */

    function readString(RLPItem memory _in) internal pure returns (string memory) {

        return string(readBytes(_in));

    }



    /**

     * Reads an RLP string value into a string.

     * @param _in RLP string value.

     * @return Decoded string.

     */

    function readString(bytes memory _in) internal pure returns (string memory) {

        return readString(toRLPItem(_in));

    }



    /**

     * Reads an RLP bytes32 value into a bytes32.

     * @param _in RLP bytes32 value.

     * @return Decoded bytes32.

     */

    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {

        require(_in.length <= 33, "Invalid RLP bytes32 value.");



        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);



        require(itemType == RLPItemType.DATA_ITEM, "Invalid RLP bytes32 value.");



        uint256 ptr = _in.ptr + itemOffset;

        bytes32 out;

        assembly {

            out := mload(ptr)



            // Shift the bytes over to match the item size.

            if lt(itemLength, 32) {

                out := div(out, exp(256, sub(32, itemLength)))

            }

        }



        return out;

    }



    /**

     * Reads an RLP bytes32 value into a bytes32.

     * @param _in RLP bytes32 value.

     * @return Decoded bytes32.

     */

    function readBytes32(bytes memory _in) internal pure returns (bytes32) {

        return readBytes32(toRLPItem(_in));

    }



    /**

     * Reads an RLP uint256 value into a uint256.

     * @param _in RLP uint256 value.

     * @return Decoded uint256.

     */

    function readUint256(RLPItem memory _in) internal pure returns (uint256) {

        return uint256(readBytes32(_in));

    }



    /**

     * Reads an RLP uint256 value into a uint256.

     * @param _in RLP uint256 value.

     * @return Decoded uint256.

     */

    function readUint256(bytes memory _in) internal pure returns (uint256) {

        return readUint256(toRLPItem(_in));

    }



    /**

     * Reads an RLP bool value into a bool.

     * @param _in RLP bool value.

     * @return Decoded bool.

     */

    function readBool(RLPItem memory _in) internal pure returns (bool) {

        require(_in.length == 1, "Invalid RLP boolean value.");



        uint256 ptr = _in.ptr;

        uint256 out;

        assembly {

            out := byte(0, mload(ptr))

        }



        require(out == 0 || out == 1, "Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1");



        return out != 0;

    }



    /**

     * Reads an RLP bool value into a bool.

     * @param _in RLP bool value.

     * @return Decoded bool.

     */

    function readBool(bytes memory _in) internal pure returns (bool) {

        return readBool(toRLPItem(_in));

    }



    /**

     * Reads an RLP address value into a address.

     * @param _in RLP address value.

     * @return Decoded address.

     */

    function readAddress(RLPItem memory _in) internal pure returns (address) {

        if (_in.length == 1) {

            return address(0);

        }



        require(_in.length == 21, "Invalid RLP address value.");



        return address(uint160(readUint256(_in)));

    }



    /**

     * Reads an RLP address value into a address.

     * @param _in RLP address value.

     * @return Decoded address.

     */

    function readAddress(bytes memory _in) internal pure returns (address) {

        return readAddress(toRLPItem(_in));

    }



    /**

     * Reads the raw bytes of an RLP item.

     * @param _in RLP item to read.

     * @return Raw RLP bytes.

     */

    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {

        return _copy(_in);

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Decodes the length of an RLP item.

     * @param _in RLP item to decode.

     * @return Offset of the encoded data.

     * @return Length of the encoded data.

     * @return RLP item type (LIST_ITEM or DATA_ITEM).

     */

    function _decodeLength(RLPItem memory _in)

        private

        pure

        returns (

            uint256,

            uint256,

            RLPItemType

        )

    {

        require(_in.length > 0, "RLP item cannot be null.");



        uint256 ptr = _in.ptr;

        uint256 prefix;

        assembly {

            prefix := byte(0, mload(ptr))

        }



        if (prefix <= 0x7f) {

            // Single byte.



            return (0, 1, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xb7) {

            // Short string.



            uint256 strLen = prefix - 0x80;



            require(_in.length > strLen, "Invalid RLP short string.");



            return (1, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xbf) {

            // Long string.

            uint256 lenOfStrLen = prefix - 0xb7;



            require(_in.length > lenOfStrLen, "Invalid RLP long string length.");



            uint256 strLen;

            assembly {

                // Pick out the string length.

                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))

            }



            require(_in.length > lenOfStrLen + strLen, "Invalid RLP long string.");



            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);

        } else if (prefix <= 0xf7) {

            // Short list.

            uint256 listLen = prefix - 0xc0;



            require(_in.length > listLen, "Invalid RLP short list.");



            return (1, listLen, RLPItemType.LIST_ITEM);

        } else {

            // Long list.

            uint256 lenOfListLen = prefix - 0xf7;



            require(_in.length > lenOfListLen, "Invalid RLP long list length.");



            uint256 listLen;

            assembly {

                // Pick out the list length.

                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))

            }



            require(_in.length > lenOfListLen + listLen, "Invalid RLP long list.");



            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);

        }

    }



    /**

     * Copies the bytes from a memory location.

     * @param _src Pointer to the location to read from.

     * @param _offset Offset to start reading from.

     * @param _length Number of bytes to read.

     * @return Copied bytes.

     */

    function _copy(

        uint256 _src,

        uint256 _offset,

        uint256 _length

    ) private pure returns (bytes memory) {

        bytes memory out = new bytes(_length);

        if (out.length == 0) {

            return out;

        }



        uint256 src = _src + _offset;

        uint256 dest;

        assembly {

            dest := add(out, 32)

        }



        // Copy over as many complete words as we can.

        for (uint256 i = 0; i < _length / 32; i++) {

            assembly {

                mstore(dest, mload(src))

            }



            src += 32;

            dest += 32;

        }



        // Pick out the remaining bytes.

        uint256 mask;

        unchecked {

            mask = 256**(32 - (_length % 32)) - 1;

        }



        assembly {

            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))

        }

        return out;

    }



    /**

     * Copies an RLP item into bytes.

     * @param _in RLP item to copy.

     * @return Copied bytes.

     */

    function _copy(RLPItem memory _in) private pure returns (bytes memory) {

        return _copy(_in.ptr, 0, _in.length);

    }

}





// File contracts/libraries/rlp/Lib_RLPWriter.sol



//   MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_RLPWriter

 * @author Bakaoh (with modifications)

 */

library Lib_RLPWriter {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * RLP encodes a byte string.

     * @param _in The byte string to encode.

     * @return The RLP encoded string in bytes.

     */

    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {

        bytes memory encoded;



        if (_in.length == 1 && uint8(_in[0]) < 128) {

            encoded = _in;

        } else {

            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);

        }



        return encoded;

    }



    /**

     * RLP encodes a list of RLP encoded byte byte strings.

     * @param _in The list of RLP encoded byte strings.

     * @return The RLP encoded list of items in bytes.

     */

    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {

        bytes memory list = _flatten(_in);

        return abi.encodePacked(_writeLength(list.length, 192), list);

    }



    /**

     * RLP encodes a string.

     * @param _in The string to encode.

     * @return The RLP encoded string in bytes.

     */

    function writeString(string memory _in) internal pure returns (bytes memory) {

        return writeBytes(bytes(_in));

    }



    /**

     * RLP encodes an address.

     * @param _in The address to encode.

     * @return The RLP encoded address in bytes.

     */

    function writeAddress(address _in) internal pure returns (bytes memory) {

        return writeBytes(abi.encodePacked(_in));

    }



    /**

     * RLP encodes a uint.

     * @param _in The uint256 to encode.

     * @return The RLP encoded uint256 in bytes.

     */

    function writeUint(uint256 _in) internal pure returns (bytes memory) {

        return writeBytes(_toBinary(_in));

    }



    /**

     * RLP encodes a bool.

     * @param _in The bool to encode.

     * @return The RLP encoded bool in bytes.

     */

    function writeBool(bool _in) internal pure returns (bytes memory) {

        bytes memory encoded = new bytes(1);

        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));

        return encoded;

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.

     * @param _len The length of the string or the payload.

     * @param _offset 128 if item is string, 192 if item is list.

     * @return RLP encoded bytes.

     */

    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {

        bytes memory encoded;



        if (_len < 56) {

            encoded = new bytes(1);

            encoded[0] = bytes1(uint8(_len) + uint8(_offset));

        } else {

            uint256 lenLen;

            uint256 i = 1;

            while (_len / i != 0) {

                lenLen++;

                i *= 256;

            }



            encoded = new bytes(lenLen + 1);

            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);

            for (i = 1; i <= lenLen; i++) {

                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));

            }

        }



        return encoded;

    }



    /**

     * Encode integer in big endian binary form with no leading zeroes.

     * @notice TODO: This should be optimized with assembly to save gas costs.

     * @param _x The integer to encode.

     * @return RLP encoded bytes.

     */

    function _toBinary(uint256 _x) private pure returns (bytes memory) {

        bytes memory b = abi.encodePacked(_x);



        uint256 i = 0;

        for (; i < 32; i++) {

            if (b[i] != 0) {

                break;

            }

        }



        bytes memory res = new bytes(32 - i);

        for (uint256 j = 0; j < res.length; j++) {

            res[j] = b[i++];

        }



        return res;

    }



    /**

     * Copies a piece of memory to another location.

     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.

     * @param _dest Destination location.

     * @param _src Source location.

     * @param _len Length of memory to copy.

     */

    function _memcpy(

        uint256 _dest,

        uint256 _src,

        uint256 _len

    ) private pure {

        uint256 dest = _dest;

        uint256 src = _src;

        uint256 len = _len;



        for (; len >= 32; len -= 32) {

            assembly {

                mstore(dest, mload(src))

            }

            dest += 32;

            src += 32;

        }



        uint256 mask;

        unchecked {

            mask = 256**(32 - len) - 1;

        }

        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }

    }



    /**

     * Flattens a list of byte strings into one byte string.

     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.

     * @param _list List of byte strings to flatten.

     * @return The flattened byte string.

     */

    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {

        if (_list.length == 0) {

            return new bytes(0);

        }



        uint256 len;

        uint256 i = 0;

        for (; i < _list.length; i++) {

            len += _list[i].length;

        }



        bytes memory flattened = new bytes(len);

        uint256 flattenedPtr;

        assembly {

            flattenedPtr := add(flattened, 0x20)

        }



        for (i = 0; i < _list.length; i++) {

            bytes memory item = _list[i];



            uint256 listPtr;

            assembly {

                listPtr := add(item, 0x20)

            }



            _memcpy(flattenedPtr, listPtr, item.length);

            flattenedPtr += _list[i].length;

        }



        return flattened;

    }

}





// File contracts/libraries/utils/Lib_BytesUtils.sol



//   MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_BytesUtils

 */

library Lib_BytesUtils {

    /**********************

     * Internal Functions *

     **********************/



    function slice(

        bytes memory _bytes,

        uint256 _start,

        uint256 _length

    ) internal pure returns (bytes memory) {

        require(_length + 31 >= _length, "slice_overflow");

        require(_start + _length >= _start, "slice_overflow");

        require(_bytes.length >= _start + _length, "slice_outOfBounds");



        bytes memory tempBytes;



        assembly {

            switch iszero(_length)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                let lengthmod := and(_length, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, _length)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, _length)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                //zero out the 32 bytes slice we are about to return

                //we need to do it because Solidity does not garbage collect

                mstore(tempBytes, 0)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return tempBytes;

    }



    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {

        if (_start >= _bytes.length) {

            return bytes("");

        }



        return slice(_bytes, _start, _bytes.length - _start);

    }



    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {

        if (_bytes.length < 32) {

            bytes32 ret;

            assembly {

                ret := mload(add(_bytes, 32))

            }

            return ret;

        }



        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes

    }



    function toUint256(bytes memory _bytes) internal pure returns (uint256) {

        return uint256(toBytes32(_bytes));

    }



    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {

        bytes memory nibbles = new bytes(_bytes.length * 2);



        for (uint256 i = 0; i < _bytes.length; i++) {

            nibbles[i * 2] = _bytes[i] >> 4;

            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);

        }



        return nibbles;

    }



    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {

        bytes memory ret = new bytes(_bytes.length / 2);



        for (uint256 i = 0; i < ret.length; i++) {

            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);

        }



        return ret;

    }



    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {

        return keccak256(_bytes) == keccak256(_other);

    }

}





// File contracts/libraries/utils/Lib_Bytes32Utils.sol



//   MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_Byte32Utils

 */

library Lib_Bytes32Utils {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to "true."

     * @param _in Input bytes32 value.

     * @return Bytes32 as a boolean.

     */

    function toBool(bytes32 _in) internal pure returns (bool) {

        return _in != 0;

    }



    /**

     * Converts a boolean to a bytes32 value.

     * @param _in Input boolean value.

     * @return Boolean as a bytes32.

     */

    function fromBool(bool _in) internal pure returns (bytes32) {

        return bytes32(uint256(_in ? 1 : 0));

    }



    /**

     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.

     * @param _in Input bytes32 value.

     * @return Bytes32 as an address.

     */

    function toAddress(bytes32 _in) internal pure returns (address) {

        return address(uint160(uint256(_in)));

    }



    /**

     * Converts an address to a bytes32.

     * @param _in Input address value.

     * @return Address as a bytes32.

     */

    function fromAddress(address _in) internal pure returns (bytes32) {

        return bytes32(uint256(uint160(_in)));

    }

}





// File contracts/libraries/codec/Lib_OVMCodec.sol



//   MIT

pragma solidity ^0.8.9;



/* Library Imports */









/**

 * @title Lib_OVMCodec

 */

library Lib_OVMCodec {

    /*********

     * Enums *

     *********/



    enum QueueOrigin {

        SEQUENCER_QUEUE,

        L1TOL2_QUEUE

    }



    /***********

     * Structs *

     ***********/



    struct EVMAccount {

        uint256 nonce;

        uint256 balance;

        bytes32 storageRoot;

        bytes32 codeHash;

    }



    struct ChainBatchHeader {

        uint256 batchIndex;

        bytes32 batchRoot;

        uint256 batchSize;

        uint256 prevTotalElements;

        bytes extraData;

    }



    struct ChainInclusionProof {

        uint256 index;

        bytes32[] siblings;

    }



    struct Transaction {

        uint256 timestamp;

        uint256 blockNumber;

        QueueOrigin l1QueueOrigin;

        address l1TxOrigin;

        address entrypoint;

        uint256 gasLimit;

        bytes data;

    }



    struct TransactionChainElement {

        bool isSequenced;

        uint256 queueIndex; // QUEUED TX ONLY

        uint256 timestamp; // SEQUENCER TX ONLY

        uint256 blockNumber; // SEQUENCER TX ONLY

        bytes txData; // SEQUENCER TX ONLY

    }



    struct QueueElement {

        bytes32 transactionHash;

        uint40 timestamp;

        uint40 blockNumber;

    }



    /**********************

     * Internal Functions *

     **********************/



    /**

     * Encodes a standard OVM transaction.

     * @param _transaction OVM transaction to encode.

     * @return Encoded transaction bytes.

     */

    function encodeTransaction(Transaction memory _transaction)

        internal

        pure

        returns (bytes memory)

    {

        return

            abi.encodePacked(

                _transaction.timestamp,

                _transaction.blockNumber,

                _transaction.l1QueueOrigin,

                _transaction.l1TxOrigin,

                _transaction.entrypoint,

                _transaction.gasLimit,

                _transaction.data

            );

    }



    /**

     * Hashes a standard OVM transaction.

     * @param _transaction OVM transaction to encode.

     * @return Hashed transaction

     */

    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {

        return keccak256(encodeTransaction(_transaction));

    }



    /**

     * @notice Decodes an RLP-encoded account state into a useful struct.

     * @param _encoded RLP-encoded account state.

     * @return Account state struct.

     */

    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {

        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);



        return

            EVMAccount({

                nonce: Lib_RLPReader.readUint256(accountState[0]),

                balance: Lib_RLPReader.readUint256(accountState[1]),

                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),

                codeHash: Lib_RLPReader.readBytes32(accountState[3])

            });

    }



    /**

     * Calculates a hash for a given batch header.

     * @param _batchHeader Header to hash.

     * @return Hash of the header.

     */

    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)

        internal

        pure

        returns (bytes32)

    {

        return

            keccak256(

                abi.encode(

                    _batchHeader.batchRoot,

                    _batchHeader.batchSize,

                    _batchHeader.prevTotalElements,

                    _batchHeader.extraData

                )

            );

    }

}





// File contracts/libraries/utils/Lib_MerkleTree.sol



//   MIT

pragma solidity ^0.8.9;



/**

 * @title Lib_MerkleTree

 * @author River Keefer

 */

library Lib_MerkleTree {

    /**********************

     * Internal Functions *

     **********************/



    /**

     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number

     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.

     * If you do not know the original length of elements for the tree you are verifying, then

     * this may allow empty leaves past _elements.length to pass a verification check down the line.

     * Note that the _elements argument is modified, therefore it must not be used again afterwards

     * @param _elements Array of hashes from which to generate a merkle root.

     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).

     */

    function getMerkleRoot(bytes32[] memory _elements) internal pure returns (bytes32) {

        require(_elements.length > 0, "Lib_MerkleTree: Must provide at least one leaf hash.");



        if (_elements.length == 1) {

            return _elements[0];

        }



        uint256[16] memory defaults = [

            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,

            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,

            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,

            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,

            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,

            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,

            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,

            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,

            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,

            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,

            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,

            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,

            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,

            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,

            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,

            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10

        ];



        // Reserve memory space for our hashes.

        bytes memory buf = new bytes(64);



        // We'll need to keep track of left and right siblings.

        bytes32 leftSibling;

        bytes32 rightSibling;



        // Number of non-empty nodes at the current depth.

        uint256 rowSize = _elements.length;



        // Current depth, counting from 0 at the leaves

        uint256 depth = 0;



        // Common sub-expressions

        uint256 halfRowSize; // rowSize / 2

        bool rowSizeIsOdd; // rowSize % 2 == 1



        while (rowSize > 1) {

            halfRowSize = rowSize / 2;

            rowSizeIsOdd = rowSize % 2 == 1;



            for (uint256 i = 0; i < halfRowSize; i++) {

                leftSibling = _elements[(2 * i)];

                rightSibling = _elements[(2 * i) + 1];

                assembly {

                    mstore(add(buf, 32), leftSibling)

                    mstore(add(buf, 64), rightSibling)

                }



                _elements[i] = keccak256(buf);

            }



            if (rowSizeIsOdd) {

                leftSibling = _elements[rowSize - 1];

                rightSibling = bytes32(defaults[depth]);

                assembly {

                    mstore(add(buf, 32), leftSibling)

                    mstore(add(buf, 64), rightSibling)

                }



                _elements[halfRowSize] = keccak256(buf);

            }



            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);

            depth++;

        }



        return _elements[0];

    }



    /**

     * Verifies a merkle branch for the given leaf hash.  Assumes the original length

     * of leaves generated is a known, correct input, and does not return true for indices

     * extending past that index (even if _siblings would be otherwise valid.)

     * @param _root The Merkle root to verify against.

     * @param _leaf The leaf hash to verify inclusion of.

     * @param _index The index in the tree of this leaf.

     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0

     * (bottom of the tree).

     * @param _totalLeaves The total number of leaves originally passed into.

     * @return Whether or not the merkle branch and leaf passes verification.

     */

    function verify(

        bytes32 _root,

        bytes32 _leaf,

        uint256 _index,

        bytes32[] memory _siblings,

        uint256 _totalLeaves

    ) internal pure returns (bool) {

        require(_totalLeaves > 0, "Lib_MerkleTree: Total leaves must be greater than zero.");



        require(_index < _totalLeaves, "Lib_MerkleTree: Index out of bounds.");



        require(

            _siblings.length == _ceilLog2(_totalLeaves),

            "Lib_MerkleTree: Total siblings does not correctly correspond to total leaves."

        );



        bytes32 computedRoot = _leaf;



        for (uint256 i = 0; i < _siblings.length; i++) {

            if ((_index & 1) == 1) {

                computedRoot = keccak256(abi.encodePacked(_siblings[i], computedRoot));

            } else {

                computedRoot = keccak256(abi.encodePacked(computedRoot, _siblings[i]));

            }



            _index >>= 1;

        }



        return _root == computedRoot;

    }



    /*********************

     * Private Functions *

     *********************/



    /**

     * Calculates the integer ceiling of the log base 2 of an input.

     * @param _in Unsigned input to calculate the log.

     * @return ceil(log_base_2(_in))

     */

    function _ceilLog2(uint256 _in) private pure returns (uint256) {

        require(_in > 0, "Lib_MerkleTree: Cannot compute ceil(log_2) of 0.");



        if (_in == 1) {

            return 0;

        }



        // Find the highest set bit (will be floor(log_2)).

        // Borrowed with <3 from https://github.com/ethereum/solidity-examples

        uint256 val = _in;

        uint256 highest = 0;

        for (uint256 i = 128; i >= 1; i >>= 1) {

            if (val & (((uint256(1) << i) - 1) << i) != 0) {

                highest += i;

                val >>= i;

            }

        }



        // Increment by one if this is not a perfect logarithm.

        if ((uint256(1) << highest) != _in) {

            highest += 1;

        }



        return highest;

    }

}





// File contracts/L1/rollup/IChainStorageContainer.sol



//   MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title IChainStorageContainer

 */

interface IChainStorageContainer {

    /********************

     * Public Functions *

     ********************/



    /**

     * Sets the container's global metadata field. We're using `bytes27` here because we use five

     * bytes to maintain the length of the underlying data structure, meaning we have an extra

     * 27 bytes to store arbitrary data.

     * @param _globalMetadata New global metadata to set.

     */

    function setGlobalMetadata(bytes27 _globalMetadata) external;



    /**

     * Retrieves the container's global metadata field.

     * @return Container global metadata field.

     */

    function getGlobalMetadata() external view returns (bytes27);



    /**

     * Retrieves the number of objects stored in the container.

     * @return Number of objects in the container.

     */

    function length() external view returns (uint256);



    /**

     * Pushes an object into the container.

     * @param _object A 32 byte value to insert into the container.

     */

    function push(bytes32 _object) external;



    /**

     * Pushes an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _object A 32 byte value to insert into the container.

     * @param _globalMetadata New global metadata for the container.

     */

    function push(bytes32 _object, bytes27 _globalMetadata) external;



    /**

     * Set an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _index position.

     * @param _object A 32 byte value to insert into the container.

     */  

    function setByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes32 _object

    )

        external;

        

    /**

     * Retrieves an object from the container.

     * @param _index Index of the particular object to access.

     * @return 32 byte object value.

     */

    function get(uint256 _index) external view returns (bytes32);



    /**

     * Removes all objects after and including a given index.

     * @param _index Object index to delete from.

     */

    function deleteElementsAfterInclusive(uint256 _index) external;



    /**

     * Removes all objects after and including a given index. Also allows setting the global

     * metadata field.

     * @param _index Object index to delete from.

     * @param _globalMetadata New global metadata for the container.

     */

    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;



    /**

     * Sets the container's global metadata field. We're using `bytes27` here because we use five

     * bytes to maintain the length of the underlying data structure, meaning we have an extra

     * 27 bytes to store arbitrary data.

     * @param _chainId identity for the l2 chain.

     * @param _globalMetadata New global metadata to set.

     */

    function setGlobalMetadataByChainId(

        uint256 _chainId,

        bytes27 _globalMetadata

    )

        external;



    /**

     * Retrieves the container's global metadata field.

     * @param _chainId identity for the l2 chain.

     * @return Container global metadata field.

     */

    function getGlobalMetadataByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            bytes27

        );



    /**

     * Retrieves the number of objects stored in the container.

     * @param _chainId identity for the l2 chain.

     * @return Number of objects in the container.

     */

    function lengthByChainId(

        uint256 _chainId

        )

        external

        view

        returns (

            uint256

        );



    /**

     * Pushes an object into the container.

     * @param _chainId identity for the l2 chain.

     * @param _object A 32 byte value to insert into the container.

     */

    function pushByChainId(

        uint256 _chainId,

        bytes32 _object

    )

        external;



    /**

     * Pushes an object into the container. Function allows setting the global metadata since

     * we'll need to touch the "length" storage slot anyway, which also contains the global

     * metadata (it's an optimization).

     * @param _chainId identity for the l2 chain.

     * @param _object A 32 byte value to insert into the container.

     * @param _globalMetadata New global metadata for the container.

     */

    function pushByChainId(

        uint256 _chainId,

        bytes32 _object,

        bytes27 _globalMetadata

    )

        external;



    /**

     * Retrieves an object from the container.

     * @param _chainId identity for the l2 chain.

     * @param _index Index of the particular object to access.

     * @return 32 byte object value.

     */

    function getByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external

        view

        returns (

            bytes32

        );



    /**

     * Removes all objects after and including a given index.

     * @param _chainId identity for the l2 chain.

     * @param _index Object index to delete from.

     */

    function deleteElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index

    )

        external;

        

    /**

     * Removes all objects after and including a given index. Also allows setting the global

     * metadata field.

     * @param _chainId identity for the l2 chain.

     * @param _index Object index to delete from.

     * @param _globalMetadata New global metadata for the container.

     */

    function deleteElementsAfterInclusiveByChainId(

        uint256 _chainId,

        uint256 _index,

        bytes27 _globalMetadata

    )

        external;

        

}





// File contracts/L1/rollup/IStateCommitmentChain.sol



//   MIT

pragma solidity >0.5.0 <0.9.0;



/* Library Imports */





/**

 * @title IStateCommitmentChain

 */

interface IStateCommitmentChain {

    /**********

     * Events *

     **********/



    event StateBatchAppended(

        uint256 _chainId,

        uint256 indexed _batchIndex,

        bytes32 _batchRoot,

        uint256 _batchSize,

        uint256 _prevTotalElements,

        bytes _extraData

    );



    event StateBatchDeleted(

        uint256 _chainId,

        uint256 indexed _batchIndex,

        bytes32 _batchRoot

    );





    /********************

     * Public Functions *

     ********************/

    

    function batches() external view returns (IChainStorageContainer);

    

    /**

     * Retrieves the total number of elements submitted.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElements() external view returns (uint256 _totalElements);



    /**

     * Retrieves the total number of batches submitted.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatches() external view returns (uint256 _totalBatches);



    /**

     * Retrieves the timestamp of the last batch submitted by the sequencer.

     * @return _lastSequencerTimestamp Last sequencer batch timestamp.

     */

    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);



    /**

     * Appends a batch of state roots to the chain.

     * @param _batch Batch of state roots.

     * @param _shouldStartAtElement Index of the element at which this batch should start.

     */

    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;



    /**

     * Deletes all state roots after (and including) a given batch.

     * @param _batchHeader Header of the batch to start deleting from.

     */

    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) external;



    /**

     * Verifies a batch inclusion proof.

     * @param _element Hash of the element to verify a proof for.

     * @param _batchHeader Header of the batch in which the element was included.

     * @param _proof Merkle inclusion proof for the element.

     */

    function verifyStateCommitment(

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    ) external view returns (bool _verified);



    /**

     * Checks whether a given batch is still inside its fraud proof window.

     * @param _batchHeader Header of the batch to check.

     * @return _inside Whether or not the batch is inside the fraud proof window.

     */

    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)

        external

        view

        returns (

            bool _inside

        );

        

        

        

     /********************

     * chain id added func *

     ********************/



    /**

     * Retrieves the total number of elements submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalElements Total submitted elements.

     */

    function getTotalElementsByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256 _totalElements

        );



    /**

     * Retrieves the total number of batches submitted.

     * @param _chainId identity for the l2 chain.

     * @return _totalBatches Total submitted batches.

     */

    function getTotalBatchesByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256 _totalBatches

        );



    /**

     * Retrieves the timestamp of the last batch submitted by the sequencer.

     * @param _chainId identity for the l2 chain.

     * @return _lastSequencerTimestamp Last sequencer batch timestamp.

     */

    function getLastSequencerTimestampByChainId(uint256 _chainId)

        external

        view

        returns (

            uint256 _lastSequencerTimestamp

        );

        

    /**

     * Appends a batch of state roots to the chain.

     * @param _chainId identity for the l2 chain.

     * @param _batch Batch of state roots.

     * @param _shouldStartAtElement Index of the element at which this batch should start.

     */

    function appendStateBatchByChainId(

        uint256 _chainId,

        bytes32[] calldata _batch,

        uint256 _shouldStartAtElement,

        string calldata proposer

    )

        external;



    /**

     * Deletes all state roots after (and including) a given batch.

     * @param _chainId identity for the l2 chain.

     * @param _batchHeader Header of the batch to start deleting from.

     */

    function deleteStateBatchByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        external;



    /**

     * Verifies a batch inclusion proof.

     * @param _chainId identity for the l2 chain.

     * @param _element Hash of the element to verify a proof for.

     * @param _batchHeader Header of the batch in which the element was included.

     * @param _proof Merkle inclusion proof for the element.

     */

    function verifyStateCommitmentByChainId(

        uint256 _chainId,

        bytes32 _element,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,

        Lib_OVMCodec.ChainInclusionProof memory _proof

    )

        external

        view

        returns (

            bool _verified

        );



    /**

     * Checks whether a given batch is still inside its fraud proof window.

     * @param _chainId identity for the l2 chain.

     * @param _batchHeader Header of the batch to check.

     * @return _inside Whether or not the batch is inside the fraud proof window.

     */

    function insideFraudProofWindowByChainId(

        uint256 _chainId,

        Lib_OVMCodec.ChainBatchHeader memory _batchHeader

    )

        external

        view

        returns (

            bool _inside

        );

}





// File contracts/MVM/MVM_Verifier.sol



//   MIT

pragma solidity ^0.8.9;

/* Contract Imports */

/* External Imports */















contract MVM_Verifier is Lib_AddressResolver{

    // second slot

    address public metis;



    enum SETTLEMENT {NOT_ENOUGH_VERIFIER, SAME_ROOT, AGREE, DISAGREE, PASS}



    event NewChallenge(uint256 cIndex, uint256 chainID, Lib_OVMCodec.ChainBatchHeader header, uint256 timestamp);

    event Verify1(uint256 cIndex, address verifier);

    event Verify2(uint256 cIndex, address verifier);

    event Finalize(uint256 cIndex, address sender, SETTLEMENT result);

    event Penalize(address sender, uint256 stakeLost);

    event Reward(address target, uint256 amount);

    event Claim(address sender, uint256 amount);

    event Withdraw(address sender, uint256 amount);

    event Stake(address verifier, uint256 amount);

    event SlashSequencer(uint256 chainID, address seq);



    /*************

     * Constants *

     *************/

    string constant public CONFIG_OWNER_KEY = "METIS_MANAGER";



    //challenge info

    struct Challenge {

       address challenger;

       uint256 chainID;

       uint256 index;

       Lib_OVMCodec.ChainBatchHeader header;

       uint256 timestamp;

       uint256 numQualifiedVerifiers;

       uint256 numVerifiers;

       address[] verifiers;

       bool done;

    }



    mapping (address => uint256) public verifier_stakes;

    mapping (uint256 => mapping (address=>bytes)) private challenge_keys;

    mapping (uint256 => mapping (address=>bytes)) private challenge_key_hashes;

    mapping (uint256 => mapping (address=>bytes)) private challenge_hashes;



    mapping (address => uint256) public rewards;

    mapping (address => uint8) public absence_strikes;

    mapping (address => uint8) public consensus_strikes;



    // only one active challenge for each chain  chainid=>cIndex

    mapping (uint256 => uint256) public chain_under_challenge;



    // white list

    mapping (address => bool) public whitelist;

    bool useWhiteList;



    address[] public verifiers;

    Challenge[] public challenges;



    uint public verifyWindow = 3600 * 24; // 24 hours of window to complete the each verify phase

    uint public activeChallenges;



    uint256 public minStake;

    uint256 public seqStake;



    uint256 public numQualifiedVerifiers;



    uint FAIL_THRESHOLD = 2;  // 1 time grace

    uint ABSENCE_THRESHOLD = 4;  // 2 times grace



    modifier onlyManager {

        require(

            msg.sender == resolve(CONFIG_OWNER_KEY),

            "MVM_Verifier: Function can only be called by the METIS_MANAGER."

        );

        _;

    }



    modifier onlyWhitelisted {

        require(isWhiteListed(msg.sender), "only whitelisted verifiers can call");

        _;

    }



    modifier onlyStaked {

        require(isSufficientlyStaked(msg.sender), "insufficient stake");

        _;

    }



    constructor(

    )

      Lib_AddressResolver(address(0))

    {

    }



    // add stake as a verifier

    function verifierStake(uint256 stake) public onlyWhitelisted{

       require(activeChallenges == 0, "stake is currently prohibited"); //ongoing challenge

       require(stake > 0, "zero stake not allowed");

       require(IERC20(metis).transferFrom(msg.sender, address(this), stake), "transfer metis failed");



       uint256 previousBalance = verifier_stakes[msg.sender];

       verifier_stakes[msg.sender] += stake;



       require(isSufficientlyStaked(msg.sender), "insufficient stake to qualify as a verifier");



       if (previousBalance == 0) {

          numQualifiedVerifiers++;

          verifiers.push(msg.sender);

       }



       emit Stake(msg.sender, stake);

    }



    // start a new challenge

    // @param chainID chainid

    // @param header chainbatch header

    // @param proposedHash encrypted hash of the correct state

    // @param keyhash hash of the decryption key

    //

    // @dev why do we ask for key and keyhash? because we want verifiers compute the state instead

    // of just copying from other verifiers.

    function newChallenge(uint256 chainID, Lib_OVMCodec.ChainBatchHeader calldata header, bytes calldata proposedHash, bytes calldata keyhash)

       public onlyWhitelisted onlyStaked {



       uint tempIndex = chain_under_challenge[chainID] - 1;

       require(tempIndex == 0 || block.timestamp - challenges[tempIndex].timestamp > verifyWindow * 2, "there is an ongoing challenge");

       if (tempIndex > 0) {

          finalize(tempIndex);

       }

       IStateCommitmentChain stateChain = IStateCommitmentChain(resolve("StateCommitmentChain"));



       // while the root is encrypted, the timestamp is available in the extradata field of the header

       require(stateChain.insideFraudProofWindow(header), "the batch is outside of the fraud proof window");



       Challenge memory c;

       c.chainID = chainID;

       c.challenger = msg.sender;

       c.timestamp = block.timestamp;

       c.header = header;



       challenges.push(c);

       uint cIndex = challenges.length - 1;



       // house keeping

       challenge_hashes[cIndex][msg.sender] = proposedHash;

       challenge_key_hashes[cIndex][msg.sender] = keyhash;

       challenges[cIndex].numVerifiers++; // the challenger



       // this will prevent stake change

       activeChallenges++;



       chain_under_challenge[chainID] = cIndex + 1; // +1 because 0 means no in-progress challenge

       emit NewChallenge(cIndex, chainID, header, block.timestamp);

    }



    // phase 1 of the verify, provide an encrypted hash and the hash of the decryption key

    // @param cIndex index of the challenge

    // @param hash encrypted hash of the correct state (for the index referred in the challenge)

    // @param keyhash hash of the decryption key

    function verify1(uint256 cIndex, bytes calldata hash, bytes calldata keyhash) public onlyWhitelisted onlyStaked{

       require(challenge_hashes[cIndex][msg.sender].length == 0, "verify1 already completed for the sender");

       challenge_hashes[cIndex][msg.sender] = hash;

       challenge_key_hashes[cIndex][msg.sender] = keyhash;

       challenges[cIndex].numVerifiers++;

       emit Verify1(cIndex, msg.sender);

    }



    // phase 2 of the verify, provide the actual key to decrypt the hash

    // @param cIndex index of the challenge

    // @param key the decryption key

    function verify2(uint256 cIndex, bytes calldata key) public onlyStaked onlyWhitelisted{

        require(challenges[cIndex].numVerifiers == numQualifiedVerifiers

               || block.timestamp - challenges[cIndex].timestamp > verifyWindow, "phase 2 not ready");

        require(challenge_hashes[cIndex][msg.sender].length > 0, "you didn't participate in phase 1");

        if (challenge_keys[cIndex][msg.sender].length > 0) {

            finalize(cIndex);

            return;

        }



        //verify whether the key matches the keyhash initially provided.

        require(sha256(key) == bytes32(challenge_key_hashes[cIndex][msg.sender]), "key and keyhash don't match");



        if (msg.sender == challenges[cIndex].challenger) {

            //decode the root in the header too

            challenges[cIndex].header.batchRoot = bytes32(decrypt(abi.encodePacked(challenges[cIndex].header.batchRoot), key));

        }

        challenge_keys[cIndex][msg.sender] = key;

        challenge_hashes[cIndex][msg.sender] = decrypt(challenge_hashes[cIndex][msg.sender], key);

        challenges[cIndex].verifiers.push(msg.sender);

        emit Verify2(cIndex, msg.sender);



        finalize(cIndex);

    }



    function finalize(uint256 cIndex) internal {



        Challenge storage challenge = challenges[cIndex];



        require(challenge.done == false, "challenge is closed");



        if (challenge.verifiers.length != challenge.numVerifiers

           && block.timestamp - challenge.timestamp < verifyWindow * 2) {

           // not ready to finalize. do nothing

           return;

        }



        IStateCommitmentChain stateChain = IStateCommitmentChain(resolve("StateCommitmentChain"));

        bytes32 proposedHash = bytes32(challenge_hashes[cIndex][challenge.challenger]);



        uint reward = 0;



        address[] memory agrees = new address[](challenge.verifiers.length);

        uint numAgrees = 0;

        address[] memory disagrees = new address[](challenge.verifiers.length);

        uint numDisagrees = 0;



        for (uint256 i = 0; i < verifiers.length; i++) {

            if (!isSufficientlyStaked(verifiers[i]) || !isWhiteListed(verifiers[i])) {

                // not qualified as a verifier

                continue;

            }



            //record the agreement

            if (bytes32(challenge_hashes[cIndex][verifiers[i]]) == proposedHash) {

                //agree with the challenger

                if (absence_strikes[verifiers[i]] > 0) {

                    absence_strikes[verifiers[i]] -= 1; // slowly clear the strike

                }

                agrees[numAgrees] = verifiers[i];

                numAgrees++;

            } else if (challenge_keys[cIndex][verifiers[i]].length == 0) {

                //absent

                absence_strikes[verifiers[i]] += 2;

                if (absence_strikes[verifiers[i]] > ABSENCE_THRESHOLD) {

                    reward += penalize(verifiers[i]);

                }

            } else {

                //disagree with the challenger

                if (absence_strikes[verifiers[i]] > 0) {

                    absence_strikes[verifiers[i]] -= 1; // slowly clear the strike

                }

                disagrees[numDisagrees] = verifiers[i];

                numDisagrees++;

            }

        }



        if (Lib_OVMCodec.hashBatchHeader(challenge.header) !=

                stateChain.batches().getByChainId(challenge.chainID, challenge.header.batchIndex)) {

            // wrong header, penalize the challenger

            reward += penalize(challenge.challenger);



            // reward the disagrees. but no penalty on agrees because the input

            // is garbage.

            distributeReward(reward, disagrees, challenge.verifiers.length - 1);

            emit Finalize(cIndex, msg.sender, SETTLEMENT.DISAGREE);



        } else if (challenge.verifiers.length < numQualifiedVerifiers * 75 / 100) {

            // the absent verifiers get a absense strike. no other penalties. already done

            emit Finalize(cIndex, msg.sender, SETTLEMENT.NOT_ENOUGH_VERIFIER);

        }

        else if (proposedHash != challenge.header.batchRoot) {

            if (numAgrees <= numDisagrees) {

               // no consensus, challenge failed.

               for (uint i = 0; i < numAgrees; i++) {

                    consensus_strikes[agrees[i]] += 2;

                    if (consensus_strikes[agrees[i]] > FAIL_THRESHOLD) {

                        reward += penalize(agrees[i]);

                    }

               }

               distributeReward(reward, disagrees, disagrees.length);

               emit Finalize(cIndex, msg.sender, SETTLEMENT.DISAGREE);

            } else {

               // reached agreement. delete the batch root and slash the sequencer if the header is still valid

               if(stateChain.insideFraudProofWindow(challenge.header)) {

                    // this header needs to be within the window

                    stateChain.deleteStateBatchByChainId(challenge.chainID, challenge.header);



                    // temporary for the p1 of the decentralization roadmap

                    if (seqStake > 0) {

                        reward += seqStake;



                        for (uint i = 0; i < numDisagrees; i++) {

                            consensus_strikes[disagrees[i]] += 2;

                            if (consensus_strikes[disagrees[i]] > FAIL_THRESHOLD) {

                                reward += penalize(disagrees[i]);

                            }

                        }

                        distributeReward(reward, agrees, agrees.length);

                    }

                    emit Finalize(cIndex, msg.sender, SETTLEMENT.AGREE);

                } else {

                    //not in the window anymore. let it pass... no penalty

                    emit Finalize(cIndex, msg.sender, SETTLEMENT.PASS);

                }

            }

        } else {

            //wasteful challenge, add consensus_strikes to the challenger

            consensus_strikes[challenge.challenger] += 2;

            if (consensus_strikes[challenge.challenger] > FAIL_THRESHOLD) {

                reward += penalize(challenge.challenger);

            }

            distributeReward(reward, challenge.verifiers, challenge.verifiers.length - 1);

            emit Finalize(cIndex, msg.sender, SETTLEMENT.SAME_ROOT);

        }



        challenge.done = true;

        activeChallenges--;

        chain_under_challenge[challenge.chainID] = 0;

    }



    function depositSeqStake(uint256 amount) public onlyManager {

        require(IERC20(metis).transferFrom(msg.sender, address(this), amount), "transfer metis failed");

        seqStake += amount;

        emit Stake(msg.sender, amount);

    }



    function withdrawSeqStake(address to) public onlyManager {

        require(seqStake > 0, "no stake");

        emit Withdraw(msg.sender, seqStake);

        uint256 amount = seqStake;

        seqStake = 0;



        require(IERC20(metis).transfer(to, amount), "transfer metis failed");

    }



    function claim() public {

       require(rewards[msg.sender] > 0, "no reward to claim");

       uint256 amount = rewards[msg.sender];

       rewards[msg.sender] = 0;



       require(IERC20(metis).transfer(msg.sender, amount), "token transfer failed");



       emit Claim(msg.sender, amount);

    }



    function withdraw(uint256 amount) public {

       require(activeChallenges == 0, "withdraw is currently prohibited"); //ongoing challenge



       uint256 balance = verifier_stakes[msg.sender];

       require(balance >= amount, "insufficient stake to withdraw");



       if (balance - amount < minStake && balance >= minStake) {

           numQualifiedVerifiers--;

           deleteVerifier(msg.sender);

       }

       verifier_stakes[msg.sender] -= amount;



       require(IERC20(metis).transfer(msg.sender, amount), "token transfer failed");

    }



    function setMinStake(

        uint256 _minStake

    )

        public

        onlyManager

    {

        minStake = _minStake;

        uint num = 0;

        if (verifiers.length > 0) {

            address[] memory arr = new address[](verifiers.length);

            for (uint i = 0; i < verifiers.length; ++i) {

                if (verifier_stakes[verifiers[i]] >= minStake) {

                    arr[num] = verifiers[i];

                    num++;

                }

            }

            if (num < verifiers.length) {

                delete verifiers;

                for (uint i = 0; i < num; i++) {

                    verifiers.push(arr[i]);

                }

            }

        }

        numQualifiedVerifiers = num;

    }



    // helper

    function isWhiteListed(address verifier) view public returns(bool){

        return !useWhiteList || whitelist[verifier];

    }

    function isSufficientlyStaked (address target) view public returns(bool) {

       return (verifier_stakes[target] >= minStake);

    }



    // set the length of the time windows for each verification phase

    function setVerifyWindow (uint256 window) onlyManager public {

        verifyWindow = window;

    }



    // add the verifier to the whitelist

    function setWhiteList(address verifier, bool allowed) public onlyManager {

        whitelist[verifier] = allowed;

        useWhiteList = true;

    }



    // allow everyone to be the verifier

    function disableWhiteList() public onlyManager {

        useWhiteList = false;

    }



    function setThreshold(uint absence_threshold, uint fail_threshold) public onlyManager {

        ABSENCE_THRESHOLD = absence_threshold;

        FAIL_THRESHOLD = fail_threshold;

    }



    function getMerkleRoot(bytes32[] calldata elements) pure public returns (bytes32) {

        return Lib_MerkleTree.getMerkleRoot(elements);

    }



    //helper fucntion to encrypt data

    function encrypt(bytes calldata data, bytes calldata key) pure public returns (bytes memory) {

      bytes memory encryptedData = data;

      uint j = 0;



      for (uint i = 0; i < encryptedData.length; i++) {

          if (j == key.length) {

             j = 0;

          }

          encryptedData[i] = encryptByte(encryptedData[i], uint8(key[j]));

          j++;

      }



      return encryptedData;

    }



    function encryptByte(bytes1 b, uint8 k) pure internal returns (bytes1) {

      uint16 temp16 = uint16(uint8(b));

      temp16 += k;



      if (temp16 > 255) {

         temp16 -= 256;

      }

      return bytes1(uint8(temp16));

    }



    // helper fucntion to decrypt the data

    function decrypt(bytes memory data, bytes memory key) pure public returns (bytes memory) {

      bytes memory decryptedData = data;

      uint j = 0;



      for (uint i = 0; i < decryptedData.length; i++) {

          if (j == key.length) {

             j = 0;

          }



          decryptedData[i] = decryptByte(decryptedData[i], uint8(key[j]));



          j++;

      }



      return decryptedData;

    }



    function decryptByte(bytes1 b, uint8 k) pure internal returns (bytes1) {

      uint16 temp16 = uint16(uint8(b));

      if (temp16 > k) {

         temp16 -= k;

      } else {

         temp16 = 256 - k;

      }



      return bytes1(uint8(temp16));

    }



    // calculate the rewards

    function distributeReward(uint256 amount, address[] memory list, uint num) internal {

        uint reward = amount / num;

        if (reward == 0) {

            return;

        }

        uint total = 0;

        for (uint i; i < list.length; i++) {

            if (isSufficientlyStaked(list[i])) {

               rewards[list[i]] += reward;

               total += reward;

               emit Reward(list[i], reward);

            }

        }



        if (total < amount) {

            if (isSufficientlyStaked(list[0])) {

                rewards[list[0]] += total - amount;

                emit Reward(list[0], total - amount);

            } else {

                rewards[list[1]] += total - amount;

                emit Reward(list[1], total - amount);

            }

        }

    }



    // slash the verifier stake

    function penalize(address target) internal returns(uint256) {

        uint256 stake = verifier_stakes[target];

        verifier_stakes[target] = 0;

        numQualifiedVerifiers--;

        deleteVerifier(target);

        emit Penalize(target, stake);



        return stake;

    }



    function deleteVerifier(address target) internal {

        bool hasVerifier = false;

        uint pos = 0;

        for (uint i = 0; i < verifiers.length; i++){

            if (verifiers[i] == target) {

                hasVerifier = true;

                pos = i;

                break;

            }

        }

        if (hasVerifier) {

            for (uint i = pos; i < verifiers.length-1; i++) {

                verifiers[i] = verifiers[i+1];

            }

            verifiers.pop();

        }

    }



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\OVM_GasPriceOracle.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



/* External Imports */



import { iOVM_SequencerFeeVault } from "./iOVM_SequencerFeeVault.sol";

import { Lib_PredeployAddresses } from "../../libraries/constants/Lib_PredeployAddresses.sol";



/**

 * @title OVM_GasPriceOracle

 * @dev This contract exposes the current l2 gas price, a measure of how congested the network

 * currently is. This measure is used by the Sequencer to determine what fee to charge for

 * transactions. When the system is more congested, the l2 gas price will increase and fees

 * will also increase as a result.

 *

 * All public variables are set while generating the initial L2 state. The

 * constructor doesn't run in practice as the L2 state generation script uses

 * the deployed bytecode instead of running the initcode.

 */

contract OVM_GasPriceOracle {

    /*************

     * Variables *

     *************/

    address public owner;

    // Current L2 gas price

    uint256 public gasPrice;

    // Current L1 base fee

    uint256 public l1BaseFee;

    // Amortized cost of batch submission per transaction

    uint256 public overhead;

    // Value to scale the fee up by

    uint256 public scalar;

    // Number of decimals of the scalar

    uint256 public decimals;

    

    // minimum gas to bridge the asset back to l1

    uint256 public minErc20BridgeCost;

    

    

    /**********************

     * Function Modifiers *

     **********************/



    /**

     * Blocks functions to anyone except the contract owner.

     */

    modifier onlyOwner() {

        require(msg.sender == owner, "Function can only be called by the owner of this contract.");

        _;

    }

    

    modifier onlyManager() {

        require(msg.sender == iOVM_SequencerFeeVault(Lib_PredeployAddresses.SEQUENCER_FEE_WALLET).getL2Manager(),

                "Function can only be called by the l2manager.");

        _;

    }

    



    /***************

     * Constructor *

     ***************/



    /**

     * @param _owner Address that will initially own this contract.

     */

    constructor(address _owner) {

        owner = _owner;

    }



    /**********

     * Events *

     **********/



    event GasPriceUpdated(uint256);

    event L1BaseFeeUpdated(uint256);

    event OverheadUpdated(uint256);

    event ScalarUpdated(uint256);

    event DecimalsUpdated(uint256);

    event MinErc20BridgeCostUpdated(uint256);

    event OwnerChanged(address oldOwner, address newOwner);



    /********************

     * Public Functions *

     ********************/

    /**

     * Updates the owner of this contract.

     * @param _owner Address of the new owner.

     */

    function setOwner(address _owner) public onlyManager {

        emit OwnerChanged(owner, _owner);

        owner = _owner;

    }

    

    /**

     * Allows the owner to modify the l2 gas price.

     * @param _gasPrice New l2 gas price.

     */

    function setGasPrice(uint256 _gasPrice) public onlyOwner {

        gasPrice = _gasPrice;

        emit GasPriceUpdated(_gasPrice);

    }

    

    /**

     * Allows the owner to modify the l1 bridge price.

     * @param _minCost New l2 gas price.

     */

    function setMinErc20BridgeCost(uint256 _minCost) public onlyOwner {

        minErc20BridgeCost = _minCost;

        emit MinErc20BridgeCostUpdated(_minCost);

    }



    /**

     * Allows the owner to modify the l1 base fee.

     * @param _baseFee New l1 base fee

     */

    function setL1BaseFee(uint256 _baseFee) public onlyOwner {

        require(_baseFee < l1BaseFee * 105 / 100, "increase is capped at 5%");

        l1BaseFee = _baseFee;

        emit L1BaseFeeUpdated(_baseFee);

    }



    /**

     * Allows the owner to modify the overhead.

     * @param _overhead New overhead

     */

    function setOverhead(uint256 _overhead) public onlyOwner {

        require(_overhead < overhead * 105 / 100, "increase is capped at 5%");

        overhead = _overhead;

        emit OverheadUpdated(_overhead);

    }



    /**

     * Allows the owner to modify the scalar.

     * @param _scalar New scalar

     */

    function setScalar(uint256 _scalar) public onlyOwner {

        require(_scalar < scalar * 105 / 100, "increase is capped at 5%");

        scalar = _scalar;

        emit ScalarUpdated(_scalar);

    }



    /**

     * Allows the owner to modify the decimals.

     * For maximum safety, this method should only be called when there is no active tx

     * @param _decimals New decimals

     */

    function setDecimals(uint256 _decimals) public onlyOwner {

        decimals = _decimals;

        emit DecimalsUpdated(_decimals);

    }



    /**

     * Computes the L1 portion of the fee

     * based on the size of the RLP encoded tx

     * and the current l1BaseFee

     * @param _data Unsigned RLP encoded tx, 6 elements

     * @return L1 fee that should be paid for the tx

     */

    function getL1Fee(bytes memory _data) public view returns (uint256) {

        uint256 l1GasUsed = getL1GasUsed(_data);

        uint256 l1Fee = l1GasUsed * l1BaseFee;

        uint256 divisor = 10**decimals;

        uint256 unscaled = l1Fee * scalar;

        uint256 scaled = unscaled / divisor;

        return scaled;

    }



    // solhint-disable max-line-length

    /**

     * Computes the amount of L1 gas used for a transaction

     * The overhead represents the per batch gas overhead of

     * posting both transaction and state roots to L1 given larger

     * batch sizes.

     * 4 gas for 0 byte

     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L33

     * 16 gas for non zero byte

     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L87

     * This will need to be updated if calldata gas prices change

     * Account for the transaction being unsigned

     * Padding is added to account for lack of signature on transaction

     * 1 byte for RLP V prefix

     * 1 byte for V

     * 1 byte for RLP R prefix

     * 32 bytes for R

     * 1 byte for RLP S prefix

     * 32 bytes for S

     * Total: 68 bytes of padding

     * @param _data Unsigned RLP encoded tx, 6 elements

     * @return Amount of L1 gas used for a transaction

     */

    // solhint-enable max-line-length

    function getL1GasUsed(bytes memory _data) public view returns (uint256) {

        uint256 total = 0;

        for (uint256 i = 0; i < _data.length; i++) {

            if (_data[i] == 0) {

                total += 4;

            } else {

                total += 16;

            }

        }

        uint256 unsigned = total + overhead;

        return unsigned + (68 * 16);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/Context.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _setOwner(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _setOwner(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _setOwner(newOwner);

    }



    function _setOwner(address newOwner) private {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\OwnableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/ContextUpgradeable.sol";

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    function __Ownable_init() internal initializer {

        __Context_init_unchained();

        __Ownable_init_unchained();

    }



    function __Ownable_init_unchained() internal initializer {

        _setOwner(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _setOwner(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _setOwner(newOwner);

    }



    function _setOwner(address newOwner) private {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\PausableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/ContextUpgradeable.sol";

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module which allows children to implement an emergency stop

 * mechanism that can be triggered by an authorized account.

 *

 * This module is used through inheritance. It will make available the

 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to

 * the functions of your contract. Note that they will not be pausable by

 * simply including this module, only once the modifiers are put in place.

 */

abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {

    /**

     * @dev Emitted when the pause is triggered by `account`.

     */

    event Paused(address account);



    /**

     * @dev Emitted when the pause is lifted by `account`.

     */

    event Unpaused(address account);



    bool private _paused;



    /**

     * @dev Initializes the contract in unpaused state.

     */

    function __Pausable_init() internal initializer {

        __Context_init_unchained();

        __Pausable_init_unchained();

    }



    function __Pausable_init_unchained() internal initializer {

        _paused = false;

    }



    /**

     * @dev Returns true if the contract is paused, and false otherwise.

     */

    function paused() public view virtual returns (bool) {

        return _paused;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is not paused.

     *

     * Requirements:

     *

     * - The contract must not be paused.

     */

    modifier whenNotPaused() {

        require(!paused(), "Pausable: paused");

        _;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is paused.

     *

     * Requirements:

     *

     * - The contract must be paused.

     */

    modifier whenPaused() {

        require(paused(), "Pausable: not paused");

        _;

    }



    /**

     * @dev Triggers stopped state.

     *

     * Requirements:

     *

     * - The contract must not be paused.

     */

    function _pause() internal virtual whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    /**

     * @dev Returns to normal state.

     *

     * Requirements:

     *

     * - The contract must be paused.

     */

    function _unpause() internal virtual whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\ReentrancyGuardUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * TIP: If you would like to learn more about reentrancy and alternative ways

 * to protect against it, check out our blog post

 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].

 */

abstract contract ReentrancyGuardUpgradeable is Initializable {

    // Booleans are more expensive than uint256 or any type that takes up a full

    // word because each write operation emits an extra SLOAD to first read the

    // slot's contents, replace the bits taken up by the boolean, and then write

    // back. This is the compiler's defense against contract upgrades and

    // pointer aliasing, and it cannot be disabled.



    // The values being non-zero value makes deployment a bit more expensive,

    // but in exchange the refund on every call to nonReentrant will be lower in

    // amount. Since refunds are capped to a percentage of the total

    // transaction's gas, it is best to keep them low in cases like this one, to

    // increase the likelihood of the full refund coming into effect.

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    uint256 private _status;



    function __ReentrancyGuard_init() internal initializer {

        __ReentrancyGuard_init_unchained();

    }



    function __ReentrancyGuard_init_unchained() internal initializer {

        _status = _NOT_ENTERED;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _status = _ENTERED;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _status = _NOT_ENTERED;

    }

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\Metis Bridge\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC20.sol";

import "../../../utils/Address.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender) + value;

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        unchecked {

            uint256 oldAllowance = token.allowance(address(this), spender);

            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");

            uint256 newAllowance = oldAllowance - value;

            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

        }

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {

            // Return data is optional

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------

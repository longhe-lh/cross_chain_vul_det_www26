{
    "src_chain": {
        "TokenMint1": [
            {
                "buyWanCoin": "function buyWanCoin(address receipient) \n public \n payable \n notHalted \n initialized \n ceilingNotReached \n notEarlierThan(earlyReserveBeginTime)\n earlierThan(endTime)\n returns (bool) \n {\n require(receipient != 0x0);\n require(msg.value >= 0.1 ether);\n \n function isContract(...) {...}\nfunction buyEarlyAdopters(...) {...}\nfunction buyNormal(...) {...}\nrequire(!isContract(msg.sender)); \n if( now < startTime && now >= earlyReserveBeginTime)\n buyEarlyAdopters(receipient);\n else {\n require( tx.gasprice <= 50000000000 wei );\n require(msg.value <= normalBuyLimit);\n buyNormal(receipient);\n }\n return true;\n }"
            },
            {
                "buyEarlyAdopters": "function buyEarlyAdopters(address receipient) internal {\n uint quotaAvailable = earlyUserQuotas[receipient];\n require(quotaAvailable > 0);\n uint toFund = quotaAvailable.min256(msg.value);\n uint tokenAvailable4Adopter = toFund.mul(PRICE_RATE_FIRST);\n function sub(...) {...}\nearlyUserQuotas[receipient] = earlyUserQuotas[receipient].sub(toFund);\n buyCommon(receipient, toFund, tokenAvailable4Adopter);\n }"
            },
            {
                "buyCommon": "function buyCommon(address receipient, uint toFund, uint wanTokenCollect) internal {\n require(msg.value >= toFund); \n if(toFund > 0) {\n function mintToken(...) {...}\nfunction transfer(...) {...}\nfunction add(...) {...}\nrequire(wanToken.mintToken(receipient, wanTokenCollect)); \n wanport.transfer(toFund);\n openSoldTokens = openSoldTokens.add(wanTokenCollect);\n NewSale(receipient, toFund, wanTokenCollect); \n }\n uint toReturn = msg.value.sub(toFund);\n if(toReturn > 0) {\n msg.sender.transfer(toReturn);\n }\n }"
            },
            {
                "buyNormal": "function buyNormal(address receipient) internal {\n uint inWhiteListTag = fullWhiteList[receipient];\n require(inWhiteListTag > 0);\n \n uint tokenAvailable = MAX_OPEN_SOLD.sub(openSoldTokens);\n require(tokenAvailable > 0);\n uint toFund;\n uint toCollect;\n (toFund, toCollect) = costAndBuyTokens(tokenAvailable);\n buyCommon(receipient, toFund, toCollect);\n }"
            }
        ],
        "TokenClaim2": []
    },
    "rel_chain": {},
    "det_chain": {
        "Transfer1": [
            {
                "transfer": "function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n \n \n \n \n if (balances[msg.sender] >= _value) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }"
            }
        ],
        "claimTokens2": [
            {
                "claimTokens": "function claimTokens(address receipent)\n public\n onlyMinter\n {\n function add(...) {...}\nbalances[receipent] = balances[receipent].add(lockedBalances[receipent]);\n lockedBalances[receipent] = 0;\n }"
            }
        ]
    }
}
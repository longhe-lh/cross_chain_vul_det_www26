Folder Structure
--------------------------------------------------
contracts/
    Address.sol
    AggregatorV3Interface.sol
    BalanceResolver.sol
    BalancesCounter.sol
    BaseChain.sol
    Blacklisted.sol
    Chain.sol
    ChainlinkV3PriceProvider.sol
    console.sol
    Context.sol
    DPoSCore.sol
    DPoSUmbRewards.sol
    ECDSA.sol
    EnumerableMap.sol
    EnumerableSet.sol
    ERC165.sol
    ERC20.sol
    ERC20Burnable.sol
    ERC20Mintable.sol
    ERC721.sol
    ERC721Burnable.sol
    ERC721Mintable.sol
    ForeignChain.sol
    ForeignGate.sol
    FullMath.sol
    HashStore.sol
    HomeGate.sol
    IBaseChainV1.sol
    IBurnableToken.sol
    IERC165.sol
    IERC20.sol
    IERC20LikeV2.sol
    IERC20Metadata.sol
    IERC721.sol
    IERC721Enumerable.sol
    IERC721Metadata.sol
    IERC721Receiver.sol
    IMigrationReceiver.sol
    IPriceProvider.sol
    IPriceProvidersRepository.sol
    IRegistry.sol
    IStakingBank.sol
    IStakingRewards.sol
    ISwapReceiver.sol
    IUniswapV3Pool.sol
    IUniswapV3PoolActions.sol
    IUniswapV3PoolDerivedState.sol
    IUniswapV3PoolEvents.sol
    IUniswapV3PoolImmutables.sol
    IUniswapV3PoolOwnerActions.sol
    IUniswapV3PoolState.sol
    LinearVesting.sol
    LockSettings.sol
    Math.sol
    MerkleProof.sol
    MintableToken.sol
    NFTRewards.sol
    OnDemandToken.sol
    OnDemandTokenBridgable.sol
    OperatorHub.sol
    OracleLibrary.sol
    Ownable.sol
    Owned.sol
    Pausable.sol
    Ping.sol
    PriceProvider.sol
    ReentrancyGuard.sol
    Registrable.sol
    Registry.sol
    RewardsDistributionRecipient.sol
    rUMB1.sol
    rUMB2.sol
    rUMBV2.sol
    SafeERC20.sol
    SafeMath.sol
    SampleERC20.sol
    SampleERC721.sol
    StakingBankState.sol
    StakingLens.sol
    StakingLockable.sol
    StakingRewards.sol
    StakingRewardsV2.sol
    Strings.sol
    SwappableTokenV2.sol
    TickMath.sol
    UMB.sol
    UmbMultiSig.sol
    UniswapV2LPTokenCounter.sol
    UniswapV3Helper.sol
    ValueDecoder.sol


File Contents
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\AggregatorV3Interface.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  // getRoundData and latestRoundData should both raise "No data present"
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\BalanceResolver.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import "@openzeppelin/contracts/V4/token/ERC20/IERC20.sol";

contract BalanceResolver {
    function balanceOf(IERC20 token, address[] memory addresses) external view returns (uint256[] memory balances) {
        balances = new uint256[](addresses.length);

        unchecked {
            for (uint i = 0; i < addresses.length; i++) {
                balances[i] = token.balanceOf(addresses[i]);
            }
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\BalancesCounter.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/// @dev Astro pool
interface IStakingLockable {
    struct Balance {
        // total supply of UMB = 500_000_000e18, it can be saved using 89bits, so we good with 96 and above
        // user UMB balance
        uint96 umbBalance;
        // amount locked + virtual balance generated using multiplier when locking
        uint96 lockedWithBonus;
        uint32 nextLockIndex;
        uint160 userRewardPerTokenPaid;
        uint96 rewards;
    }

    function balances(address _account) external view returns (Balance memory);
}

/// @dev helper contract for snapshot voting
/// sums up balance of users UMB tokens in different locations
/// For snapshot purposes it must follow ERC20 interface
contract BalancesCounter is ERC20, Ownable {
    // token which we want to track
    IERC20 public immutable mainToken;
    
    IStakingLockable public immutable astro;

    // token which we want to track
    IERC20[] public tokens;

    /// @param _mainToken token for which we calculating balances eg. UMB token
    /// @param _tokens list of contracts that has UMB tokens and returns balance per user when called for `balanceOf`
    /// @param _astro Astro contract (optional)
    constructor(IERC20 _mainToken, IERC20[] memory _tokens, IStakingLockable _astro)
        ERC20("BalancesCounter", "BalancesCounter")
    {
        // make sure we can access balance
        _mainToken.balanceOf(address(this));
        mainToken = _mainToken;

        for (uint256 i; i < _tokens.length; i++) {
            // make sure we can access balance
            _tokens[i].balanceOf(address(this));
        }

        tokens = _tokens;

        if (address(_astro) != address(0)) {
            // make sure we can access balances
            _astro.balances(address(this));
        }

        astro = _astro;
    }

    /// @dev add token to the list
    function addToken(IERC20 _token) external onlyOwner {
        // make sure we can access balance
        _token.balanceOf(address(this));
        tokens.push(_token);
    }

    /// @dev remove token from the list
    function removeToken(uint256 _id) external onlyOwner {
        uint256 lastId = tokens.length - 1;

        if (lastId != _id) {
            tokens[_id] = tokens[lastId];
        }

        tokens.pop();
    }

    function allTokens() external view returns (IERC20[] memory) {
        return tokens;
    }

    function astroUmbBalanceOf(address _account) public view returns (uint96 umbBalance) {
        if (address(astro) == address(0)) return 0;

        IStakingLockable.Balance memory balances = astro.balances(_account);
        return balances.umbBalance;
    }

    function totalSupply() public view override returns (uint256) {
        return mainToken.totalSupply();
    }

    /// @return total amount of UMB tokens for `_account` that is present in all defined `tokens` and in Astro pool
    function balanceOf(address _account) public view override returns (uint256 total) {
        total = astroUmbBalanceOf(_account);

        uint256 count = tokens.length;

        for (uint256 i; i < count; i++) {
            total += tokens[i].balanceOf(_account);
        }
    }

    function _beforeTokenTransfer(address, address, uint256) internal pure override {
        revert("this is oly view contract");
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\BaseChain.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol";

import "./interfaces/IBaseChainV1.sol";
import "./interfaces/IStakingBank.sol";
import "./extensions/Registrable.sol";
import "./Registry.sol";

abstract contract BaseChain is Registrable, Ownable {
    using ValueDecoder for bytes;
    using ValueDecoder for uint224;
    using MerkleProof for bytes32[];

    /// @param root merkle root for consensus
    /// @param dataTimestamp consensus timestamp
    struct Block {
        bytes32 root;
        uint32 dataTimestamp;
    }

    /// @param value FCD value
    /// @param dataTimestamp FCD timestamp
    struct FirstClassData {
        uint224 value;
        uint32 dataTimestamp;
    }

    /// @param blocksCountOffset number of all blocks that were generated before switching to this contract
    /// @param sequence is a total number of blocks (consensus rounds) including previous contracts
    /// @param lastTimestamp is a timestamp of last submitted block
    /// @param padding number of seconds that need to pass before new submit will be possible
    /// @param deprecated flag that changes to TRUE on `unregister`, when TRUE submissions are not longer available
    struct ConsensusData {
        uint32 blocksCountOffset;
        uint32 sequence;
        uint32 lastTimestamp;
        uint32 padding;
        bool deprecated;
    }

    uint256 constant public VERSION = 2;

    bool internal immutable _ALLOW_FOR_MIXED_TYPE; // solhint-disable-line var-name-mixedcase

    bytes4 constant private _VERSION_SELECTOR = bytes4(keccak256("VERSION()"));

    /// @dev minimal number of signatures required for accepting submission (PoA)
    uint16 internal immutable _REQUIRED_SIGNATURES; // solhint-disable-line var-name-mixedcase

    ConsensusData internal _consensusData;

    bytes constant public ETH_PREFIX = "\x19Ethereum Signed Message:\n32";

    /// @dev block id (consensus ID) => root
    /// consensus ID is at the same time consensus timestamp
    mapping(uint256 => bytes32) public roots;

    /// @dev FCD key => FCD data
    mapping(bytes32 => FirstClassData) public fcds;

    event LogDeprecation(address indexed deprecator);
    event LogPadding(address indexed executor, uint32 timePadding);

    error ArraysDataDoNotMatch();
    error AlreadyDeprecated();
    error AlreadyRegistered();
    error BlockSubmittedToFastOrDataToOld();
    error ContractNotReady();
    error FCDOverflow();
    error InvalidContractType();
    error NoChangeToState();
    error OnlyOwnerOrRegistry();
    error UnregisterFirst();

    modifier onlyOwnerOrRegistry () {
        if (msg.sender != address(contractRegistry) && msg.sender != owner()) revert OnlyOwnerOrRegistry();
        _;
    }

    /// @param _contractRegistry Registry address
    /// @param _padding required "space" between blocks in seconds
    /// @param _requiredSignatures number of required signatures for accepting consensus submission
    constructor(
        IRegistry _contractRegistry,
        uint32 _padding,
        uint16 _requiredSignatures,
        bool _allowForMixedType
    ) Registrable(_contractRegistry) {
        _ALLOW_FOR_MIXED_TYPE = _allowForMixedType;
        _REQUIRED_SIGNATURES = _requiredSignatures;

        _setPadding(_padding);

        BaseChain oldChain = BaseChain(_contractRegistry.getAddress("Chain"));

        if (address(oldChain) == address(0)) {
            // if this is first contract in sidechain, then we need to initialise lastTimestamp so submission
            // can be possible
            _consensusData.lastTimestamp = uint32(block.timestamp) - _padding - 1;
        }
    }

    /// @dev setter for `padding`
    function setPadding(uint16 _padding) external {
        _setPadding(_padding);
    }

    /// @notice if this method needs to be called manually (not from Registry)
    /// it is important to do it as part of tx batch
    /// eg using multisig, we should prepare set of transactions and confirm them all at once
    /// @inheritdoc Registrable
    function register() external override onlyOwnerOrRegistry {
        address oldChain = contractRegistry.getAddress("Chain");

        // registration must be done before address in registry is replaced
        if (oldChain == address(this)) revert AlreadyRegistered();

        if (oldChain == address(0x0)) {
            return;
        }

        _cloneLastDataFromPrevChain(oldChain);
    }

    /// @inheritdoc Registrable
    function unregister() external override onlyOwnerOrRegistry {
        // in case we deprecated contract manually, we simply return
        if (_consensusData.deprecated) return;

        address newChain = contractRegistry.getAddress("Chain");
        // unregistering must be done after address in registry is replaced
        if (newChain == address(this)) revert UnregisterFirst();

        // TODO:
        // I think we need to remove restriction for type (at least once)
        // when we will switch to multichain architecture

        if (!_ALLOW_FOR_MIXED_TYPE) {
            // can not be replaced with chain of different type
            if (BaseChain(newChain).isForeign() != this.isForeign()) revert InvalidContractType();
        }

        _consensusData.deprecated = true;
        emit LogDeprecation(msg.sender);
    }

    /// @notice it allows to deprecate contract manually
    /// Only new Registry calls `unregister()` where we set deprecated to true
    /// In old Registries we don't have this feature, so in order to safely redeploy new Chain
    /// we will have to first deprecate current contract manually, then register new contract
    function deprecate() external onlyOwnerOrRegistry {
        if (_consensusData.deprecated) revert AlreadyDeprecated();

        _consensusData.deprecated = true;
        emit LogDeprecation(msg.sender);
    }

    /// @dev getter for `_consensusData`
    function getConsensusData() external view returns (ConsensusData memory) {
        return _consensusData;
    }

    /// @dev number of blocks (consensus rounds) saved in this contract
    function blocksCount() external view returns (uint256) {
        return _consensusData.sequence - _consensusData.blocksCountOffset;
    }

    function blocksCountOffset() external view returns (uint32) {
        return _consensusData.blocksCountOffset;
    }

    function lastBlockId() external view returns (uint256) {
        return _consensusData.lastTimestamp;
    }

    /// @return TRUE if contract is ForeignChain, FALSE otherwise
    function isForeign() external pure virtual returns (bool);

    /// @inheritdoc Registrable
    function getName() external pure override returns (bytes32) {
        return "Chain";
    }

    /// @param _affidavit root and FCDs hashed together
    /// @param _v part of signature
    /// @param _r part of signature
    /// @param _s part of signature
    /// @return signer address
    function recoverSigner(bytes32 _affidavit, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {
        bytes32 hash = keccak256(abi.encodePacked(ETH_PREFIX, _affidavit));
        return ecrecover(hash, _v, _r, _s);
    }

    /// @param _blockId ID of submitted block
    /// @return block data (root + timestamp)
    function blocks(uint256 _blockId) external view returns (Block memory) {
        return Block(roots[_blockId], uint32(_blockId));
    }

    /// @return current block ID
    /// please note, that current ID is not the same as last ID, current means that once padding pass,
    /// ID will switch to next one and it will be pointing to empty submit until submit for that ID is done
    function getBlockId() external view returns (uint32) {
        if (_consensusData.lastTimestamp == 0) return 0;

        return getBlockIdAtTimestamp(block.timestamp);
    }

    function requiredSignatures() external view returns (uint16) {
        return _REQUIRED_SIGNATURES;
    }

    /// @dev calculates block ID for provided timestamp
    /// this function does not works for past timestamps
    /// @param _timestamp current or future timestamp
    /// @return block ID for provided timestamp
    function getBlockIdAtTimestamp(uint256 _timestamp) virtual public view returns (uint32) {
        ConsensusData memory data = _consensusData;

        unchecked {
            // we can't overflow because we adding two `uint32`
            if (data.lastTimestamp + data.padding < _timestamp) {
                return uint32(_timestamp);
            }
        }

        return data.lastTimestamp;
    }

    /// @return last submitted block ID, please note, that on deployment, when there is no submission for this contract
    /// block for last ID will be available in previous contract
    function getLatestBlockId() virtual public view returns (uint32) {
        return _consensusData.lastTimestamp;
    }

    /// @dev verifies if the leaf is valid leaf for merkle tree
    /// @param _proof merkle proof for merkle tree
    /// @param _root merkle root
    /// @param _leaf leaf hash
    /// @return TRUE if `_leaf` is valid, FALSE otherwise
    function verifyProof(bytes32[] memory _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {
        if (_root == bytes32(0)) {
            return false;
        }

        return _proof.verify(_root, _leaf);
    }

    /// @dev creates leaf hash, that has is used in merkle tree
    /// @param _key key under which we store the value
    /// @param _value value itself as bytes
    /// @return leaf hash
    function hashLeaf(bytes memory _key, bytes memory _value) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_key, _value));
    }

    /// @dev verifies, if provided key-value pair was part of consensus
    /// @param _blockId consensus ID for which we doing a check
    /// @param _proof merkle proof for pair
    /// @param _key pair key
    /// @param _value pair value
    /// @return TRUE if key-value par was part of consensus, FALSE otherwise
    function verifyProofForBlock(
        uint256 _blockId,
        bytes32[] memory _proof,
        bytes memory _key,
        bytes memory _value
    )
        public
        view
        returns (bool)
    {
        return _proof.verify(roots[_blockId], keccak256(abi.encodePacked(_key, _value)));
    }

    /// @dev this is helper method, that extracts one merkle proof from many hashed provided as bytes
    /// @param _data many hashes as bytes
    /// @param _offset this is starting point for extraction
    /// @param _items how many hashes to extract
    /// @return merkle proof (array of bytes32 hashes)
    function bytesToBytes32Array(
        bytes memory _data,
        uint256 _offset,
        uint256 _items
    )
        public
        pure
        returns (bytes32[] memory)
    {
        bytes32[] memory dataList = new bytes32[](_items);

        // we can unchecked because we working only with `i` and `_offset`
        // in case of wrong `_offset` it will throw
        unchecked {
            for (uint256 i = 0; i < _items; i++) {
                bytes32 temp;
                uint256 idx = (i + 1 + _offset) * 32;

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    temp := mload(add(_data, idx))
                }

                dataList[i] = temp;
            }
        }

        return (dataList);
    }

    /// @dev batch method for data verification
    /// @param _blockIds consensus IDs for which we doing a checks
    /// @param _proofs merkle proofs for all pair, sequence of hashes provided as bytes
    /// @param _proofItemsCounter array of counters, each counter tells how many hashes proof for each leaf has
    /// @param _leaves array of merkle leaves
    /// @return results array of verification results, TRUE if leaf is part of consensus, FALSE otherwise
    function verifyProofs(
        uint32[] memory _blockIds,
        bytes memory _proofs,
        uint256[] memory _proofItemsCounter,
        bytes32[] memory _leaves
    )
        public
        view
        returns (bool[] memory results)
    {
        results = new bool[](_leaves.length);
        uint256 offset = 0;

        for (uint256 i = 0; i < _leaves.length;) {
            results[i] = bytesToBytes32Array(_proofs, offset, _proofItemsCounter[i]).verify(
                roots[_blockIds[i]], _leaves[i]
            );

            unchecked {
                // we can uncheck because it will not overflow in a lifetime, and if someone provide invalid counter
                // we verification will not be valid (or we throw because of invalid memory access)
                offset += _proofItemsCounter[i];
                // we can uncheck because `i` will not overflow in a lifetime
                i++;
            }
        }
    }

    /// @param _blockId consensus ID
    /// @return root for provided consensus ID
    function getBlockRoot(uint32 _blockId) external view returns (bytes32) {
        return roots[_blockId];
    }

    /// @param _blockId consensus ID
    /// @return timestamp for provided consensus ID
    function getBlockTimestamp(uint32 _blockId) external view returns (uint32) {
        return roots[_blockId] == bytes32(0) ? 0 : _blockId;
    }

    /// @dev batch getter for FCDs
    /// @param _keys FCDs keys to fetch
    /// @return values array of FCDs values
    /// @return timestamps array of FCDs timestamps
    function getCurrentValues(bytes32[] calldata _keys)
        external
        view
        returns (uint256[] memory values, uint32[] memory timestamps)
    {
        timestamps = new uint32[](_keys.length);
        values = new uint256[](_keys.length);

        for (uint i=0; i<_keys.length;) {
            FirstClassData storage numericFCD = fcds[_keys[i]];
            values[i] = uint256(numericFCD.value);
            timestamps[i] = numericFCD.dataTimestamp;

            unchecked {
                // we can uncheck because `i` will not overflow in a lifetime
                i++;
            }
        }
    }

    /// @dev getter for single FCD value
    /// @param _key FCD key
    /// @return value FCD value
    /// @return timestamp FCD timestamp
    function getCurrentValue(bytes32 _key) external view returns (uint256 value, uint256 timestamp) {
        FirstClassData storage numericFCD = fcds[_key];
        return (uint256(numericFCD.value), numericFCD.dataTimestamp);
    }

    /// @dev getter for single FCD value in case its type is `int`
    /// @param _key FCD key
    /// @return value FCD value
    /// @return timestamp FCD timestamp
    function getCurrentIntValue(bytes32 _key) external view returns (int256 value, uint256 timestamp) {
        FirstClassData storage numericFCD = fcds[_key];
        return (numericFCD.value.toInt(), numericFCD.dataTimestamp);
    }

    function _setPadding(uint32 _padding) internal onlyOwner {
        if (_consensusData.padding == _padding) revert NoChangeToState();

        _consensusData.padding = _padding;
        emit LogPadding(msg.sender, _padding);
    }

    /// @dev we cloning last block time, because we will need reference point for next submissions
    function _cloneLastDataFromPrevChain(address _prevChain) internal {
        (bool success, bytes memory v) = _prevChain.staticcall(abi.encode(_VERSION_SELECTOR));
        uint256 prevVersion = success ? abi.decode(v, (uint256)) : 1;

        if (prevVersion == 1) {
            uint32 latestId = IBaseChainV1(address(_prevChain)).getLatestBlockId();
            _consensusData.lastTimestamp = IBaseChainV1(address(_prevChain)).getBlockTimestamp(latestId);

            // +1 because getLatestBlockId subtracts 1
            // +1 because it might be situation when tx is already in progress in old contract
            // and old contract do not have deprecated flag
            _consensusData.sequence = latestId + 2;
            _consensusData.blocksCountOffset = latestId + 2;
        } else { // VERSION 2
            // with new Registry, we have register/unregister methods
            // Chain will be deprecated, so there is no need to do "+1" as in old version
            // TODO what with current Registries??
            // we need a way to make it deprecated!
            ConsensusData memory data = BaseChain(_prevChain).getConsensusData();

            _consensusData.sequence = data.sequence;
            _consensusData.blocksCountOffset = data.sequence;
            _consensusData.lastTimestamp = data.lastTimestamp;
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Blacklisted.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "@openzeppelin/contracts/access/Ownable.sol";

abstract contract Blacklisted is Ownable {
    mapping (address => bool) public blacklist;

    event BlacklistedWallet(address wallet, bool status);

    function setupBlacklist(address[] calldata _addresses, bool[] calldata _statuses) external onlyOwner {
        uint256 n = _addresses.length;

        for (uint256 i; i < n; i++) {
            blacklist[_addresses[i]] = _statuses[i];
            emit BlacklistedWallet(_addresses[i], _statuses[i]);
        }
    }

    function _beforeTokenTransfer(address _from, address _to, uint256) internal virtual {
        if (blacklist[_to] || blacklist[_from]) {
            revert("address blacklisted");
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Chain.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "./BaseChain.sol";

contract Chain is BaseChain {
    IStakingBank public immutable stakingBank;

    event LogMint(address indexed minter, uint256 blockId, uint256 staked, uint256 power);
    event LogVoter(uint256 indexed blockId, address indexed voter, uint256 vote);

    error NotEnoughSignatures();
    error SignaturesOutOfOrder();

    /// @param _contractRegistry Registry address
    /// @param _padding required "space" between blocks in seconds
    /// @param _requiredSignatures number of required signatures for accepting consensus submission
    /// @param _allowForMixedType we have two "types" of Chain: HomeChain and ForeignChain, when we redeploying
    /// we don't want to mix up them, so we checking, if new Chain has the same type as current one.
    /// However, when we will be switching from one homechain to another one, we have to allow for this mixing up.
    /// This flag will tell contract, if this is the case.
    constructor(
        IRegistry _contractRegistry,
        uint32 _padding,
        uint16 _requiredSignatures,
        bool _allowForMixedType
    ) BaseChain(_contractRegistry, _padding, _requiredSignatures, _allowForMixedType) {
        stakingBank = IStakingBank(_contractRegistry.requireAndGetAddress("StakingBank"));
    }

    /// @dev method for submitting consensus data
    /// @param _dataTimestamp consensus timestamp, this is time for all data in merkle tree including FCDs
    /// @param _root merkle root
    /// @param _keys FCDs keys
    /// @param _values FCDs values
    /// @param _v array of `v` part of validators signatures
    /// @param _r array of `r` part of validators signatures
    /// @param _s array of `s` part of validators signatures
    // solhint-disable-next-line function-max-lines, code-complexity
    function submit(
        uint32 _dataTimestamp,
        bytes32 _root,
        bytes32[] memory _keys,
        uint256[] memory _values,
        uint8[] memory _v,
        bytes32[] memory _r,
        bytes32[] memory _s
    ) external {
        // below two checks are only for pretty errors, so we can safe gas and allow for raw revert
        // if (_keys.length != _values.length) revert ArraysDataDoNotMatch();
        // if (_v.length != _r.length || _r.length != _s.length) revert ArraysDataDoNotMatch();

        _verifySubmitTimestampAndIncSequence(_dataTimestamp);

        // we can't expect minter will have exactly the same timestamp
        // but for sure we can demand not to be off by a lot, that's why +3sec
        // temporary remove this condition, because recently on ropsten we see cases when minter/node
        // can be even 100sec behind
        // require(_dataTimestamp <= block.timestamp + 3,
        //   string(abi.encodePacked("oh, so you can predict the future:", _dataTimestamp - block.timestamp + 48)));

        bytes memory testimony = abi.encodePacked(_dataTimestamp, _root);

        for (uint256 i = 0; i < _keys.length;) {
            if (uint224(_values[i]) != _values[i]) revert FCDOverflow();

            fcds[_keys[i]] = FirstClassData(uint224(_values[i]), _dataTimestamp);
            testimony = abi.encodePacked(testimony, _keys[i], _values[i]);

            unchecked {
                // we can't pass enough data to overflow
                i++;
            }
        }

        uint256 signatures = 0;
        uint256 power = 0;
        //uint256 staked = stakingBank.totalSupply();
        bytes32 affidavit = keccak256(testimony);

        address prevSigner = address(0x0);

        for (uint256 i; i < _v.length;) {
            address signer = recoverSigner(affidavit, _v[i], _r[i], _s[i]);
            uint256 balance = stakingBank.balanceOf(signer);

            if (prevSigner >= signer) revert SignaturesOutOfOrder();

            prevSigner = signer;

            if (balance == 0) {
                unchecked { i++; }
                continue;
            }

            signatures++;
            emit LogVoter(uint256(_dataTimestamp), signer, balance);

            unchecked {
                // we can't overflow because that means token overflowed
                // and even if we do, we will get lower power
                power += balance;
                i++;
            }
        }

        if (signatures < _REQUIRED_SIGNATURES) revert NotEnoughSignatures();

        emit LogMint(msg.sender, _dataTimestamp, stakingBank.totalSupply(), power);

        // TODO remember to protect against flash loans when DPoS will be in place
        // we turn on power once we have DPoS in action, we have PoA now
        // require(power * 100 / staked >= 66, "not enough power was gathered");

        roots[_dataTimestamp] = _root;
        _consensusData.lastTimestamp = _dataTimestamp;
    }

    /// @inheritdoc BaseChain
    function isForeign() external pure virtual override returns (bool) {
        return false;
    }

    /// @dev helper method that returns all important data about current state of contract
    /// @return blockNumber `block.number`
    /// @return timePadding `this.padding`
    /// @return lastDataTimestamp timestamp for last submitted consensus
    /// @return lastId ID of last submitted consensus
    /// @return nextLeader leader for `block.timestamp + 1`
    /// @return nextBlockId block ID for `block.timestamp + padding`
    /// @return validators array of all validators addresses
    /// @return powers array of all validators powers
    /// @return locations array of all validators locations
    /// @return staked total UMB staked by validators
    /// @return minSignatures `this.requiredSignatures`
    function getStatus() external view virtual returns(
        uint256 blockNumber,
        uint32 timePadding,
        uint32 lastDataTimestamp,
        uint32 lastId,
        address nextLeader,
        uint32 nextBlockId,
        address[] memory validators,
        uint256[] memory powers,
        string[] memory locations,
        uint256 staked,
        uint16 minSignatures
    ) {
        ConsensusData memory data = _consensusData;

        blockNumber = block.number;
        timePadding = data.padding;
        lastId = data.lastTimestamp;
        lastDataTimestamp = lastId;
        minSignatures = _REQUIRED_SIGNATURES;

        staked = stakingBank.totalSupply();
        uint256 numberOfValidators = stakingBank.getNumberOfValidators();
        powers = new uint256[](numberOfValidators);
        validators = new address[](numberOfValidators);
        locations = new string[](numberOfValidators);

        for (uint256 i = 0; i < numberOfValidators;) {
            validators[i] = stakingBank.addresses(i);
            (, locations[i]) = stakingBank.validators(validators[i]);
            powers[i] = stakingBank.balanceOf(validators[i]);

            unchecked {
                // we will run out of gas before overflow happen
                i++;
            }
        }

        unchecked {
            // we will not overflow with timestamp in a lifetime
            nextBlockId = lastId + data.padding + 1;

            nextLeader = numberOfValidators > 0
                // we will not overflow with timestamp in a lifetime
                ? validators[getLeaderIndex(numberOfValidators, block.timestamp + 1)]
                : address(0);
        }
    }

    /// @return address of leader for next second
    function getNextLeaderAddress() external view returns (address) {
        return getLeaderAddressAtTime(block.timestamp + 1);
    }

    /// @return address of current leader
    function getLeaderAddress() external view returns (address) {
        return getLeaderAddressAtTime(block.timestamp);
    }

    /// @param _numberOfValidators total number of validators
    /// @param _timestamp timestamp for which you want to calculate index
    /// @return leader index, use it for StakingBank.addresses[index] to fetch leader address
    function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) public view virtual returns (uint256) {
        ConsensusData memory data = _consensusData;

        unchecked {
            // we will not overflow on `timestamp` and `padding` in a life time
            // timePadding + 1 => because padding is a space between blocks,
            // so next round starts on first block after padding
            // TODO will it work for off-chain??
            uint256 validatorIndex = data.sequence + (_timestamp - data.lastTimestamp) / (data.padding + 1);

            return validatorIndex % _numberOfValidators;
        }
    }

    // @todo - properly handled non-enabled validators, newly added validators, and validators with low stake
    /// @param _timestamp timestamp for which you want to calculate leader address
    /// @return leader address for provider timestamp
    function getLeaderAddressAtTime(uint256 _timestamp) public view virtual returns (address) {
        uint256 numberOfValidators = stakingBank.getNumberOfValidators();

        if (numberOfValidators == 0) {
            return address(0x0);
        }

        uint256 validatorIndex = getLeaderIndex(numberOfValidators, _timestamp);

        return stakingBank.addresses(validatorIndex);
    }

    /// @dev we had stack too deep in `submit` so this method was created as a solution
    // we increasing `_consensusData.sequence` here so we don't have to read sequence again in other place
    function _verifySubmitTimestampAndIncSequence(uint256 _dataTimestamp) internal {
        ConsensusData memory data = _consensusData;

        // `data.lastTimestamp` must be setup either on deployment
        // or via cloning from previous contract
        if (data.lastTimestamp == 0) revert ContractNotReady();

        unchecked {
            // we will not overflow with timestamp and padding in a life time
            if (data.lastTimestamp + data.padding >= _dataTimestamp) revert BlockSubmittedToFastOrDataToOld();
        }

        unchecked {
            // we will not overflow in a life time
            _consensusData.sequence = uint32(data.sequence + 1);
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ChainlinkV3PriceProvider.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

import "../PriceProvider.sol";
import "../IERC20LikeV2.sol";

contract ChainlinkV3PriceProvider is PriceProvider {
    using SafeMath for uint256;

    struct AssetData {
        // Time threshold to invalidate stale prices
        uint256 heartbeat;
        // If true, we bypass the aggregator and consult the fallback provider directly
        bool forceFallback;
        // If true, the aggregator returns price in USD, so we need to convert to QUOTE
        bool convertToQuote;
        // Chainlink aggregator proxy
        AggregatorV3Interface aggregator;
        // Provider used if the aggregator's price is invalid or if it became disabled
        IPriceProvider fallbackProvider;
    }

    /// @dev Aggregator that converts from USD to quote token
    AggregatorV3Interface internal immutable _QUOTE_AGGREGATOR; // solhint-disable-line var-name-mixedcase

    /// @dev Decimals used by the _QUOTE_AGGREGATOR
    uint8 internal immutable _QUOTE_AGGREGATOR_DECIMALS; // solhint-disable-line var-name-mixedcase

    /// @dev Used to optimize calculations in emergency disable function
    // solhint-disable-next-line var-name-mixedcase
    uint256 internal immutable _MAX_PRICE_DIFF = type(uint256).max / (100 * EMERGENCY_PRECISION);
    
    // @dev Precision to use for the EMERGENCY_THRESHOLD
    uint256 public constant EMERGENCY_PRECISION = 1e6;

    /// @dev Disable the aggregator if the difference with the fallback is higher than this percentage (10%)
    uint256 public constant EMERGENCY_THRESHOLD = 10 * EMERGENCY_PRECISION; // solhint-disable-line var-name-mixedcase

    /// @dev this is basically `PriceProvider.quoteToken.decimals()`
    uint8 internal immutable _QUOTE_TOKEN_DECIMALS; // solhint-disable-line var-name-mixedcase

    /// @dev Address allowed to call the emergencyDisable function, can be set by the owner
    address public emergencyManager;

    /// @dev Threshold used to determine if the price returned by the _QUOTE_AGGREGATOR is valid
    uint256 public quoteAggregatorHeartbeat;

    /// @dev Data used for each asset
    mapping(address => AssetData) public assetData;

    event NewAggregator(address indexed asset, AggregatorV3Interface indexed aggregator, bool convertToQuote);
    event NewFallbackPriceProvider(address indexed asset, IPriceProvider indexed fallbackProvider);
    event NewHeartbeat(address indexed asset, uint256 heartbeat);
    event NewQuoteAggregatorHeartbeat(uint256 heartbeat);
    event NewEmergencyManager(address indexed emergencyManager);
    event AggregatorDisabled(address indexed asset, AggregatorV3Interface indexed aggregator);

    error AggregatorDidNotChange();
    error AggregatorPriceNotAvailable();
    error AssetNotSupported();
    error EmergencyManagerDidNotChange();
    error EmergencyThresholdNotReached();
    error FallbackProviderAlreadySet();
    error FallbackProviderDidNotChange();
    error FallbackProviderNotSet();
    error HeartbeatDidNotChange();
    error InvalidAggregator();
    error InvalidAggregatorDecimals();
    error InvalidFallbackPriceProvider();
    error InvalidHeartbeat();
    error OnlyEmergencyManager();
    error QuoteAggregatorHeartbeatDidNotChange();

    modifier onlyAssetSupported(address _asset) {
        if (!assetSupported(_asset)) {
            revert AssetNotSupported();
        }

        _;
    }

    constructor(
        IPriceProvidersRepository _priceProvidersRepository,
        address _emergencyManager,
        AggregatorV3Interface _quoteAggregator,
        uint256 _quoteAggregatorHeartbeat
    ) PriceProvider(_priceProvidersRepository) {
        _setEmergencyManager(_emergencyManager);
        _QUOTE_TOKEN_DECIMALS = IERC20LikeV2(quoteToken).decimals();
        _QUOTE_AGGREGATOR = _quoteAggregator;
        _QUOTE_AGGREGATOR_DECIMALS = _quoteAggregator.decimals();
        quoteAggregatorHeartbeat = _quoteAggregatorHeartbeat;
    }

    /// @inheritdoc IPriceProvider
    function assetSupported(address _asset) public view virtual override returns (bool) {
        AssetData storage data = assetData[_asset];

        // Asset is supported if:
        //     - the asset is the quote token
        //       OR
        //     - the aggregator address is defined AND
        //         - the aggregator is not disabled
        //           OR
        //         - the fallback is defined

        if (_asset == quoteToken) {
            return true;
        }

        if (address(data.aggregator) != address(0)) {
            return !data.forceFallback || address(data.fallbackProvider) != address(0);
        }

        return false;
    }

    /// @dev Returns price directly from aggregator using all internal settings except fallback
    /// @param _asset Asset for which we want to get the price
    function getAggregatorPrice(address _asset) public view virtual returns (bool success, uint256 price) {
        return _getAggregatorPrice(_asset);
    }
    
    /// @inheritdoc IPriceProvider
    function getPrice(address _asset) public view virtual override returns (uint256) {
        address quote = quoteToken;

        if (_asset == quote) {
            return 10 ** _QUOTE_TOKEN_DECIMALS;
        }

        (bool success, uint256 price) = _getAggregatorPrice(_asset);

        return success ? price : _getFallbackPrice(_asset);
    }

    /// @dev Sets the aggregator, fallbackProvider and heartbeat for an asset. Can only be called by the manager.
    /// @param _asset Asset to setup
    /// @param _aggregator Chainlink aggregator proxy
    /// @param _fallbackProvider Provider to use if the price is invalid or if the aggregator was disabled
    /// @param _heartbeat Threshold in seconds to invalidate a stale price
    function setupAsset(
        address _asset,
        AggregatorV3Interface _aggregator,
        IPriceProvider _fallbackProvider,
        uint256 _heartbeat,
        bool _convertToQuote
    ) external virtual onlyManager {
        // This has to be done first so that `_setAggregator` works
        _setHeartbeat(_asset, _heartbeat);

        if (!_setAggregator(_asset, _aggregator, _convertToQuote)) revert AggregatorDidNotChange();

        // We don't care if this doesn't change
        _setFallbackPriceProvider(_asset, _fallbackProvider);
    }

    /// @dev Sets the aggregator for an asset. Can only be called by the manager.
    /// @param _asset Asset for which to set the aggregator
    /// @param _aggregator Aggregator to set
    function setAggregator(address _asset, AggregatorV3Interface _aggregator, bool _convertToQuote)
        external
        virtual
        onlyManager
        onlyAssetSupported(_asset)
    {
        if (!_setAggregator(_asset, _aggregator, _convertToQuote)) revert AggregatorDidNotChange();
    }

    /// @dev Sets the fallback provider for an asset. Can only be called by the manager.
    /// @param _asset Asset for which to set the fallback provider
    /// @param _fallbackProvider Provider to set
    function setFallbackPriceProvider(address _asset, IPriceProvider _fallbackProvider)
        external
        virtual
        onlyManager
        onlyAssetSupported(_asset)
    {
        if (!_setFallbackPriceProvider(_asset, _fallbackProvider)) {
            revert FallbackProviderDidNotChange();
        }
    }

    /// @dev Sets the heartbeat threshold for an asset. Can only be called by the manager.
    /// @param _asset Asset for which to set the heartbeat threshold
    /// @param _heartbeat Threshold to set
    function setHeartbeat(address _asset, uint256 _heartbeat)
        external
        virtual
        onlyManager
        onlyAssetSupported(_asset)
    {
        if (!_setHeartbeat(_asset, _heartbeat)) revert HeartbeatDidNotChange();
    }

    /// @dev Sets the quote aggregator heartbeat threshold. Can only be called by the manager.
    /// @param _heartbeat Threshold to set
    function setQuoteAggregatorHeartbeat(uint256 _heartbeat)
        external
        virtual
        onlyManager
    {
        if (!_setQuoteAggregatorHeartbeat(_heartbeat)) revert QuoteAggregatorHeartbeatDidNotChange();
    }

    /// @dev Sets the emergencyManager. Can only be called by the manager.
    /// @param _emergencyManager Emergency manager to set
    function setEmergencyManager(address _emergencyManager) external virtual onlyManager {
        if (!_setEmergencyManager(_emergencyManager)) revert EmergencyManagerDidNotChange();
    }

    /// @dev Disables the aggregator for an asset if there is a big discrepancy between the aggregator and the
    /// fallback provider. The only way to reenable the asset is by calling setupAsset or setAggregator again.
    /// Can only be called by the emergencyManager.
    /// @param _asset Asset for which to disable the aggregator
    function emergencyDisable(address _asset) external virtual {
        if (msg.sender != emergencyManager) {
            revert OnlyEmergencyManager();
        }

        (bool success, uint256 price) = _getAggregatorPrice(_asset);

        if (!success) {
            revert AggregatorPriceNotAvailable();
        }

        uint256 fallbackPrice = _getFallbackPrice(_asset);

        uint256 diff;

        unchecked {
            // It is ok to uncheck because of the initial fallbackPrice >= price check
            diff = fallbackPrice >= price ? fallbackPrice - price : price - fallbackPrice;
        }

        if (diff > _MAX_PRICE_DIFF || (diff * 100 * EMERGENCY_PRECISION) / price < EMERGENCY_THRESHOLD) {
            revert EmergencyThresholdNotReached();
        }

        // Disable main aggregator, fallback stays enabled
        assetData[_asset].forceFallback = true;

        emit AggregatorDisabled(_asset, assetData[_asset].aggregator);
    }

    function getFallbackProvider(address _asset) external view virtual returns (IPriceProvider) {
        return assetData[_asset].fallbackProvider;
    }

    function _getAggregatorPrice(address _asset) internal view virtual returns (bool success, uint256 price) {
        AssetData storage data = assetData[_asset];

        uint256 heartbeat = data.heartbeat;
        bool forceFallback = data.forceFallback;
        AggregatorV3Interface aggregator = data.aggregator;

        if (address(aggregator) == address(0)) revert AssetNotSupported();

        (
            /*uint80 roundID*/,
            int256 aggregatorPrice,
            /*uint256 startedAt*/,
            uint256 timestamp,
            /*uint80 answeredInRound*/
        ) = aggregator.latestRoundData();

        // If a valid price is returned and it was updated recently
        if (!forceFallback && _isValidPrice(aggregatorPrice, timestamp, heartbeat)) {
            uint256 result;

            if (data.convertToQuote) {
                // _toQuote performs decimal normalization internally
                result = _toQuote(uint256(aggregatorPrice));
            } else {
                uint8 aggregatorDecimals = aggregator.decimals();
                result = _normalizeWithDecimals(uint256(aggregatorPrice), aggregatorDecimals);
            }

            return (true, result);
        }

        return (false, 0);
    }

    function _getFallbackPrice(address _asset) internal view virtual returns (uint256) {
        IPriceProvider fallbackProvider = assetData[_asset].fallbackProvider;

        if (address(fallbackProvider) == address(0)) revert FallbackProviderNotSet();

        return fallbackProvider.getPrice(_asset);
    }

    function _setEmergencyManager(address _emergencyManager) internal virtual returns (bool changed) {
        if (_emergencyManager == emergencyManager) {
            return false;
        }

        emergencyManager = _emergencyManager;

        emit NewEmergencyManager(_emergencyManager);

        return true;
    }

    function _setAggregator(
        address _asset,
        AggregatorV3Interface _aggregator,
        bool _convertToQuote
    ) internal virtual returns (bool changed) {
        if (address(_aggregator) == address(0)) revert InvalidAggregator();

        AssetData storage data = assetData[_asset];

        if (data.aggregator == _aggregator && data.forceFallback == false) {
            return false;
        }

        // There doesn't seem to be a way to verify if this is a "valid" aggregator (other than getting the price)
        data.forceFallback = false;
        data.aggregator = _aggregator;

        (bool success,) = _getAggregatorPrice(_asset);

        if (!success) revert AggregatorPriceNotAvailable();

        if (_convertToQuote && _aggregator.decimals() != _QUOTE_AGGREGATOR_DECIMALS) {
            revert InvalidAggregatorDecimals();
        }

        // We want to always update this
        assetData[_asset].convertToQuote = _convertToQuote;

        emit NewAggregator(_asset, _aggregator, _convertToQuote);

        return true;
    }

    function _setFallbackPriceProvider(address _asset, IPriceProvider _fallbackProvider)
        internal
        virtual
        returns (bool changed)
    {
        if (_fallbackProvider == assetData[_asset].fallbackProvider) {
            return false;
        }

        assetData[_asset].fallbackProvider = _fallbackProvider;

        if (address(_fallbackProvider) != address(0)) {
            if (
                !priceProvidersRepository.isPriceProvider(_fallbackProvider) ||
                !_fallbackProvider.assetSupported(_asset) ||
                _fallbackProvider.quoteToken() != quoteToken
            ) {
                revert InvalidFallbackPriceProvider();
            }

            // Make sure it doesn't revert
            _getFallbackPrice(_asset);
        }

        emit NewFallbackPriceProvider(_asset, _fallbackProvider);

        return true;
    }

    function _setHeartbeat(address _asset, uint256 _heartbeat) internal virtual returns (bool changed) {
        // Arbitrary limit, Chainlink's threshold is always less than a day
        if (_heartbeat > 2 days) revert InvalidHeartbeat();

        if (_heartbeat == assetData[_asset].heartbeat) {
            return false;
        }

        assetData[_asset].heartbeat = _heartbeat;

        emit NewHeartbeat(_asset, _heartbeat);

        return true;
    }

    function _setQuoteAggregatorHeartbeat(uint256 _heartbeat) internal virtual returns (bool changed) {
        // Arbitrary limit, Chainlink's threshold is always less than a day
        if (_heartbeat > 2 days) revert InvalidHeartbeat();

        if (_heartbeat == quoteAggregatorHeartbeat) {
            return false;
        }

        quoteAggregatorHeartbeat = _heartbeat;

        emit NewQuoteAggregatorHeartbeat(_heartbeat);

        return true;
    }

    /// @dev Adjusts the given price to use the same decimals as the quote token.
    /// @param _price Price to adjust decimals
    /// @param _decimals Decimals considered in `_price`
    function _normalizeWithDecimals(uint256 _price, uint8 _decimals) internal view virtual returns (uint256) {
        // We want to return the price of 1 asset token, but with the decimals of the quote token
        if (_QUOTE_TOKEN_DECIMALS == _decimals) {
            return _price;
        } else if (_QUOTE_TOKEN_DECIMALS < _decimals) {
            return _price / 10 ** (_decimals - _QUOTE_TOKEN_DECIMALS);
        } else {
            return _price * 10 ** (_QUOTE_TOKEN_DECIMALS - _decimals);
        }
    }

    /// @dev Converts a price returned by an aggregator to quote units
    function _toQuote(uint256 _price) internal view virtual returns (uint256) {
       (
            /*uint80 roundID*/,
            int256 aggregatorPrice,
            /*uint256 startedAt*/,
            uint256 timestamp,
            /*uint80 answeredInRound*/
        ) = _QUOTE_AGGREGATOR.latestRoundData();

        // If an invalid price is returned
        if (!_isValidPrice(aggregatorPrice, timestamp, quoteAggregatorHeartbeat)) {
            revert AggregatorPriceNotAvailable();
        }

        // _price and aggregatorPrice should both have the same decimals so we normalize here
        return _price * 10 ** _QUOTE_TOKEN_DECIMALS / uint256(aggregatorPrice);
    }

    function _isValidPrice(int256 _price, uint256 _timestamp, uint256 _heartbeat) internal view virtual returns (bool) {
        return _price > 0 && block.timestamp - _timestamp < _heartbeat;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\console.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity >= 0.4.22 <0.9.0;

library console {
	address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);

	function _sendLogPayload(bytes memory payload) private view {
		uint256 payloadLength = payload.length;
		address consoleAddress = CONSOLE_ADDRESS;
		assembly {
			let payloadStart := add(payload, 32)
			let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
		}
	}

	function log() internal view {
		_sendLogPayload(abi.encodeWithSignature("log()"));
	}

	function logInt(int p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(int)", p0));
	}

	function logUint(uint p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
	}

	function logString(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function logBool(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function logAddress(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function logBytes(bytes memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
	}

	function logBytes1(bytes1 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
	}

	function logBytes2(bytes2 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
	}

	function logBytes3(bytes3 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
	}

	function logBytes4(bytes4 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
	}

	function logBytes5(bytes5 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
	}

	function logBytes6(bytes6 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
	}

	function logBytes7(bytes7 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
	}

	function logBytes8(bytes8 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
	}

	function logBytes9(bytes9 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
	}

	function logBytes10(bytes10 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
	}

	function logBytes11(bytes11 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
	}

	function logBytes12(bytes12 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
	}

	function logBytes13(bytes13 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
	}

	function logBytes14(bytes14 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
	}

	function logBytes15(bytes15 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
	}

	function logBytes16(bytes16 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
	}

	function logBytes17(bytes17 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
	}

	function logBytes18(bytes18 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
	}

	function logBytes19(bytes19 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
	}

	function logBytes20(bytes20 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
	}

	function logBytes21(bytes21 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
	}

	function logBytes22(bytes22 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
	}

	function logBytes23(bytes23 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
	}

	function logBytes24(bytes24 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
	}

	function logBytes25(bytes25 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
	}

	function logBytes26(bytes26 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
	}

	function logBytes27(bytes27 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
	}

	function logBytes28(bytes28 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
	}

	function logBytes29(bytes29 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
	}

	function logBytes30(bytes30 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
	}

	function logBytes31(bytes31 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
	}

	function logBytes32(bytes32 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
	}

	function log(uint p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
	}

	function log(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function log(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function log(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function log(uint p0, uint p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
	}

	function log(uint p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
	}

	function log(uint p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
	}

	function log(uint p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
	}

	function log(string memory p0, uint p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
	}

	function log(string memory p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
	}

	function log(string memory p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
	}

	function log(string memory p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
	}

	function log(bool p0, uint p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
	}

	function log(bool p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
	}

	function log(bool p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
	}

	function log(bool p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
	}

	function log(address p0, uint p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
	}

	function log(address p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
	}

	function log(address p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
	}

	function log(address p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
	}

	function log(uint p0, uint p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
	}

	function log(uint p0, uint p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
	}

	function log(uint p0, uint p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
	}

	function log(uint p0, uint p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
	}

	function log(uint p0, string memory p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
	}

	function log(uint p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
	}

	function log(uint p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
	}

	function log(uint p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
	}

	function log(uint p0, bool p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
	}

	function log(uint p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
	}

	function log(uint p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
	}

	function log(uint p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
	}

	function log(uint p0, address p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
	}

	function log(uint p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
	}

	function log(uint p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
	}

	function log(uint p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
	}

	function log(string memory p0, uint p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
	}

	function log(string memory p0, uint p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
	}

	function log(string memory p0, uint p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
	}

	function log(string memory p0, uint p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
	}

	function log(string memory p0, address p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
	}

	function log(string memory p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
	}

	function log(string memory p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
	}

	function log(string memory p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
	}

	function log(bool p0, uint p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
	}

	function log(bool p0, uint p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
	}

	function log(bool p0, uint p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
	}

	function log(bool p0, uint p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
	}

	function log(bool p0, bool p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
	}

	function log(bool p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
	}

	function log(bool p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
	}

	function log(bool p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
	}

	function log(bool p0, address p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
	}

	function log(bool p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
	}

	function log(bool p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
	}

	function log(bool p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
	}

	function log(address p0, uint p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
	}

	function log(address p0, uint p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
	}

	function log(address p0, uint p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
	}

	function log(address p0, uint p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
	}

	function log(address p0, string memory p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
	}

	function log(address p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
	}

	function log(address p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
	}

	function log(address p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
	}

	function log(address p0, bool p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
	}

	function log(address p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
	}

	function log(address p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
	}

	function log(address p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
	}

	function log(address p0, address p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
	}

	function log(address p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
	}

	function log(address p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
	}

	function log(address p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
	}

	function log(uint p0, uint p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
	}

}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\DPoSCore.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import "@openzeppelin/contracts/V4/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/V4/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/V4/access/Ownable.sol";
import "@openzeppelin/contracts/V4/utils/cryptography/ECDSA.sol";

interface Token {
    function mint(address _holder, uint256 _amount) external;
}

/// @author  umb.network
/// @dev claiming reward is token agnostic, contract only keep track of total reward paid
/// so we can pay in UMB, rUmb1, rUmb2 or any other token
abstract contract DPoSCore is Ownable {
    using SafeERC20 for IERC20;

    /// @dev rewards settings for token, in case of Umbrella tokens (UMB, rUmb) it will be same setting, we treat
    /// Umb tokens as one
    /// total supply of UMB = 500_000_000e18, it can be saved using 89bits, so we good with 96 and above
    /// for other tokens total supply might be unlimited, but we do not expect to give away 500 millions
    /// so we can keep optimisation and use same data type as for UMB
    struct RewardStatus {
        /// @dev total rewards claimed by users so far
        uint96 totalPaid;

        /// @dev total limit for rewards, `totalPaid` can not be higher than `totalLimit`
        /// this allow us to set some limit and then contract can mint on demand up to this limit
        /// this is more efficient than transferring tokens beforehand:
        /// - minting is less gas
        /// - no need to withdraw unnecessary tokens
        /// - it will not affect total supply
        uint96 totalLimit;

        bool transferringActive;

        bool mintingActive;
    }

    bytes constant private _ETH_PREFIX = "\x19Ethereum Signed Message:\n32";

    /// @dev BE signer
    address public rewardSigner;

    event RewardPaid(address indexed token, address indexed user, uint256 amount);

    event NewRewardSigner(address rewardSigner);

    constructor(address _rewardSigner) {
        _setRewardSigner(_rewardSigner);
    }

    /// @dev this method can be used to rescue tokens or simply withdraw them
    function withdrawTokens(IERC20 _token, address _recipient, uint256 _amount) external onlyOwner {
        _token.safeTransfer(_recipient, _amount);
    }

    function setRewardSigner(address _rewardSigner) external onlyOwner {
        _setRewardSigner(_rewardSigner);
    }

    function getChainId() public view returns (uint256 id) {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            id := chainid()
        }
    }

    function recover(address _token, address _recipient, uint256 _totalAmount, bytes memory _signature)
        public
        view
        returns (address)
    {
        bytes32 hash = keccak256(abi.encodePacked(getChainId(), _token, _recipient, _totalAmount));
        bytes32 prefixedHash = keccak256(abi.encodePacked(_ETH_PREFIX, hash));
        return ECDSA.recover(prefixedHash, _signature);
    }

    function _setRewardSigner(address _rewardSigner) internal {
        require(_rewardSigner != address(0), "empty reward signer");

        rewardSigner = _rewardSigner;
        emit NewRewardSigner(_rewardSigner);
    }

    function _executeClaim(
        RewardStatus storage _rewardStatus,
        mapping(address => uint256) storage _rewardsPaid,
        address _token,
        address _recipient,
        uint256 _totalAmount,
        bytes memory _signature
    )
        internal
        returns (uint256 rewardToClaim)
    {
        require(_totalAmount != 0, "totalAmount is zero");
        require(_recipient != address(0), "empty recipient");
        require(_token != address(0), "empty token");

        uint256 paid = _rewardsPaid[_recipient];

        require(paid < _totalAmount, "there is nothing to claim");
        require(rewardSigner == recover(_token, _recipient, _totalAmount, _signature), "invalid signature");

        unchecked {
            // underflow not possible because of require(paid < _totalAmount)
            rewardToClaim = _totalAmount - paid;
            RewardStatus memory status = _rewardStatus;
            // overflow `status.totalPaid + rewardToClaim` not possible because: in order to overflow `rewardToClaim`
            // needs to be at least `MAX(uint96) - status.totalPaid`, that basically means, contract will be asked
            // either to mint or to transfer `rewardToClaim`, in that case:
            // - on mint: we revert, because it will overflow on totalSupply
            // - on transfer: we revert, because contract will not have such an amount, because it is impossible to mint
            // for every other scenario, with values that are not close to MAX, we are protected by below requirement
            require(status.totalPaid + rewardToClaim <= status.totalLimit, "reward limit");

            // overflow not possible because of require(r.totalPaid + rewardToClaim <= r.totalLimit)
            _rewardStatus.totalPaid = uint96(status.totalPaid + rewardToClaim);
            _rewardsPaid[_recipient] = paid + rewardToClaim;
        }

        emit RewardPaid(_token, _recipient, rewardToClaim);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\DPoSUmbRewards.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import "./DPoSCore.sol";

/// @author  umb.network
/// @dev claiming reward is token agnostic, contract only keep track of total reward paid
/// so we can pay in UMB, rUmb1, rUmb2 or any other token
contract DPoSUmbRewards is DPoSCore {
    RewardStatus public rewardStatus;

    /// @dev user => reward paid so far
    mapping(address => uint256) public rewardsPaid;
    
    event LimitChanged(uint256 limit);

    event TransferringStatus(bool active);

    event MintingStatus(bool active);

    constructor(address _rewardSigner) DPoSCore(_rewardSigner) {
        //
    }
    
    function setLimit(uint96 _limit) external onlyOwner {
        uint96 totalPaid = rewardStatus.totalPaid;

        if (_limit < totalPaid) {
            _limit = totalPaid;
        }

        rewardStatus.totalLimit = _limit;
        emit LimitChanged(_limit);
    }

    function setStatuses(bool _transferringActive, bool _mintingActive) external {
        setTransferringStatus(_transferringActive);
        setMintingStatus(_mintingActive);
    }

    /// @param _token token that will be transferred to recipient
    /// @param _recipient user for whom rewards will be claimed (no need to be same user who execute this tx)
    /// @param _totalAmount total (ever increasing) amount of reward collected by user in DPoS
    /// @param _signature rewardSigner signature
    function transferReward(IERC20 _token, address _recipient, uint256 _totalAmount, bytes memory _signature) external {
        require(rewardStatus.transferringActive, "transferring NOT active");

        uint256 rewardToClaim = _executeClaim(
            rewardStatus,
            rewardsPaid,
            address(_token),
            _recipient,
            _totalAmount,
            _signature
        );

        require(_token.transfer(_recipient, rewardToClaim), "umbrella token transfer failed");
    }

    /// @dev same as `transferReward` but for minting on demand so eg. rUmb2
    function mintReward(Token _token, address _recipient, uint256 _totalAmount, bytes memory _signature) external {
        require(rewardStatus.mintingActive, "minting NOT active");

        uint256 rewardToClaim = _executeClaim(
            rewardStatus,
            rewardsPaid,
            address(_token),
            _recipient,
            _totalAmount,
            _signature
        );

        _token.mint(_recipient, rewardToClaim);
    }

    function setMintingStatus(bool _active) public onlyOwner {
        rewardStatus.mintingActive = _active;
        emit MintingStatus(_active);
    }

    function setTransferringStatus(bool _active) public onlyOwner {
        rewardStatus.transferringActive = _active;
        emit TransferringStatus(_active);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ECDSA.sol
File type: .sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)

pragma solidity ^0.8.0;

import "../Strings.sol";

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS,
        InvalidSignatureV
    }

    function _throwError(RecoverError error) private pure {
        if (error == RecoverError.NoError) {
            return; // no error: do nothing
        } else if (error == RecoverError.InvalidSignature) {
            revert("ECDSA: invalid signature");
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert("ECDSA: invalid signature length");
        } else if (error == RecoverError.InvalidSignatureS) {
            revert("ECDSA: invalid signature 's' value");
        } else if (error == RecoverError.InvalidSignatureV) {
            revert("ECDSA: invalid signature 'v' value");
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature` or error string. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     *
     * Documentation for signature generation:
     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
     *
     * _Available since v4.3._
     */
    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
        // Check the signature length
        // - case 65: r,s,v signature (standard)
        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            // ecrecover takes the signature parameters, and the only way to get them
            // currently is to use assembly.
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else if (signature.length == 64) {
            bytes32 r;
            bytes32 vs;
            // ecrecover takes the signature parameters, and the only way to get them
            // currently is to use assembly.
            assembly {
                r := mload(add(signature, 0x20))
                vs := mload(add(signature, 0x40))
            }
            return tryRecover(hash, r, vs);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength);
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, signature);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
     *
     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
     *
     * _Available since v4.3._
     */
    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address, RecoverError) {
        bytes32 s;
        uint8 v;
        assembly {
            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            v := add(shr(255, vs), 27)
        }
        return tryRecover(hash, v, r, s);
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
     *
     * _Available since v4.2._
     */
    function recover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, r, vs);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
     * `r` and `s` signature fields separately.
     *
     * _Available since v4.3._
     */
    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError) {
        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (301): 0 < s < secp256k1n ¡Â 2 + 1, and for v in (302): v ¡Ê {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
        if (v != 27 && v != 28) {
            return (address(0), RecoverError.InvalidSignatureV);
        }

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature);
        }

        return (signer, RecoverError.NoError);
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `v`,
     * `r` and `s` signature fields separately.
     */
    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * produces hash corresponding to the one signed with the
     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
     * JSON-RPC method as part of EIP-191.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from `s`. This
     * produces hash corresponding to the one signed with the
     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
     * JSON-RPC method as part of EIP-191.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));
    }

    /**
     * @dev Returns an Ethereum Signed Typed Data, created from a
     * `domainSeparator` and a `structHash`. This produces hash corresponding
     * to the one signed with the
     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]
     * JSON-RPC method as part of EIP-712.
     *
     * See {recover}.
     */
    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\EnumerableMap.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

/**
 * @dev Library for managing an enumerable variant of Solidity's
 * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]
 * type.
 *
 * Maps have the following properties:
 *
 * - Entries are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Entries are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableMap for EnumerableMap.UintToAddressMap;
 *
 *     // Declare a set state variable
 *     EnumerableMap.UintToAddressMap private myMap;
 * }
 * ```
 *
 * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are
 * supported.
 */
library EnumerableMap {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Map type with
    // bytes32 keys and values.
    // The Map implementation uses private functions, and user-facing
    // implementations (such as Uint256ToAddressMap) are just wrappers around
    // the underlying Map.
    // This means that we can only create new EnumerableMaps for types that fit
    // in bytes32.

    struct MapEntry {
        bytes32 _key;
        bytes32 _value;
    }

    struct Map {
        // Storage of map keys and values
        MapEntry[] _entries;

        // Position of the entry defined by a key in the `entries` array, plus 1
        // because index 0 means a key is not in the map.
        mapping (bytes32 => uint256) _indexes;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex == 0) { // Equivalent to !contains(map, key)
            map._entries.push(MapEntry({ _key: key, _value: value }));
            // The entry is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            map._indexes[key] = map._entries.length;
            return true;
        } else {
            map._entries[keyIndex - 1]._value = value;
            return false;
        }
    }

    /**
     * @dev Removes a key-value pair from a map. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function _remove(Map storage map, bytes32 key) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex != 0) { // Equivalent to contains(map, key)
            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one
            // in the array, and then remove the last entry (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = keyIndex - 1;
            uint256 lastIndex = map._entries.length - 1;

            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            MapEntry storage lastEntry = map._entries[lastIndex];

            // Move the last entry to the index where the entry to delete is
            map._entries[toDeleteIndex] = lastEntry;
            // Update the index for the moved entry
            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved entry was stored
            map._entries.pop();

            // Delete the index for the deleted slot
            delete map._indexes[key];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function _contains(Map storage map, bytes32 key) private view returns (bool) {
        return map._indexes[key] != 0;
    }

    /**
     * @dev Returns the number of key-value pairs in the map. O(1).
     */
    function _length(Map storage map) private view returns (uint256) {
        return map._entries.length;
    }

   /**
    * @dev Returns the key-value pair stored at position `index` in the map. O(1).
    *
    * Note that there are no guarantees on the ordering of entries inside the
    * array, and it may change when more entries are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {
        require(map._entries.length > index, "EnumerableMap: index out of bounds");

        MapEntry storage entry = map._entries[index];
        return (entry._key, entry._value);
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function _get(Map storage map, bytes32 key) private view returns (bytes32) {
        return _get(map, key, "EnumerableMap: nonexistent key");
    }

    /**
     * @dev Same as {_get}, with a custom error message when `key` is not in the map.
     */
    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {
        uint256 keyIndex = map._indexes[key];
        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)
        return map._entries[keyIndex - 1]._value; // All indexes are 1-based
    }

    // UintToAddressMap

    struct UintToAddressMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {
        return _set(map._inner, bytes32(key), bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {
        return _remove(map._inner, bytes32(key));
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {
        return _contains(map._inner, bytes32(key));
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(UintToAddressMap storage map) internal view returns (uint256) {
        return _length(map._inner);
    }

   /**
    * @dev Returns the element stored at position `index` in the set. O(1).
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (uint256(key), address(uint256(value)));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {
        return address(uint256(_get(map._inner, bytes32(key))));
    }

    /**
     * @dev Same as {get}, with a custom error message when `key` is not in the map.
     */
    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {
        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\EnumerableSet.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`
 * (`UintSet`) are supported.
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;

        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping (bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) { // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            bytes32 lastvalue = set._values[lastIndex];

            // Move the last value to the index where the value to delete is
            set._values[toDeleteIndex] = lastvalue;
            // Update the index for the moved value
            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        require(set._values.length > index, "EnumerableSet: index out of bounds");
        return set._values[index];
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint256(_at(set._inner, index)));
    }


    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts may inherit from this and call {_registerInterface} to declare
 * their support of an interface.
 */
abstract contract ERC165 is IERC165 {
    /*
     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7
     */
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /**
     * @dev Mapping of interface ids to whether or not it's supported.
     */
    mapping(bytes4 => bool) private _supportedInterfaces;

    constructor () {
        // Derived contracts need only register support for their own interfaces,
        // we register support for ERC165 itself here
        _registerInterface(_INTERFACE_ID_ERC165);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     *
     * Time complexity O(1), guaranteed to always use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    /**
     * @dev Registers the contract as an implementer of the interface defined by
     * `interfaceId`. Support of the actual ERC165 interface is automatic and
     * registering its interface id is not required.
     *
     * See {IERC165-supportsInterface}.
     *
     * Requirements:
     *
     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).
     */
    function _registerInterface(bytes4 interfaceId) internal virtual {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./IERC20.sol";
import "./extensions/IERC20Metadata.sol";
import "../../utils/Context.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        unchecked {
            _approve(sender, _msgSender(), currentAllowance - amount);
        }

        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `sender` to `recipient`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        _afterTokenTransfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ERC20Burnable.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import "../../GSN/Context.sol";
import "./ERC20.sol";

/**
 * @dev Extension of {ERC20} that allows token holders to destroy both their own
 * tokens and those that they have an allowance for, in a way that can be
 * recognized off-chain (via event analysis).
 */
abstract contract ERC20Burnable is Context, ERC20 {
    using SafeMath for uint256;

    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual {
        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");

        _approve(account, _msgSender(), decreasedAllowance);
        _burn(account, amount);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ERC20Mintable.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol";

abstract contract ERC20Mintable is ERC20Burnable, Ownable {
  constructor(string memory _name, string memory _symbol)
    ERC20(_name, _symbol) {
  }

  function mint(address to, uint256 amount) onlyOwner external {
    _mint(to, amount);
  }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ERC721.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import "../../GSN/Context.sol";
import "./IERC721.sol";
import "./IERC721Metadata.sol";
import "./IERC721Enumerable.sol";
import "./IERC721Receiver.sol";
import "../../introspection/ERC165.sol";
import "../../math/SafeMath.sol";
import "../../utils/Address.sol";
import "../../utils/EnumerableSet.sol";
import "../../utils/EnumerableMap.sol";
import "../../utils/Strings.sol";

/**
 * @title ERC721 Non-Fungible Token Standard basic implementation
 * @dev see https://eips.ethereum.org/EIPS/eip-721
 */
contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {
    using SafeMath for uint256;
    using Address for address;
    using EnumerableSet for EnumerableSet.UintSet;
    using EnumerableMap for EnumerableMap.UintToAddressMap;
    using Strings for uint256;

    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`
    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    // Mapping from holder address to their (enumerable) set of owned tokens
    mapping (address => EnumerableSet.UintSet) private _holderTokens;

    // Enumerable mapping from token ids to their owners
    EnumerableMap.UintToAddressMap private _tokenOwners;

    // Mapping from token ID to approved address
    mapping (uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Optional mapping for token URIs
    mapping (uint256 => string) private _tokenURIs;

    // Base URI
    string private _baseURI;

    /*
     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231
     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e
     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3
     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc
     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465
     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5
     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd
     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e
     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde
     *
     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^
     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd
     */
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /*
     *     bytes4(keccak256('name()')) == 0x06fdde03
     *     bytes4(keccak256('symbol()')) == 0x95d89b41
     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd
     *
     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f
     */
    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;

    /*
     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd
     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59
     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7
     *
     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63
     */
    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;

    /**
     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
     */
    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;

        // register the supported interfaces to conform to ERC721 via ERC165
        _registerInterface(_INTERFACE_ID_ERC721);
        _registerInterface(_INTERFACE_ID_ERC721_METADATA);
        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");

        return _holderTokens[owner].length();
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return _tokenOwners.get(tokenId, "ERC721: owner query for nonexistent token");
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        string memory _tokenURI = _tokenURIs[tokenId];

        // If there is no base URI, return the token URI.
        if (bytes(_baseURI).length == 0) {
            return _tokenURI;
        }
        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
        if (bytes(_tokenURI).length > 0) {
            return string(abi.encodePacked(_baseURI, _tokenURI));
        }
        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.
        return string(abi.encodePacked(_baseURI, tokenId.toString()));
    }

    /**
    * @dev Returns the base URI set via {_setBaseURI}. This will be
    * automatically added as a prefix in {tokenURI} to each token's URI, or
    * to the token ID if no specific URI is set for that token ID.
    */
    function baseURI() public view returns (string memory) {
        return _baseURI;
    }

    /**
     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {
        return _holderTokens[owner].at(index);
    }

    /**
     * @dev See {IERC721Enumerable-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds
        return _tokenOwners.length();
    }

    /**
     * @dev See {IERC721Enumerable-tokenByIndex}.
     */
    function tokenByIndex(uint256 index) public view override returns (uint256) {
        (uint256 tokenId, ) = _tokenOwners.at(index);
        return tokenId;
    }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721: approve caller is not owner nor approved for all"
        );

        _approve(to, tokenId);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != _msgSender(), "ERC721: approve to caller");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(address from, address to, uint256 tokenId) public virtual override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransfer(from, to, tokenId, _data);
    }

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * `_data` is additional data, it has no specified format and it is sent in call to `to`.
     *
     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
     * implement alternative mechanisms to perform token transfer, such as signature-based.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     * and stop existing when they are burned (`_burn`).
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _tokenOwners.contains(tokenId);
    }

    /**
     * @dev Returns whether `spender` is allowed to manage `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), "ERC721: operator query for nonexistent token");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    /**
     * @dev Safely mints `tokenId` and transfers it to `to`.
     *
     * Requirements:
     d*
     * - `tokenId` must not exist.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, "");
    }

    /**
     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
     */
    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId);

        _holderTokens[to].add(tokenId);

        _tokenOwners.set(tokenId, to);

        emit Transfer(address(0), to, tokenId);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId) internal virtual {
        address owner = ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        // Clear approvals
        _approve(address(0), tokenId);

        // Clear metadata (if any)
        if (bytes(_tokenURIs[tokenId]).length != 0) {
            delete _tokenURIs[tokenId];
        }

        _holderTokens[owner].remove(tokenId);

        _tokenOwners.remove(tokenId);

        emit Transfer(owner, address(0), tokenId);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
        require(to != address(0), "ERC721: transfer to the zero address");

        _beforeTokenTransfer(from, to, tokenId);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId);

        _holderTokens[from].remove(tokenId);
        _holderTokens[to].add(tokenId);

        _tokenOwners.set(tokenId, to);

        emit Transfer(from, to, tokenId);
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }

    /**
     * @dev Internal function to set the base URI for all token IDs. It is
     * automatically added as a prefix to the value returned in {tokenURI},
     * or to the token ID if {tokenURI} is empty.
     */
    function _setBaseURI(string memory baseURI_) internal virtual {
        _baseURI = baseURI_;
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
     * The call is not executed if the target address is not a contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
        private returns (bool)
    {
        if (!to.isContract()) {
            return true;
        }
        bytes memory returndata = to.functionCall(abi.encodeWithSelector(
            IERC721Receiver(to).onERC721Received.selector,
            _msgSender(),
            from,
            tokenId,
            _data
        ), "ERC721: transfer to non ERC721Receiver implementer");
        bytes4 retval = abi.decode(returndata, (bytes4));
        return (retval == _ERC721_RECEIVED);
    }

    function _approve(address to, uint256 tokenId) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, ``from``'s `tokenId` will be burned.
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ERC721Burnable.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import "../../GSN/Context.sol";
import "./ERC721.sol";

/**
 * @title ERC721 Burnable Token
 * @dev ERC721 Token that can be irreversibly burned (destroyed).
 */
abstract contract ERC721Burnable is Context, ERC721 {
    /**
     * @dev Burns `tokenId`. See {ERC721-_burn}.
     *
     * Requirements:
     *
     * - The caller must own `tokenId` or be an approved operator.
     */
    function burn(uint256 tokenId) public virtual {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721Burnable: caller is not owner nor approved");
        _burn(tokenId);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ERC721Mintable.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol";

abstract contract ERC721Mintable is ERC721Burnable, Ownable {
  constructor(string memory _name, string memory _symbol)
    ERC721(_name, _symbol) {
  }

  function mint(address to, uint256 tokenId) onlyOwner external {
    _mint(to, tokenId);
  }

  function transfer(address to, uint256 tokenId) external {
    _transfer(msg.sender, to, tokenId);
  }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ForeignChain.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "./Chain.sol";

/// @dev contract for foreign chains
contract ForeignChain is Chain {
    error NotSupported();

    /// @param _contractRegistry Registry address
    /// @param _padding required "space" between blocks in seconds
    /// @param _requiredSignatures number of required signatures for accepting consensus submission
    constructor(
        IRegistry _contractRegistry,
        uint32 _padding,
        uint16 _requiredSignatures,
        bool _allowForMixedType
    ) Chain(_contractRegistry, _padding, _requiredSignatures, _allowForMixedType) {
        // no additional configuration needed
    }

    /// @inheritdoc BaseChain
    function isForeign() external pure override returns (bool) {
        return true;
    }

    /// @inheritdoc Chain
    /// @notice this method is made to be compatible with MasterChain, but it does not return full data eg validators
    /// data will be missing.
    /// @return blockNumber `block.number`
    /// @return timePadding `this.padding`
    /// @return lastDataTimestamp timestamp for last submitted consensus
    /// @return lastId ID of last submitted consensus
    /// @return nextLeader will be always address(0)
    /// @return nextBlockId block ID for `block.timestamp + padding`
    /// @return validators array will be always empty
    /// @return powers array will be always empty
    /// @return locations array will be always empty
    /// @return staked total UMB staked by validators
    /// @return minSignatures `this.requiredSignatures`
    function getStatus() external view override returns(
        uint256 blockNumber,
        uint32 timePadding,
        uint32 lastDataTimestamp,
        uint32 lastId,
        address nextLeader,
        uint32 nextBlockId,
        address[] memory validators,
        uint256[] memory powers,
        string[] memory locations,
        uint256 staked,
        uint16 minSignatures
    ) {
        ConsensusData memory data = _consensusData;

        blockNumber = block.number;
        timePadding = data.padding;
        lastId = data.lastTimestamp;
        lastDataTimestamp = lastId;
        minSignatures = _REQUIRED_SIGNATURES;

        staked = stakingBank.totalSupply();
        uint256 numberOfValidators = 0;
        powers = new uint256[](numberOfValidators);
        validators = new address[](numberOfValidators);
        locations = new string[](numberOfValidators);
        nextLeader = address(0);

        unchecked {
            // we will not overflow with timestamp in a lifetime
            nextBlockId = lastId + data.padding + 1;
        }
    }

    function getLeaderIndex(uint256, uint256) public pure override returns (uint256) {
        revert NotSupported();
    }

    function getLeaderAddressAtTime(uint256) public pure override returns (address) {
        revert NotSupported();
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ForeignGate.sol
File type: .sol
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

import './OperatorHub.sol';
import './ERC721Mintable.sol';

contract ForeignGate is OperatorHub {
  uint64 constant PREFIX = 0x9da38c22b41d70ee; // random number

  constructor(HashStore _hashStore, uint8 requiredOperators_, address[] memory initialOperators)
    OperatorHub(_hashStore, requiredOperators_, initialOperators) {
  }

  function canMint(
    bytes32 transactionHash,
    address tokenContract,
    address recipient,
    uint256 value
  ) public view returns (bool) {
    require(tokenContract != address(0x0), "should provide a token contract");
    require(recipient != address(0x0), "should provide a recipient");
    require(value > 0, "should provide value");
    require(transactionHash > 0, "TX hash should be provided");

    bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));

    return !hashStore.hashes(hash);
  }

  function mint(
    bytes32 transactionHash,
    address tokenContract,
    address recipient,
    uint256 value,
    uint8[] memory v,
    bytes32[] memory r,
    bytes32[] memory s
  ) external {
    require(tokenContract != address(0x0), "should provide a token contract");
    require(value > 0, "should provide value");
    require(transactionHash > 0, "TX hash should be provided");
    require(recipient == msg.sender, "should be the recipient");

    bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));

    hashStore.addHash(hash);

    require(v.length > 0, "should provide signatures at least one signature");
    require(v.length == r.length, "should the same number of inputs for signatures (r)");
    require(v.length == s.length, "should the same number of inputs for signatures (s)");

    require(checkSignatures(hash, v.length, v, r, s) >= requiredOperators, "not enough signatures to proceed");

    ERC721Mintable(tokenContract).mint(recipient, value);

    emit LogMint(transactionHash, tokenContract, recipient, value);
  }

  /**
   * @dev Transfers ownership of the token contract to a new account (`newOwner`).
   * Can only be called by the current owner.
   */
  function transferTokenOwnership(address[] memory tokenContracts, address newOwner) public onlyOwner {
    for (uint i = 0; i < tokenContracts.length; i++) {
      Ownable tokenContract = Ownable(tokenContracts[i]);
      tokenContract.transferOwnership(newOwner);
    }
  }

  /**
   * @dev Transfers ownership of the token contract and HashStore to a new account (`newOwner`).
   * Can only be called by the current owner.
   */
  function migrate(address[] memory tokenContracts, address newOwner) public onlyOwner {
    transferTokenOwnership(tokenContracts, newOwner);
    transferHashStoreOwnership(newOwner);
  }

  event LogMint(bytes32 transactionHash, address tokenContract, address recipient, uint256 value);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\FullMath.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.0;

/// @title Contains 512-bit math functions
/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
/// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
library FullMath {
    /// @notice Calculates floor(a¡Áb¡Âdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        // 512-bit multiply [prod1 prod0] = a * b
        // Compute the product mod 2**256 and mod 2**256 - 1
        // then use the Chinese Remainder Theorem to reconstruct
        // the 512 bit result. The result is stored in two 256
        // variables such that product = prod1 * 2**256 + prod0
        uint256 prod0; // Least significant 256 bits of the product
        uint256 prod1; // Most significant 256 bits of the product
        assembly {
            let mm := mulmod(a, b, not(0))
            prod0 := mul(a, b)
            prod1 := sub(sub(mm, prod0), lt(mm, prod0))
        }

        // Handle non-overflow cases, 256 by 256 division
        if (prod1 == 0) {
            require(denominator > 0);
            assembly {
                result := div(prod0, denominator)
            }
            return result;
        }

        // Make sure the result is less than 2**256.
        // Also prevents denominator == 0
        require(denominator > prod1);

        ///////////////////////////////////////////////
        // 512 by 256 division.
        ///////////////////////////////////////////////

        // Make division exact by subtracting the remainder from [prod1 prod0]
        // Compute remainder using mulmod
        uint256 remainder;
        assembly {
            remainder := mulmod(a, b, denominator)
        }
        // Subtract 256 bit number from 512 bit number
        assembly {
            prod1 := sub(prod1, gt(remainder, prod0))
            prod0 := sub(prod0, remainder)
        }

        // Factor powers of two out of denominator
        // Compute largest power of two divisor of denominator.
        // Always >= 1.
        uint256 twos = -denominator & denominator;
        // Divide denominator by power of two
        assembly {
            denominator := div(denominator, twos)
        }

        // Divide [prod1 prod0] by the factors of two
        assembly {
            prod0 := div(prod0, twos)
        }
        // Shift in bits from prod1 into prod0. For this we need
        // to flip `twos` such that it is 2**256 / twos.
        // If twos is zero, then it becomes one
        assembly {
            twos := add(div(sub(0, twos), twos), 1)
        }
        prod0 |= prod1 * twos;

        // Invert denominator mod 2**256
        // Now that denominator is an odd number, it has an inverse
        // modulo 2**256 such that denominator * inv = 1 mod 2**256.
        // Compute the inverse by starting with a seed that is correct
        // correct for four bits. That is, denominator * inv = 1 mod 2**4
        uint256 inv = (3 * denominator) ^ 2;
        // Now use Newton-Raphson iteration to improve the precision.
        // Thanks to Hensel's lifting lemma, this also works in modular
        // arithmetic, doubling the correct bits in each step.
        inv *= 2 - denominator * inv; // inverse mod 2**8
        inv *= 2 - denominator * inv; // inverse mod 2**16
        inv *= 2 - denominator * inv; // inverse mod 2**32
        inv *= 2 - denominator * inv; // inverse mod 2**64
        inv *= 2 - denominator * inv; // inverse mod 2**128
        inv *= 2 - denominator * inv; // inverse mod 2**256

        // Because the division is now exact we can divide by multiplying
        // with the modular inverse of denominator. This will give us the
        // correct result modulo 2**256. Since the precoditions guarantee
        // that the outcome is less than 2**256, this is the final result.
        // We don't need to compute the high bits of the result and prod1
        // is no longer required.
        result = prod0 * inv;
        return result;
    }

    /// @notice Calculates ceil(a¡Áb¡Âdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    function mulDivRoundingUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        result = mulDiv(a, b, denominator);
        if (mulmod(a, b, denominator) > 0) {
            require(result < type(uint256).max);
            result++;
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\HashStore.sol
File type: .sol
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import "@openzeppelin/contracts/access/Ownable.sol";

contract HashStore is Ownable {
  mapping(bytes32 => bool) public hashes;

  function addHash(bytes32 key) external onlyOwner {
    require(!hashes[key], "cannot add a hash again");

    hashes[key] = true;
  }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\HomeGate.sol
File type: .sol
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import './OperatorHub.sol';
import './ERC721Mintable.sol';

contract HomeGate is OperatorHub {
  uint64 constant PREFIX = 0xef4810cde406e3f5; // random number

  constructor(HashStore _hashStore, uint8 requiredOperators, address[] memory initialOperators)
    OperatorHub(_hashStore, requiredOperators, initialOperators) {
  }

  function canWithdraw(
    bytes32 transactionHash,
    address tokenContract,
    address recipient,
    uint256 value
  ) public view returns (bool) {
    require(tokenContract != address(0x0), "should provide a token contract");
    require(recipient != address(0x0), "should provide a recipient");
    require(value > 0, "should provide value");
    require(transactionHash > 0, "TX hash should be provided");

    bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));

    return !hashStore.hashes(hash);
  }

  function withdraw(
    bytes32 transactionHash,
    address tokenContract,
    address recipient,
    uint256 value,
    uint8[] memory v,
    bytes32[] memory r,
    bytes32[] memory s
  ) external {
    require(tokenContract != address(0x0), "should provide a token contract");
    require(value > 0, "should provide value");
    require(transactionHash > 0, "TX hash should be provided");
    require(recipient == msg.sender, "should be the recipient");

    bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));

    hashStore.addHash(hash);

    require(v.length > 0, "should provide signatures at least one signature");
    require(v.length == r.length, "should the same number of inputs for signatures (r)");
    require(v.length == s.length, "should the same number of inputs for signatures (s)");

    require(checkSignatures(hash, v.length, v, r, s) >= requiredOperators, "not enough signatures to proceed");

    ERC721Mintable(tokenContract).transfer(recipient, value);

    LogWithdraw(transactionHash, tokenContract, recipient, value);
  }

  /**
   * @dev Transfers tokens to the new HomeGate contract
   * Can only be called by the current owner.
   */
  function transferTokens(address[] memory tokenContracts, address recipient) public onlyOwner {
    for (uint i = 0; i < tokenContracts.length; i++) {
      ERC721Mintable tokenContract = ERC721Mintable(tokenContracts[i]);
      tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
    }
  }

  /**
   * @dev Transfers tokens of the token contract and HashStore to a new account (`newOwner`).
   * Can only be called by the current owner.
   */
  function migrate(address[] memory tokenContracts, address newOwner) public onlyOwner {
    transferTokens(tokenContracts, newOwner);
    transferHashStoreOwnership(newOwner);
  }

  event LogWithdraw(bytes32 transactionHash, address tokenContract, address recipient, uint256 value);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IBaseChainV1.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IBaseChainV1 {
    /// @dev number of blocks (consensus rounds) saved in this contract
    function blocksCount() external returns (uint32);

    /// @dev number of all blocks that were generated before switching to this contract
    /// please note, that there might be a gap of one block when we switching from old to new contract
    /// see constructor for details
    function blocksCountOffset() external returns (uint32);

    function getLatestBlockId() external view returns (uint32);

    function getBlockTimestamp(uint32 _blockId) external view returns (uint32);

    function getStatus() external view returns (
        uint256 blockNumber,
        uint16 timePadding,
        uint32 lastDataTimestamp,
        uint32 lastId,
        uint32 nextBlockId
    );
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IBurnableToken.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

interface IBurnableToken {
    function burn(uint256 _amount) external;
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IERC20LikeV2.sol
File type: .sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity >=0.7.6;

/// @dev This is only meant to be used by price providers, which use a different
/// Solidity version than the rest of the codebase. This way de won't need to include
/// an additional version of OpenZeppelin's library.
interface IERC20LikeV2 {
    function decimals() external view returns (uint8);
    function balanceOf(address) external view returns(uint256);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IERC20Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IERC721.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import "../../introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    /**
      * @dev Safely transfers `tokenId` token from `from` to `to`.
      *
      * Requirements:
      *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
      * - `tokenId` token must exist and be owned by `from`.
      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
      *
      * Emits a {Transfer} event.
      */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IERC721Enumerable.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import "./IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Enumerable is IERC721 {

    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);

    /**
     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
     * Use along with {totalSupply} to enumerate all tokens.
     */
    function tokenByIndex(uint256 index) external view returns (uint256);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IERC721Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import "./IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {

    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IERC721Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
     */
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)
    external returns (bytes4);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IMigrationReceiver.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity >=0.7.5 <0.9.0;

/// @dev when modifying this contract, please copy all to MigrationPoolsV8
interface IMigrationReceiver {

    /// @dev should use onlyPool modifier
    ///         this method is responsible for "accepting" tokens from other pool to our
    function migrateTokenCallback(address _token, address _user, uint256 _amount, bytes calldata _data) external;
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IPriceProvider.sol
File type: .sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity >=0.7.6 <0.9.0;

/// @title Common interface for Silo Price Providers
interface IPriceProvider {
    /// @notice Returns "Time-Weighted Average Price" for an asset. Calculates TWAP price for quote/asset.
    /// It unifies all tokens decimal to 18, examples:
    /// - if asses == quote it returns 1e18
    /// - if asset is USDC and quote is ETH and ETH costs ~$3300 then it returns ~0.0003e18 WETH per 1 USDC
    /// @param _asset address of an asset for which to read price
    /// @return price of asses with 18 decimals, throws when pool is not ready yet to provide price
    function getPrice(address _asset) external view returns (uint256 price);

    /// @dev Informs if PriceProvider is setup for asset. It does not means PriceProvider can provide price right away.
    /// Some providers implementations need time to "build" buffer for TWAP price,
    /// so price may not be available yet but this method will return true.
    /// @param _asset asset in question
    /// @return TRUE if asset has been setup, otherwise false
    function assetSupported(address _asset) external view returns (bool);

    /// @notice Gets token address in which prices are quoted
    /// @return quoteToken address
    function quoteToken() external view returns (address);

    /// @notice Helper method that allows easily detects, if contract is PriceProvider
    /// @dev this can save us from simple human errors, in case we use invalid address
    /// but this should NOT be treated as security check
    /// @return always true
    function priceProviderPing() external pure returns (bytes4);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IPriceProvidersRepository.sol
File type: .sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity >=0.7.6 <0.9.0;

import "./IPriceProvider.sol";

interface IPriceProvidersRepository {
    /// @notice Emitted when price provider is added
    /// @param newPriceProvider new price provider address
    event NewPriceProvider(IPriceProvider indexed newPriceProvider);

    /// @notice Emitted when price provider is removed
    /// @param priceProvider removed price provider address
    event PriceProviderRemoved(IPriceProvider indexed priceProvider);

    /// @notice Emitted when asset is assigned to price provider
    /// @param asset assigned asset   address
    /// @param priceProvider price provider address
    event PriceProviderForAsset(address indexed asset, IPriceProvider indexed priceProvider);

    /// @notice Register new price provider
    /// @param _priceProvider address of price provider
    function addPriceProvider(IPriceProvider _priceProvider) external;

    /// @notice Unregister price provider
    /// @param _priceProvider address of price provider to be removed
    function removePriceProvider(IPriceProvider _priceProvider) external;

    /// @notice Sets price provider for asset
    /// @dev Request for asset price is forwarded to the price provider assigned to that asset
    /// @param _asset address of an asset for which price provider will be used
    /// @param _priceProvider address of price provider
    function setPriceProviderForAsset(address _asset, IPriceProvider _priceProvider) external;

    /// @notice Returns "Time-Weighted Average Price" for an asset
    /// @param _asset address of an asset for which to read price
    /// @return price TWAP price of a token with 18 decimals
    function getPrice(address _asset) external view returns (uint256 price);

    /// @notice Gets price provider assigned to an asset
    /// @param _asset address of an asset for which to get price provider
    /// @return priceProvider address of price provider
    function priceProviders(address _asset) external view returns (IPriceProvider priceProvider);

    /// @notice Gets token address in which prices are quoted
    /// @return quoteToken address
    function quoteToken() external view returns (address);

    /// @notice Gets manager role address
    /// @return manager role address
    function manager() external view returns (address);

    /// @notice Checks if providers are available for an asset
    /// @param _asset asset address to check
    /// @return returns TRUE if price feed is ready, otherwise false
    function providersReadyForAsset(address _asset) external view returns (bool);

    /// @notice Returns true if address is a registered price provider
    /// @param _provider address of price provider to be removed
    /// @return true if address is a registered price provider, otherwise false
    function isPriceProvider(IPriceProvider _provider) external view returns (bool);

    /// @notice Gets number of price providers registered
    /// @return number of price providers registered
    function providersCount() external view returns (uint256);

    /// @notice Gets an array of price providers
    /// @return array of price providers
    function providerList() external view returns (address[] memory);

    /// @notice Sanity check function
    /// @return returns always TRUE
    function priceProvidersRepositoryPing() external pure returns (bytes4);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IRegistry.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.6.8;


interface IRegistry {
    function getAddress(bytes32 name) external view returns (address);

    function requireAndGetAddress(bytes32 name) external view returns (address);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IStakingBank.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.8;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IStakingBank is IERC20 {
  function receiveApproval(address _from) external returns (bool success);

  function withdraw(uint256 _value) external returns (bool success);

  function create(address _id, string calldata _location) external;

  function update(address _id, string calldata _location) external;

  function addresses(uint256 _ix) external view returns (address);

  function validators(address _id) external view returns (address id, string memory location);

  function getNumberOfValidators() external view returns (uint256);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IStakingRewards.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;


interface IStakingRewards {
    // Mutative
    function stake(uint256 amount) external;

    function withdraw(uint256 amount) external;

    function getReward() external;

    function exit() external;
    // Views
    function lastTimeRewardApplicable() external view returns (uint256);

    function rewardPerToken() external view returns (uint256);

    function earned(address account) external view returns (uint256);

    function getRewardForDuration() external view returns (uint256);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ISwapReceiver.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

interface ISwapReceiver {
    function swapMint(address _holder, uint256 _amount) external;
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IUniswapV3Pool.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

import './pool/IUniswapV3PoolImmutables.sol';
import './pool/IUniswapV3PoolState.sol';
import './pool/IUniswapV3PoolDerivedState.sol';
import './pool/IUniswapV3PoolActions.sol';
import './pool/IUniswapV3PoolOwnerActions.sol';
import './pool/IUniswapV3PoolEvents.sol';

/// @title The interface for a Uniswap V3 Pool
/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
/// to the ERC20 specification
/// @dev The pool interface is broken up into many smaller pieces
interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState,
    IUniswapV3PoolDerivedState,
    IUniswapV3PoolActions,
    IUniswapV3PoolOwnerActions,
    IUniswapV3PoolEvents
{

}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IUniswapV3PoolActions.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Permissionless pool actions
/// @notice Contains pool methods that can be called by anyone
interface IUniswapV3PoolActions {
    /// @notice Sets the initial price for the pool
    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
    function initialize(uint160 sqrtPriceX96) external;

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Swap token0 for token1, or token1 for token0
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1);

    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
    /// with 0 amount{0,1} and sending the donation amount(s) from the callback
    /// @param recipient The address which will receive the token0 and token1 amounts
    /// @param amount0 The amount of token0 to send
    /// @param amount1 The amount of token1 to send
    /// @param data Any data to be passed through to the callback
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;

    /// @notice Increase the maximum number of price and liquidity observations that this pool will store
    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
    /// the input observationCardinalityNext.
    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IUniswapV3PoolDerivedState.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that is not stored
/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
/// blockchain. The functions here may have variable gas costs.
interface IUniswapV3PoolDerivedState {
    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgos = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgos)
        external
        view
        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);

    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
    /// snapshot is taken and the second snapshot is taken.
    /// @param tickLower The lower tick of the range
    /// @param tickUpper The upper tick of the range
    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
    /// @return secondsInside The snapshot of seconds per liquidity for the range
    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
        external
        view
        returns (
            int56 tickCumulativeInside,
            uint160 secondsPerLiquidityInsideX128,
            uint32 secondsInside
        );
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IUniswapV3PoolEvents.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Events emitted by a pool
/// @notice Contains all events emitted by the pool
interface IUniswapV3PoolEvents {
    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
    event Initialize(uint160 sqrtPriceX96, int24 tick);

    /// @notice Emitted when liquidity is minted for a given position
    /// @param sender The address that minted the liquidity
    /// @param owner The owner of the position and recipient of any minted liquidity
    /// @param tickLower The lower tick of the position
    /// @param tickUpper The upper tick of the position
    /// @param amount The amount of liquidity minted to the position range
    /// @param amount0 How much token0 was required for the minted liquidity
    /// @param amount1 How much token1 was required for the minted liquidity
    event Mint(
        address sender,
        address indexed owner,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount,
        uint256 amount0,
        uint256 amount1
    );

    /// @notice Emitted when fees are collected by the owner of a position
    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
    /// @param owner The owner of the position for which fees are collected
    /// @param tickLower The lower tick of the position
    /// @param tickUpper The upper tick of the position
    /// @param amount0 The amount of token0 fees collected
    /// @param amount1 The amount of token1 fees collected
    event Collect(
        address indexed owner,
        address recipient,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount0,
        uint128 amount1
    );

    /// @notice Emitted when a position's liquidity is removed
    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
    /// @param owner The owner of the position for which liquidity is removed
    /// @param tickLower The lower tick of the position
    /// @param tickUpper The upper tick of the position
    /// @param amount The amount of liquidity to remove
    /// @param amount0 The amount of token0 withdrawn
    /// @param amount1 The amount of token1 withdrawn
    event Burn(
        address indexed owner,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount,
        uint256 amount0,
        uint256 amount1
    );

    /// @notice Emitted by the pool for any swaps between token0 and token1
    /// @param sender The address that initiated the swap call, and that received the callback
    /// @param recipient The address that received the output of the swap
    /// @param amount0 The delta of the token0 balance of the pool
    /// @param amount1 The delta of the token1 balance of the pool
    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
    /// @param liquidity The liquidity of the pool after the swap
    /// @param tick The log base 1.0001 of price of the pool after the swap
    event Swap(
        address indexed sender,
        address indexed recipient,
        int256 amount0,
        int256 amount1,
        uint160 sqrtPriceX96,
        uint128 liquidity,
        int24 tick
    );

    /// @notice Emitted by the pool for any flashes of token0/token1
    /// @param sender The address that initiated the swap call, and that received the callback
    /// @param recipient The address that received the tokens from flash
    /// @param amount0 The amount of token0 that was flashed
    /// @param amount1 The amount of token1 that was flashed
    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
    event Flash(
        address indexed sender,
        address indexed recipient,
        uint256 amount0,
        uint256 amount1,
        uint256 paid0,
        uint256 paid1
    );

    /// @notice Emitted by the pool for increases to the number of observations that can be stored
    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
    /// just before a mint/swap/burn.
    /// @param observationCardinalityNextOld The previous value of the next observation cardinality
    /// @param observationCardinalityNextNew The updated value of the next observation cardinality
    event IncreaseObservationCardinalityNext(
        uint16 observationCardinalityNextOld,
        uint16 observationCardinalityNextNew
    );

    /// @notice Emitted when the protocol fee is changed by the pool
    /// @param feeProtocol0Old The previous value of the token0 protocol fee
    /// @param feeProtocol1Old The previous value of the token1 protocol fee
    /// @param feeProtocol0New The updated value of the token0 protocol fee
    /// @param feeProtocol1New The updated value of the token1 protocol fee
    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);

    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
    /// @param sender The address that collects the protocol fees
    /// @param recipient The address that receives the collected protocol fees
    /// @param amount0 The amount of token0 protocol fees that is withdrawn
    /// @param amount0 The amount of token1 protocol fees that is withdrawn
    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IUniswapV3PoolImmutables.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that never changes
/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
interface IUniswapV3PoolImmutables {
    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
    /// @return The contract address
    function factory() external view returns (address);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view returns (int24);

    /// @notice The maximum amount of position liquidity that can use any tick in the range
    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
    /// @return The max amount of liquidity per tick
    function maxLiquidityPerTick() external view returns (uint128);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IUniswapV3PoolOwnerActions.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Permissioned pool actions
/// @notice Contains pool methods that may only be called by the factory owner
interface IUniswapV3PoolOwnerActions {
    /// @notice Set the denominator of the protocol's % share of the fees
    /// @param feeProtocol0 new protocol fee for token0 of the pool
    /// @param feeProtocol1 new protocol fee for token1 of the pool
    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;

    /// @notice Collect the protocol fee accrued to the pool
    /// @param recipient The address to which collected protocol fees should be sent
    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
    /// @return amount0 The protocol fee collected in token0
    /// @return amount1 The protocol fee collected in token1
    function collectProtocol(
        address recipient,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\IUniswapV3PoolState.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that can change
/// @notice These methods compose the pool's state, and can change with any frequency including multiple times
/// per transaction
interface IUniswapV3PoolState {
    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal0X128() external view returns (uint256);

    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal1X128() external view returns (uint256);

    /// @notice The amounts of token0 and token1 that are owed to the protocol
    /// @dev Protocol fees will never exceed uint128 max in either token
    function protocolFees() external view returns (uint128 token0, uint128 token1);

    /// @notice The currently in range liquidity available to the pool
    /// @dev This value has no relationship to the total liquidity across all ticks
    function liquidity() external view returns (uint128);

    /// @notice Look up information about a specific tick in the pool
    /// @param tick The tick to look up
    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
    /// tick upper,
    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
    /// a specific position.
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @notice Returns data about a specific observation index
    /// @param index The element of the observations array to fetch
    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
    /// ago, rather than at a specific index in the array.
    /// @return blockTimestamp The timestamp of the observation,
    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
    /// Returns initialized whether the observation has been initialized and the values are safe to use
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\LinearVesting.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;


// Inheritance
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/Owned.sol";

/// @title   Umbrella Rewards contract
/// @author  umb.network
/// @notice  This contract serves TOKEN DISTRIBUTION AT LAUNCH for:
///           - node, founders, early contributors etc...
///          It can be used for future distributions for next milestones also
///          as its functionality stays the same.
///          It supports linear vesting
/// @dev     Deploy contract. Mint tokens reward for this contract.
///          Then as owner call .setupDistribution() and then start()
contract LinearVesting is Owned {
    using SafeMath for uint256;

    struct Reward {
        uint256 total;
        uint256 duration;
        uint256 paid;
        uint256 startTime;
    }

    uint8 public constant VERSION = 2;

    IERC20 public immutable umbToken;
    uint256 public totalVestingAmount;

    mapping(address => Reward) public rewards;

    // ========== EVENTS ========== //

    event LogSetup(uint256 prevSum, uint256 newSum);
    event LogClaimed(address indexed recipient, uint256 amount);

    // ========== CONSTRUCTOR ========== //

    constructor(address _owner, address _token) Owned(_owner) {
        require(_token != address(0x0), "empty _token");

        umbToken = IERC20(_token);
    }

    // ========== MUTATIVE FUNCTIONS ========== //

    function claim() external {
        _claim(msg.sender);
    }

    function claimFor(address[] calldata _participants) external {
        for (uint i = 0; i < _participants.length; i++) {
            _claim(_participants[i]);
        }
    }

    // ========== RESTRICTED FUNCTIONS ========== //

    function addRewards(
        address[] calldata _participants,
        uint256[] calldata _rewards,
        uint256[] calldata _durations,
        uint256[] calldata _startTimes
    )
    external onlyOwner {
        require(_participants.length != 0, "there is no _participants");
        require(_participants.length == _rewards.length, "_participants count must match _rewards count");
        require(_participants.length == _durations.length, "_participants count must match _durations count");
        require(_participants.length == _startTimes.length, "_participants count must match _startTimes count");

        uint256 sum = totalVestingAmount;

        for (uint256 i = 0; i < _participants.length; i++) {
            require(_participants[i] != address(0x0), "empty participant");
            require(_durations[i] != 0, "empty duration");
            require(_durations[i] < 5 * 365 days, "duration too long");
            require(_rewards[i] != 0, "empty reward");
            require(_startTimes[i] != 0, "empty startTime");

            uint256 total = rewards[_participants[i]].total;

            if (total < _rewards[i]) {
                // we increased existing reward, so sum will be higher
                sum = sum.add(_rewards[i] - total);
            } else {
                // we decreased existing reward, so sum will be lower
                sum = sum.sub(total - _rewards[i]);
            }

            if (total != 0) {
                // updating existing
                require(rewards[_participants[i]].startTime == _startTimes[i], "can't change start time");
                require(
                    _rewards[i] >= balanceOf(_participants[i]) + rewards[_participants[i]].paid,
                        "can't take what's already done"
                );

                rewards[_participants[i]].total = _rewards[i];
                rewards[_participants[i]].duration = _durations[i];
            } else {
                // new participant
                rewards[_participants[i]] = Reward(_rewards[i], _durations[i], 0, _startTimes[i]);
            }
        }

        emit LogSetup(totalVestingAmount, sum);
        totalVestingAmount = sum;
    }

    // ========== VIEWS ========== //

    function balanceOf(address _address) public view returns (uint256) {
        Reward memory reward = rewards[_address];

        if (block.timestamp <= reward.startTime) {
            return 0;
        }

        if (block.timestamp >= reward.startTime.add(reward.duration)) {
            return reward.total - reward.paid;
        }

        return reward.total.mul(block.timestamp - reward.startTime).div(reward.duration) - reward.paid;
    }

    // ========== INTERNAL ========== //

    function _claim(address _participant) internal {
        uint256 balance = balanceOf(_participant);
        require(balance != 0, "you have no tokens to claim");

        // no need for safe math because sum was calculated using safeMath
        rewards[_participant].paid += balance;

        // this is our token, we can save gas and simple use transfer instead safeTransfer
        require(umbToken.transfer(_participant, balance), "umb.transfer failed");

        emit LogClaimed(_participant, balance);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\LockSettings.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "@openzeppelin/contracts/access/Ownable.sol";

abstract contract LockSettings is Ownable {
    /// @dev decimals for: baseRate, APY, multipliers
    ///         eg for baseRate: 1e6 is 1%, 50e6 is 50%
    ///         eg for multipliers: 1e6 is 1.0x, 3210000 is 3.21x
    uint256 public constant RATE_DECIMALS = 10 ** 6;
    uint256 public constant MAX_MULTIPLIER = 5 * RATE_DECIMALS;

    /// @notice token => period => multiplier
    mapping(address => mapping(uint256 => uint256)) public multipliers;

    /// @notice token => period => index in periods array
    mapping(address => mapping(uint256 => uint256)) public periodIndexes;

    /// @notice token => periods
    mapping(address => uint256[]) public periods;

    event TokenSettings(address indexed token, uint256 period, uint256 multiplier);

    function removePeriods(address _token, uint256[] calldata _periods) external onlyOwner {
        for (uint256 i; i < _periods.length; i++) {
            if (_periods[i] == 0) revert("InvalidSettings");

            multipliers[_token][_periods[i]] = 0;
            _removePeriod(_token, _periods[i]);

            emit TokenSettings(_token, _periods[i], 0);
        }
    }

    // solhint-disable-next-line code-complexity
    function setLockingTokenSettings(address _token, uint256[] calldata _periods, uint256[] calldata _multipliers)
        external
        onlyOwner
    {
        if (_periods.length == 0) revert("EmptyPeriods");
        if (_periods.length != _multipliers.length) revert("ArraysNotMatch");

        for (uint256 i; i < _periods.length; i++) {
            if (_periods[i] == 0) revert("InvalidSettings");
            if (_multipliers[i] < RATE_DECIMALS) revert("multiplier must be >= 1e6");
            if (_multipliers[i] > MAX_MULTIPLIER) revert("multiplier overflow");

            multipliers[_token][_periods[i]] = _multipliers[i];
            emit TokenSettings(_token, _periods[i], _multipliers[i]);

            if (_multipliers[i] == 0) _removePeriod(_token, _periods[i]);
            else _addPeriod(_token, _periods[i]);
        }
    }

    function periodsCount(address _token) external view returns (uint256) {
        return periods[_token].length;
    }

    function getPeriods(address _token) external view returns (uint256[] memory) {
        return periods[_token];
    }

    function _addPeriod(address _token, uint256 _period) internal {
        uint256 key = periodIndexes[_token][_period];
        if (key != 0) return;

        periods[_token].push(_period);
        // periodIndexes are starting from 1, not from 0
        periodIndexes[_token][_period] = periods[_token].length;
    }

    function _removePeriod(address _token, uint256 _period) internal {
        uint256 key = periodIndexes[_token][_period];
        if (key == 0) return;

        periods[_token][key - 1] = periods[_token][periods[_token].length - 1];
        periodIndexes[_token][_period] = 0;
        periods[_token].pop();
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Math.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\MerkleProof.sol
File type: .sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (utils/cryptography/MerkleProof.sol)

pragma solidity ^0.8.0;

/**
 * @dev These functions deal with verification of Merkle Trees proofs.
 *
 * The proofs can be generated using the JavaScript library
 * https://github.com/miguelmota/merkletreejs[merkletreejs].
 * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
 *
 * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
 *
 * WARNING: You should avoid using leaf values that are 64 bytes long prior to
 * hashing, or use a hash function other than keccak256 for hashing leaves.
 * This is because the concatenation of a sorted pair of internal nodes in
 * the merkle tree could be reinterpreted as a leaf value.
 */
library MerkleProof {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProof(proof, leaf) == root;
    }

    /**
     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
     * hash matches the root of the tree. When processing the proof, the pairs
     * of leafs & pre-images are assumed to be sorted.
     *
     * _Available since v4.4._
     */
    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = _efficientHash(computedHash, proofElement);
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = _efficientHash(proofElement, computedHash);
            }
        }
        return computedHash;
    }

    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
            value := keccak256(0x00, 0x40)
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\MintableToken.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import "../interfaces/Owned.sol";
import "../interfaces/IBurnableToken.sol";

/// @author  umb.network
abstract contract MintableToken is Owned, ERC20, IBurnableToken {
    uint256 public immutable maxAllowedTotalSupply;
    uint256 public everMinted;

    modifier assertMaxSupply(uint256 _amountToMint) {
        _assertMaxSupply(_amountToMint);
        _;
    }

    // ========== CONSTRUCTOR ========== //

    constructor (uint256 _maxAllowedTotalSupply) {
        require(_maxAllowedTotalSupply != 0, "_maxAllowedTotalSupply is empty");

        maxAllowedTotalSupply = _maxAllowedTotalSupply;
    }

    // ========== MUTATIVE FUNCTIONS ========== //

    function burn(uint256 _amount) override external {
        _burn(msg.sender, _amount);
    }

    // ========== RESTRICTED FUNCTIONS ========== //

    function mint(address _holder, uint256 _amount)
        virtual
        external
        onlyOwner()
        assertMaxSupply(_amount)
    {
        require(_amount != 0, "zero amount");

        _mint(_holder, _amount);
    }

    function _assertMaxSupply(uint256 _amountToMint) internal {
        uint256 everMintedTotal = everMinted + _amountToMint;
        everMinted = everMintedTotal;
        require(everMintedTotal <= maxAllowedTotalSupply, "total supply limit exceeded");
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\NFTRewards.sol
File type: .sol
/**
 *Submitted for verification at Etherscan.io on 2021-02-12
*/

// File: @openzeppelin/contracts/math/SafeMath.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the substraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryDiv}.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol


pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @openzeppelin/contracts/introspection/IERC165.sol


pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol


pragma solidity >=0.6.2 <0.8.0;


/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) external view returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
}

// File: @openzeppelin/contracts/utils/Address.sol


pragma solidity >=0.6.2 <0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol


pragma solidity >=0.6.0 <0.8.0;




/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// File: @openzeppelin/contracts/utils/Context.sol


pragma solidity >=0.6.0 <0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/access/Ownable.sol


pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: contracts/interfaces/IBurnableToken.sol

pragma solidity 0.7.5;

interface IBurnableToken {
    function burn(uint256 _amount) external;
}

// File: contracts/NFTRewards.sol

pragma solidity 0.7.5;

// Inheritance







/// @title   UMB to NFT swapping contract
/// @author  umb.network
contract NFTRewards is Ownable {
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    address public umbToken;
    address public leftoverReceiver;
    uint256 public multiplier;
    uint256 public rewardsDeadline;

    mapping(address => uint) public balances;

    constructor(address _umbToken, address _leftoverReceiver) {
        require(_umbToken != address(0x0), "should be non-null UMB token address");
        require(_leftoverReceiver != address(0x0), "should be non-null leftoverReceiver address");

        umbToken = _umbToken;
        leftoverReceiver = _leftoverReceiver;
    }

    function balanceOf(address _addr) view public returns(uint256) {
        return balances[_addr].mul(multiplier);
    }

    function startRewards(
        uint _multiplier,
        address[] calldata _addresses,
        uint[] calldata _balances,
        uint _duration
    ) external onlyOwner {
        require(_duration > 0, "duration should be positive");
        require(rewardsDeadline == 0, "can start rewards one time");
        require(_multiplier > 0, "multiplier must be positive");
        require(_addresses.length > 0, "should be at least 1 address");
        require(_addresses.length == _balances.length, "should be the same number of addresses and balances");

        for (uint i = 0; i < _addresses.length; i++) {
            balances[_addresses[i]] = _balances[i];
        }

        multiplier = _multiplier;
        rewardsDeadline = block.timestamp + _duration;
    }

    function close() external {
        require(block.timestamp > rewardsDeadline, "cannot close the contract right now");

        uint umbBalance = IERC20(umbToken).balanceOf(address(this));

        if (umbBalance > 0) {
            require(IERC20(umbToken).transfer(leftoverReceiver, umbBalance), "transfer failed");
        }

        selfdestruct(msg.sender);
    }

    function claimUMB() external {
        uint nftAmount = balances[msg.sender];
        require(nftAmount > 0, "amount should be positive");

        balances[msg.sender] = 0;

        uint umbAmount = nftAmount.mul(multiplier);

        IERC20(umbToken).safeTransfer(msg.sender, umbAmount);

        emit Claimed(msg.sender, nftAmount, umbAmount);
    }

    event Claimed(
        address indexed receiver,
        uint nftAmount,
        uint umbAmount);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\OnDemandToken.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "./MintableToken.sol";

abstract contract OnDemandToken is MintableToken {
    bool constant public ON_DEMAND_TOKEN = true;

    mapping (address => bool) public minters;

    event SetupMinter(address minter, bool active);

    modifier onlyOwnerOrMinter() {
        address msgSender = _msgSender();
        require(owner() == msgSender || minters[msgSender], "access denied");

        _;
    }

    function setupMinter(address _minter, bool _active) external onlyOwner() {
        minters[_minter] = _active;
        emit SetupMinter(_minter, _active);
    }

    function setupMinters(address[] calldata _minters, bool[] calldata _actives) external onlyOwner() {
        for (uint256 i; i < _minters.length; i++) {
            minters[_minters[i]] = _actives[i];
            emit SetupMinter(_minters[i], _actives[i]);
        }
    }

    function mint(address _holder, uint256 _amount)
        external
        virtual
        override
        onlyOwnerOrMinter()
        assertMaxSupply(_amount)
    {
        require(_amount != 0, "zero amount");

        _mint(_holder, _amount);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\OnDemandTokenBridgable.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "./OnDemandToken.sol";

abstract contract OnDemandTokenBridgable is OnDemandToken {
    mapping (address => bool) public bridges;

    event SetupBridge(address bridge, bool active);

    function setupBridge(address _bridge, bool _active) external onlyOwner() {
        bridges[_bridge] = _active;
        emit SetupBridge(_bridge, _active);
    }

    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal virtual override {
        if (_from != address(0) && _to != address(0) && bridges[msg.sender]) {
            uint256 balance = balanceOf(msg.sender);

            if (balance < _amount) {
                uint256 amountToMint = _amount - balance;
                _assertMaxSupply(amountToMint);
                _mint(msg.sender, amountToMint);
            }
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\OperatorHub.sol
File type: .sol
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import "@openzeppelin/contracts/access/Ownable.sol";

import './HashStore.sol';

contract OperatorHub is Ownable {
  bytes constant public ETH_PREFIX = "\x19Ethereum Signed Message:\n32";

  uint constant public MIN_REQUIRED_OPERATORS = 2;

  uint8 public requiredOperators;

  mapping(address => bool) public operators;

  mapping(address => string) public operatorLocation;

  address[] public operatorList;

  HashStore public immutable hashStore;

  constructor(HashStore _hashStore, uint8 _requiredOperators, address[] memory initialOperators) {
    require(_requiredOperators != 0, "should provide the number of required operators");
    require(initialOperators.length >= _requiredOperators, "should provide more operators");
    require(_requiredOperators >= MIN_REQUIRED_OPERATORS, "should be greater than the minimum number of required operators");

    for (uint i = 0; i < initialOperators.length; i++) {
      addOperator(initialOperators[i]);
    }

    if (_hashStore == HashStore(0x0)) {
      _hashStore = new HashStore();
    }

    hashStore = _hashStore;

    setRequiredOperators(_requiredOperators);
  }

  function addOperator(address operator) public onlyOwner {
    require(operator != address(0));
    require(!operators[operator], "cannot add the same operator twice");
    operators[operator] = true;
    operatorList.push(operator);

    emit OperatorAdded(operator);
  }

  /**
   * @dev Transfers ownership of the HashStore contract to a new account (`newOwner`).
   * Can only be called by the current owner.
   */
  function transferHashStoreOwnership(address newOwner) public onlyOwner {
    hashStore.transferOwnership(newOwner);
  }

  function removeOperator(address operator) public onlyOwner {
    require(operators[operator], "cannot find this operator");

    require(operatorList.length > requiredOperators, "cannot remove more operators");
    delete operators[operator];
    delete operatorLocation[operator];

    emit OperatorRemoved(operator);

    for (uint256 i = 0; i < operatorList.length; i++) {
      if (operatorList[i] == operator) {
        operatorList[i] = operatorList[operatorList.length - 1];
        operatorList.pop();
        return;
      }
    }
  }

  function updateLocation(address operator, string memory location) public onlyOwner {
    require(operators[operator], "cannot find this operator");

    operatorLocation[operator] = location;

    emit LocationUpdated(operator, location);
  }

  function setRequiredOperators(uint8 requiredOperators_) public onlyOwner {
    require(requiredOperators_ > 0, "at least one operator is required");
    require(operatorList.length >= requiredOperators_, "cannot be more than the number of added operators");
    require(requiredOperators_ >= MIN_REQUIRED_OPERATORS, "should be greater than the minimum number of required operators");
    requiredOperators = requiredOperators_;
  }

  function isOperator(address operator) public view returns (bool) {
    return (operators[operator] == true);
  }

  function operatorCount() public view returns (uint) {
    return operatorList.length;
  }

  function operatorAddresses() public view returns (address[] memory) {
    return operatorList;
  }

  function checkSignatures(
    bytes32 hash,
    uint256 length,
    uint8[] memory v,
    bytes32[] memory r,
    bytes32[] memory s
  ) public view returns(uint8) {
    uint8 approvals = 0;

    address prevOperator = address(0x0);

    for (uint i = 0; i < length; ++i) {
      address operator = ecrecover(hash, v[i], r[i], s[i]);
      require(isOperator(operator), "should be an operator");
      require(prevOperator < operator, "signatures are out of order");
      prevOperator = operator;
      approvals ++;
    }

    return approvals;
  }

  function prefixed(bytes32 hash) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
  }

  event OperatorAdded(address operator);
  event OperatorRemoved(address operator);
  event LocationUpdated(address operator, string location);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\OracleLibrary.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.7.6;

// source: @uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol

import "@uniswap/v3-core/contracts/libraries/FullMath.sol";
import "@uniswap/v3-core/contracts/libraries/TickMath.sol";
import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";


/// @title Oracle library
/// @notice Provides functions to integrate with V3 pool oracle
library OracleLibrary {

    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool
    /// @param pool Address of the pool that we want to observe
    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means
    /// @return success false on throw
    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp
    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp
    function consult(address pool, uint32 secondsAgo)
        internal
        view
        returns (bool success, int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)
    {
        require(secondsAgo != 0, "BP");

        uint32[] memory secondsAgos = new uint32[](2);
        secondsAgos[0] = secondsAgo;
        secondsAgos[1] = 0;

        int56[] memory tickCumulatives;
        uint160[] memory secondsPerLiquidityCumulativeX128s;

        (success, tickCumulatives, secondsPerLiquidityCumulativeX128s) = observe(IUniswapV3Pool(pool), secondsAgos);
        // IUniswapV3Pool(pool).observe(secondsAgos); <<< this can revert

        if (success) {
            int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
            uint160 secondsPerLiquidityCumulativesDelta =
            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];

            arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);
            // Always round to negative infinity
            if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;

            // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn"t overflow uint128
            uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;
            harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));
        }
    }

    function observe(IUniswapV3Pool pool, uint32[] memory secondsAgos)
        internal
        view
        returns (bool success, int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)
    {
        bytes4 observeSelector = pool.observe.selector;
        bytes memory data = abi.encodeWithSelector(observeSelector, secondsAgos);
        // solhint-disable-next-line avoid-low-level-calls
        (success, data) = address(pool).staticcall(data);

        if (success) {
            (tickCumulatives, secondsPerLiquidityCumulativeX128s) = abi.decode(data, (int56[], uint160[]));
        }
    }

    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange
    /// @param tick Tick value used to calculate the quote
    /// @param baseAmount Amount of token to be converted
    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination
    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination
    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken
    function getQuoteAtTick(
        int24 tick,
        uint128 baseAmount,
        address baseToken,
        address quoteToken
    ) internal pure returns (uint256 quoteAmount) {
        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);

        // Calculate quoteAmount with better precision if it doesn"t overflow when multiplied by itself
        if (sqrtRatioX96 <= type(uint128).max) {
            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
            quoteAmount = baseToken < quoteToken
            ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
            : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
        } else {
            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
            quoteAmount = baseToken < quoteToken
            ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
            : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import "../GSN/Context.sol";
/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Owned.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "@openzeppelin/contracts/access/Ownable.sol";

abstract contract Owned is Ownable {
    constructor(address _owner) {
        transferOwnership(_owner);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Pausable.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

// Inheritance
import "./Owned.sol";


abstract contract Pausable is Owned {
    bool public paused;

    event PauseChanged(bool isPaused);

    modifier notPaused {
        require(!paused, "This action cannot be performed while the contract is paused");
        _;
    }

    constructor() {
        // This contract is abstract, and thus cannot be instantiated directly
        require(owner() != address(0), "Owner must be set");
        // Paused will be false
    }

    /**
     * @notice Change the paused state of the contract
     * @dev Only the contract owner may call this.
     */
    function setPaused(bool _paused) external onlyOwner {
        // Ensure we're actually changing the state before we do anything
        if (_paused == paused) {
            return;
        }

        // Set our paused state.
        paused = _paused;

        // Let everyone know that our pause state has changed.
        emit PauseChanged(paused);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Ping.sol
File type: .sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity >=0.7.6 <0.9.0;


library Ping {
    function pong(function() external pure returns(bytes4) pingFunction) internal pure returns (bool) {
        return pingFunction.address != address(0) && pingFunction.selector == pingFunction();
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\PriceProvider.sol
File type: .sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity >=0.7.6 <0.9.0;

import "../lib/Ping.sol";
import "../interfaces/IPriceProvider.sol";
import "../interfaces/IPriceProvidersRepository.sol";

/// @title PriceProvider
/// @notice Abstract PriceProvider contract, parent of all PriceProviders
/// @dev Price provider is a contract that directly integrates with a price source, ie. a DEX or alternative system
/// like Chainlink to calculate TWAP prices for assets. Each price provider should support a single price source
/// and multiple assets.
abstract contract PriceProvider is IPriceProvider {
    /// @notice PriceProvidersRepository address
    IPriceProvidersRepository public immutable priceProvidersRepository;

    /// @notice Token address which prices are quoted in. Must be the same as PriceProvidersRepository.quoteToken
    address public immutable override quoteToken;

    modifier onlyManager() {
        if (priceProvidersRepository.manager() != msg.sender) revert("OnlyManager");
        _;
    }

    /// @param _priceProvidersRepository address of PriceProvidersRepository
    constructor(IPriceProvidersRepository _priceProvidersRepository) {
        if (
            !Ping.pong(_priceProvidersRepository.priceProvidersRepositoryPing)            
        ) {
            revert("InvalidPriceProviderRepository");
        }

        priceProvidersRepository = _priceProvidersRepository;
        quoteToken = _priceProvidersRepository.quoteToken();
    }

    /// @inheritdoc IPriceProvider
    function priceProviderPing() external pure override returns (bytes4) {
        return this.priceProviderPing.selector;
    }

    function _revertBytes(bytes memory _errMsg, string memory _customErr) internal pure {
        if (_errMsg.length > 0) {
            assembly { // solhint-disable-line no-inline-assembly
                revert(add(32, _errMsg), mload(_errMsg))
            }
        }

        revert(_customErr);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ReentrancyGuard.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor () internal {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Registrable.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.6.8;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "../interfaces/IRegistry.sol";
import "../interfaces/IStakingBank.sol";

abstract contract Registrable {
  IRegistry public contractRegistry;

  // ========== CONSTRUCTOR ========== //

  constructor(address _contractRegistry) internal {
    require(_contractRegistry != address(0x0), "_registry is empty");
    contractRegistry = IRegistry(_contractRegistry);
  }

  // ========== MODIFIERS ========== //

  modifier onlyFromContract(address _msgSender, bytes32 _contractName) {
    require(
      contractRegistry.getAddress(_contractName) == _msgSender,
        string(abi.encodePacked("caller is not ", _contractName))
    );
    _;
  }

  modifier withRegistrySetUp() {
    require(address(contractRegistry) != address(0x0), "_registry is empty");
    _;
  }

  // ========== MUTATIVE ========== //

  function register() virtual external {
    // this is required only for ForeignChain
    // but for backward compatibility the body is implemented as empty
    // also note, that in order to use this method, we need new registry
  }

  function unregister() virtual external {
    // this is required only for ForeignChain
    // but for backward compatibility the body is implemented as empty
    // also note, that in order to use this method, we need new registry
  }

  // ========== VIEWS ========== //

  function getName() virtual external pure returns (bytes32);

  function stakingBankContract() public view returns (IStakingBank) {
    return IStakingBank(contractRegistry.requireAndGetAddress("StakingBank"));
  }

  function tokenContract() public view withRegistrySetUp returns (ERC20) {
    return ERC20(contractRegistry.requireAndGetAddress("UMB"));
  }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Registry.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.6.8;

// Inheritance
import "@openzeppelin/contracts/access/Ownable.sol";

import "./extensions/Registrable.sol";

contract Registry is Ownable {
  mapping(bytes32 => address) public registry;

  // ========== EVENTS ========== //

  event LogRegistered(address indexed destination, bytes32 name);

  // ========== MUTATIVE FUNCTIONS ========== //

  function importAddresses(bytes32[] calldata _names, address[] calldata _destinations) external onlyOwner {
    require(_names.length == _destinations.length, "Input lengths must match");

    for (uint i = 0; i < _names.length; i++) {
      registry[_names[i]] = _destinations[i];
      emit LogRegistered(_destinations[i], _names[i]);
    }
  }

  function importContracts(address[] calldata _destinations) external onlyOwner {
    for (uint i = 0; i < _destinations.length; i++) {
      bytes32 name = Registrable(_destinations[i]).getName();
      registry[name] = _destinations[i];
      emit LogRegistered(_destinations[i], name);
    }
  }

  function atomicUpdate(address _newContract) external onlyOwner {
    Registrable(_newContract).register();

    bytes32 name = Registrable(_newContract).getName();
    address oldContract = registry[name];
    registry[name] = _newContract;

    Registrable(oldContract).unregister();

    emit LogRegistered(_newContract, name);
  }

  // ========== VIEWS ========== //

  function requireAndGetAddress(bytes32 name) external view returns (address) {
    address _foundAddress = registry[name];
    require(_foundAddress != address(0), string(abi.encodePacked("Name not registered: ", name)));
    return _foundAddress;
  }

  function getAddress(bytes32 _bytes) external view returns (address) {
    return registry[_bytes];
  }

  function getAddressByString(string memory _name) public view returns (address) {
    return registry[stringToBytes32(_name)];
  }

  function stringToBytes32(string memory _string) public pure returns (bytes32 result) {
    bytes memory tempEmptyStringTest = bytes(_string);

    if (tempEmptyStringTest.length == 0) {
      return 0x0;
    }

    assembly {
      result := mload(add(_string, 32))
    }
  }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\RewardsDistributionRecipient.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

// Inheritance
import "./Owned.sol";


// https://docs.synthetix.io/contracts/RewardsDistributionRecipient
abstract contract RewardsDistributionRecipient is Owned {
    address public rewardsDistribution;

    modifier onlyRewardsDistribution() {
        require(msg.sender == rewardsDistribution, "Caller is not RewardsDistributor");
        _;
    }

    function notifyRewardAmount(uint256 reward) virtual external;

    function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {
        rewardsDistribution = _rewardsDistribution;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\rUMB1.sol
File type: .sol
/**
 *Submitted for verification at Etherscan.io on 2021-02-08
*/

// File: @openzeppelin/contracts/math/SafeMath.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the substraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryDiv}.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}

// File: @openzeppelin/contracts/utils/Context.sol


pragma solidity >=0.6.0 <0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol


pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @openzeppelin/contracts/token/ERC20/ERC20.sol


pragma solidity >=0.6.0 <0.8.0;




/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor (string memory name_, string memory symbol_) public {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal virtual {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}

// File: @openzeppelin/contracts/access/Ownable.sol


pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: contracts/interfaces/Owned.sol

pragma solidity 0.7.5;


abstract contract Owned is Ownable {
    constructor(address _owner) {
        transferOwnership(_owner);
    }
}

// File: contracts/interfaces/ISwapReceiver.sol

pragma solidity 0.7.5;

interface ISwapReceiver {
    function swapMint(address _holder, uint256 _amount) external;
}

// File: contracts/interfaces/SwappableToken.sol

pragma solidity 0.7.5;

// Inheritance






/// @title   Umbrella Rewards contract
/// @author  umb.network
/// @notice  This contract serves Swap functionality for rewards tokens
/// @dev     It allows to swap itself for other token (main UMB token).
///          Swap can start 1y from deployment or can be triggered earlier by owner.
///          There is a daily limit for swapping so we can't swap all at once.
///          When swap is executing, this contract do not care about target token,
///          so target token should be responsible for all the check before he mint tokens for swap.
abstract contract SwappableToken is Owned, ERC20 {
    using SafeMath for uint256;

    uint256 public totalAmountToBeSwapped;
    uint256 public swappedSoFar;
    uint256 public swapStartsOn;
    uint256 public swapDuration;

    // ========== CONSTRUCTOR ========== //

    constructor(uint _totalAmountToBeSwapped, uint _swapDuration) {
        require(_totalAmountToBeSwapped != 0, "_totalAmountToBeSwapped is empty");
        require(_swapDuration != 0, "swapDuration is empty");

        totalAmountToBeSwapped = _totalAmountToBeSwapped;
        swapStartsOn = block.timestamp + 365 days;
        swapDuration = _swapDuration;
    }

    // ========== MODIFIERS ========== //

    // ========== VIEWS ========== //

    function isSwapStarted() public view returns (bool) {
        return block.timestamp >= swapStartsOn;
    }

    function canSwapTokens(address _address) public view returns (bool) {
        return balanceOf(_address) <= totalUnlockedAmountOfToken().sub(swappedSoFar);
    }

    function totalUnlockedAmountOfToken() public view returns (uint256) {
        if (block.timestamp < swapStartsOn)
            return 0;
        if (block.timestamp >= swapStartsOn.add(swapDuration)) {
            return totalSupply().add(swappedSoFar);
        } else {
            return totalSupply().add(swappedSoFar).mul(block.timestamp.sub(swapStartsOn)).div(swapDuration);
        }
    }

    // ========== MUTATIVE FUNCTIONS ========== //

    function swapFor(ISwapReceiver _umb) external {
        require(block.timestamp >= swapStartsOn, "swapping period has not started yet");

        uint amountToSwap = balanceOf(_msgSender());

        require(amountToSwap != 0, "you dont have tokens to swap");
        require(amountToSwap <= totalUnlockedAmountOfToken().sub(swappedSoFar), "your swap is over the limit");

        swappedSoFar = swappedSoFar.add(amountToSwap);

        _burn(_msgSender(), amountToSwap);
        _umb.swapMint(_msgSender(), amountToSwap);

        emit LogSwap(_msgSender(), amountToSwap);
    }

    // ========== PRIVATE / INTERNAL ========== //

    // ========== RESTRICTED FUNCTIONS ========== //

    function startEarlySwap() external onlyOwner {
        require(block.timestamp < swapStartsOn, "swap is already allowed");

        swapStartsOn = block.timestamp;
        emit LogStartEarlySwapNow(block.timestamp);
    }

    // ========== EVENTS ========== //

    event LogStartEarlySwapNow(uint time);
    event LogSwap(address indexed swappedTo, uint amount);
}

// File: contracts/interfaces/IBurnableToken.sol

pragma solidity 0.7.5;

interface IBurnableToken {
    function burn(uint256 _amount) external;
}

// File: contracts/interfaces/MintableToken.sol

pragma solidity 0.7.5;

// Inheritance





/// @title   Umbrella Rewards contract
/// @author  umb.network
/// @notice  This contract allows to mint tokens and burn key (renounceOwnership)
/// @dev     Can be use used with MultiSig as owner
abstract contract MintableToken is Owned, ERC20, IBurnableToken {
    using SafeMath for uint256;

    // ========== STATE VARIABLES ========== //

    uint256 public maxAllowedTotalSupply;

    // ========== CONSTRUCTOR ========== //

    constructor (uint256 _maxAllowedTotalSupply) {
        require(_maxAllowedTotalSupply != 0, "_maxAllowedTotalSupply is empty");
        maxAllowedTotalSupply = _maxAllowedTotalSupply;
    }

    // ========== MODIFIERS ========== //

    modifier assertMaxSupply(uint256 _amountToMint) {
        require(totalSupply().add(_amountToMint) <= maxAllowedTotalSupply, "total supply limit exceeded");
        _;
    }

    // ========== MUTATIVE FUNCTIONS ========== //

    function burn(uint256 _amount) override external {
        uint balance = balanceOf(msg.sender);
        require(_amount <= balance, "not enough tokens to burn");

        _burn(msg.sender, _amount);
        maxAllowedTotalSupply = maxAllowedTotalSupply - _amount;
    }

    // ========== RESTRICTED FUNCTIONS ========== //

    function mint(address _holder, uint256 _amount)
    external
    onlyOwner()
    assertMaxSupply(_amount) {
        require(_amount > 0, "zero amount");

        _mint(_holder, _amount);
    }
}

// File: contracts/interfaces/rUMB.sol

pragma solidity 0.7.5;

// Inheritance




/// @title   Umbrella Rewards contract
/// @author  umb.network
/// @notice  This is reward UMB token (rUMB)
/// @dev     Rewards tokens are used for farming and other rewards distributions.
abstract contract rUMB is MintableToken, SwappableToken {
    // ========== STATE VARIABLES ========== //

    // ========== CONSTRUCTOR ========== //

    constructor (
        address _owner,
        address _initialHolder,
        uint256 _initialBalance,
        uint256 _maxAllowedTotalSupply,
        uint256 _swapDuration,
        string memory _name,
        string memory _symbol
    )
    Owned(_owner)
    ERC20(_name, _symbol)
    MintableToken(_maxAllowedTotalSupply)
    SwappableToken(_maxAllowedTotalSupply, _swapDuration) {
        if (_initialHolder != address(0) && _initialBalance != 0) {
            _mint(_initialHolder, _initialBalance);
        }
    }
}

// File: contracts/rUMB1.sol

pragma solidity 0.7.5;


contract rUMB1 is rUMB {
     constructor (
        address _owner,
        address _initialHolder,
        uint256 _initialBalance,
        uint256 _maxAllowedTotalSupply,
        uint256 _swapDuration,
        string memory _name,
        string memory _symbol
    )
    rUMB(_owner, _initialHolder, _initialBalance, _maxAllowedTotalSupply, _swapDuration, _name, _symbol) {
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\rUMB2.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "./interfaces/rUMBV2.sol";
import "./interfaces/Blacklisted.sol";
import "./interfaces/OnDemandTokenBridgable.sol";

contract rUMB2 is Blacklisted, rUMBV2, OnDemandTokenBridgable {
     constructor (
        address _owner,
        uint256 _maxAllowedTotalSupply,
        uint32 _swapStartsOn,
        uint32 _dailyCup,
        string memory _name,
        string memory _symbol,
        address _umb
    ) rUMBV2(_owner, _maxAllowedTotalSupply, _swapStartsOn, _dailyCup, _name, _symbol, _umb) {}

    function mint(address _holder, uint256 _amount)
        external
        override(MintableToken, OnDemandToken)
        onlyOwnerOrMinter()
        assertMaxSupply(_amount)
    {
        require(_amount != 0, "zero amount");

        _mint(_holder, _amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal
        override(Blacklisted, OnDemandTokenBridgable, ERC20)
    {
        Blacklisted._beforeTokenTransfer(from, to, amount);
        OnDemandTokenBridgable._beforeTokenTransfer(from, to, amount);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\rUMBV2.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

// Inheritance
import "./SwappableTokenV2.sol";
import "./MintableToken.sol";


/// @title   Umbrella Rewards contract
/// @author  umb.network
/// @notice  This is reward UMB token (rUMB)
/// @dev     Rewards tokens are used for farming and other rewards distributions.
abstract contract rUMBV2 is MintableToken, SwappableTokenV2 {
    // ========== STATE VARIABLES ========== //

    // ========== CONSTRUCTOR ========== //

    constructor (
        address _owner,
        uint256 _maxAllowedTotalSupply,
        uint32 _swapStartsOn,
        uint32 _dailyCup,
        string memory _name,
        string memory _symbol,
        address _umb
    )
        Owned(_owner)
        ERC20(_name, _symbol)
        MintableToken(_maxAllowedTotalSupply)
        SwappableTokenV2(_umb, _swapStartsOn, _dailyCup) {}
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

import "./IERC20.sol";
import "../../math/SafeMath.sol";
import "../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\SafeMath.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\SampleERC20.sol
File type: .sol
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import "./../ERC20Mintable.sol";

contract SampleERC20 is ERC20Mintable {
  constructor(string memory _name, string memory _symbol)
    ERC20Mintable(_name, _symbol) {
  }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\SampleERC721.sol
File type: .sol
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;

import "./../ERC721Mintable.sol";

contract SampleERC721 is ERC721Mintable {
  constructor(string memory _name, string memory _symbol)
    ERC721Mintable(_name, _symbol) {
  }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\StakingBankState.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "@openzeppelin/contracts/access/Ownable.sol";

import "./interfaces/IStakingBank.sol";
import "./extensions/Registrable.sol";
import "./Registry.sol";

contract StakingBankState is IStakingBank, Registrable, Ownable {
    uint256 public totalSupply;

    /// validator address => validator balance
    mapping(address => uint256) public balances;

    /// list of all validators wallets
    address[] public addresses;

    event ValidatorBalanceUpdate(address indexed validator, uint256 balance);
    event TotalSupply(uint256 total);

    error ArrayLengthError();
    error InvalidTotalSupply();
    error NoChangeToState();
    error NotSupported();

    constructor(IRegistry _contractRegistry) Registrable(_contractRegistry) {
        // no additional configuration needed
    }

    /// @inheritdoc Registrable
    function register() external override {
        // there are no requirements atm
    }

    /// @inheritdoc Registrable
    function unregister() external override {
        // there are no requirements atm
    }

    /// @notice use it to clone validators balances from master chain
    /// @param _totalSupply cloned value from master chain, it can be 0
    function setTotalSupply(uint256 _totalSupply) external onlyOwner {
        if (totalSupply == _totalSupply) revert NoChangeToState();

        _setTotalSupply(_totalSupply);
    }

    /// @notice use it to clone validators balances from master chain
    /// @param _validators array of validator addresses that needs to be updated
    /// @param _balances array of validator _balances that will be set (can be 0s)
    /// @param _totalSupply cloned value of total staked amount from master chain, it can be 0
    function setBalances(address[] calldata _validators, uint256[] calldata _balances, uint256 _totalSupply)
        external
        onlyOwner
    {
        if (_validators.length != _balances.length) revert ArrayLengthError();

        for (uint256 i; i < _validators.length;) {
            _setBalance(_validators[i], _balances[i]);

            unchecked {
                // we will not have enough data to overflow
                i++;
            }
        }

        if (_calculateTotalBalance() > _totalSupply) revert InvalidTotalSupply();

        if (totalSupply != _totalSupply) {
            _setTotalSupply(_totalSupply);
        }
    }

    function getNumberOfValidators() external view returns (uint256) {
        return addresses.length;
    }

    function getAddresses() external view returns (address[] memory) {
        return addresses;
    }

    function getBalances() external view returns (uint256[] memory allBalances) {
        uint256 count = addresses.length;
        allBalances = new uint256[](count);

        for (uint256 i = 0; i < count;) {
            allBalances[i] = balances[addresses[i]];

            unchecked {
                // we will not have enough data to overflow
                i++;
            }
        }
    }

    /// @inheritdoc IERC20
    function balanceOf(address _account) external view returns (uint256) {
        return balances[_account];
    }

    function transfer(address, uint256) external pure returns (bool) {
        revert NotSupported();
    }

    function stake(uint256) external pure {
        revert NotSupported();
    }

    function withdraw(uint256) external pure returns (bool) {
        revert NotSupported();
    }

    function exit() external pure returns (bool) {
        revert NotSupported();
    }

    function create(address, string calldata) external pure {
        revert NotSupported();
    }

    function update(address, string calldata) external pure {
        revert NotSupported();
    }

    function remove(address) external pure {
        revert NotSupported();
    }

    function validators(address) external pure returns (address, string memory) {
        revert NotSupported();
    }

    function setMinAmountForStake(uint256) external pure {
        revert NotSupported();
    }

    function approve(address, uint256) external pure returns (bool) {
        revert NotSupported();
    }

    function receiveApproval(address) external pure returns (bool) {
        revert NotSupported();
    }

    function receiveApproval(address, uint256) external pure returns (bool) {
        revert NotSupported();
    }

    function transferFrom(address, address, uint256) public pure virtual override returns (bool) {
        revert NotSupported();
    }

    function allowance(address, address) external pure returns (uint256) {
        revert NotSupported();
    }

    /// @inheritdoc Registrable
    function getName() external pure override returns (bytes32) {
        return "StakingBank";
    }

    /// @param _validator validator addresses that needs to be updated
    /// @param _balance validator balance that will be set (can be 0)
    function _setBalance(address _validator, uint256 _balance) internal {
        uint256 currentBalance = balances[_validator];

        // if balance that we want to set for validator is 0, means we want to remove validator
        if (_balance == 0) {
            // if current balance is 0, validator address is already removed
            if (currentBalance != 0) {
                _removeAddress(_validator);
            }
        } else if (currentBalance == 0) {
            // if we setting up balance > 0 and current balance is 0, then this is new validator
            // so we have to add address
            addresses.push(_validator);
        }

        balances[_validator] = _balance;

        emit ValidatorBalanceUpdate(_validator, _balance);
    }

    function _setTotalSupply(uint256 _totalSupply) private {
        totalSupply = _totalSupply;
        emit TotalSupply(_totalSupply);
    }

    function _removeAddress(address _address) internal {
        uint256 count = addresses.length;

        for (uint256 i = 0; i < count;) {
            if (addresses[i] == _address) {
                addresses[i] = addresses[count - 1];
                addresses.pop();
                return;
            }

            unchecked {
                // we will not have enough data to overflow
                i++;
            }
        }
    }

    function _calculateTotalBalance() internal returns (uint256 total) {
        uint256 count = addresses.length;

        for (uint256 i = 0; i < count;) {
            total += balances[addresses[i]];

            unchecked {
                // we will not have enough data to overflow
                i++;
            }
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\StakingLens.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;
pragma abicoder v2;

import "./StakingLockable.sol";

/// @author  umb.network
/// @notice Math is based on synthetix staking contract
///         Contract allows to stake and lock tokens. For rUMB tokens only locking option is available.
///         When locking user choose period and based on period multiplier is apply to the amount (boost).
///         If pool is set for rUMB1->rUMB2, (rUmbPool) then rUMB2 can be locked as well
contract StakingLens {
    struct LockData {
        uint256 period;
        uint256 multiplier;
    }

    /// @dev returns amount of all staked and locked tokens including bonuses
    function balanceOf(StakingLockable _pool, address _account) external view returns (uint256) {
        (uint96 umbBalance, uint96 lockedWithBonus,,,) = _pool.balances(_account);
        return umbBalance + lockedWithBonus;
    }

    function getRewardForDuration(StakingLockable _pool) external view returns (uint256) {
        (, uint32 rewardsDuration,,) = _pool.timeData();
        return _pool.rewardRate() * rewardsDuration;
    }

    function rewards(StakingLockable _pool, address _user) external view returns (uint256) {
        (,,,,uint96 userRewards) = _pool.balances(_user);
        return userRewards;
    }

    /// @notice returns array of max 100 booleans, where index corresponds to lock id. `true` means lock can be withdraw
    function getVestedLockIds(StakingLockable _pool, address _account, uint256 _offset)
        external
        view
        returns (bool[] memory results)
    {
        (,,uint256 nextLockIndex,,) = _pool.balances(_account);
        uint256 batch = 100;

        if (nextLockIndex == 0) return results;
        if (nextLockIndex <= _offset) return results;

        uint256 end = _offset + batch > nextLockIndex ? nextLockIndex : _offset + batch;

        results = new bool[](end);

        for (uint256 i = _offset; i < end; i++) {
            (,,, uint32 unlockDate,, uint32 withdrawnAt) = _pool.locks(_account, i);
            results[i] = withdrawnAt == 0 && unlockDate <= block.timestamp;
        }
    }

    /// @notice returns array of max 100 booleans, where index corresponds to lock id.
    ///         `true` means lock was not withdrawn yet
    function getActiveLockIds(StakingLockable _pool, address _account, uint256 _offset)
        external
        view
        returns (bool[] memory results)
    {
        (,,uint256 nextLockIndex,,) = _pool.balances(_account);
        uint256 batch = 100;

        if (nextLockIndex == 0) return results;
        if (nextLockIndex <= _offset) return results;

        uint256 end = _offset + batch > nextLockIndex ? nextLockIndex : _offset + batch;

        results = new bool[](end);

        for (uint256 i = _offset; i < end; i++) {
            (,,,,, uint32 withdrawnAt) = _pool.locks(_account, i);
            results[i] = withdrawnAt == 0;
        }
    }

    function getPeriods(StakingLockable _pool, address _token) external view returns (uint256[] memory periods) {
        return _pool.getPeriods(_token);
    }

    function getPeriodsAndMultipliers(StakingLockable _pool, address _token)
        external
        view
        returns (LockData[] memory lockData)
    {
        uint256[] memory periods = _pool.getPeriods(_token);
        uint256 n = periods.length;
        lockData = new LockData[](n);

        for (uint256 i; i < n; i++) {
            lockData[i] = LockData(periods[i], _pool.multipliers(_token, periods[i]));
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\StakingLockable.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// Inheritance
import "../interfaces/IStakingRewards.sol";
import "../interfaces/Pausable.sol";
import "../interfaces/IBurnableToken.sol";
import "../interfaces/RewardsDistributionRecipient.sol";
import "../interfaces/OnDemandToken.sol";
import "../interfaces/LockSettings.sol";
import "../interfaces/SwappableTokenV2.sol";

/// @author  umb.network
/// @notice Math is based on synthetix staking contract
///         Contract allows to stake and lock tokens. For rUMB tokens only locking option is available.
///         When locking user choose period and based on period multiplier is apply to the amount (boost).
///         If pool is set for rUMB1->rUMB2, (rUmbPool) then rUMB2 can be locked as well
contract StakingLockable is LockSettings, RewardsDistributionRecipient, ReentrancyGuard, Pausable {
    struct Times {
        uint32 periodFinish;
        uint32 rewardsDuration;
        uint32 lastUpdateTime;
        uint96 totalRewardsSupply;
    }

    struct Balance {
        // total supply of UMB = 500_000_000e18, it can be saved using 89bits, so we good with 96 and above
        // user UMB balance
        uint96 umbBalance;
        // amount locked + virtual balance generated using multiplier when locking
        uint96 lockedWithBonus;
        uint32 nextLockIndex;
        uint160 userRewardPerTokenPaid;
        uint96 rewards;
    }

    struct Supply {
        // staked + raw locked
        uint128 totalBalance;
        // virtual balance
        uint128 totalBonus;
    }

    struct Lock {
        uint8 tokenId;
        // total supply of UMB can be saved using 89bits, so we good with 96 and above
        uint120 amount;
        uint32 lockDate;
        uint32 unlockDate;
        uint32 multiplier;
        uint32 withdrawnAt;
    }

    uint8 public constant UMB_ID = 2 ** 0;
    uint8 public constant RUMB1_ID = 2 ** 1;
    uint8 public constant RUMB2_ID = 2 ** 2;

    uint256 public immutable maxEverTotalRewards;

    address public immutable umb;
    address public immutable rUmb1;
    /// @dev this is reward token but we also allow to lock it
    address public immutable rUmb2;

    uint256 public rewardRate = 0;
    uint256 public rewardPerTokenStored;

    Supply public totalSupply;

    Times public timeData;

    /// @dev user => Balance
    mapping(address => Balance) public balances;

    /// @dev user => lock ID => Lock
    mapping(address => mapping(uint256 => Lock)) public locks;

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount, uint256 bonus);

    event LockedTokens(
        address indexed user,
        address indexed token,
        uint256 lockId,
        uint256 amount,
        uint256 period,
        uint256 multiplier
    );

    event UnlockedTokens(address indexed user, address indexed token, uint256 lockId, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event FarmingFinished();
    event Swap1to2(uint256 swapped);

    modifier updateReward(address _account) virtual {
        uint256 newRewardPerTokenStored = rewardPerToken();
        rewardPerTokenStored = newRewardPerTokenStored;
        timeData.lastUpdateTime = uint32(lastTimeRewardApplicable());

        if (_account != address(0)) {
            balances[_account].rewards = uint96(earned(_account));
            balances[_account].userRewardPerTokenPaid = uint160(newRewardPerTokenStored);
        }

        _;
    }

    constructor(
        address _owner,
        address _rewardsDistribution,
        address _umb,
        address _rUmb1,
        address _rUmb2
    ) Owned(_owner) {
        require(
            (
                MintableToken(_umb).maxAllowedTotalSupply() +
                MintableToken(_rUmb1).maxAllowedTotalSupply() +
                MintableToken(_rUmb2).maxAllowedTotalSupply()
            ) * MAX_MULTIPLIER / RATE_DECIMALS <= type(uint96).max,
            "staking overflow"
        );

        require(
            MintableToken(_rUmb2).maxAllowedTotalSupply() * MAX_MULTIPLIER / RATE_DECIMALS <= type(uint96).max,
            "rewards overflow"
        );

        require(OnDemandToken(_rUmb2).ON_DEMAND_TOKEN(), "rewardsToken must be OnDemandToken");

        umb = _umb;
        rUmb1 = _rUmb1;
        rUmb2 = _rUmb2;

        rewardsDistribution = _rewardsDistribution;
        timeData.rewardsDuration = 2592000; // 30 days
        maxEverTotalRewards = MintableToken(_rUmb2).maxAllowedTotalSupply();
    }

    function lockTokens(address _token, uint256 _amount, uint256 _period) external {
        if (_token == rUmb2 && !SwappableTokenV2(rUmb2).isSwapStarted()) {
            revert("locking rUMB2 not available yet");
        }

        _lockTokens(msg.sender, _token, _amount, _period);
    }

    function unlockTokens(uint256[] calldata _ids) external {
        _unlockTokensFor(msg.sender, _ids, msg.sender);
    }

    function restart(uint256 _rewardsDuration, uint256 _reward) external {
        setRewardsDuration(_rewardsDuration);
        notifyRewardAmount(_reward);
    }

    // when farming was started with 1y and 12tokens
    // and we want to finish after 4 months, we need to end up with situation
    // like we were starting with 4mo and 4 tokens.
    function finishFarming() external onlyOwner {
        Times memory t = timeData;
        require(block.timestamp < t.periodFinish, "can't stop if not started or already finished");

        if (totalSupply.totalBalance != 0) {
            uint32 remaining = uint32(t.periodFinish - block.timestamp);
            timeData.rewardsDuration = t.rewardsDuration - remaining;
        }

        timeData.periodFinish = uint32(block.timestamp);

        emit FarmingFinished();
    }

    /// @notice one of the reasons this method can throw is, when we swap for UMB and somebody stake rUMB1 after that.
    ///         In that case execution of `swapForUMB()` is required (anyone can execute this method) before proceeding.
    function exit() external {
        _withdraw(type(uint256).max, msg.sender, msg.sender);
        _getReward(msg.sender, msg.sender);
    }

    /// @notice one of the reasons this method can throw is, when we swap for UMB and somebody stake rUMB1 after that.
    ///         In that case execution of `swapForUMB()` is required (anyone can execute this method) before proceeding.
    function exitAndUnlock(uint256[] calldata _lockIds) external {
        _withdraw(type(uint256).max, msg.sender, msg.sender);
        _unlockTokensFor(msg.sender, _lockIds, msg.sender);
        _getReward(msg.sender, msg.sender);
    }

    function stake(uint256 _amount) external {
        _stake(umb, msg.sender, _amount, 0);
    }

    function getReward() external {
        _getReward(msg.sender, msg.sender);
    }

    function swap1to2() public {
        if (!SwappableTokenV2(rUmb2).isSwapStarted()) return;

        uint256 myBalance = IERC20(rUmb1).balanceOf(address(this));
        if (myBalance == 0) return;

        IBurnableToken(rUmb1).burn(myBalance);
        OnDemandToken(rUmb2).mint(address(this), myBalance);

        emit Swap1to2(myBalance);
    }

    /// @dev when notifying about amount, we don't have to mint or send any tokens, reward tokens will be mint on demand
    ///         this method is used to restart staking
    function notifyRewardAmount(
        uint256 _reward
    ) override public onlyRewardsDistribution updateReward(address(0)) {
        // this method can be executed on its own as well, I'm including here to not need to remember about it
        swap1to2();

        Times memory t = timeData;
        uint256 newRewardRate;

        if (block.timestamp >= t.periodFinish) {
            newRewardRate = _reward / t.rewardsDuration;
        } else {
            uint256 remaining = t.periodFinish - block.timestamp;
            uint256 leftover = remaining * rewardRate;
            newRewardRate = (_reward + leftover) / t.rewardsDuration;
        }

        require(newRewardRate != 0, "invalid rewardRate");

        rewardRate = newRewardRate;

        // always increasing by _reward even if notification is in a middle of period
        // because leftover is included
        uint256 totalRewardsSupply = timeData.totalRewardsSupply + _reward;
        require(totalRewardsSupply <= maxEverTotalRewards, "rewards overflow");

        timeData.totalRewardsSupply = uint96(totalRewardsSupply);
        timeData.lastUpdateTime = uint32(block.timestamp);
        timeData.periodFinish = uint32(block.timestamp + t.rewardsDuration);

        emit RewardAdded(_reward);
    }

    function setRewardsDuration(uint256 _rewardsDuration) public onlyRewardsDistribution {
        require(_rewardsDuration != 0, "empty _rewardsDuration");

        require(
            block.timestamp > timeData.periodFinish,
            "Previous period must be complete before changing the duration"
        );

        timeData.rewardsDuration = uint32(_rewardsDuration);
        emit RewardsDurationUpdated(_rewardsDuration);
    }

    /// @notice one of the reasons this method can throw is, when we swap for UMB and somebody stake rUMB1 after that.
    ///         In that case execution of `swapForUMB()` is required (anyone can execute this method) before proceeding.
    function withdraw(uint256 _amount) public {
        _withdraw(_amount, msg.sender, msg.sender);
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        uint256 periodFinish = timeData.periodFinish;
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }

    function rewardPerToken() public view returns (uint256 perToken) {
        Supply memory s = totalSupply;

        if (s.totalBalance == 0) {
            return rewardPerTokenStored;
        }

        perToken = rewardPerTokenStored + (
            (lastTimeRewardApplicable() - timeData.lastUpdateTime) * rewardRate * 1e18 / (s.totalBalance + s.totalBonus)
        );
    }

    function earned(address _account) virtual public view returns (uint256) {
        Balance memory b = balances[_account];
        uint256 totalBalance = b.umbBalance + b.lockedWithBonus;
        return (totalBalance * (rewardPerToken() - b.userRewardPerTokenPaid) / 1e18) + b.rewards;
    }

    function calculateBonus(uint256 _amount, uint256 _multiplier) public pure returns (uint256 bonus) {
        if (_multiplier <= RATE_DECIMALS) return 0;

        bonus = _amount * _multiplier / RATE_DECIMALS - _amount;
    }

    /// @param _token token that we allow to stake, validator check should be do outside
    /// @param _user token owner
    /// @param _amount amount
    /// @param _bonus if bonus is 0, means we are staking, bonus > 0 means this is locking
    function _stake(address _token, address _user, uint256 _amount, uint256 _bonus)
        internal
        nonReentrant
        notPaused
        updateReward(_user)
    {
        uint256 amountWithBonus = _amount + _bonus;

        require(timeData.periodFinish > block.timestamp, "Stake period not started yet");
        require(amountWithBonus != 0, "Cannot stake 0");

        // TODO check if we ever need to separate balance and bonuses
        totalSupply.totalBalance += uint96(_amount);
        totalSupply.totalBonus += uint128(_bonus);

        if (_bonus == 0) {
            balances[_user].umbBalance += uint96(_amount);
        } else {
            balances[_user].lockedWithBonus += uint96(amountWithBonus);
        }

        // not using safe transfer, because we working with trusted tokens
        require(IERC20(_token).transferFrom(_user, address(this), _amount), "token transfer failed");

        emit Staked(_user, _amount, _bonus);
    }

    function _lockTokens(address _user, address _token, uint256 _amount, uint256 _period) internal notPaused {
        uint256 multiplier = multipliers[_token][_period];
        require(multiplier != 0, "invalid period or not supported token");

        uint256 stakeBonus = calculateBonus(_amount, multiplier);

        _stake(_token, _user, _amount, stakeBonus);
        _addLock(_user, _token, _amount, _period, multiplier);
    }

    function _addLock(address _user, address _token, uint256 _amount, uint256 _period, uint256 _multiplier) internal {
        uint256 newIndex = balances[_user].nextLockIndex;
        if (newIndex == type(uint32).max) revert("nextLockIndex overflow");

        balances[_user].nextLockIndex = uint32(newIndex + 1);

        Lock storage lock = locks[_user][newIndex];

        lock.amount = uint120(_amount);
        lock.multiplier = uint32(_multiplier);
        lock.lockDate = uint32(block.timestamp);
        lock.unlockDate = uint32(block.timestamp + _period);

        if (_token == rUmb2) lock.tokenId = RUMB2_ID;
        else if (_token == rUmb1) lock.tokenId = RUMB1_ID;
        else lock.tokenId = UMB_ID;

        emit LockedTokens(_user, _token, newIndex, _amount, _period, _multiplier);
    }

    // solhint-disable-next-line code-complexity
    function _unlockTokensFor(address _user, uint256[] calldata _indexes, address _recipient)
        internal
        returns (address token, uint256 totalRawAmount)
    {
        uint256 totalBonus;
        uint256 acceptedTokenId;
        bool isSwapStarted = SwappableTokenV2(rUmb2).isSwapStarted();

        for (uint256 i; i < _indexes.length; i++) {
            (uint256 amount, uint256 bonus, uint256 tokenId) = _markAsUnlocked(_user, _indexes[i]);
            if (amount == 0) continue;

            if (acceptedTokenId == 0) {
                acceptedTokenId = tokenId;
                token = _idToToken(tokenId);

                // if token is already rUmb2 means swap started already

                if (token == rUmb1 && isSwapStarted) {
                    token = rUmb2;
                    acceptedTokenId = RUMB2_ID;
                }
            } else if (acceptedTokenId != tokenId) {
                if (acceptedTokenId == RUMB2_ID && tokenId == RUMB1_ID) {
                    // this lock is for rUMB1 but swap 1->2 is started so we unlock as rUMB2
                } else revert("batch unlock possible only for the same tokens");
            }

            emit UnlockedTokens(_user, token, _indexes[i], amount);

            totalRawAmount += amount;
            totalBonus += bonus;
        }

        if (totalRawAmount == 0) revert("nothing to unlock");
        _withdrawUnlockedTokens(_user, token, _recipient, totalRawAmount, totalBonus);
    }

    function _withdrawUnlockedTokens(
        address _user,
        address _token,
        address _recipient,
        uint256 _totalRawAmount,
        uint256 _totalBonus
    )
        internal
    {
        uint256 amountWithBonus = _totalRawAmount + _totalBonus;

        balances[_user].lockedWithBonus -= uint96(amountWithBonus);

        totalSupply.totalBalance -= uint96(_totalRawAmount);
        totalSupply.totalBonus -= uint128(_totalBonus);

        // note: there is one case when this transfer can fail:
        // when swap is started by we did not swap rUmb1 -> rUmb2,
        // in that case we have to execute `swap1to2`
        // to save gas I'm not including it here, because it is unlikely case
        require(IERC20(_token).transfer(_recipient, _totalRawAmount), "withdraw unlocking failed");
    }

    function _markAsUnlocked(address _user, uint256 _index)
        internal
        returns (uint256 amount, uint256 bonus, uint256 tokenId)
    {
        // TODO will storage save gas?
        Lock memory lock = locks[_user][_index];

        if (lock.withdrawnAt != 0) revert("DepositAlreadyWithdrawn");
        if (block.timestamp < lock.unlockDate) revert("DepositLocked");

        if (lock.amount == 0) return (0, 0, 0);

        locks[_user][_index].withdrawnAt = uint32(block.timestamp);

        return (lock.amount, calculateBonus(lock.amount, lock.multiplier), lock.tokenId);
    }

    /// @param _amount tokens to withdraw
    /// @param _user address
    /// @param _recipient address, where to send tokens, if we migrating token address can be zero
    function _withdraw(uint256 _amount, address _user, address _recipient) internal nonReentrant updateReward(_user) {
        Balance memory balance = balances[_user];

        if (_amount == type(uint256).max) _amount = balance.umbBalance;
        else require(balance.umbBalance >= _amount, "withdraw amount to high");

        if (_amount == 0) return;

        // not using safe math, because there is no way to overflow because of above check
        totalSupply.totalBalance -= uint120(_amount);
        balances[_user].umbBalance = uint96(balance.umbBalance - _amount);

        // not using safe transfer, because we working with trusted tokens
        require(IERC20(umb).transfer(_recipient, _amount), "token transfer failed");

        emit Withdrawn(_user, _amount);
    }

    /// @param _user address
    /// @param _recipient address, where to send reward
    function _getReward(address _user, address _recipient)
        internal
        nonReentrant
        updateReward(_user)
        returns (uint256 reward)
    {
        reward = balances[_user].rewards;

        if (reward != 0) {
            balances[_user].rewards = 0;
            OnDemandToken(address(rUmb2)).mint(_recipient, reward);
            emit RewardPaid(_user, reward);
        }
    }

    function _idToToken(uint256 _tokenId) internal view returns (address token) {
        if (_tokenId == RUMB2_ID) token = rUmb2;
        else if (_tokenId == RUMB1_ID) token = rUmb1;
        else if (_tokenId == UMB_ID) token = umb;
        else return address(0);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\StakingRewards.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "@openzeppelin/contracts/math/Math.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";

// Inheritance
import "../interfaces/IStakingRewards.sol";
import "../interfaces/Pausable.sol";
import "../interfaces/RewardsDistributionRecipient.sol";
import "../interfaces/MintableToken.sol";

// based on synthetix
contract StakingRewards is IStakingRewards, RewardsDistributionRecipient, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    struct Times {
        uint32 periodFinish;
        uint32 rewardsDuration;
        uint32 lastUpdateTime;
        uint96 totalRewardsSupply;
    }

    uint256 public immutable maxEverTotalRewards;

    IERC20 public immutable rewardsToken;
    IERC20 public immutable stakingToken;

    uint256 public rewardRate;
    uint256 public rewardPerTokenStored;
    
    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    Times public timeData;
    bool public stopped;

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event FarmingFinished();

    modifier whenActive() {
        require(!stopped, "farming is stopped");
        _;
    }

    modifier updateReward(address account) virtual {
        uint256 newRewardPerTokenStored = rewardPerToken();
        rewardPerTokenStored = newRewardPerTokenStored;
        timeData.lastUpdateTime = uint32(lastTimeRewardApplicable());

        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = newRewardPerTokenStored;
        }

        _;
    }

    constructor(
        address _owner,
        address _rewardsDistribution,
        address _stakingToken,
        address _rewardsToken
    ) Owned(_owner) {
        // works like sanity check for tokens
        IERC20(_stakingToken).totalSupply();
        IERC20(_rewardsToken).totalSupply();

        stakingToken = IERC20(_stakingToken);
        rewardsToken = IERC20(_rewardsToken);

        rewardsDistribution = _rewardsDistribution;

        timeData.rewardsDuration = 2592000; // 30 days
        maxEverTotalRewards = MintableToken(_rewardsToken).maxAllowedTotalSupply();
    }


    function notifyRewardAmount(
        uint256 _reward
    ) override virtual external whenActive onlyRewardsDistribution updateReward(address(0)) {
        Times memory t = timeData;
        uint256 newRewardRate;

        if (block.timestamp >= t.periodFinish) {
            newRewardRate = _reward / t.rewardsDuration;
        } else {
            uint256 remaining = t.periodFinish - block.timestamp;
            uint256 leftover = remaining.mul(rewardRate);
            newRewardRate = _reward.add(leftover) / t.rewardsDuration;
        }

        require(newRewardRate != 0, "invalid rewardRate");

        rewardRate = newRewardRate;

        // always increasing by _reward even if notification is in a middle of period
        // because leftover is included
        uint256 totalRewardsSupply = SafeMath.add(timeData.totalRewardsSupply, _reward);
        require(totalRewardsSupply <= maxEverTotalRewards, "rewards overflow");

        timeData.totalRewardsSupply = uint96(totalRewardsSupply);

        // if this is a fresh start, we will not be setting up periodFinish and lastUpdateTime
        // it will be set up when the user first stakes
        // that way we will avoid generating dust between start and first stake
        if (t.periodFinish != 0) {
            timeData.lastUpdateTime = uint32(block.timestamp);
            timeData.periodFinish = uint32(block.timestamp + t.rewardsDuration);
        }

        emit RewardAdded(_reward);
    }

    function setRewardsDuration(uint256 _rewardsDuration) external whenActive onlyOwner {
        require(_rewardsDuration != 0, "empty _rewardsDuration");

        require(
            block.timestamp > timeData.periodFinish,
            "Previous period must be complete before changing the duration"
        );

        timeData.rewardsDuration = uint32(_rewardsDuration);
        emit RewardsDurationUpdated(_rewardsDuration);
    }

    // when farming was started with 1y and 12tokens
    // and we want to finish after 4 months, we need to end up with situation
    // like we were starting with 4mo and 4 tokens.
    function finishFarming() virtual external whenActive onlyOwner {
        stopped = true;
        emit FarmingFinished();

        Times memory t = timeData;

        if (t.periodFinish == 0 && t.totalRewardsSupply != 0) {
            // it was notified but nobody staked yet
            timeData.lastUpdateTime = 0;
            timeData.totalRewardsSupply = 0;
            return;
        }

        require(block.timestamp < t.periodFinish, "can't stop if not started or already finished");

        if (_totalSupply != 0) {
            uint256 remaining = t.periodFinish - block.timestamp;
            timeData.rewardsDuration = uint32(t.rewardsDuration - remaining);
        }

        timeData.periodFinish = uint32(block.timestamp);
    }

    function exit() override external {
        withdraw(_balances[msg.sender]);
        getReward();
    }

    function stake(uint256 amount) override external {
        _stake(msg.sender, amount, false);
    }

    function periodFinish() external view returns (uint256) {
        return timeData.periodFinish;
    }

    function rewardsDuration() external view returns (uint256) {
        return timeData.rewardsDuration;
    }

    function lastUpdateTime() external view returns (uint256) {
        return timeData.lastUpdateTime;
    }

    function balanceOf(address account) override external view returns (uint256) {
        return _balances[account];
    }

    function getRewardForDuration() override external view returns (uint256) {
        return rewardRate * timeData.rewardsDuration;
    }

    function totalSupply() override external view returns (uint256) {
        return _totalSupply;
    }

    function version() external pure virtual returns (uint256) {
        return 1;
    }

    function withdraw(uint256 amount) override public {
        _withdraw(amount, msg.sender, msg.sender);
    }

    function getReward() override public {
        _getReward(msg.sender, msg.sender);
    }

    function lastTimeRewardApplicable() override public view returns (uint256) {
        return Math.min(block.timestamp, timeData.periodFinish);
    }

    function rewardPerToken() override public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }

        return rewardPerTokenStored + (
            (lastTimeRewardApplicable() - timeData.lastUpdateTime) * rewardRate * 1e18 / _totalSupply
        );
    }

    function earned(address account) override virtual public view returns (uint256) {
        // rewardPerToken() is always at least `rewardPerTokenStored`
        // `userRewardPerTokenPaid[account]` is at most == rewardPerToken()
        // so when we doing below calculation: rewardPerToken() >= userRewardPerTokenPaid[account], we do not underflow
        return (_balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) + rewards[account];
    }

    function _stake(address user, uint256 amount, bool migration)
        internal
        nonReentrant
        notPaused
        updateReward(user) // on first stake it will not update anything, all calculations will be 0
    {
        require(timeData.totalRewardsSupply != 0, "Stake period not started yet");
        require(amount != 0, "Cannot stake 0");

        // if we pass `rewardsDuration` check but `periodFinish` is empty, then staking is active and this is first user
        if (timeData.periodFinish == 0) {
            // set `periodFinish` on initial staking to avoid dust
            timeData.periodFinish = uint32(block.timestamp + timeData.rewardsDuration);
            timeData.lastUpdateTime = uint32(block.timestamp);
        }

        // `amount` is what we will transferFrom contract, so we can not overflow `totalSupply.totalBalance`
        _totalSupply = _totalSupply + amount;
        _balances[user] = _balances[user] + amount;

        if (migration) {
            // other contract will send tokens to us, this will save ~13K gas
        } else {
            // not using safe transfer, because we working with trusted tokens
            require(stakingToken.transferFrom(user, address(this), amount), "token transfer failed");
        }

        emit Staked(user, amount);
    }

    /// @param amount tokens to withdraw
    /// @param user address
    /// @param recipient address, where to send tokens, if we migrating token address can be zero
    function _withdraw(uint256 amount, address user, address recipient) internal nonReentrant updateReward(user) {
        require(amount != 0, "Cannot withdraw 0");

        uint256 userBalance = _balances[user];
        require(userBalance >= amount, "withdraw amount to high");

        // not using safe math, because there is no way to overflow if stake tokens not overflow
        _totalSupply = _totalSupply - amount;
        // not using safe math because of check "withdraw amount to high"
        _balances[user] = userBalance - amount;

        // not using safe transfer, because we working with trusted tokens
        require(stakingToken.transfer(recipient, amount), "token transfer failed");

        emit Withdrawn(user, amount);
    }

    /// @param user address
    /// @param recipient address, where to send reward
    function _getReward(address user, address recipient)
        internal
        virtual
        nonReentrant
        updateReward(user)
        returns (uint256 reward)
    {
        reward = rewards[user];

        if (reward != 0) {
            rewards[user] = 0;
            // not using safe transfer because reward is trusted token eg UMB
            require(rewardsToken.transfer(recipient, reward), "RewardTransferFailed");
            
            emit RewardPaid(user, reward);
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\StakingRewardsV2.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

import "./StakingLockable.sol";
import "../interfaces/IMigrationReceiver.sol";

/// @author  umb.network
contract StakingRewardsV2 is StakingLockable {
    constructor(
        address _owner,
        address _rewardsDistribution,
        address _umb,
        address _rUmb1,
        address _rUmb2
    ) StakingLockable(_owner, _rewardsDistribution, _umb, _rUmb1, _rUmb2) {}

    /// @param _newPool address of new pool, where tokens will be staked
    /// @param _data additional data for new pool
    function getRewardAndMigrate(IMigrationReceiver _newPool, bytes calldata _data) external {
        uint256 reward = _getReward(msg.sender, address(_newPool));
        _newPool.migrateTokenCallback(rUmb2, msg.sender, reward, _data);
    }

    /// @param _newPool address of new pool, where tokens will be staked
    /// @param _amount amount of staked tokens to migrate to new pool
    /// @param _data additional data for new pool
    function withdrawAndMigrate(IMigrationReceiver _newPool, uint256 _amount, bytes calldata _data) external {
        _withdraw(_amount, msg.sender, address(_newPool));
        _newPool.migrateTokenCallback(umb, msg.sender, _amount, _data);
    }

    function unlockAndMigrate(IMigrationReceiver _newPool, uint256[] calldata _ids, bytes calldata _data) external {
        (address token, uint256 totalRawAmount) = _unlockTokensFor(msg.sender, _ids, address(_newPool));
        _newPool.migrateTokenCallback(token, msg.sender, totalRawAmount, _data);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\Strings.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

/**
 * @dev String operations.
 */
library Strings {
    /**
     * @dev Converts a `uint256` to its ASCII `string` representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        uint256 index = digits - 1;
        temp = value;
        while (temp != 0) {
            buffer[index--] = byte(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(buffer);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\SwappableTokenV2.sol
File type: .sol
//SPDX-License-Identifier: MIT
pragma solidity 0.7.5;

// Inheritance
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import "../interfaces/Owned.sol";
import "../interfaces/ISwapReceiver.sol";


/// @title   Umbrella Rewards contract V2
/// @author  umb.network
/// @notice  This contract serves Swap functionality for rewards tokens
/// @dev     It allows to swap itself for other token (main UMB token).
abstract contract SwappableTokenV2 is Owned, ERC20 {
    struct SwapData {
        // number of tokens swapped so far (no decimals)
        uint32 swappedSoFar;
        // used limit since last swap (no decimals)
        uint32 usedLimit;
        // daily cup (no decimals)
        uint32 dailyCup;
        uint32 dailyCupTimestamp;
        uint32 swapEnabledAt;
    }

    uint256 public constant ONE = 1e18;

    uint256 public immutable swapStartsOn;
    ISwapReceiver public immutable umb;

    SwapData public swapData;

    event LogStartEarlySwapNow(uint time);
    event LogSwap(address indexed swappedTo, uint amount);
    event LogDailyCup(uint newCup);

    constructor(address _umb, uint32 _swapStartsOn, uint32 _dailyCup) {
        require(_dailyCup != 0, "invalid dailyCup");
        require(_swapStartsOn > block.timestamp, "invalid swapStartsOn");
        require(ERC20(_umb).decimals() == 18, "invalid UMB token");

        swapStartsOn = _swapStartsOn;
        umb = ISwapReceiver(_umb);
        swapData.dailyCup = _dailyCup;
    }

    function swapForUMB() external {
        SwapData memory data = swapData;

        (uint256 limit, bool fullLimit) = _currentLimit(data);
        require(limit != 0, "swapping period not started OR limit");

        uint256 amountToSwap = balanceOf(msg.sender);
        require(amountToSwap != 0, "you dont have tokens to swap");

        uint32 amountWoDecimals = uint32(amountToSwap / ONE);
        require(amountWoDecimals <= limit, "daily CUP limit");

        swapData.usedLimit = uint32(fullLimit ? amountWoDecimals : data.usedLimit + amountWoDecimals);
        swapData.swappedSoFar += amountWoDecimals;
        if (fullLimit) swapData.dailyCupTimestamp = uint32(block.timestamp);

        _burn(msg.sender, amountToSwap);
        umb.swapMint(msg.sender, amountToSwap);

        emit LogSwap(msg.sender, amountToSwap);
    }

    function startEarlySwap() external onlyOwner {
        require(block.timestamp < swapStartsOn, "swap is already allowed");
        require(swapData.swapEnabledAt == 0, "swap was already enabled");

        swapData.swapEnabledAt = uint32(block.timestamp);
        emit LogStartEarlySwapNow(block.timestamp);
    }

    /// @param _cup daily cup limit (no decimals), eg. if cup=5 means it is 5 * 10^18 tokens
    function setDailyCup(uint32 _cup) external onlyOwner {
        swapData.dailyCup = _cup;
        emit LogDailyCup(_cup);
    }

    function isSwapStarted() external view returns (bool) {
        // will it save gas if I do 2x if??
        return block.timestamp >= swapStartsOn || swapData.swapEnabledAt != 0;
    }

    function canSwapTokens(address _address) external view returns (bool) {
        uint256 balance = balanceOf(_address);
        if (balance == 0) return false;

        (uint256 limit,) = _currentLimit(swapData);
        return balance / ONE <= limit;
    }

    function currentLimit() external view returns (uint256 limit) {
        (limit,) = _currentLimit(swapData);
        limit *= ONE;
    }

    function _currentLimit(SwapData memory data) internal view returns (uint256 limit, bool fullLimit) {
        if (block.timestamp < swapStartsOn && data.swapEnabledAt == 0) return (0, false);

        fullLimit = block.timestamp - data.dailyCupTimestamp >= 24 hours;
        limit = fullLimit ? data.dailyCup : data.dailyCup - data.usedLimit;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\TickMath.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Math library for computing sqrt prices from ticks and vice versa
/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
/// prices between 2**-128 and 2**128
library TickMath {
    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
    int24 internal constant MIN_TICK = -887272;
    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
    int24 internal constant MAX_TICK = -MIN_TICK;

    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    /// @notice Calculates sqrt(1.0001^tick) * 2^96
    /// @dev Throws if |tick| > max tick
    /// @param tick The input tick for the above formula
    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
    /// at the given tick
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        require(absTick <= uint256(MAX_TICK), 'T');

        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

        if (tick > 0) ratio = type(uint256).max / ratio;

        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
    }

    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
    /// ever return.
    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        // second inequality must be < because the price can never reach the price at the max tick
        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb = 0;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }

        if (msb >= 128) r = ratio >> (msb - 127);
        else r = ratio << (127 - msb);

        int256 log_2 = (int256(msb) - 128) << 64;

        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(63, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(62, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(61, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(60, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(59, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(58, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(57, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(56, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(55, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(54, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(53, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(52, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(51, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(50, f))
        }

        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number

        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\UMB.sol
File type: .sol
/**
 *Submitted for verification at Etherscan.io on 2021-02-08
*/

// File: @openzeppelin/contracts/math/SafeMath.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the substraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryDiv}.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}

// File: @openzeppelin/contracts/utils/Context.sol


pragma solidity >=0.6.0 <0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol


pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @openzeppelin/contracts/token/ERC20/ERC20.sol


pragma solidity >=0.6.0 <0.8.0;




/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor (string memory name_, string memory symbol_) public {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal virtual {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}

// File: @openzeppelin/contracts/access/Ownable.sol


pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: contracts/interfaces/Owned.sol

pragma solidity 0.7.5;


abstract contract Owned is Ownable {
    constructor(address _owner) {
        transferOwnership(_owner);
    }
}

// File: contracts/interfaces/ISwapReceiver.sol

pragma solidity 0.7.5;

interface ISwapReceiver {
    function swapMint(address _holder, uint256 _amount) external;
}

// File: contracts/interfaces/SwappableToken.sol

pragma solidity 0.7.5;

// Inheritance






/// @title   Umbrella Rewards contract
/// @author  umb.network
/// @notice  This contract serves Swap functionality for rewards tokens
/// @dev     It allows to swap itself for other token (main UMB token).
///          Swap can start 1y from deployment or can be triggered earlier by owner.
///          There is a daily limit for swapping so we can't swap all at once.
///          When swap is executing, this contract do not care about target token,
///          so target token should be responsible for all the check before he mint tokens for swap.
abstract contract SwappableToken is Owned, ERC20 {
    using SafeMath for uint256;

    uint256 public totalAmountToBeSwapped;
    uint256 public swappedSoFar;
    uint256 public swapStartsOn;
    uint256 public swapDuration;

    // ========== CONSTRUCTOR ========== //

    constructor(uint _totalAmountToBeSwapped, uint _swapDuration) {
        require(_totalAmountToBeSwapped != 0, "_totalAmountToBeSwapped is empty");
        require(_swapDuration != 0, "swapDuration is empty");

        totalAmountToBeSwapped = _totalAmountToBeSwapped;
        swapStartsOn = block.timestamp + 365 days;
        swapDuration = _swapDuration;
    }

    // ========== MODIFIERS ========== //

    // ========== VIEWS ========== //

    function isSwapStarted() public view returns (bool) {
        return block.timestamp >= swapStartsOn;
    }

    function canSwapTokens(address _address) public view returns (bool) {
        return balanceOf(_address) <= totalUnlockedAmountOfToken().sub(swappedSoFar);
    }

    function totalUnlockedAmountOfToken() public view returns (uint256) {
        if (block.timestamp < swapStartsOn)
            return 0;
        if (block.timestamp >= swapStartsOn.add(swapDuration)) {
            return totalSupply().add(swappedSoFar);
        } else {
            return totalSupply().add(swappedSoFar).mul(block.timestamp.sub(swapStartsOn)).div(swapDuration);
        }
    }

    // ========== MUTATIVE FUNCTIONS ========== //

    function swapFor(ISwapReceiver _umb) external {
        require(block.timestamp >= swapStartsOn, "swapping period has not started yet");

        uint amountToSwap = balanceOf(_msgSender());

        require(amountToSwap != 0, "you dont have tokens to swap");
        require(amountToSwap <= totalUnlockedAmountOfToken().sub(swappedSoFar), "your swap is over the limit");

        swappedSoFar = swappedSoFar.add(amountToSwap);

        _burn(_msgSender(), amountToSwap);
        _umb.swapMint(_msgSender(), amountToSwap);

        emit LogSwap(_msgSender(), amountToSwap);
    }

    // ========== PRIVATE / INTERNAL ========== //

    // ========== RESTRICTED FUNCTIONS ========== //

    function startEarlySwap() external onlyOwner {
        require(block.timestamp < swapStartsOn, "swap is already allowed");

        swapStartsOn = block.timestamp;
        emit LogStartEarlySwapNow(block.timestamp);
    }

    // ========== EVENTS ========== //

    event LogStartEarlySwapNow(uint time);
    event LogSwap(address indexed swappedTo, uint amount);
}

// File: contracts/interfaces/IBurnableToken.sol

pragma solidity 0.7.5;

interface IBurnableToken {
    function burn(uint256 _amount) external;
}

// File: contracts/interfaces/MintableToken.sol

pragma solidity 0.7.5;

// Inheritance





/// @title   Umbrella Rewards contract
/// @author  umb.network
/// @notice  This contract allows to mint tokens and burn key (renounceOwnership)
/// @dev     Can be use used with MultiSig as owner
abstract contract MintableToken is Owned, ERC20, IBurnableToken {
    using SafeMath for uint256;

    // ========== STATE VARIABLES ========== //

    uint256 public maxAllowedTotalSupply;

    // ========== CONSTRUCTOR ========== //

    constructor (uint256 _maxAllowedTotalSupply) {
        require(_maxAllowedTotalSupply != 0, "_maxAllowedTotalSupply is empty");
        maxAllowedTotalSupply = _maxAllowedTotalSupply;
    }

    // ========== MODIFIERS ========== //

    modifier assertMaxSupply(uint256 _amountToMint) {
        require(totalSupply().add(_amountToMint) <= maxAllowedTotalSupply, "total supply limit exceeded");
        _;
    }

    // ========== MUTATIVE FUNCTIONS ========== //

    function burn(uint256 _amount) override external {
        uint balance = balanceOf(msg.sender);
        require(_amount <= balance, "not enough tokens to burn");

        _burn(msg.sender, _amount);
        maxAllowedTotalSupply = maxAllowedTotalSupply - _amount;
    }

    // ========== RESTRICTED FUNCTIONS ========== //

    function mint(address _holder, uint256 _amount)
    external
    onlyOwner()
    assertMaxSupply(_amount) {
        require(_amount > 0, "zero amount");

        _mint(_holder, _amount);
    }
}

// File: contracts/interfaces/Airdrop.sol

pragma solidity 0.7.5;

// Inheritance


/// @title   Umbrella Airdrop contract
/// @author  umb.network
/// @notice  This contract provides Airdrop capability.
abstract contract Airdrop is ERC20 {
    function airdropTokens(
        address[] calldata _addresses,
        uint256[] calldata _amounts
    ) external {
        require(_addresses.length != 0, "there are no _addresses");
        require(_addresses.length == _amounts.length, "the number of _addresses should match _amounts");

        for(uint i = 0; i < _addresses.length; i++) {
            transfer(_addresses[i], _amounts[i]);
        }
    }
}

// File: contracts/UMB.sol

pragma solidity 0.7.5;

// import "@nomiclabs/buidler/console.sol";

// Inheritance








/// @title   Umbrella Rewards contract
/// @author  umb.network
/// @notice  This is main UMB token
///
/// @dev     Owner (multisig) can set list of rewards tokens rUMB. rUMBs can be swapped to UMB.
///          This token can be mint by owner eg we need UMB for auction. After that we can burn the key
///          so nobody can mint anymore.
///          It has limit for max total supply, so we need to make sure, total amount of rUMBs fit this limit.
contract UMB is MintableToken, Airdrop, ISwapReceiver {
    using SafeMath for uint256;

    // ========== STATE VARIABLES ========== //

    mapping(address => bool) rewardsTokens;

    // ========== CONSTRUCTOR ========== //

    constructor (
        address _owner,
        address _initialHolder,
        uint _initialBalance,
        uint256 _maxAllowedTotalSupply,
        string memory _name,
        string memory _symbol
    )
    Owned(_owner)
    ERC20(_name, _symbol)
    MintableToken(_maxAllowedTotalSupply) {
        if (_initialHolder != address(0) && _initialBalance != 0) {
            _mint(_initialHolder, _initialBalance);
        }
    }

    // ========== MODIFIERS ========== //

    // ========== MUTATIVE FUNCTIONS ========== //

    // ========== PRIVATE / INTERNAL ========== //

    // ========== RESTRICTED FUNCTIONS ========== //

    function setRewardTokens(address[] calldata _tokens, bool[] calldata _statuses)
    external
    onlyOwner {
        require(_tokens.length > 0, "please pass a positive number of reward tokens");
        require(_tokens.length == _statuses.length, "please pass same number of tokens and statuses");

        for (uint i = 0; i < _tokens.length; i++) {
            rewardsTokens[_tokens[i]] = _statuses[i];
        }

        emit LogSetRewardTokens(_tokens, _statuses);
    }

    function swapMint(address _holder, uint256 _amount) public override assertMaxSupply(_amount) {
        require(rewardsTokens[_msgSender()], "only reward token can be swapped");

        _mint(_holder, _amount);
    }

    // ========== EVENTS ========== //

    event LogSetRewardTokens(address[] tokens, bool[] statuses);
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\UmbMultiSig.sol
File type: .sol
/**
 *Submitted for verification at Etherscan.io on 2021-02-08
*/

// File: @openzeppelin/contracts/math/SafeMath.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the substraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryDiv}.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}

// File: contracts/interfaces/PowerMultiSig.sol

pragma solidity 0.7.5;

// Inheritance


// TODO remove power user

/// @title   Multi Signature base on Power
/// @author  umb.network
/// @notice  It's based on https://github.com/gnosis/MultiSigWallet but modified in a way to support power of vote.
///          It has option to assign power to owners, so we can have "super owner(s)".
abstract contract PowerMultiSig {
    using SafeMath for uint256;

    uint256 constant public MAX_OWNER_COUNT = 5;

    struct Transaction {
        address destination;
        uint256 value;
        uint256 executed;
        bytes data;
    }

    mapping(uint256 => Transaction) public transactions;
    mapping(uint256 => mapping(address => bool)) public confirmations;
    mapping(address => uint256) public ownersPowers;
    address[] public owners;

    uint256 public requiredPower;
    uint256 public totalCurrentPower;
    uint256 public transactionCount;

    // ========== MODIFIERS ========== //

    modifier onlyWallet() {
        require(msg.sender == address(this), "only MultiSigMinter can execute this");
        _;
    }

    modifier whenOwnerDoesNotExist(address _owner) {
        require(ownersPowers[_owner] == 0, "owner already exists");
        _;
    }

    modifier whenOwnerExists(address _owner) {
        require(ownersPowers[_owner] > 0, "owner do NOT exists");
        _;
    }

    modifier whenTransactionExists(uint256 _transactionId) {
        require(transactions[_transactionId].destination != address(0), "transaction does not exists");
        _;
    }

    modifier whenConfirmedBy(uint256 _transactionId, address _owner) {
        require(confirmations[_transactionId][_owner], "transaction NOT confirmed by owner");
        _;
    }

    modifier notConfirmedBy(uint256 _transactionId, address _owner) {
        require(!confirmations[_transactionId][_owner], "transaction already confirmed by owner");
        _;
    }

    modifier whenNotExecuted(uint256 _transactionId) {
        require(transactions[_transactionId].executed == 0, "transaction already executed");
        _;
    }

    modifier notNull(address _address) {
        require(_address != address(0), "address is empty");
        _;
    }

    modifier validRequirement(uint256 _totalOwnersCount, uint256 _totalPowerSum, uint256 _requiredPower) {
        require(_totalPowerSum >= _requiredPower, "owners do NOT have enough power");
        require(_totalOwnersCount <= MAX_OWNER_COUNT, "too many owners");
        require(_requiredPower != 0, "_requiredPower is zero");
        require(_totalOwnersCount != 0, "_totalOwnersCount is zero");
        _;
    }

    // ========== CONSTRUCTOR ========== //

    constructor(address[] memory _owners, uint256[] memory _powers, uint256 _requiredPower)
    validRequirement(_owners.length, sum(_powers), _requiredPower)
    {
        uint256 sumOfPowers = 0;

        for (uint256 i = 0; i < _owners.length; i++) {
            require(ownersPowers[_owners[i]] == 0, "owner already exists");
            require(_owners[i] != address(0), "owner is empty");
            require(_powers[i] != 0, "power is empty");

            ownersPowers[_owners[i]] = _powers[i];
            sumOfPowers = sumOfPowers.add(_powers[i]);
        }

        owners = _owners;
        requiredPower = _requiredPower;
        totalCurrentPower = sumOfPowers;
    }

    // ========== MODIFIERS ========== //

    function addOwner(address _owner, uint256 _power)
    public
    onlyWallet
    whenOwnerDoesNotExist(_owner)
    notNull(_owner)
    validRequirement(owners.length + 1, totalCurrentPower + _power, requiredPower)
    {
        require(_power != 0, "_power is empty");

        ownersPowers[_owner] = _power;
        owners.push(_owner);
        totalCurrentPower = totalCurrentPower.add(_power);

        emit LogOwnerAddition(_owner, _power);
    }

    function removeOwner(address _owner) public onlyWallet whenOwnerExists(_owner)
    {
        uint256 ownerPower = ownersPowers[_owner];
        require(
            totalCurrentPower - ownerPower >= requiredPower,
            "can't remove owner, because there will be not enough power left"
        );

        ownersPowers[_owner] = 0;
        totalCurrentPower = totalCurrentPower.sub(ownerPower);

        for (uint256 i = 0; i < owners.length - 1; i++) {
            if (owners[i] == _owner) {
                owners[i] = owners[owners.length - 1];
                break;
            }
        }

        owners.pop();

        emit LogOwnerRemoval(_owner);
    }

    function replaceOwner(address _oldOwner, address _newOwner)
    public
    onlyWallet
    whenOwnerExists(_oldOwner)
    whenOwnerDoesNotExist(_newOwner)
    {
        for (uint256 i = 0; i < owners.length; i++) {
            if (owners[i] == _oldOwner) {
                owners[i] = _newOwner;
                break;
            }
        }

        uint256 power = ownersPowers[_oldOwner];
        ownersPowers[_newOwner] = power;
        ownersPowers[_oldOwner] = 0;

        emit LogOwnerRemoval(_oldOwner);
        emit LogOwnerAddition(_newOwner, power);
    }

    function changeRequiredPower(uint256 _newPower)
    public
    onlyWallet
    validRequirement(owners.length, totalCurrentPower, _newPower)
    {
        requiredPower = _newPower;
        emit LogPowerChange(_newPower);
    }

    function submitTransaction(address _destination, uint256 _value, bytes memory _data)
    public
    returns (uint256 transactionId)
    {
        transactionId = _addTransaction(_destination, _value, _data);
        confirmTransaction(transactionId);
    }

    function confirmTransactions(uint256[] calldata _transactionsIds) external {
        for (uint i=0; i < _transactionsIds.length; i++) {
            confirmTransaction(_transactionsIds[i]);
        }
    }

    function confirmTransaction(uint256 _transactionId)
    public
    whenOwnerExists(msg.sender)
    whenTransactionExists(_transactionId)
    notConfirmedBy(_transactionId, msg.sender)
    {
        confirmations[_transactionId][msg.sender] = true;
        emit LogConfirmation(msg.sender, _transactionId);
        executeTransaction(_transactionId);
    }

    /// @dev Allows an owner to revoke a confirmation for a transaction.
    /// @param _transactionId Transaction ID.
    function revokeLogConfirmation(uint256 _transactionId)
    public
    whenOwnerExists(msg.sender)
    whenConfirmedBy(_transactionId, msg.sender)
    whenNotExecuted(_transactionId)
    {
        confirmations[_transactionId][msg.sender] = false;
        emit LogRevocation(msg.sender, _transactionId);
    }

    function executeTransactions(uint256[] calldata _transactionsIds) external {
        for (uint i=0; i < _transactionsIds.length; i++) {
            executeTransaction(_transactionsIds[i]);
        }
    }

    /// @dev Allows anyone to execute a confirmed transaction.
    /// @param _transactionId Transaction ID.
    function executeTransaction(uint256 _transactionId)
    public
    whenOwnerExists(msg.sender)
    whenConfirmedBy(_transactionId, msg.sender)
    whenNotExecuted(_transactionId)
    {
        if (isConfirmed(_transactionId)) {
            Transaction storage txn = transactions[_transactionId];
            txn.executed = block.timestamp;

            (bool success, bytes memory returnedData) = txn.destination.call(txn.data);

            require(success, string(abi.encodePacked("executeTransaction failed: ", string(returnedData))));

            emit LogExecution(_transactionId, returnedData);
        }
    }

    function _addTransaction(address _destination, uint256 _value, bytes memory _data)
    internal
    notNull(_destination)
    returns (uint256 transactionId)
    {
        transactionId = transactionCount;

        transactions[transactionId] = Transaction({
            destination : _destination,
            value : _value,
            data : _data,
            executed : 0
        });

        transactionCount += 1;
        emit LogSubmission(transactionId);
    }

    // ========== VIEWS ========== //

    function ownersCount() public view returns (uint256) {
        return owners.length;
    }

    function sum(uint256[] memory _numbers) public pure returns (uint256 total) {
        uint256 numbersCount = _numbers.length;

        for (uint256 i = 0; i < numbersCount; i++) {
            total += _numbers[i];
        }
    }

    function isConfirmed(uint256 _transactionId) public view returns (bool) {
        uint256 power = 0;

        for (uint256 i = 0; i < owners.length; i++) {
            if (confirmations[_transactionId][owners[i]]) {
                power += ownersPowers[owners[i]];
            }

            if (power >= requiredPower) {
                return true;
            }
        }

        return false;
    }

    function isExceuted(uint256 _transactionId) public view returns (bool) {
        return transactions[_transactionId].executed != 0;
    }

    function getTransactionShort(uint256 _transactionId)
    public view returns (address destination, uint256 value, uint256 executed) {
        Transaction memory t = transactions[_transactionId];
        return (t.destination, t.value, t.executed);
    }

    function getTransaction(uint256 _transactionId)
    public view returns (address destination, uint256 value, uint256 executed, bytes memory data) {
        Transaction memory t = transactions[_transactionId];
        return (t.destination, t.value, t.executed, t.data);
    }

    /*
     * Web3 call functions
     */
    /// @dev Returns number of confirmations of a transaction.
    /// @param _transactionId Transaction ID.
    /// @return count Number of confirmations.
    function getLogConfirmationCount(uint256 _transactionId) public view returns (uint256 count)
    {
        for (uint256 i = 0; i < owners.length; i++) {
            if (confirmations[_transactionId][owners[i]]) {
                count += 1;
            }
        }
    }

    /// @dev Returns total number of transactions after filers are applied.
    /// @param _pending Include pending transactions.
    /// @param _executed Include executed transactions.
    /// @return count Total number of transactions after filters are applied.
    function getTransactionCount(bool _pending, bool _executed) public view returns (uint256 count)
    {
        for (uint256 i = 0; i < transactionCount; i++) {
            if (_pending && transactions[i].executed == 0 || _executed && transactions[i].executed != 0) {
                count += 1;
            }
        }
    }

    /// @dev Returns array with owner addresses, which confirmed transaction.
    /// @param _transactionId Transaction ID.
    /// @return _confirmations Returns array of owner addresses.
    function getLogConfirmations(uint256 _transactionId)
    public
    view
    returns (address[] memory _confirmations)
    {
        address[] memory confirmationsTemp = new address[](owners.length);
        uint256 count = 0;
        uint256 i;

        for (i = 0; i < owners.length; i++) {
            if (confirmations[_transactionId][owners[i]]) {
                confirmationsTemp[count] = owners[i];
                count += 1;
            }
        }

        _confirmations = new address[](count);

        for (i = 0; i < count; i++) {
            _confirmations[i] = confirmationsTemp[i];
        }
    }

    /// @dev Returns list of transaction IDs in defined range.
    /// @param _from Index start position of transaction array.
    /// @param _to Index end position of transaction array.
    /// @param _pending Include pending transactions.
    /// @param _executed Include executed transactions.
    /// @return _transactionIds Returns array of transaction IDs.
    function getTransactionIds(uint256 _from, uint256 _to, bool _pending, bool _executed)
    public
    view
    returns (uint256[] memory _transactionIds)
    {
        uint256[] memory transactionIdsTemp = new uint256[](_to - _from);
        uint256 count = 0;
        uint256 i;

        for (i = _from; i < _to; i++) {
            if (_pending && transactions[i].executed == 0 || _executed && transactions[i].executed != 0) {
                transactionIdsTemp[count] = i;
                count += 1;
            }
        }

        _transactionIds = new uint256[](count);

        for (i = 0; i < count; i++) {
            _transactionIds[i] = transactionIdsTemp[i];
        }
    }

    // ========== EVENTS ========== //

    event LogConfirmation(address indexed sender, uint256 indexed transactionId);
    event LogRevocation(address indexed sender, uint256 indexed transactionId);
    event LogSubmission(uint256 indexed transactionId);
    event LogExecution(uint256 indexed transactionId, bytes returnedData);
    event LogOwnerAddition(address indexed owner, uint256 power);
    event LogOwnerRemoval(address indexed owner);
    event LogPowerChange(uint256 power);
}

// File: contracts/UmbMultiSig.sol

pragma solidity 0.7.5;

// Inheritance


/// @title   Umbrella MultiSig contract
/// @author  umb.network
/// @notice  This is extended version of PowerMultiSig wallet, that will allow to execute commands without FE.
/// @dev     Original MultiSig requires FE to run, but here, we have some predefined data for few transactions
///          so we can run it directly from Etherscan and not worry about data bytes
contract UmbMultiSig is PowerMultiSig {

    // ========== MODIFIERS ========== //

    // ========== CONSTRUCTOR ========== //

    constructor(address[] memory _owners, uint256[] memory _powers, uint256 _requiredPower)
    PowerMultiSig(_owners, _powers, _requiredPower) {
    }

    // ========== VIEWS ========== //

    function createFunctionSignature(string memory _f) public pure returns (bytes memory) {
        return abi.encodeWithSignature(_f);
    }

    // ========== MUTATIVE FUNCTIONS ========== //

    // ========== helpers for: MultiSig

    function submitAddOwner(address _owner, uint256 _power) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("addOwner(address,uint256)", _owner, _power);
        return submitTransaction(address(this), 0, data);
    }

    function submitRemoveOwner(address _owner) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("removeOwner(address)", _owner);
        return submitTransaction(address(this), 0, data);
    }

    function submitReplaceOwner(address _old, address _new) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("replaceOwner(address,address)", _old, _new);
        return submitTransaction(address(this), 0, data);
    }

    function submitChangeRequiredPower(uint256 _power) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("changeRequiredPower(uint256)", _power);
        return submitTransaction(address(this), 0, data);
    }

    // ========== helpers for: UMB, rUMB

    function submitTokenMintTx(address _destination, address _holder, uint _amount) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("mint(address,uint256)", _holder, _amount);
        return submitTransaction(_destination, 0, data);
    }

    // ========== helpers for: UMB

    function submitUMBSetRewardTokensTx(
        address _destination,
        address[] memory _tokens,
        bool[] calldata _statuses
    ) external returns (uint) {
        bytes memory data = abi.encodeWithSignature("setRewardTokens(address[],bool[])", _tokens, _statuses);
        return submitTransaction(_destination, 0, data);
    }

    // ========== helpers for: rUMB

    function submitRUMBStartEarlySwapTx(address _destination) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("startEarlySwap()");
        return submitTransaction(_destination, 0, data);
    }

    // ========== helpers for: StakingRewards

    function submitStakingRewardsSetRewardsDistributionTx(
        address _destination,
        address _rewardsDistributor
    ) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("setRewardsDistribution(address)", _rewardsDistributor);
        return submitTransaction(_destination, 0, data);
    }

    function submitStakingRewardsSetRewardsDurationTx(address _destination, uint _duration) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("setRewardsDuration(uint256)", _duration);
        return submitTransaction(_destination, 0, data);
    }

    function submitStakingRewardsNotifyRewardAmountTx(address _destination, uint _amount) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("notifyRewardAmount(uint256)", _amount);
        return submitTransaction(_destination, 0, data);
    }

    function submitStakingRewardsFinishFarmingTx(address _destination) public returns (uint) {
        bytes memory data = abi.encodeWithSignature("finishFarming()");
        return submitTransaction(_destination, 0, data);
    }

    // ========== EVENTS ========== //
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\UniswapV2LPTokenCounter.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

interface IStaking {
    function balanceOf(address _account) external view returns (uint256);
    function stakingToken() external view returns (ERC20);
}

interface ILP {
    function balanceOf(address _account) external view returns (uint256);
    function getReserves() external view returns (uint112 reserve0 , uint112 reserve1 , uint32 blockTimestampLast);
    function token0() external view returns (address);
    function totalSupply() external view returns (uint256);
}

import "hardhat/console.sol";

// This contracts calculates balance of target token, that was provided as liquidity and then staked
contract UniswapV2LPTokenCounter is ERC20 {
    // token which we want to track
    ERC20 public immutable token;

    // UniV2 pool, where `token` were used as liquidity
    ILP public immutable lpPool;

    // staking contract, where LP token were staked
    IStaking public immutable staking;

    constructor(address _token, address _lpPool, address _staking) ERC20("UniV2LPTokenCounter", "UniV2LPTokenCounter") {
        token = ERC20(_token);
        lpPool = ILP(_lpPool);
        staking = IStaking(_staking);
    }

    function totalSupply() public view override returns (uint256) {
        return token.totalSupply();
    }

    function balanceOf(address _account) public view override returns (uint256) {
        uint256 lpBalance = staking.balanceOf(_account) + lpPool.balanceOf(_account);
        uint256 lpShare = lpBalance * 1e18 / lpPool.totalSupply();

        (uint112 reserve0 , uint112 reserve1, ) = lpPool.getReserves();
        bool isToken0 = lpPool.token0() == address(token);
        uint256 tokenReserves = isToken0 ? reserve0 : reserve1;

        return lpShare * tokenReserves / 1e18;
    }

    function _beforeTokenTransfer(address, address, uint256) internal pure override {
        revert("Non-transferable");
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\UniswapV3Helper.sol
File type: .sol
// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import "./lib/OracleLibrary.sol";


contract UniswapV3Helper {
    address public immutable uniswapV3Factory;

    bytes4 public constant SYMBOL_SELECTOR = bytes4(keccak256("symbol()"));
    bytes4 public constant DECIMALS_SELECTOR = bytes4(keccak256("decimals()"));
    bytes4 public constant GET_POOL_SELECTOR = bytes4(keccak256("getPool(address,address,uint24)"));

    struct PriceData {
        address tokenA;
        address tokenB;
        uint24 fee;
    }

    struct Price {
        uint256 price;
        bool success;
    }

    constructor(address _factory) public {
        bytes4 selector = bytes4(keccak256("feeAmountTickSpacing(uint24)"));
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = _factory.staticcall(abi.encode(selector, 500));
        require(success, "UniswapV3Oracle: invalid factory");

        uniswapV3Factory = _factory;
    }

    function tokensSymbols(address[] memory _tokens) external view returns (string[] memory symbols) {
        uint256 n = _tokens.length;
        symbols = new string[](n);

        for (uint256 i = 0; i < n; i++) {
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, bytes memory data) = _tokens[i].staticcall(abi.encode(SYMBOL_SELECTOR));

            symbols[i] = success
                ? data.length == 32 ? string(abi.encodePacked(data)) : abi.decode(data, (string))
                : "";
        }
    }

    function getPrices(
        PriceData[] calldata _data,
        uint32 _periodForAvgPrice
    )
        external
        view
        returns (Price[] memory prices, uint256 timestamp)
    {
        timestamp = block.timestamp;
        uint256 n = _data.length;
        prices = new Price[](n);

        for (uint256 i = 0; i < n; i++) {
            (
                prices[i].success,
                prices[i].price
            ) = getPrice(_data[i].tokenA, _data[i].tokenB, _data[i].fee, _periodForAvgPrice);
        }
    }

    /// @param _tokenA address
    /// @param _tokenB address
    /// @param _fee fee, based on which we can resolve a pool
    /// @param _periodForAvgPrice Number of seconds in the past to start calculating time-weighted average
    ///         in our case it might be the best, to set it to the Chain.padding
    function getPrice(
        address _tokenA,
        address _tokenB,
        uint24 _fee,
        uint32 _periodForAvgPrice
    ) public view returns (bool success, uint256 price) {
        address pool = resolvePool(_tokenA, _tokenB, _fee);
        if (pool == address(0)) return (false, 0);

        int24 arithmeticMeanTick;
        (success, arithmeticMeanTick, ) = OracleLibrary.consult(pool, _periodForAvgPrice);
        if (!success) return (false, 0);

        bytes memory data;

        // solhint-disable-next-line avoid-low-level-calls
        (success, data) = _tokenA.staticcall(abi.encode(DECIMALS_SELECTOR));
        if (!success) return (false, 0);

        uint256 decimals = abi.decode(data, (uint256));
        uint256 baseAmountA = 10 ** decimals;

        if (_tokenA == _tokenB) return (true, baseAmountA);

        price = OracleLibrary.getQuoteAtTick(arithmeticMeanTick, uint128(baseAmountA), _tokenA, _tokenB);
    }

    function resolvePool(address _tokenA, address _tokenB, uint24 _fee) public view returns (address pool) {
        (address token0, address token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);

        (bool success, bytes memory data) =
            // solhint-disable-next-line avoid-low-level-calls
            uniswapV3Factory.staticcall(abi.encodeWithSelector(GET_POOL_SELECTOR, token0, token1, _fee));

        return success ? abi.decode(data, (address)) : address(0);
    }
}

--------------------------------------------------
File End
--------------------------------------------------


D:\LongHe\01-PHD\02-»ùÓÚLLMµÄ¿çÁ´Â©¶´¼ì²â\10-data-deduplicate\dedup_non_vul_bridges\Umbrella Token Bridge\contracts\ValueDecoder.sol
File type: .sol
//SPDX-License-Identifier: Unlicensed
pragma solidity >=0.6.8;

library ValueDecoder {
  function toUint(bytes memory _bytes) internal pure returns (uint256 value) {
    assembly {
      value := mload(add(_bytes, 32))
    }
  }

  function toUint(bytes32 _bytes) internal pure returns (uint256 value) {
    assembly {
      value := _bytes
    }
  }

  function toInt(uint224 u) internal pure returns (int256) {
    int224 i;
    uint224 max = type(uint224).max;

    if (u <= (max - 1) / 2) { // positive values
      assembly {
        i := add(u, 0)
      }

      return i;
    } else { // negative values
      assembly {
        i := sub(sub(u, max), 1)
      }
    }

    return i;
  }
}

--------------------------------------------------
File End
--------------------------------------------------

Folder Structure
--------------------------------------------------
contracts/
    AccessControl.sol
    Address.sol
    Alpha_Homora_Earn_Zap_V1.sol
    Balancer_ZapIn_General_V2_5.sol
    Balancer_ZapIn_General_V4.sol
    CompoundInterface.sol
    Compound_Zap_V1.sol
    Context.sol
    Counters.sol
    CreamInterface.sol
    Curve_Registry_V2.sol
    Curve_to_Curve_Pipe.sol
    Curve_ZapIn_General_V1_4.sol
    Curve_ZapIn_General_V4.sol
    Curve_ZapOut_General_V4.sol
    ERC1155.sol
    ERC165.sol
    ERC20.sol
    ERC20toUniPoolZapV1_General.sol
    ETH_ERC20_Curve_General_Zap_V1.sol
    Harvest_ZapIn_V3.sol
    ibTokenInterface.sol
    IdleInterface.sol
    Idle_Zap_V1.sol
    IERC1155.sol
    IERC1155MetadataURI.sol
    IERC1155Receiver.sol
    IERC165.sol
    IERC20.sol
    IERC20Metadata.sol
    Ownable.sol
    Pickle_ZapOut_V1.sol
    SafeERC20.sol
    SafeMath.sol
    SignatureVerifier.sol
    SignatureVerifier_V2.sol
    Strings.sol
    Sushiswap_ZapIn_V4.sol
    Sushiswap_ZapOut_General_V3.sol
    TokenTimelock.sol
    UniSwapAddLiquityV3_General.sol
    UniswapV2_ZapIn_General_V5.sol
    UniswapV2_ZapOut_General_V4.sol
    UniswapV2_ZapOut_General_V5.sol
    UniSwap_ETH_CDAIZap.sol
    UniSwap_ETH_CHAIZap.sol
    UniSwap_ETH_DAIZap.sol
    Vesper_ZapIn_V1.sol
    ZapBaseV1.sol
    ZapBaseV2.sol
    ZapBaseV2_1.sol
    ZapInBaseV3.sol
    ZapInBaseV3_1.sol
    ZapOutBaseV2.sol
    ZapOutBaseV3.sol
    ZapOutBaseV3_1.sol
    Zapper_Matic_Bridge_V1.sol
    Zapper_Matic_Bridge_V1_2.sol
    Zapper_NFT_V1.sol
    Zapper_NFT_V2.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\AccessControl.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/Context.sol";

import "../utils/Strings.sol";

import "../utils/introspection/ERC165.sol";



/**

 * @dev External interface of AccessControl declared to support ERC165 detection.

 */

interface IAccessControl {

    function hasRole(bytes32 role, address account)

        external

        view

        returns (bool);



    function getRoleAdmin(bytes32 role) external view returns (bytes32);



    function grantRole(bytes32 role, address account) external;



    function revokeRole(bytes32 role, address account) external;



    function renounceRole(bytes32 role, address account) external;

}



/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms. This is a lightweight version that doesn't allow enumerating role

 * members except through off-chain means by accessing the contract event logs. Some

 * applications may benefit from on-chain enumerability, for those cases see

 * {AccessControlEnumerable}.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context, IAccessControl, ERC165 {

    struct RoleData {

        mapping(address => bool) members;

        bytes32 adminRole;

    }



    mapping(bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(

        bytes32 indexed role,

        bytes32 indexed previousAdminRole,

        bytes32 indexed newAdminRole

    );



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {_setupRole}.

     */

    event RoleGranted(

        bytes32 indexed role,

        address indexed account,

        address indexed sender

    );



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(

        bytes32 indexed role,

        address indexed account,

        address indexed sender

    );



    /**

     * @dev Modifier that checks that an account has a specific role. Reverts

     * with a standardized message including the required role.

     *

     * The format of the revert reason is given by the following regular expression:

     *

     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/

     *

     * _Available since v4.1._

     */

    modifier onlyRole(bytes32 role) {

        _checkRole(role, _msgSender());

        _;

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId)

        public

        view

        virtual

        override

        returns (bool)

    {

        return

            interfaceId == type(IAccessControl).interfaceId ||

            super.supportsInterface(interfaceId);

    }



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account)

        public

        view

        override

        returns (bool)

    {

        return _roles[role].members[account];

    }



    /**

     * @dev Revert with a standard message if `account` is missing `role`.

     *

     * The format of the revert reason is given by the following regular expression:

     *

     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/

     */

    function _checkRole(bytes32 role, address account) internal view {

        if (!hasRole(role, account)) {

            revert(

                string(

                    abi.encodePacked(

                        "AccessControl: account ",

                        Strings.toHexString(uint160(account), 20),

                        " is missing role ",

                        Strings.toHexString(uint256(role), 32)

                    )

                )

            );

        }

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account)

        public

        virtual

        override

        onlyRole(getRoleAdmin(role))

    {

        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account)

        public

        virtual

        override

        onlyRole(getRoleAdmin(role))

    {

        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account)

        public

        virtual

        override

    {

        require(

            account == _msgSender(),

            "AccessControl: can only renounce roles for self"

        );



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (!hasRole(role, account)) {

            _roles[role].members[account] = true;

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (hasRole(role, account)) {

            _roles[role].members[account] = false;

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(

            address(this).balance >= amount,

            "Address: insufficient balance"

        );



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(

            success,

            "Address: unable to send value, recipient may have reverted"

        );

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data)

        internal

        returns (bytes memory)

    {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return

            functionCallWithValue(

                target,

                data,

                value,

                "Address: low-level call with value failed"

            );

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(

            address(this).balance >= value,

            "Address: insufficient balance for call"

        );

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) =

            target.call{ value: value }(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data)

        internal

        view

        returns (bytes memory)

    {

        return

            functionStaticCall(

                target,

                data,

                "Address: low-level static call failed"

            );

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.staticcall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data)

        internal

        returns (bytes memory)

    {

        return

            functionDelegateCall(

                target,

                data,

                "Address: low-level delegate call failed"

            );

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.delegatecall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    function _verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) private pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Alpha_Homora_Earn_Zap_V1.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract deposits and withdraws assets to/from Alpha Homora V2 Earn
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapInBaseV3_1.sol";
import "../_base/ZapOutBaseV3_1.sol";
import "./ibTokenInterface.sol";
import "../Cream/CreamInterface.sol";

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}

contract Alpha_Homora_Earn_Zap_V1 is ZapInBaseV3_1, ZapOutBaseV3_1 {
    using SafeERC20 for IERC20;

    address private constant wethTokenAddress =
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    address private constant ibETH = 0xeEa3311250FE4c3268F8E684f7C87A82fF183Ec1;

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2_1(_goodwill, _affiliateSplit)
    {
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
        transferOwnership(ZapperAdmin);
    }

    event zapIn(
        address sender,
        address token,
        uint256 tokensRec,
        address affiliate
    );
    event zapOut(
        address sender,
        address token,
        uint256 tokensRec,
        address affiliate
    );

    /**
    @notice This function deposits assets into Alpha Homora V2 Earn with ETH or ERC20 tokens
    @param fromToken The token used for entry (address(0) if ether)
    @param amountIn The amount of fromToken to invest
    @param ibToken Address of the ibToken
    @param minIbTokens The minimum acceptable quantity ibTokens to receive. Reverts otherwise
    @param swapTarget Excecution target for the swap or zap
    @param swapData DEX or Zap data. Must swap to ibToken underlying address
    @param affiliate Affiliate address
    @return ibTokensRec Quantity of ibTokens received
     */
    function ZapIn(
        address fromToken,
        uint256 amountIn,
        address ibToken,
        uint256 minIbTokens,
        address swapTarget,
        bytes calldata swapData,
        address affiliate
    ) external payable stopInEmergency returns (uint256 ibTokensRec) {
        uint256 toInvest = _pullTokens(fromToken, amountIn, affiliate, true);

        address toToken = getUnderlyingToken(ibToken);

        uint256 tokensBought =
            _fillQuote(fromToken, toToken, toInvest, swapTarget, swapData);

        (ibTokensRec) = enterAlpha(ibToken, toToken, tokensBought);
        require(ibTokensRec > minIbTokens, "High Slippage");

        IERC20(ibToken).safeTransfer(msg.sender, ibTokensRec);

        emit zapIn(msg.sender, ibToken, ibTokensRec, affiliate);
    }

    function enterAlpha(
        address ibToken,
        address underlyingToken,
        uint256 underlyingAmount
    ) internal returns (uint256 ibTokensRec) {
        uint256 initialBalance = _getBalance(ibToken);

        if (underlyingToken == address(0)) {
            IibToken(ibToken).deposit{ value: underlyingAmount }();
        } else {
            _approveToken(underlyingToken, ibToken, underlyingAmount);
            IibToken(ibToken).deposit(underlyingAmount);
        }

        ibTokensRec = _getBalance(ibToken) - initialBalance;
    }

    /**
    @notice This function withdraws assets from Alpha Homora V2 Earn, receiving tokens or ETH
    @param fromToken The ibToken being withdrawn
    @param amountIn The quantity of fromToken to withdraw
    @param toToken Address of the token to receive (0 address if ETH)
    @param minToTokens The minimum acceptable quantity tokens to receive. Reverts otherwise
    @param swapTarget Excecution target for the swap or zap
    @param swapData DEX or Zap data
    @param affiliate Affiliate address
    @return tokensRec Quantity of aTokens received
     */
    function ZapOut(
        address fromToken,
        uint256 amountIn,
        address toToken,
        uint256 minToTokens,
        address swapTarget,
        bytes calldata swapData,
        address affiliate
    ) external stopInEmergency returns (uint256 tokensRec) {
        amountIn = _pullTokens(fromToken, amountIn);

        address underlyingToken = getUnderlyingToken(fromToken);

        uint256 underlyingRec = exitAlpha(fromToken, amountIn, underlyingToken);

        tokensRec = _fillQuote(
            underlyingToken,
            toToken,
            underlyingRec,
            swapTarget,
            swapData
        );

        require(tokensRec >= minToTokens, "High Slippage");

        uint256 totalGoodwillPortion;

        if (toToken == address(0)) {
            totalGoodwillPortion = _subtractGoodwill(
                ETHAddress,
                tokensRec,
                affiliate,
                true
            );

            payable(msg.sender).transfer(tokensRec - totalGoodwillPortion);
        } else {
            totalGoodwillPortion = _subtractGoodwill(
                toToken,
                tokensRec,
                affiliate,
                true
            );

            IERC20(toToken).safeTransfer(
                msg.sender,
                tokensRec - totalGoodwillPortion
            );
        }

        tokensRec = tokensRec - totalGoodwillPortion;

        emit zapOut(msg.sender, toToken, tokensRec, affiliate);
    }

    function exitAlpha(
        address ibToken,
        uint256 ibTokenAmount,
        address underlyingToken
    ) internal returns (uint256 underlyingRec) {
        uint256 initialBalance = _getBalance(underlyingToken);

        IibToken(ibToken).withdraw(ibTokenAmount);

        underlyingRec = _getBalance(underlyingToken) - initialBalance;
    }

    function _fillQuote(
        address fromToken,
        address toToken,
        uint256 amount,
        address swapTarget,
        bytes memory swapData
    ) internal returns (uint256 amountBought) {
        if (fromToken == toToken) {
            return amount;
        }

        if (fromToken == address(0) && toToken == wethTokenAddress) {
            IWETH(wethTokenAddress).deposit{ value: amount }();
            return amount;
        }

        if (fromToken == wethTokenAddress && toToken == address(0)) {
            IWETH(wethTokenAddress).withdraw(amount);
            return amount;
        }

        uint256 valueToSend;
        if (fromToken == address(0)) {
            valueToSend = amount;
        } else {
            _approveToken(fromToken, swapTarget, amount);
        }

        uint256 initialBalance = _getBalance(toToken);

        require(approvedTargets[swapTarget], "Target not Authorized");
        (bool success, ) = swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens");

        amountBought = _getBalance(toToken) - initialBalance;

        require(amountBought > 0, "Swapped To Invalid Intermediate");
    }

    function getCyToken(address ibToken) public view returns (address) {
        return IibToken(ibToken).cToken();
    }

    function getUnderlyingToken(address ibToken) public view returns (address) {
        return ibToken == ibETH ? address(0) : IibToken(ibToken).uToken();
    }

    function removeLiquidityReturn(address ibToken, uint256 ibTokenAmount)
        external
        view
        returns (uint256 underlyingRec)
    {
        return
            (ibTokenAmount *
                ICreamToken(getCyToken(ibToken)).exchangeRateStored()) / 10**18;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Balancer_ZapIn_General_V2_5.sol
File type: .sol
/**
 *Submitted for verification at Etherscan.io on 2020-07-30
*/

// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2020 zapper, dipeshsukhani, nodarjanashia, suhailg, sebaudet, sumitrajput, apoorvlathey

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice this contract adds liquidity to Balancer liquidity pools in one transaction

// File: @openzeppelin/contracts/utils/Address.sol

pragma solidity ^0.5.5;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;


            bytes32 accountHash
         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            codehash := extcodehash(account)
        }
        return (codehash != accountHash && codehash != 0x0);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     *
     * _Available since v2.4.0._
     */
    function toPayable(address account)
        internal
        pure
        returns (address payable)
    {
        return address(uint160(account));
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     *
     * _Available since v2.4.0._
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            "Address: insufficient balance"
        );

        // solhint-disable-next-line avoid-call-value
        (bool success, ) = recipient.call.value(amount)("");
        require(
            success,
            "Address: unable to send value, recipient may have reverted"
        );
    }
}

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol

/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

// File: @openzeppelin/contracts/GSN/Context.sol

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor() internal {}

    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: @openzeppelin/contracts/ownership/Ownable.sol

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 *
 * _Since v2.5.0:_ this module is now much more gas efficient, given net gas
 * metering changes introduced in the Istanbul hardfork.
 */
contract ReentrancyGuard {
    bool private _notEntered;

    constructor() internal {
        // Storing an initial non-zero value makes deployment a bit more
        // expensive, but in exchange the refund on every call to nonReentrant
        // will be lower in amount. Since refunds are capped to a percetange of
        // the total transaction's gas, it is best to keep them low in cases
        // like this one, to increase the likelihood of the full refund coming
        // into effect.
        _notEntered = true;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_notEntered, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _notEntered = false;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _notEntered = true;
    }
}

// File: @openzeppelin/contracts/math/SafeMath.sol

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface IBFactory {
    function isBPool(address b) external view returns (bool);
}

interface IBPool {
    function joinswapExternAmountIn(
        address tokenIn,
        uint256 tokenAmountIn,
        uint256 minPoolAmountOut
    ) external payable returns (uint256 poolAmountOut);

    function isBound(address t) external view returns (bool);

    function getFinalTokens() external view returns (address[] memory tokens);

    function totalSupply() external view returns (uint256);

    function getDenormalizedWeight(address token)
        external
        view
        returns (uint256);

    function getTotalDenormalizedWeight() external view returns (uint256);

    function getSwapFee() external view returns (uint256);

    function calcPoolOutGivenSingleIn(
        uint256 tokenBalanceIn,
        uint256 tokenWeightIn,
        uint256 poolSupply,
        uint256 totalWeight,
        uint256 tokenAmountIn,
        uint256 swapFee
    ) external pure returns (uint256 poolAmountOut);

    function getBalance(address token) external view returns (uint256);
}

interface IWETH {
    function deposit() external payable;

    function transfer(address to, uint256 value) external returns (bool);

    function withdraw(uint256) external;
}

library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0x095ea7b3, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper: APPROVE_FAILED"
        );
    }

    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0xa9059cbb, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper: TRANSFER_FAILED"
        );
    }

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0x23b872dd, from, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper: TRANSFER_FROM_FAILED"
        );
    }
}

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address);
}

interface IUniswapRouter02 {
    //get estimated amountOut
    function getAmountsOut(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    //token 2 token
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    //eth 2 token
    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    //token 2 eth
    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}

contract Balancer_ZapIn_General_V2_5 is ReentrancyGuard, Ownable {
    using SafeMath for uint256;
    using Address for address;
    bool public stopped = false;
    uint16 public goodwill;

    IBFactory BalancerFactory = IBFactory(
        0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd
    );
    IUniswapV2Factory
        private constant UniSwapV2FactoryAddress = IUniswapV2Factory(
        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f
    );
    IUniswapRouter02 private constant uniswapRouter = IUniswapRouter02(
        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
    );

    address
        private constant wethTokenAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address
        private constant dzgoodwillAddress = 0xE737b6AfEC2320f616297e59445b60a11e3eF75F;

    uint256
        private constant deadline = 0xf000000000000000000000000000000000000000000000000000000000000000;

    event Zapin(
        address _toWhomToIssue,
        address _toBalancerPoolAddress,
        uint256 _OutgoingBPT
    );

    constructor(uint16 _goodwill) public {
        goodwill = _goodwill;
    }

    // circuit breaker modifiers
    modifier stopInEmergency {
        if (stopped) {
            revert("Temporarily Paused");
        } else {
            _;
        }
    }

    /**
    @notice This function is used to invest in given balancer pool through ETH/ERC20 Tokens
    @param _FromTokenContractAddress The token used for investment (address(0x00) if ether)
    @param _ToBalancerPoolAddress The address of balancer pool to zapin
    @param _amount The amount of ERC to invest
    @param _minPoolTokens for slippage
    @return success or failure
     */
    function EasyZapIn(
        address _FromTokenContractAddress,
        address _ToBalancerPoolAddress,
        uint256 _amount,
        uint256 _minPoolTokens
    )
        public
        payable
        nonReentrant
        stopInEmergency
        returns (uint256 tokensBought)
    {
        require(
            BalancerFactory.isBPool(_ToBalancerPoolAddress),
            "Invalid Balancer Pool"
        );

        if (_FromTokenContractAddress == address(0)) {
            require(msg.value > 0, "ERR: No ETH sent");

            address _IntermediateToken = _getBestDeal(
                _ToBalancerPoolAddress,
                msg.value,
                _FromTokenContractAddress
            );

            tokensBought = _performZapIn(
                msg.sender,
                _FromTokenContractAddress,
                _ToBalancerPoolAddress,
                msg.value,
                _IntermediateToken,
                _minPoolTokens
            );

            return tokensBought;
        }

        require(_amount > 0, "ERR: No ERC sent");
        require(msg.value == 0, "ERR: ETH sent with tokens");

        //transfer tokens to contract
        TransferHelper.safeTransferFrom(
            _FromTokenContractAddress,
            msg.sender,
            address(this),
            _amount
        );

        address _IntermediateToken = _getBestDeal(
            _ToBalancerPoolAddress,
            _amount,
            _FromTokenContractAddress
        );

        tokensBought = _performZapIn(
            msg.sender,
            _FromTokenContractAddress,
            _ToBalancerPoolAddress,
            _amount,
            _IntermediateToken,
            _minPoolTokens
        );
    }

    /**
    @notice This function internally called by ZapIn() and EasyZapIn()
    @param _toWhomToIssue The user address who want to invest
    @param _FromTokenContractAddress The token used for investment (address(0x00) if ether)
    @param _ToBalancerPoolAddress The address of balancer pool to zapin
    @param _amount The amount of ETH/ERC to invest
    @param _IntermediateToken The token for intermediate conversion before zapin
    @param _minPoolTokens for slippage
    @return The quantity of Balancer Pool tokens returned
     */
    function _performZapIn(
        address _toWhomToIssue,
        address _FromTokenContractAddress,
        address _ToBalancerPoolAddress,
        uint256 _amount,
        address _IntermediateToken,
        uint256 _minPoolTokens
    ) internal returns (uint256 tokensBought) {
        // check if isBound()
        bool isBound = IBPool(_ToBalancerPoolAddress).isBound(
            _FromTokenContractAddress
        );

        uint256 balancerTokens;

        if (isBound) {
            balancerTokens = _enter2Balancer(
                _ToBalancerPoolAddress,
                _FromTokenContractAddress,
                _amount,
                _minPoolTokens
            );
        } else {
            // swap tokens or eth
            uint256 tokenBought;
            if (_FromTokenContractAddress == address(0)) {
                tokenBought = _eth2Token(_IntermediateToken);
            } else {
                tokenBought = _token2Token(
                    _FromTokenContractAddress,
                    _IntermediateToken,
                    _amount
                );
            }

            //get BPT
            balancerTokens = _enter2Balancer(
                _ToBalancerPoolAddress,
                _IntermediateToken,
                tokenBought,
                _minPoolTokens
            );
        }

        //transfer goodwill
        uint256 goodwillPortion = _transferGoodwill(
            _ToBalancerPoolAddress,
            balancerTokens
        );

        emit Zapin(
            _toWhomToIssue,
            _ToBalancerPoolAddress,
            SafeMath.sub(balancerTokens, goodwillPortion)
        );

        //transfer tokens to user
        TransferHelper.safeTransfer(
            _ToBalancerPoolAddress,
            _toWhomToIssue,
            SafeMath.sub(balancerTokens, goodwillPortion)
        );
        return SafeMath.sub(balancerTokens, goodwillPortion);
    }

    /**
    @notice This function is used to zapin to balancer pool
    @param _ToBalancerPoolAddress The address of balancer pool to zap in
    @param _FromTokenContractAddress The token used to zap in
    @param tokens2Trade The amount of tokens to invest
    @return The quantity of Balancer Pool tokens returned
     */
    function _enter2Balancer(
        address _ToBalancerPoolAddress,
        address _FromTokenContractAddress,
        uint256 tokens2Trade,
        uint256 _minPoolTokens
    ) internal returns (uint256 poolTokensOut) {
        require(
            IBPool(_ToBalancerPoolAddress).isBound(_FromTokenContractAddress),
            "Token not bound"
        );

        uint256 allowance = IERC20(_FromTokenContractAddress).allowance(
            address(this),
            _ToBalancerPoolAddress
        );

        if (allowance < tokens2Trade) {
            TransferHelper.safeApprove(
                _FromTokenContractAddress,
                _ToBalancerPoolAddress,
                uint256(-1)
            );
        }

        poolTokensOut = IBPool(_ToBalancerPoolAddress).joinswapExternAmountIn(
            _FromTokenContractAddress,
            tokens2Trade,
            _minPoolTokens
        );

        require(poolTokensOut > 0, "Error in entering balancer pool");
    }

    /**
    @notice This function finds best token from the final tokens of balancer pool
    @param _ToBalancerPoolAddress The address of balancer pool to zap in
    @param _amount amount of eth/erc to invest
    @param _FromTokenContractAddress the token address which is used to invest
    @return The token address having max liquidity
     */
    function _getBestDeal(
        address _ToBalancerPoolAddress,
        uint256 _amount,
        address _FromTokenContractAddress
    ) internal view returns (address _token) {
        // If input is not eth or weth
        if (
            _FromTokenContractAddress != address(0) &&
            _FromTokenContractAddress != wethTokenAddress
        ) {
            // check if input token or weth is bound and if so return it as intermediate
            bool isBound = IBPool(_ToBalancerPoolAddress).isBound(
                _FromTokenContractAddress
            );
            if (isBound) return _FromTokenContractAddress;
        }

        bool wethIsBound = IBPool(_ToBalancerPoolAddress).isBound(
            wethTokenAddress
        );
        if (wethIsBound) return wethTokenAddress;

        //get token list
        address[] memory tokens = IBPool(_ToBalancerPoolAddress)
            .getFinalTokens();

        uint256 amount = _amount;
        address[] memory path = new address[](2);

        if (
            _FromTokenContractAddress != address(0) &&
            _FromTokenContractAddress != wethTokenAddress
        ) {
            path[0] = _FromTokenContractAddress;
            path[1] = wethTokenAddress;
            //get eth value for given token
            amount = uniswapRouter.getAmountsOut(_amount, path)[1];
        }

        uint256 maxBPT;
        path[0] = wethTokenAddress;

        for (uint256 index = 0; index < tokens.length; index++) {
            uint256 expectedBPT;

            if (tokens[index] != wethTokenAddress) {
                if (
                    UniSwapV2FactoryAddress.getPair(
                        tokens[index],
                        wethTokenAddress
                    ) == address(0)
                ) {
                    continue;
                }

                //get qty of tokens
                path[1] = tokens[index];
                uint256 expectedTokens = uniswapRouter.getAmountsOut(
                    amount,
                    path
                )[1];

                //get bpt for given tokens
                expectedBPT = getToken2BPT(
                    _ToBalancerPoolAddress,
                    expectedTokens,
                    tokens[index]
                );

                //get token giving max BPT
                if (maxBPT < expectedBPT) {
                    maxBPT = expectedBPT;
                    _token = tokens[index];
                }
            } else {
                //get bpt for given weth tokens
                expectedBPT = getToken2BPT(
                    _ToBalancerPoolAddress,
                    amount,
                    tokens[index]
                );
            }

            //get token giving max BPT
            if (maxBPT < expectedBPT) {
                maxBPT = expectedBPT;
                _token = tokens[index];
            }
        }
    }

    /**
    @notice Function gives the expected amount of pool tokens on investing
    @param _ToBalancerPoolAddress Address of balancer pool to zapin
    @param _IncomingERC The amount of ERC to invest
    @param _FromToken Address of token to zap in with
    @return Amount of BPT token
     */
    function getToken2BPT(
        address _ToBalancerPoolAddress,
        uint256 _IncomingERC,
        address _FromToken
    ) internal view returns (uint256 tokensReturned) {
        uint256 totalSupply = IBPool(_ToBalancerPoolAddress).totalSupply();
        uint256 swapFee = IBPool(_ToBalancerPoolAddress).getSwapFee();
        uint256 totalWeight = IBPool(_ToBalancerPoolAddress)
            .getTotalDenormalizedWeight();
        uint256 balance = IBPool(_ToBalancerPoolAddress).getBalance(_FromToken);
        uint256 denorm = IBPool(_ToBalancerPoolAddress).getDenormalizedWeight(
            _FromToken
        );

        tokensReturned = IBPool(_ToBalancerPoolAddress)
            .calcPoolOutGivenSingleIn(
            balance,
            denorm,
            totalSupply,
            totalWeight,
            _IncomingERC,
            swapFee
        );
    }

    /**
    @notice This function is used to buy tokens from eth
    @param _tokenContractAddress Token address which we want to buy
    @return The quantity of token bought
     */
    function _eth2Token(address _tokenContractAddress)
        internal
        returns (uint256 tokenBought)
    {
        if (_tokenContractAddress == wethTokenAddress) {
            IWETH(wethTokenAddress).deposit.value(msg.value)();
            return msg.value;
        }

        address[] memory path = new address[](2);
        path[0] = wethTokenAddress;
        path[1] = _tokenContractAddress;
        tokenBought = uniswapRouter.swapExactETHForTokens.value(msg.value)(
            1,
            path,
            address(this),
            deadline
        )[path.length - 1];
    }

    /**
    @notice This function is used to swap tokens
    @param _FromTokenContractAddress The token address to swap from
    @param _ToTokenContractAddress The token address to swap to
    @param tokens2Trade The amount of tokens to swap
    @return The quantity of tokens bought
     */
    function _token2Token(
        address _FromTokenContractAddress,
        address _ToTokenContractAddress,
        uint256 tokens2Trade
    ) public returns (uint256 tokenBought) {
        TransferHelper.safeApprove(
            _FromTokenContractAddress,
            address(uniswapRouter),
            tokens2Trade
        );

        if (_FromTokenContractAddress != wethTokenAddress) {
            if (_ToTokenContractAddress != wethTokenAddress) {
                address[] memory path = new address[](3);
                path[0] = _FromTokenContractAddress;
                path[1] = wethTokenAddress;
                path[2] = _ToTokenContractAddress;
                tokenBought = uniswapRouter.swapExactTokensForTokens(
                    tokens2Trade,
                    1,
                    path,
                    address(this),
                    deadline
                )[path.length - 1];
            } else {
                address[] memory path = new address[](2);
                path[0] = _FromTokenContractAddress;
                path[1] = wethTokenAddress;

                tokenBought = uniswapRouter.swapExactTokensForTokens(
                    tokens2Trade,
                    1,
                    path,
                    address(this),
                    deadline
                )[path.length - 1];
            }
        } else {
            address[] memory path = new address[](2);
            path[0] = wethTokenAddress;
            path[1] = _ToTokenContractAddress;
            tokenBought = uniswapRouter.swapExactTokensForTokens(
                tokens2Trade,
                1,
                path,
                address(this),
                deadline
            )[path.length - 1];
        }

        require(tokenBought > 0, "Error in swapping ERC: 1");
    }

    /**
    @notice This function is used to calculate and transfer goodwill
    @param _tokenContractAddress Token in which goodwill is deducted
    @param tokens2Trade The total amount of tokens to be zapped in
    @return The quantity of goodwill deducted
     */
    function _transferGoodwill(
        address _tokenContractAddress,
        uint256 tokens2Trade
    ) internal returns (uint256 goodwillPortion) {
        goodwillPortion = SafeMath.div(
            SafeMath.mul(tokens2Trade, goodwill),
            10000
        );

        if (goodwillPortion == 0) {
            return 0;
        }

        TransferHelper.safeTransfer(
            _tokenContractAddress,
            dzgoodwillAddress,
            goodwillPortion
        );
    }

    function set_new_goodwill(uint16 _new_goodwill) public onlyOwner {
        require(
            _new_goodwill >= 0 && _new_goodwill < 10000,
            "GoodWill Value not allowed"
        );
        goodwill = _new_goodwill;
    }

    function inCaseTokengetsStuck(IERC20 _TokenAddress) public onlyOwner {
        uint256 qty = _TokenAddress.balanceOf(address(this));
        TransferHelper.safeTransfer(address(_TokenAddress), owner(), qty);
    }

    // - to Pause the contract
    function toggleContractActive() public onlyOwner {
        stopped = !stopped;
    }

    // - to withdraw any ETH balance sitting in the contract
    function withdraw() public onlyOwner {
        uint256 contractBalance = address(this).balance;
        address payable _to = owner().toPayable();
        _to.transfer(contractBalance);
    }

    function() external payable {}
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Balancer_ZapIn_General_V4.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
// SPDX-License-Identifier: GPL-2.0

///@author Zapper
///@notice this contract adds liquidity to Balancer liquidity pools in one transaction

pragma solidity ^0.8.0;
import "../_base/ZapInBaseV3_1.sol";

interface IWETH {
    function deposit() external payable;
}

interface IBFactory {
    function isBPool(address b) external view returns (bool);
}

interface IBPool {
    function joinswapExternAmountIn(
        address tokenIn,
        uint256 tokenAmountIn,
        uint256 minPoolAmountOut
    ) external payable returns (uint256 poolAmountOut);

    function isBound(address t) external view returns (bool);
}

contract Balancer_ZapIn_General_V4 is ZapInBaseV3_1 {
    using SafeERC20 for IERC20;

    IBFactory BalancerFactory =
        IBFactory(0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd);

    address private constant wethTokenAddress =
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2_1(_goodwill, _affiliateSplit)
    {
        // 0x exchange
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;

        transferOwnership(ZapperAdmin);
    }

    event zapIn(address sender, address pool, uint256 tokensRec);

    /**
    @notice This function is used to invest in given balancer pool using ETH/ERC20 Tokens
    @param _FromTokenContractAddress The token used for investment (address(0x00) if ether)
    @param _ToBalancerPoolAddress The address of balancer pool
    @param _toTokenContractAddress The token with which we are adding liquidity
    @param _amount The amount of fromToken to invest
    @param _minPoolTokens Minimum quantity of pool tokens to receive. Reverts otherwise
    @param _swapTarget indicates the execution target for swap.
    @param swapData indicates the callData for execution
    @param affiliate Affiliate address
    @return LPTRec quantity of Balancer pool tokens acquired
    */
    function ZapIn(
        address _FromTokenContractAddress,
        address _ToBalancerPoolAddress,
        address _toTokenContractAddress,
        uint256 _amount,
        uint256 _minPoolTokens,
        address _swapTarget,
        bytes calldata swapData,
        address affiliate
    ) external payable stopInEmergency returns (uint256 LPTRec) {
        require(
            BalancerFactory.isBPool(_ToBalancerPoolAddress),
            "Invalid Balancer Pool"
        );

        // get incoming tokens
        uint256 toInvest =
            _pullTokens(_FromTokenContractAddress, _amount, affiliate, true);

        LPTRec = _performZapIn(
            _FromTokenContractAddress,
            _ToBalancerPoolAddress,
            toInvest,
            _toTokenContractAddress,
            _swapTarget,
            swapData
        );

        require(LPTRec >= _minPoolTokens, "High Slippage");

        IERC20(_ToBalancerPoolAddress).safeTransfer(msg.sender, LPTRec);

        emit zapIn(msg.sender, _ToBalancerPoolAddress, LPTRec);

        return LPTRec;
    }

    function _performZapIn(
        address _FromTokenContractAddress,
        address _ToBalancerPoolAddress,
        uint256 _amount,
        address _toTokenContractAddress,
        address _swapTarget,
        bytes memory swapData
    ) internal returns (uint256 tokensBought) {
        bool isBound =
            IBPool(_ToBalancerPoolAddress).isBound(_FromTokenContractAddress);

        uint256 balancerTokens;

        if (isBound) {
            balancerTokens = _enter2Balancer(
                _ToBalancerPoolAddress,
                _FromTokenContractAddress,
                _amount
            );
        } else {
            uint256 tokenBought =
                _fillQuote(
                    _FromTokenContractAddress,
                    _toTokenContractAddress,
                    _amount,
                    _swapTarget,
                    swapData
                );

            //get BPT
            balancerTokens = _enter2Balancer(
                _ToBalancerPoolAddress,
                _toTokenContractAddress,
                tokenBought
            );
        }

        return balancerTokens;
    }

    function _fillQuote(
        address _fromTokenAddress,
        address toToken,
        uint256 _amount,
        address _swapTarget,
        bytes memory swapData
    ) internal returns (uint256 amtBought) {
        if (_fromTokenAddress == toToken) {
            return _amount;
        }

        if (_fromTokenAddress == address(0) && toToken == wethTokenAddress) {
            IWETH(wethTokenAddress).deposit{ value: _amount }();
            return _amount;
        }

        uint256 valueToSend;
        if (_fromTokenAddress == address(0)) {
            valueToSend = _amount;
        } else {
            _approveToken(_fromTokenAddress, _swapTarget, _amount);
        }

        uint256 iniBal = _getBalance(toToken);
        require(approvedTargets[_swapTarget], "Target not Authorized");
        (bool success, ) = _swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens 1");
        uint256 finalBal = _getBalance(toToken);

        amtBought = finalBal - iniBal;
        require(amtBought > 0, "Swapped To Invalid Intermediate");
    }

    function _enter2Balancer(
        address _ToBalancerPoolAddress,
        address _FromTokenContractAddress,
        uint256 tokens2Trade
    ) internal returns (uint256 poolTokensOut) {
        require(
            IBPool(_ToBalancerPoolAddress).isBound(_FromTokenContractAddress),
            "Token not bound"
        );

        uint256 allowance =
            IERC20(_FromTokenContractAddress).allowance(
                address(this),
                _ToBalancerPoolAddress
            );

        if (allowance < tokens2Trade) {
            IERC20(_FromTokenContractAddress).safeApprove(
                _ToBalancerPoolAddress,
                tokens2Trade
            );
        }

        poolTokensOut = IBPool(_ToBalancerPoolAddress).joinswapExternAmountIn(
            _FromTokenContractAddress,
            tokens2Trade,
            1
        );

        require(poolTokensOut > 0, "Error Entering Pool");
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\CompoundInterface.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;



interface ICompoundToken {

    function underlying() external view returns (address);



    function mint(uint256 mintAmount) external returns (uint256);



    function mint() external payable;



    function redeem(uint256 redeemTokens) external returns (uint256);



    function exchangeRateStored() external view returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Compound_Zap_V1.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract deposits and withdraws assets to/from Compound
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapInBaseV3_1.sol";
import "../_base/ZapOutBaseV3_1.sol";
import "./CompoundInterface.sol";

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}

contract Compound_Zap_V1 is ZapInBaseV3_1, ZapOutBaseV3_1 {
    using SafeERC20 for IERC20;

    address private constant wethTokenAddress =
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    address private constant cETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2_1(_goodwill, _affiliateSplit)
    {
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
    }

    event zapIn(address sender, address token, uint256 tokensRec);
    event zapOut(address sender, address token, uint256 tokensRec);

    /**
    @notice This function deposits assets into Compound with ETH or ERC20 tokens
    @param fromToken The token used for entry (address(0) if ether)
    @param amountIn The amount of fromToken to invest
    @param cToken Address of the cToken
    @param minCtokens The minimum acceptable quantity cTokens to receive. Reverts otherwise
    @param swapTarget Excecution target for the swap or zap
    @param swapData DEX or Zap data. Must swap to cToken underlying address
    @param affiliate Affiliate address
    @return cTokensRec Quantity of cTokens received
     */
    function ZapIn(
        address fromToken,
        uint256 amountIn,
        address cToken,
        uint256 minCtokens,
        address swapTarget,
        bytes calldata swapData,
        address affiliate
    ) external payable stopInEmergency returns (uint256 cTokensRec) {
        uint256 toInvest = _pullTokens(fromToken, amountIn, affiliate, true);

        address toToken = getUnderlyingToken(cToken);

        uint256 tokensBought =
            _fillQuote(fromToken, toToken, toInvest, swapTarget, swapData);

        (cTokensRec) = enterCompound(cToken, toToken, tokensBought);
        require(cTokensRec > minCtokens, "High Slippage");

        IERC20(cToken).safeTransfer(msg.sender, cTokensRec);

        emit zapIn(msg.sender, cToken, cTokensRec);
    }

    function enterCompound(
        address cToken,
        address underlyingToken,
        uint256 underlyingAmount
    ) internal returns (uint256 cTokensRec) {
        uint256 initialBalance = _getBalance(cToken);

        if (underlyingToken == address(0)) {
            ICompoundToken(cToken).mint{ value: underlyingAmount }();
        } else {
            _approveToken(underlyingToken, cToken, underlyingAmount);
            ICompoundToken(cToken).mint(underlyingAmount);
        }

        cTokensRec = _getBalance(cToken) - initialBalance;
    }

    /**
    @notice This function withdraws assets from Compound, receiving tokens or ETH
    @param fromToken The cToken being withdrawn
    @param amountIn The quantity of fromToken to withdraw
    @param toToken Address of the token to receive (0 address if ETH)
    @param minToTokens The minimum acceptable quantity tokens to receive. Reverts otherwise
    @param swapTarget Excecution target for the swap or zap
    @param swapData DEX or Zap data
    @param affiliate Affiliate address
    @return tokensRec Quantity of aTokens received
     */
    function ZapOut(
        address fromToken,
        uint256 amountIn,
        address toToken,
        uint256 minToTokens,
        address swapTarget,
        bytes calldata swapData,
        address affiliate
    ) public stopInEmergency returns (uint256 tokensRec) {
        amountIn = _pullTokens(fromToken, amountIn);

        address underlyingToken = getUnderlyingToken(fromToken);

        uint256 underlyingRec =
            exitCompound(fromToken, amountIn, underlyingToken);

        tokensRec = _fillQuote(
            underlyingToken,
            toToken,
            underlyingRec,
            swapTarget,
            swapData
        );

        require(tokensRec >= minToTokens, "High Slippage");

        uint256 totalGoodwillPortion;

        if (toToken == address(0)) {
            totalGoodwillPortion = _subtractGoodwill(
                ETHAddress,
                tokensRec,
                affiliate,
                true
            );

            payable(msg.sender).transfer(tokensRec - totalGoodwillPortion);
        } else {
            totalGoodwillPortion = _subtractGoodwill(
                toToken,
                tokensRec,
                affiliate,
                true
            );

            IERC20(toToken).safeTransfer(
                msg.sender,
                tokensRec - totalGoodwillPortion
            );
        }

        tokensRec = tokensRec - totalGoodwillPortion;

        emit zapOut(msg.sender, toToken, tokensRec);
    }

    function exitCompound(
        address cToken,
        uint256 cTokenAmount,
        address underlyingToken
    ) internal returns (uint256 underlyingRec) {
        uint256 initialBalance = _getBalance(underlyingToken);

        ICompoundToken(cToken).redeem(cTokenAmount);

        underlyingRec = _getBalance(underlyingToken) - initialBalance;
    }

    function _fillQuote(
        address fromToken,
        address toToken,
        uint256 _amount,
        address swapTarget,
        bytes memory swapData
    ) internal returns (uint256 amountBought) {
        if (fromToken == toToken) {
            return _amount;
        }

        if (fromToken == address(0) && toToken == wethTokenAddress) {
            IWETH(wethTokenAddress).deposit{ value: _amount }();
            return _amount;
        }

        if (fromToken == wethTokenAddress && toToken == address(0)) {
            IWETH(wethTokenAddress).withdraw(_amount);
            return _amount;
        }

        uint256 valueToSend;
        if (fromToken == address(0)) {
            valueToSend = _amount;
        } else {
            _approveToken(fromToken, swapTarget);
        }

        uint256 initialBalance = _getBalance(toToken);

        require(approvedTargets[swapTarget], "Target not Authorized");
        (bool success, ) = swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens");

        amountBought = _getBalance(toToken) - initialBalance;

        require(amountBought > 0, "Swapped To Invalid Intermediate");
    }

    function getUnderlyingToken(address cToken) public view returns (address) {
        return
            cToken == cETH ? address(0) : ICompoundToken(cToken).underlying();
    }

    function removeLiquidityReturn(address cToken, uint256 cTokenAmt)
        external
        view
        returns (uint256 underlyingRec)
    {
        return
            (cTokenAmt * ICompoundToken(cToken).exchangeRateStored()) / 10**18;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Counters.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids.

 *

 * Include with `using Counters for Counters.Counter;`

 */

library Counters {

    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        unchecked {

            counter._value += 1;

        }

    }



    function decrement(Counter storage counter) internal {

        uint256 value = counter._value;

        require(value > 0, "Counter: decrement overflow");

        unchecked {

            counter._value = value - 1;

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\CreamInterface.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;



interface ICreamToken {

    function underlying() external view returns (address);



    function mint(uint256 mintAmount) external returns (uint256);



    function mint() external payable;



    function redeem(uint256 redeemTokens) external returns (uint256);



    function exchangeRateStored() external view returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Curve_Registry_V2.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2020 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice Registry for Curve Pools with Utility functions.

pragma solidity ^0.5.7;

import "../oz/ownership/Ownable.sol";
import "../oz/token/ERC20/SafeERC20.sol";

interface ICurveAddressProvider {
    function get_registry() external view returns (address);

    function get_address(uint256 _id) external view returns (address);
}

interface ICurveRegistry {
    function get_pool_from_lp_token(address lpToken)
        external
        view
        returns (address);

    function get_lp_token(address swapAddress) external view returns (address);

    function get_n_coins(address _pool)
        external
        view
        returns (uint256[2] memory);

    function get_coins(address _pool) external view returns (address[8] memory);

    function get_underlying_coins(address _pool)
        external
        view
        returns (address[8] memory);
}

interface ICurveFactoryRegistry {
    function get_n_coins(address _pool)
        external
        view
        returns (uint256, uint256);

    function get_coins(address _pool) external view returns (address[2] memory);

    function get_underlying_coins(address _pool)
        external
        view
        returns (address[8] memory);
}

contract Curve_Registry_V2 is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    ICurveAddressProvider private constant CurveAddressProvider =
        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);
    ICurveRegistry public CurveRegistry;

    ICurveFactoryRegistry public FactoryRegistry;

    address private constant wbtcToken =
        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address private constant sbtcCrvToken =
        0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3;
    address internal constant ETHAddress =
        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    mapping(address => bool) public shouldAddUnderlying;
    mapping(address => address) private depositAddresses;

    constructor() public {
        CurveRegistry = ICurveRegistry(CurveAddressProvider.get_registry());
        FactoryRegistry = ICurveFactoryRegistry(
            CurveAddressProvider.get_address(3)
        );
    }

    function isCurvePool(address swapAddress) public view returns (bool) {
        if (CurveRegistry.get_lp_token(swapAddress) != address(0)) {
            return true;
        }
        return false;
    }

    function isFactoryPool(address swapAddress) public view returns (bool) {
        if (FactoryRegistry.get_coins(swapAddress)[0] != address(0)) {
            return true;
        }
        return false;
    }

    /**
    @notice This function is used to get the curve pool deposit address
    @notice The deposit address is used for pools with wrapped (c, y) tokens
    @param swapAddress Curve swap address for the pool
    @return curve pool deposit address or the swap address not mapped
    */
    function getDepositAddress(address swapAddress)
        external
        view
        returns (address depositAddress)
    {
        depositAddress = depositAddresses[swapAddress];
        if (depositAddress == address(0)) return swapAddress;
    }

    /**
    @notice This function is used to get the curve pool swap address
    @notice The token and swap address is the same for metapool factory pools
    @param swapAddress Curve swap address for the pool
    @return curve pool swap address or address(0) if pool doesnt exist
    */
    function getSwapAddress(address tokenAddress)
        external
        view
        returns (address swapAddress)
    {
        swapAddress = CurveRegistry.get_pool_from_lp_token(tokenAddress);
        if (swapAddress != address(0)) {
            return swapAddress;
        }
        if (isFactoryPool(swapAddress)) {
            return tokenAddress;
        }
        return address(0);
    }

    /**
    @notice This function is used to check the curve pool token address
    @notice The token and swap address is the same for metapool factory pools
    @param swapAddress Curve swap address for the pool
    @return curve pool token address or address(0) if pool doesnt exist
    */
    function getTokenAddress(address swapAddress)
        external
        view
        returns (address tokenAddress)
    {
        tokenAddress = CurveRegistry.get_lp_token(swapAddress);
        if (tokenAddress != address(0)) {
            return tokenAddress;
        }
        if (isFactoryPool(swapAddress)) {
            return swapAddress;
        }
        return address(0);
    }

    /**
    @notice Checks the number of non-underlying tokens in a pool
    @param swapAddress Curve swap address for the pool
    @return number of underlying tokens in the pool
    */
    function getNumTokens(address swapAddress) public view returns (uint256) {
        if (isCurvePool(swapAddress)) {
            return CurveRegistry.get_n_coins(swapAddress)[0];
        } else {
            (uint256 numTokens, ) = FactoryRegistry.get_n_coins(swapAddress);
            return numTokens;
        }
    }

    /**
    @notice This function is used to check if the curve pool is a metapool
    @notice all factory pools are metapools
    @param swapAddress Curve swap address for the pool
    @return true if the pool is a metapool, false otherwise
    */
    function isMetaPool(address swapAddress) public view returns (bool) {
        if (isCurvePool(swapAddress)) {
            uint256[2] memory poolTokenCounts =
                CurveRegistry.get_n_coins(swapAddress);
            if (poolTokenCounts[0] == poolTokenCounts[1]) return false;
            else return true;
        }
        if (isFactoryPool(swapAddress)) return true;
    }

    /**
    @notice This function returns an array of underlying pool token addresses
    @param swapAddress Curve swap address for the pool
    @return returns 4 element array containing the addresses of the pool tokens (0 address if pool contains < 4 tokens)
    */
    function getPoolTokens(address swapAddress)
        public
        view
        returns (address[4] memory poolTokens)
    {
        if (isMetaPool(swapAddress)) {
            if (isFactoryPool(swapAddress)) {
                address[2] memory poolUnderlyingCoins =
                    FactoryRegistry.get_coins(swapAddress);
                for (uint256 i = 0; i < 2; i++) {
                    poolTokens[i] = poolUnderlyingCoins[i];
                }
            } else {
                address[8] memory poolUnderlyingCoins =
                    CurveRegistry.get_coins(swapAddress);
                for (uint256 i = 0; i < 2; i++) {
                    poolTokens[i] = poolUnderlyingCoins[i];
                }
            }

            return poolTokens;
        } else {
            address[8] memory poolUnderlyingCoins;
            if (isBtcPool(swapAddress) && !isMetaPool(swapAddress)) {
                poolUnderlyingCoins = CurveRegistry.get_coins(swapAddress);
            } else {
                poolUnderlyingCoins = CurveRegistry.get_underlying_coins(
                    swapAddress
                );
            }
            for (uint256 i = 0; i < 4; i++) {
                poolTokens[i] = poolUnderlyingCoins[i];
            }
        }
    }

    /**
    @notice This function checks if the curve pool contains WBTC
    @param swapAddress Curve swap address for the pool
    @return true if the pool contains WBTC, false otherwise
    */
    function isBtcPool(address swapAddress) public view returns (bool) {
        address[8] memory poolTokens = CurveRegistry.get_coins(swapAddress);
        for (uint256 i = 0; i < 4; i++) {
            if (poolTokens[i] == wbtcToken || poolTokens[i] == sbtcCrvToken)
                return true;
        }
        return false;
    }

    /**
    @notice This function checks if the curve pool contains ETH
    @param swapAddress Curve swap address for the pool
    @return true if the pool contains ETH, false otherwise
    */
    function isEthPool(address swapAddress) external view returns (bool) {
        address[8] memory poolTokens = CurveRegistry.get_coins(swapAddress);
        for (uint256 i = 0; i < 4; i++) {
            if (poolTokens[i] == ETHAddress) {
                return true;
            }
        }
        return false;
    }

    /**
    @notice This function is used to check if the pool contains the token
    @param swapAddress Curve swap address for the pool
    @param tokenContractAddress contract address of the token
    @return true if the pool contains the token, false otherwise
    @return index of the token in the pool, 0 if pool does not contain the token
    */
    function isUnderlyingToken(
        address swapAddress,
        address tokenContractAddress
    ) external view returns (bool, uint256) {
        address[4] memory poolTokens = getPoolTokens(swapAddress);
        for (uint256 i = 0; i < 4; i++) {
            if (poolTokens[i] == address(0)) return (false, 0);
            if (poolTokens[i] == tokenContractAddress) return (true, i);
        }
    }

    /**
    @notice Updates to the latest curve registry from the address provider
    */
    function update_curve_registry() external onlyOwner {
        address new_address = CurveAddressProvider.get_registry();

        require(address(CurveRegistry) != new_address, "Already updated");

        CurveRegistry = ICurveRegistry(new_address);
    }

    /**
    @notice Updates to the latest curve registry from the address provider
    */
    function update_factory_registry() external onlyOwner {
        address new_address = CurveAddressProvider.get_address(3);

        require(address(FactoryRegistry) != new_address, "Already updated");

        FactoryRegistry = ICurveFactoryRegistry(new_address);
    }

    /**
    @notice Add new pools which use the _use_underlying bool
    @param swapAddresses Curve swap addresses for the pool
    @param addUnderlying True if underlying tokens are always added
    */
    function updateShouldAddUnderlying(
        address[] calldata swapAddresses,
        bool[] calldata addUnderlying
    ) external onlyOwner {
        require(
            swapAddresses.length == addUnderlying.length,
            "Mismatched arrays"
        );
        for (uint256 i = 0; i < swapAddresses.length; i++) {
            shouldAddUnderlying[swapAddresses[i]] = addUnderlying[i];
        }
    }

    /**
    @notice Add new pools which use uamounts for add_liquidity
    @param swapAddresses Curve swap addresses to map from
    @param _depositAddresses Curve deposit addresses to map to
    */
    function updateDepositAddresses(
        address[] calldata swapAddresses,
        address[] calldata _depositAddresses
    ) external onlyOwner {
        require(
            swapAddresses.length == _depositAddresses.length,
            "Mismatched arrays"
        );
        for (uint256 i = 0; i < swapAddresses.length; i++) {
            depositAddresses[swapAddresses[i]] = _depositAddresses[i];
        }
    }

    /**
    //@notice Add new pools which use the _use_underlying bool
    */
    function withdrawTokens(address[] calldata tokens) external onlyOwner {
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 qty;

            if (tokens[i] == ETHAddress) {
                qty = address(this).balance;
                Address.sendValue(Address.toPayable(owner()), qty);
            } else {
                qty = IERC20(tokens[i]).balanceOf(address(this));
                IERC20(tokens[i]).safeTransfer(owner(), qty);
            }
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Curve_to_Curve_Pipe.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-05-24

*/



// File: @openzeppelin/contracts/math/SafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: @openzeppelin/contracts/GSN/Context.sol



pragma solidity ^0.5.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: @openzeppelin/contracts/ownership/Ownable.sol



pragma solidity ^0.5.0;



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: @openzeppelin/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: @openzeppelin/contracts/utils/Address.sol



pragma solidity ^0.5.5;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following 

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Converts an `address` into `address payable`. Note that this is

     * simply a type cast: the actual underlying value is not changed.

     *

     * _Available since v2.4.0._

     */

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     *

     * _Available since v2.4.0._

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-call-value

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol



pragma solidity ^0.5.0;



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * TIP: If you would like to learn more about reentrancy and alternative ways

 * to protect against it, check out our blog post

 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].

 *

 * _Since v2.5.0:_ this module is now much more gas efficient, given net gas

 * metering changes introduced in the Istanbul hardfork.

 */

contract ReentrancyGuard {

    bool private _notEntered;



    constructor () internal {

        // Storing an initial non-zero value makes deployment a bit more

        // expensive, but in exchange the refund on every call to nonReentrant

        // will be lower in amount. Since refunds are capped to a percetange of

        // the total transaction's gas, it is best to keep them low in cases

        // like this one, to increase the likelihood of the full refund coming

        // into effect.

        _notEntered = true;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_notEntered, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _notEntered = false;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _notEntered = true;

    }

}



// File: contracts/Curve-pool/Curve_to_Curve_Pipe.sol



pragma solidity ^0.5.0;





// Copyright (C) 2019, 2020 dipeshsukhani, nodarjanashia, suhailg, apoorvlathey, seb, sumit



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU Affero General Public License as published by

// the Free Software Foundation, either version 2 of the License, or

// (at your option) any later version.

//

// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU Affero General Public License for more details.

//

// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License















interface ICurveGenZapOut {

    function ZapOut(

        address payable _toWhomToIssue,

        address _curveExchangeAddress,

        uint256 _IncomingCRV,

        address _ToTokenAddress

    ) external returns (uint256 ToTokensBought);

}





interface ICurveGenZapIn {

    function ZapIn(

        address _toWhomToIssue,

        address _IncomingTokenAddress,

        address _curvePoolExchangeAddress,

        uint256 _IncomingTokenQty

    ) external payable returns (uint256 crvTokensBought);

}





contract Curve_to_Curve_Pipe is ReentrancyGuard, Ownable {

    using SafeMath for uint256;

    using Address for address;

    bool private stopped = false;



    ICurveGenZapIn public curveGenZapIn;

    ICurveGenZapOut public curveGenZapOut;



    address public DaiTokenAddress = address(

        0x6B175474E89094C44Da98b954EedeAC495271d0F

    );

    address public sUSDCurveExchangeAddress = address(

        0xA5407eAE9Ba41422680e2e00537571bcC53efBfD

    );

    address public sUSDCurvePoolTokenAddress = address(

        0xC25a3A3b969415c80451098fa907EC722572917F

    );

    address public yCurveExchangeAddress = address(

        0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3

    );

    address public yCurvePoolTokenAddress = address(

        0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8

    );

    address public bUSDCurveExchangeAddress = address(

        0xb6c057591E073249F2D9D88Ba59a46CFC9B59EdB

    );

    address public bUSDCurvePoolTokenAddress = address(

        0x3B3Ac5386837Dc563660FB6a0937DFAa5924333B

    );

    address public paxCurveExchangeAddress = address(

        0xA50cCc70b6a011CffDdf45057E39679379187287

    );

    address public paxCurvePoolTokenAddress = address(

        0xD905e2eaeBe188fc92179b6350807D8bd91Db0D8

    );



    mapping(address => address) internal exchange2Token;



    constructor(address _genCurveZapInAddress, address _curveZapOutAddress)

        public

    {

        curveGenZapIn = ICurveGenZapIn(_genCurveZapInAddress);

        curveGenZapOut = ICurveGenZapOut(_curveZapOutAddress);



        exchange2Token[sUSDCurveExchangeAddress] = sUSDCurvePoolTokenAddress;

        exchange2Token[yCurveExchangeAddress] = yCurvePoolTokenAddress;

        exchange2Token[bUSDCurveExchangeAddress] = bUSDCurvePoolTokenAddress;

        exchange2Token[paxCurveExchangeAddress] = paxCurvePoolTokenAddress;



        approveToken();

    }



    function approveToken() public {

        IERC20(sUSDCurvePoolTokenAddress).approve(

            address(curveGenZapOut),

            uint256(-1)

        );

        IERC20(yCurvePoolTokenAddress).approve(

            address(curveGenZapOut),

            uint256(-1)

        );

        IERC20(bUSDCurvePoolTokenAddress).approve(

            address(curveGenZapOut),

            uint256(-1)

        );

        IERC20(paxCurvePoolTokenAddress).approve(

            address(curveGenZapOut),

            uint256(-1)

        );



        IERC20(DaiTokenAddress).approve(address(curveGenZapIn), uint256(-1));

    }



    // circuit breaker modifiers

    modifier stopInEmergency {

        if (stopped) {

            revert("Temporarily Paused");

        } else {

            _;

        }

    }



    function Curve2Curve(

        address payable _toWhomToIssue,

        address _incomingCurveExchange,

        uint256 _IncomingCRV,

        address _toCurveExchange

    ) public nonReentrant stopInEmergency {

        require(

            IERC20(exchange2Token[_incomingCurveExchange]).transferFrom(

                _toWhomToIssue,

                address(this),

                _IncomingCRV

            ),

            "Error transferring CRV"

        );



        curveGenZapOut.ZapOut(

            address(this).toPayable(),

            _incomingCurveExchange,

            _IncomingCRV,

            DaiTokenAddress

        );



        uint256 daiBought = IERC20(DaiTokenAddress).balanceOf(address(this));



        curveGenZapIn.ZapIn(

            _toWhomToIssue,

            DaiTokenAddress,

            _toCurveExchange,

            daiBought

        );

    }



    function inCaseTokengetsStuck(IERC20 _TokenAddress) public onlyOwner {

        uint256 qty = _TokenAddress.balanceOf(address(this));

        _TokenAddress.transfer(owner(), qty);

    }



    // - to Pause the contract

    function toggleContractActive() public onlyOwner {

        stopped = !stopped;

    }



    // - to withdraw any ETH balance sitting in the contract

    function withdraw() public onlyOwner {

        uint256 contractBalance = address(this).balance;

        address payable _to = owner().toPayable();

        _to.transfer(contractBalance);

    }



    // - to kill the contract

    function destruct() public onlyOwner {

        address payable _to = owner().toPayable();

        selfdestruct(_to);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Curve_ZapIn_General_V1_4.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-07-15

*/



// File: Context.sol



pragma solidity ^0.5.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

// File: OpenZepplinOwnable.sol



pragma solidity ^0.5.0;



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address payable public _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address payable msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address payable newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address payable newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

// File: OpenZepplinSafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

// File: OpenZepplinIERC20.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

// File: OpenZepplinReentrancyGuard.sol



pragma solidity ^0.5.0;



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * _Since v2.5.0:_ this module is now much more gas efficient, given net gas

 * metering changes introduced in the Istanbul hardfork.

 */

contract ReentrancyGuard {

    bool private _notEntered;



    constructor () internal {

        // Storing an initial non-zero value makes deployment a bit more

        // expensive, but in exchange the refund on every call to nonReentrant

        // will be lower in amount. Since refunds are capped to a percetange of

        // the total transaction's gas, it is best to keep them low in cases

        // like this one, to increase the likelihood of the full refund coming

        // into effect.

        _notEntered = true;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_notEntered, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _notEntered = false;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _notEntered = true;

    }

}



// File: browser/Curve_ZapIn_General_V1_4.sol



// Copyright (C) 2020 zapper, nodarjanashia, suhailg, sebaudet, sumitrajput, apoorvlathey



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU Affero General Public License as published by

// the Free Software Foundation, either version 2 of the License, or

// (at your option) any later version.

//

// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU Affero General Public License for more details.

//



///@author Zapper

///@notice This contract adds liquidity to Curve stablecoin and BTC liquidity pools in one transaction with ETH or ERC tokens.



pragma solidity ^0.5.0;



interface IuniswapFactory {

    function getExchange(address token)

        external

        view

        returns (address exchange);

}





interface IuniswapExchange {

    // for removing liquidity (returns ETH removed, ERC20 Removed)

    function removeLiquidity(

        uint256 amount,

        uint256 min_eth,

        uint256 min_tokens,

        uint256 deadline

    ) external returns (uint256, uint256);



    // converting ERC20 to ERC20 and transfer

    function tokenToTokenSwapInput(

        uint256 tokens_sold,

        uint256 min_tokens_bought,

        uint256 min_eth_bought,

        uint256 deadline,

        address token_addr

    ) external returns (uint256 tokens_bought);



    // add liquidity to a pool (returns LP tokens rec)

    function addLiquidity(

        uint256 min_liquidity,

        uint256 max_tokens,

        uint256 deadline

    ) external payable returns (uint256);



    function getEthToTokenInputPrice(uint256 eth_sold)

        external

        view

        returns (uint256 tokens_bought);



    function getTokenToEthInputPrice(uint256 tokens_sold)

        external

        view

        returns (uint256 eth_bought);

        

    function tokenToEthSwapInput(

        uint256 tokens_sold,

        uint256 min_eth,

        uint256 deadline

    ) external returns (uint256 eth_bought);



    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)

        external

        payable

        returns (uint256 tokens_bought);



    function balanceOf(address _owner) external view returns (uint256);



    function transfer(address _to, uint256 _value) external returns (bool);



    function transferFrom(address from, address to, uint256 tokens)

        external

        returns (bool success);

}





interface ICurveExchange {

    function add_liquidity(uint256[4] calldata amounts, uint256 min_mint_amount)

        external;

}



interface IrenBtcCurveExchange {

    function add_liquidity(

        uint256[2] calldata amounts,

        uint min_mint_amount

    ) external;

}



interface IsBtcCurveExchange {

    function add_liquidity(

        uint256[3] calldata amounts,

        uint min_mint_amount

    ) external;

}





interface yERC20 {

    function deposit(uint256 _amount) external;

}



interface IBalancer {

    function swapExactAmountIn(

        address tokenIn,

        uint tokenAmountIn,

        address tokenOut,

        uint minAmountOut,

        uint maxPrice

    ) external returns (uint tokenAmountOut, uint spotPriceAfter);

}



interface IWETH {

    function deposit() external payable;



    function transfer(address to, uint256 value) external returns (bool);



    function withdraw(uint256) external;

}



contract Curve_ZapIn_General_V1_4 is ReentrancyGuard, Ownable {

    using SafeMath for uint256;

    bool private stopped = false;

    uint16 public goodwill;

    address public dzgoodwillAddress;

    



    IuniswapFactory private UniSwapFactoryAddress = IuniswapFactory(

        0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95

    );

    address private DaiTokenAddress = address(

        0x6B175474E89094C44Da98b954EedeAC495271d0F

    );

    address private UsdcTokenAddress = address(

        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48

    );

    address private sUSDCurveExchangeAddress = address(

        0xA5407eAE9Ba41422680e2e00537571bcC53efBfD

    );

    address private sUSDCurvePoolTokenAddress = address(

        0xC25a3A3b969415c80451098fa907EC722572917F

    );

    address private yCurveExchangeAddress = address(

        0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3

    );

    address private yCurvePoolTokenAddress = address(

        0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8

    );

    address private bUSDCurveExchangeAddress = address(

        0xb6c057591E073249F2D9D88Ba59a46CFC9B59EdB

    );

    address private bUSDCurvePoolTokenAddress = address(

        0x3B3Ac5386837Dc563660FB6a0937DFAa5924333B

    );

    address private paxCurveExchangeAddress = address(

        0xA50cCc70b6a011CffDdf45057E39679379187287

    );

    address private paxCurvePoolTokenAddress = address(

        0xD905e2eaeBe188fc92179b6350807D8bd91Db0D8

    );

    address private renBtcCurveExchangeAddress = address(

        0x93054188d876f558f4a66B2EF1d97d16eDf0895B

    );

    address private renBtcCurvePoolTokenAddress = address(

        0x49849C98ae39Fff122806C06791Fa73784FB3675

    );

    address private sBtcCurveExchangeAddress = address(

        0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714

    );

    address private sBtcCurvePoolTokenAddress = address(

        0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3

    );

    

    IBalancer BalWBTCPool = IBalancer(0x294de1cdE8b04bf6d25F98f1d547052F8080A177);

    

    address private wethTokenAddress = address(

        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

    );

    

    address private wbtcTokenAddress = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);

    address private renBtcTokenAddress = address(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);

    address private sBtcTokenAddress = address(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);





    mapping(address => address) internal exchange2Token;



    constructor(uint16 _goodwill, address _dzgoodwillAddress) public {

        goodwill = _goodwill;

        dzgoodwillAddress = _dzgoodwillAddress;

        exchange2Token[sUSDCurveExchangeAddress] = sUSDCurvePoolTokenAddress;

        exchange2Token[yCurveExchangeAddress] = yCurvePoolTokenAddress;

        exchange2Token[bUSDCurveExchangeAddress] = bUSDCurvePoolTokenAddress;

        exchange2Token[paxCurveExchangeAddress] = paxCurvePoolTokenAddress;

        exchange2Token[renBtcCurveExchangeAddress] = renBtcCurvePoolTokenAddress;     

        exchange2Token[sBtcCurveExchangeAddress] = sBtcCurvePoolTokenAddress;

        

        approveToken();

    }



    // circuit breaker modifiers

    modifier stopInEmergency {

        if (stopped) {

            revert("Temporarily Paused");

        } else {

            _;

        }

    }



    function approveToken() public {

        IERC20(DaiTokenAddress).approve(sUSDCurveExchangeAddress, uint256(-1));

        IERC20(DaiTokenAddress).approve(yCurveExchangeAddress, uint256(-1));

        IERC20(DaiTokenAddress).approve(bUSDCurveExchangeAddress, uint256(-1));

        IERC20(DaiTokenAddress).approve(paxCurveExchangeAddress, uint256(-1));



        IERC20(UsdcTokenAddress).approve(sUSDCurveExchangeAddress, uint256(-1));

        IERC20(UsdcTokenAddress).approve(yCurveExchangeAddress, uint256(-1));

        IERC20(UsdcTokenAddress).approve(bUSDCurveExchangeAddress, uint256(-1));

        IERC20(UsdcTokenAddress).approve(paxCurveExchangeAddress, uint256(-1));

    }





    function ZapIn(

        address _toWhomToIssue,

        address _IncomingTokenAddress,

        address _curvePoolExchangeAddress,

        uint256 _IncomingTokenQty,

        uint256 _minPoolTokens

    ) public payable stopInEmergency returns (uint256 crvTokensBought) {

        require(

            _curvePoolExchangeAddress == sUSDCurveExchangeAddress ||

                _curvePoolExchangeAddress == yCurveExchangeAddress ||

                _curvePoolExchangeAddress == bUSDCurveExchangeAddress ||

                _curvePoolExchangeAddress == paxCurveExchangeAddress ||

                _curvePoolExchangeAddress == renBtcCurveExchangeAddress ||

                _curvePoolExchangeAddress == sBtcCurveExchangeAddress,

            "Invalid Curve Pool Address"

        );



        if (_IncomingTokenAddress == address(0)) {

            crvTokensBought = ZapInWithETH(

                _toWhomToIssue,

                _curvePoolExchangeAddress,

                _minPoolTokens

            );

        } else {

            crvTokensBought = ZapInWithERC20(

                _toWhomToIssue,

                _IncomingTokenAddress,

                _curvePoolExchangeAddress,

                _IncomingTokenQty,

                _minPoolTokens

            );

        }

    }



    function ZapInWithETH(

        address _toWhomToIssue,

        address _curvePoolExchangeAddress,

        uint256 _minPoolTokens

    ) internal stopInEmergency returns (uint256 crvTokensBought) {

        require(msg.value > 0, "Err: No ETH sent");

        

        if(_curvePoolExchangeAddress != sBtcCurveExchangeAddress && _curvePoolExchangeAddress != renBtcCurveExchangeAddress) {

            uint256 daiBought = _eth2Token(DaiTokenAddress, (msg.value).div(2));

            uint256 usdcBought = _eth2Token(UsdcTokenAddress, (msg.value).div(2));

            crvTokensBought = _enter2Curve(

                _toWhomToIssue,

                daiBought,

                usdcBought,

                _curvePoolExchangeAddress,

                _minPoolTokens

            );

        } else {

            uint256 wbtcBought = _eth2WBTC(msg.value);

            crvTokensBought = _enter2BtcCurve(

                _toWhomToIssue,

                wbtcTokenAddress,

                _curvePoolExchangeAddress,

                wbtcBought,

                _minPoolTokens

            );

        }

    }





    function ZapInWithERC20(

        address _toWhomToIssue,

        address _IncomingTokenAddress,

        address _curvePoolExchangeAddress,

        uint256 _IncomingTokenQty,

        uint256 _minPoolTokens

    ) internal stopInEmergency returns (uint256 crvTokensBought) {

        require(_IncomingTokenQty > 0, "Err: No ERC20 sent");



        require(

            IERC20(_IncomingTokenAddress).transferFrom(

                msg.sender,

                address(this),

                _IncomingTokenQty

            ),

            "Error in transferring ERC20"

        );

        

        if(_curvePoolExchangeAddress == sBtcCurveExchangeAddress || _curvePoolExchangeAddress == renBtcCurveExchangeAddress) {

            if(_IncomingTokenAddress == wbtcTokenAddress || _IncomingTokenAddress == renBtcTokenAddress || _IncomingTokenAddress == sBtcTokenAddress) {

                crvTokensBought = _enter2BtcCurve(

                    _toWhomToIssue,

                    _IncomingTokenAddress,

                    _curvePoolExchangeAddress,

                    _IncomingTokenQty,

                    _minPoolTokens

                );

            } else {

                IERC20(_IncomingTokenAddress).approve(

                    UniSwapFactoryAddress.getExchange(_IncomingTokenAddress),

                    _IncomingTokenQty

                );

                uint256 ethBought = IuniswapExchange(UniSwapFactoryAddress.getExchange(_IncomingTokenAddress))

                                        .tokenToEthSwapInput(

                                          _IncomingTokenQty,

                                          1,

                                          SafeMath.add(now, 1800)

                                        );

                                        

                uint256 wbtcBought = _eth2WBTC(ethBought);

                

                crvTokensBought = _enter2BtcCurve(

                    _toWhomToIssue,

                    wbtcTokenAddress,

                    _curvePoolExchangeAddress,

                    wbtcBought,

                    _minPoolTokens

                );



            }

            

        } else {

            uint256 daiBought;

            uint256 usdcBought;

    

            if (_IncomingTokenAddress == DaiTokenAddress) {

                daiBought = _IncomingTokenQty;

                usdcBought = 0;

            } else if (_IncomingTokenAddress == UsdcTokenAddress) {

                daiBought = 0;

                usdcBought = _IncomingTokenQty;

            } else {

                daiBought = _token2Token(

                    _IncomingTokenAddress,

                    DaiTokenAddress,

                    (_IncomingTokenQty).div(2)

                );

                usdcBought = _token2Token(

                    _IncomingTokenAddress,

                    UsdcTokenAddress,

                    (_IncomingTokenQty).div(2)

                );

            }

    

            crvTokensBought = _enter2Curve(

                _toWhomToIssue,

                daiBought,

                usdcBought,

                _curvePoolExchangeAddress,

                _minPoolTokens

            );

        }

        

    }

    

    function _enter2BtcCurve(

        address _toWhomToIssue,

        address _incomingBtcTokenAddress,

        address _curvePoolExchangeAddress,

        uint256 _incomingBtcTokenAmt,

        uint256 _minPoolTokens

    ) internal returns (uint256 crvTokensBought) {

        require(_incomingBtcTokenAddress == sBtcTokenAddress || 

                _incomingBtcTokenAddress == wbtcTokenAddress ||

                _incomingBtcTokenAddress == renBtcTokenAddress,

                "ERR: Incorrect BTC Token Address"

        );

        IERC20(_incomingBtcTokenAddress).approve(_curvePoolExchangeAddress, _incomingBtcTokenAmt);

        address btcCurvePoolTokenAddress = exchange2Token[_curvePoolExchangeAddress];

        uint256 iniTokenBal = IERC20(btcCurvePoolTokenAddress).balanceOf(address(this));

        // 0 = renBTC, 1 = wBTC, 2 = sBTC

        if(_incomingBtcTokenAddress == wbtcTokenAddress) {

            if(_curvePoolExchangeAddress == renBtcCurveExchangeAddress){

                IrenBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                    [0, _incomingBtcTokenAmt],

                    _minPoolTokens

                );

            }else {

                IsBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                    [0, _incomingBtcTokenAmt, 0],

                    _minPoolTokens

                );                

            }

        } else if(_incomingBtcTokenAddress == renBtcTokenAddress) {

            if(_curvePoolExchangeAddress == renBtcCurveExchangeAddress){

                IrenBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                    [_incomingBtcTokenAmt,0],

                    _minPoolTokens

                );

            }else {

                IsBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                    [_incomingBtcTokenAmt,0, 0],

                    _minPoolTokens

                );                

            }

        } 

        else {

            IsBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                [0, 0, _incomingBtcTokenAmt],

                0

            );

        }

        crvTokensBought = (IERC20(btcCurvePoolTokenAddress).balanceOf(address(this))).sub(iniTokenBal);

        require(crvTokensBought > _minPoolTokens, "Error less than min pool tokens");

        IERC20(btcCurvePoolTokenAddress).transfer(

            _toWhomToIssue,

            crvTokensBought

        );

    }



    function _enter2Curve(

        address _toWhomToIssue,

        uint256 daiBought,

        uint256 usdcBought,

        address _curvePoolExchangeAddress,

        uint256 _minPoolTokens

    ) internal returns (uint256 crvTokensBought) {

        // 0 = DAI, 1 = USDC, 2 = USDT, 3 = TUSD/sUSD

        address poolTokenAddress = exchange2Token[_curvePoolExchangeAddress];

        uint256 iniTokenBal = IERC20(poolTokenAddress).balanceOf(address(this));

        ICurveExchange(_curvePoolExchangeAddress).add_liquidity(

            [daiBought, usdcBought, 0, 0],

            _minPoolTokens

        );

        crvTokensBought = (IERC20(poolTokenAddress).balanceOf(address(this))).sub(iniTokenBal);

        require(crvTokensBought > _minPoolTokens, "Error less than min pool tokens");



        uint256 goodwillPortion = SafeMath.div(

            SafeMath.mul(crvTokensBought, goodwill),

            10000

        );



        require(

            IERC20(poolTokenAddress).transfer(

                dzgoodwillAddress,

                goodwillPortion

            ),

            "Error transferring goodwill"

        );



        require(

            IERC20(poolTokenAddress).transfer(

                _toWhomToIssue,

                SafeMath.sub(crvTokensBought, goodwillPortion)

            ),

            "Error transferring CRV"

        );

    }

    

    function _eth2WBTC(uint256 ethReceived)

        internal

        returns(uint256 tokensBought)

    {

        IWETH(wethTokenAddress).deposit.value(ethReceived)();

        

        IERC20(wethTokenAddress).approve(

            address(BalWBTCPool),

            ethReceived

        );

        

        (tokensBought, ) = BalWBTCPool.swapExactAmountIn(

                            wethTokenAddress,

                            ethReceived,

                            wbtcTokenAddress,

                            0,

                            uint(-1)

                        );

    }



    function _eth2Token(address _ToTokenContractAddress, uint256 ethReceived)

        internal

        returns (uint256 tokensBought)

    {

        IuniswapExchange ToUniSwapExchangeContractAddress = IuniswapExchange(

            UniSwapFactoryAddress.getExchange(_ToTokenContractAddress)

        );

        

        uint ERC20_againstETH = ToUniSwapExchangeContractAddress.getEthToTokenInputPrice(ethReceived);

        

        tokensBought = ToUniSwapExchangeContractAddress

            .ethToTokenSwapInput

            .value(ethReceived)(

                SafeMath.div(SafeMath.mul(ERC20_againstETH, 98), 100), 

                SafeMath.add(now, 300)

            );

    }



    function _token2Token(

        address _FromTokenContractAddress,

        address _ToTokenContractAddress,

        uint256 tokens2Trade

    ) internal returns (uint256 tokensBought) {

        IuniswapExchange FromUniSwapExchangeContractAddress = IuniswapExchange(

            UniSwapFactoryAddress.getExchange(_FromTokenContractAddress)

        );



        IERC20(_FromTokenContractAddress).approve(

            address(FromUniSwapExchangeContractAddress),

            tokens2Trade

        );



        tokensBought = FromUniSwapExchangeContractAddress.tokenToTokenSwapInput(

            tokens2Trade,

            1,

            1,

            SafeMath.add(now, 300),

            _ToTokenContractAddress

        );



    }



    function inCaseTokengetsStuck(IERC20 _TokenAddress) public onlyOwner {

        uint256 qty = _TokenAddress.balanceOf(address(this));

        _TokenAddress.transfer(_owner, qty);

    }



    function set_new_goodwill(uint16 _new_goodwill) public onlyOwner {

        require(

            _new_goodwill >= 0 && _new_goodwill < 10000,

            "GoodWill Value not allowed"

        );

        goodwill = _new_goodwill;

    }



    function set_new_dzgoodwillAddress(address _new_dzgoodwillAddress)

        public

        onlyOwner

    {

        dzgoodwillAddress = _new_dzgoodwillAddress;

    }



    // - to Pause the contract

    function toggleContractActive() public onlyOwner {

        stopped = !stopped;

    }



    // - to withdraw any ETH balance sitting in the contract

    function withdraw() public onlyOwner {

        _owner.transfer(address(this).balance);

    }



    function() external payable {}



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Curve_ZapIn_General_V4.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract adds liquidity to Curve pools with ETH or ERC tokens.
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapInBaseV3.sol";

interface IWETH {
    function deposit() external payable;
}

interface ICurveSwap {
    function coins(int128 arg0) external view returns (address);

    function underlying_coins(int128 arg0) external view returns (address);

    function add_liquidity(uint256[4] calldata amounts, uint256 min_mint_amount)
        external;

    function add_liquidity(
        uint256[4] calldata amounts,
        uint256 min_mint_amount,
        bool addUnderlying
    ) external;

    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount)
        external;

    function add_liquidity(
        uint256[3] calldata amounts,
        uint256 min_mint_amount,
        bool addUnderlying
    ) external;

    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)
        external;

    function add_liquidity(
        uint256[2] calldata amounts,
        uint256 min_mint_amount,
        bool addUnderlying
    ) external;
}

interface ICurveEthSwap {
    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)
        external
        payable
        returns (uint256);
}

interface ICurveRegistry {
    function getSwapAddress(address tokenAddress)
        external
        view
        returns (address swapAddress);

    function getTokenAddress(address swapAddress)
        external
        view
        returns (address tokenAddress);

    function getDepositAddress(address swapAddress)
        external
        view
        returns (address depositAddress);

    function getPoolTokens(address swapAddress)
        external
        view
        returns (address[4] memory poolTokens);

    function shouldAddUnderlying(address swapAddress)
        external
        view
        returns (bool);

    function getNumTokens(address swapAddress)
        external
        view
        returns (uint8 numTokens);

    function isBtcPool(address swapAddress) external view returns (bool);

    function isEthPool(address swapAddress) external view returns (bool);

    function isUnderlyingToken(
        address swapAddress,
        address tokenContractAddress
    ) external view returns (bool, uint8);
}

contract Curve_ZapIn_General_V4 is ZapInBaseV3 {
    using SafeERC20 for IERC20;

    ICurveRegistry public curveReg;

    address private constant wethTokenAddress =
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    constructor(
        ICurveRegistry _curveRegistry,
        uint256 _goodwill,
        uint256 _affiliateSplit
    ) ZapBaseV2(_goodwill, _affiliateSplit) {
        curveReg = _curveRegistry;

        // 0x exchange
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
    }

    event zapIn(address sender, address pool, uint256 tokensRec);

    /**
        @notice This function adds liquidity to a Curve pool with ETH or ERC20 tokens
        @param fromTokenAddress The token used for entry (address(0) if ether)
        @param toTokenAddress The intermediate ERC20 token to swap to
        @param swapAddress Curve swap address for the pool
        @param incomingTokenQty The amount of fromTokenAddress to invest
        @param minPoolTokens The minimum acceptable quantity of Curve LP to receive. Reverts otherwise
        @param swapTarget Excecution target for the first swap
        @param swapData DEX quote data
        @param affiliate Affiliate address
        @param shouldSellEntireBalance If True transfers entrire allowable amount from another contract
        @return crvTokensBought Quantity of Curve LP tokens received
    */
    function ZapIn(
        address fromTokenAddress,
        address toTokenAddress,
        address swapAddress,
        uint256 incomingTokenQty,
        uint256 minPoolTokens,
        address swapTarget,
        bytes calldata swapData,
        address affiliate,
        bool shouldSellEntireBalance
    ) external payable stopInEmergency returns (uint256 crvTokensBought) {
        uint256 toInvest =
            _pullTokens(
                fromTokenAddress,
                incomingTokenQty,
                affiliate,
                true,
                shouldSellEntireBalance
            );
        if (fromTokenAddress == address(0)) {
            fromTokenAddress = ETHAddress;
        }

        // perform zapIn
        crvTokensBought = _performZapIn(
            fromTokenAddress,
            toTokenAddress,
            swapAddress,
            toInvest,
            swapTarget,
            swapData
        );

        require(
            crvTokensBought > minPoolTokens,
            "Received less than minPoolTokens"
        );

        address poolTokenAddress = curveReg.getTokenAddress(swapAddress);

        emit zapIn(msg.sender, poolTokenAddress, crvTokensBought);

        IERC20(poolTokenAddress).transfer(msg.sender, crvTokensBought);
    }

    function _performZapIn(
        address fromTokenAddress,
        address toTokenAddress,
        address swapAddress,
        uint256 toInvest,
        address swapTarget,
        bytes memory swapData
    ) internal returns (uint256 crvTokensBought) {
        (bool isUnderlying, uint8 underlyingIndex) =
            curveReg.isUnderlyingToken(swapAddress, fromTokenAddress);

        if (isUnderlying) {
            crvTokensBought = _enterCurve(
                swapAddress,
                toInvest,
                underlyingIndex
            );
        } else {
            //swap tokens using 0x swap
            uint256 tokensBought =
                _fillQuote(
                    fromTokenAddress,
                    toTokenAddress,
                    toInvest,
                    swapTarget,
                    swapData
                );
            if (toTokenAddress == address(0)) toTokenAddress = ETHAddress;

            //get underlying token index
            (isUnderlying, underlyingIndex) = curveReg.isUnderlyingToken(
                swapAddress,
                toTokenAddress
            );

            if (isUnderlying) {
                crvTokensBought = _enterCurve(
                    swapAddress,
                    tokensBought,
                    underlyingIndex
                );
            } else {
                (uint256 tokens, uint8 metaIndex) =
                    _enterMetaPool(swapAddress, toTokenAddress, tokensBought);

                crvTokensBought = _enterCurve(swapAddress, tokens, metaIndex);
            }
        }
    }

    /**
        @notice This function gets adds the liquidity for meta pools and returns the token index and swap tokens
        @param swapAddress Curve swap address for the pool
        @param toTokenAddress The ERC20 token to which from token to be convert
        @param swapTokens quantity of toToken to invest
        @return tokensBought quantity of curve LP acquired
        @return index index of LP token in swapAddress whose pool tokens were acquired
     */
    function _enterMetaPool(
        address swapAddress,
        address toTokenAddress,
        uint256 swapTokens
    ) internal returns (uint256 tokensBought, uint8 index) {
        address[4] memory poolTokens = curveReg.getPoolTokens(swapAddress);
        for (uint8 i = 0; i < 4; i++) {
            address intermediateSwapAddress =
                curveReg.getSwapAddress(poolTokens[i]);
            if (intermediateSwapAddress != address(0)) {
                (, index) = curveReg.isUnderlyingToken(
                    intermediateSwapAddress,
                    toTokenAddress
                );

                tokensBought = _enterCurve(
                    intermediateSwapAddress,
                    swapTokens,
                    index
                );

                return (tokensBought, i);
            }
        }
    }

    function _fillQuote(
        address fromTokenAddress,
        address toTokenAddress,
        uint256 amount,
        address swapTarget,
        bytes memory swapData
    ) internal returns (uint256 amountBought) {
        if (fromTokenAddress == toTokenAddress) {
            return amount;
        }

        if (swapTarget == wethTokenAddress) {
            IWETH(wethTokenAddress).deposit{ value: amount }();
            return amount;
        }

        uint256 valueToSend;
        if (fromTokenAddress == ETHAddress) {
            valueToSend = amount;
        } else {
            _approveToken(fromTokenAddress, swapTarget, amount);
        }

        uint256 initialBalance = _getBalance(toTokenAddress);

        require(approvedTargets[swapTarget], "Target not Authorized");
        (bool success, ) = swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens");

        amountBought = _getBalance(toTokenAddress) - initialBalance;

        require(amountBought > 0, "Swapped To Invalid Intermediate");
    }

    /**
        @notice This function adds liquidity to a curve pool
        @param swapAddress Curve swap address for the pool
        @param amount The quantity of tokens being added as liquidity
        @param index The token index for the add_liquidity call
        @return crvTokensBought the quantity of curve LP tokens received
    */
    function _enterCurve(
        address swapAddress,
        uint256 amount,
        uint8 index
    ) internal returns (uint256 crvTokensBought) {
        address tokenAddress = curveReg.getTokenAddress(swapAddress);
        address depositAddress = curveReg.getDepositAddress(swapAddress);
        uint256 initialBalance = _getBalance(tokenAddress);
        address entryToken = curveReg.getPoolTokens(swapAddress)[index];
        if (entryToken != ETHAddress) {
            IERC20(entryToken).safeIncreaseAllowance(
                address(depositAddress),
                amount
            );
        }

        uint256 numTokens = curveReg.getNumTokens(swapAddress);
        bool addUnderlying = curveReg.shouldAddUnderlying(swapAddress);

        if (numTokens == 4) {
            uint256[4] memory amounts;
            amounts[index] = amount;
            if (addUnderlying) {
                ICurveSwap(depositAddress).add_liquidity(amounts, 0, true);
            } else {
                ICurveSwap(depositAddress).add_liquidity(amounts, 0);
            }
        } else if (numTokens == 3) {
            uint256[3] memory amounts;
            amounts[index] = amount;
            if (addUnderlying) {
                ICurveSwap(depositAddress).add_liquidity(amounts, 0, true);
            } else {
                ICurveSwap(depositAddress).add_liquidity(amounts, 0);
            }
        } else {
            uint256[2] memory amounts;
            amounts[index] = amount;
            if (curveReg.isEthPool(depositAddress)) {
                ICurveEthSwap(depositAddress).add_liquidity{ value: amount }(
                    amounts,
                    0
                );
            } else if (addUnderlying) {
                ICurveSwap(depositAddress).add_liquidity(amounts, 0, true);
            } else {
                ICurveSwap(depositAddress).add_liquidity(amounts, 0);
            }
        }
        crvTokensBought = _getBalance(tokenAddress) - initialBalance;
    }

    function updateCurveRegistry(ICurveRegistry newCurveRegistry)
        external
        onlyOwner
    {
        require(newCurveRegistry != curveReg, "Already using this Registry");
        curveReg = newCurveRegistry;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Curve_ZapOut_General_V4.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract removes liquidity from Curve pools
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.5.7;
import "../_base/ZapOutBaseV2.sol";
import "./Curve_Registry_V2.sol";

interface ICurveSwap {
    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount
    ) external;

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount,
        bool removeUnderlying
    ) external;

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        uint256 i,
        uint256 min_amount
    ) external;

    function calc_withdraw_one_coin(uint256 tokenAmount, int128 index)
        external
        view
        returns (uint256);

    function calc_withdraw_one_coin(
        uint256 tokenAmount,
        int128 index,
        bool _use_underlying
    ) external view returns (uint256);

    function calc_withdraw_one_coin(uint256 tokenAmount, uint256 index)
        external
        view
        returns (uint256);
}

interface IWETH {
    function withdraw(uint256 wad) external;

    function deposit() external payable;
}

contract Curve_ZapOut_General_V4_2 is ZapOutBaseV2_1 {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    address private constant wethTokenAddress =
        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    Curve_Registry_V2 public curveReg;

    mapping(address => bool) public approvedTargets;

    mapping(address => bool) internal v2Pool;

    constructor(
        Curve_Registry_V2 _curveRegistry,
        uint256 _goodwill,
        uint256 _affiliateSplit
    ) public ZapBaseV1(_goodwill, _affiliateSplit) {
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
        v2Pool[0x80466c64868E1ab14a1Ddf27A676C3fcBE638Fe5] = true;
        curveReg = _curveRegistry;
    }

    event zapOut(
        address sender,
        address pool,
        address token,
        uint256 tokensRec
    );

    /**
    @notice This method removes the liquidity from curve pools to ETH/ERC tokens
    @param swapAddress indicates Curve swap address for the pool
    @param incomingCrv indicates the amount of lp tokens to remove
    @param intermediateToken specifies in which token to exit the curve pool
    @param toToken indicates the ETH/ERC token to which tokens to convert
    @param minToTokens indicates the minimum amount of toTokens to receive
    @param _swapTarget Excecution target for the first swap
    @param _swapCallData DEX quote data
    @param affiliate Affiliate address to share fees
    @param shouldSellEntireBalance True if incomingCrv is determined at execution time (i.e. contract is caller)
    @return ToTokensBought- indicates the amount of toTokens received
     */
    function ZapOut(
        address swapAddress,
        uint256 incomingCrv,
        address intermediateToken,
        address toToken,
        uint256 minToTokens,
        address _swapTarget,
        bytes calldata _swapCallData,
        address affiliate,
        bool shouldSellEntireBalance
    ) external stopInEmergency returns (uint256 ToTokensBought) {
        address poolTokenAddress = curveReg.getTokenAddress(swapAddress);

        // get lp tokens
        incomingCrv = _pullTokens(
            poolTokenAddress,
            incomingCrv,
            shouldSellEntireBalance
        );

        if (intermediateToken == address(0)) {
            intermediateToken = ETHAddress;
        }

        // perform zapOut
        ToTokensBought = _zapOut(
            swapAddress,
            incomingCrv,
            intermediateToken,
            toToken,
            _swapTarget,
            _swapCallData
        );
        require(ToTokensBought >= minToTokens, "High Slippage");

        uint256 totalGoodwillPortion;

        // Transfer tokens
        if (toToken == address(0)) {
            totalGoodwillPortion = _subtractGoodwill(
                ETHAddress,
                ToTokensBought,
                affiliate,
                true
            );
            Address.sendValue(
                msg.sender,
                ToTokensBought.sub(totalGoodwillPortion)
            );
        } else {
            totalGoodwillPortion = _subtractGoodwill(
                toToken,
                ToTokensBought,
                affiliate,
                true
            );

            IERC20(toToken).safeTransfer(
                msg.sender,
                ToTokensBought.sub(totalGoodwillPortion)
            );
        }

        emit zapOut(msg.sender, swapAddress, toToken, ToTokensBought);

        return ToTokensBought.sub(totalGoodwillPortion);
    }

    function _zapOut(
        address swapAddress,
        uint256 incomingCrv,
        address intermediateToken,
        address toToken,
        address _swapTarget,
        bytes memory _swapCallData
    ) internal returns (uint256 ToTokensBought) {
        (bool isUnderlying, uint256 underlyingIndex) =
            curveReg.isUnderlyingToken(swapAddress, intermediateToken);

        // not metapool
        if (isUnderlying) {
            uint256 intermediateBought =
                _exitCurve(
                    swapAddress,
                    incomingCrv,
                    underlyingIndex,
                    intermediateToken
                );

            if (intermediateToken == ETHAddress) intermediateToken = address(0);

            ToTokensBought = _fillQuote(
                intermediateToken,
                toToken,
                intermediateBought,
                _swapTarget,
                _swapCallData
            );
        } else {
            // from metapool
            address[4] memory poolTokens = curveReg.getPoolTokens(swapAddress);
            address intermediateSwapAddress;
            uint8 i;
            for (; i < 4; i++) {
                if (curveReg.getSwapAddress(poolTokens[i]) != address(0)) {
                    intermediateSwapAddress = curveReg.getSwapAddress(
                        poolTokens[i]
                    );
                    break;
                }
            }
            // _exitCurve to intermediateSwapAddress Token
            uint256 intermediateCrvBought =
                _exitMetaCurve(swapAddress, incomingCrv, i, poolTokens[i]);
            // _performZapOut: fromPool = intermediateSwapAddress
            ToTokensBought = _zapOut(
                intermediateSwapAddress,
                intermediateCrvBought,
                intermediateToken,
                toToken,
                _swapTarget,
                _swapCallData
            );
        }
    }

    /**
    @notice This method removes the liquidity from meta curve pools
    @param swapAddress indicates the curve pool address from which liquidity to be removed.
    @param incomingCrv indicates the amount of liquidity to be removed from the pool
    @param index indicates the index of underlying token of the pool in which liquidity will be removed. 
    @return tokensReceived- indicates the amount of reserve tokens received 
    */
    function _exitMetaCurve(
        address swapAddress,
        uint256 incomingCrv,
        uint256 index,
        address exitTokenAddress
    ) internal returns (uint256 tokensReceived) {
        address tokenAddress = curveReg.getTokenAddress(swapAddress);
        _approveToken(tokenAddress, swapAddress);

        uint256 iniTokenBal = IERC20(exitTokenAddress).balanceOf(address(this));
        ICurveSwap(swapAddress).remove_liquidity_one_coin(
            incomingCrv,
            int128(index),
            0
        );
        tokensReceived = (IERC20(exitTokenAddress).balanceOf(address(this)))
            .sub(iniTokenBal);

        require(tokensReceived > 0, "Could not receive reserve tokens");
    }

    /**
    @notice This method removes the liquidity from given curve pool
    @param swapAddress indicates the curve pool address from which liquidity to be removed.
    @param incomingCrv indicates the amount of liquidity to be removed from the pool
    @param index indicates the index of underlying token of the pool in which liquidity will be removed. 
    @return tokensReceived- indicates the amount of reserve tokens received 
    */
    function _exitCurve(
        address swapAddress,
        uint256 incomingCrv,
        uint256 index,
        address exitTokenAddress
    ) internal returns (uint256 tokensReceived) {
        address depositAddress = curveReg.getDepositAddress(swapAddress);

        address tokenAddress = curveReg.getTokenAddress(swapAddress);
        _approveToken(tokenAddress, depositAddress);

        address balanceToken =
            exitTokenAddress == ETHAddress ? address(0) : exitTokenAddress;

        uint256 iniTokenBal = _getBalance(balanceToken);

        if (curveReg.shouldAddUnderlying(swapAddress)) {
            // aave
            ICurveSwap(depositAddress).remove_liquidity_one_coin(
                incomingCrv,
                int128(index),
                0,
                true
            );
        } else if (v2Pool[swapAddress]) {
            ICurveSwap(depositAddress).remove_liquidity_one_coin(
                incomingCrv,
                index,
                0
            );
        } else {
            ICurveSwap(depositAddress).remove_liquidity_one_coin(
                incomingCrv,
                int128(index),
                0
            );
        }

        tokensReceived = _getBalance(balanceToken).sub(iniTokenBal);

        require(tokensReceived > 0, "Could not receive reserve tokens");
    }

    /**
    @notice This method swaps the fromToken to toToken using the 0x swap
    @param _fromTokenAddress indicates the ETH/ERC20 token
    @param _toTokenAddress indicates the ETH/ERC20 token
    @param _amount indicates the amount of from tokens to swap
    @param _swapTarget Excecution target for the first swap
    @param _swapCallData DEX quote data
    */
    function _fillQuote(
        address _fromTokenAddress,
        address _toTokenAddress,
        uint256 _amount,
        address _swapTarget,
        bytes memory _swapCallData
    ) internal returns (uint256 amountBought) {
        if (_fromTokenAddress == _toTokenAddress) return _amount;

        if (
            _fromTokenAddress == wethTokenAddress &&
            _toTokenAddress == address(0)
        ) {
            IWETH(wethTokenAddress).withdraw(_amount);
            return _amount;
        } else if (
            _fromTokenAddress == address(0) &&
            _toTokenAddress == wethTokenAddress
        ) {
            IWETH(wethTokenAddress).deposit.value(_amount)();
            return _amount;
        }

        uint256 valueToSend;
        if (_fromTokenAddress == address(0)) valueToSend = _amount;
        else _approveToken(_fromTokenAddress, _swapTarget, _amount);

        uint256 iniBal = _getBalance(_toTokenAddress);
        require(approvedTargets[_swapTarget], "Target not Authorized");
        (bool success, ) = _swapTarget.call.value(valueToSend)(_swapCallData);
        require(success, "Error Swapping Tokens");
        uint256 finalBal = _getBalance(_toTokenAddress);

        amountBought = finalBal.sub(iniBal);

        require(amountBought > 0, "Swapped To Invalid Intermediate");
    }

    /**
    @notice Utility function to determine the quantity and address of a token being removed
    @param swapAddress indicates the curve pool address from which liquidity to be removed
    @param tokenAddress token to be removed
    @param liquidity Quantity of LP tokens to remove.
    @return  amount Quantity of token removed
    */
    function removeLiquidityReturn(
        address swapAddress,
        address tokenAddress,
        uint256 liquidity
    ) external view returns (uint256 amount) {
        if (tokenAddress == address(0)) tokenAddress = ETHAddress;
        (bool underlying, uint256 index) =
            curveReg.isUnderlyingToken(swapAddress, tokenAddress);
        if (underlying) {
            if (v2Pool[swapAddress]) {
                return
                    ICurveSwap(curveReg.getDepositAddress(swapAddress))
                        .calc_withdraw_one_coin(liquidity, uint256(index));
            } else if (curveReg.shouldAddUnderlying(swapAddress)) {
                return
                    ICurveSwap(curveReg.getDepositAddress(swapAddress))
                        .calc_withdraw_one_coin(liquidity, int128(index), true);
            } else {
                return
                    ICurveSwap(curveReg.getDepositAddress(swapAddress))
                        .calc_withdraw_one_coin(liquidity, int128(index));
            }
        } else {
            address[4] memory poolTokens = curveReg.getPoolTokens(swapAddress);
            address intermediateSwapAddress;
            for (uint256 i = 0; i < 4; i++) {
                intermediateSwapAddress = curveReg.getSwapAddress(
                    poolTokens[i]
                );
                if (intermediateSwapAddress != address(0)) break;
            }
            uint256 metaTokensRec =
                ICurveSwap(swapAddress).calc_withdraw_one_coin(
                    liquidity,
                    int128(1)
                );

            (, index) = curveReg.isUnderlyingToken(
                intermediateSwapAddress,
                tokenAddress
            );

            return
                ICurveSwap(intermediateSwapAddress).calc_withdraw_one_coin(
                    metaTokensRec,
                    int128(index)
                );
        }
    }

    function updateCurveRegistry(Curve_Registry_V2 newCurveRegistry)
        external
        onlyOwner
    {
        require(newCurveRegistry != curveReg, "Already using this Registry");
        curveReg = newCurveRegistry;
    }

    function setApprovedTargets(
        address[] calldata targets,
        bool[] calldata isApproved
    ) external onlyOwner {
        require(targets.length == isApproved.length, "Invalid Input length");

        for (uint256 i = 0; i < targets.length; i++) {
            approvedTargets[targets[i]] = isApproved[i];
        }
    }

    function setV2Pool(address[] calldata pool, bool[] calldata isV2Pool)
        external
        onlyOwner
    {
        require(pool.length == isV2Pool.length, "Invalid Input length");

        for (uint256 i = 0; i < pool.length; i++) {
            v2Pool[pool[i]] = isV2Pool[i];
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ERC1155.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC1155.sol";

import "./IERC1155Receiver.sol";

import "./extensions/IERC1155MetadataURI.sol";

import "../utils/Address.sol";

import "../utils/Context.sol";

import "../utils/introspection/ERC165.sol";



/**

 * @dev Implementation of the basic standard multi-token.

 * See https://eips.ethereum.org/EIPS/eip-1155

 * Originally based on code by Enjin: https://github.com/enjin/erc-1155

 *

 * _Available since v3.1._

 */

contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {

    using Address for address;



    // Mapping from token ID to account balances

    mapping(uint256 => mapping(address => uint256)) private _balances;



    // Mapping from account to operator approvals

    mapping(address => mapping(address => bool)) private _operatorApprovals;



    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json

    string private _uri;



    /**

     * @dev See {_setURI}.

     */

    constructor(string memory uri_) {

        _setURI(uri_);

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId)

        public

        view

        virtual

        override(ERC165, IERC165)

        returns (bool)

    {

        return

            interfaceId == type(IERC1155).interfaceId ||

            interfaceId == type(IERC1155MetadataURI).interfaceId ||

            super.supportsInterface(interfaceId);

    }



    /**

     * @dev See {IERC1155MetadataURI-uri}.

     *

     * This implementation returns the same URI for *all* token types. It relies

     * on the token type ID substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * Clients calling this function must replace the `\{id\}` substring with the

     * actual token type ID.

     */

    function uri(uint256) public view virtual override returns (string memory) {

        return _uri;

    }



    /**

     * @dev See {IERC1155-balanceOf}.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id)

        public

        view

        virtual

        override

        returns (uint256)

    {

        require(

            account != address(0),

            "ERC1155: balance query for the zero address"

        );

        return _balances[id][account];

    }



    /**

     * @dev See {IERC1155-balanceOfBatch}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)

        public

        view

        virtual

        override

        returns (uint256[] memory)

    {

        require(

            accounts.length == ids.length,

            "ERC1155: accounts and ids length mismatch"

        );



        uint256[] memory batchBalances = new uint256[](accounts.length);



        for (uint256 i = 0; i < accounts.length; ++i) {

            batchBalances[i] = balanceOf(accounts[i], ids[i]);

        }



        return batchBalances;

    }



    /**

     * @dev See {IERC1155-setApprovalForAll}.

     */

    function setApprovalForAll(address operator, bool approved)

        public

        virtual

        override

    {

        require(

            _msgSender() != operator,

            "ERC1155: setting approval status for self"

        );



        _operatorApprovals[_msgSender()][operator] = approved;

        emit ApprovalForAll(_msgSender(), operator, approved);

    }



    /**

     * @dev See {IERC1155-isApprovedForAll}.

     */

    function isApprovedForAll(address account, address operator)

        public

        view

        virtual

        override

        returns (bool)

    {

        return _operatorApprovals[account][operator];

    }



    /**

     * @dev See {IERC1155-safeTransferFrom}.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) public virtual override {

        require(to != address(0), "ERC1155: transfer to the zero address");

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: caller is not owner nor approved"

        );



        address operator = _msgSender();



        _beforeTokenTransfer(

            operator,

            from,

            to,

            _asSingletonArray(id),

            _asSingletonArray(amount),

            data

        );



        uint256 fromBalance = _balances[id][from];

        require(

            fromBalance >= amount,

            "ERC1155: insufficient balance for transfer"

        );

        _balances[id][from] = fromBalance - amount;

        _balances[id][to] += amount;



        emit TransferSingle(operator, from, to, id, amount);



        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);

    }



    /**

     * @dev See {IERC1155-safeBatchTransferFrom}.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) public virtual override {

        require(

            ids.length == amounts.length,

            "ERC1155: ids and amounts length mismatch"

        );

        require(to != address(0), "ERC1155: transfer to the zero address");

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: transfer caller is not owner nor approved"

        );



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; ++i) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 fromBalance = _balances[id][from];

            require(

                fromBalance >= amount,

                "ERC1155: insufficient balance for transfer"

            );

            _balances[id][from] = fromBalance - amount;

            _balances[id][to] += amount;

        }



        emit TransferBatch(operator, from, to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(

            operator,

            from,

            to,

            ids,

            amounts,

            data

        );

    }



    /**

     * @dev Sets a new URI for all token types, by relying on the token type ID

     * substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * By this mechanism, any occurrence of the `\{id\}` substring in either the

     * URI or any of the amounts in the JSON file at said URI will be replaced by

     * clients with the token type ID.

     *

     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be

     * interpreted by clients as

     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`

     * for token type ID 0x4cce0.

     *

     * See {uri}.

     *

     * Because these URIs cannot be meaningfully represented by the {URI} event,

     * this function emits no events.

     */

    function _setURI(string memory newuri) internal virtual {

        _uri = newuri;

    }



    /**

     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function _mint(

        address account,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        require(account != address(0), "ERC1155: mint to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(

            operator,

            address(0),

            account,

            _asSingletonArray(id),

            _asSingletonArray(amount),

            data

        );



        _balances[id][account] += amount;

        emit TransferSingle(operator, address(0), account, id, amount);



        _doSafeTransferAcceptanceCheck(

            operator,

            address(0),

            account,

            id,

            amount,

            data

        );

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function _mintBatch(

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: mint to the zero address");

        require(

            ids.length == amounts.length,

            "ERC1155: ids and amounts length mismatch"

        );



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; i++) {

            _balances[ids[i]][to] += amounts[i];

        }



        emit TransferBatch(operator, address(0), to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(

            operator,

            address(0),

            to,

            ids,

            amounts,

            data

        );

    }



    /**

     * @dev Destroys `amount` tokens of token type `id` from `account`

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens of token type `id`.

     */

    function _burn(

        address account,

        uint256 id,

        uint256 amount

    ) internal virtual {

        require(account != address(0), "ERC1155: burn from the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(

            operator,

            account,

            address(0),

            _asSingletonArray(id),

            _asSingletonArray(amount),

            ""

        );



        uint256 accountBalance = _balances[id][account];

        require(

            accountBalance >= amount,

            "ERC1155: burn amount exceeds balance"

        );

        _balances[id][account] = accountBalance - amount;



        emit TransferSingle(operator, account, address(0), id, amount);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     */

    function _burnBatch(

        address account,

        uint256[] memory ids,

        uint256[] memory amounts

    ) internal virtual {

        require(account != address(0), "ERC1155: burn from the zero address");

        require(

            ids.length == amounts.length,

            "ERC1155: ids and amounts length mismatch"

        );



        address operator = _msgSender();



        _beforeTokenTransfer(operator, account, address(0), ids, amounts, "");



        for (uint256 i = 0; i < ids.length; i++) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 accountBalance = _balances[id][account];

            require(

                accountBalance >= amount,

                "ERC1155: burn amount exceeds balance"

            );

            _balances[id][account] = accountBalance - amount;

        }



        emit TransferBatch(operator, account, address(0), ids, amounts);

    }



    /**

     * @dev Hook that is called before any token transfer. This includes minting

     * and burning, as well as batched variants.

     *

     * The same hook is called on both single and batched variants. For single

     * transfers, the length of the `id` and `amount` arrays will be 1.

     *

     * Calling conditions (for each `id` and `amount` pair):

     *

     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * of token type `id` will be  transferred to `to`.

     * - When `from` is zero, `amount` tokens of token type `id` will be minted

     * for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`

     * will be burned.

     * - `from` and `to` are never both zero.

     * - `ids` and `amounts` have the same, non-zero length.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    function _doSafeTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try

                IERC1155Receiver(to).onERC1155Received(

                    operator,

                    from,

                    id,

                    amount,

                    data

                )

            returns (bytes4 response) {

                if (

                    response != IERC1155Receiver(to).onERC1155Received.selector

                ) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _doSafeBatchTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try

                IERC1155Receiver(to).onERC1155BatchReceived(

                    operator,

                    from,

                    ids,

                    amounts,

                    data

                )

            returns (bytes4 response) {

                if (

                    response !=

                    IERC1155Receiver(to).onERC1155BatchReceived.selector

                ) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _asSingletonArray(uint256 element)

        private

        pure

        returns (uint256[] memory)

    {

        uint256[] memory array = new uint256[](1);

        array[0] = element;



        return array;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check

 * for the additional interface id that will be supported. For example:

 *

 * ```solidity

 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);

 * }

 * ```

 *

 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.

 */

abstract contract ERC165 is IERC165 {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId)

        public

        view

        virtual

        override

        returns (bool)

    {

        return interfaceId == type(IERC165).interfaceId;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC20.sol";

import "./extensions/IERC20Metadata.sol";

import "../../utils/Context.sol";



/**

 * @dev Implementation of the {IERC20} interface.

 *

 * This implementation is agnostic to the way tokens are created. This means

 * that a supply mechanism has to be added in a derived contract using {_mint}.

 * For a generic mechanism see {ERC20PresetMinterPauser}.

 *

 * TIP: For a detailed writeup see our guide

 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How

 * to implement supply mechanisms].

 *

 * We have followed general OpenZeppelin guidelines: functions revert instead

 * of returning `false` on failure. This behavior is nonetheless conventional

 * and does not conflict with the expectations of ERC20 applications.

 *

 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.

 * This allows applications to reconstruct the allowance for all accounts just

 * by listening to said events. Other implementations of the EIP may not emit

 * these events, as it isn't required by the specification.

 *

 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}

 * functions have been added to mitigate the well-known issues around setting

 * allowances. See {IERC20-approve}.

 */

contract ERC20 is Context, IERC20, IERC20Metadata {

    mapping(address => uint256) private _balances;



    mapping(address => mapping(address => uint256)) private _allowances;



    uint256 private _totalSupply;



    string private _name;

    string private _symbol;



    /**

     * @dev Sets the values for {name} and {symbol}.

     *

     * The defaut value of {decimals} is 18. To select a different value for

     * {decimals} you should overload it.

     *

     * All two of these values are immutable: they can only be set once during

     * construction.

     */

    constructor(string memory name_, string memory symbol_) {

        _name = name_;

        _symbol = symbol_;

    }



    /**

     * @dev Returns the name of the token.

     */

    function name() public view virtual override returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view virtual override returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5,05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei. This is the value {ERC20} uses, unless this function is

     * overridden;

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view virtual override returns (uint8) {

        return 18;

    }



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view virtual override returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account)

        public

        view

        virtual

        override

        returns (uint256)

    {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `recipient` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address recipient, uint256 amount)

        public

        virtual

        override

        returns (bool)

    {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender)

        public

        view

        virtual

        override

        returns (uint256)

    {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount)

        public

        virtual

        override

        returns (bool)

    {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20}.

     *

     * Requirements:

     *

     * - `sender` and `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     * - the caller must have allowance for ``sender``'s tokens of at least

     * `amount`.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);



        uint256 currentAllowance = _allowances[sender][_msgSender()];

        require(

            currentAllowance >= amount,

            "ERC20: transfer amount exceeds allowance"

        );

        _approve(sender, _msgSender(), currentAllowance - amount);



        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue)

        public

        virtual

        returns (bool)

    {

        _approve(

            _msgSender(),

            spender,

            _allowances[_msgSender()][spender] + addedValue

        );

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue)

        public

        virtual

        returns (bool)

    {

        uint256 currentAllowance = _allowances[_msgSender()][spender];

        require(

            currentAllowance >= subtractedValue,

            "ERC20: decreased allowance below zero"

        );

        _approve(_msgSender(), spender, currentAllowance - subtractedValue);



        return true;

    }



    /**

     * @dev Moves tokens `amount` from `sender` to `recipient`.

     *

     * This is internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `sender` cannot be the zero address.

     * - `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     */

    function _transfer(

        address sender,

        address recipient,

        uint256 amount

    ) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);



        uint256 senderBalance = _balances[sender];

        require(

            senderBalance >= amount,

            "ERC20: transfer amount exceeds balance"

        );

        _balances[sender] = senderBalance - amount;

        _balances[recipient] += amount;



        emit Transfer(sender, recipient, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply += amount;

        _balances[account] += amount;

        emit Transfer(address(0), account, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        uint256 accountBalance = _balances[account];

        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");

        _balances[account] = accountBalance - amount;

        _totalSupply -= amount;



        emit Transfer(account, address(0), amount);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.

     *

     * This internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(

        address owner,

        address spender,

        uint256 amount

    ) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    /**

     * @dev Hook that is called before any transfer of tokens. This includes

     * minting and burning.

     *

     * Calling conditions:

     *

     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * will be to transferred to `to`.

     * - when `from` is zero, `amount` tokens will be minted for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.

     * - `from` and `to` are never both zero.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ERC20toUniPoolZapV1_General.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-02-25

*/



// Copyright (C) 2019, 2020 dipeshsukhani, nodarjonashi, suhailg



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU Affero General Public License as published by

// the Free Software Foundation, either version 2 of the License, or

// (at your option) any later version.

//

// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU Affero General Public License for more details.

//

// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License





// File: localhost/defizap/node_modules/@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol



///@author DeFiZap

///@notice this contract implements one click conversion from ERC20 to UniPoolZap





pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: localhost/defizap/node_modules/@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: localhost/defizap/node_modules/@openzeppelin/upgrades/contracts/Initializable.sol



pragma solidity >=0.4.24 <0.7.0;





/**

 * @title Initializable

 *

 * @dev Helper contract to support initializer functions. To use it, replace

 * the constructor with a function that has the `initializer` modifier.

 * WARNING: Unlike constructors, initializer functions must be manually

 * invoked. This applies both to deploying an Initializable contract, as well

 * as extending an Initializable contract via inheritance.

 * WARNING: When used with inheritance, manual care must be taken to not invoke

 * a parent initializer twice, or ensure that all initializers are idempotent,

 * because this is not dealt with automatically as with constructors.

 */

contract Initializable {



  /**

   * @dev Indicates that the contract has been initialized.

   */

  bool private initialized;



  /**

   * @dev Indicates that the contract is in the process of being initialized.

   */

  bool private initializing;



  /**

   * @dev Modifier to use in the initializer function of a contract.

   */

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  /// @dev Returns true if and only if the function is running in the constructor

  function isConstructor() private view returns (bool) {

    // extcodesize checks the size of the code stored in an address, and

    // address returns the current address. Since the code is still not

    // deployed when running a constructor, any checks on its code size will

    // yield zero, making it an effective way to detect if a contract is

    // under construction or not.

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  // Reserved storage space to allow for layout changes in the future.

  uint256[50] private ______gap;

}







pragma solidity ^0.5.0;





// interface

interface IuniswapFactory_ERC20toUniPoolZapV1 {

    function getExchange(address token)

        external

        view

        returns (address exchange);

}



interface IuniswapExchange_ERC20toUniPoolZapV1 {

    function getEthToTokenInputPrice(uint256 eth_sold)

        external

        view

        returns (uint256 tokens_bought);

    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)

        external

        payable

        returns (uint256 tokens_bought);

    function balanceOf(address _owner) external view returns (uint256);

    function transfer(address _to, uint256 _value) external returns (bool);

    function tokenToEthSwapInput(

        uint256 tokens_sold,

        uint256 min_eth,

        uint256 deadline

    ) external returns (uint256 eth_bought);

    function tokenToEthTransferInput(

        uint256 tokens_sold,

        uint256 min_eth,

        uint256 deadline,

        address recipient

    ) external returns (uint256 eth_bought);

    function tokenToTokenSwapInput(

        uint256 tokens_sold,

        uint256 min_tokens_bought,

        uint256 min_eth_bought,

        uint256 deadline,

        address token_addr

    ) external returns (uint256 tokens_bought);

    function addLiquidity(

        uint256 min_liquidity,

        uint256 max_tokens,

        uint256 deadline

    ) external payable returns (uint256);



}



contract Ownable {

    address payable public owner = 0x19627796b318E27C333530aD67c464Cfc37596ec;



    modifier onlyOwner() {

        require(isOwner(), "you are not authorised to call this function");

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == owner;

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address payable newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address payable newOwner) internal {

        require(

            newOwner != address(0),

            "Ownable: new owner is the zero address"

        );

        owner = newOwner;

    }



}



contract ERC20toUniPoolZapV1_General is Initializable, Ownable {

    using SafeMath for uint256;



    // state variables



    // - THESE MUST ALWAYS STAY IN THE SAME LAYOUT

    bool private stopped = false;



    IuniswapFactory_ERC20toUniPoolZapV1 public UniSwapFactoryAddress = IuniswapFactory_ERC20toUniPoolZapV1(

        0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95

    );



    mapping(address => uint256) private userBalance;



    // events

    event details(

        address indexed user,

        address toWhomIssued,

        address indexed IncomingTokenAddress,

        address indexed UniPoolUnderlyingTokenAddressTokenAddress

    );

    event residualETH(uint256 residualETHtransferred);



    // circuit breaker modifiers

    modifier stopInEmergency {

        if (stopped) {

            revert("Temporarily Paused");

        } else {

            _;

        }

    }



    constructor() public {}



    function LetsInvest(

        address _toWhomToIssue,

        address _IncomingTokenContractAddress,

        uint256 _IncomingTokenQty,

        address _UniPoolsUnderlyingTokenAddress

    )

        public

        stopInEmergency

        returns (bool)

    {

        // checkingAllowance

        require(

            IERC20(_IncomingTokenContractAddress).balanceOf(msg.sender) >

                _IncomingTokenQty,

            "Ownership less than requested"

        );

        require(

            IERC20(_IncomingTokenContractAddress).allowance(

                msg.sender,

                address(this)

            ) >

                _IncomingTokenQty,

            "Permission to DeFiZap is less than requested"

        );

        uint256 investmentQTY = _IncomingTokenQty;

        require(

            IERC20(_IncomingTokenContractAddress).transferFrom(

                msg.sender,

                address(this),

                investmentQTY

            ),

            "Error in transferring token:1"

        );

        require(

            (

                invest2UniPool(

                    investmentQTY,

                    _toWhomToIssue,

                    _IncomingTokenContractAddress,

                    _UniPoolsUnderlyingTokenAddress

                )

            ),

            "error in invest2UniPool"

        );

        emit details(

            msg.sender,

            _toWhomToIssue,

            _IncomingTokenContractAddress,

            _UniPoolsUnderlyingTokenAddress

        );

        return (true);

    }



    function invest2UniPool(

        uint256 _ERC20QTY,

        address _toWhomToIssue,

        address _IncomingTokenContractAddress,

        address _UniPoolsUnderlyingTokenAddress

    ) internal returns (bool) {

        // setting some internal variables

        uint256 EthOnConversion;

        uint256 nonConvertiblePortion;

        IuniswapExchange_ERC20toUniPoolZapV1 UniSwapExchangeContractAddress;

        // computation

        if (_IncomingTokenContractAddress == _UniPoolsUnderlyingTokenAddress) {

            nonConvertiblePortion = SafeMath.div(

                SafeMath.mul(_ERC20QTY, 503),

                1000

            );

            uint256 convertiblePortion = SafeMath.sub(

                _ERC20QTY,

                nonConvertiblePortion

            );

            // finding the uniswap address

            UniSwapExchangeContractAddress = IuniswapExchange_ERC20toUniPoolZapV1(

                UniSwapFactoryAddress.getExchange(_IncomingTokenContractAddress)

            );

            // approving the address

            IERC20(_IncomingTokenContractAddress).approve(

                address(UniSwapExchangeContractAddress),

                _ERC20QTY

            );

            // converting the required portion to ETH

            EthOnConversion = UniSwapExchangeContractAddress

                .tokenToEthSwapInput(

                convertiblePortion,

                1,

                SafeMath.add(now, 1800)

            );



        } else {

            // convert ERCs

            IuniswapExchange_ERC20toUniPoolZapV1 UniSwapExchangeContractAddress_incomingToken = IuniswapExchange_ERC20toUniPoolZapV1(

                UniSwapFactoryAddress.getExchange(_IncomingTokenContractAddress)

            );



            require(

                (

                    IERC20(_IncomingTokenContractAddress).approve(

                        address(UniSwapExchangeContractAddress_incomingToken),

                        _ERC20QTY

                    )

                ),

                "error in approval:3"

            );

            uint256 nonConvertiblePortion_beforeConversion = SafeMath.div(

                SafeMath.mul(_ERC20QTY, 503),

                1000

            );

            nonConvertiblePortion = UniSwapExchangeContractAddress_incomingToken

                .tokenToTokenSwapInput(

                nonConvertiblePortion_beforeConversion,

                1,

                1,

                SafeMath.add(now, 1800),

                _UniPoolsUnderlyingTokenAddress

            );



            uint256 convertiblePortion = SafeMath.sub(

                _ERC20QTY,

                nonConvertiblePortion_beforeConversion

            );



            EthOnConversion = UniSwapExchangeContractAddress_incomingToken

                .tokenToEthSwapInput(

                convertiblePortion,

                1,

                SafeMath.add(now, 1800)

            );



            require(

                (

                    IERC20(_IncomingTokenContractAddress).approve(

                        address(UniSwapExchangeContractAddress_incomingToken),

                        0

                    )

                ),

                "error in setting approval back to zero"

            );

            UniSwapExchangeContractAddress = IuniswapExchange_ERC20toUniPoolZapV1(

                UniSwapFactoryAddress.getExchange(

                    _UniPoolsUnderlyingTokenAddress

                )

            );



        }

        require(

            (

                addLiquidity(

                    _toWhomToIssue,

                    _UniPoolsUnderlyingTokenAddress,

                    nonConvertiblePortion,

                    UniSwapExchangeContractAddress,

                    EthOnConversion

                )

            ),

            "issue in adding Liquidity"

        );

        return (true);

    }



    function addLiquidity(

        address _toWhomToIssue,

        address _UniPoolsUnderlyingTokenAddress,

        uint256 _UsableERC20,

        IuniswapExchange_ERC20toUniPoolZapV1 _UniSwapExchangeContractAddress,

        uint256 _valueinETH

    ) internal returns (bool) {

        uint256 max_tokens_ans = getMaxTokens(

            address(_UniSwapExchangeContractAddress),

            IERC20(_UniPoolsUnderlyingTokenAddress),

            _valueinETH

        );



        require(

            (

                IERC20(_UniPoolsUnderlyingTokenAddress).approve(

                    address(_UniSwapExchangeContractAddress),

                    _UsableERC20

                )

            ),

            "error in approving the unicontract, addLiquidity"

        );

        uint256 LiquidityTokens = _UniSwapExchangeContractAddress

            .addLiquidity

            .value(_valueinETH)(1, max_tokens_ans, SafeMath.add(now, 1800));

        require(

            LiquidityTokens ==

                _UniSwapExchangeContractAddress.balanceOf(address(this)),

            "error3:DeFiZap"

        );

        require(

            _UniSwapExchangeContractAddress.transfer(

                _toWhomToIssue,

                LiquidityTokens

            ),

            "error6:DeFiZap"

        );



        // computing the remainder of the tokens

        uint256 residual = IERC20(_UniPoolsUnderlyingTokenAddress).balanceOf(

            address(this)

        );

        uint256 ETHfromResidual = _UniSwapExchangeContractAddress

            .tokenToEthTransferInput(

            residual,

            1,

            SafeMath.add(now, 1800),

            _toWhomToIssue

        );

        emit residualETH(ETHfromResidual);

        require(

            (

                IERC20(_UniPoolsUnderlyingTokenAddress).approve(

                    address(_UniSwapExchangeContractAddress),

                    0

                )

            ),

            "error in resetting the approval to zero"

        );

        return true;

    }



    function getMaxTokens(

        address _UniSwapExchangeContractAddress,

        IERC20 _ERC20TokenAddress,

        uint256 _value

    ) internal view returns (uint256) {

        uint256 contractBalance = address(_UniSwapExchangeContractAddress)

            .balance;

        uint256 eth_reserve = SafeMath.sub(contractBalance, _value);

        uint256 token_reserve = _ERC20TokenAddress.balanceOf(

            _UniSwapExchangeContractAddress

        );

        uint256 token_amount = SafeMath.div(

            SafeMath.mul(_value, token_reserve),

            eth_reserve

        ) +

            1;

        return token_amount;

    }



    function inCaseTokengetsStuck(IERC20 _TokenAddress) public onlyOwner {

        uint256 qty = _TokenAddress.balanceOf(address(this));

        _TokenAddress.transfer(owner, qty);

    }



    // - to Pause the contract

    function toggleContractActive() public onlyOwner {

        stopped = !stopped;

    }



    // - to withdraw any ETH balance sitting in the contract

    function withdraw() public onlyOwner {

        owner.transfer(address(this).balance);

    }



    // - fallback function let you / anyone send ETH to this wallet without the need to call any function

    function() external payable {

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ETH_ERC20_Curve_General_Zap_V1.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-06-29

*/



// Copyright (C) 2019, 2020 dipeshsukhani, nodarjanashia, suhailg, apoorvlathey, sebaudet, sumit



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU Affero General Public License as published by

// the Free Software Foundation, either version 2 of the License, or

// (at your option) any later version.

//

// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU Affero General Public License for more details.

//

// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License



///@author DeFiZap

///@notice this contract implements one click swapping among Uniswap Pools.



pragma solidity ^0.5.0;





/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount)

        external

        returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender)

        external

        view

        returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount)

        external

        returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );

}

// File: browser/Context.sol



pragma solidity ^0.5.0;





/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor() internal {}



    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

// File: browser/OpenZepplinOwnable.sol



pragma solidity ^0.5.0;





/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address payable public _owner;



    event OwnershipTransferred(

        address indexed previousOwner,

        address indexed newOwner

    );



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() internal {

        address payable msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address payable newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address payable newOwner) internal {

        require(

            newOwner != address(0),

            "Ownable: new owner is the zero address"

        );

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

// File: browser/OpenZepplinSafeMath.sol



pragma solidity ^0.5.0;





/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage)

        internal

        pure

        returns (uint256)

    {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage)

        internal

        pure

        returns (uint256)

    {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage)

        internal

        pure

        returns (uint256)

    {

        require(b != 0, errorMessage);

        return a % b;

    }

}

// File: browser/OpenZepplinReentrancyGuard.sol



pragma solidity ^0.5.0;





/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * _Since v2.5.0:_ this module is now much more gas efficient, given net gas

 * metering changes introduced in the Istanbul hardfork.

 */

contract ReentrancyGuard {

    bool private _notEntered;



    constructor() internal {

        // Storing an initial non-zero value makes deployment a bit more

        // expensive, but in exchange the refund on every call to nonReentrant

        // will be lower in amount. Since refunds are capped to a percetange of

        // the total transaction's gas, it is best to keep them low in cases

        // like this one, to increase the likelihood of the full refund coming

        // into effect.

        _notEntered = true;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_notEntered, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _notEntered = false;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _notEntered = true;

    }

}





// interface

interface IuniswapFactory {

    function getExchange(address token)

        external

        view

        returns (address exchange);

}





interface IuniswapExchange {

    // for removing liquidity (returns ETH removed, ERC20 Removed)

    function removeLiquidity(

        uint256 amount,

        uint256 min_eth,

        uint256 min_tokens,

        uint256 deadline

    ) external returns (uint256, uint256);



    // converting ERC20 to ERC20 and transfer

    function tokenToTokenSwapInput(

        uint256 tokens_sold,

        uint256 min_tokens_bought,

        uint256 min_eth_bought,

        uint256 deadline,

        address token_addr

    ) external returns (uint256 tokens_bought);



    // add liquidity to a pool (returns LP tokens rec)

    function addLiquidity(

        uint256 min_liquidity,

        uint256 max_tokens,

        uint256 deadline

    ) external payable returns (uint256);



    function getEthToTokenInputPrice(uint256 eth_sold)

        external

        view

        returns (uint256 tokens_bought);



    function getTokenToEthInputPrice(uint256 tokens_sold)

        external

        view

        returns (uint256 eth_bought);



    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)

        external

        payable

        returns (uint256 tokens_bought);



    function balanceOf(address _owner) external view returns (uint256);



    function transfer(address _to, uint256 _value) external returns (bool);



    function transferFrom(address from, address to, uint256 tokens)

        external

        returns (bool success);

}





interface ICurveExchange {

    function add_liquidity(uint256[4] calldata amounts, uint256 min_mint_amount)

        external;

}



interface IrenBtcCurveExchange {

    function add_liquidity(

        uint256[2] calldata amounts,

        uint min_mint_amount

    ) external;

}



interface IsBtcCurveExchange {

    function add_liquidity(

        uint256[3] calldata amounts,

        uint min_mint_amount

    ) external;

}





interface yERC20 {

    function deposit(uint256 _amount) external;

}



contract ETH_ERC20_Curve_General_Zap_V1 is ReentrancyGuard, Ownable {

    using SafeMath for uint256;

    bool private stopped = false;

    uint16 public goodwill;

    address public dzgoodwillAddress;

    



    IuniswapFactory private UniSwapFactoryAddress = IuniswapFactory(

        0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95

    );

    address private DaiTokenAddress = address(

        0x6B175474E89094C44Da98b954EedeAC495271d0F

    );

    address private UsdcTokenAddress = address(

        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48

    );

    address private sUSDCurveExchangeAddress = address(

        0xA5407eAE9Ba41422680e2e00537571bcC53efBfD

    );

    address private sUSDCurvePoolTokenAddress = address(

        0xC25a3A3b969415c80451098fa907EC722572917F

    );

    address private yCurveExchangeAddress = address(

        0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3

    );

    address private yCurvePoolTokenAddress = address(

        0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8

    );

    address private bUSDCurveExchangeAddress = address(

        0xb6c057591E073249F2D9D88Ba59a46CFC9B59EdB

    );

    address private bUSDCurvePoolTokenAddress = address(

        0x3B3Ac5386837Dc563660FB6a0937DFAa5924333B

    );

    address private paxCurveExchangeAddress = address(

        0xA50cCc70b6a011CffDdf45057E39679379187287

    );

    address private paxCurvePoolTokenAddress = address(

        0xD905e2eaeBe188fc92179b6350807D8bd91Db0D8

    );

    address private renBtcCurveExchangeAddress = address(

        0x93054188d876f558f4a66B2EF1d97d16eDf0895B

    );

    address private renBtcCurvePoolTokenAddress = address(

        0x49849C98ae39Fff122806C06791Fa73784FB3675

    );

    address private sBtcCurveExchangeAddress = address(

        0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714

    );

    address private sBtcCurvePoolTokenAddress = address(

        0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3

    );

    

    

    address private wbtcTokenAddress = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);

    address private renBtcTokenAddress = address(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);

    address private sBtcTokenAddress = address(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);





    mapping(address => address) internal exchange2Token;



    constructor(uint16 _goodwill, address _dzgoodwillAddress) public {

        goodwill = _goodwill;

        dzgoodwillAddress = _dzgoodwillAddress;

        exchange2Token[sUSDCurveExchangeAddress] = sUSDCurvePoolTokenAddress;

        exchange2Token[yCurveExchangeAddress] = yCurvePoolTokenAddress;

        exchange2Token[bUSDCurveExchangeAddress] = bUSDCurvePoolTokenAddress;

        exchange2Token[paxCurveExchangeAddress] = paxCurvePoolTokenAddress;

        exchange2Token[renBtcCurveExchangeAddress] = renBtcCurvePoolTokenAddress;     

        exchange2Token[sBtcCurveExchangeAddress] = sBtcCurvePoolTokenAddress;

        

        approveToken();

    }



    // circuit breaker modifiers

    modifier stopInEmergency {

        if (stopped) {

            revert("Temporarily Paused");

        } else {

            _;

        }

    }



    function approveToken() public {

        IERC20(DaiTokenAddress).approve(sUSDCurveExchangeAddress, uint256(-1));

        IERC20(DaiTokenAddress).approve(yCurveExchangeAddress, uint256(-1));

        IERC20(DaiTokenAddress).approve(bUSDCurveExchangeAddress, uint256(-1));

        IERC20(DaiTokenAddress).approve(paxCurveExchangeAddress, uint256(-1));



        IERC20(UsdcTokenAddress).approve(sUSDCurveExchangeAddress, uint256(-1));

        IERC20(UsdcTokenAddress).approve(yCurveExchangeAddress, uint256(-1));

        IERC20(UsdcTokenAddress).approve(bUSDCurveExchangeAddress, uint256(-1));

        IERC20(UsdcTokenAddress).approve(paxCurveExchangeAddress, uint256(-1));

    }





    function ZapIn(

        address _toWhomToIssue,

        address _IncomingTokenAddress,

        address _curvePoolExchangeAddress,

        uint256 _IncomingTokenQty,

        uint256 _minPoolTokens

    ) public payable stopInEmergency returns (uint256 crvTokensBought) {

        require(

            _curvePoolExchangeAddress == sUSDCurveExchangeAddress ||

                _curvePoolExchangeAddress == yCurveExchangeAddress ||

                _curvePoolExchangeAddress == bUSDCurveExchangeAddress ||

                _curvePoolExchangeAddress == paxCurveExchangeAddress ||

                _curvePoolExchangeAddress == renBtcCurveExchangeAddress ||

                _curvePoolExchangeAddress == sBtcCurveExchangeAddress,

            "Invalid Curve Pool Address"

        );



        if (_IncomingTokenAddress == address(0)) {

            crvTokensBought = ZapInWithETH(

                _toWhomToIssue,

                _curvePoolExchangeAddress,

                _minPoolTokens

            );

        } else {

            crvTokensBought = ZapInWithERC20(

                _toWhomToIssue,

                _IncomingTokenAddress,

                _curvePoolExchangeAddress,

                _IncomingTokenQty,

                _minPoolTokens

            );

        }

    }



    function ZapInWithETH(

        address _toWhomToIssue,

        address _curvePoolExchangeAddress,

        uint256 _minPoolTokens

    ) internal stopInEmergency returns (uint256 crvTokensBought) {

        require(msg.value > 0, "Err: No ETH sent");

        

        if(_curvePoolExchangeAddress != sBtcCurveExchangeAddress && _curvePoolExchangeAddress != renBtcCurveExchangeAddress) {

            uint256 daiBought = _eth2Token(DaiTokenAddress, (msg.value).div(2));

            uint256 usdcBought = _eth2Token(UsdcTokenAddress, (msg.value).div(2));

            crvTokensBought = _enter2Curve(

                _toWhomToIssue,

                daiBought,

                usdcBought,

                _curvePoolExchangeAddress,

                _minPoolTokens

            );

        } else {

            uint256 wbtcBought = _eth2Token(wbtcTokenAddress, msg.value);

            crvTokensBought = _enter2BtcCurve(

                _toWhomToIssue,

                wbtcTokenAddress,

                _curvePoolExchangeAddress,

                wbtcBought,

                _minPoolTokens

            );

        }

    }





    function ZapInWithERC20(

        address _toWhomToIssue,

        address _IncomingTokenAddress,

        address _curvePoolExchangeAddress,

        uint256 _IncomingTokenQty,

        uint256 _minPoolTokens

    ) internal stopInEmergency returns (uint256 crvTokensBought) {

        require(_IncomingTokenQty > 0, "Err: No ERC20 sent");



        require(

            IERC20(_IncomingTokenAddress).transferFrom(

                msg.sender,

                address(this),

                _IncomingTokenQty

            ),

            "Error in transferring ERC20"

        );

        

        if(_curvePoolExchangeAddress == sBtcCurveExchangeAddress || _curvePoolExchangeAddress == renBtcCurveExchangeAddress) {

            if(_IncomingTokenAddress == wbtcTokenAddress || _IncomingTokenAddress == renBtcTokenAddress || _IncomingTokenAddress == sBtcTokenAddress) {

                crvTokensBought = _enter2BtcCurve(

                    _toWhomToIssue,

                    _IncomingTokenAddress,

                    _curvePoolExchangeAddress,

                    _IncomingTokenQty,

                    _minPoolTokens

                );

            } else {

                uint256 wbtcBought = _token2Token(

                    _IncomingTokenAddress,

                    wbtcTokenAddress,

                    _IncomingTokenQty

                );

                crvTokensBought = _enter2BtcCurve(

                    _toWhomToIssue,

                    wbtcTokenAddress,

                    _curvePoolExchangeAddress,

                    wbtcBought,

                    _minPoolTokens

                );

            }

            

        } else {

            uint256 daiBought;

            uint256 usdcBought;

    

            if (_IncomingTokenAddress == DaiTokenAddress) {

                daiBought = _IncomingTokenQty;

                usdcBought = 0;

            } else if (_IncomingTokenAddress == UsdcTokenAddress) {

                daiBought = 0;

                usdcBought = _IncomingTokenQty;

            } else {

                daiBought = _token2Token(

                    _IncomingTokenAddress,

                    DaiTokenAddress,

                    (_IncomingTokenQty).div(2)

                );

                usdcBought = _token2Token(

                    _IncomingTokenAddress,

                    UsdcTokenAddress,

                    (_IncomingTokenQty).div(2)

                );

            }

    

            crvTokensBought = _enter2Curve(

                _toWhomToIssue,

                daiBought,

                usdcBought,

                _curvePoolExchangeAddress,

                _minPoolTokens

            );

        }

        

    }

    

    function _enter2BtcCurve(

        address _toWhomToIssue,

        address _incomingBtcTokenAddress,

        address _curvePoolExchangeAddress,

        uint256 _incomingBtcTokenAmt,

        uint256 _minPoolTokens

    ) internal returns (uint256 crvTokensBought) {

        require(_incomingBtcTokenAddress == sBtcTokenAddress || 

                _incomingBtcTokenAddress == wbtcTokenAddress ||

                _incomingBtcTokenAddress == renBtcTokenAddress,

                "ERR: Incorrect BTC Token Address"

        );

        IERC20(_incomingBtcTokenAddress).approve(_curvePoolExchangeAddress, _incomingBtcTokenAmt);

        address btcCurvePoolTokenAddress = exchange2Token[_curvePoolExchangeAddress];

        uint256 iniTokenBal = IERC20(btcCurvePoolTokenAddress).balanceOf(address(this));

        // 0 = renBTC, 1 = wBTC, 2 = sBTC

        if(_incomingBtcTokenAddress == wbtcTokenAddress) {

            if(_curvePoolExchangeAddress == renBtcCurveExchangeAddress){

                IrenBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                    [0, _incomingBtcTokenAmt],

                    _minPoolTokens

                );

            }else {

                IsBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                    [0, _incomingBtcTokenAmt, 0],

                    _minPoolTokens

                );                

            }

        } else if(_incomingBtcTokenAddress == renBtcTokenAddress) {

            if(_curvePoolExchangeAddress == renBtcCurveExchangeAddress){

                IrenBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                    [_incomingBtcTokenAmt,0],

                    _minPoolTokens

                );

            }else {

                IsBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                    [_incomingBtcTokenAmt,0, 0],

                    _minPoolTokens

                );                

            }

        } 

        else {

            IsBtcCurveExchange(_curvePoolExchangeAddress).add_liquidity(

                [0, 0, _incomingBtcTokenAmt],

                0

            );

        }

        crvTokensBought = (IERC20(btcCurvePoolTokenAddress).balanceOf(address(this))).sub(iniTokenBal);

        require(crvTokensBought > _minPoolTokens, "Error less than min pool tokens");

        IERC20(btcCurvePoolTokenAddress).transfer(

            _toWhomToIssue,

            crvTokensBought

        );

    }



    function _enter2Curve(

        address _toWhomToIssue,

        uint256 daiBought,

        uint256 usdcBought,

        address _curvePoolExchangeAddress,

        uint256 _minPoolTokens

    ) internal returns (uint256 crvTokensBought) {

        // 0 = DAI, 1 = USDC, 2 = USDT, 3 = TUSD/sUSD

        address poolTokenAddress = exchange2Token[_curvePoolExchangeAddress];

        uint256 iniTokenBal = IERC20(poolTokenAddress).balanceOf(address(this));

        ICurveExchange(_curvePoolExchangeAddress).add_liquidity(

            [daiBought, usdcBought, 0, 0],

            _minPoolTokens

        );

        crvTokensBought = (IERC20(poolTokenAddress).balanceOf(address(this))).sub(iniTokenBal);

        require(crvTokensBought > _minPoolTokens, "Error less than min pool tokens");



        uint256 goodwillPortion = SafeMath.div(

            SafeMath.mul(crvTokensBought, goodwill),

            10000

        );



        require(

            IERC20(poolTokenAddress).transfer(

                dzgoodwillAddress,

                goodwillPortion

            ),

            "Error transferring goodwill"

        );



        require(

            IERC20(poolTokenAddress).transfer(

                _toWhomToIssue,

                SafeMath.sub(crvTokensBought, goodwillPortion)

            ),

            "Error transferring CRV"

        );

    }



    // Use 1Split 

    function _eth2Token(address _ToTokenContractAddress, uint256 ethReceived)

        internal

        returns (uint256 tokensBought)

    {

        IuniswapExchange ToUniSwapExchangeContractAddress = IuniswapExchange(

            UniSwapFactoryAddress.getExchange(_ToTokenContractAddress)

        );

        

        uint ERC20_againstETH = ToUniSwapExchangeContractAddress.getEthToTokenInputPrice(ethReceived);

        

        tokensBought = ToUniSwapExchangeContractAddress

            .ethToTokenSwapInput

            .value(ethReceived)(

                SafeMath.div(SafeMath.mul(ERC20_againstETH, 98), 100), 

                SafeMath.add(now, 300)

            );

        require(tokensBought > 0, "Error in swapping ETH");

    }



    function _token2Token(

        address _FromTokenContractAddress,

        address _ToTokenContractAddress,

        uint256 tokens2Trade

    ) internal returns (uint256 tokensBought) {

        IuniswapExchange FromUniSwapExchangeContractAddress = IuniswapExchange(

            UniSwapFactoryAddress.getExchange(_FromTokenContractAddress)

        );



        IERC20(_FromTokenContractAddress).approve(

            address(FromUniSwapExchangeContractAddress),

            tokens2Trade

        );



        tokensBought = FromUniSwapExchangeContractAddress.tokenToTokenSwapInput(

            tokens2Trade,

            1,

            1,

            SafeMath.add(now, 300),

            _ToTokenContractAddress

        );



        require(tokensBought > 0, "Error in swapping ERC");

    }



    function inCaseTokengetsStuck(IERC20 _TokenAddress) public onlyOwner {

        uint256 qty = _TokenAddress.balanceOf(address(this));

        _TokenAddress.transfer(_owner, qty);

    }



    function set_new_goodwill(uint16 _new_goodwill) public onlyOwner {

        require(

            _new_goodwill >= 0 && _new_goodwill < 10000,

            "GoodWill Value not allowed"

        );

        goodwill = _new_goodwill;

    }



    function set_new_dzgoodwillAddress(address _new_dzgoodwillAddress)

        public

        onlyOwner

    {

        dzgoodwillAddress = _new_dzgoodwillAddress;

    }



    // - to Pause the contract

    function toggleContractActive() public onlyOwner {

        stopped = !stopped;

    }



    // - to withdraw any ETH balance sitting in the contract

    function withdraw() public onlyOwner {

        _owner.transfer(address(this).balance);

    }



    // - to kill the contract

    function destruct() public onlyOwner {

        selfdestruct(_owner);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Harvest_ZapIn_V3.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract deposits ETH or ERC20 tokens into Harvest Vaults
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapInBaseV3.sol";

interface IWETH {
    function deposit() external payable;
}

// -- Harvest --
interface IHVault {
    function underlying() external view returns (address);

    function deposit(uint256 amountWei) external;
}

contract Harvest_ZapIn_V3 is ZapInBaseV3 {
    using SafeERC20 for IERC20;

    address private constant wethTokenAddress =
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    event zapIn(address sender, address pool, uint256 tokensRec);

    constructor(
        address _curveZapIn,
        address _uniZapIn,
        address _sushiZapIn,
        uint256 _goodwill,
        uint256 _affiliateSplit
    ) ZapBaseV2(_goodwill, _affiliateSplit) {
        // 0x exchange
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
        approvedTargets[_curveZapIn] = true;
        approvedTargets[_uniZapIn] = true;
        approvedTargets[_sushiZapIn] = true;
    }

    /**
        @notice This function adds liquidity to harvest vaults with ETH or ERC20 tokens
        @param fromToken The token used for entry (address(0) if ether)
        @param amountIn The amount of fromToken to invest
        @param vault Harvest vault address
        @param minVaultTokens The minimum acceptable quantity vault tokens to receive. Reverts otherwise
        @param intermediateToken Token to swap fromToken to before entering vault
        @param swapTarget Excecution target for the swap or zap
        @param swapData DEX or Zap data
        @param affiliate Affiliate address
        @param shouldSellEntireBalance True if amountIn is determined at execution time (i.e. contract is caller)
        @return tokensReceived Quantity of Vault tokens received
     */
    function ZapIn(
        address fromToken,
        uint256 amountIn,
        address vault,
        uint256 minVaultTokens,
        address intermediateToken,
        address swapTarget,
        bytes calldata swapData,
        address affiliate,
        bool shouldSellEntireBalance
    ) external payable stopInEmergency returns (uint256 tokensReceived) {
        // get incoming tokens
        uint256 toInvest =
            _pullTokens(
                fromToken,
                amountIn,
                affiliate,
                true,
                shouldSellEntireBalance
            );

        // get intermediate token
        uint256 intermediateAmt =
            _fillQuote(
                fromToken,
                intermediateToken,
                toInvest,
                swapTarget,
                swapData
            );

        // Deposit to Vault
        tokensReceived = _vaultDeposit(intermediateAmt, vault, minVaultTokens);
    }

    function _vaultDeposit(
        uint256 amount,
        address toVault,
        uint256 minTokensRec
    ) internal returns (uint256 tokensReceived) {
        address underlyingVaultToken = IHVault(toVault).underlying();

        _approveToken(underlyingVaultToken, toVault);

        uint256 iniYVaultBal = IERC20(toVault).balanceOf(address(this));
        IHVault(toVault).deposit(amount);
        tokensReceived =
            IERC20(toVault).balanceOf(address(this)) -
            iniYVaultBal;
        require(tokensReceived >= minTokensRec, "High Slippage");

        IERC20(toVault).safeTransfer(msg.sender, tokensReceived);
        emit zapIn(msg.sender, toVault, tokensReceived);
    }

    function _fillQuote(
        address _fromTokenAddress,
        address toToken,
        uint256 _amount,
        address _swapTarget,
        bytes memory swapData
    ) internal returns (uint256 amtBought) {
        if (_fromTokenAddress == toToken) {
            return _amount;
        }

        if (_fromTokenAddress == address(0) && toToken == wethTokenAddress) {
            IWETH(wethTokenAddress).deposit{ value: _amount }();
            return _amount;
        }

        uint256 valueToSend;
        if (_fromTokenAddress == address(0)) {
            valueToSend = _amount;
        } else {
            _approveToken(_fromTokenAddress, _swapTarget);
        }

        uint256 iniBal = _getBalance(toToken);
        require(approvedTargets[_swapTarget], "Target not Authorized");
        (bool success, ) = _swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens 1");
        uint256 finalBal = _getBalance(toToken);

        amtBought = finalBal - iniBal;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ibTokenInterface.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;



interface IibToken {

    function deposit(uint256 amount) external;



    function deposit() external payable;



    function withdraw(uint256 amount) external;



    function cToken() external view returns (address);



    function uToken() external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\IdleInterface.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;



interface IIdleToken {

    function token() external view returns (address);



    function mintIdleToken(

        uint256 _amount,

        bool _skipWholeRebalance,

        address _referral

    ) external returns (uint256 mintedTokens);



    function redeemIdleToken(uint256 _amount)

        external

        returns (uint256 redeemedTokens);



    function getGovTokens() external view returns (address[] memory);



    function tokenPrice() external view returns (uint256 price);

}



interface IIdleTokenHelper {

    function getRedeemPrice(address idleYieldToken)

        external

        view

        returns (uint256 redeemPrice);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Idle_Zap_V1.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract deposits and withdraws assets to/from Idle Finance 'Best Yield' and 'Risk Adjusted' opportunities
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapInBaseV3_1.sol";
import "../_base/ZapOutBaseV3_1.sol";
import "./IdleInterface.sol";

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}

contract Idle_Zap_V1 is ZapInBaseV3_1, ZapOutBaseV3_1 {
    using SafeERC20 for IERC20;

    address private constant wethTokenAddress =
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    IIdleTokenHelper private constant IdleTokenHelper =
        IIdleTokenHelper(0x04Ce60ed10F6D2CfF3AA015fc7b950D13c113be5);

    // COMP, IDLE, stkAAVE
    address[] govTokens = [
        0xc00e94Cb662C3520282E6f5717214004A7f26888,
        0x875773784Af8135eA0ef43b5a374AaD105c5D39e,
        0x4da27a545c0c5B758a6BA100e3a049001de870f5
    ];

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2_1(_goodwill, _affiliateSplit)
    {
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
    }

    event zapIn(address sender, address token, uint256 tokensRec);
    event zapOut(address sender, address token, uint256 tokensRec);

    /**
    @notice This function deposits assets into Idle finance with ETH or ERC20 tokens
    @param fromToken The token used for entry (address(0) if ether)
    @param amountIn The amount of fromToken to invest
    @param idleToken Address of the Idle token
    @param minIdleTokens The minimum acceptable quantity Idle tokens to receive. Reverts otherwise
    @param swapTarget Excecution target for the swap or zap
    @param swapData DEX or Zap data. Must swap to cToken underlying address
    @param affiliate Affiliate address
    @return idleTokensRec Quantity of cTokens received
     */
    function ZapIn(
        address fromToken,
        uint256 amountIn,
        address idleToken,
        uint256 minIdleTokens,
        address swapTarget,
        bytes calldata swapData,
        address affiliate
    ) external payable stopInEmergency returns (uint256 idleTokensRec) {
        uint256 toInvest = _pullTokens(fromToken, amountIn, affiliate, true);

        address toToken = getUnderlyingToken(idleToken);

        uint256 tokensBought =
            _fillQuote(fromToken, toToken, toInvest, swapTarget, swapData);

        (idleTokensRec) = enterIdle(idleToken, toToken, tokensBought);
        require(idleTokensRec > minIdleTokens, "High Slippage");

        IERC20(idleToken).safeTransfer(msg.sender, idleTokensRec);

        emit zapIn(msg.sender, idleToken, idleTokensRec);
    }

    function enterIdle(
        address idleToken,
        address underlyingToken,
        uint256 underlyingAmount
    ) internal returns (uint256 idleTokensRec) {
        uint256 initialBalance = _getBalance(idleToken);

        _approveToken(underlyingToken, idleToken, underlyingAmount);
        IIdleToken(idleToken).mintIdleToken(
            underlyingAmount,
            true,
            ZapperAdmin
        );

        idleTokensRec = _getBalance(idleToken) - initialBalance;
    }

    /**
    @notice This function withdraws assets from Idle finance, receiving tokens or ETH
    @param fromToken The Idle token being withdrawn
    @param amountIn The quantity of fromToken to withdraw
    @param toToken Address of the token to receive (0 address if ETH)
    @param minToTokens The minimum acceptable quantity tokens to receive. Reverts otherwise
    @param swapTarget Excecution target for the swap or zap
    @param swapData DEX or Zap data
    @param affiliate Affiliate address
    @return tokensRec Quantity of aTokens received
     */
    function ZapOut(
        address fromToken,
        uint256 amountIn,
        address toToken,
        uint256 minToTokens,
        address swapTarget,
        bytes calldata swapData,
        address affiliate
    ) public stopInEmergency returns (uint256 tokensRec) {
        amountIn = _pullTokens(fromToken, amountIn);

        (uint256 underlyingRec, uint256[] memory govTokensRec) =
            exitIdle(fromToken, amountIn);

        address underlyingToken = getUnderlyingToken(fromToken);

        tokensRec = _fillQuote(
            underlyingToken,
            toToken,
            underlyingRec,
            swapTarget,
            swapData
        );

        require(tokensRec >= minToTokens, "High Slippage");

        uint256 totalGoodwillPortion;

        if (toToken == address(0)) {
            totalGoodwillPortion = _subtractGoodwill(
                ETHAddress,
                tokensRec,
                affiliate,
                true
            );

            payable(msg.sender).transfer(tokensRec - totalGoodwillPortion);
        } else {
            totalGoodwillPortion = _subtractGoodwill(
                toToken,
                tokensRec,
                affiliate,
                true
            );

            IERC20(toToken).safeTransfer(
                msg.sender,
                tokensRec - totalGoodwillPortion
            );
        }

        for (uint256 i = 0; i < govTokens.length; i++) {
            if (govTokensRec[i] > 0) {
                IERC20(govTokens[i]).safeTransfer(msg.sender, govTokensRec[i]);
            }
        }

        tokensRec = tokensRec - totalGoodwillPortion;

        emit zapOut(msg.sender, toToken, tokensRec);
    }

    function exitIdle(address idleToken, uint256 idleTokenAmount)
        internal
        returns (uint256, uint256[] memory)
    {
        uint256[] memory initialGovBalance = new uint256[](govTokens.length);
        for (uint256 i = 0; i < govTokens.length; i++) {
            initialGovBalance[i] = _getBalance(govTokens[i]);
        }

        uint256 underlyingRec =
            IIdleToken(idleToken).redeemIdleToken(idleTokenAmount);

        uint256[] memory govTokensRec = new uint256[](govTokens.length);
        for (uint256 i = 0; i < govTokens.length; i++) {
            govTokensRec[i] = _getBalance(govTokens[i]) - initialGovBalance[i];
        }
        return (underlyingRec, govTokensRec);
    }

    function _fillQuote(
        address fromToken,
        address toToken,
        uint256 _amount,
        address swapTarget,
        bytes memory swapData
    ) internal returns (uint256 amountBought) {
        if (fromToken == toToken) {
            return _amount;
        }

        if (fromToken == address(0) && toToken == wethTokenAddress) {
            IWETH(wethTokenAddress).deposit{ value: _amount }();
            return _amount;
        }

        if (fromToken == wethTokenAddress && toToken == address(0)) {
            IWETH(wethTokenAddress).withdraw(_amount);
            return _amount;
        }

        uint256 valueToSend;
        if (fromToken == address(0)) {
            valueToSend = _amount;
        } else {
            _approveToken(fromToken, swapTarget);
        }

        uint256 initialBalance = _getBalance(toToken);

        require(approvedTargets[swapTarget], "Target not Authorized");
        (bool success, ) = swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens");

        amountBought = _getBalance(toToken) - initialBalance;

        require(amountBought > 0, "Swapped To Invalid Intermediate");
    }

    function getUnderlyingToken(address idleToken)
        public
        view
        returns (address)
    {
        return IIdleToken(idleToken).token();
    }

    function removeLiquidityReturn(address idleToken, uint256 idleTokenAmount)
        external
        view
        returns (uint256 underlyingRec)
    {
        return
            (IdleTokenHelper.getRedeemPrice(idleToken) * idleTokenAmount) /
            10**18;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\IERC1155.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/introspection/IERC165.sol";



/**

 * @dev Required interface of an ERC1155 compliant contract, as defined in the

 * https://eips.ethereum.org/EIPS/eip-1155[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155 is IERC165 {

    /**

     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.

     */

    event TransferSingle(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256 id,

        uint256 value

    );



    /**

     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all

     * transfers.

     */

    event TransferBatch(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256[] ids,

        uint256[] values

    );



    /**

     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to

     * `approved`.

     */

    event ApprovalForAll(

        address indexed account,

        address indexed operator,

        bool approved

    );



    /**

     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.

     *

     * If an {URI} event was emitted for `id`, the standard

     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value

     * returned by {IERC1155MetadataURI-uri}.

     */

    event URI(string value, uint256 indexed id);



    /**

     * @dev Returns the amount of tokens of token type `id` owned by `account`.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id)

        external

        view

        returns (uint256);



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)

        external

        view

        returns (uint256[] memory);



    /**

     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,

     *

     * Emits an {ApprovalForAll} event.

     *

     * Requirements:

     *

     * - `operator` cannot be the caller.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.

     *

     * See {setApprovalForAll}.

     */

    function isApprovedForAll(address account, address operator)

        external

        view

        returns (bool);



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes calldata data

    ) external;



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\IERC1155MetadataURI.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC1155.sol";



/**

 * @dev Interface of the optional ERC1155MetadataExtension interface, as defined

 * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155MetadataURI is IERC1155 {

    /**

     * @dev Returns the URI for token type `id`.

     *

     * If the `\{id\}` substring is present in the URI, it must be replaced by

     * clients with the actual token type ID.

     */

    function uri(uint256 id) external view returns (string memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\IERC1155Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/introspection/IERC165.sol";



/**

 * @dev _Available since v3.1._

 */

interface IERC1155Receiver is IERC165 {

    /**

        @dev Handles the receipt of a single ERC1155 token type. This function is

        called at the end of a `safeTransferFrom` after the balance has been updated.

        To accept the transfer, this must return

        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

        (i.e. 0xf23a6e61, or its own function selector).

        @param operator The address which initiated the transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param id The ID of the token being transferred

        @param value The amount of tokens being transferred

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed

    */

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    ) external returns (bytes4);



    /**

        @dev Handles the receipt of a multiple ERC1155 token types. This function

        is called at the end of a `safeBatchTransferFrom` after the balances have

        been updated. To accept the transfer(s), this must return

        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

        (i.e. 0xbc197c81, or its own function selector).

        @param operator The address which initiated the batch transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param ids An array containing ids of each token being transferred (order and length must match values array)

        @param values An array containing amounts of each token being transferred (order and length must match ids array)

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed

    */

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    ) external returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount)

        external

        returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender)

        external

        view

        returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\IERC20Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC20.sol";



/**

 * @dev Interface for the optional metadata functions from the ERC20 standard.

 *

 * _Available since v4.1._

 */

interface IERC20Metadata is IERC20 {

    /**

     * @dev Returns the name of the token.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the symbol of the token.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the decimals places of the token.

     */

    function decimals() external view returns (uint8);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/Context.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(

        address indexed previousOwner,

        address indexed newOwner

    );



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(

            newOwner != address(0),

            "Ownable: new owner is the zero address"

        );

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Pickle_ZapOut_V1.sol
File type: .sol
/**
 *Submitted for verification at Etherscan.io on 2021-04-21
*/

// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract removes liquidity from Pickle Jars to ETH or ERC20 Tokens.
// SPDX-License-Identifier: GPLv2

// File: oz/GSN/Context.sol

pragma solidity ^0.5.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor() internal {}

    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: oz/ownership/Ownable.sol

pragma solidity ^0.5.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: oz/token/ERC20/IERC20.sol

pragma solidity ^0.5.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */
interface IERC20 {
    function decimals() external view returns (uint8);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

// File: oz/math/SafeMath.sol

pragma solidity ^0.5.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

// File: oz/utils/Address.sol

pragma solidity ^0.5.5;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;

        bytes32 accountHash =
            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            codehash := extcodehash(account)
        }
        return (codehash != accountHash && codehash != 0x0);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     *
     * _Available since v2.4.0._
     */
    function toPayable(address account)
        internal
        pure
        returns (address payable)
    {
        return address(uint160(account));
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     *
     * _Available since v2.4.0._
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            "Address: insufficient balance"
        );

        // solhint-disable-next-line avoid-call-value
        (bool success, ) = recipient.call.value(amount)("");
        require(
            success,
            "Address: unable to send value, recipient may have reverted"
        );
    }
}

// File: oz/token/ERC20/SafeERC20.sol

pragma solidity ^0.5.0;

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance =
            token.allowance(address(this), spender).add(value);
        callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance =
            token.allowance(address(this), spender).sub(
                value,
                "SafeERC20: decreased allowance below zero"
            );
        callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {
            // Return data is optional
            // solhint-disable-next-line max-line-length
            require(
                abi.decode(returndata, (bool)),
                "SafeERC20: ERC20 operation did not succeed"
            );
        }
    }
}

// File: contracts/_base/ZapBaseV1.sol

pragma solidity ^0.5.7;

contract ZapBaseV1 is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;
    bool public stopped = false;

    // if true, goodwill is not deducted
    mapping(address => bool) public feeWhitelist;

    uint256 public goodwill;
    // % share of goodwill (0-100 %)
    uint256 affiliateSplit;
    // restrict affiliates
    mapping(address => bool) public affiliates;
    // affiliate => token => amount
    mapping(address => mapping(address => uint256)) public affiliateBalance;
    // token => amount
    mapping(address => uint256) public totalAffiliateBalance;

    address internal constant ETHAddress =
        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    constructor(uint256 _goodwill, uint256 _affiliateSplit) public {
        goodwill = _goodwill;
        affiliateSplit = _affiliateSplit;
    }

    // circuit breaker modifiers
    modifier stopInEmergency {
        if (stopped) {
            revert("Temporarily Paused");
        } else {
            _;
        }
    }

    function _getBalance(address token)
        internal
        view
        returns (uint256 balance)
    {
        if (token == address(0)) {
            balance = address(this).balance;
        } else {
            balance = IERC20(token).balanceOf(address(this));
        }
    }

    function _approveToken(address token, address spender) internal {
        IERC20 _token = IERC20(token);
        if (_token.allowance(address(this), spender) > 0) return;
        else {
            _token.safeApprove(spender, uint256(-1));
        }
    }

    function _approveToken(
        address token,
        address spender,
        uint256 amount
    ) internal {
        IERC20 _token = IERC20(token);
        _token.safeApprove(spender, 0);
        _token.safeApprove(spender, amount);
    }

    // - to Pause the contract
    function toggleContractActive() public onlyOwner {
        stopped = !stopped;
    }

    function set_feeWhitelist(address zapAddress, bool status)
        external
        onlyOwner
    {
        feeWhitelist[zapAddress] = status;
    }

    function set_new_goodwill(uint256 _new_goodwill) public onlyOwner {
        require(
            _new_goodwill >= 0 && _new_goodwill <= 100,
            "GoodWill Value not allowed"
        );
        goodwill = _new_goodwill;
    }

    function set_new_affiliateSplit(uint256 _new_affiliateSplit)
        external
        onlyOwner
    {
        require(
            _new_affiliateSplit <= 100,
            "Affiliate Split Value not allowed"
        );
        affiliateSplit = _new_affiliateSplit;
    }

    function set_affiliate(address _affiliate, bool _status)
        external
        onlyOwner
    {
        affiliates[_affiliate] = _status;
    }

    ///@notice Withdraw goodwill share, retaining affilliate share
    function withdrawTokens(address[] calldata tokens) external onlyOwner {
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 qty;

            if (tokens[i] == ETHAddress) {
                qty = address(this).balance.sub(
                    totalAffiliateBalance[tokens[i]]
                );
                Address.sendValue(Address.toPayable(owner()), qty);
            } else {
                qty = IERC20(tokens[i]).balanceOf(address(this)).sub(
                    totalAffiliateBalance[tokens[i]]
                );
                IERC20(tokens[i]).safeTransfer(owner(), qty);
            }
        }
    }

    ///@notice Withdraw affilliate share, retaining goodwill share
    function affilliateWithdraw(address[] calldata tokens) external {
        uint256 tokenBal;
        for (uint256 i = 0; i < tokens.length; i++) {
            tokenBal = affiliateBalance[msg.sender][tokens[i]];
            affiliateBalance[msg.sender][tokens[i]] = 0;
            totalAffiliateBalance[tokens[i]] = totalAffiliateBalance[tokens[i]]
                .sub(tokenBal);

            if (tokens[i] == ETHAddress) {
                Address.sendValue(msg.sender, tokenBal);
            } else {
                IERC20(tokens[i]).safeTransfer(msg.sender, tokenBal);
            }
        }
    }

    function() external payable {
        require(msg.sender != tx.origin, "Do not send ETH directly");
    }
}

// File: contracts/_base/ZapOutBaseV1.sol

pragma solidity ^0.5.7;

contract ZapOutBaseV1 is ZapBaseV1 {
    function _subtractGoodwill(
        address token,
        uint256 amount,
        address affiliate,
        bool enableGoodwill
    ) internal returns (uint256 totalGoodwillPortion) {
        bool whitelisted = feeWhitelist[msg.sender];
        if (enableGoodwill && !whitelisted && goodwill > 0) {
            totalGoodwillPortion = SafeMath.div(
                SafeMath.mul(amount, goodwill),
                10000
            );

            if (affiliates[affiliate]) {
                if (token == address(0)) {
                    token = ETHAddress;
                }

                uint256 affiliatePortion =
                    totalGoodwillPortion.mul(affiliateSplit).div(100);
                affiliateBalance[affiliate][token] = affiliateBalance[
                    affiliate
                ][token]
                    .add(affiliatePortion);
                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(
                    affiliatePortion
                );
            }
        }
    }
}

// File: contracts/Pickle/Pickle_ZapOut_V1.sol

pragma solidity ^0.5.7;

interface IPickleJar {
    function token() external view returns (address);

    function withdraw(uint256 _shares) external;

    function getRatio() external view returns (uint256);
}

contract Pickle_ZapOut_V1 is ZapOutBaseV1 {
    // calldata only accepted for approved zap contracts
    mapping(address => bool) public approvedTargets;

    event Zapout(
        address _toWhomToIssue,
        address _fromPJarAddress,
        address _toTokenAddress,
        uint256 _tokensRecieved
    );

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        public
        ZapBaseV1(_goodwill, _affiliateSplit)
    {}

    /**
    @notice Zap out in to a single token or ETH
    @param fromJar Pickle Jar from which to remove liquidity
    @param amountIn Quantity of Jar tokens to remove
    @param toToken Address of desired token
    @param minToTokens Minimum quantity of tokens to receive, reverts otherwise
    @param swapTarget Execution targets for swap or Zap
    @param swapData DEX or Zap data
    @param affiliate Affiliate address
    @return Quantity of tokens or ETH received
    */
    function ZapOut(
        address fromJar,
        uint256 amountIn,
        address toToken,
        uint256 minToTokens,
        address swapTarget,
        bytes memory swapData,
        address affiliate
    ) public stopInEmergency returns (uint256 tokensReceived) {
        require(
            approvedTargets[swapTarget] || swapTarget == address(0),
            "Target not Authorized"
        );

        IERC20(fromJar).safeTransferFrom(msg.sender, address(this), amountIn);

        // withdraw underlying token from jar
        address underlyingToken = IPickleJar(fromJar).token();
        uint256 underlyingTokenReceived =
            _jarWithdraw(fromJar, amountIn, underlyingToken);

        // swap to toToken
        uint256 toTokenAmt =
            _fillQuote(
                underlyingToken,
                toToken,
                underlyingTokenReceived,
                swapTarget,
                swapData
            );
        require(toTokenAmt >= minToTokens, "Err: High Slippage");

        uint256 totalGoodwillPortion =
            _subtractGoodwill(toToken, toTokenAmt, affiliate, true);
        tokensReceived = toTokenAmt.sub(totalGoodwillPortion);

        // send toTokens
        if (toToken == address(0)) {
            Address.sendValue(msg.sender, tokensReceived);
        } else {
            IERC20(toToken).safeTransfer(msg.sender, tokensReceived);
        }
    }

    function _jarWithdraw(
        address fromJar,
        uint256 amount,
        address underlyingToken
    ) internal returns (uint256 underlyingReceived) {
        uint256 iniUnderlyingBal = _getBalance(underlyingToken);

        IPickleJar(fromJar).withdraw(amount);

        underlyingReceived = _getBalance(underlyingToken).sub(iniUnderlyingBal);
    }

    function _fillQuote(
        address _fromTokenAddress,
        address toToken,
        uint256 _amount,
        address _swapTarget,
        bytes memory swapCallData
    ) internal returns (uint256 amtBought) {
        uint256 valueToSend;

        if (_fromTokenAddress == toToken) {
            return _amount;
        }

        if (_fromTokenAddress == address(0)) {
            valueToSend = _amount;
        } else {
            _approveToken(_fromTokenAddress, _swapTarget, _amount);
        }

        uint256 iniBal = _getBalance(toToken);

        (bool success, ) = _swapTarget.call.value(valueToSend)(swapCallData);
        require(success, "Error Swapping Tokens 1");

        uint256 finalBal = _getBalance(toToken);

        require(finalBal > 0, "ERR: Swapped to wrong token");

        amtBought = finalBal.sub(iniBal);
    }

    /**
    @notice Utility function to determine the quantity of underlying tokens removed from jar
    @param fromJar Pickle Jar from which to remove liquidity
    @param liquidity Quantity of Jar tokens to remove
    @return Quantity of underlying LP or token removed
    */
    function removeLiquidityReturn(IPickleJar fromJar, uint256 liquidity)
        external
        view
        returns (uint256)
    {
        return (liquidity.mul(fromJar.getRatio())).div(1e18);
    }

    function setApprovedTargets(
        address[] calldata targets,
        bool[] calldata isApproved
    ) external onlyOwner {
        require(targets.length == isApproved.length, "Invalid Input length");

        for (uint256 i = 0; i < targets.length; i++) {
            approvedTargets[targets[i]] = isApproved[i];
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC20.sol";

import "../../../utils/Address.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(token.transfer.selector, to, value)

        );

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)

        );

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(token.approve.selector, spender, value)

        );

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender) + value;

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(

                token.approve.selector,

                spender,

                newAllowance

            )

        );

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        unchecked {

            uint256 oldAllowance = token.allowance(address(this), spender);

            require(

                oldAllowance >= value,

                "SafeERC20: decreased allowance below zero"

            );

            uint256 newAllowance = oldAllowance - value;

            _callOptionalReturn(

                token,

                abi.encodeWithSelector(

                    token.approve.selector,

                    spender,

                    newAllowance

                )

            );

        }

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata =

            address(token).functionCall(

                data,

                "SafeERC20: low-level call failed"

            );

        if (returndata.length > 0) {

            // Return data is optional

            // solhint-disable-next-line max-line-length

            require(

                abi.decode(returndata, (bool)),

                "SafeERC20: ERC20 operation did not succeed"

            );

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\SafeMath.sol
File type: .sol
pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\SignatureVerifier.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper
// Copyright (c) 2018 Tasuku Nakamura

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract checks if a message has been signed by a verified signer via personal_sign.
// SPDX-License-Identifier: GPLv2

pragma solidity ^0.8.0;

contract SignatureVerifier {
    address public _signer;

    constructor(address signer) {
        _signer = signer;
    }

    function verify(
        address account,
        uint256 id,
        bytes memory signature
    ) internal view returns (bool) {
        bytes32 messageHash = getMessageHash(account, id);
        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);

        return recoverSigner(ethSignedMessageHash, signature) == _signer;
    }

    function getMessageHash(address account, uint256 id)
        public
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(account, id));
    }

    function getEthSignedMessageHash(bytes32 messageHash)
        internal
        pure
        returns (bytes32)
    {
        return
            keccak256(
                abi.encodePacked(
                    "\x19Ethereum Signed Message:\n32",
                    messageHash
                )
            );
    }

    function recoverSigner(
        bytes32 _ethSignedMessageHash,
        bytes memory _signature
    ) internal pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);

        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    function splitSignature(bytes memory signature)
        internal
        pure
        returns (
            bytes32 r,
            bytes32 s,
            uint8 v
        )
    {
        require(signature.length == 65, "invalid signature length");

        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\SignatureVerifier_V2.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper
// Copyright (c) 2018 Tasuku Nakamura

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract checks if a message has been signed by a verified signer via personal_sign.
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;

contract SignatureVerifier_V2 {
    address public signer;

    constructor(address _signer) {
        signer = _signer;
    }

    function verify(bytes32 messageHash, bytes memory signature)
        internal
        view
        returns (bool)
    {
        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);

        return recoverSigner(ethSignedMessageHash, signature) == signer;
    }

    function getEthSignedMessageHash(bytes32 messageHash)
        internal
        pure
        returns (bytes32)
    {
        return
            keccak256(
                abi.encodePacked(
                    "\x19Ethereum Signed Message:\n32",
                    messageHash
                )
            );
    }

    function recoverSigner(
        bytes32 _ethSignedMessageHash,
        bytes memory _signature
    ) internal pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);

        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    function splitSignature(bytes memory signature)
        internal
        pure
        returns (
            bytes32 r,
            bytes32 s,
            uint8 v
        )
    {
        require(signature.length == 65, "invalid signature length");

        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Strings.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev String operations.

 */

library Strings {

    bytes16 private constant alphabet = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length)

        internal

        pure

        returns (string memory)

    {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = alphabet[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Sushiswap_ZapIn_V4.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract adds liquidity to Sushiswap pools using ETH or any ERC20 Token.
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapInBaseV3.sol";

// import "@uniswap/lib/contracts/libraries/Babylonian.sol";
library Babylonian {
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
        // else z = 0
    }
}

interface IWETH {
    function deposit() external payable;
}

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address);
}

interface IUniswapV2Router02 {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}

interface IUniswapV2Pair {
    function token0() external pure returns (address);

    function token1() external pure returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        );
}

contract Sushiswap_ZapIn_V4 is ZapInBaseV3 {
    using SafeERC20 for IERC20;

    IUniswapV2Factory private constant sushiSwapFactoryAddress =
        IUniswapV2Factory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);

    IUniswapV2Router02 private constant sushiSwapRouter =
        IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);

    address private constant wethTokenAddress =
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    uint256 private constant deadline =
        0xf000000000000000000000000000000000000000000000000000000000000000;

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2(_goodwill, _affiliateSplit)
    {
        // 0x exchange
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
    }

    event zapIn(address sender, address pool, uint256 tokensRec);

    /**
    @notice Add liquidity to Sushiswap pools with ETH/ERC20 Tokens
    @param _FromTokenContractAddress The ERC20 token used (address(0x00) if ether)
    @param _pairAddress The Sushiswap pair address
    @param _amount The amount of fromToken to invest
    @param _minPoolTokens Minimum quantity of pool tokens to receive. Reverts otherwise
    @param _swapTarget Excecution target for the first swap
    @param swapData DEX quote data
    @param affiliate Affiliate address
    @param transferResidual Set false to save gas by donating the residual remaining after a Zap
    @param shouldSellEntireBalance If True transfers entrire allowable amount from another contract
    @return Amount of LP bought
     */
    function ZapIn(
        address _FromTokenContractAddress,
        address _pairAddress,
        uint256 _amount,
        uint256 _minPoolTokens,
        address _swapTarget,
        bytes calldata swapData,
        address affiliate,
        bool transferResidual,
        bool shouldSellEntireBalance
    ) external payable stopInEmergency returns (uint256) {
        uint256 toInvest =
            _pullTokens(
                _FromTokenContractAddress,
                _amount,
                affiliate,
                true,
                shouldSellEntireBalance
            );

        uint256 LPBought =
            _performZapIn(
                _FromTokenContractAddress,
                _pairAddress,
                toInvest,
                _swapTarget,
                swapData,
                transferResidual
            );
        require(LPBought >= _minPoolTokens, "High Slippage");

        emit zapIn(msg.sender, _pairAddress, LPBought);

        IERC20(_pairAddress).safeTransfer(msg.sender, LPBought);
        return LPBought;
    }

    function _getPairTokens(address _pairAddress)
        internal
        pure
        returns (address token0, address token1)
    {
        IUniswapV2Pair uniPair = IUniswapV2Pair(_pairAddress);
        token0 = uniPair.token0();
        token1 = uniPair.token1();
    }

    function _performZapIn(
        address _FromTokenContractAddress,
        address _pairAddress,
        uint256 _amount,
        address _swapTarget,
        bytes memory swapData,
        bool transferResidual
    ) internal returns (uint256) {
        uint256 intermediateAmt;
        address intermediateToken;
        (address _ToUniswapToken0, address _ToUniswapToken1) =
            _getPairTokens(_pairAddress);

        if (
            _FromTokenContractAddress != _ToUniswapToken0 &&
            _FromTokenContractAddress != _ToUniswapToken1
        ) {
            // swap to intermediate
            (intermediateAmt, intermediateToken) = _fillQuote(
                _FromTokenContractAddress,
                _pairAddress,
                _amount,
                _swapTarget,
                swapData
            );
        } else {
            intermediateToken = _FromTokenContractAddress;
            intermediateAmt = _amount;
        }

        // divide intermediate into appropriate amount to add liquidity
        (uint256 token0Bought, uint256 token1Bought) =
            _swapIntermediate(
                intermediateToken,
                _ToUniswapToken0,
                _ToUniswapToken1,
                intermediateAmt
            );

        return
            _uniDeposit(
                _ToUniswapToken0,
                _ToUniswapToken1,
                token0Bought,
                token1Bought,
                transferResidual
            );
    }

    function _uniDeposit(
        address _ToUnipoolToken0,
        address _ToUnipoolToken1,
        uint256 token0Bought,
        uint256 token1Bought,
        bool transferResidual
    ) internal returns (uint256) {
        _approveToken(_ToUnipoolToken0, address(sushiSwapRouter), token0Bought);
        _approveToken(_ToUnipoolToken1, address(sushiSwapRouter), token1Bought);

        (uint256 amountA, uint256 amountB, uint256 LP) =
            sushiSwapRouter.addLiquidity(
                _ToUnipoolToken0,
                _ToUnipoolToken1,
                token0Bought,
                token1Bought,
                1,
                1,
                address(this),
                deadline
            );

        if (transferResidual) {
            //Returning Residue in token0, if any.
            if (token0Bought - amountA > 0) {
                IERC20(_ToUnipoolToken0).safeTransfer(
                    msg.sender,
                    token0Bought - amountA
                );
            }

            //Returning Residue in token1, if any
            if (token1Bought - amountB > 0) {
                IERC20(_ToUnipoolToken1).safeTransfer(
                    msg.sender,
                    token1Bought - amountB
                );
            }
        }

        return LP;
    }

    function _fillQuote(
        address _fromTokenAddress,
        address _pairAddress,
        uint256 _amount,
        address _swapTarget,
        bytes memory swapData
    ) internal returns (uint256 amountBought, address intermediateToken) {
        if (_swapTarget == wethTokenAddress) {
            IWETH(wethTokenAddress).deposit{ value: _amount }();
            return (_amount, wethTokenAddress);
        }

        uint256 valueToSend;
        if (_fromTokenAddress == address(0)) {
            valueToSend = _amount;
        } else {
            _approveToken(_fromTokenAddress, _swapTarget, _amount);
        }

        (address _token0, address _token1) = _getPairTokens(_pairAddress);
        IERC20 token0 = IERC20(_token0);
        IERC20 token1 = IERC20(_token1);
        uint256 initialBalance0 = token0.balanceOf(address(this));
        uint256 initialBalance1 = token1.balanceOf(address(this));

        require(approvedTargets[_swapTarget], "Target not Authorized");
        (bool success, ) = _swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens 1");

        uint256 finalBalance0 =
            token0.balanceOf(address(this)) - initialBalance0;
        uint256 finalBalance1 =
            token1.balanceOf(address(this)) - initialBalance1;

        if (finalBalance0 > finalBalance1) {
            amountBought = finalBalance0;
            intermediateToken = _token0;
        } else {
            amountBought = finalBalance1;
            intermediateToken = _token1;
        }

        require(amountBought > 0, "Swapped to Invalid Intermediate");
    }

    function _swapIntermediate(
        address _toContractAddress,
        address _ToUnipoolToken0,
        address _ToUnipoolToken1,
        uint256 _amount
    ) internal returns (uint256 token0Bought, uint256 token1Bought) {
        IUniswapV2Pair pair =
            IUniswapV2Pair(
                sushiSwapFactoryAddress.getPair(
                    _ToUnipoolToken0,
                    _ToUnipoolToken1
                )
            );
        (uint256 res0, uint256 res1, ) = pair.getReserves();
        if (_toContractAddress == _ToUnipoolToken0) {
            uint256 amountToSwap = calculateSwapInAmount(res0, _amount);
            //if no reserve or a new pair is created
            if (amountToSwap <= 0) amountToSwap = _amount / 2;
            token1Bought = _token2Token(
                _toContractAddress,
                _ToUnipoolToken1,
                amountToSwap
            );
            token0Bought = _amount - amountToSwap;
        } else {
            uint256 amountToSwap = calculateSwapInAmount(res1, _amount);
            //if no reserve or a new pair is created
            if (amountToSwap <= 0) amountToSwap = _amount / 2;
            token0Bought = _token2Token(
                _toContractAddress,
                _ToUnipoolToken0,
                amountToSwap
            );
            token1Bought = _amount - amountToSwap;
        }
    }

    function calculateSwapInAmount(uint256 reserveIn, uint256 userIn)
        internal
        pure
        returns (uint256)
    {
        return
            (Babylonian.sqrt(
                reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))
            ) - (reserveIn * 1997)) / 1994;
    }

    /**
    @notice This function is used to swap ERC20 <> ERC20
    @param _FromTokenContractAddress The token address to swap from.
    @param _ToTokenContractAddress The token address to swap to. 
    @param tokens2Trade The amount of tokens to swap
    @return tokenBought The quantity of tokens bought
    */
    function _token2Token(
        address _FromTokenContractAddress,
        address _ToTokenContractAddress,
        uint256 tokens2Trade
    ) internal returns (uint256 tokenBought) {
        if (_FromTokenContractAddress == _ToTokenContractAddress) {
            return tokens2Trade;
        }

        _approveToken(
            _FromTokenContractAddress,
            address(sushiSwapRouter),
            tokens2Trade
        );

        address pair =
            sushiSwapFactoryAddress.getPair(
                _FromTokenContractAddress,
                _ToTokenContractAddress
            );
        require(pair != address(0), "No Swap Available");
        address[] memory path = new address[](2);
        path[0] = _FromTokenContractAddress;
        path[1] = _ToTokenContractAddress;

        tokenBought = sushiSwapRouter.swapExactTokensForTokens(
            tokens2Trade,
            1,
            path,
            address(this),
            deadline
        )[path.length - 1];

        require(tokenBought > 0, "Error Swapping Tokens 2");
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Sushiswap_ZapOut_General_V3.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License

///@author Zapper
///@notice this contract implements one click removal of liquidity from Sushiswap pools, receiving ETH, ERC20 or both.
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapOutBaseV3.sol";

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);
}

interface IUniswapV2Router02 {
    function WETH() external pure returns (address);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);
}

interface IUniswapV2Pair {
    function token0() external pure returns (address);

    function token1() external pure returns (address);

    function balanceOf(address user) external view returns (uint256);

    function totalSupply() external view returns (uint256);

    function getReserves()
        external
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        );

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

interface IWETH {
    function withdraw(uint256 wad) external;
}

contract Sushiswap_ZapOut_General_V3 is ZapOutBaseV3 {
    using SafeERC20 for IERC20;

    uint256 private constant deadline =
        0xf000000000000000000000000000000000000000000000000000000000000000;

    IUniswapV2Router02 private constant sushiswapRouter =
        IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);
    IUniswapV2Factory private constant sushiswapFactory =
        IUniswapV2Factory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);

    address private constant wethTokenAddress =
        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2(_goodwill, _affiliateSplit)
    {
        // 0x exchange
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
    }

    event zapOut(
        address sender,
        address pool,
        address token,
        uint256 tokensRec
    );

    /**
        @notice Zap out in both tokens
        @param fromPoolAddress Pool from which to remove liquidity
        @param incomingLP Quantity of LP to remove from pool
        @param affiliate Affiliate address
        @return amountA Quantity of tokenA received after zapout
        @return amountB Quantity of tokenB received after zapout
    */
    function ZapOut2PairToken(
        address fromPoolAddress,
        uint256 incomingLP,
        address affiliate
    ) public stopInEmergency returns (uint256 amountA, uint256 amountB) {
        IUniswapV2Pair pair = IUniswapV2Pair(fromPoolAddress);

        require(address(pair) != address(0), "Pool Cannot be Zero Address");

        // get reserves
        address token0 = pair.token0();
        address token1 = pair.token1();

        IERC20(fromPoolAddress).safeTransferFrom(
            msg.sender,
            address(this),
            incomingLP
        );

        _approveToken(fromPoolAddress, address(sushiswapRouter), incomingLP);

        if (token0 == wethTokenAddress || token1 == wethTokenAddress) {
            address _token = token0 == wethTokenAddress ? token1 : token0;
            (amountA, amountB) = sushiswapRouter.removeLiquidityETH(
                _token,
                incomingLP,
                1,
                1,
                address(this),
                deadline
            );

            // subtract goodwill
            uint256 tokenGoodwill =
                _subtractGoodwill(_token, amountA, affiliate, true);
            uint256 ethGoodwill =
                _subtractGoodwill(ETHAddress, amountB, affiliate, true);

            // send tokens
            IERC20(_token).safeTransfer(msg.sender, amountA - tokenGoodwill);
            Address.sendValue(payable(msg.sender), amountB - ethGoodwill);
        } else {
            (amountA, amountB) = sushiswapRouter.removeLiquidity(
                token0,
                token1,
                incomingLP,
                1,
                1,
                address(this),
                deadline
            );

            // subtract goodwill
            uint256 tokenAGoodwill =
                _subtractGoodwill(token0, amountA, affiliate, true);
            uint256 tokenBGoodwill =
                _subtractGoodwill(token1, amountB, affiliate, true);

            // send tokens
            IERC20(token0).safeTransfer(msg.sender, amountA - tokenAGoodwill);
            IERC20(token1).safeTransfer(msg.sender, amountB - tokenBGoodwill);
        }
        emit zapOut(msg.sender, fromPoolAddress, token0, amountA);
        emit zapOut(msg.sender, fromPoolAddress, token1, amountB);
    }

    /**
    @notice Zap out in a single token
    @param toTokenAddress Address of desired token
    @param fromPoolAddress Pool from which to remove liquidity
    @param incomingLP Quantity of LP to remove from pool
    @param minTokensRec Minimum quantity of tokens to receive
    @param swapTargets Execution targets for swaps
    @param swapData DEX swap data
    @param affiliate Affiliate address
    @param shouldSellEntireBalance If True transfers entrire allowable amount from another contract
    */
    function ZapOut(
        address toTokenAddress,
        address fromPoolAddress,
        uint256 incomingLP,
        uint256 minTokensRec,
        address[] memory swapTargets,
        bytes[] memory swapData,
        address affiliate,
        bool shouldSellEntireBalance
    ) public stopInEmergency returns (uint256 tokensRec) {
        (uint256 amount0, uint256 amount1) =
            _removeLiquidity(
                fromPoolAddress,
                incomingLP,
                shouldSellEntireBalance
            );

        //swaps tokens to token
        tokensRec = _swapTokens(
            fromPoolAddress,
            amount0,
            amount1,
            toTokenAddress,
            swapTargets,
            swapData
        );
        require(tokensRec >= minTokensRec, "High Slippage");

        uint256 totalGoodwillPortion;

        // transfer toTokens to sender
        if (toTokenAddress == address(0)) {
            totalGoodwillPortion = _subtractGoodwill(
                ETHAddress,
                tokensRec,
                affiliate,
                true
            );

            payable(msg.sender).transfer(tokensRec - totalGoodwillPortion);
        } else {
            totalGoodwillPortion = _subtractGoodwill(
                toTokenAddress,
                tokensRec,
                affiliate,
                true
            );

            IERC20(toTokenAddress).safeTransfer(
                msg.sender,
                tokensRec - totalGoodwillPortion
            );
        }

        tokensRec = tokensRec - totalGoodwillPortion;

        emit zapOut(msg.sender, fromPoolAddress, toTokenAddress, tokensRec);

        return tokensRec;
    }

    /**
    @notice Zap out in both tokens with permit
    @param fromPoolAddress Pool from which to remove liquidity
    @param incomingLP Quantity of LP to remove from pool
    @param affiliate Affiliate address to share fees
    @param permitData Encoded permit data, which contains owner, spender, value, deadline, r,s,v values 
    @return amountA Quantity of tokenA received
    @return amountB Quantity of tokenB received
    */
    function ZapOut2PairTokenWithPermit(
        address fromPoolAddress,
        uint256 incomingLP,
        address affiliate,
        bytes calldata permitData
    ) external stopInEmergency returns (uint256 amountA, uint256 amountB) {
        // permit
        _validatePool(fromPoolAddress);
        (bool success, ) = fromPoolAddress.call(permitData);
        require(success, "Could Not Permit");

        (amountA, amountB) = ZapOut2PairToken(
            fromPoolAddress,
            incomingLP,
            affiliate
        );
    }

    /**
    @notice Zap out in a single token with permit
    @param toTokenAddress Address of desired token
    @param fromPoolAddress Pool from which to remove liquidity
    @param incomingLP Quantity of LP to remove from pool
    @param minTokensRec Minimum quantity of tokens to receive
    @param swapTargets Execution targets for swaps
    @param swapData DEX swap data
    @param affiliate Affiliate address
    */
    function ZapOutWithPermit(
        address toTokenAddress,
        address fromPoolAddress,
        uint256 incomingLP,
        uint256 minTokensRec,
        bytes memory permitData,
        address[] memory swapTargets,
        bytes[] memory swapData,
        address affiliate
    ) public stopInEmergency returns (uint256) {
        // permit
        _validatePool(fromPoolAddress);
        (bool success, ) = fromPoolAddress.call(permitData);
        require(success, "Could Not Permit");

        return (
            ZapOut(
                toTokenAddress,
                fromPoolAddress,
                incomingLP,
                minTokensRec,
                swapTargets,
                swapData,
                affiliate,
                false
            )
        );
    }

    function _validatePool(address poolAddress) internal view {
        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);
        address token0 = pair.token0();
        address token1 = pair.token1();

        address retrievedAddress = sushiswapFactory.getPair(token0, token1);

        require(retrievedAddress == poolAddress, "Invalid Pool Address");
    }

    function _removeLiquidity(
        address fromPoolAddress,
        uint256 incomingLP,
        bool shouldSellEntireBalance
    ) internal returns (uint256 amount0, uint256 amount1) {
        IUniswapV2Pair pair = IUniswapV2Pair(fromPoolAddress);

        require(address(pair) != address(0), "Pool Cannot be Zero Address");

        address token0 = pair.token0();
        address token1 = pair.token1();

        _pullTokens(fromPoolAddress, incomingLP, shouldSellEntireBalance);

        _approveToken(fromPoolAddress, address(sushiswapRouter), incomingLP);

        (amount0, amount1) = sushiswapRouter.removeLiquidity(
            token0,
            token1,
            incomingLP,
            1,
            1,
            address(this),
            deadline
        );
        require(amount0 > 0 && amount1 > 0, "Removed Insufficient Liquidity");
    }

    function _swapTokens(
        address fromPoolAddress,
        uint256 amount0,
        uint256 amount1,
        address toToken,
        address[] memory swapTargets,
        bytes[] memory swapData
    ) internal returns (uint256 tokensBought) {
        address token0 = IUniswapV2Pair(fromPoolAddress).token0();
        address token1 = IUniswapV2Pair(fromPoolAddress).token1();

        //swap token0 to toToken
        if (token0 == toToken) {
            tokensBought = tokensBought + amount0;
        } else {
            //swap token using 0x swap
            tokensBought =
                tokensBought +
                _fillQuote(
                    token0,
                    toToken,
                    amount0,
                    swapTargets[0],
                    swapData[0]
                );
        }

        //swap token1 to toToken
        if (token1 == toToken) {
            tokensBought = tokensBought + amount1;
        } else {
            //swap token using 0x swap
            tokensBought =
                tokensBought +
                _fillQuote(
                    token1,
                    toToken,
                    amount1,
                    swapTargets[1],
                    swapData[1]
                );
        }
    }

    function _fillQuote(
        address fromTokenAddress,
        address toToken,
        uint256 amount,
        address swapTarget,
        bytes memory swapData
    ) internal returns (uint256) {
        if (fromTokenAddress == wethTokenAddress && toToken == address(0)) {
            IWETH(wethTokenAddress).withdraw(amount);
            return amount;
        }

        uint256 valueToSend;
        if (fromTokenAddress == address(0)) {
            valueToSend = amount;
        } else {
            _approveToken(fromTokenAddress, swapTarget, amount);
        }

        uint256 initialBalance = _getBalance(toToken);

        require(approvedTargets[swapTarget], "Target not Authorized");
        (bool success, ) = swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens");

        uint256 finalBalance = _getBalance(toToken) - initialBalance;

        require(finalBalance > 0, "Swapped to Invalid Intermediate");

        return finalBalance;
    }

    /**
        @notice Utility function to determine quantity and addresses of tokens being removed
        @param fromPoolAddress Pool from which to remove liquidity
        @param liquidity Quantity of LP tokens to remove.
        @return amountA Quantity of tokenA removed
        @return amountB Quantity of tokenB removed
        @return token0 Address of the underlying token to be removed
        @return token1 Address of the underlying token to be removed
    */
    function removeLiquidityReturn(address fromPoolAddress, uint256 liquidity)
        external
        view
        returns (
            uint256 amountA,
            uint256 amountB,
            address token0,
            address token1
        )
    {
        IUniswapV2Pair pair = IUniswapV2Pair(fromPoolAddress);
        token0 = pair.token0();
        token1 = pair.token1();

        uint256 balance0 = IERC20(token0).balanceOf(fromPoolAddress);
        uint256 balance1 = IERC20(token1).balanceOf(fromPoolAddress);

        uint256 _totalSupply = pair.totalSupply();

        amountA = (liquidity * balance0) / _totalSupply;
        amountB = (liquidity * balance1) / _totalSupply;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\TokenTimelock.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./SafeERC20.sol";



/**

 * @dev A token holder contract that will allow a beneficiary to extract the

 * tokens after a given release time.

 *

 * Useful for simple vesting schedules like "advisors get all of their tokens

 * after 1 year".

 */

contract TokenTimelock {

    using SafeERC20 for IERC20;



    // ERC20 basic token contract being held

    IERC20 private immutable _token;



    // beneficiary of tokens after they are released

    address private immutable _beneficiary;



    // timestamp when token release is enabled

    uint256 private immutable _releaseTime;



    constructor(

        IERC20 token_,

        address beneficiary_,

        uint256 releaseTime_

    ) {

        // solhint-disable-next-line not-rely-on-time

        require(

            releaseTime_ > block.timestamp,

            "TokenTimelock: release time is before current time"

        );

        _token = token_;

        _beneficiary = beneficiary_;

        _releaseTime = releaseTime_;

    }



    /**

     * @return the token being held.

     */

    function token() public view virtual returns (IERC20) {

        return _token;

    }



    /**

     * @return the beneficiary of the tokens.

     */

    function beneficiary() public view virtual returns (address) {

        return _beneficiary;

    }



    /**

     * @return the time when the tokens are released.

     */

    function releaseTime() public view virtual returns (uint256) {

        return _releaseTime;

    }



    /**

     * @notice Transfers tokens held by timelock to beneficiary.

     */

    function release() public virtual {

        // solhint-disable-next-line not-rely-on-time

        require(

            block.timestamp >= releaseTime(),

            "TokenTimelock: current time is before release time"

        );



        uint256 amount = token().balanceOf(address(this));

        require(amount > 0, "TokenTimelock: no tokens to release");



        token().safeTransfer(beneficiary(), amount);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\UniSwapAddLiquityV3_General.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-02-10

*/



// File: @openzeppelin/upgrades/contracts/Initializable.sol



pragma solidity >=0.4.24 <0.6.0;





/**

 * @title Initializable

 *

 * @dev Helper contract to support initializer functions. To use it, replace

 * the constructor with a function that has the `initializer` modifier.

 * WARNING: Unlike constructors, initializer functions must be manually

 * invoked. This applies both to deploying an Initializable contract, as well

 * as extending an Initializable contract via inheritance.

 * WARNING: When used with inheritance, manual care must be taken to not invoke

 * a parent initializer twice, or ensure that all initializers are idempotent,

 * because this is not dealt with automatically as with constructors.

 */

contract Initializable {



  /**

   * @dev Indicates that the contract has been initialized.

   */

  bool private initialized;



  /**

   * @dev Indicates that the contract is in the process of being initialized.

   */

  bool private initializing;



  /**

   * @dev Modifier to use in the initializer function of a contract.

   */

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  /// @dev Returns true if and only if the function is running in the constructor

  function isConstructor() private view returns (bool) {

    // extcodesize checks the size of the code stored in an address, and

    // address returns the current address. Since the code is still not

    // deployed when running a constructor, any checks on its code size will

    // yield zero, making it an effective way to detect if a contract is

    // under construction or not.

    uint256 cs;

    assembly { cs := extcodesize(address) }

    return cs == 0;

  }



  // Reserved storage space to allow for layout changes in the future.

  uint256[50] private ______gap;

}



// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: @openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol



pragma solidity ^0.5.0;





/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 */

contract ReentrancyGuard is Initializable {

    // counter to allow mutex lock with only one SSTORE operation

    uint256 private _guardCounter;



    function initialize() public initializer {

        // The counter starts at one to prevent changing it from zero to a non-zero

        // value, which is a more expensive operation.

        _guardCounter = 1;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        _guardCounter += 1;

        uint256 localCounter = _guardCounter;

        _;

        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");

    }



    uint256[50] private ______gap;

}



// File: contracts/UpdatedZaps/Done/UniSwapAddLiquidityV3_UpgradableGeneral.sol



// Copyright (C) 2019, 2020 dipeshsukhani, nodarjonashi, toshsharma, suhailg



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU Affero General Public License as published by

// the Free Software Foundation, either version 2 of the License, or

// (at your option) any later version.

//

// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU Affero General Public License for more details.

//

// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License



/**

 * WARNING: This is an upgradable contract. Be careful not to disrupt

 * the existing storage layout when making upgrades to the contract. In particular,

 * existing fields should not be removed and should not have their types changed.

 * The order of field declarations must not be changed, and new fields must be added

 * below all existing declarations.

 *

 * The base contracts and the order in which they are declared must not be changed.

 * New fields must not be added to base contracts (unless the base contract has

 * reserved placeholder fields for this purpose).

 *

 * See https://docs.zeppelinos.org/docs/writing_contracts.html for more info.

*/



pragma solidity ^0.5.0;











///@author DeFiZap

///@notice this contract implements one click conversion from ETH to unipool liquidity tokens



interface IuniswapFactory_UniPoolGeneralv3 {

    function getExchange(address token)

        external

        view

        returns (address exchange);

}



interface IuniswapExchange_UniPoolGeneralv3 {

    function getEthToTokenInputPrice(uint256 eth_sold)

        external

        view

        returns (uint256 tokens_bought);

    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)

        external

        payable

        returns (uint256 tokens_bought);

    function balanceOf(address _owner) external view returns (uint256);

    function transfer(address _to, uint256 _value) external returns (bool);

    function addLiquidity(

        uint256 min_liquidity,

        uint256 max_tokens,

        uint256 deadline

    ) external payable returns (uint256);

    function tokenToEthSwapInput(

        uint256 tokens_sold,

        uint256 min_eth,

        uint256 deadline

    ) external returns (uint256 eth_bought);

    function tokenToEthTransferInput(

        uint256 tokens_sold,

        uint256 min_eth,

        uint256 deadline,

        address recipient

    ) external returns (uint256 eth_bought);

}



contract UniSwapAddLiquityV3_General is Initializable, ReentrancyGuard {

    using SafeMath for uint256;



    // state variables



    // - THESE MUST ALWAYS STAY IN THE SAME LAYOUT

    bool private stopped;

    address payable public owner;

    IuniswapFactory_UniPoolGeneralv3 public UniSwapFactoryAddress;

    uint16 public goodwill;



    // events

    event ERC20TokenHoldingsOnConversion(uint256);

    event uniswapGeneralv3_details(

        address indexed _user,

        address indexed _tokenContractAddress,

        address indexed _uniswapExchangeAddress,

        uint256 _ethDeployed,

        uint256 _liquidityTokens

    );



    // circuit breaker modifiers

    modifier stopInEmergency {

        if (stopped) {

            revert("Temporarily Paused");

        } else {

            _;

        }

    }

    modifier onlyOwner() {

        require(isOwner(), "you are not authorised to call this function");

        _;

    }



    function initialize(address _UniSwapFactoryAddress) public initializer {

        ReentrancyGuard.initialize();

        stopped = false;

        owner = msg.sender;

        UniSwapFactoryAddress = IuniswapFactory_UniPoolGeneralv3(

            _UniSwapFactoryAddress

        );

    }



    function set_new_UniSwapFactoryAddress(address _new_UniSwapFactoryAddress)

        public

        onlyOwner

    {

        UniSwapFactoryAddress = IuniswapFactory_UniPoolGeneralv3(

            _new_UniSwapFactoryAddress

        );



    }



    function LetsInvest(address _TokenContractAddress, address _towhomtoissue)

        public

        payable

        stopInEmergency

        returns (uint256)

    {

        IERC20 ERC20TokenAddress = IERC20(_TokenContractAddress);

        IuniswapExchange_UniPoolGeneralv3 UniSwapExchangeContractAddress = IuniswapExchange_UniPoolGeneralv3(

            UniSwapFactoryAddress.getExchange(_TokenContractAddress)

        );



        // determining the portion of the incoming ETH to be converted to the ERC20 Token

        uint256 conversionPortion = SafeMath.div(

            SafeMath.mul(msg.value, 503),

            1000

        );

        uint256 non_conversionPortion = SafeMath.sub(

            msg.value,

            conversionPortion

        );



        // coversion of ETH to the ERC20 Token

        uint256 min_Tokens = SafeMath.div(

            SafeMath.mul(

                UniSwapExchangeContractAddress.getEthToTokenInputPrice(

                    conversionPortion

                ),

                98

            ),

            100

        );

        UniSwapExchangeContractAddress.ethToTokenSwapInput.value(

            conversionPortion

        )(min_Tokens, SafeMath.add(now, 1800));

        ERC20TokenAddress.approve(

            address(UniSwapExchangeContractAddress),

            ERC20TokenAddress.balanceOf(address(this))

        );

        require(

            ERC20TokenAddress.balanceOf(address(this)) > 0,

            "the conversion did not happen as planned"

        );

        emit ERC20TokenHoldingsOnConversion(

            ERC20TokenAddress.balanceOf(address(this))

        );



        // adding Liquidity

        uint256 max_tokens_ans = getMaxTokens(

            address(UniSwapExchangeContractAddress),

            ERC20TokenAddress,

            non_conversionPortion

        );

        uint256 LiquidityTokens = UniSwapExchangeContractAddress

            .addLiquidity

            .value(non_conversionPortion)(

            1,

            max_tokens_ans,

            SafeMath.add(now, 1800)

        );



        // transferring Liquidity

        UniSwapExchangeContractAddress.transfer(

            _towhomtoissue,

            UniSwapExchangeContractAddress.balanceOf(address(this))

        );



        // converting the residual

        UniSwapExchangeContractAddress.tokenToEthTransferInput(

            ERC20TokenAddress.balanceOf(address(this)),

            1,

            SafeMath.add(now, 1800),

            _towhomtoissue

        );

        ERC20TokenAddress.approve(address(UniSwapExchangeContractAddress), 0);

        emit uniswapGeneralv3_details(

            _towhomtoissue,

            address(ERC20TokenAddress),

            address(UniSwapExchangeContractAddress),

            msg.value,

            LiquidityTokens

        );

        return LiquidityTokens;

    }



    function getMaxTokens(

        address _UniSwapExchangeContractAddress,

        IERC20 _ERC20TokenAddress,

        uint256 _value

    ) internal view returns (uint256) {

        uint256 contractBalance = address(_UniSwapExchangeContractAddress)

            .balance;

        uint256 eth_reserve = SafeMath.sub(contractBalance, _value);

        uint256 token_reserve = _ERC20TokenAddress.balanceOf(

            _UniSwapExchangeContractAddress

        );

        uint256 token_amount = SafeMath.div(

            SafeMath.mul(_value, token_reserve),

            eth_reserve

        ) +

            1;

        return token_amount;

    }



    function inCaseTokengetsStuck(IERC20 _TokenAddress) public onlyOwner {

        uint256 qty = _TokenAddress.balanceOf(address(this));

        _TokenAddress.transfer(owner, qty);

    }



    // - fallback function let you / anyone send ETH to this wallet without the need to call any function

    function() external payable {

        if (msg.sender != owner) {

            LetsInvest(0x6B175474E89094C44Da98b954EedeAC495271d0F, msg.sender);

        }

    }



    // - to Pause the contract

    function toggleContractActive() public onlyOwner {

        stopped = !stopped;

    }



    // - to withdraw any ETH balance sitting in the contract

    function withdraw() public onlyOwner {

        owner.transfer(address(this).balance);

    }



    // - to kill the contract

    function destruct() public onlyOwner {

        selfdestruct(owner);

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == owner;

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address payable newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address payable newOwner) internal {

        require(

            newOwner != address(0),

            "Ownable: new owner is the zero address"

        );

        owner = newOwner;

    }



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\UniswapV2_ZapIn_General_V5.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract adds liquidity to Uniswap V2 pools using ETH or any ERC20 Token.
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapInBaseV3.sol";

// import "@uniswap/lib/contracts/libraries/Babylonian.sol";
library Babylonian {
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
        // else z = 0
    }
}

interface IWETH {
    function deposit() external payable;

    function transfer(address to, uint256 value) external returns (bool);

    function withdraw(uint256) external;
}

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address);
}

interface IUniswapV2Router02 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountsOut(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);
}

interface IUniswapV2Pair {
    function token0() external pure returns (address);

    function token1() external pure returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        );
}

contract UniswapV2_ZapIn_General_V5 is ZapInBaseV3 {
    using SafeERC20 for IERC20;

    IUniswapV2Factory private constant UniSwapV2FactoryAddress =
        IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);

    IUniswapV2Router02 private constant uniswapRouter =
        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    address private constant wethTokenAddress =
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    uint256 private constant deadline =
        0xf000000000000000000000000000000000000000000000000000000000000000;

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2(_goodwill, _affiliateSplit)
    {
        // 0x exchange
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
    }

    event zapIn(address sender, address pool, uint256 tokensRec);

    /**
    @notice This function is used to invest in given Uniswap V2 pair through ETH/ERC20 Tokens
    @param _FromTokenContractAddress The ERC20 token used for investment (address(0x00) if ether)
    @param _pairAddress The Uniswap pair address
    @param _amount The amount of fromToken to invest
    @param _minPoolTokens Reverts if less tokens received than this
    @param _swapTarget Excecution target for the first swap
    @param swapData DEX quote data
    @param affiliate Affiliate address
    @param transferResidual Set false to save gas by donating the residual remaining after a Zap
    @param shouldSellEntireBalance If True transfers entrire allowable amount from another contract
    @return Amount of LP bought
     */
    function ZapIn(
        address _FromTokenContractAddress,
        address _pairAddress,
        uint256 _amount,
        uint256 _minPoolTokens,
        address _swapTarget,
        bytes calldata swapData,
        address affiliate,
        bool transferResidual,
        bool shouldSellEntireBalance
    ) external payable stopInEmergency returns (uint256) {
        uint256 toInvest =
            _pullTokens(
                _FromTokenContractAddress,
                _amount,
                affiliate,
                true,
                shouldSellEntireBalance
            );

        uint256 LPBought =
            _performZapIn(
                _FromTokenContractAddress,
                _pairAddress,
                toInvest,
                _swapTarget,
                swapData,
                transferResidual
            );
        require(LPBought >= _minPoolTokens, "High Slippage");

        emit zapIn(msg.sender, _pairAddress, LPBought);

        IERC20(_pairAddress).safeTransfer(msg.sender, LPBought);
        return LPBought;
    }

    function _getPairTokens(address _pairAddress)
        internal
        pure
        returns (address token0, address token1)
    {
        IUniswapV2Pair uniPair = IUniswapV2Pair(_pairAddress);
        token0 = uniPair.token0();
        token1 = uniPair.token1();
    }

    function _performZapIn(
        address _FromTokenContractAddress,
        address _pairAddress,
        uint256 _amount,
        address _swapTarget,
        bytes memory swapData,
        bool transferResidual
    ) internal returns (uint256) {
        uint256 intermediateAmt;
        address intermediateToken;
        (address _ToUniswapToken0, address _ToUniswapToken1) =
            _getPairTokens(_pairAddress);

        if (
            _FromTokenContractAddress != _ToUniswapToken0 &&
            _FromTokenContractAddress != _ToUniswapToken1
        ) {
            // swap to intermediate
            (intermediateAmt, intermediateToken) = _fillQuote(
                _FromTokenContractAddress,
                _pairAddress,
                _amount,
                _swapTarget,
                swapData
            );
        } else {
            intermediateToken = _FromTokenContractAddress;
            intermediateAmt = _amount;
        }

        // divide intermediate into appropriate amount to add liquidity
        (uint256 token0Bought, uint256 token1Bought) =
            _swapIntermediate(
                intermediateToken,
                _ToUniswapToken0,
                _ToUniswapToken1,
                intermediateAmt
            );

        return
            _uniDeposit(
                _ToUniswapToken0,
                _ToUniswapToken1,
                token0Bought,
                token1Bought,
                transferResidual
            );
    }

    function _uniDeposit(
        address _ToUnipoolToken0,
        address _ToUnipoolToken1,
        uint256 token0Bought,
        uint256 token1Bought,
        bool transferResidual
    ) internal returns (uint256) {
        _approveToken(_ToUnipoolToken0, address(uniswapRouter), token0Bought);
        _approveToken(_ToUnipoolToken1, address(uniswapRouter), token1Bought);

        (uint256 amountA, uint256 amountB, uint256 LP) =
            uniswapRouter.addLiquidity(
                _ToUnipoolToken0,
                _ToUnipoolToken1,
                token0Bought,
                token1Bought,
                1,
                1,
                address(this),
                deadline
            );

        if (transferResidual) {
            //Returning Residue in token0, if any.
            if (token0Bought - amountA > 0) {
                IERC20(_ToUnipoolToken0).safeTransfer(
                    msg.sender,
                    token0Bought - amountA
                );
            }

            //Returning Residue in token1, if any
            if (token1Bought - amountB > 0) {
                IERC20(_ToUnipoolToken1).safeTransfer(
                    msg.sender,
                    token1Bought - amountB
                );
            }
        }

        return LP;
    }

    function _fillQuote(
        address _fromTokenAddress,
        address _pairAddress,
        uint256 _amount,
        address _swapTarget,
        bytes memory swapData
    ) internal returns (uint256 amountBought, address intermediateToken) {
        if (_swapTarget == wethTokenAddress) {
            IWETH(wethTokenAddress).deposit{ value: _amount }();
            return (_amount, wethTokenAddress);
        }

        uint256 valueToSend;
        if (_fromTokenAddress == address(0)) {
            valueToSend = _amount;
        } else {
            _approveToken(_fromTokenAddress, _swapTarget, _amount);
        }

        (address _token0, address _token1) = _getPairTokens(_pairAddress);
        IERC20 token0 = IERC20(_token0);
        IERC20 token1 = IERC20(_token1);
        uint256 initialBalance0 = token0.balanceOf(address(this));
        uint256 initialBalance1 = token1.balanceOf(address(this));

        require(approvedTargets[_swapTarget], "Target not Authorized");
        (bool success, ) = _swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens 1");

        uint256 finalBalance0 =
            token0.balanceOf(address(this)) - initialBalance0;
        uint256 finalBalance1 =
            token1.balanceOf(address(this)) - initialBalance1;

        if (finalBalance0 > finalBalance1) {
            amountBought = finalBalance0;
            intermediateToken = _token0;
        } else {
            amountBought = finalBalance1;
            intermediateToken = _token1;
        }

        require(amountBought > 0, "Swapped to Invalid Intermediate");
    }

    function _swapIntermediate(
        address _toContractAddress,
        address _ToUnipoolToken0,
        address _ToUnipoolToken1,
        uint256 _amount
    ) internal returns (uint256 token0Bought, uint256 token1Bought) {
        IUniswapV2Pair pair =
            IUniswapV2Pair(
                UniSwapV2FactoryAddress.getPair(
                    _ToUnipoolToken0,
                    _ToUnipoolToken1
                )
            );
        (uint256 res0, uint256 res1, ) = pair.getReserves();
        if (_toContractAddress == _ToUnipoolToken0) {
            uint256 amountToSwap = calculateSwapInAmount(res0, _amount);
            //if no reserve or a new pair is created
            if (amountToSwap <= 0) amountToSwap = _amount / 2;
            token1Bought = _token2Token(
                _toContractAddress,
                _ToUnipoolToken1,
                amountToSwap
            );
            token0Bought = _amount - amountToSwap;
        } else {
            uint256 amountToSwap = calculateSwapInAmount(res1, _amount);
            //if no reserve or a new pair is created
            if (amountToSwap <= 0) amountToSwap = _amount / 2;
            token0Bought = _token2Token(
                _toContractAddress,
                _ToUnipoolToken0,
                amountToSwap
            );
            token1Bought = _amount - amountToSwap;
        }
    }

    function calculateSwapInAmount(uint256 reserveIn, uint256 userIn)
        internal
        pure
        returns (uint256)
    {
        return
            (Babylonian.sqrt(
                reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))
            ) - (reserveIn * 1997)) / 1994;
    }

    /**
    @notice This function is used to swap ERC20 <> ERC20
    @param _FromTokenContractAddress The token address to swap from.
    @param _ToTokenContractAddress The token address to swap to. 
    @param tokens2Trade The amount of tokens to swap
    @return tokenBought The quantity of tokens bought
    */
    function _token2Token(
        address _FromTokenContractAddress,
        address _ToTokenContractAddress,
        uint256 tokens2Trade
    ) internal returns (uint256 tokenBought) {
        if (_FromTokenContractAddress == _ToTokenContractAddress) {
            return tokens2Trade;
        }

        _approveToken(
            _FromTokenContractAddress,
            address(uniswapRouter),
            tokens2Trade
        );

        address pair =
            UniSwapV2FactoryAddress.getPair(
                _FromTokenContractAddress,
                _ToTokenContractAddress
            );
        require(pair != address(0), "No Swap Available");
        address[] memory path = new address[](2);
        path[0] = _FromTokenContractAddress;
        path[1] = _ToTokenContractAddress;

        tokenBought = uniswapRouter.swapExactTokensForTokens(
            tokens2Trade,
            1,
            path,
            address(this),
            deadline
        )[path.length - 1];

        require(tokenBought > 0, "Error Swapping Tokens 2");
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\UniswapV2_ZapOut_General_V4.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License

///@author Zapper
///@notice this contract implements one click removal of liquidity from UniswapV2 pools, receiving ETH, ERC20 or both.
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapOutBaseV3.sol";

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);
}

interface IUniswapV2Router02 {
    function WETH() external pure returns (address);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);
}

interface IUniswapV2Pair {
    function token0() external pure returns (address);

    function token1() external pure returns (address);

    function balanceOf(address user) external view returns (uint256);

    function totalSupply() external view returns (uint256);

    function getReserves()
        external
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        );

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

interface IWETH {
    function withdraw(uint256 wad) external;
}

contract UniswapV2_ZapOut_General_V4_0_1 is ZapOutBaseV3 {
    using SafeERC20 for IERC20;

    uint256 private constant deadline =
        0xf000000000000000000000000000000000000000000000000000000000000000;

    IUniswapV2Router02 private constant uniswapV2Router =
        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IUniswapV2Factory private constant uniswapFactory =
        IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);

    address private constant wethTokenAddress =
        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2(_goodwill, _affiliateSplit)
    {
        // 0x exchange
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
    }

    event zapOut(
        address sender,
        address pool,
        address token,
        uint256 tokensRec
    );

    /**
        @notice Zap out in both tokens
        @param fromPoolAddress Pool from which to remove liquidity
        @param incomingLP Quantity of LP to remove from pool
        @param affiliate Affiliate address
        @return amountA Quantity of tokenA received after zapout
        @return amountB Quantity of tokenB received after zapout
    */
    function ZapOut2PairToken(
        address fromPoolAddress,
        uint256 incomingLP,
        address affiliate
    ) public stopInEmergency returns (uint256 amountA, uint256 amountB) {
        IUniswapV2Pair pair = IUniswapV2Pair(fromPoolAddress);

        require(address(pair) != address(0), "Pool Cannot be Zero Address");

        // get reserves
        address token0 = pair.token0();
        address token1 = pair.token1();

        IERC20(fromPoolAddress).safeTransferFrom(
            msg.sender,
            address(this),
            incomingLP
        );

        _approveToken(fromPoolAddress, address(uniswapV2Router), incomingLP);

        if (token0 == wethTokenAddress || token1 == wethTokenAddress) {
            address _token = token0 == wethTokenAddress ? token1 : token0;
            (amountA, amountB) = uniswapV2Router.removeLiquidityETH(
                _token,
                incomingLP,
                1,
                1,
                address(this),
                deadline
            );

            // subtract goodwill
            uint256 tokenGoodwill =
                _subtractGoodwill(_token, amountA, affiliate, true);
            uint256 ethGoodwill =
                _subtractGoodwill(ETHAddress, amountB, affiliate, true);

            // send tokens
            IERC20(_token).safeTransfer(msg.sender, amountA - tokenGoodwill);
            Address.sendValue(payable(msg.sender), amountB - ethGoodwill);
        } else {
            (amountA, amountB) = uniswapV2Router.removeLiquidity(
                token0,
                token1,
                incomingLP,
                1,
                1,
                address(this),
                deadline
            );

            // subtract goodwill
            uint256 tokenAGoodwill =
                _subtractGoodwill(token0, amountA, affiliate, true);
            uint256 tokenBGoodwill =
                _subtractGoodwill(token1, amountB, affiliate, true);

            // send tokens
            IERC20(token0).safeTransfer(msg.sender, amountA - tokenAGoodwill);
            IERC20(token1).safeTransfer(msg.sender, amountB - tokenBGoodwill);
        }
        emit zapOut(msg.sender, fromPoolAddress, token0, amountA);
        emit zapOut(msg.sender, fromPoolAddress, token1, amountB);
    }

    /**
        @notice Zap out in a single token
        @param toTokenAddress Address of desired token
        @param fromPoolAddress Pool from which to remove liquidity
        @param incomingLP Quantity of LP to remove from pool
        @param minTokensRec Minimum quantity of tokens to receive
        @param swapTargets Execution targets for swaps
        @param swapData DEX swap data
        @param affiliate Affiliate address
        @param shouldSellEntireBalance If True transfers entrire allowable amount from another contract
    */
    function ZapOut(
        address toTokenAddress,
        address fromPoolAddress,
        uint256 incomingLP,
        uint256 minTokensRec,
        address[] memory swapTargets,
        bytes[] memory swapData,
        address affiliate,
        bool shouldSellEntireBalance
    ) public stopInEmergency returns (uint256 tokensRec) {
        (uint256 amount0, uint256 amount1) =
            _removeLiquidity(
                fromPoolAddress,
                incomingLP,
                shouldSellEntireBalance
            );

        //swaps tokens to token
        tokensRec = _swapTokens(
            fromPoolAddress,
            amount0,
            amount1,
            toTokenAddress,
            swapTargets,
            swapData
        );
        require(tokensRec >= minTokensRec, "High Slippage");

        uint256 totalGoodwillPortion;

        // transfer toTokens to sender
        if (toTokenAddress == address(0)) {
            totalGoodwillPortion = _subtractGoodwill(
                ETHAddress,
                tokensRec,
                affiliate,
                true
            );

            payable(msg.sender).transfer(tokensRec - totalGoodwillPortion);
        } else {
            totalGoodwillPortion = _subtractGoodwill(
                toTokenAddress,
                tokensRec,
                affiliate,
                true
            );

            IERC20(toTokenAddress).safeTransfer(
                msg.sender,
                tokensRec - totalGoodwillPortion
            );
        }

        tokensRec = tokensRec - totalGoodwillPortion;

        emit zapOut(msg.sender, fromPoolAddress, toTokenAddress, tokensRec);

        return tokensRec;
    }

    /**
        @notice Zap out in both tokens with permit
        @param fromPoolAddress Pool from which to remove liquidity
        @param incomingLP Quantity of LP to remove from pool
        @param affiliate Affiliate address to share fees
        @param permitData Encoded permit data, which contains owner, spender, value, deadline, r,s,v values 
        @return amountA Quantity of tokenA received
        @return amountB Quantity of tokenB received
    */
    function ZapOut2PairTokenWithPermit(
        address fromPoolAddress,
        uint256 incomingLP,
        address affiliate,
        bytes calldata permitData
    ) external stopInEmergency returns (uint256 amountA, uint256 amountB) {
        // permit
        _validatePool(fromPoolAddress);
        (bool success, ) = fromPoolAddress.call(permitData);
        require(success, "Could Not Permit");

        (amountA, amountB) = ZapOut2PairToken(
            fromPoolAddress,
            incomingLP,
            affiliate
        );
    }

    /**
        @notice Zap out in a single token with permit
        @param toTokenAddress Address of desired token
        @param fromPoolAddress Pool from which to remove liquidity
        @param incomingLP Quantity of LP to remove from pool
        @param minTokensRec Minimum quantity of tokens to receive
        @param swapTargets Execution targets for swaps
        @param swapData DEX swap data
        @param affiliate Affiliate address
    */
    function ZapOutWithPermit(
        address toTokenAddress,
        address fromPoolAddress,
        uint256 incomingLP,
        uint256 minTokensRec,
        bytes memory permitData,
        address[] memory swapTargets,
        bytes[] memory swapData,
        address affiliate
    ) public stopInEmergency returns (uint256) {
        // permit
        _validatePool(fromPoolAddress);
        (bool success, ) = fromPoolAddress.call(permitData);
        require(success, "Could Not Permit");

        return (
            ZapOut(
                toTokenAddress,
                fromPoolAddress,
                incomingLP,
                minTokensRec,
                swapTargets,
                swapData,
                affiliate,
                false
            )
        );
    }

    function _validatePool(address poolAddress) internal view {
        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);
        address token0 = pair.token0();
        address token1 = pair.token1();

        address retrievedAddress = uniswapFactory.getPair(token0, token1);

        require(retrievedAddress == poolAddress, "Invalid Pool Address");
    }

    function _removeLiquidity(
        address fromPoolAddress,
        uint256 incomingLP,
        bool shouldSellEntireBalance
    ) internal returns (uint256 amount0, uint256 amount1) {
        IUniswapV2Pair pair = IUniswapV2Pair(fromPoolAddress);

        require(address(pair) != address(0), "Pool Cannot be Zero Address");

        address token0 = pair.token0();
        address token1 = pair.token1();

        _pullTokens(fromPoolAddress, incomingLP, shouldSellEntireBalance);

        _approveToken(fromPoolAddress, address(uniswapV2Router), incomingLP);

        (amount0, amount1) = uniswapV2Router.removeLiquidity(
            token0,
            token1,
            incomingLP,
            1,
            1,
            address(this),
            deadline
        );
        require(amount0 > 0 && amount1 > 0, "Removed Insufficient Liquidity");
    }

    function _swapTokens(
        address fromPoolAddress,
        uint256 amount0,
        uint256 amount1,
        address toToken,
        address[] memory swapTargets,
        bytes[] memory swapData
    ) internal returns (uint256 tokensBought) {
        address token0 = IUniswapV2Pair(fromPoolAddress).token0();
        address token1 = IUniswapV2Pair(fromPoolAddress).token1();

        //swap token0 to toToken
        if (token0 == toToken) {
            tokensBought = tokensBought + amount0;
        } else {
            //swap token using 0x swap
            tokensBought =
                tokensBought +
                _fillQuote(
                    token0,
                    toToken,
                    amount0,
                    swapTargets[0],
                    swapData[0]
                );
        }

        //swap token1 to toToken
        if (token1 == toToken) {
            tokensBought = tokensBought + amount1;
        } else {
            //swap token using 0x swap
            tokensBought =
                tokensBought +
                _fillQuote(
                    token1,
                    toToken,
                    amount1,
                    swapTargets[1],
                    swapData[1]
                );
        }
    }

    function _fillQuote(
        address fromTokenAddress,
        address toToken,
        uint256 amount,
        address swapTarget,
        bytes memory swapData
    ) internal returns (uint256) {
        if (fromTokenAddress == wethTokenAddress && toToken == address(0)) {
            IWETH(wethTokenAddress).withdraw(amount);
            return amount;
        }

        uint256 valueToSend;
        if (fromTokenAddress == address(0)) {
            valueToSend = amount;
        } else {
            _approveToken(fromTokenAddress, swapTarget, amount);
        }

        uint256 initialBalance = _getBalance(toToken);

        require(approvedTargets[swapTarget], "Target not Authorized");
        (bool success, ) = swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens");

        uint256 finalBalance = _getBalance(toToken) - initialBalance;

        require(finalBalance > 0, "Swapped to Invalid Intermediate");

        return finalBalance;
    }

    /**
        @notice Utility function to determine quantity and addresses of tokens being removed
        @param fromPoolAddress Pool from which to remove liquidity
        @param liquidity Quantity of LP tokens to remove.
        @return amountA Quantity of tokenA removed
        @return amountB Quantity of tokenB removed
        @return token0 Address of the underlying token to be removed
        @return token1 Address of the underlying token to be removed
    */
    function removeLiquidityReturn(address fromPoolAddress, uint256 liquidity)
        external
        view
        returns (
            uint256 amountA,
            uint256 amountB,
            address token0,
            address token1
        )
    {
        IUniswapV2Pair pair = IUniswapV2Pair(fromPoolAddress);
        token0 = pair.token0();
        token1 = pair.token1();

        uint256 balance0 = IERC20(token0).balanceOf(fromPoolAddress);
        uint256 balance1 = IERC20(token1).balanceOf(fromPoolAddress);

        uint256 _totalSupply = pair.totalSupply();

        amountA = (liquidity * balance0) / _totalSupply;
        amountB = (liquidity * balance1) / _totalSupply;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\UniswapV2_ZapOut_General_V5.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License

///@author Zapper
///@notice this contract implements one click removal of liquidity from UniswapV2 pools, receiving ETH, ERC20 or both.
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "../_base/ZapOutBaseV3.sol";

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);
}

interface IUniswapV2Router02 {
    function WETH() external pure returns (address);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);
}

interface IUniswapV2Pair {
    function token0() external pure returns (address);

    function token1() external pure returns (address);

    function balanceOf(address user) external view returns (uint256);

    function totalSupply() external view returns (uint256);

    function getReserves()
        external
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        );

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

interface IWETH {
    function withdraw(uint256 wad) external;
}

contract UniswapV2_ZapOut_General_V5 is ZapOutBaseV3 {
    using SafeERC20 for IERC20;

    uint256 private constant deadline =
        0xf000000000000000000000000000000000000000000000000000000000000000;

    uint256 private constant permitAllowance = 79228162514260000000000000000;

    IUniswapV2Router02 private constant uniswapV2Router =
        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IUniswapV2Factory private constant uniswapFactory =
        IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);

    address private constant wethTokenAddress =
        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2(_goodwill, _affiliateSplit)
    {
        // 0x exchange
        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
    }

    event zapOut(
        address sender,
        address pool,
        address token,
        uint256 tokensRec
    );

    /**
        @notice Zap out in both tokens
        @param fromPoolAddress Pool from which to remove liquidity
        @param incomingLP Quantity of LP to remove from pool
        @param affiliate Affiliate address
        @return amountA Quantity of tokenA received after zapout
        @return amountB Quantity of tokenB received after zapout
    */
    function ZapOut2PairToken(
        address fromPoolAddress,
        uint256 incomingLP,
        address affiliate
    ) public stopInEmergency returns (uint256 amountA, uint256 amountB) {
        IUniswapV2Pair pair = IUniswapV2Pair(fromPoolAddress);

        require(address(pair) != address(0), "Pool Cannot be Zero Address");

        // get reserves
        address token0 = pair.token0();
        address token1 = pair.token1();

        IERC20(fromPoolAddress).safeTransferFrom(
            msg.sender,
            address(this),
            incomingLP
        );

        _approveToken(fromPoolAddress, address(uniswapV2Router), incomingLP);

        if (token0 == wethTokenAddress || token1 == wethTokenAddress) {
            address _token = token0 == wethTokenAddress ? token1 : token0;
            (amountA, amountB) = uniswapV2Router.removeLiquidityETH(
                _token,
                incomingLP,
                1,
                1,
                address(this),
                deadline
            );

            // subtract goodwill
            uint256 tokenGoodwill =
                _subtractGoodwill(_token, amountA, affiliate, true);
            uint256 ethGoodwill =
                _subtractGoodwill(ETHAddress, amountB, affiliate, true);

            // send tokens
            IERC20(_token).safeTransfer(msg.sender, amountA - tokenGoodwill);
            Address.sendValue(payable(msg.sender), amountB - ethGoodwill);
        } else {
            (amountA, amountB) = uniswapV2Router.removeLiquidity(
                token0,
                token1,
                incomingLP,
                1,
                1,
                address(this),
                deadline
            );

            // subtract goodwill
            uint256 tokenAGoodwill =
                _subtractGoodwill(token0, amountA, affiliate, true);
            uint256 tokenBGoodwill =
                _subtractGoodwill(token1, amountB, affiliate, true);

            // send tokens
            IERC20(token0).safeTransfer(msg.sender, amountA - tokenAGoodwill);
            IERC20(token1).safeTransfer(msg.sender, amountB - tokenBGoodwill);
        }
        emit zapOut(msg.sender, fromPoolAddress, token0, amountA);
        emit zapOut(msg.sender, fromPoolAddress, token1, amountB);
    }

    /**
        @notice Zap out in a single token
        @param toTokenAddress Address of desired token
        @param fromPoolAddress Pool from which to remove liquidity
        @param incomingLP Quantity of LP to remove from pool
        @param minTokensRec Minimum quantity of tokens to receive
        @param swapTargets Execution targets for swaps
        @param swapData DEX swap data
        @param affiliate Affiliate address
        @param shouldSellEntireBalance If True transfers entrire allowable amount from another contract
    */
    function ZapOut(
        address toTokenAddress,
        address fromPoolAddress,
        uint256 incomingLP,
        uint256 minTokensRec,
        address[] memory swapTargets,
        bytes[] memory swapData,
        address affiliate,
        bool shouldSellEntireBalance
    ) public stopInEmergency returns (uint256 tokensRec) {
        (uint256 amount0, uint256 amount1) =
            _removeLiquidity(
                fromPoolAddress,
                incomingLP,
                shouldSellEntireBalance
            );

        //swaps tokens to token
        tokensRec = _swapTokens(
            fromPoolAddress,
            amount0,
            amount1,
            toTokenAddress,
            swapTargets,
            swapData
        );
        require(tokensRec >= minTokensRec, "High Slippage");

        uint256 totalGoodwillPortion;

        // transfer toTokens to sender
        if (toTokenAddress == address(0)) {
            totalGoodwillPortion = _subtractGoodwill(
                ETHAddress,
                tokensRec,
                affiliate,
                true
            );

            payable(msg.sender).transfer(tokensRec - totalGoodwillPortion);
        } else {
            totalGoodwillPortion = _subtractGoodwill(
                toTokenAddress,
                tokensRec,
                affiliate,
                true
            );

            IERC20(toTokenAddress).safeTransfer(
                msg.sender,
                tokensRec - totalGoodwillPortion
            );
        }

        tokensRec = tokensRec - totalGoodwillPortion;

        emit zapOut(msg.sender, fromPoolAddress, toTokenAddress, tokensRec);

        return tokensRec;
    }

    /**
    @notice Zap out in both tokens with permit
    @param fromPoolAddress Pool from which to remove liquidity
    @param incomingLP Quantity of LP to remove from pool
    @param affiliate Affiliate address to share fees
    @param permitSig Signature for permit
    @return amountA Quantity of tokenA received
    @return amountB Quantity of tokenB received
    */
    function ZapOut2PairTokenWithPermit(
        address fromPoolAddress,
        uint256 incomingLP,
        address affiliate,
        bytes calldata permitSig
    ) external stopInEmergency returns (uint256 amountA, uint256 amountB) {
        _permit(fromPoolAddress, permitAllowance, permitSig);

        (amountA, amountB) = ZapOut2PairToken(
            fromPoolAddress,
            incomingLP,
            affiliate
        );
    }

    /**
    @notice Zap out in a single token with permit
    @param toTokenAddress Address of desired token
    @param fromPoolAddress Pool from which to remove liquidity
    @param incomingLP Quantity of LP to remove from pool
    @param minTokensRec Minimum quantity of tokens to receive
    @param permitSig Signature for permit
    @param swapTargets Execution targets for swaps
    @param swapData DEX swap data
    @param affiliate Affiliate address
    */
    function ZapOutWithPermit(
        address toTokenAddress,
        address fromPoolAddress,
        uint256 incomingLP,
        uint256 minTokensRec,
        bytes calldata permitSig,
        address[] memory swapTargets,
        bytes[] memory swapData,
        address affiliate
    ) public stopInEmergency returns (uint256) {
        // permit
        _permit(fromPoolAddress, permitAllowance, permitSig);

        return (
            ZapOut(
                toTokenAddress,
                fromPoolAddress,
                incomingLP,
                minTokensRec,
                swapTargets,
                swapData,
                affiliate,
                false
            )
        );
    }

    function _permit(
        address fromPoolAddress,
        uint256 amountIn,
        bytes memory permitSig
    ) internal {
        require(permitSig.length == 65, "Invalid signature length");

        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(permitSig, 32))
            s := mload(add(permitSig, 64))
            v := byte(0, mload(add(permitSig, 96)))
        }
        IUniswapV2Pair(fromPoolAddress).permit(
            msg.sender,
            address(this),
            amountIn,
            deadline,
            v,
            r,
            s
        );
    }

    function _removeLiquidity(
        address fromPoolAddress,
        uint256 incomingLP,
        bool shouldSellEntireBalance
    ) internal returns (uint256 amount0, uint256 amount1) {
        IUniswapV2Pair pair = IUniswapV2Pair(fromPoolAddress);

        require(address(pair) != address(0), "Pool Cannot be Zero Address");

        address token0 = pair.token0();
        address token1 = pair.token1();

        _pullTokens(fromPoolAddress, incomingLP, shouldSellEntireBalance);

        _approveToken(fromPoolAddress, address(uniswapV2Router), incomingLP);

        (amount0, amount1) = uniswapV2Router.removeLiquidity(
            token0,
            token1,
            incomingLP,
            1,
            1,
            address(this),
            deadline
        );
        require(amount0 > 0 && amount1 > 0, "Removed Insufficient Liquidity");
    }

    function _swapTokens(
        address fromPoolAddress,
        uint256 amount0,
        uint256 amount1,
        address toToken,
        address[] memory swapTargets,
        bytes[] memory swapData
    ) internal returns (uint256 tokensBought) {
        address token0 = IUniswapV2Pair(fromPoolAddress).token0();
        address token1 = IUniswapV2Pair(fromPoolAddress).token1();

        //swap token0 to toToken
        if (token0 == toToken) {
            tokensBought = tokensBought + amount0;
        } else {
            //swap token using 0x swap
            tokensBought =
                tokensBought +
                _fillQuote(
                    token0,
                    toToken,
                    amount0,
                    swapTargets[0],
                    swapData[0]
                );
        }

        //swap token1 to toToken
        if (token1 == toToken) {
            tokensBought = tokensBought + amount1;
        } else {
            //swap token using 0x swap
            tokensBought =
                tokensBought +
                _fillQuote(
                    token1,
                    toToken,
                    amount1,
                    swapTargets[1],
                    swapData[1]
                );
        }
    }

    function _fillQuote(
        address fromTokenAddress,
        address toToken,
        uint256 amount,
        address swapTarget,
        bytes memory swapData
    ) internal returns (uint256) {
        if (fromTokenAddress == wethTokenAddress && toToken == address(0)) {
            IWETH(wethTokenAddress).withdraw(amount);
            return amount;
        }

        uint256 valueToSend;
        if (fromTokenAddress == address(0)) {
            valueToSend = amount;
        } else {
            _approveToken(fromTokenAddress, swapTarget, amount);
        }

        uint256 initialBalance = _getBalance(toToken);

        require(approvedTargets[swapTarget], "Target not Authorized");
        (bool success, ) = swapTarget.call{ value: valueToSend }(swapData);
        require(success, "Error Swapping Tokens");

        uint256 finalBalance = _getBalance(toToken) - initialBalance;

        require(finalBalance > 0, "Swapped to Invalid Intermediate");

        return finalBalance;
    }

    /**
        @notice Utility function to determine quantity and addresses of tokens being removed
        @param fromPoolAddress Pool from which to remove liquidity
        @param liquidity Quantity of LP tokens to remove.
        @return amountA Quantity of tokenA removed
        @return amountB Quantity of tokenB removed
        @return token0 Address of the underlying token to be removed
        @return token1 Address of the underlying token to be removed
    */
    function removeLiquidityReturn(address fromPoolAddress, uint256 liquidity)
        external
        view
        returns (
            uint256 amountA,
            uint256 amountB,
            address token0,
            address token1
        )
    {
        IUniswapV2Pair pair = IUniswapV2Pair(fromPoolAddress);
        token0 = pair.token0();
        token1 = pair.token1();

        uint256 balance0 = IERC20(token0).balanceOf(fromPoolAddress);
        uint256 balance1 = IERC20(token1).balanceOf(fromPoolAddress);

        uint256 _totalSupply = pair.totalSupply();

        amountA = (liquidity * balance0) / _totalSupply;
        amountB = (liquidity * balance1) / _totalSupply;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\UniSwap_ETH_CDAIZap.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2019-12-26

*/



// File: @openzeppelin/upgrades/contracts/Initializable.sol



pragma solidity >=0.4.24 <0.6.0;





/**

 * @title Initializable

 *

 * @dev Helper contract to support initializer functions. To use it, replace

 * the constructor with a function that has the `initializer` modifier.

 * WARNING: Unlike constructors, initializer functions must be manually

 * invoked. This applies both to deploying an Initializable contract, as well

 * as extending an Initializable contract via inheritance.

 * WARNING: When used with inheritance, manual care must be taken to not invoke

 * a parent initializer twice, or ensure that all initializers are idempotent,

 * because this is not dealt with automatically as with constructors.

 */

contract Initializable {



  /**

   * @dev Indicates that the contract has been initialized.

   */

  bool private initialized;



  /**

   * @dev Indicates that the contract is in the process of being initialized.

   */

  bool private initializing;



  /**

   * @dev Modifier to use in the initializer function of a contract.

   */

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  /// @dev Returns true if and only if the function is running in the constructor

  function isConstructor() private view returns (bool) {

    // extcodesize checks the size of the code stored in an address, and

    // address returns the current address. Since the code is still not

    // deployed when running a constructor, any checks on its code size will

    // yield zero, making it an effective way to detect if a contract is

    // under construction or not.

    uint256 cs;

    assembly { cs := extcodesize(address) }

    return cs == 0;

  }



  // Reserved storage space to allow for layout changes in the future.

  uint256[50] private ______gap;

}



// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: contracts/UpdatedZaps/Current WIP/UniSwap_ETH_cDAI_upgradable.sol



// Copyright (C) 2019, 2020 dipeshsukhani, nodarjonashi, toshsharma, suhailg



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU Affero General Public License as published by

// the Free Software Foundation, either version 2 of the License, or

// (at your option) any later version.

//

// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU Affero General Public License for more details.

//

// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License



/**

 * WARNING: This is an upgradable contract. Be careful not to disrupt

 * the existing storage layout when making upgrades to the contract. In particular,

 * existing fields should not be removed and should not have their types changed.

 * The order of field declarations must not be changed, and new fields must be added

 * below all existing declarations.

 *

 * The base contracts and the order in which they are declared must not be changed.

 * New fields must not be added to base contracts (unless the base contract has

 * reserved placeholder fields for this purpose).

 *

 * See https://docs.zeppelinos.org/docs/writing_contracts.html for more info.

*/



pragma solidity ^0.5.0;









///@author DeFiZap

///@notice this contract implements one click conversion from ETH to unipool liquidity tokens (cDAI)



interface IuniswapFactory {

    function getExchange(address token) external view returns (address exchange);

}





interface IuniswapExchange {

    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);

    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);

    function balanceOf(address _owner) external view returns (uint256);

    function transfer(address _to, uint256 _value) external returns (bool);

    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);

}



interface IKyberInterface {

    function swapTokentoToken(IERC20 _srcTokenAddressIERC20, IERC20 _dstTokenAddress, uint _slippageValue, address _toWhomToIssue) external payable returns (uint);

}



interface Compound {

    function approve ( address spender, uint256 amount ) external returns ( bool );

    function mint ( uint256 mintAmount ) external returns ( uint256 );

    function balanceOf(address _owner) external view returns (uint256 balance);

    function transfer(address _to, uint _value) external returns (bool success);

}





contract UniSwap_ETH_CDAIZap is Initializable {

    using SafeMath for uint;

    // state variables

    

    // - THESE MUST ALWAYS STAY IN THE SAME LAYOUT

    bool private stopped;

    address payable public owner;

    IuniswapFactory public UniSwapFactoryAddress;

    IKyberInterface public KyberInterfaceAddresss;

    IERC20 public NEWDAI_TOKEN_ADDRESS;

    Compound public COMPOUND_TOKEN_ADDRESS;

    



    // events

    event ERC20TokenHoldingsOnConversionDaiChai(uint);

    event ERC20TokenHoldingsOnConversionEthDai(uint);

    event LiquidityTokens(uint);

     

    // circuit breaker modifiers

    modifier stopInEmergency {if (!stopped) _;}

    modifier onlyInEmergency {if (stopped) _;}

    modifier onlyOwner() {

        require(isOwner(), "you are not authorised to call this function");

        _;

    }

    

    

    function initialize() initializer public {

        stopped = false;

        owner = msg.sender;

        UniSwapFactoryAddress = IuniswapFactory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);

        NEWDAI_TOKEN_ADDRESS = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);

        COMPOUND_TOKEN_ADDRESS = Compound(0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643);

        KyberInterfaceAddresss = IKyberInterface(0x16183BE9f0c145fc6c24E1780211F51767382135);

    }



    

    function set_new_UniSwapFactoryAddress(address _new_UniSwapFactoryAddress) public onlyOwner {

        UniSwapFactoryAddress = IuniswapFactory(_new_UniSwapFactoryAddress);

        

    }



    function set_new_DAI_TOKEN_ADDRESS(address _new_DAI_TOKEN_ADDRESS) public onlyOwner {

        NEWDAI_TOKEN_ADDRESS = IERC20(_new_DAI_TOKEN_ADDRESS);

        

    }



    function set_new_cDAI_TokenContractAddress(address _new_cDAI_TokenContractAddress) public onlyOwner {

        COMPOUND_TOKEN_ADDRESS = Compound(address(_new_cDAI_TokenContractAddress));

        

    }



    function set_KyberInterfaceAddresss(IKyberInterface _new_KyberInterfaceAddresss) public onlyOwner {

        KyberInterfaceAddresss = _new_KyberInterfaceAddresss;

    }



    

    

    function LetsInvest(address _src, address _towhomtoissue, uint _MaxslippageValue) public payable stopInEmergency returns (uint) {

        IERC20 ERC20TokenAddress = IERC20(address(COMPOUND_TOKEN_ADDRESS));

        IuniswapExchange UniSwapExchangeContractAddress = IuniswapExchange(UniSwapFactoryAddress.getExchange(address(COMPOUND_TOKEN_ADDRESS)));



        // determining the portion of the incoming ETH to be converted to the ERC20 Token

        uint conversionPortion = SafeMath.div(SafeMath.mul(msg.value, 505), 1000);

        uint non_conversionPortion = SafeMath.sub(msg.value,conversionPortion);



        KyberInterfaceAddresss.swapTokentoToken.value(conversionPortion)(IERC20(_src), NEWDAI_TOKEN_ADDRESS, _MaxslippageValue, address(this));

        uint tokenBalance = NEWDAI_TOKEN_ADDRESS.balanceOf(address(this));

        // conversion of DAI to cDAI

        uint qty2approve = SafeMath.mul(tokenBalance, 3);

        require(NEWDAI_TOKEN_ADDRESS.approve(address(ERC20TokenAddress), qty2approve));

        COMPOUND_TOKEN_ADDRESS.mint(tokenBalance);

        uint ERC20TokenHoldings = ERC20TokenAddress.balanceOf(address(this));

        require (ERC20TokenHoldings > 0, "the conversion did not happen as planned");

        emit ERC20TokenHoldingsOnConversionDaiChai(ERC20TokenHoldings);

        NEWDAI_TOKEN_ADDRESS.approve(address(ERC20TokenAddress), 0);

        ERC20TokenAddress.approve(address(UniSwapExchangeContractAddress),ERC20TokenHoldings);



        // adding Liquidity

        uint max_tokens_ans = getMaxTokens(address(UniSwapExchangeContractAddress), ERC20TokenAddress, non_conversionPortion);

        UniSwapExchangeContractAddress.addLiquidity.value(non_conversionPortion)(1,max_tokens_ans,SafeMath.add(now,1800));

        ERC20TokenAddress.approve(address(UniSwapExchangeContractAddress),0);



        // transferring Liquidity

        uint LiquityTokenHoldings = UniSwapExchangeContractAddress.balanceOf(address(this));

        emit LiquidityTokens(LiquityTokenHoldings);

        UniSwapExchangeContractAddress.transfer(_towhomtoissue, LiquityTokenHoldings);

        ERC20TokenHoldings = ERC20TokenAddress.balanceOf(address(this));

        ERC20TokenAddress.transfer(_towhomtoissue, ERC20TokenHoldings);

        return LiquityTokenHoldings;

    }



    function getMaxTokens(address _UniSwapExchangeContractAddress, IERC20 _ERC20TokenAddress, uint _value) internal view returns (uint) {

        uint contractBalance = address(_UniSwapExchangeContractAddress).balance;

        uint eth_reserve = SafeMath.sub(contractBalance, _value);

        uint token_reserve = _ERC20TokenAddress.balanceOf(_UniSwapExchangeContractAddress);

        uint token_amount = SafeMath.div(SafeMath.mul(_value,token_reserve),eth_reserve) + 1;

        return token_amount;

    }

    



    // incase of half-way error

    function inCaseTokengetsStuck(IERC20 _TokenAddress) onlyOwner public {

        uint qty = _TokenAddress.balanceOf(address(this));

        _TokenAddress.transfer(owner, qty);

    }

    

    // - fallback function let you / anyone send ETH to this wallet without the need to call any function

    function() external payable {

        if (msg.sender != owner) {

            LetsInvest(address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), msg.sender, 5);}

    }

    

// - to Pause the contract

    function toggleContractActive() onlyOwner public {

        stopped = !stopped;

    }

    // - to withdraw any ETH balance sitting in the contract

    function withdraw() onlyOwner public{

        owner.transfer(address(this).balance);

    }

    // - to kill the contract

    function destruct() public onlyOwner {

        selfdestruct(owner);

    }

    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == owner;

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address payable newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address payable newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        owner = newOwner;

    }

    

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\UniSwap_ETH_CHAIZap.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2019-12-19

*/



// File: browser/OpenZepplinReentrancyGuard.sol



pragma solidity ^0.5.0;



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * _Since v2.5.0:_ this module is now much more gas efficient, given net gas

 * metering changes introduced in the Istanbul hardfork.

 */

contract ReentrancyGuard {

    bool private _notEntered;



    constructor () internal {

        // Storing an initial non-zero value makes deployment a bit more

        // expensive, but in exchange the refund on every call to nonReentrant

        // will be lower in amount. Since refunds are capped to a percetange of

        // the total transaction's gas, it is best to keep them low in cases

        // like this one, to increase the likelihood of the full refund coming

        // into effect.

        _notEntered = true;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_notEntered, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _notEntered = false;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _notEntered = true;

    }

}

// File: browser/OpenZepplinIERC20.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

// File: browser/OpenZepplinSafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

// File: browser/Context.sol



pragma solidity ^0.5.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

// File: browser/OpenZepplinOwnable.sol



pragma solidity ^0.5.0;



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address payable public _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address payable msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address payable newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address payable newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

// File: browser/UniSwap_ETH_CHAIZapV3.sol



pragma solidity ^0.5.0;













///@author DeFiZap

///@notice this contract implements one click conversion from ETH to unipool liquidity tokens (CHAI)



interface IuniswapFactory {

    function getExchange(address token) external view returns (address exchange);

}





interface IuniswapExchange {

    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);

    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);

    function balanceOf(address _owner) external view returns (uint256);

    function transfer(address _to, uint256 _value) external returns (bool);

    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);

}



interface IKyberInterface {

    function swapTokentoToken(IERC20 _srcTokenAddressERC20, IERC20 _dstTokenAddress, uint _slippageValue) external payable returns (uint);

}



interface IChaiContract {

    function join(address dst, uint wad) external;

}





contract UniSwap_ETH_CHAIZap is Ownable, ReentrancyGuard {

    using SafeMath for uint;

    

    // events

    event ERC20TokenHoldingsOnConversionDaiChai(uint);

    event ERC20TokenHoldingsOnConversionEthDai(uint);

    event LiquidityTokens(uint);



    

    // state variables

    uint public balance = address(this).balance;

    



    // in relation to the emergency functioning of this contract

    bool private stopped = false;

     

    // circuit breaker modifiers

    modifier stopInEmergency {if (!stopped) _;}

    modifier onlyInEmergency {if (stopped) _;}

    

    function toggleContractActive() onlyOwner public {

        stopped = !stopped;

    }

    

    // - Key Addresses

    IuniswapFactory public UniSwapFactoryAddress = IuniswapFactory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);

    IKyberInterface public KyberInterfaceAddresss;

    IERC20 public NEWDAI_TOKEN_ADDRESS = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);

    IChaiContract public CHAI_TOKEN_ADDRESS = IChaiContract(0x06AF07097C9Eeb7fD685c692751D5C66dB49c215);

    

    function set_KyberInterfaceAddresss(IKyberInterface _new_KyberInterfaceAddresss) public onlyOwner {

        KyberInterfaceAddresss = _new_KyberInterfaceAddresss;

    }

    

    

    function LetsInvest(address _src, address _towhomtoissue, uint _MaxslippageValue) public payable stopInEmergency returns (uint) {

        IERC20 ERC20TokenAddress = IERC20(address(CHAI_TOKEN_ADDRESS));

        IuniswapExchange UniSwapExchangeContractAddress = IuniswapExchange(UniSwapFactoryAddress.getExchange(address(CHAI_TOKEN_ADDRESS)));

        IChaiContract ChaiTokenAddress = IChaiContract(address(CHAI_TOKEN_ADDRESS));



        // determining the portion of the incoming ETH to be converted to the ERC20 Token

        uint conversionPortion = SafeMath.div(SafeMath.mul(msg.value, 505), 1000);

        uint non_conversionPortion = SafeMath.sub(msg.value,conversionPortion);



        KyberInterfaceAddresss.swapTokentoToken.value(conversionPortion)(IERC20(_src), NEWDAI_TOKEN_ADDRESS, _MaxslippageValue);

        uint tokenBalance = NEWDAI_TOKEN_ADDRESS.balanceOf(address(this));

        // conversion of DAI to CHAI

        uint qty2approve = SafeMath.mul(tokenBalance, 3);

        require(NEWDAI_TOKEN_ADDRESS.approve(address(ERC20TokenAddress), qty2approve));

        ChaiTokenAddress.join(address(this), tokenBalance);

        uint ERC20TokenHoldings = ERC20TokenAddress.balanceOf(address(this));

        require (ERC20TokenHoldings > 0, "the conversion did not happen as planned");

        emit ERC20TokenHoldingsOnConversionDaiChai(ERC20TokenHoldings);

        NEWDAI_TOKEN_ADDRESS.approve(address(ERC20TokenAddress), 0);

        ERC20TokenAddress.approve(address(UniSwapExchangeContractAddress),ERC20TokenHoldings);



        // adding Liquidity

        uint max_tokens_ans = getMaxTokens(address(UniSwapExchangeContractAddress), ERC20TokenAddress, non_conversionPortion);

        UniSwapExchangeContractAddress.addLiquidity.value(non_conversionPortion)(1,max_tokens_ans,SafeMath.add(now,1800));

        ERC20TokenAddress.approve(address(UniSwapExchangeContractAddress),0);



        // transferring Liquidity

        uint LiquityTokenHoldings = UniSwapExchangeContractAddress.balanceOf(address(this));

        emit LiquidityTokens(LiquityTokenHoldings);

        UniSwapExchangeContractAddress.transfer(_towhomtoissue, LiquityTokenHoldings);

        ERC20TokenHoldings = ERC20TokenAddress.balanceOf(address(this));

        ERC20TokenAddress.transfer(_towhomtoissue, ERC20TokenHoldings);

        return LiquityTokenHoldings;

    }



    function getMaxTokens(address _UniSwapExchangeContractAddress, IERC20 _ERC20TokenAddress, uint _value) internal view returns (uint) {

        uint contractBalance = address(_UniSwapExchangeContractAddress).balance;

        uint eth_reserve = SafeMath.sub(contractBalance, _value);

        uint token_reserve = _ERC20TokenAddress.balanceOf(_UniSwapExchangeContractAddress);

        uint token_amount = SafeMath.div(SafeMath.mul(_value,token_reserve),eth_reserve) + 1;

        return token_amount;

    }

    

    





    

    // incase of half-way error

    function withdrawERC20Token (address _TokenContractAddress) public onlyOwner {

        IERC20 ERC20TokenAddress = IERC20(_TokenContractAddress);

        uint StuckERC20Holdings = ERC20TokenAddress.balanceOf(address(this));

        ERC20TokenAddress.transfer(_owner, StuckERC20Holdings);

    }

    

    function set_new_CHAI_TokenContractAddress(address _new_CHAI_TokenContractAddress) public onlyOwner {

        CHAI_TOKEN_ADDRESS = IChaiContract(address(_new_CHAI_TokenContractAddress));

        

    }

    



    // fx in relation to ETH held by the contract sent by the owner

    

    // - this function lets you deposit ETH into this wallet

    function depositETH() public payable  onlyOwner {

        balance += msg.value;

    }

    

    // - fallback function let you / anyone send ETH to this wallet without the need to call any function

    function() external payable {

        if (msg.sender == _owner) {

            depositETH();

        } else {

            LetsInvest(address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee), msg.sender, 3);

        }

    }

    



    

    // - to withdraw any ETH balance sitting in the contract

    function withdraw() public onlyOwner {

        _owner.transfer(address(this).balance);

    }

    

    function _selfDestruct() public onlyOwner {

        selfdestruct(_owner);

    }

    

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\UniSwap_ETH_DAIZap.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2019-12-08

*/



// File: contracts/OpenZepplinOwnable.sol



pragma solidity ^0.5.0;



contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address payable public _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address payable msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address payable newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address payable newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/OpenZepplinSafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: contracts/OpenZepplinIERC20.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: contracts/OpenZepplinReentrancyGuard.sol



pragma solidity ^0.5.0;



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * _Since v2.5.0:_ this module is now much more gas efficient, given net gas

 * metering changes introduced in the Istanbul hardfork.

 */

contract ReentrancyGuard {

    bool private _notEntered;



    constructor () internal {

        // Storing an initial non-zero value makes deployment a bit more

        // expensive, but in exchange the refund on every call to nonReentrant

        // will be lower in amount. Since refunds are capped to a percetange of

        // the total transaction's gas, it is best to keep them low in cases

        // like this one, to increase the likelihood of the full refund coming

        // into effect.

        _notEntered = true;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_notEntered, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _notEntered = false;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _notEntered = true;

    }

}



// File: contracts/UniSwap_ETH_DAIZap.sol



pragma solidity ^0.5.0;











// the objective of this contract is only to get the exchange price of the assets from the uniswap indexed



interface UniSwapAddLiquityV2_General {

    function LetsInvest(address _TokenContractAddress, address _towhomtoissue) external payable returns (uint);

}



contract UniSwap_ETH_DAIZap is Ownable, ReentrancyGuard {

    using SafeMath for uint;



    // state variables

    uint public balance = address(this).balance;

    

    

    // in relation to the emergency functioning of this contract

    bool private stopped = false;

     

    // circuit breaker modifiers

    modifier stopInEmergency {if (!stopped) _;}

    modifier onlyInEmergency {if (stopped) _;}

    

    address public DAI_TokenContractAddress;

    UniSwapAddLiquityV2_General public UniSwapAddLiquityV2_GeneralAddress;

    



    constructor(address _DAI_TokenContractAddress, UniSwapAddLiquityV2_General _UniSwapAddLiquityV2_GeneralAddress ) public {

        DAI_TokenContractAddress = _DAI_TokenContractAddress;

        UniSwapAddLiquityV2_GeneralAddress = _UniSwapAddLiquityV2_GeneralAddress;

    }



    function set_new_DAI_TokenContractAddress(address _new_DAI_TokenContractAddress) public onlyOwner {

        DAI_TokenContractAddress = _new_DAI_TokenContractAddress;

    }



    function set_new_UniSwapAddLiquityV2_GeneralAddress(UniSwapAddLiquityV2_General _new_UniSwapAddLiquityV2_GeneralAddress) public onlyOwner {

        UniSwapAddLiquityV2_GeneralAddress = _new_UniSwapAddLiquityV2_GeneralAddress;

    }



    function LetsInvest() public payable stopInEmergency {

        UniSwapAddLiquityV2_GeneralAddress.LetsInvest.value(msg.value)(DAI_TokenContractAddress, address(msg.sender));



    }





    // - this function lets you deposit ETH into this wallet

    function depositETH() public payable  onlyOwner {

        balance += msg.value;

    }

    

    // - fallback function let you / anyone send ETH to this wallet without the need to call any function

    function() external payable {

        if (msg.sender == _owner) {

            depositETH();

        } else {

            LetsInvest();

        }

    }

    

    // - to withdraw any ETH balance sitting in the contract

    function withdraw() public onlyOwner {

        _owner.transfer(address(this).balance);

    }





}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Vesper_ZapIn_V1.sol
File type: .sol
/**
 *Submitted for verification at Etherscan.io on 2021-05-15
*/

// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract adds liquidity to Vesper Vaults using ETH or ERC20 Tokens.

// File: oz/GSN/Context.sol

pragma solidity ^0.5.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor() internal {}

    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: oz/ownership/Ownable.sol

pragma solidity ^0.5.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: oz/token/ERC20/IERC20.sol

pragma solidity ^0.5.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */
interface IERC20 {
    function decimals() external view returns (uint8);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

// File: oz/math/SafeMath.sol

pragma solidity ^0.5.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

// File: oz/utils/Address.sol

pragma solidity ^0.5.5;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;

        bytes32 accountHash =
            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            codehash := extcodehash(account)
        }
        return (codehash != accountHash && codehash != 0x0);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     *
     * _Available since v2.4.0._
     */
    function toPayable(address account)
        internal
        pure
        returns (address payable)
    {
        return address(uint160(account));
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     *
     * _Available since v2.4.0._
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            "Address: insufficient balance"
        );

        // solhint-disable-next-line avoid-call-value
        (bool success, ) = recipient.call.value(amount)("");
        require(
            success,
            "Address: unable to send value, recipient may have reverted"
        );
    }
}

// File: oz/token/ERC20/SafeERC20.sol

pragma solidity ^0.5.0;

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance =
            token.allowance(address(this), spender).add(value);
        callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance =
            token.allowance(address(this), spender).sub(
                value,
                "SafeERC20: decreased allowance below zero"
            );
        callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {
            // Return data is optional
            // solhint-disable-next-line max-line-length
            require(
                abi.decode(returndata, (bool)),
                "SafeERC20: ERC20 operation did not succeed"
            );
        }
    }
}

// File: contracts/_base/ZapBaseV1.sol

pragma solidity ^0.5.7;

contract ZapBaseV1 is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;
    bool public stopped = false;

    // if true, goodwill is not deducted
    mapping(address => bool) public feeWhitelist;

    uint256 public goodwill;
    // % share of goodwill (0-100 %)
    uint256 affiliateSplit;
    // restrict affiliates
    mapping(address => bool) public affiliates;
    // affiliate => token => amount
    mapping(address => mapping(address => uint256)) public affiliateBalance;
    // token => amount
    mapping(address => uint256) public totalAffiliateBalance;

    address internal constant ETHAddress =
        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    constructor(uint256 _goodwill, uint256 _affiliateSplit) public {
        goodwill = _goodwill;
        affiliateSplit = _affiliateSplit;
    }

    // circuit breaker modifiers
    modifier stopInEmergency {
        if (stopped) {
            revert("Temporarily Paused");
        } else {
            _;
        }
    }

    function _getBalance(address token)
        internal
        view
        returns (uint256 balance)
    {
        if (token == address(0)) {
            balance = address(this).balance;
        } else {
            balance = IERC20(token).balanceOf(address(this));
        }
    }

    function _approveToken(address token, address spender) internal {
        IERC20 _token = IERC20(token);
        if (_token.allowance(address(this), spender) > 0) return;
        else {
            _token.safeApprove(spender, uint256(-1));
        }
    }

    function _approveToken(
        address token,
        address spender,
        uint256 amount
    ) internal {
        IERC20 _token = IERC20(token);
        _token.safeApprove(spender, 0);
        _token.safeApprove(spender, amount);
    }

    // - to Pause the contract
    function toggleContractActive() public onlyOwner {
        stopped = !stopped;
    }

    function set_feeWhitelist(address zapAddress, bool status)
        external
        onlyOwner
    {
        feeWhitelist[zapAddress] = status;
    }

    function set_new_goodwill(uint256 _new_goodwill) public onlyOwner {
        require(
            _new_goodwill >= 0 && _new_goodwill <= 100,
            "GoodWill Value not allowed"
        );
        goodwill = _new_goodwill;
    }

    function set_new_affiliateSplit(uint256 _new_affiliateSplit)
        external
        onlyOwner
    {
        require(
            _new_affiliateSplit <= 100,
            "Affiliate Split Value not allowed"
        );
        affiliateSplit = _new_affiliateSplit;
    }

    function set_affiliate(address _affiliate, bool _status)
        external
        onlyOwner
    {
        affiliates[_affiliate] = _status;
    }

    ///@notice Withdraw goodwill share, retaining affilliate share
    function withdrawTokens(address[] calldata tokens) external onlyOwner {
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 qty;

            if (tokens[i] == ETHAddress) {
                qty = address(this).balance.sub(
                    totalAffiliateBalance[tokens[i]]
                );
                Address.sendValue(Address.toPayable(owner()), qty);
            } else {
                qty = IERC20(tokens[i]).balanceOf(address(this)).sub(
                    totalAffiliateBalance[tokens[i]]
                );
                IERC20(tokens[i]).safeTransfer(owner(), qty);
            }
        }
    }

    ///@notice Withdraw affilliate share, retaining goodwill share
    function affilliateWithdraw(address[] calldata tokens) external {
        uint256 tokenBal;
        for (uint256 i = 0; i < tokens.length; i++) {
            tokenBal = affiliateBalance[msg.sender][tokens[i]];
            affiliateBalance[msg.sender][tokens[i]] = 0;
            totalAffiliateBalance[tokens[i]] = totalAffiliateBalance[tokens[i]]
                .sub(tokenBal);

            if (tokens[i] == ETHAddress) {
                Address.sendValue(msg.sender, tokenBal);
            } else {
                IERC20(tokens[i]).safeTransfer(msg.sender, tokenBal);
            }
        }
    }

    function() external payable {
        require(msg.sender != tx.origin, "Do not send ETH directly");
    }
}

// File: contracts/_base/ZapInBaseV2.sol

pragma solidity ^0.5.7;

contract ZapInBaseV2 is ZapBaseV1 {
    function _pullTokens(
        address token,
        uint256 amount,
        address affiliate,
        bool enableGoodwill,
        bool shouldSellEntireBalance
    ) internal returns (uint256 value) {
        uint256 totalGoodwillPortion;

        if (token == address(0)) {
            require(msg.value > 0, "No eth sent");

            // subtract goodwill
            totalGoodwillPortion = _subtractGoodwill(
                ETHAddress,
                msg.value,
                affiliate,
                enableGoodwill
            );

            return msg.value.sub(totalGoodwillPortion);
        }
        require(amount > 0, "Invalid token amount");
        require(msg.value == 0, "Eth sent with token");

        //transfer token
        if (shouldSellEntireBalance) {
            require(
                Address.isContract(msg.sender),
                "ERR: shouldSellEntireBalance is true for EOA"
            );
            amount = IERC20(token).allowance(msg.sender, address(this));
        }
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);

        // subtract goodwill
        totalGoodwillPortion = _subtractGoodwill(
            token,
            amount,
            affiliate,
            enableGoodwill
        );

        return amount.sub(totalGoodwillPortion);
    }

    function _subtractGoodwill(
        address token,
        uint256 amount,
        address affiliate,
        bool enableGoodwill
    ) internal returns (uint256 totalGoodwillPortion) {
        bool whitelisted = feeWhitelist[msg.sender];
        if (enableGoodwill && !whitelisted && goodwill > 0) {
            totalGoodwillPortion = SafeMath.div(
                SafeMath.mul(amount, goodwill),
                10000
            );

            if (affiliates[affiliate]) {
                if (token == address(0)) {
                    token = ETHAddress;
                }

                uint256 affiliatePortion =
                    totalGoodwillPortion.mul(affiliateSplit).div(100);
                affiliateBalance[affiliate][token] = affiliateBalance[
                    affiliate
                ][token]
                    .add(affiliatePortion);
                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(
                    affiliatePortion
                );
            }
        }
    }
}

// File: contracts/Vesper/Vesper_ZapIn_V1.sol

// SPDX-License-Identifier: GPLv2

pragma solidity ^0.5.7;

interface IVesper {
    function token() external view returns (address);

    function deposit(uint256 amount) external;
}

contract Vesper_ZapIn_V1 is ZapInBaseV2 {
    // calldata only accepted for approved zap contracts
    mapping(address => bool) public approvedTargets;

    event zapIn(address sender, address pool, uint256 tokensRec);

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        public
        ZapBaseV1(_goodwill, _affiliateSplit)
    {}

    /**
    @notice This function adds liquidity to a Vesper vaults with ETH or ERC20 tokens
    @param fromToken The token used for entry (address(0) if ether)
    @param amountIn The amount of fromToken to invest
    @param toVault Vesper vault address
    @param minVaultTokens The minimum acceptable quantity vault tokens to receive. Reverts otherwise
    @param swapTarget Excecution target for the swap or zap
    @param swapData DEX or Zap data
    @param affiliate Affiliate address
    @param shouldSellEntireBalance True if amountIn is determined at execution time (i.e. contract is caller)
    @return tokensReceived- Quantity of Vault tokens received
     */
    function ZapIn(
        address fromToken,
        uint256 amountIn,
        address toVault,
        uint256 minVaultTokens,
        address swapTarget,
        bytes calldata swapData,
        address affiliate,
        bool shouldSellEntireBalance
    ) external payable stopInEmergency returns (uint256 tokensReceived) {
        require(
            approvedTargets[swapTarget] || swapTarget == address(0),
            "Target not Authorized"
        );

        // get incoming tokens
        uint256 toInvest =
            _pullTokens(
                fromToken,
                amountIn,
                affiliate,
                true,
                shouldSellEntireBalance
            );

        address underlyingVaultToken = IVesper(toVault).token();

        // get intermediate token
        uint256 intermediateAmt =
            _fillQuote(
                fromToken,
                underlyingVaultToken,
                toInvest,
                swapTarget,
                swapData
            );

        // Deposit to Vault
        tokensReceived = _vaultDeposit(
            intermediateAmt,
            toVault,
            minVaultTokens
        );
    }

    function _vaultDeposit(
        uint256 amount,
        address toVault,
        uint256 minTokensRec
    ) internal returns (uint256 tokensReceived) {
        address underlyingVaultToken = IVesper(toVault).token();

        _approveToken(underlyingVaultToken, toVault);

        uint256 iniYVaultBal = IERC20(toVault).balanceOf(address(this));
        IVesper(toVault).deposit(amount);
        tokensReceived = IERC20(toVault).balanceOf(address(this)).sub(
            iniYVaultBal
        );
        require(tokensReceived >= minTokensRec, "Err: High Slippage");

        IERC20(toVault).safeTransfer(msg.sender, tokensReceived);
        emit zapIn(msg.sender, toVault, tokensReceived);
    }

    function _fillQuote(
        address _fromTokenAddress,
        address toToken,
        uint256 _amount,
        address _swapTarget,
        bytes memory swapCallData
    ) internal returns (uint256 amtBought) {
        uint256 valueToSend;

        if (_fromTokenAddress == toToken) {
            return _amount;
        }

        if (_fromTokenAddress == address(0)) {
            valueToSend = _amount;
        } else {
            _approveToken(_fromTokenAddress, _swapTarget);
        }

        uint256 iniBal = _getBalance(toToken);
        (bool success, ) = _swapTarget.call.value(valueToSend)(swapCallData);
        require(success, "Error Swapping Tokens 1");
        uint256 finalBal = _getBalance(toToken);

        amtBought = finalBal.sub(iniBal);
    }

    function setApprovedTargets(
        address[] calldata targets,
        bool[] calldata isApproved
    ) external onlyOwner {
        require(targets.length == isApproved.length, "Invalid Input length");

        for (uint256 i = 0; i < targets.length; i++) {
            approvedTargets[targets[i]] = isApproved[i];
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ZapBaseV1.sol
File type: .sol
pragma solidity ^0.5.7;



import "../oz/ownership/Ownable.sol";

import "../oz/token/ERC20/SafeERC20.sol";



contract ZapBaseV1 is Ownable {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;

    bool public stopped = false;



    // if true, goodwill is not deducted

    mapping(address => bool) public feeWhitelist;



    uint256 public goodwill;

    // % share of goodwill (0-100 %)

    uint256 affiliateSplit;

    // restrict affiliates

    mapping(address => bool) public affiliates;

    // affiliate => token => amount

    mapping(address => mapping(address => uint256)) public affiliateBalance;

    // token => amount

    mapping(address => uint256) public totalAffiliateBalance;



    address internal constant ETHAddress =

        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    constructor(uint256 _goodwill, uint256 _affiliateSplit) public {

        goodwill = _goodwill;

        affiliateSplit = _affiliateSplit;

    }



    // circuit breaker modifiers

    modifier stopInEmergency {

        if (stopped) {

            revert("Temporarily Paused");

        } else {

            _;

        }

    }



    function _getBalance(address token)

        internal

        view

        returns (uint256 balance)

    {

        if (token == address(0)) {

            balance = address(this).balance;

        } else {

            balance = IERC20(token).balanceOf(address(this));

        }

    }



    function _approveToken(address token, address spender) internal {

        IERC20 _token = IERC20(token);

        if (_token.allowance(address(this), spender) > 0) return;

        else {

            _token.safeApprove(spender, uint256(-1));

        }

    }



    function _approveToken(

        address token,

        address spender,

        uint256 amount

    ) internal {

        IERC20 _token = IERC20(token);

        _token.safeApprove(spender, 0);

        _token.safeApprove(spender, amount);

    }



    // - to Pause the contract

    function toggleContractActive() public onlyOwner {

        stopped = !stopped;

    }



    function set_feeWhitelist(address zapAddress, bool status)

        external

        onlyOwner

    {

        feeWhitelist[zapAddress] = status;

    }



    function set_new_goodwill(uint256 _new_goodwill) public onlyOwner {

        require(

            _new_goodwill >= 0 && _new_goodwill <= 100,

            "GoodWill Value not allowed"

        );

        goodwill = _new_goodwill;

    }



    function set_new_affiliateSplit(uint256 _new_affiliateSplit)

        external

        onlyOwner

    {

        require(

            _new_affiliateSplit <= 100,

            "Affiliate Split Value not allowed"

        );

        affiliateSplit = _new_affiliateSplit;

    }



    function set_affiliate(address _affiliate, bool _status)

        external

        onlyOwner

    {

        affiliates[_affiliate] = _status;

    }



    ///@notice Withdraw goodwill share, retaining affilliate share

    function withdrawTokens(address[] calldata tokens) external onlyOwner {

        for (uint256 i = 0; i < tokens.length; i++) {

            uint256 qty;



            if (tokens[i] == ETHAddress) {

                qty = address(this).balance.sub(

                    totalAffiliateBalance[tokens[i]]

                );

                Address.sendValue(Address.toPayable(owner()), qty);

            } else {

                qty = IERC20(tokens[i]).balanceOf(address(this)).sub(

                    totalAffiliateBalance[tokens[i]]

                );

                IERC20(tokens[i]).safeTransfer(owner(), qty);

            }

        }

    }



    ///@notice Withdraw affilliate share, retaining goodwill share

    function affilliateWithdraw(address[] calldata tokens) external {

        uint256 tokenBal;

        for (uint256 i = 0; i < tokens.length; i++) {

            tokenBal = affiliateBalance[msg.sender][tokens[i]];

            affiliateBalance[msg.sender][tokens[i]] = 0;

            totalAffiliateBalance[tokens[i]] = totalAffiliateBalance[tokens[i]]

                .sub(tokenBal);



            if (tokens[i] == ETHAddress) {

                Address.sendValue(msg.sender, tokenBal);

            } else {

                IERC20(tokens[i]).safeTransfer(msg.sender, tokenBal);

            }

        }

    }



    function() external payable {

        require(msg.sender != tx.origin, "Do not send ETH directly");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ZapBaseV2.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;



import "../oz/0.8.0/access/Ownable.sol";

import "../oz/0.8.0/token/ERC20/utils/SafeERC20.sol";



abstract contract ZapBaseV2 is Ownable {

    using SafeERC20 for IERC20;

    bool public stopped = false;



    // if true, goodwill is not deducted

    mapping(address => bool) public feeWhitelist;



    uint256 public goodwill;

    // % share of goodwill (0-100 %)

    uint256 affiliateSplit;

    // restrict affiliates

    mapping(address => bool) public affiliates;

    // affiliate => token => amount

    mapping(address => mapping(address => uint256)) public affiliateBalance;

    // token => amount

    mapping(address => uint256) public totalAffiliateBalance;

    // swapTarget => approval status

    mapping(address => bool) public approvedTargets;



    address internal constant ETHAddress =

        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    constructor(uint256 _goodwill, uint256 _affiliateSplit) {

        goodwill = _goodwill;

        affiliateSplit = _affiliateSplit;

    }



    // circuit breaker modifiers

    modifier stopInEmergency {

        if (stopped) {

            revert("Temporarily Paused");

        } else {

            _;

        }

    }



    function _getBalance(address token)

        internal

        view

        returns (uint256 balance)

    {

        if (token == address(0)) {

            balance = address(this).balance;

        } else {

            balance = IERC20(token).balanceOf(address(this));

        }

    }



    function _approveToken(address token, address spender) internal {

        IERC20 _token = IERC20(token);

        if (_token.allowance(address(this), spender) > 0) return;

        else {

            _token.safeApprove(spender, type(uint256).max);

        }

    }



    function _approveToken(

        address token,

        address spender,

        uint256 amount

    ) internal {

        IERC20(token).safeApprove(spender, 0);

        IERC20(token).safeApprove(spender, amount);

    }



    // - to Pause the contract

    function toggleContractActive() public onlyOwner {

        stopped = !stopped;

    }



    function set_feeWhitelist(address zapAddress, bool status)

        external

        onlyOwner

    {

        feeWhitelist[zapAddress] = status;

    }



    function set_new_goodwill(uint256 _new_goodwill) public onlyOwner {

        require(

            _new_goodwill >= 0 && _new_goodwill <= 100,

            "GoodWill Value not allowed"

        );

        goodwill = _new_goodwill;

    }



    function set_new_affiliateSplit(uint256 _new_affiliateSplit)

        external

        onlyOwner

    {

        require(

            _new_affiliateSplit <= 100,

            "Affiliate Split Value not allowed"

        );

        affiliateSplit = _new_affiliateSplit;

    }



    function set_affiliate(address _affiliate, bool _status)

        external

        onlyOwner

    {

        affiliates[_affiliate] = _status;

    }



    ///@notice Withdraw goodwill share, retaining affilliate share

    function withdrawTokens(address[] calldata tokens) external onlyOwner {

        for (uint256 i = 0; i < tokens.length; i++) {

            uint256 qty;



            if (tokens[i] == ETHAddress) {

                qty = address(this).balance - totalAffiliateBalance[tokens[i]];



                Address.sendValue(payable(owner()), qty);

            } else {

                qty =

                    IERC20(tokens[i]).balanceOf(address(this)) -

                    totalAffiliateBalance[tokens[i]];

                IERC20(tokens[i]).safeTransfer(owner(), qty);

            }

        }

    }



    ///@notice Withdraw affilliate share, retaining goodwill share

    function affilliateWithdraw(address[] calldata tokens) external {

        uint256 tokenBal;

        for (uint256 i = 0; i < tokens.length; i++) {

            tokenBal = affiliateBalance[msg.sender][tokens[i]];

            affiliateBalance[msg.sender][tokens[i]] = 0;

            totalAffiliateBalance[tokens[i]] =

                totalAffiliateBalance[tokens[i]] -

                tokenBal;



            if (tokens[i] == ETHAddress) {

                Address.sendValue(payable(msg.sender), tokenBal);

            } else {

                IERC20(tokens[i]).safeTransfer(msg.sender, tokenBal);

            }

        }

    }



    function setApprovedTargets(

        address[] calldata targets,

        bool[] calldata isApproved

    ) external onlyOwner {

        require(targets.length == isApproved.length, "Invalid Input length");



        for (uint256 i = 0; i < targets.length; i++) {

            approvedTargets[targets[i]] = isApproved[i];

        }

    }



    receive() external payable {

        require(msg.sender != tx.origin, "Do not send ETH directly");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ZapBaseV2_1.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;



import "../oz/0.8.0/access/Ownable.sol";

import "../oz/0.8.0/token/ERC20/utils/SafeERC20.sol";



abstract contract ZapBaseV2_1 is Ownable {

    using SafeERC20 for IERC20;

    bool public stopped = false;



    // if true, goodwill is not deducted

    mapping(address => bool) public feeWhitelist;



    uint256 public goodwill;

    // % share of goodwill (0-100 %)

    uint256 affiliateSplit;

    // restrict affiliates

    mapping(address => bool) public affiliates;

    // affiliate => token => amount

    mapping(address => mapping(address => uint256)) public affiliateBalance;

    // token => amount

    mapping(address => uint256) public totalAffiliateBalance;

    // swapTarget => approval status

    mapping(address => bool) public approvedTargets;



    address internal constant ETHAddress =

        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    address internal constant ZapperAdmin =

        0x3CE37278de6388532C3949ce4e886F365B14fB56;



    constructor(uint256 _goodwill, uint256 _affiliateSplit) {

        goodwill = _goodwill;

        affiliateSplit = _affiliateSplit;

    }



    // circuit breaker modifiers

    modifier stopInEmergency {

        if (stopped) {

            revert("Paused");

        } else {

            _;

        }

    }



    function _getBalance(address token)

        internal

        view

        returns (uint256 balance)

    {

        if (token == address(0)) {

            balance = address(this).balance;

        } else {

            balance = IERC20(token).balanceOf(address(this));

        }

    }



    function _approveToken(address token, address spender) internal {

        IERC20 _token = IERC20(token);

        if (_token.allowance(address(this), spender) > 0) return;

        else {

            _token.safeApprove(spender, type(uint256).max);

        }

    }



    function _approveToken(

        address token,

        address spender,

        uint256 amount

    ) internal {

        IERC20(token).safeApprove(spender, 0);

        IERC20(token).safeApprove(spender, amount);

    }



    // - to Pause the contract

    function toggleContractActive() public onlyOwner {

        stopped = !stopped;

    }



    function set_feeWhitelist(address zapAddress, bool status)

        external

        onlyOwner

    {

        feeWhitelist[zapAddress] = status;

    }



    function set_new_goodwill(uint256 _new_goodwill) public onlyOwner {

        require(

            _new_goodwill >= 0 && _new_goodwill <= 100,

            "GoodWill Value not allowed"

        );

        goodwill = _new_goodwill;

    }



    function set_new_affiliateSplit(uint256 _new_affiliateSplit)

        external

        onlyOwner

    {

        require(

            _new_affiliateSplit <= 100,

            "Affiliate Split Value not allowed"

        );

        affiliateSplit = _new_affiliateSplit;

    }



    function set_affiliate(address _affiliate, bool _status)

        external

        onlyOwner

    {

        affiliates[_affiliate] = _status;

    }



    ///@notice Withdraw goodwill share, retaining affilliate share

    function withdrawTokens(address[] calldata tokens) external onlyOwner {

        for (uint256 i = 0; i < tokens.length; i++) {

            uint256 qty;



            if (tokens[i] == ETHAddress) {

                qty = address(this).balance - totalAffiliateBalance[tokens[i]];



                Address.sendValue(payable(owner()), qty);

            } else {

                qty =

                    IERC20(tokens[i]).balanceOf(address(this)) -

                    totalAffiliateBalance[tokens[i]];

                IERC20(tokens[i]).safeTransfer(owner(), qty);

            }

        }

    }



    ///@notice Withdraw affilliate share, retaining goodwill share

    function affilliateWithdraw(address[] calldata tokens) external {

        uint256 tokenBal;

        for (uint256 i = 0; i < tokens.length; i++) {

            tokenBal = affiliateBalance[msg.sender][tokens[i]];

            affiliateBalance[msg.sender][tokens[i]] = 0;

            totalAffiliateBalance[tokens[i]] =

                totalAffiliateBalance[tokens[i]] -

                tokenBal;



            if (tokens[i] == ETHAddress) {

                Address.sendValue(payable(msg.sender), tokenBal);

            } else {

                IERC20(tokens[i]).safeTransfer(msg.sender, tokenBal);

            }

        }

    }



    function setApprovedTargets(

        address[] calldata targets,

        bool[] calldata isApproved

    ) external onlyOwner {

        require(targets.length == isApproved.length, "Invalid Input length");



        for (uint256 i = 0; i < targets.length; i++) {

            approvedTargets[targets[i]] = isApproved[i];

        }

    }



    function _subtractGoodwill(

        address token,

        uint256 amount,

        address affiliate,

        bool enableGoodwill

    ) internal returns (uint256 totalGoodwillPortion) {

        bool whitelisted = feeWhitelist[msg.sender];

        if (enableGoodwill && !whitelisted && goodwill > 0) {

            totalGoodwillPortion = (amount * goodwill) / 10000;



            if (affiliates[affiliate]) {

                if (token == address(0)) {

                    token = ETHAddress;

                }



                uint256 affiliatePortion =

                    (totalGoodwillPortion * affiliateSplit) / 100;

                affiliateBalance[affiliate][token] += affiliatePortion;

                totalAffiliateBalance[token] += affiliatePortion;

            }

        }

    }



    receive() external payable {

        require(msg.sender != tx.origin, "Do not send ETH directly");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ZapInBaseV3.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0



pragma solidity ^0.8.0;

import "./ZapBaseV2.sol";



abstract contract ZapInBaseV3 is ZapBaseV2 {

    using SafeERC20 for IERC20;



    function _pullTokens(

        address token,

        uint256 amount,

        address affiliate,

        bool enableGoodwill,

        bool shouldSellEntireBalance

    ) internal returns (uint256 value) {

        uint256 totalGoodwillPortion;



        if (token == address(0)) {

            require(msg.value > 0, "No eth sent");



            // subtract goodwill

            totalGoodwillPortion = _subtractGoodwill(

                ETHAddress,

                msg.value,

                affiliate,

                enableGoodwill

            );



            return msg.value - totalGoodwillPortion;

        }

        require(amount > 0, "Invalid token amount");

        require(msg.value == 0, "Eth sent with token");



        //transfer token

        if (shouldSellEntireBalance) {

            require(

                Address.isContract(msg.sender),

                "ERR: shouldSellEntireBalance is true for EOA"

            );

            amount = IERC20(token).allowance(msg.sender, address(this));

        }

        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);



        // subtract goodwill

        totalGoodwillPortion = _subtractGoodwill(

            token,

            amount,

            affiliate,

            enableGoodwill

        );



        return amount - totalGoodwillPortion;

    }



    function _subtractGoodwill(

        address token,

        uint256 amount,

        address affiliate,

        bool enableGoodwill

    ) internal returns (uint256 totalGoodwillPortion) {

        bool whitelisted = feeWhitelist[msg.sender];

        if (enableGoodwill && !whitelisted && goodwill > 0) {

            totalGoodwillPortion = (amount * goodwill) / 10000;



            if (affiliates[affiliate]) {

                if (token == address(0)) {

                    token = ETHAddress;

                }



                uint256 affiliatePortion =

                    (totalGoodwillPortion * affiliateSplit) / 100;

                affiliateBalance[affiliate][token] += affiliatePortion;

                totalAffiliateBalance[token] += affiliatePortion;

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ZapInBaseV3_1.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0



pragma solidity ^0.8.0;

import "./ZapBaseV2_1.sol";



abstract contract ZapInBaseV3_1 is ZapBaseV2_1 {

    using SafeERC20 for IERC20;



    /**

    @dev Transfer tokens (including ETH) from msg.sender to this contract

    @param token The ERC20 token to transfer to this contract (0 address if ETH)

    @return Quantity of tokens transferred to this contract

     */

    function _pullTokens(

        address token,

        uint256 amount,

        address affiliate,

        bool enableGoodwill

    ) internal returns (uint256) {

        uint256 totalGoodwillPortion;



        if (token == address(0)) {

            require(msg.value > 0, "No eth sent");



            // subtract goodwill

            totalGoodwillPortion = _subtractGoodwill(

                ETHAddress,

                msg.value,

                affiliate,

                enableGoodwill

            );



            return msg.value - totalGoodwillPortion;

        }



        require(amount > 0, "Invalid token amount");

        require(msg.value == 0, "Eth sent with token");



        //transfer token



        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);



        // subtract goodwill

        totalGoodwillPortion = _subtractGoodwill(

            token,

            amount,

            affiliate,

            enableGoodwill

        );



        return amount - totalGoodwillPortion;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ZapOutBaseV2.sol
File type: .sol
pragma solidity ^0.5.7;



import "./ZapBaseV1.sol";



contract ZapOutBaseV2_1 is ZapBaseV1 {

    /**

    @dev Transfer tokens from msg.sender to this contract

    @param token The ERC20 token to transfer to this contract

    @param shouldSellEntireBalance If True transfers entrire allowable amount from another contract

    @return Quantity of tokens transferred to this contract

     */

    function _pullTokens(

        address token,

        uint256 amount,

        bool shouldSellEntireBalance

    ) internal returns (uint256) {

        if (shouldSellEntireBalance) {

            require(

                Address.isContract(msg.sender),

                "ERR: shouldSellEntireBalance is true for EOA"

            );



            IERC20 _token = IERC20(token);

            uint256 allowance = _token.allowance(msg.sender, address(this));

            _token.safeTransferFrom(msg.sender, address(this), allowance);



            return allowance;

        } else {

            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);



            return amount;

        }

    }



    function _subtractGoodwill(

        address token,

        uint256 amount,

        address affiliate,

        bool enableGoodwill

    ) internal returns (uint256 totalGoodwillPortion) {

        bool whitelisted = feeWhitelist[msg.sender];

        if (enableGoodwill && !whitelisted && goodwill > 0) {

            totalGoodwillPortion = SafeMath.div(

                SafeMath.mul(amount, goodwill),

                10000

            );



            if (affiliates[affiliate]) {

                if (token == address(0)) {

                    token = ETHAddress;

                }



                uint256 affiliatePortion =

                    totalGoodwillPortion.mul(affiliateSplit).div(100);

                affiliateBalance[affiliate][token] = affiliateBalance[

                    affiliate

                ][token]

                    .add(affiliatePortion);

                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(

                    affiliatePortion

                );

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ZapOutBaseV3.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0



pragma solidity ^0.8.0;

import "./ZapBaseV2.sol";



abstract contract ZapOutBaseV3 is ZapBaseV2 {

    using SafeERC20 for IERC20;



    /**

        @dev Transfer tokens from msg.sender to this contract

        @param token The ERC20 token to transfer to this contract

        @param shouldSellEntireBalance If True transfers entrire allowable amount from another contract

        @return Quantity of tokens transferred to this contract

     */

    function _pullTokens(

        address token,

        uint256 amount,

        bool shouldSellEntireBalance

    ) internal returns (uint256) {

        if (shouldSellEntireBalance) {

            require(

                Address.isContract(msg.sender),

                "ERR: shouldSellEntireBalance is true for EOA"

            );



            uint256 allowance =

                IERC20(token).allowance(msg.sender, address(this));

            IERC20(token).safeTransferFrom(

                msg.sender,

                address(this),

                allowance

            );



            return allowance;

        } else {

            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);



            return amount;

        }

    }



    function _subtractGoodwill(

        address token,

        uint256 amount,

        address affiliate,

        bool enableGoodwill

    ) internal returns (uint256 totalGoodwillPortion) {

        bool whitelisted = feeWhitelist[msg.sender];

        if (enableGoodwill && !whitelisted && goodwill > 0) {

            totalGoodwillPortion = (amount * goodwill) / 10000;



            if (affiliates[affiliate]) {

                if (token == address(0)) {

                    token = ETHAddress;

                }



                uint256 affiliatePortion =

                    (totalGoodwillPortion * affiliateSplit) / 100;

                affiliateBalance[affiliate][token] += affiliatePortion;

                totalAffiliateBalance[token] += affiliatePortion;

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\ZapOutBaseV3_1.sol
File type: .sol
// SPDX-License-Identifier: GPL-2.0



pragma solidity ^0.8.0;

import "./ZapBaseV2_1.sol";



abstract contract ZapOutBaseV3_1 is ZapBaseV2_1 {

    using SafeERC20 for IERC20;



    /**

    @dev Transfer tokens from msg.sender to this contract

    @param token The ERC20 token to transfer to this contract

    @return Quantity of tokens transferred to this contract

     */

    function _pullTokens(address token, uint256 amount)

        internal

        returns (uint256)

    {

        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);



        return amount;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Zapper_Matic_Bridge_V1.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract swaps and bridges ETH/Tokens to Matic/Polygon
// SPDX-License-Identifier: GPLv2

pragma solidity ^0.8.0;

import "../../_base/ZapBaseV2.sol";

// PoS Bridge
interface IRootChainManager {
    function depositEtherFor(address user) external payable;

    function depositFor(
        address user,
        address rootToken,
        bytes calldata depositData
    ) external;

    function tokenToType(address) external returns (bytes32);

    function typeToPredicate(bytes32) external returns (address);
}

// Plasma Bridge
interface IDepositManager {
    function depositERC20ForUser(
        address _token,
        address _user,
        uint256 _amount
    ) external;
}

interface IWETH {
    function deposit() external payable;
}

contract Zapper_Matic_Bridge_V1_1 is ZapBaseV2 {
    using SafeERC20 for IERC20;

    address private constant wethTokenAddress =
        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    IRootChainManager public rootChainManager =
        IRootChainManager(0xA0c68C638235ee32657e8f720a23ceC1bFc77C77);
    IDepositManager public depositManager =
        IDepositManager(0x401F6c983eA34274ec46f84D70b31C151321188b);

    address private constant maticAddress =
        0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0;

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        ZapBaseV2(_goodwill, _affiliateSplit)
    {
        _approveToken(maticAddress, address(depositManager));

        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;
    }

    /**
    @notice Bridge from Ethereum to Matic
    @notice Use index 0 for primary swap and index 1 for matic swap
    @param fromToken Address of the token to swap from
    @param toToken Address of the token to bridge
    @param swapAmounts Quantites of fromToken to swap to toToken and matic
    @param minTokensRec Minimum acceptable quantity of swapped tokens and/or matic
    @param swapTargets Execution targets for swaps
    @param swapData DEX swap data
    @param affiliate Affiliate address
    */
    function ZapBridge(
        address fromToken,
        address toToken,
        uint256[2] calldata swapAmounts,
        uint256[2] calldata minTokensRec,
        address[2] calldata swapTargets,
        bytes[2] calldata swapData,
        address affiliate
    ) external payable stopInEmergency {
        uint256[2] memory toInvest =
            _pullTokens(fromToken, swapAmounts, affiliate);

        if (swapAmounts[0] > 0) {
            // Token swap
            uint256 toTokenAmt =
                _fillQuote(
                    fromToken,
                    toInvest[0],
                    toToken,
                    swapTargets[0],
                    swapData[0]
                );
            require(toTokenAmt >= minTokensRec[0], "ERR: High Slippage 1");

            _bridgeToken(toToken, toTokenAmt);
        }

        // Matic swap
        if (swapAmounts[1] > 0) {
            uint256 maticAmount =
                _fillQuote(
                    fromToken,
                    toInvest[1],
                    maticAddress,
                    swapTargets[1],
                    swapData[1]
                );
            require(maticAmount >= minTokensRec[1], "ERR: High Slippage 2");

            _bridgeMatic(maticAmount);
        }
    }

    function _bridgeToken(address toToken, uint256 toTokenAmt) internal {
        if (toToken == address(0)) {
            rootChainManager.depositEtherFor{ value: toTokenAmt }(msg.sender);
        } else {
            bytes32 tokenType = rootChainManager.tokenToType(toToken);
            address predicate = rootChainManager.typeToPredicate(tokenType);
            _approveToken(toToken, predicate);
            rootChainManager.depositFor(
                msg.sender,
                toToken,
                abi.encode(toTokenAmt)
            );
        }
    }

    function _bridgeMatic(uint256 maticAmount) internal {
        depositManager.depositERC20ForUser(
            maticAddress,
            msg.sender,
            maticAmount
        );
    }

    // 0x Swap
    function _fillQuote(
        address fromToken,
        uint256 amount,
        address toToken,
        address swapTarget,
        bytes memory swapCallData
    ) internal returns (uint256 amtBought) {
        if (fromToken == wethTokenAddress && toToken == address(0)) {
            IWETH(wethTokenAddress).deposit{ value: amount }();
            return amount;
        }

        uint256 valueToSend;

        if (fromToken == toToken) {
            return amount;
        }

        if (fromToken == address(0)) {
            valueToSend = amount;
        } else {
            _approveToken(fromToken, swapTarget);
        }

        uint256 iniBal = _getBalance(toToken);
        require(approvedTargets[swapTarget], "Target not Authorized");
        (bool success, ) = swapTarget.call{ value: valueToSend }(swapCallData);
        require(success, "Error Swapping Tokens");
        uint256 finalBal = _getBalance(toToken);

        amtBought = finalBal - iniBal;
    }

    function _pullTokens(
        address fromToken,
        uint256[2] memory swapAmounts,
        address affiliate
    ) internal returns (uint256[2] memory toInvest) {
        if (fromToken == address(0)) {
            require(msg.value > 0, "No eth sent");
            require(
                swapAmounts[0] + (swapAmounts[1]) == msg.value,
                "msg.value != fromTokenAmounts"
            );
        } else {
            require(msg.value == 0, "Eth sent with token");

            // transfer token
            IERC20(fromToken).safeTransferFrom(
                msg.sender,
                address(this),
                swapAmounts[0] + (swapAmounts[1])
            );
        }

        if (swapAmounts[0] > 0) {
            toInvest[0] =
                swapAmounts[0] -
                (_subtractGoodwill(fromToken, swapAmounts[0], affiliate));
        }

        if (swapAmounts[1] > 0) {
            toInvest[1] =
                swapAmounts[1] -
                (_subtractGoodwill(fromToken, swapAmounts[1], affiliate));
        }
    }

    function _subtractGoodwill(
        address token,
        uint256 amount,
        address affiliate
    ) internal returns (uint256 totalGoodwillPortion) {
        bool whitelisted = feeWhitelist[msg.sender];
        if (!whitelisted && goodwill > 0) {
            totalGoodwillPortion = (amount * goodwill) / 10000;

            if (affiliates[affiliate]) {
                if (token == address(0)) {
                    token = ETHAddress;
                }

                uint256 affiliatePortion =
                    (totalGoodwillPortion * affiliateSplit) / 100;
                affiliateBalance[affiliate][token] += affiliatePortion;
                totalAffiliateBalance[token] += affiliatePortion;
            }
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Zapper_Matic_Bridge_V1_2.sol
File type: .sol
/**
 *Submitted for verification at Etherscan.io on 2021-03-17
*/

// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract swaps and bridges ETH/Tokens to Matic/Polygon
// SPDX-License-Identifier: GPLv2

// File: contracts/oz/GSN/Context.sol

pragma solidity ^0.5.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor() internal {}

    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: contracts/oz/ownership/Ownable.sol

pragma solidity ^0.5.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// File: contracts/oz/token/ERC20/IERC20.sol

pragma solidity ^0.5.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

// File: contracts/oz/math/SafeMath.sol

pragma solidity ^0.5.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

// File: contracts/oz/utils/Address.sol

pragma solidity ^0.5.5;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;


            bytes32 accountHash
         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            codehash := extcodehash(account)
        }
        return (codehash != accountHash && codehash != 0x0);
    }

    /**
     * @dev Converts an `address` into `address payable`. Note that this is
     * simply a type cast: the actual underlying value is not changed.
     *
     * _Available since v2.4.0._
     */
    function toPayable(address account)
        internal
        pure
        returns (address payable)
    {
        return address(uint160(account));
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     *
     * _Available since v2.4.0._
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            "Address: insufficient balance"
        );

        // solhint-disable-next-line avoid-call-value
        (bool success, ) = recipient.call.value(amount)("");
        require(
            success,
            "Address: unable to send value, recipient may have reverted"
        );
    }
}

// File: contracts/oz/token/ERC20/SafeERC20.sol

pragma solidity ^0.5.0;

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(
            value
        );
        callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(
            value,
            "SafeERC20: decreased allowance below zero"
        );
        callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {
            // Return data is optional
            // solhint-disable-next-line max-line-length
            require(
                abi.decode(returndata, (bool)),
                "SafeERC20: ERC20 operation did not succeed"
            );
        }
    }
}

// File: contracts/_base/ZapBaseV1.sol

pragma solidity ^0.5.7;

contract ZapBaseV1 is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;
    bool public stopped = false;

    // if true, goodwill is not deducted
    mapping(address => bool) public feeWhitelist;

    uint256 public goodwill;
    // % share of goodwill (0-100 %)
    uint256 affiliateSplit;
    // restrict affiliates
    mapping(address => bool) public affiliates;
    // affiliate => token => amount
    mapping(address => mapping(address => uint256)) public affiliateBalance;
    // token => amount
    mapping(address => uint256) public totalAffiliateBalance;

    address
        internal constant ETHAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    constructor(uint256 _goodwill, uint256 _affiliateSplit) public {
        goodwill = _goodwill;
        affiliateSplit = _affiliateSplit;
    }

    // circuit breaker modifiers
    modifier stopInEmergency {
        if (stopped) {
            revert("Temporarily Paused");
        } else {
            _;
        }
    }

    function _getBalance(address token)
        internal
        view
        returns (uint256 balance)
    {
        if (token == address(0)) {
            balance = address(this).balance;
        } else {
            balance = IERC20(token).balanceOf(address(this));
        }
    }

    function _approveToken(address token, address spender) internal {
        IERC20 _token = IERC20(token);
        if (_token.allowance(address(this), spender) > 0) return;
        else {
            _token.safeApprove(spender, uint256(-1));
        }
    }

    // - to Pause the contract
    function toggleContractActive() public onlyOwner {
        stopped = !stopped;
    }

    function set_feeWhitelist(address zapAddress, bool status)
        external
        onlyOwner
    {
        feeWhitelist[zapAddress] = status;
    }

    function set_new_goodwill(uint256 _new_goodwill) public onlyOwner {
        require(
            _new_goodwill >= 0 && _new_goodwill <= 100,
            "GoodWill Value not allowed"
        );
        goodwill = _new_goodwill;
    }

    function set_new_affiliateSplit(uint256 _new_affiliateSplit)
        external
        onlyOwner
    {
        require(
            _new_affiliateSplit <= 100,
            "Affiliate Split Value not allowed"
        );
        affiliateSplit = _new_affiliateSplit;
    }

    function set_affiliate(address _affiliate, bool _status)
        external
        onlyOwner
    {
        affiliates[_affiliate] = _status;
    }

    ///@notice Withdraw goodwill share, retaining affilliate share
    function withdrawTokens(address[] calldata tokens) external onlyOwner {
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 qty;

            if (tokens[i] == ETHAddress) {
                qty = address(this).balance.sub(
                    totalAffiliateBalance[tokens[i]]
                );
                Address.sendValue(Address.toPayable(owner()), qty);
            } else {
                qty = IERC20(tokens[i]).balanceOf(address(this)).sub(
                    totalAffiliateBalance[tokens[i]]
                );
                IERC20(tokens[i]).safeTransfer(owner(), qty);
            }
        }
    }

    ///@notice Withdraw affilliate share, retaining goodwill share
    function affilliateWithdraw(address[] calldata tokens) external {
        uint256 tokenBal;
        for (uint256 i = 0; i < tokens.length; i++) {
            tokenBal = affiliateBalance[msg.sender][tokens[i]];
            affiliateBalance[msg.sender][tokens[i]] = 0;
            totalAffiliateBalance[tokens[i]] = totalAffiliateBalance[tokens[i]]
                .sub(tokenBal);

            if (tokens[i] == ETHAddress) {
                Address.sendValue(msg.sender, tokenBal);
            } else {
                IERC20(tokens[i]).safeTransfer(msg.sender, tokenBal);
            }
        }
    }

    function() external payable {
        require(msg.sender != tx.origin, "Do not send ETH directly");
    }
}

// File: contracts/MaticBridge/Zapper_Matic_Bridge_V1.sol

pragma solidity ^0.5.7;
pragma experimental ABIEncoderV2;

// PoS Bridge
interface IRootChainManager {
    function depositEtherFor(address user) external payable;

    function depositFor(
        address user,
        address rootToken,
        bytes calldata depositData
    ) external;

    function tokenToType(address) external returns (bytes32);

    function typeToPredicate(bytes32) external returns (address);
}

// Plasma Bridge
interface IDepositManager {
    function depositERC20ForUser(
        address _token,
        address _user,
        uint256 _amount
    ) external;
}

contract Zapper_Matic_Bridge_V1_2 is ZapBaseV1 {
    IRootChainManager public rootChainManager;
    IDepositManager public depositManager;

    address
        private constant maticAddress = 0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0;

    constructor(uint256 _goodwill, uint256 _affiliateSplit)
        public
        ZapBaseV1(_goodwill, _affiliateSplit)
    {
        rootChainManager = IRootChainManager(
            0xA0c68C638235ee32657e8f720a23ceC1bFc77C77
        );
        depositManager = IDepositManager(
            0x401F6c983eA34274ec46f84D70b31C151321188b
        );
        IERC20(maticAddress).approve(address(depositManager), uint256(-1));
    }

    /**
    @notice Bridge from Ethereum to Matic
    @notice Use index 0 for primary swap and index 1 for matic swap
    @param fromToken Address of the token to swap from
    @param toToken Address of the token to bridge
    @param swapAmounts Quantites of fromToken to swap to toToken and matic
    @param minTokensRec Minimum acceptable quantity of swapped tokens and/or matic
    @param swapTargets Execution targets for swaps
    @param swapData DEX swap data
    @param affiliate Affiliate address
    */
    function ZapBridge(
        address fromToken,
        address toToken,
        uint256[2] calldata swapAmounts,
        uint256[2] calldata minTokensRec,
        address[2] calldata swapTargets,
        bytes[2] calldata swapData,
        address affiliate
    ) external payable {
        uint256[2] memory toInvest = _pullTokens(
            fromToken,
            swapAmounts,
            affiliate
        );

        if (swapAmounts[0] > 0) {
            // Token swap
            uint256 toTokenAmt = _fillQuote(
                fromToken,
                toInvest[0],
                toToken,
                swapTargets[0],
                swapData[0]
            );
            require(toTokenAmt >= minTokensRec[0], "ERR: High Slippage 1");

            _bridgeToken(toToken, toTokenAmt);
        }

        // Matic swap
        if (swapAmounts[1] > 0) {
            uint256 maticAmount = _fillQuote(
                fromToken,
                toInvest[1],
                maticAddress,
                swapTargets[1],
                swapData[1]
            );
            require(maticAmount >= minTokensRec[1], "ERR: High Slippage 2");

            _bridgeMatic(maticAmount);
        }
    }

    function _bridgeToken(address toToken, uint256 toTokenAmt) internal {
        if (toToken == address(0)) {
            rootChainManager.depositEtherFor.value(toTokenAmt)(msg.sender);
        } else {
            bytes32 tokenType = rootChainManager.tokenToType(toToken);
            address predicate = rootChainManager.typeToPredicate(tokenType);
            _approveToken(toToken, predicate);
            rootChainManager.depositFor(
                msg.sender,
                toToken,
                abi.encode(toTokenAmt)
            );
        }
    }

    function _bridgeMatic(uint256 maticAmount) internal {
        depositManager.depositERC20ForUser(
            maticAddress,
            msg.sender,
            maticAmount
        );
    }

    // 0x Swap
    function _fillQuote(
        address fromToken,
        uint256 amount,
        address toToken,
        address swapTarget,
        bytes memory swapCallData
    ) internal returns (uint256 amtBought) {
        uint256 valueToSend;

        if (fromToken == toToken) {
            return amount;
        }

        if (fromToken == address(0)) {
            valueToSend = amount;
        } else {
            _approveToken(fromToken, swapTarget);
        }

        uint256 iniBal = _getBalance(toToken);
        (bool success, ) = swapTarget.call.value(valueToSend)(swapCallData);
        require(success, "Error Swapping Tokens");
        uint256 finalBal = _getBalance(toToken);

        amtBought = finalBal.sub(iniBal);
    }

    function _pullTokens(
        address fromToken,
        uint256[2] memory swapAmounts,
        address affiliate
    ) internal returns (uint256[2] memory toInvest) {
        if (fromToken == address(0)) {
            require(msg.value > 0, "No eth sent");
            require(
                swapAmounts[0].add(swapAmounts[1]) == msg.value,
                "msg.value != fromTokenAmounts"
            );
        } else {
            require(msg.value == 0, "Eth sent with token");

            // transfer token
            IERC20(fromToken).safeTransferFrom(
                msg.sender,
                address(this),
                swapAmounts[0].add(swapAmounts[1])
            );
        }

        if (swapAmounts[0] > 0) {
            toInvest[0] = swapAmounts[0].sub(
                _subtractGoodwill(fromToken, swapAmounts[0], affiliate)
            );
        }

        if (swapAmounts[1] > 0) {
            toInvest[1] = swapAmounts[1].sub(
                _subtractGoodwill(fromToken, swapAmounts[1], affiliate)
            );
        }
    }

    function _subtractGoodwill(
        address token,
        uint256 amount,
        address affiliate
    ) internal returns (uint256 totalGoodwillPortion) {
        bool whitelisted = feeWhitelist[msg.sender];
        if (!whitelisted && goodwill > 0) {
            totalGoodwillPortion = SafeMath.div(
                SafeMath.mul(amount, goodwill),
                10000
            );

            if (affiliates[affiliate]) {
                if (token == address(0)) {
                    token = ETHAddress;
                }

                uint256 affiliatePortion = totalGoodwillPortion
                    .mul(affiliateSplit)
                    .div(100);
                affiliateBalance[affiliate][token] = affiliateBalance[affiliate][token]
                    .add(affiliatePortion);
                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(
                    affiliatePortion
                );
            }
        }
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Zapper_NFT_V1.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract manages Zapper NFTs and allows minting at any time if verified by a signer
// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "./ERC1155/ERC1155.sol";
import "./access/Ownable.sol";
import "./utils/Counters.sol";
import "./SignatureVerifier/SignatureVerifier.sol";

contract Zapper_NFT_V1_0_5 is ERC1155, Ownable, SignatureVerifier {
    using Counters for Counters.Counter;
    Counters.Counter private ID;

    bool public paused = false;
    string public name;
    string public symbol;

    // Mapping from token ID to token URI
    mapping(uint256 => string) private idToUri;

    // Mapping from token ID to token supply
    mapping(uint256 => uint256) private tokenSupply;

    // Mapping from token ID to account status
    mapping(uint256 => mapping(address => bool)) public hasMinted;

    constructor(
        string memory _name,
        string memory _symbol,
        string memory _uri,
        address _signer,
        address manager
    ) ERC1155(_uri) SignatureVerifier(_signer) {
        name = _name;
        symbol = _symbol;

        transferOwnership(manager);
    }

    modifier pausable {
        if (paused) {
            revert("Paused");
        } else {
            _;
        }
    }

    /**
     * @dev Creates a new NFT type
     * @param _cid Content identifier
     * @param _data Data to pass if receiver is contract
     * @return _id The newly created token ID
     */
    function create(string calldata _cid, bytes calldata _data)
        external
        onlyOwner
        returns (uint256 _id)
    {
        require(bytes(_cid).length > 0, "Err: Missing Content Identifier");

        _id = _nextId();

        _mint(msg.sender, _id, 0, _data);

        string memory _uri = _createUri(_cid);
        idToUri[_id] = _uri;

        emit URI(_uri, _id);
    }

    /**
     * @dev Mints an existing NFT type
     * @notice Enforces a maximum of 1 minting event per NFT type per account
     * @param _account Account to mint NFT to (i.e. the owner)
     * @param _id ID (i.e. type) of  NFT to mint
     * @param _signature Verified signature granting _account an NFT
     * @param _data Data to pass if receiver is contract
     */
    function mint(
        address _account,
        uint256 _id,
        bytes calldata _signature,
        bytes calldata _data
    ) public pausable {
        require(_exists(_id), "Err: Invalid ID");
        require(!hasMinted[_id][_account], "Err: Already Minted");
        require(verify(_account, _id, _signature), "Err: Invalid Signature");

        hasMinted[_id][_account] = true;
        _mint(_account, _id, 1, _data);

        tokenSupply[_id]++;
    }

    /**
     * @dev Batch mints multiple different existing NFT types
     * @notice Enforces a maximum of 1 minting event per account per NFT type
     * @param _account Account to mint NFT to (i.e. the owner)
     * @param _ids IDs of the type of NFT to mint
     * @param _signatures Verified signatures granting _account an NFT
     * @param _data Data to pass if receiver is contract
     */
    function batchMint(
        address _account,
        uint256[] calldata _ids,
        bytes[] calldata _signatures,
        bytes[] calldata _data
    ) external pausable {
        for (uint256 i = 0; i < _ids.length; i++) {
            mint(_account, _ids[i], _signatures[i], _data[i]);
        }
    }

    function _createUri(string memory _cid)
        internal
        view
        returns (string memory _uri)
    {
        string memory baseUri = super.uri(0);
        return string(abi.encodePacked(baseUri, _cid));
    }

    function _nextId() internal returns (uint256 id) {
        ID.increment();
        return ID.current();
    }

    function _exists(uint256 _id) internal view returns (bool) {
        return (bytes(idToUri[_id]).length > 0);
    }

    /**
     * @dev Returns the uri of a token given its ID
     * @param _id ID of the token to query
     * @return uri of the token or an empty string if it does not exist
     */
    function uri(uint256 _id) public view override returns (string memory) {
        return idToUri[_id];
    }

    /**
     * @dev Returns the total quantity for a token ID
     * @param _id ID of the token to query
     * @return amount of token in existence
     */
    function totalSupply(uint256 _id) public view returns (uint256) {
        return tokenSupply[_id];
    }

    /**
     * @dev Pause or unpause the minting and creation of NFTs
     */
    function pause() public onlyOwner {
        paused = !paused;
    }

    /**
     * @dev Update the signer
     */
    function updateSigner(address signer) public onlyOwner {
        _signer = signer;
    }
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\Zapper\contracts\Zapper_NFT_V2.sol
File type: .sol
// [?[?[?[?[[????[[
// ^TTTTUXTT[XTT[XTT[XTTTT빠XTT[???XTTTT빠U
// ??XT빠UX빠X빠[??X빠???[??U
// XTT빠??XTTUXTTT빠?XTTT빠?XTT빠??XTT[???XTT빠??U
// [U??UU?????U?????[U??U[U?????U
// ^TTTTTT빠^T빠??^T빠^T빠?????^T빠?????^TTTTTT빠^T빠??^T빠^T빠^T빠?????^T빠
// Copyright (C) 2021 zapper

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//

///@author Zapper
///@notice This contract manages Zapper V2 NFTs and Volts.
/// Volts can be claimed through quests in order to mint various NFTs.
/// Crafting combines NFTs of the same type into higher tier NFTs. NFTs
/// can also be redemeed for Volts.

// SPDX-License-Identifier: GPL-2.0

pragma solidity ^0.8.0;
import "./ERC1155/ERC1155.sol";
import "./access/Ownable.sol";
import "./SignatureVerifier/SignatureVerifier_V2.sol";
import "./ERC1155/IERC1155.sol";
import "./utils/Strings.sol";

contract Zapper_NFT_V2_0_1 is ERC1155, Ownable, SignatureVerifier_V2 {
    // Used in pausable modifier
    bool public paused;

    // NFT name
    string public name;

    // NFT symbol
    string public symbol;

    // Season deadline
    uint256 public deadline;

    // Modifier to apply to cost of NFT when redeeming in bps
    uint256 public redeemModifier = 7500;

    // Quantity of NFTs consumed per crafting event
    uint256 public craftingRequirement = 3;

    // Mapping from token ID to token supply
    mapping(uint256 => uint256) private tokenSupply;

    // Mapping of accessory contracts that have permission to mint
    mapping(address => bool) public accessoryContract;

    // Total Volt supply
    uint256 public voltSupply;

    // Mapping from account to Volt balance
    mapping(address => uint256) public voltBalance;

    // Mapping from token ID to token existence
    mapping(uint256 => bool) private exists;

    // Mapping for the rarity classes for use in crafting
    mapping(uint256 => uint256) public nextRarity;

    // Mapping from token ID to token cost in volts
    mapping(uint256 => uint256) public cost;

    // Mapping from account to nonce
    mapping(address => uint256) public nonces;

    // Emitted when `account` claims Volts
    event ClaimVolts(
        address indexed account,
        uint256 voltsRecieved,
        uint256 nonce
    );

    // Emitted when `account` burns Volts
    event BurnVolts(address indexed account, uint256 voltsBurned);

    // Emitted when `account` mints one or more NFTs by spending Volts
    event Mint(address indexed account, uint256 voltsSpent);

    // Emitted when `account` redeems Volts by burning one or more NFTs
    event Redeem(address indexed account, uint256 voltsRecieved);

    // Emitted when `account` crafts one or more of the same NFT
    event Craft(address indexed account, uint256 craftID);

    // Emitted when `account` crafts multiple different NFTs
    event CraftBatch(address indexed account, uint256[] craftIDs);

    // Emitted when a new NFT type is added
    event Add(uint256 id, uint256 cost, uint256 nextRarity);

    // Emitted when the baseURI is updated
    event updateBaseURI(string uri);

    modifier pausable {
        require(!paused, "Paused");
        _;
    }

    modifier beforeDeadline {
        require(block.timestamp <= deadline, "Deadline elapsed");
        _;
    }

    constructor(
        string memory _name,
        string memory _symbol,
        string memory _uri,
        address signer,
        address manager,
        uint256 _deadline
    ) ERC1155(_uri) SignatureVerifier_V2(signer) {
        name = _name;
        symbol = _symbol;
        deadline = _deadline;
        transferOwnership(manager);
    }

    /**
     * @dev Adds a new NFT and initializes crafting params
     * @param costs An array of the cost of each ID. 0 if it cannot
     * be crafted
     * @param nextRarities An array of higher rarity IDs which can be
     * crafted from the ID. 0 if max rarity.
     */
    function add(
        uint256[] calldata ids,
        uint256[] calldata costs,
        uint256[] calldata nextRarities
    ) external onlyOwner {
        require(
            ids.length == costs.length && ids.length == nextRarities.length,
            "Mismatched array lengths"
        );

        for (uint256 i = 0; i < ids.length; i++) {
            uint256 newId = ids[i];
            require(!exists[newId], "ID already exists");
            require(newId != 0, "Invalid ID");

            exists[newId] = true;

            cost[newId] = costs[i];
            nextRarity[newId] = nextRarities[i];

            emit Add(newId, costs[i], nextRarities[i]);
        }
    }

    /**
     * @notice Claims Volts earned through quests
     * @param voltsEarned The quantity of Volts being awarded
     * @param signature The signature granting msg.sender the volts
     */
    function claimVolts(uint256 voltsEarned, bytes calldata signature)
        external
        pausable
        beforeDeadline
    {
        bytes32 messageHash =
            getMessageHash(msg.sender, voltsEarned, nonces[msg.sender]++);

        require(verify(messageHash, signature), "Invalid Signature");

        _createVolts(voltsEarned);

        emit ClaimVolts(msg.sender, voltsEarned, nonces[msg.sender]);
    }

    /**
     * @notice Burns Volts
     * @param voltsBurned The quantity of Volts being burned
     */
    function burnVolts(uint256 voltsBurned) external pausable {
        _burnVolts(voltsBurned);

        emit BurnVolts(msg.sender, voltsBurned);
    }

    /**
     * @notice Mints a desired quantity of a single NFT ID
     * in exchange for Volts
     * @param id The ID of the  NFT to mint
     * @param quantity The quantity of the NFT to mint
     */
    function mint(uint256 id, uint256 quantity) external pausable {
        require(exists[id], "Invalid ID");

        uint256 voltsSpent;

        if (!accessoryContract[msg.sender]) {
            require(cost[id] > 0, "Price not set");

            voltsSpent = cost[id] * quantity;
            _burnVolts(voltsSpent);
        }

        _mint(msg.sender, id, quantity, new bytes(0));

        emit Mint(msg.sender, voltsSpent);
    }

    /**
     * @notice Batch Mints desired quantities of different NFT IDs
     * in exchange for Volts
     * @param ids An array consisting of the IDs of the NFTs to mint
     * @param quantities  An array consisting of the quantities of the NFTs to mint
     */
    function mintBatch(uint256[] calldata ids, uint256[] calldata quantities)
        external
        pausable
    {
        require(ids.length == quantities.length, "Mismatched array lengths");

        uint256 voltsSpent;

        if (!accessoryContract[msg.sender]) {
            for (uint256 i = 0; i < ids.length; i++) {
                require(exists[ids[i]], "Invalid ID");
                require(cost[ids[i]] > 0, "Price not set");

                voltsSpent += cost[ids[i]] * quantities[i];
            }

            _burnVolts(voltsSpent);
        } else {
            for (uint256 i = 0; i < ids.length; i++) {
                require(exists[ids[i]], "Invalid ID");
            }
        }

        _mintBatch(msg.sender, ids, quantities, new bytes(0));

        emit Mint(msg.sender, voltsSpent);
    }

    /**
     * @notice Burns an NFT
     * @dev Does not award Volts!
     * @param id The ID of the  NFT to burn
     * @param quantity The quantity of the NFT to burn
     */
    function burn(uint256 id, uint256 quantity) external pausable {
        _burn(msg.sender, id, quantity);
    }

    /**
     * @notice Batch burns NFTs
     * @dev Does not award Volts!
     * @param ids An array consisting of the IDs of the  NFTs to burn
     * @param quantities An array consisting of the quantities
     * of each NFT to burn
     */
    function burnBatch(uint256[] calldata ids, uint256[] calldata quantities)
        external
        pausable
    {
        _burnBatch(msg.sender, ids, quantities);
    }

    /**
     * @notice Redeems an NFT for Volts. Redeeming NFTs is
     * subject to a modifier which returns some percentage of
     * the full cost of the NFT
     * @param id ID of the  NFT to redeem
     * @param quantity The quantity of the NFT being redeemed
     */
    function redeem(uint256 id, uint256 quantity) external pausable {
        require(cost[id] > 0, "Cannot redeem this type");

        _burn(msg.sender, id, quantity);

        uint256 voltsRecieved = (cost[id] * quantity * redeemModifier) / 10000;

        _createVolts(voltsRecieved);

        emit Redeem(msg.sender, voltsRecieved);
    }

    /**
     * @notice Redeems multiple NFTs for Volts. Redeeming NFTs is
     * subject to a modifier which returns some percentage of
     * the full cost of the NFT
     * @param ids An array consisting of the IDs of the NFTs to redeem
     * @param quantities An array consisting of the quantities of
     * each NFT to redeem
     */
    function redeemBatch(uint256[] calldata ids, uint256[] calldata quantities)
        external
        pausable
    {
        _burnBatch(msg.sender, ids, quantities);

        uint256 voltsRecieved;

        for (uint256 i = 0; i < ids.length; i++) {
            require(cost[ids[i]] > 0, "Cannot redeem this type");

            voltsRecieved +=
                (cost[ids[i]] * quantities[i] * redeemModifier) /
                10000;
        }

        _createVolts(voltsRecieved);

        emit Redeem(msg.sender, voltsRecieved);
    }

    /**
     * @notice Crafts higher tier NFTs with lower tier NFTs
     * @param id ID of the NFT used for crafting
     * @param quantity The quantity of id to consume in crafting
     */
    function craft(uint256 id, uint256 quantity) external pausable {
        uint256 craftID = nextRarity[id];
        require(craftID != 0, "Already maximum rarity");
        require(
            quantity % craftingRequirement == 0,
            "Incorrect quantity for crafting"
        );

        _burn(msg.sender, id, quantity);

        uint256 craftQuantity = quantity / craftingRequirement;

        _mint(msg.sender, craftID, craftQuantity, new bytes(0));

        emit Craft(msg.sender, craftID);
    }

    /**
     * @notice Crafts multiple different higher tier NFTs with
     * lower tier NFTs
     * @param ids An array consisting of the IDs of the NFT used for crafting
     * @param quantities An array consisting of the quantities of the NFT
     * to consume in crafting
     */
    function craftBatch(uint256[] calldata ids, uint256[] calldata quantities)
        external
        pausable
    {
        _burnBatch(msg.sender, ids, quantities);

        uint256[] memory craftQuantities = new uint256[](quantities.length);
        uint256[] memory craftIds = new uint256[](ids.length);

        for (uint256 i = 0; i < ids.length; i++) {
            uint256 craftID = nextRarity[ids[i]];
            require(craftID != 0, "Already maximum rarity");
            require(
                quantities[i] % craftingRequirement == 0,
                "Incorrect quantity for crafting"
            );

            craftIds[i] = craftID;
            craftQuantities[i] = quantities[i] / craftingRequirement;
        }

        _mintBatch(msg.sender, craftIds, craftQuantities, new bytes(0));

        emit CraftBatch(msg.sender, craftIds);
    }

    /**
     * @dev Function to set the URI for all NFT IDs
     */
    function setBaseURI(string calldata _uri) external onlyOwner {
        _setURI(_uri);

        emit updateBaseURI(_uri);
    }

    /**
     * @dev Returns the URI of a token given its ID
     * @param id ID of the token to query
     * @return uri of the token or an empty string if it does not exist
     */
    function uri(uint256 id) public view override returns (string memory) {
        require(exists[id], "URI query for nonexistent token");

        string memory baseUri = super.uri(0);
        return string(abi.encodePacked(baseUri, Strings.toString(id)));
    }

    /**
     * @notice Maps the rarity classes and Volt costs
     * for use in crafting
     * @param ids An array of the  IDs being updated
     * @param costs An array of the cost of each ID
     * @param nextRarities An array of higher rarity IDs which
     * can be crafted from the ID
     */
    function updateCraftingParameters(
        uint256[] calldata ids,
        uint256[] calldata costs,
        uint256[] calldata nextRarities
    ) external onlyOwner {
        require(
            ids.length == costs.length && ids.length == nextRarities.length,
            "Mismatched array lengths"
        );

        for (uint256 i = 0; i < ids.length; i++) {
            require(exists[ids[i]], "ID does not exist");

            cost[ids[i]] = costs[i];
            nextRarity[ids[i]] = nextRarities[i];
        }
    }

    /**
     * @dev Updates the modifier which is used when redeeming
     * NFTs for Volts
     */
    function updateRedeemModifier(uint256 _redeemModifier) external onlyOwner {
        redeemModifier = _redeemModifier;
    }

    /**
     * @dev Updates the crafting requirement modifier which determines
     * the quantity of NFTs that are burned in order to craft
     * higher rarity NFTs
     */
    function updateCraftingRequirement(uint256 _craftingRequirement)
        external
        onlyOwner
    {
        craftingRequirement = _craftingRequirement;
    }

    /**
     * @dev Updates the mapping of accessory contracts which have
     * special permssions to mint NFTs (lootbox, bridge, etc.)
     */
    function updateAccessoryContracts(address _accessoryContract, bool allowed)
        external
        onlyOwner
    {
        accessoryContract[_accessoryContract] = allowed;
    }

    /**
     * @dev Updates the deadline after which Volts can no longer be claimed
     */
    function updateDeadline(uint256 _deadline) external onlyOwner {
        deadline = _deadline;
    }

    /**
     * @dev Returns the total quantity for a token ID
     * @param id ID of the token to query
     * @return amount of token in existence
     */
    function totalSupply(uint256 id) external view returns (uint256) {
        return tokenSupply[id];
    }

    /**
     * @dev Pause or unpause the contract
     */
    function pause() external onlyOwner {
        paused = !paused;
    }

    /**
     * @dev Function to return the message hash that will be
     * signed by the signer
     */
    function getMessageHash(
        address account,
        uint256 volts,
        uint256 nonce
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(account, volts, nonce));
    }

    /**
     * @dev Internal override function for minting an NFT
     */
    function _mint(
        address account,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal override {
        super._mint(account, id, amount, data);

        tokenSupply[id] += amount;
    }

    /**
     * @dev Internal override function for batch minting NFTs
     */
    function _mintBatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override {
        super._mintBatch(to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; i++) {
            tokenSupply[ids[i]] += amounts[i];
        }
    }

    /**
     * @dev Internal override function for burning an NFT
     */
    function _burn(
        address account,
        uint256 id,
        uint256 amount
    ) internal override {
        super._burn(account, id, amount);

        tokenSupply[id] -= amount;
    }

    /**
     * @dev Internal override function for batch burning NFTs
     */
    function _burnBatch(
        address account,
        uint256[] memory ids,
        uint256[] memory amounts
    ) internal override {
        super._burnBatch(account, ids, amounts);

        for (uint256 i; i < ids.length; i++) {
            tokenSupply[ids[i]] -= amounts[i];
        }
    }

    /**
     * @dev Internal function to create volts
     */
    function _createVolts(uint256 quantity) internal {
        voltBalance[msg.sender] += quantity;
        voltSupply += quantity;
    }

    /**
     * @dev Internal function to burn volts
     */
    function _burnVolts(uint256 quantity) internal {
        require(
            voltBalance[msg.sender] >= quantity,
            "Insufficient Volt balance"
        );

        voltBalance[msg.sender] -= quantity;
        voltSupply -= quantity;
    }
}

--------------------------------------------------
File End
--------------------------------------------------

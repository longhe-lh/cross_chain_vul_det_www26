{
    "src_chain": {
        "RequestSent1": [
            {
                "crossChainWithSwap": "function crossChainWithSwap(\n BaseCrossChainParams calldata _params,\n string calldata _providerName\n )\n external\n payable\n nonReentrant\n whenNotPaused\n eventEmitter(_params, _providerName)\n {\n IntegratorFeeInfo memory _info = integratorToFeeInfo[\n _params.integrator\n ];\n IERC20(_params.srcInputToken).transferFrom(\n msg.sender,\n address(this),\n _params.srcInputAmount\n );\n accrueFixedCryptoFee(_params.integrator, _info);\n uint256 _amountIn = accrueTokenFees(\n _params.integrator,\n _info,\n _params.srcInputAmount,\n 0,\n _params.srcInputToken\n );\n SmartApprove.smartApprove(\n _params.srcInputToken,\n _amountIn,\n _params.router\n );\n ITestDEX(_params.router).swap(\n _params.srcInputToken,\n _amountIn,\n _params.dstOutputToken\n );\n }"
            },
            {
                "accrueFixedCryptoFee": "function accrueFixedCryptoFee(\n address _integrator,\n IntegratorFeeInfo memory _info\n ) internal returns (uint256) {\n uint256 _fixedCryptoFee;\n uint256 _RubicPart;\n if (_info.isIntegrator) {\n _fixedCryptoFee = uint256(_info.fixedFeeAmount);\n if (_fixedCryptoFee > 0) {\n _RubicPart =\n (_fixedCryptoFee *\n _info.RubicFixedCryptoShare) /\n DENOMINATOR;\n availableIntegratorCryptoFee[_integrator] +=\n _fixedCryptoFee -\n _RubicPart;\n }\n } else {\n _fixedCryptoFee = fixedCryptoFee;\n _RubicPart = _fixedCryptoFee;\n }\n availableRubicCryptoFee += _RubicPart;\n emit FixedCryptoFee(\n _RubicPart,\n _fixedCryptoFee - _RubicPart,\n _integrator\n );\n \n return (msg.value - _fixedCryptoFee);\n }"
            },
            {
                "accrueTokenFees": "function accrueTokenFees(\n address _integrator,\n IntegratorFeeInfo memory _info,\n uint256 _amountWithFee,\n uint256 _initBlockchainNum,\n address _token\n ) internal returns (uint256) {\n (uint256 _totalFees, uint256 _RubicFee) = _calculateFee(\n _info,\n _amountWithFee,\n _initBlockchainNum\n );\n if (_integrator != address(0)) {\n availableIntegratorTokenFee[_token][_integrator] +=\n _totalFees -\n _RubicFee;\n }\n availableRubicTokenFee[_token] += _RubicFee;\n emit TokenFee(\n _RubicFee,\n _totalFees - _RubicFee,\n _integrator,\n _token\n );\n return _amountWithFee - _totalFees;\n }"
            },
            {
                "smartApprove": "function smartApprove(\n address _tokenIn,\n uint256 _amount,\n address _to\n ) internal {\n IERC20Upgradeable tokenIn = IERC20Upgradeable(_tokenIn);\n uint256 _allowance = tokenIn.allowance(\n address(this),\n _to\n );\n if (_allowance < _amount) {\n if (_allowance == 0) {\n tokenIn.safeApprove(_to, type(uint256).max);\n } else {\n try\n tokenIn.approve(_to, type(uint256).max)\n returns (bool res) {\n if (!res) {\n revert ApproveFailed();\n }\n } catch {\n tokenIn.safeApprove(_to, 0);\n tokenIn.safeApprove(_to, type(uint256).max);\n }\n }\n }\n }"
            }
        ]
    },
    "rel_chain": {},
    "det_chain": {
        "CrossChainProcessed1": [
            {
                "changeTxStatus": "function changeTxStatus(\n bytes32 _id,\n SwapStatus _statusCode\n ) external onlyManagerOrAdmin {\n if (_statusCode == SwapStatus.Null) {\n revert CantSetToNull();\n }\n SwapStatus _status = processedTransactions[_id];\n if (\n _status == SwapStatus.Succeeded ||\n _status == SwapStatus.Fallback\n ) {\n revert Unchangeable();\n }\n processedTransactions[_id] = _statusCode;\n }"
            }
        ]
    }
}
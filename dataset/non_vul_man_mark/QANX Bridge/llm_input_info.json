{
    "src_chain": {
        "TokenLocked1": [
            {
                "bridgeSend": "function bridgeSend(address beneficiary, uint256 amount, uint256 withdrawChainId) external returns (bytes32) {\n \n bytes32 txid = keccak256(abi.encode(msg.sender, block.chainid, withdrawChainId, _nonces[msg.sender][block.chainid][withdrawChainId]++, beneficiary, amount));\n \n require(_qanx.transferFrom(msg.sender, address(this), amount));\n \n return txid;\n }"
            },
            {
                "transferFrom": "function transferFrom(\n address from,\n address to,\n uint256 amount\n ) external virtual override returns (bool) {\n address spender = _msgSender();\n function _spendAllowance(...) {...}\nfunction _transfer(...) {...}\n_spendAllowance(from, spender, amount);\n _transfer(from, to, amount);\n return true;\n }"
            },
            {
                "_transfer": "function _transfer(\n address from,\n address to,\n uint256 amount\n ) internal virtual {\n require(from != address(0), \"ERC20: transfer from the zero address\");\n require(to != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(from, to, amount);\n uint256 fromBalance = _balances[from];\n require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n unchecked {\n _balances[from] = fromBalance - amount;\n \n \n _balances[to] += amount;\n }\n emit Transfer(from, to, amount);\n _afterTokenTransfer(from, to, amount);\n }"
            }
        ]
    },
    "rel_chain": {},
    "det_chain": {
        "TokenUnlocked1": [
            {
                "bridgeWithdraw": "function bridgeWithdraw(address beneficiary, uint256 amount, uint256 depositChainId, bytes calldata signature) external returns (bool) {\n \n bytes32 txid = keccak256(abi.encode(msg.sender, depositChainId, block.chainid, _nonces[msg.sender][depositChainId][block.chainid]++, beneficiary, amount));\n \n function verifySignature(...) {...}\nrequire(verifySignature(txid, signature, amount), \"ERR_SIG\");\n \n uint256 fee = amount / 100 * feePercentage;\n feesCollected += fee;\n \n require(_qanx.transfer(beneficiary, amount - fee), \"ERR_TXN\");\n return true;\n }"
            },
            {
                "verifySignature": "function verifySignature(bytes32 txid, bytes memory signature, uint256 amount) internal view returns (bool) {\n \n bytes32 r;\n bytes32 vs;\n \n assembly {\n r := mload(add(signature, 32))\n vs := mload(add(signature, 64))\n }\n \n bytes32 s = vs & 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n uint8 v = 27 + uint8(uint256(vs) >> 255);\n \n return amount < signers[ecrecover(txid, v, r, s)];\n }"
            },
            {
                "transfer": "function transfer(address to, uint256 amount) external virtual override returns (bool) {\n address owner = _msgSender();\n function _transfer(...) {...}\n_transfer(owner, to, amount);\n return true;\n }"
            },
            {
                "_transfer": "function _transfer(\n address from,\n address to,\n uint256 amount\n ) internal virtual {\n require(from != address(0), \"ERC20: transfer from the zero address\");\n require(to != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(from, to, amount);\n uint256 fromBalance = _balances[from];\n require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n unchecked {\n _balances[from] = fromBalance - amount;\n \n \n _balances[to] += amount;\n }\n emit Transfer(from, to, amount);\n _afterTokenTransfer(from, to, amount);\n }"
            }
        ]
    }
}
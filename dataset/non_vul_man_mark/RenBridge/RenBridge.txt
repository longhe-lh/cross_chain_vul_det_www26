Folder Structure
--------------------------------------------------
contracts/
    AccessControl.sol
    AccessControlEnumerableUpgradeable.sol
    AccessControlUpgradeable.sol
    Address.sol
    BaseAdminUpgradeabilityProxy.sol
    BaseUpgradeabilityProxy.sol
    BasicBridge.sol
    BeaconProxy.sol
    CanReclaimTokens.sol
    Claimable.sol
    Context.sol
    ContextUpgradeable.sol
    DarknodePayment.sol
    DarknodePaymentStore.sol
    DarknodeRegistryLogicV1.sol
    DarknodeRegistryProxy.sol
    DarknodeRegistryStore.sol
    ECDSA.sol
    EnumerableSetUpgradeable.sol
    ERC165.sol
    ERC165Upgradeable.sol
    ERC1967Proxy.sol
    ERC1967Upgrade.sol
    ERC20.sol
    ERC20Detailed.sol
    ERC20WithPermit.sol
    ERC20WithRate.sol
    GatewayLogicV1.sol
    GatewayRegistry.sol
    GatewayRegistryV3.sol
    IAccessControl.sol
    IAccessControlEnumerableUpgradeable.sol
    IAccessControlUpgradeable.sol
    IBeacon.sol
    IERC165.sol
    IERC165Upgradeable.sol
    IERC20.sol
    IGateway.sol
    IGatewayRegistry.sol
    ILockGateway.sol
    IMintGateway.sol
    Initializable.sol
    InitializableAdminUpgradeabilityProxy.sol
    InitializableUpgradeabilityProxy.sol
    MintGatewayLogicV1.sol
    MintGatewayV1.sol
    MintGatewayV2.sol
    Ownable.sol
    OwnableUpgradeable.sol
    ProtocolLogicV1.sol
    ProtocolProxy.sol
    Proxy.sol
    ProxyBeacon.sol
    RenAssetFactory.sol
    RenERC20.sol
    RenERC20LogicV1.sol
    RepublicToken.sol
    SafeERC20.sol
    SafeMath.sol
    StorageSlot.sol
    String.sol
    Strings.sol
    StringSet.sol
    StringsUpgradeable.sol
    StringV1.sol
    TransparentUpgradeableProxy.sol
    UpgradeabilityProxy.sol
    UpgradeableBeacon.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\AccessControl.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IAccessControl.sol";

import "../utils/Context.sol";

import "../utils/Strings.sol";

import "../utils/introspection/ERC165.sol";



/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms. This is a lightweight version that doesn't allow enumerating role

 * members except through off-chain means by accessing the contract event logs. Some

 * applications may benefit from on-chain enumerability, for those cases see

 * {AccessControlEnumerable}.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControl is Context, IAccessControl, ERC165 {

    struct RoleData {

        mapping(address => bool) members;

        bytes32 adminRole;

    }



    mapping(bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Modifier that checks that an account has a specific role. Reverts

     * with a standardized message including the required role.

     *

     * The format of the revert reason is given by the following regular expression:

     *

     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/

     *

     * _Available since v4.1._

     */

    modifier onlyRole(bytes32 role) {

        _checkRole(role, _msgSender());

        _;

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);

    }



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view override returns (bool) {

        return _roles[role].members[account];

    }



    /**

     * @dev Revert with a standard message if `account` is missing `role`.

     *

     * The format of the revert reason is given by the following regular expression:

     *

     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/

     */

    function _checkRole(bytes32 role, address account) internal view {

        if (!hasRole(role, account)) {

            revert(

                string(

                    abi.encodePacked(

                        "AccessControl: account ",

                        Strings.toHexString(uint160(account), 20),

                        " is missing role ",

                        Strings.toHexString(uint256(role), 32)

                    )

                )

            );

        }

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {

        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {

        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual override {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        bytes32 previousAdminRole = getRoleAdmin(role);

        _roles[role].adminRole = adminRole;

        emit RoleAdminChanged(role, previousAdminRole, adminRole);

    }



    function _grantRole(bytes32 role, address account) private {

        if (!hasRole(role, account)) {

            _roles[role].members[account] = true;

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (hasRole(role, account)) {

            _roles[role].members[account] = false;

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\AccessControlEnumerableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IAccessControlEnumerableUpgradeable.sol";

import "./AccessControlUpgradeable.sol";

import "../utils/structs/EnumerableSetUpgradeable.sol";

import "../proxy/utils/Initializable.sol";



/**

 * @dev Extension of {AccessControl} that allows enumerating the members of each role.

 */

abstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {

    function __AccessControlEnumerable_init() internal initializer {

        __Context_init_unchained();

        __ERC165_init_unchained();

        __AccessControl_init_unchained();

        __AccessControlEnumerable_init_unchained();

    }



    function __AccessControlEnumerable_init_unchained() internal initializer {

    }

    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;



    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);

    }



    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {

        return _roleMembers[role].at(index);

    }



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {

        return _roleMembers[role].length();

    }



    /**

     * @dev Overload {grantRole} to track enumerable memberships

     */

    function grantRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {

        super.grantRole(role, account);

        _roleMembers[role].add(account);

    }



    /**

     * @dev Overload {revokeRole} to track enumerable memberships

     */

    function revokeRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {

        super.revokeRole(role, account);

        _roleMembers[role].remove(account);

    }



    /**

     * @dev Overload {renounceRole} to track enumerable memberships

     */

    function renounceRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {

        super.renounceRole(role, account);

        _roleMembers[role].remove(account);

    }



    /**

     * @dev Overload {_setupRole} to track enumerable memberships

     */

    function _setupRole(bytes32 role, address account) internal virtual override {

        super._setupRole(role, account);

        _roleMembers[role].add(account);

    }

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\AccessControlUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IAccessControlUpgradeable.sol";

import "../utils/ContextUpgradeable.sol";

import "../utils/StringsUpgradeable.sol";

import "../utils/introspection/ERC165Upgradeable.sol";

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module that allows children to implement role-based access

 * control mechanisms. This is a lightweight version that doesn't allow enumerating role

 * members except through off-chain means by accessing the contract event logs. Some

 * applications may benefit from on-chain enumerability, for those cases see

 * {AccessControlEnumerable}.

 *

 * Roles are referred to by their `bytes32` identifier. These should be exposed

 * in the external API and be unique. The best way to achieve this is by

 * using `public constant` hash digests:

 *

 * ```

 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");

 * ```

 *

 * Roles can be used to represent a set of permissions. To restrict access to a

 * function call, use {hasRole}:

 *

 * ```

 * function foo() public {

 *     require(hasRole(MY_ROLE, msg.sender));

 *     ...

 * }

 * ```

 *

 * Roles can be granted and revoked dynamically via the {grantRole} and

 * {revokeRole} functions. Each role has an associated admin role, and only

 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.

 *

 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means

 * that only accounts with this role will be able to grant or revoke other

 * roles. More complex role relationships can be created by using

 * {_setRoleAdmin}.

 *

 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to

 * grant and revoke this role. Extra precautions should be taken to secure

 * accounts that have been granted it.

 */

abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {

    function __AccessControl_init() internal initializer {

        __Context_init_unchained();

        __ERC165_init_unchained();

        __AccessControl_init_unchained();

    }



    function __AccessControl_init_unchained() internal initializer {

    }

    struct RoleData {

        mapping(address => bool) members;

        bytes32 adminRole;

    }



    mapping(bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



    /**

     * @dev Modifier that checks that an account has a specific role. Reverts

     * with a standardized message including the required role.

     *

     * The format of the revert reason is given by the following regular expression:

     *

     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/

     *

     * _Available since v4.1._

     */

    modifier onlyRole(bytes32 role) {

        _checkRole(role, _msgSender());

        _;

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);

    }



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) public view override returns (bool) {

        return _roles[role].members[account];

    }



    /**

     * @dev Revert with a standard message if `account` is missing `role`.

     *

     * The format of the revert reason is given by the following regular expression:

     *

     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/

     */

    function _checkRole(bytes32 role, address account) internal view {

        if (!hasRole(role, account)) {

            revert(

                string(

                    abi.encodePacked(

                        "AccessControl: account ",

                        StringsUpgradeable.toHexString(uint160(account), 20),

                        " is missing role ",

                        StringsUpgradeable.toHexString(uint256(role), 32)

                    )

                )

            );

        }

    }



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {

        return _roles[role].adminRole;

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {

        _grantRole(role, account);

    }



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {

        _revokeRole(role, account);

    }



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) public virtual override {

        require(account == _msgSender(), "AccessControl: can only renounce roles for self");



        _revokeRole(role, account);

    }



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event. Note that unlike {grantRole}, this function doesn't perform any

     * checks on the calling account.

     *

     * [WARNING]

     * ====

     * This function should only be called from the constructor when setting

     * up the initial roles for the system.

     *

     * Using this function in any other way is effectively circumventing the admin

     * system imposed by {AccessControl}.

     * ====

     */

    function _setupRole(bytes32 role, address account) internal virtual {

        _grantRole(role, account);

    }



    /**

     * @dev Sets `adminRole` as ``role``'s admin role.

     *

     * Emits a {RoleAdminChanged} event.

     */

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        bytes32 previousAdminRole = getRoleAdmin(role);

        _roles[role].adminRole = adminRole;

        emit RoleAdminChanged(role, previousAdminRole, adminRole);

    }



    function _grantRole(bytes32 role, address account) private {

        if (!hasRole(role, account)) {

            _roles[role].members[account] = true;

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (hasRole(role, account)) {

            _roles[role].members[account] = false;

            emit RoleRevoked(role, account, _msgSender());

        }

    }

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\BaseAdminUpgradeabilityProxy.sol
File type: .sol
pragma solidity ^0.5.0;



import './UpgradeabilityProxy.sol';



/**

 * @title BaseAdminUpgradeabilityProxy

 * @dev This contract combines an upgradeability proxy with an authorization

 * mechanism for administrative tasks.

 * All external functions in this contract must be guarded by the

 * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity

 * feature proposal that would enable this to be done automatically.

 */

contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

  /**

   * @dev Emitted when the administration has been transferred.

   * @param previousAdmin Address of the previous admin.

   * @param newAdmin Address of the new admin.

   */

  event AdminChanged(address previousAdmin, address newAdmin);



  /**

   * @dev Storage slot with the admin of the contract.

   * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is

   * validated in the constructor.

   */



  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



  /**

   * @dev Modifier to check whether the `msg.sender` is the admin.

   * If it is, it will run the function. Otherwise, it will delegate the call

   * to the implementation.

   */

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  /**

   * @return The address of the proxy admin.

   */

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  /**

   * @return The address of the implementation.

   */

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  /**

   * @dev Changes the admin of the proxy.

   * Only the current admin can call this function.

   * @param newAdmin Address to transfer proxy administration to.

   */

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  /**

   * @dev Upgrade the backing implementation of the proxy.

   * Only the admin can call this function.

   * @param newImplementation Address of the new implementation.

   */

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  /**

   * @dev Upgrade the backing implementation of the proxy and call a function

   * on the new implementation.

   * This is useful to initialize the proxied contract.

   * @param newImplementation Address of the new implementation.

   * @param data Data to send as msg.data in the low level call.

   * It should include the signature and the parameters of the function to be called, as described in

   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.

   */

  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    (bool success,) = newImplementation.delegatecall(data);

    require(success);

  }



  /**

   * @return The admin slot.

   */

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  /**

   * @dev Sets the address of the proxy admin.

   * @param newAdmin Address of the new proxy admin.

   */

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  /**

   * @dev Only fall back when the sender is not the admin.

   */

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\BaseUpgradeabilityProxy.sol
File type: .sol
pragma solidity ^0.5.0;



import './Proxy.sol';

import '../utils/Address.sol';



/**

 * @title BaseUpgradeabilityProxy

 * @dev This contract implements a proxy that allows to change the

 * implementation address to which it will delegate.

 * Such a change is called an implementation upgrade.

 */

contract BaseUpgradeabilityProxy is Proxy {

  /**

   * @dev Emitted when the implementation is upgraded.

   * @param implementation Address of the new implementation.

   */

  event Upgraded(address indexed implementation);



  /**

   * @dev Storage slot with the address of the current implementation.

   * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is

   * validated in the constructor.

   */

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



  /**

   * @dev Returns the current implementation.

   * @return Address of the current implementation

   */

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  /**

   * @dev Upgrades the proxy to a new implementation.

   * @param newImplementation Address of the new implementation.

   */

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  /**

   * @dev Sets the implementation address of the proxy.

   * @param newImplementation Address of the new implementation.

   */

  function _setImplementation(address newImplementation) internal {

    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\BasicBridge.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import {Context} from "@openzeppelin/contracts/utils/Context.sol";



import {IGatewayRegistry} from "./GatewayRegistry/interfaces/IGatewayRegistry.sol";

import {IMintGateway} from "./Gateways/interfaces/IMintGateway.sol";

import {ILockGateway} from "./Gateways/interfaces/ILockGateway.sol";



contract BasicBridge is Context {

    using SafeERC20 for IERC20;



    string public constant NAME = "BasicBridge";



    IGatewayRegistry public registry;



    constructor(IGatewayRegistry _registry) {

        registry = _registry;

    }



    function mint(

        // Payload

        string calldata symbol,

        address recipient,

        // Required

        uint256 amount,

        bytes32 nHash,

        bytes calldata sig

    ) external {

        IERC20 renAsset = registry.getRenAssetBySymbol(symbol);

        IMintGateway mintGateway = registry.getMintGatewayBySymbol(symbol);



        if (address(renAsset) == address(0x0) || address(mintGateway) == address(0x0)) {

            revert(string(abi.encodePacked("BasicBridge: unknown asset ", symbol)));

        }



        bytes32 payloadHash = keccak256(abi.encode(symbol, recipient));

        uint256 amountMinted = mintGateway.mint(payloadHash, amount, nHash, sig);

        renAsset.safeTransfer(recipient, amountMinted);

    }



    function burn(

        string calldata symbol,

        string calldata recipient,

        uint256 amount

    ) external {

        IERC20 renAsset = registry.getRenAssetBySymbol(symbol);

        IMintGateway mintGateway = registry.getMintGatewayBySymbol(symbol);



        if (address(renAsset) == address(0x0) || address(mintGateway) == address(0x0)) {

            revert(string(abi.encodePacked("BasicBridge: unknown asset ", symbol)));

        }



        renAsset.safeTransferFrom(_msgSender(), address(this), amount);

        mintGateway.burn(recipient, amount);

    }



    function lock(

        string calldata symbol,

        string calldata recipientAddress,

        string calldata recipientChain,

        bytes calldata recipientPayload,

        uint256 amount

    ) external {

        IERC20 lockAsset = registry.getLockAssetBySymbol(symbol);

        ILockGateway lockGateway = registry.getLockGatewayBySymbol(symbol);



        if (address(lockAsset) == address(0x0) || address(lockGateway) == address(0x0)) {

            revert(string(abi.encodePacked("BasicBridge: unknown asset ", symbol)));

        }



        lockAsset.safeTransferFrom(_msgSender(), address(this), amount);

        lockAsset.safeIncreaseAllowance(address(lockGateway), amount);

        lockGateway.lock(recipientAddress, recipientChain, recipientPayload, amount);

    }



    function release(

        // Payload

        string calldata symbol,

        address recipient,

        // Required

        uint256 amount,

        bytes32 nHash,

        bytes calldata sig

    ) external {

        IERC20 lockAsset = registry.getLockAssetBySymbol(symbol);

        ILockGateway lockGateway = registry.getLockGatewayBySymbol(symbol);



        if (address(lockAsset) == address(0x0) || address(lockGateway) == address(0x0)) {

            revert(string(abi.encodePacked("BasicBridge: unknown asset ", symbol)));

        }



        bytes32 payloadHash = keccak256(abi.encode(symbol, recipient));

        uint256 amountReleased = lockGateway.release(payloadHash, amount, nHash, sig);

        lockAsset.safeTransfer(recipient, amountReleased);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\BeaconProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IBeacon.sol";

import "../Proxy.sol";

import "../ERC1967/ERC1967Upgrade.sol";



/**

 * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.

 *

 * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't

 * conflict with the storage layout of the implementation behind the proxy.

 *

 * _Available since v3.4._

 */

contract BeaconProxy is Proxy, ERC1967Upgrade {

    /**

     * @dev Initializes the proxy with `beacon`.

     *

     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This

     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity

     * constructor.

     *

     * Requirements:

     *

     * - `beacon` must be a contract with the interface {IBeacon}.

     */

    constructor(address beacon, bytes memory data) payable {

        assert(_BEACON_SLOT == bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1));

        _upgradeBeaconToAndCall(beacon, data, false);

    }



    /**

     * @dev Returns the current beacon address.

     */

    function _beacon() internal view virtual returns (address) {

        return _getBeacon();

    }



    /**

     * @dev Returns the current implementation address of the associated beacon.

     */

    function _implementation() internal view virtual override returns (address) {

        return IBeacon(_getBeacon()).implementation();

    }



    /**

     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.

     *

     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.

     *

     * Requirements:

     *

     * - `beacon` must be a contract.

     * - The implementation returned by `beacon` must be a contract.

     */

    function _setBeacon(address beacon, bytes memory data) internal virtual {

        _upgradeBeaconToAndCall(beacon, data, false);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\CanReclaimTokens.sol
File type: .sol
pragma solidity ^0.5.17;



import "@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol";

import "@openzeppelin/upgrades/contracts/Initializable.sol";



import "../Governance/Claimable.sol";



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    /// @notice Allow the owner of the contract to recover funds accidentally

    /// sent to the contract. To withdraw ETH, the token should be set to `0x0`.

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\Claimable.sol
File type: .sol
pragma solidity ^0.5.17;



import "@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol";

import "@openzeppelin/upgrades/contracts/Initializable.sol";



/**

 * @title Claimable

 * @dev Extension for the Ownable contract, where the ownership needs to be claimed.

 * This allows the new owner to accept the transfer.

 */

contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    // Allow skipping two-step transfer if the recipient is known to be a valid

    // owner, for use in smart-contracts only.

    function _directTransferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ContextUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;

import "../proxy/utils/Initializable.sol";



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract ContextUpgradeable is Initializable {

    function __Context_init() internal initializer {

        __Context_init_unchained();

    }



    function __Context_init_unchained() internal initializer {

    }

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

    uint256[50] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\DarknodePayment.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-03-25

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 9068f80

Repository: https://github.com/renproject/darknode-sol

Issues: https://github.com/renproject/darknode-sol/issues



Licenses

@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE



*/



pragma solidity 0.5.16;





library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



library Math {

    

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        

        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

    }

}



library ERC20WithFees {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    

    

    function safeTransferFromWithFees(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal returns (uint256) {

        uint256 balancesBefore = token.balanceOf(to);

        token.safeTransferFrom(from, to, value);

        uint256 balancesAfter = token.balanceOf(to);

        return Math.min(value, balancesAfter.sub(balancesBefore));

    }

}



contract Proxy {

  

  function () payable external {

    _fallback();

  }



  

  function _implementation() internal view returns (address);



  

  function _delegate(address implementation) internal {

    assembly {

      

      

      

      calldatacopy(0, 0, calldatasize)



      

      

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      

      returndatacopy(0, 0, returndatasize)



      switch result

      

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  

  function _willFallback() internal {

  }



  

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



library OpenZeppelinUpgradesAddress {

    

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        

        

        

        

        

        

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



contract BaseUpgradeabilityProxy is Proxy {

  

  event Upgraded(address indexed implementation);



  

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



  

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  

  function _setImplementation(address newImplementation) internal {

    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  constructor(address _logic, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  event AdminChanged(address previousAdmin, address newAdmin);



  



  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



  

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  

  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    (bool success,) = newImplementation.delegatecall(data);

    require(success);

  }



  

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  function initialize(address _logic, bytes memory _data) public payable {

    require(_implementation() == address(0));

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {

  

  function initialize(address _logic, address _admin, bytes memory _data) public payable {

    require(_implementation() == address(0));

    InitializableUpgradeabilityProxy.initialize(_logic, _data);

    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));

    _setAdmin(_admin);

  }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}



library Roles {

    struct Role {

        mapping (address => bool) bearer;

    }



    

    function add(Role storage role, address account) internal {

        require(!has(role, account), "Roles: account already has role");

        role.bearer[account] = true;

    }



    

    function remove(Role storage role, address account) internal {

        require(has(role, account), "Roles: account does not have role");

        role.bearer[account] = false;

    }



    

    function has(Role storage role, address account) internal view returns (bool) {

        require(account != address(0), "Roles: account is the zero address");

        return role.bearer[account];

    }

}



contract PauserRole is Initializable, Context {

    using Roles for Roles.Role;



    event PauserAdded(address indexed account);

    event PauserRemoved(address indexed account);



    Roles.Role private _pausers;



    function initialize(address sender) public initializer {

        if (!isPauser(sender)) {

            _addPauser(sender);

        }

    }



    modifier onlyPauser() {

        require(isPauser(_msgSender()), "PauserRole: caller does not have the Pauser role");

        _;

    }



    function isPauser(address account) public view returns (bool) {

        return _pausers.has(account);

    }



    function addPauser(address account) public onlyPauser {

        _addPauser(account);

    }



    function renouncePauser() public {

        _removePauser(_msgSender());

    }



    function _addPauser(address account) internal {

        _pausers.add(account);

        emit PauserAdded(account);

    }



    function _removePauser(address account) internal {

        _pausers.remove(account);

        emit PauserRemoved(account);

    }



    uint256[50] private ______gap;

}



contract Pausable is Initializable, Context, PauserRole {

    

    event Paused(address account);



    

    event Unpaused(address account);



    bool private _paused;



    

    function initialize(address sender) public initializer {

        PauserRole.initialize(sender);



        _paused = false;

    }



    

    function paused() public view returns (bool) {

        return _paused;

    }



    

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    

    function pause() public onlyPauser whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    

    function unpause() public onlyPauser whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }



    uint256[50] private ______gap;

}



contract ERC20Pausable is Initializable, ERC20, Pausable {

    function initialize(address sender) public initializer {

        Pausable.initialize(sender);

    }



    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transfer(to, value);

    }



    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transferFrom(from, to, value);

    }



    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {

        return super.approve(spender, value);

    }



    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {

        return super.increaseAllowance(spender, addedValue);

    }



    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {

        return super.decreaseAllowance(spender, subtractedValue);

    }



    uint256[50] private ______gap;

}



contract ERC20Burnable is Initializable, Context, ERC20 {

    

    function burn(uint256 amount) public {

        _burn(_msgSender(), amount);

    }



    

    function burnFrom(address account, uint256 amount) public {

        _burnFrom(account, amount);

    }



    uint256[50] private ______gap;

}



contract RenToken is Ownable, ERC20Detailed, ERC20Pausable, ERC20Burnable {

    string private constant _name = "REN";

    string private constant _symbol = "REN";

    uint8 private constant _decimals = 18;



    uint256 public constant INITIAL_SUPPLY = 1000000000 *

        10**uint256(_decimals);



    

    constructor() public {

        ERC20Pausable.initialize(msg.sender);

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        Ownable.initialize(msg.sender);

        _mint(msg.sender, INITIAL_SUPPLY);

    }



    function transferTokens(address beneficiary, uint256 amount)

        public

        onlyOwner

        returns (bool)

    {

        

        

        require(amount > 0);



        _transfer(msg.sender, beneficiary, amount);

        emit Transfer(msg.sender, beneficiary, amount);



        return true;

    }

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library LinkedList {



    

    address public constant NULL = address(0);



    

    struct Node {

        bool inList;

        address previous;

        address next;

    }



    

    struct List {

        mapping (address => Node) list;

    }



    

    function insertBefore(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address prev = self.list[target].previous;



        self.list[newNode].next = target;

        self.list[newNode].previous = prev;

        self.list[target].previous = newNode;

        self.list[prev].next = newNode;



        self.list[newNode].inList = true;

    }



    

    function insertAfter(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address n = self.list[target].next;



        self.list[newNode].previous = target;

        self.list[newNode].next = n;

        self.list[target].next = newNode;

        self.list[n].previous = newNode;



        self.list[newNode].inList = true;

    }



    

    function remove(List storage self, address node) internal {

        require(isInList(self, node), "LinkedList: not in list");

        

        address p = self.list[node].previous;

        address n = self.list[node].next;



        self.list[p].next = n;

        self.list[n].previous = p;



        

        

        self.list[node].inList = false;

        delete self.list[node];

    }



    

    function prepend(List storage self, address node) internal {

        



        insertBefore(self, begin(self), node);

    }



    

    function append(List storage self, address node) internal {

        



        insertAfter(self, end(self), node);

    }



    function swap(List storage self, address left, address right) internal {

        



        address previousRight = self.list[right].previous;

        remove(self, right);

        insertAfter(self, left, right);

        remove(self, left);

        insertAfter(self, previousRight, left);

    }



    function isInList(List storage self, address node) internal view returns (bool) {

        return self.list[node].inList;

    }



    

    function begin(List storage self) internal view returns (address) {

        return self.list[NULL].next;

    }



    

    function end(List storage self) internal view returns (address) {

        return self.list[NULL].previous;

    }



    function next(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].next;

    }



    function previous(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].previous;

    }



    function elements(List storage self, address _start, uint256 _count) internal view returns (address[] memory) {

        require(_count > 0, "LinkedList: invalid count");

        require(isInList(self, _start) || _start == address(0), "LinkedList: not in list");

        address[] memory elems = new address[](_count);



        

        uint256 n = 0;

        address nextItem = _start;

        if (nextItem == address(0)) {

            nextItem = begin(self);

        }



        while (n < _count) {

            if (nextItem == address(0)) {

                break;

            }

            elems[n] = nextItem;

            nextItem = next(self, nextItem);

            n += 1;

        }

        return elems;

    }

}



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    

    

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}



contract DarknodeRegistryStore is Claimable, CanReclaimTokens {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    

    

    struct Darknode {

        

        

        

        

        address payable owner;

        

        

        

        uint256 bond;

        

        uint256 registeredAt;

        

        uint256 deregisteredAt;

        

        

        

        

        bytes publicKey;

    }



    

    mapping(address => Darknode) private darknodeRegistry;

    LinkedList.List private darknodes;



    

    RenToken public ren;



    

    

    

    

    constructor(string memory _VERSION, RenToken _ren) public {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;

        ren = _ren;

        blacklistRecoverableToken(address(ren));

    }



    

    

    

    

    

    

    

    

    

    function appendDarknode(

        address _darknodeID,

        address payable _darknodeOperator,

        uint256 _bond,

        bytes calldata _publicKey,

        uint256 _registeredAt,

        uint256 _deregisteredAt

    ) external onlyOwner {

        Darknode memory darknode = Darknode({

            owner: _darknodeOperator,

            bond: _bond,

            publicKey: _publicKey,

            registeredAt: _registeredAt,

            deregisteredAt: _deregisteredAt

        });

        darknodeRegistry[_darknodeID] = darknode;

        LinkedList.append(darknodes, _darknodeID);

    }



    

    function begin() external view onlyOwner returns (address) {

        return LinkedList.begin(darknodes);

    }



    

    

    function next(address darknodeID)

        external

        view

        onlyOwner

        returns (address)

    {

        return LinkedList.next(darknodes, darknodeID);

    }



    

    

    function removeDarknode(address darknodeID) external onlyOwner {

        uint256 bond = darknodeRegistry[darknodeID].bond;

        delete darknodeRegistry[darknodeID];

        LinkedList.remove(darknodes, darknodeID);

        require(

            ren.transfer(owner(), bond),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    

    function updateDarknodeBond(address darknodeID, uint256 decreasedBond)

        external

        onlyOwner

    {

        uint256 previousBond = darknodeRegistry[darknodeID].bond;

        require(

            decreasedBond < previousBond,

            "DarknodeRegistryStore: bond not decreased"

        );

        darknodeRegistry[darknodeID].bond = decreasedBond;

        require(

            ren.transfer(owner(), previousBond.sub(decreasedBond)),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    function updateDarknodeDeregisteredAt(

        address darknodeID,

        uint256 deregisteredAt

    ) external onlyOwner {

        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;

    }



    

    function darknodeOperator(address darknodeID)

        external

        view

        onlyOwner

        returns (address payable)

    {

        return darknodeRegistry[darknodeID].owner;

    }



    

    function darknodeBond(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].bond;

    }



    

    function darknodeRegisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].registeredAt;

    }



    

    function darknodeDeregisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].deregisteredAt;

    }



    

    function darknodePublicKey(address darknodeID)

        external

        view

        onlyOwner

        returns (bytes memory)

    {

        return darknodeRegistry[darknodeID].publicKey;

    }

}



interface IDarknodePaymentStore {}



interface IDarknodePayment {

    function changeCycle() external returns (uint256);

    function store() external view returns (IDarknodePaymentStore);

}



interface IDarknodeSlasher {}



contract DarknodeRegistryStateV1 {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    struct Epoch {

        uint256 epochhash;

        uint256 blocktime;

    }



    uint256 public numDarknodes;

    uint256 public numDarknodesNextEpoch;

    uint256 public numDarknodesPreviousEpoch;



    

    uint256 public minimumBond;

    uint256 public minimumPodSize;

    uint256 public minimumEpochInterval;

    uint256 public deregistrationInterval;



    

    

    

    uint256 public nextMinimumBond;

    uint256 public nextMinimumPodSize;

    uint256 public nextMinimumEpochInterval;



    

    Epoch public currentEpoch;

    Epoch public previousEpoch;



    

    RenToken public ren;



    

    DarknodeRegistryStore public store;



    

    IDarknodePayment public darknodePayment;



    

    IDarknodeSlasher public slasher;

    IDarknodeSlasher public nextSlasher;

}



contract DarknodeRegistryLogicV1 is

    Claimable,

    CanReclaimTokens,

    DarknodeRegistryStateV1

{

    

    

    

    

    event LogDarknodeRegistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _bond

    );



    

    

    

    event LogDarknodeDeregistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID

    );



    

    

    

    event LogDarknodeRefunded(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _amount

    );



    

    

    

    

    

    event LogDarknodeSlashed(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        address indexed _challenger,

        uint256 _percentage

    );



    

    event LogNewEpoch(uint256 indexed epochhash);



    

    event LogMinimumBondUpdated(

        uint256 _previousMinimumBond,

        uint256 _nextMinimumBond

    );

    event LogMinimumPodSizeUpdated(

        uint256 _previousMinimumPodSize,

        uint256 _nextMinimumPodSize

    );

    event LogMinimumEpochIntervalUpdated(

        uint256 _previousMinimumEpochInterval,

        uint256 _nextMinimumEpochInterval

    );

    event LogSlasherUpdated(

        address indexed _previousSlasher,

        address indexed _nextSlasher

    );

    event LogDarknodePaymentUpdated(

        IDarknodePayment indexed _previousDarknodePayment,

        IDarknodePayment indexed _nextDarknodePayment

    );



    

    modifier onlyDarknodeOperator(address _darknodeID) {

        require(

            store.darknodeOperator(_darknodeID) == msg.sender,

            "DarknodeRegistry: must be darknode owner"

        );

        _;

    }



    

    modifier onlyRefunded(address _darknodeID) {

        require(

            isRefunded(_darknodeID),

            "DarknodeRegistry: must be refunded or never registered"

        );

        _;

    }



    

    modifier onlyRefundable(address _darknodeID) {

        require(

            isRefundable(_darknodeID),

            "DarknodeRegistry: must be deregistered for at least one epoch"

        );

        _;

    }



    

    

    modifier onlyDeregisterable(address _darknodeID) {

        require(

            isDeregisterable(_darknodeID),

            "DarknodeRegistry: must be deregisterable"

        );

        _;

    }



    

    modifier onlySlasher() {

        require(

            address(slasher) == msg.sender,

            "DarknodeRegistry: must be slasher"

        );

        _;

    }



    

    

    modifier onlyDarknode(address _darknodeID) {

        require(

            isRegistered(_darknodeID),

            "DarknodeRegistry: invalid darknode"

        );

        _;

    }



    

    

    

    

    

    

    

    

    

    function initialize(

        string memory _VERSION,

        RenToken _renAddress,

        DarknodeRegistryStore _storeAddress,

        uint256 _minimumBond,

        uint256 _minimumPodSize,

        uint256 _minimumEpochIntervalSeconds,

        uint256 _deregistrationIntervalSeconds

    ) public initializer {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;



        store = _storeAddress;

        ren = _renAddress;



        minimumBond = _minimumBond;

        nextMinimumBond = minimumBond;



        minimumPodSize = _minimumPodSize;

        nextMinimumPodSize = minimumPodSize;



        minimumEpochInterval = _minimumEpochIntervalSeconds;

        nextMinimumEpochInterval = minimumEpochInterval;

        deregistrationInterval = _deregistrationIntervalSeconds;



        uint256 epochhash = uint256(blockhash(block.number - 1));

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });

        emit LogNewEpoch(epochhash);

    }



    

    

    

    

    

    

    

    

    

    

    function register(address _darknodeID, bytes calldata _publicKey)

        external

        onlyRefunded(_darknodeID)

    {

        require(

            _darknodeID != address(0),

            "DarknodeRegistry: darknode address cannot be zero"

        );



        

        require(

            ren.transferFrom(msg.sender, address(store), minimumBond),

            "DarknodeRegistry: bond transfer failed"

        );



        

        store.appendDarknode(

            _darknodeID,

            msg.sender,

            minimumBond,

            _publicKey,

            currentEpoch.blocktime.add(minimumEpochInterval),

            0

        );



        numDarknodesNextEpoch = numDarknodesNextEpoch.add(1);



        

        emit LogDarknodeRegistered(msg.sender, _darknodeID, minimumBond);

    }



    

    

    

    

    

    

    function deregister(address _darknodeID)

        external

        onlyDeregisterable(_darknodeID)

        onlyDarknodeOperator(_darknodeID)

    {

        deregisterDarknode(_darknodeID);

    }



    

    

    

    function epoch() external {

        if (previousEpoch.blocktime == 0) {

            

            require(

                msg.sender == owner(),

                "DarknodeRegistry: not authorized to call first epoch"

            );

        }



        

        require(

            block.timestamp >= currentEpoch.blocktime.add(minimumEpochInterval),

            "DarknodeRegistry: epoch interval has not passed"

        );

        uint256 epochhash = uint256(blockhash(block.number - 1));



        

        previousEpoch = currentEpoch;

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });



        

        numDarknodesPreviousEpoch = numDarknodes;

        numDarknodes = numDarknodesNextEpoch;



        

        if (nextMinimumBond != minimumBond) {

            minimumBond = nextMinimumBond;

            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);

        }

        if (nextMinimumPodSize != minimumPodSize) {

            minimumPodSize = nextMinimumPodSize;

            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);

        }

        if (nextMinimumEpochInterval != minimumEpochInterval) {

            minimumEpochInterval = nextMinimumEpochInterval;

            emit LogMinimumEpochIntervalUpdated(

                minimumEpochInterval,

                nextMinimumEpochInterval

            );

        }

        if (nextSlasher != slasher) {

            slasher = nextSlasher;

            emit LogSlasherUpdated(address(slasher), address(nextSlasher));

        }

        if (address(darknodePayment) != address(0x0)) {

            darknodePayment.changeCycle();

        }



        

        emit LogNewEpoch(epochhash);

    }



    

    

    

    function transferStoreOwnership(DarknodeRegistryLogicV1 _newOwner)

        external

        onlyOwner

    {

        store.transferOwnership(address(_newOwner));

        _newOwner.claimStoreOwnership();

    }



    

    

    

    function claimStoreOwnership() external {

        store.claimOwnership();



        

        

        (

            numDarknodesPreviousEpoch,

            numDarknodes,

            numDarknodesNextEpoch

        ) = getDarknodeCountFromEpochs();

    }



    

    

    

    

    function updateDarknodePayment(IDarknodePayment _darknodePayment)

        external

        onlyOwner

    {

        require(

            address(_darknodePayment) != address(0x0),

            "DarknodeRegistry: invalid Darknode Payment address"

        );

        IDarknodePayment previousDarknodePayment = darknodePayment;

        darknodePayment = _darknodePayment;

        emit LogDarknodePaymentUpdated(

            previousDarknodePayment,

            darknodePayment

        );

    }



    

    

    

    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {

        

        nextMinimumBond = _nextMinimumBond;

    }



    

    

    function updateMinimumPodSize(uint256 _nextMinimumPodSize)

        external

        onlyOwner

    {

        

        nextMinimumPodSize = _nextMinimumPodSize;

    }



    

    

    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval)

        external

        onlyOwner

    {

        

        nextMinimumEpochInterval = _nextMinimumEpochInterval;

    }



    

    

    

    function updateSlasher(IDarknodeSlasher _slasher) external onlyOwner {

        require(

            address(_slasher) != address(0),

            "DarknodeRegistry: invalid slasher address"

        );

        nextSlasher = _slasher;

    }



    

    

    

    

    

    function slash(address _guilty, address _challenger, uint256 _percentage)

        external

        onlySlasher

        onlyDarknode(_guilty)

    {

        require(_percentage <= 100, "DarknodeRegistry: invalid percent");



        

        if (isDeregisterable(_guilty)) {

            deregisterDarknode(_guilty);

        }



        uint256 totalBond = store.darknodeBond(_guilty);

        uint256 penalty = totalBond.div(100).mul(_percentage);

        uint256 challengerReward = penalty.div(2);

        uint256 darknodePaymentReward = penalty.sub(challengerReward);

        if (challengerReward > 0) {

            

            store.updateDarknodeBond(_guilty, totalBond.sub(penalty));



            

            require(

                address(darknodePayment) != address(0x0),

                "DarknodeRegistry: invalid payment address"

            );

            require(

                ren.transfer(

                    address(darknodePayment.store()),

                    darknodePaymentReward

                ),

                "DarknodeRegistry: reward transfer failed"

            );

            require(

                ren.transfer(_challenger, challengerReward),

                "DarknodeRegistry: reward transfer failed"

            );

        }



        emit LogDarknodeSlashed(

            store.darknodeOperator(_guilty),

            _guilty,

            _challenger,

            _percentage

        );

    }



    

    

    

    

    

    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        uint256 amount = store.darknodeBond(_darknodeID);



        

        store.removeDarknode(_darknodeID);



        

        require(

            ren.transfer(darknodeOperator, amount),

            "DarknodeRegistry: bond transfer failed"

        );



        

        emit LogDarknodeRefunded(darknodeOperator, _darknodeID, amount);

    }



    

    

    function getDarknodeOperator(address _darknodeID)

        external

        view

        returns (address payable)

    {

        return store.darknodeOperator(_darknodeID);

    }



    

    

    function getDarknodeBond(address _darknodeID)

        external

        view

        returns (uint256)

    {

        return store.darknodeBond(_darknodeID);

    }



    

    

    function getDarknodePublicKey(address _darknodeID)

        external

        view

        returns (bytes memory)

    {

        return store.darknodePublicKey(_darknodeID);

    }



    

    

    

    

    

    

    

    

    

    

    function getDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }

        return getDarknodesFromEpochs(_start, count, false);

    }



    

    

    function getPreviousDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodesPreviousEpoch;

        }

        return getDarknodesFromEpochs(_start, count, true);

    }



    

    

    

    function isPendingRegistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        return registeredAt != 0 && registeredAt > currentEpoch.blocktime;

    }



    

    

    function isPendingDeregistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocktime;

    }



    

    function isDeregistered(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocktime;

    }



    

    

    

    function isDeregisterable(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        

        

        return isRegistered(_darknodeID) && deregisteredAt == 0;

    }



    

    

    

    function isRefunded(address _darknodeID) public view returns (bool) {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return registeredAt == 0 && deregisteredAt == 0;

    }



    

    

    function isRefundable(address _darknodeID) public view returns (bool) {

        return

            isDeregistered(_darknodeID) &&

            store.darknodeDeregisteredAt(_darknodeID) <=

            (previousEpoch.blocktime - deregistrationInterval);

    }



    

    function isRegistered(address _darknodeID) public view returns (bool) {

        return isRegisteredInEpoch(_darknodeID, currentEpoch);

    }



    

    function isRegisteredInPreviousEpoch(address _darknodeID)

        public

        view

        returns (bool)

    {

        return isRegisteredInEpoch(_darknodeID, previousEpoch);

    }



    

    

    

    

    function isRegisteredInEpoch(address _darknodeID, Epoch memory _epoch)

        private

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocktime;

        bool notDeregistered = deregisteredAt == 0 ||

            deregisteredAt > _epoch.blocktime;

        

        

        return registered && notDeregistered;

    }



    

    

    

    

    

    function getDarknodesFromEpochs(

        address _start,

        uint256 _count,

        bool _usePreviousEpoch

    ) private view returns (address[] memory) {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }



        address[] memory nodes = new address[](count);



        

        uint256 n = 0;

        address next = _start;

        if (next == address(0)) {

            next = store.begin();

        }



        

        while (n < count) {

            if (next == address(0)) {

                break;

            }

            

            bool includeNext;

            if (_usePreviousEpoch) {

                includeNext = isRegisteredInPreviousEpoch(next);

            } else {

                includeNext = isRegistered(next);

            }

            if (!includeNext) {

                next = store.next(next);

                continue;

            }

            nodes[n] = next;

            next = store.next(next);

            n += 1;

        }

        return nodes;

    }



    

    function deregisterDarknode(address _darknodeID) private {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        store.updateDarknodeDeregisteredAt(

            _darknodeID,

            currentEpoch.blocktime.add(minimumEpochInterval)

        );

        numDarknodesNextEpoch = numDarknodesNextEpoch.sub(1);



        

        emit LogDarknodeDeregistered(darknodeOperator, _darknodeID);

    }



    function getDarknodeCountFromEpochs()

        private

        view

        returns (uint256, uint256, uint256)

    {

        

        uint256 nPreviousEpoch = 0;

        uint256 nCurrentEpoch = 0;

        uint256 nNextEpoch = 0;

        address next = store.begin();



        

        while (true) {

            

            if (next == address(0)) {

                break;

            }



            if (isRegisteredInPreviousEpoch(next)) {

                nPreviousEpoch += 1;

            }



            if (isRegistered(next)) {

                nCurrentEpoch += 1;

            }



            

            

            if (

                ((isRegistered(next) && !isPendingDeregistration(next)) ||

                    isPendingRegistration(next))

            ) {

                nNextEpoch += 1;

            }

            next = store.next(next);

        }

        return (nPreviousEpoch, nCurrentEpoch, nNextEpoch);

    }

}



contract DarknodeRegistryProxy is InitializableAdminUpgradeabilityProxy {}



contract DarknodePaymentStore is Claimable {

    using SafeMath for uint256;

    using SafeERC20 for ERC20;

    using ERC20WithFees for ERC20;



    string public VERSION; 



    

    address public constant ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    

    mapping(address => mapping(address => uint256)) public darknodeBalances;



    

    mapping(address => uint256) public lockedBalances;



    

    

    

    constructor(string memory _VERSION) public {

        Claimable.initialize(msg.sender);

        VERSION = _VERSION;

    }



    

    function() external payable {}



    

    

    

    

    function totalBalance(address _token) public view returns (uint256) {

        if (_token == ETHEREUM) {

            return address(this).balance;

        } else {

            return ERC20(_token).balanceOf(address(this));

        }

    }



    

    

    

    

    

    

    function availableBalance(address _token) public view returns (uint256) {

        return

            totalBalance(_token).sub(

                lockedBalances[_token],

                "DarknodePaymentStore: locked balance exceed total balance"

            );

    }



    

    

    

    

    

    

    function incrementDarknodeBalance(

        address _darknode,

        address _token,

        uint256 _amount

    ) external onlyOwner {

        require(_amount > 0, "DarknodePaymentStore: invalid amount");

        require(

            availableBalance(_token) >= _amount,

            "DarknodePaymentStore: insufficient contract balance"

        );



        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token]

            .add(_amount);

        lockedBalances[_token] = lockedBalances[_token].add(_amount);

    }



    

    

    

    

    

    

    function transfer(

        address _darknode,

        address _token,

        uint256 _amount,

        address payable _recipient

    ) external onlyOwner {

        require(

            darknodeBalances[_darknode][_token] >= _amount,

            "DarknodePaymentStore: insufficient darknode balance"

        );

        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token]

            .sub(

            _amount,

            "DarknodePaymentStore: insufficient darknode balance for transfer"

        );

        lockedBalances[_token] = lockedBalances[_token].sub(

            _amount,

            "DarknodePaymentStore: insufficient token balance for transfer"

        );



        if (_token == ETHEREUM) {

            _recipient.transfer(_amount);

        } else {

            ERC20(_token).safeTransfer(_recipient, _amount);

        }

    }



}



contract DarknodePayment is Claimable {

    using SafeMath for uint256;

    using SafeERC20 for ERC20;

    using ERC20WithFees for ERC20;



    string public VERSION; 



    

    address public constant ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    DarknodeRegistryLogicV1 public darknodeRegistry; 



    

    

    DarknodePaymentStore public store; 



    

    

    address public cycleChanger;



    uint256 public currentCycle;

    uint256 public previousCycle;



    

    

    

    address[] public pendingTokens;



    

    

    address[] public registeredTokens;



    

    

    mapping(address => uint256) public registeredTokenIndex;



    

    

    

    mapping(address => uint256) public unclaimedRewards;



    

    

    mapping(address => uint256) public previousCycleRewardShare;



    

    uint256 public cycleStartTime;



    

    uint256 public nextCyclePayoutPercent;



    

    uint256 public currentCyclePayoutPercent;



    

    

    

    mapping(address => mapping(uint256 => bool)) public rewardClaimed;



    

    

    

    event LogDarknodeClaim(address indexed _darknode, uint256 _cycle);



    

    

    

    

    event LogPaymentReceived(

        address indexed _payer,

        address indexed _token,

        uint256 _amount

    );



    

    

    

    

    

    event LogDarknodeWithdrew(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        address indexed _token,

        uint256 _value

    );



    

    

    

    event LogPayoutPercentChanged(uint256 _newPercent, uint256 _oldPercent);



    

    

    

    event LogCycleChangerChanged(

        address indexed _newCycleChanger,

        address indexed _oldCycleChanger

    );



    

    

    event LogTokenRegistered(address indexed _token);



    

    

    event LogTokenDeregistered(address indexed _token);



    

    

    

    event LogDarknodeRegistryUpdated(

        DarknodeRegistryLogicV1 indexed _previousDarknodeRegistry,

        DarknodeRegistryLogicV1 indexed _nextDarknodeRegistry

    );



    

    modifier onlyDarknode(address _darknode) {

        require(

            darknodeRegistry.isRegistered(_darknode),

            "DarknodePayment: darknode is not registered"

        );

        _;

    }



    

    modifier validPercent(uint256 _percent) {

        require(_percent <= 100, "DarknodePayment: invalid percentage");

        _;

    }



    

    modifier onlyCycleChanger {

        require(

            msg.sender == cycleChanger,

            "DarknodePayment: not cycle changer"

        );

        _;

    }



    

    

    

    

    

    

    

    constructor(

        string memory _VERSION,

        DarknodeRegistryLogicV1 _darknodeRegistry,

        DarknodePaymentStore _darknodePaymentStore,

        uint256 _cyclePayoutPercent

    ) public validPercent(_cyclePayoutPercent) {

        Claimable.initialize(msg.sender);

        VERSION = _VERSION;

        darknodeRegistry = _darknodeRegistry;

        store = _darknodePaymentStore;

        nextCyclePayoutPercent = _cyclePayoutPercent;

        

        cycleChanger = msg.sender;



        

        (currentCycle, cycleStartTime) = darknodeRegistry.currentEpoch();

        currentCyclePayoutPercent = nextCyclePayoutPercent;

    }



    

    

    

    

    function updateDarknodeRegistry(DarknodeRegistryLogicV1 _darknodeRegistry)

        external

        onlyOwner

    {

        require(

            address(_darknodeRegistry) != address(0x0),

            "DarknodePayment: invalid Darknode Registry address"

        );

        DarknodeRegistryLogicV1 previousDarknodeRegistry = darknodeRegistry;

        darknodeRegistry = _darknodeRegistry;

        emit LogDarknodeRegistryUpdated(

            previousDarknodeRegistry,

            darknodeRegistry

        );

    }



    

    

    

    

    

    function withdraw(address _darknode, address _token) public {

        address payable darknodeOperator = darknodeRegistry.getDarknodeOperator(

            _darknode

        );

        require(

            darknodeOperator != address(0x0),

            "DarknodePayment: invalid darknode owner"

        );



        uint256 amount = store.darknodeBalances(_darknode, _token);



        

        if (amount > 0) {

            store.transfer(_darknode, _token, amount, darknodeOperator);

            emit LogDarknodeWithdrew(

                darknodeOperator,

                _darknode,

                _token,

                amount

            );

        }

    }



    function withdrawMultiple(

        address[] calldata _darknodes,

        address[] calldata _tokens

    ) external {

        for (uint256 i = 0; i < _darknodes.length; i++) {

            for (uint256 j = 0; j < _tokens.length; j++) {

                withdraw(_darknodes[i], _tokens[j]);

            }

        }

    }



    

    function() external payable {

        address(store).transfer(msg.value);

        emit LogPaymentReceived(msg.sender, ETHEREUM, msg.value);

    }



    

    

    function currentCycleRewardPool(address _token)

        external

        view

        returns (uint256)

    {

        uint256 total = store.availableBalance(_token).sub(

            unclaimedRewards[_token],

            "DarknodePayment: unclaimed rewards exceed total rewards"

        );

        return total.div(100).mul(currentCyclePayoutPercent);

    }



    function darknodeBalances(address _darknodeID, address _token)

        external

        view

        returns (uint256)

    {

        return store.darknodeBalances(_darknodeID, _token);

    }



    

    function changeCycle() external onlyCycleChanger returns (uint256) {

        

        uint256 arrayLength = registeredTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            _snapshotBalance(registeredTokens[i]);

        }



        

        previousCycle = currentCycle;

        (currentCycle, cycleStartTime) = darknodeRegistry.currentEpoch();

        currentCyclePayoutPercent = nextCyclePayoutPercent;



        

        _updateTokenList();

        return currentCycle;

    }



    

    

    

    

    function deposit(uint256 _value, address _token) external payable {

        uint256 receivedValue;

        if (_token == ETHEREUM) {

            require(

                _value == msg.value,

                "DarknodePayment: mismatched deposit value"

            );

            receivedValue = msg.value;

            address(store).transfer(msg.value);

        } else {

            require(

                msg.value == 0,

                "DarknodePayment: unexpected ether transfer"

            );

            require(

                registeredTokenIndex[_token] != 0,

                "DarknodePayment: token not registered"

            );

            

            receivedValue = ERC20(_token).safeTransferFromWithFees(

                msg.sender,

                address(store),

                _value

            );

        }

        emit LogPaymentReceived(msg.sender, _token, receivedValue);

    }



    

    

    

    

    function forward(address _token) external {

        if (_token == ETHEREUM) {

            

            

            

            

            address(store).transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                address(store),

                ERC20(_token).balanceOf(address(this))

            );

        }

    }



    

    

    function claim(address _darknode) external onlyDarknode(_darknode) {

        require(

            darknodeRegistry.isRegisteredInPreviousEpoch(_darknode),

            "DarknodePayment: cannot claim for this epoch"

        );

        

        _claimDarknodeReward(_darknode);

        emit LogDarknodeClaim(_darknode, previousCycle);

    }



    

    

    

    

    function registerToken(address _token) external onlyOwner {

        require(

            registeredTokenIndex[_token] == 0,

            "DarknodePayment: token already registered"

        );

        require(

            !tokenPendingRegistration(_token),

            "DarknodePayment: token already pending registration"

        );

        pendingTokens.push(_token);

    }



    function tokenPendingRegistration(address _token)

        public

        view

        returns (bool)

    {

        uint256 arrayLength = pendingTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            if (pendingTokens[i] == _token) {

                return true;

            }

        }

        return false;

    }



    

    

    

    

    function deregisterToken(address _token) external onlyOwner {

        require(

            registeredTokenIndex[_token] > 0,

            "DarknodePayment: token not registered"

        );

        _deregisterToken(_token);

    }



    

    

    

    function updateCycleChanger(address _addr) external onlyOwner {

        require(

            _addr != address(0),

            "DarknodePayment: invalid contract address"

        );

        emit LogCycleChangerChanged(_addr, cycleChanger);

        cycleChanger = _addr;

    }



    

    

    

    function updatePayoutPercentage(uint256 _percent)

        external

        onlyOwner

        validPercent(_percent)

    {

        uint256 oldPayoutPercent = nextCyclePayoutPercent;

        nextCyclePayoutPercent = _percent;

        emit LogPayoutPercentChanged(nextCyclePayoutPercent, oldPayoutPercent);

    }



    

    

    

    

    function transferStoreOwnership(DarknodePayment _newOwner)

        external

        onlyOwner

    {

        store.transferOwnership(address(_newOwner));

        _newOwner.claimStoreOwnership();

    }



    

    

    

    function claimStoreOwnership() external {

        store.claimOwnership();

    }



    

    

    

    

    

    function _claimDarknodeReward(address _darknode) private {

        require(

            !rewardClaimed[_darknode][previousCycle],

            "DarknodePayment: reward already claimed"

        );

        rewardClaimed[_darknode][previousCycle] = true;

        uint256 arrayLength = registeredTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            address token = registeredTokens[i];



            

            if (previousCycleRewardShare[token] > 0) {

                unclaimedRewards[token] = unclaimedRewards[token].sub(

                    previousCycleRewardShare[token],

                    "DarknodePayment: share exceeds unclaimed rewards"

                );

                store.incrementDarknodeBalance(

                    _darknode,

                    token,

                    previousCycleRewardShare[token]

                );

            }

        }

    }



    

    

    

    

    function _snapshotBalance(address _token) private {

        uint256 shareCount = darknodeRegistry.numDarknodesPreviousEpoch();

        if (shareCount == 0) {

            unclaimedRewards[_token] = 0;

            previousCycleRewardShare[_token] = 0;

        } else {

            

            uint256 total = store.availableBalance(_token);

            unclaimedRewards[_token] = total.div(100).mul(

                currentCyclePayoutPercent

            );

            previousCycleRewardShare[_token] = unclaimedRewards[_token].div(

                shareCount

            );

        }

    }



    

    

    

    

    function _deregisterToken(address _token) private {

        address lastToken = registeredTokens[registeredTokens.length.sub(

            1,

            "DarknodePayment: no tokens registered"

        )];

        uint256 deletedTokenIndex = registeredTokenIndex[_token].sub(1);

        

        registeredTokens[deletedTokenIndex] = lastToken;

        registeredTokenIndex[lastToken] = registeredTokenIndex[_token];

        

        

        registeredTokens.pop();

        registeredTokenIndex[_token] = 0;



        emit LogTokenDeregistered(_token);

    }



    

    

    function _updateTokenList() private {

        

        uint256 arrayLength = pendingTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            address token = pendingTokens[i];

            registeredTokens.push(token);

            registeredTokenIndex[token] = registeredTokens.length;

            emit LogTokenRegistered(token);

        }

        pendingTokens.length = 0;

    }



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\DarknodePaymentStore.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-03-25

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 9068f80

Repository: https://github.com/renproject/darknode-sol

Issues: https://github.com/renproject/darknode-sol/issues



Licenses

@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE



*/



pragma solidity 0.5.16;





library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library Math {

    

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        

        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

    }

}



library ERC20WithFees {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    

    

    function safeTransferFromWithFees(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal returns (uint256) {

        uint256 balancesBefore = token.balanceOf(to);

        token.safeTransferFrom(from, to, value);

        uint256 balancesAfter = token.balanceOf(to);

        return Math.min(value, balancesAfter.sub(balancesBefore));

    }

}



contract DarknodePaymentStore is Claimable {

    using SafeMath for uint256;

    using SafeERC20 for ERC20;

    using ERC20WithFees for ERC20;



    string public VERSION; 



    

    address public constant ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    

    mapping(address => mapping(address => uint256)) public darknodeBalances;



    

    mapping(address => uint256) public lockedBalances;



    

    

    

    constructor(string memory _VERSION) public {

        Claimable.initialize(msg.sender);

        VERSION = _VERSION;

    }



    

    function() external payable {}



    

    

    

    

    function totalBalance(address _token) public view returns (uint256) {

        if (_token == ETHEREUM) {

            return address(this).balance;

        } else {

            return ERC20(_token).balanceOf(address(this));

        }

    }



    

    

    

    

    

    

    function availableBalance(address _token) public view returns (uint256) {

        return

            totalBalance(_token).sub(

                lockedBalances[_token],

                "DarknodePaymentStore: locked balance exceed total balance"

            );

    }



    

    

    

    

    

    

    function incrementDarknodeBalance(

        address _darknode,

        address _token,

        uint256 _amount

    ) external onlyOwner {

        require(_amount > 0, "DarknodePaymentStore: invalid amount");

        require(

            availableBalance(_token) >= _amount,

            "DarknodePaymentStore: insufficient contract balance"

        );



        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token]

            .add(_amount);

        lockedBalances[_token] = lockedBalances[_token].add(_amount);

    }



    

    

    

    

    

    

    function transfer(

        address _darknode,

        address _token,

        uint256 _amount,

        address payable _recipient

    ) external onlyOwner {

        require(

            darknodeBalances[_darknode][_token] >= _amount,

            "DarknodePaymentStore: insufficient darknode balance"

        );

        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token]

            .sub(

            _amount,

            "DarknodePaymentStore: insufficient darknode balance for transfer"

        );

        lockedBalances[_token] = lockedBalances[_token].sub(

            _amount,

            "DarknodePaymentStore: insufficient token balance for transfer"

        );



        if (_token == ETHEREUM) {

            _recipient.transfer(_amount);

        } else {

            ERC20(_token).safeTransfer(_recipient, _amount);

        }

    }



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\DarknodeRegistryLogicV1.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-03-25

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 9068f80

Repository: https://github.com/renproject/darknode-sol

Issues: https://github.com/renproject/darknode-sol/issues



Licenses

@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE



*/



pragma solidity 0.5.16;





library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract Proxy {

  

  function () payable external {

    _fallback();

  }



  

  function _implementation() internal view returns (address);



  

  function _delegate(address implementation) internal {

    assembly {

      

      

      

      calldatacopy(0, 0, calldatasize)



      

      

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      

      returndatacopy(0, 0, returndatasize)



      switch result

      

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  

  function _willFallback() internal {

  }



  

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



library OpenZeppelinUpgradesAddress {

    

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        

        

        

        

        

        

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



contract BaseUpgradeabilityProxy is Proxy {

  

  event Upgraded(address indexed implementation);



  

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



  

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  

  function _setImplementation(address newImplementation) internal {

    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  constructor(address _logic, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  event AdminChanged(address previousAdmin, address newAdmin);



  



  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



  

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  

  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    (bool success,) = newImplementation.delegatecall(data);

    require(success);

  }



  

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  function initialize(address _logic, bytes memory _data) public payable {

    require(_implementation() == address(0));

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {

  

  function initialize(address _logic, address _admin, bytes memory _data) public payable {

    require(_implementation() == address(0));

    InitializableUpgradeabilityProxy.initialize(_logic, _data);

    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));

    _setAdmin(_admin);

  }

}



contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



library Roles {

    struct Role {

        mapping (address => bool) bearer;

    }



    

    function add(Role storage role, address account) internal {

        require(!has(role, account), "Roles: account already has role");

        role.bearer[account] = true;

    }



    

    function remove(Role storage role, address account) internal {

        require(has(role, account), "Roles: account does not have role");

        role.bearer[account] = false;

    }



    

    function has(Role storage role, address account) internal view returns (bool) {

        require(account != address(0), "Roles: account is the zero address");

        return role.bearer[account];

    }

}



contract PauserRole is Initializable, Context {

    using Roles for Roles.Role;



    event PauserAdded(address indexed account);

    event PauserRemoved(address indexed account);



    Roles.Role private _pausers;



    function initialize(address sender) public initializer {

        if (!isPauser(sender)) {

            _addPauser(sender);

        }

    }



    modifier onlyPauser() {

        require(isPauser(_msgSender()), "PauserRole: caller does not have the Pauser role");

        _;

    }



    function isPauser(address account) public view returns (bool) {

        return _pausers.has(account);

    }



    function addPauser(address account) public onlyPauser {

        _addPauser(account);

    }



    function renouncePauser() public {

        _removePauser(_msgSender());

    }



    function _addPauser(address account) internal {

        _pausers.add(account);

        emit PauserAdded(account);

    }



    function _removePauser(address account) internal {

        _pausers.remove(account);

        emit PauserRemoved(account);

    }



    uint256[50] private ______gap;

}



contract Pausable is Initializable, Context, PauserRole {

    

    event Paused(address account);



    

    event Unpaused(address account);



    bool private _paused;



    

    function initialize(address sender) public initializer {

        PauserRole.initialize(sender);



        _paused = false;

    }



    

    function paused() public view returns (bool) {

        return _paused;

    }



    

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    

    function pause() public onlyPauser whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    

    function unpause() public onlyPauser whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }



    uint256[50] private ______gap;

}



contract ERC20Pausable is Initializable, ERC20, Pausable {

    function initialize(address sender) public initializer {

        Pausable.initialize(sender);

    }



    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transfer(to, value);

    }



    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transferFrom(from, to, value);

    }



    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {

        return super.approve(spender, value);

    }



    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {

        return super.increaseAllowance(spender, addedValue);

    }



    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {

        return super.decreaseAllowance(spender, subtractedValue);

    }



    uint256[50] private ______gap;

}



contract ERC20Burnable is Initializable, Context, ERC20 {

    

    function burn(uint256 amount) public {

        _burn(_msgSender(), amount);

    }



    

    function burnFrom(address account, uint256 amount) public {

        _burnFrom(account, amount);

    }



    uint256[50] private ______gap;

}



contract RenToken is Ownable, ERC20Detailed, ERC20Pausable, ERC20Burnable {

    string private constant _name = "REN";

    string private constant _symbol = "REN";

    uint8 private constant _decimals = 18;



    uint256 public constant INITIAL_SUPPLY = 1000000000 *

        10**uint256(_decimals);



    

    constructor() public {

        ERC20Pausable.initialize(msg.sender);

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        Ownable.initialize(msg.sender);

        _mint(msg.sender, INITIAL_SUPPLY);

    }



    function transferTokens(address beneficiary, uint256 amount)

        public

        onlyOwner

        returns (bool)

    {

        

        

        require(amount > 0);



        _transfer(msg.sender, beneficiary, amount);

        emit Transfer(msg.sender, beneficiary, amount);



        return true;

    }

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library LinkedList {



    

    address public constant NULL = address(0);



    

    struct Node {

        bool inList;

        address previous;

        address next;

    }



    

    struct List {

        mapping (address => Node) list;

    }



    

    function insertBefore(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address prev = self.list[target].previous;



        self.list[newNode].next = target;

        self.list[newNode].previous = prev;

        self.list[target].previous = newNode;

        self.list[prev].next = newNode;



        self.list[newNode].inList = true;

    }



    

    function insertAfter(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address n = self.list[target].next;



        self.list[newNode].previous = target;

        self.list[newNode].next = n;

        self.list[target].next = newNode;

        self.list[n].previous = newNode;



        self.list[newNode].inList = true;

    }



    

    function remove(List storage self, address node) internal {

        require(isInList(self, node), "LinkedList: not in list");

        

        address p = self.list[node].previous;

        address n = self.list[node].next;



        self.list[p].next = n;

        self.list[n].previous = p;



        

        

        self.list[node].inList = false;

        delete self.list[node];

    }



    

    function prepend(List storage self, address node) internal {

        



        insertBefore(self, begin(self), node);

    }



    

    function append(List storage self, address node) internal {

        



        insertAfter(self, end(self), node);

    }



    function swap(List storage self, address left, address right) internal {

        



        address previousRight = self.list[right].previous;

        remove(self, right);

        insertAfter(self, left, right);

        remove(self, left);

        insertAfter(self, previousRight, left);

    }



    function isInList(List storage self, address node) internal view returns (bool) {

        return self.list[node].inList;

    }



    

    function begin(List storage self) internal view returns (address) {

        return self.list[NULL].next;

    }



    

    function end(List storage self) internal view returns (address) {

        return self.list[NULL].previous;

    }



    function next(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].next;

    }



    function previous(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].previous;

    }



    function elements(List storage self, address _start, uint256 _count) internal view returns (address[] memory) {

        require(_count > 0, "LinkedList: invalid count");

        require(isInList(self, _start) || _start == address(0), "LinkedList: not in list");

        address[] memory elems = new address[](_count);



        

        uint256 n = 0;

        address nextItem = _start;

        if (nextItem == address(0)) {

            nextItem = begin(self);

        }



        while (n < _count) {

            if (nextItem == address(0)) {

                break;

            }

            elems[n] = nextItem;

            nextItem = next(self, nextItem);

            n += 1;

        }

        return elems;

    }

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    

    

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}



contract DarknodeRegistryStore is Claimable, CanReclaimTokens {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    

    

    struct Darknode {

        

        

        

        

        address payable owner;

        

        

        

        uint256 bond;

        

        uint256 registeredAt;

        

        uint256 deregisteredAt;

        

        

        

        

        bytes publicKey;

    }



    

    mapping(address => Darknode) private darknodeRegistry;

    LinkedList.List private darknodes;



    

    RenToken public ren;



    

    

    

    

    constructor(string memory _VERSION, RenToken _ren) public {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;

        ren = _ren;

        blacklistRecoverableToken(address(ren));

    }



    

    

    

    

    

    

    

    

    

    function appendDarknode(

        address _darknodeID,

        address payable _darknodeOperator,

        uint256 _bond,

        bytes calldata _publicKey,

        uint256 _registeredAt,

        uint256 _deregisteredAt

    ) external onlyOwner {

        Darknode memory darknode = Darknode({

            owner: _darknodeOperator,

            bond: _bond,

            publicKey: _publicKey,

            registeredAt: _registeredAt,

            deregisteredAt: _deregisteredAt

        });

        darknodeRegistry[_darknodeID] = darknode;

        LinkedList.append(darknodes, _darknodeID);

    }



    

    function begin() external view onlyOwner returns (address) {

        return LinkedList.begin(darknodes);

    }



    

    

    function next(address darknodeID)

        external

        view

        onlyOwner

        returns (address)

    {

        return LinkedList.next(darknodes, darknodeID);

    }



    

    

    function removeDarknode(address darknodeID) external onlyOwner {

        uint256 bond = darknodeRegistry[darknodeID].bond;

        delete darknodeRegistry[darknodeID];

        LinkedList.remove(darknodes, darknodeID);

        require(

            ren.transfer(owner(), bond),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    

    function updateDarknodeBond(address darknodeID, uint256 decreasedBond)

        external

        onlyOwner

    {

        uint256 previousBond = darknodeRegistry[darknodeID].bond;

        require(

            decreasedBond < previousBond,

            "DarknodeRegistryStore: bond not decreased"

        );

        darknodeRegistry[darknodeID].bond = decreasedBond;

        require(

            ren.transfer(owner(), previousBond.sub(decreasedBond)),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    function updateDarknodeDeregisteredAt(

        address darknodeID,

        uint256 deregisteredAt

    ) external onlyOwner {

        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;

    }



    

    function darknodeOperator(address darknodeID)

        external

        view

        onlyOwner

        returns (address payable)

    {

        return darknodeRegistry[darknodeID].owner;

    }



    

    function darknodeBond(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].bond;

    }



    

    function darknodeRegisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].registeredAt;

    }



    

    function darknodeDeregisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].deregisteredAt;

    }



    

    function darknodePublicKey(address darknodeID)

        external

        view

        onlyOwner

        returns (bytes memory)

    {

        return darknodeRegistry[darknodeID].publicKey;

    }

}



interface IDarknodePaymentStore {}



interface IDarknodePayment {

    function changeCycle() external returns (uint256);

    function store() external view returns (IDarknodePaymentStore);

}



interface IDarknodeSlasher {}



contract DarknodeRegistryStateV1 {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    struct Epoch {

        uint256 epochhash;

        uint256 blocktime;

    }



    uint256 public numDarknodes;

    uint256 public numDarknodesNextEpoch;

    uint256 public numDarknodesPreviousEpoch;



    

    uint256 public minimumBond;

    uint256 public minimumPodSize;

    uint256 public minimumEpochInterval;

    uint256 public deregistrationInterval;



    

    

    

    uint256 public nextMinimumBond;

    uint256 public nextMinimumPodSize;

    uint256 public nextMinimumEpochInterval;



    

    Epoch public currentEpoch;

    Epoch public previousEpoch;



    

    RenToken public ren;



    

    DarknodeRegistryStore public store;



    

    IDarknodePayment public darknodePayment;



    

    IDarknodeSlasher public slasher;

    IDarknodeSlasher public nextSlasher;

}



contract DarknodeRegistryLogicV1 is

    Claimable,

    CanReclaimTokens,

    DarknodeRegistryStateV1

{

    

    

    

    

    event LogDarknodeRegistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _bond

    );



    

    

    

    event LogDarknodeDeregistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID

    );



    

    

    

    event LogDarknodeRefunded(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _amount

    );



    

    

    

    

    

    event LogDarknodeSlashed(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        address indexed _challenger,

        uint256 _percentage

    );



    

    event LogNewEpoch(uint256 indexed epochhash);



    

    event LogMinimumBondUpdated(

        uint256 _previousMinimumBond,

        uint256 _nextMinimumBond

    );

    event LogMinimumPodSizeUpdated(

        uint256 _previousMinimumPodSize,

        uint256 _nextMinimumPodSize

    );

    event LogMinimumEpochIntervalUpdated(

        uint256 _previousMinimumEpochInterval,

        uint256 _nextMinimumEpochInterval

    );

    event LogSlasherUpdated(

        address indexed _previousSlasher,

        address indexed _nextSlasher

    );

    event LogDarknodePaymentUpdated(

        IDarknodePayment indexed _previousDarknodePayment,

        IDarknodePayment indexed _nextDarknodePayment

    );



    

    modifier onlyDarknodeOperator(address _darknodeID) {

        require(

            store.darknodeOperator(_darknodeID) == msg.sender,

            "DarknodeRegistry: must be darknode owner"

        );

        _;

    }



    

    modifier onlyRefunded(address _darknodeID) {

        require(

            isRefunded(_darknodeID),

            "DarknodeRegistry: must be refunded or never registered"

        );

        _;

    }



    

    modifier onlyRefundable(address _darknodeID) {

        require(

            isRefundable(_darknodeID),

            "DarknodeRegistry: must be deregistered for at least one epoch"

        );

        _;

    }



    

    

    modifier onlyDeregisterable(address _darknodeID) {

        require(

            isDeregisterable(_darknodeID),

            "DarknodeRegistry: must be deregisterable"

        );

        _;

    }



    

    modifier onlySlasher() {

        require(

            address(slasher) == msg.sender,

            "DarknodeRegistry: must be slasher"

        );

        _;

    }



    

    

    modifier onlyDarknode(address _darknodeID) {

        require(

            isRegistered(_darknodeID),

            "DarknodeRegistry: invalid darknode"

        );

        _;

    }



    

    

    

    

    

    

    

    

    

    function initialize(

        string memory _VERSION,

        RenToken _renAddress,

        DarknodeRegistryStore _storeAddress,

        uint256 _minimumBond,

        uint256 _minimumPodSize,

        uint256 _minimumEpochIntervalSeconds,

        uint256 _deregistrationIntervalSeconds

    ) public initializer {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;



        store = _storeAddress;

        ren = _renAddress;



        minimumBond = _minimumBond;

        nextMinimumBond = minimumBond;



        minimumPodSize = _minimumPodSize;

        nextMinimumPodSize = minimumPodSize;



        minimumEpochInterval = _minimumEpochIntervalSeconds;

        nextMinimumEpochInterval = minimumEpochInterval;

        deregistrationInterval = _deregistrationIntervalSeconds;



        uint256 epochhash = uint256(blockhash(block.number - 1));

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });

        emit LogNewEpoch(epochhash);

    }



    

    

    

    

    

    

    

    

    

    

    function register(address _darknodeID, bytes calldata _publicKey)

        external

        onlyRefunded(_darknodeID)

    {

        require(

            _darknodeID != address(0),

            "DarknodeRegistry: darknode address cannot be zero"

        );



        

        require(

            ren.transferFrom(msg.sender, address(store), minimumBond),

            "DarknodeRegistry: bond transfer failed"

        );



        

        store.appendDarknode(

            _darknodeID,

            msg.sender,

            minimumBond,

            _publicKey,

            currentEpoch.blocktime.add(minimumEpochInterval),

            0

        );



        numDarknodesNextEpoch = numDarknodesNextEpoch.add(1);



        

        emit LogDarknodeRegistered(msg.sender, _darknodeID, minimumBond);

    }



    

    

    

    

    

    

    function deregister(address _darknodeID)

        external

        onlyDeregisterable(_darknodeID)

        onlyDarknodeOperator(_darknodeID)

    {

        deregisterDarknode(_darknodeID);

    }



    

    

    

    function epoch() external {

        if (previousEpoch.blocktime == 0) {

            

            require(

                msg.sender == owner(),

                "DarknodeRegistry: not authorized to call first epoch"

            );

        }



        

        require(

            block.timestamp >= currentEpoch.blocktime.add(minimumEpochInterval),

            "DarknodeRegistry: epoch interval has not passed"

        );

        uint256 epochhash = uint256(blockhash(block.number - 1));



        

        previousEpoch = currentEpoch;

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });



        

        numDarknodesPreviousEpoch = numDarknodes;

        numDarknodes = numDarknodesNextEpoch;



        

        if (nextMinimumBond != minimumBond) {

            minimumBond = nextMinimumBond;

            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);

        }

        if (nextMinimumPodSize != minimumPodSize) {

            minimumPodSize = nextMinimumPodSize;

            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);

        }

        if (nextMinimumEpochInterval != minimumEpochInterval) {

            minimumEpochInterval = nextMinimumEpochInterval;

            emit LogMinimumEpochIntervalUpdated(

                minimumEpochInterval,

                nextMinimumEpochInterval

            );

        }

        if (nextSlasher != slasher) {

            slasher = nextSlasher;

            emit LogSlasherUpdated(address(slasher), address(nextSlasher));

        }

        if (address(darknodePayment) != address(0x0)) {

            darknodePayment.changeCycle();

        }



        

        emit LogNewEpoch(epochhash);

    }



    

    

    

    function transferStoreOwnership(DarknodeRegistryLogicV1 _newOwner)

        external

        onlyOwner

    {

        store.transferOwnership(address(_newOwner));

        _newOwner.claimStoreOwnership();

    }



    

    

    

    function claimStoreOwnership() external {

        store.claimOwnership();



        

        

        (

            numDarknodesPreviousEpoch,

            numDarknodes,

            numDarknodesNextEpoch

        ) = getDarknodeCountFromEpochs();

    }



    

    

    

    

    function updateDarknodePayment(IDarknodePayment _darknodePayment)

        external

        onlyOwner

    {

        require(

            address(_darknodePayment) != address(0x0),

            "DarknodeRegistry: invalid Darknode Payment address"

        );

        IDarknodePayment previousDarknodePayment = darknodePayment;

        darknodePayment = _darknodePayment;

        emit LogDarknodePaymentUpdated(

            previousDarknodePayment,

            darknodePayment

        );

    }



    

    

    

    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {

        

        nextMinimumBond = _nextMinimumBond;

    }



    

    

    function updateMinimumPodSize(uint256 _nextMinimumPodSize)

        external

        onlyOwner

    {

        

        nextMinimumPodSize = _nextMinimumPodSize;

    }



    

    

    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval)

        external

        onlyOwner

    {

        

        nextMinimumEpochInterval = _nextMinimumEpochInterval;

    }



    

    

    

    function updateSlasher(IDarknodeSlasher _slasher) external onlyOwner {

        require(

            address(_slasher) != address(0),

            "DarknodeRegistry: invalid slasher address"

        );

        nextSlasher = _slasher;

    }



    

    

    

    

    

    function slash(address _guilty, address _challenger, uint256 _percentage)

        external

        onlySlasher

        onlyDarknode(_guilty)

    {

        require(_percentage <= 100, "DarknodeRegistry: invalid percent");



        

        if (isDeregisterable(_guilty)) {

            deregisterDarknode(_guilty);

        }



        uint256 totalBond = store.darknodeBond(_guilty);

        uint256 penalty = totalBond.div(100).mul(_percentage);

        uint256 challengerReward = penalty.div(2);

        uint256 darknodePaymentReward = penalty.sub(challengerReward);

        if (challengerReward > 0) {

            

            store.updateDarknodeBond(_guilty, totalBond.sub(penalty));



            

            require(

                address(darknodePayment) != address(0x0),

                "DarknodeRegistry: invalid payment address"

            );

            require(

                ren.transfer(

                    address(darknodePayment.store()),

                    darknodePaymentReward

                ),

                "DarknodeRegistry: reward transfer failed"

            );

            require(

                ren.transfer(_challenger, challengerReward),

                "DarknodeRegistry: reward transfer failed"

            );

        }



        emit LogDarknodeSlashed(

            store.darknodeOperator(_guilty),

            _guilty,

            _challenger,

            _percentage

        );

    }



    

    

    

    

    

    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        uint256 amount = store.darknodeBond(_darknodeID);



        

        store.removeDarknode(_darknodeID);



        

        require(

            ren.transfer(darknodeOperator, amount),

            "DarknodeRegistry: bond transfer failed"

        );



        

        emit LogDarknodeRefunded(darknodeOperator, _darknodeID, amount);

    }



    

    

    function getDarknodeOperator(address _darknodeID)

        external

        view

        returns (address payable)

    {

        return store.darknodeOperator(_darknodeID);

    }



    

    

    function getDarknodeBond(address _darknodeID)

        external

        view

        returns (uint256)

    {

        return store.darknodeBond(_darknodeID);

    }



    

    

    function getDarknodePublicKey(address _darknodeID)

        external

        view

        returns (bytes memory)

    {

        return store.darknodePublicKey(_darknodeID);

    }



    

    

    

    

    

    

    

    

    

    

    function getDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }

        return getDarknodesFromEpochs(_start, count, false);

    }



    

    

    function getPreviousDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodesPreviousEpoch;

        }

        return getDarknodesFromEpochs(_start, count, true);

    }



    

    

    

    function isPendingRegistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        return registeredAt != 0 && registeredAt > currentEpoch.blocktime;

    }



    

    

    function isPendingDeregistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocktime;

    }



    

    function isDeregistered(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocktime;

    }



    

    

    

    function isDeregisterable(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        

        

        return isRegistered(_darknodeID) && deregisteredAt == 0;

    }



    

    

    

    function isRefunded(address _darknodeID) public view returns (bool) {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return registeredAt == 0 && deregisteredAt == 0;

    }



    

    

    function isRefundable(address _darknodeID) public view returns (bool) {

        return

            isDeregistered(_darknodeID) &&

            store.darknodeDeregisteredAt(_darknodeID) <=

            (previousEpoch.blocktime - deregistrationInterval);

    }



    

    function isRegistered(address _darknodeID) public view returns (bool) {

        return isRegisteredInEpoch(_darknodeID, currentEpoch);

    }



    

    function isRegisteredInPreviousEpoch(address _darknodeID)

        public

        view

        returns (bool)

    {

        return isRegisteredInEpoch(_darknodeID, previousEpoch);

    }



    

    

    

    

    function isRegisteredInEpoch(address _darknodeID, Epoch memory _epoch)

        private

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocktime;

        bool notDeregistered = deregisteredAt == 0 ||

            deregisteredAt > _epoch.blocktime;

        

        

        return registered && notDeregistered;

    }



    

    

    

    

    

    function getDarknodesFromEpochs(

        address _start,

        uint256 _count,

        bool _usePreviousEpoch

    ) private view returns (address[] memory) {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }



        address[] memory nodes = new address[](count);



        

        uint256 n = 0;

        address next = _start;

        if (next == address(0)) {

            next = store.begin();

        }



        

        while (n < count) {

            if (next == address(0)) {

                break;

            }

            

            bool includeNext;

            if (_usePreviousEpoch) {

                includeNext = isRegisteredInPreviousEpoch(next);

            } else {

                includeNext = isRegistered(next);

            }

            if (!includeNext) {

                next = store.next(next);

                continue;

            }

            nodes[n] = next;

            next = store.next(next);

            n += 1;

        }

        return nodes;

    }



    

    function deregisterDarknode(address _darknodeID) private {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        store.updateDarknodeDeregisteredAt(

            _darknodeID,

            currentEpoch.blocktime.add(minimumEpochInterval)

        );

        numDarknodesNextEpoch = numDarknodesNextEpoch.sub(1);



        

        emit LogDarknodeDeregistered(darknodeOperator, _darknodeID);

    }



    function getDarknodeCountFromEpochs()

        private

        view

        returns (uint256, uint256, uint256)

    {

        

        uint256 nPreviousEpoch = 0;

        uint256 nCurrentEpoch = 0;

        uint256 nNextEpoch = 0;

        address next = store.begin();



        

        while (true) {

            

            if (next == address(0)) {

                break;

            }



            if (isRegisteredInPreviousEpoch(next)) {

                nPreviousEpoch += 1;

            }



            if (isRegistered(next)) {

                nCurrentEpoch += 1;

            }



            

            

            if (

                ((isRegistered(next) && !isPendingDeregistration(next)) ||

                    isPendingRegistration(next))

            ) {

                nNextEpoch += 1;

            }

            next = store.next(next);

        }

        return (nPreviousEpoch, nCurrentEpoch, nNextEpoch);

    }

}



contract DarknodeRegistryProxy is InitializableAdminUpgradeabilityProxy {}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\DarknodeRegistryProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-03-25

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 9068f80

Repository: https://github.com/renproject/darknode-sol

Issues: https://github.com/renproject/darknode-sol/issues



Licenses

@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE



*/



pragma solidity 0.5.16;





library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract Proxy {

  

  function () payable external {

    _fallback();

  }



  

  function _implementation() internal view returns (address);



  

  function _delegate(address implementation) internal {

    assembly {

      

      

      

      calldatacopy(0, 0, calldatasize)



      

      

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      

      returndatacopy(0, 0, returndatasize)



      switch result

      

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  

  function _willFallback() internal {

  }



  

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



library OpenZeppelinUpgradesAddress {

    

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        

        

        

        

        

        

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



contract BaseUpgradeabilityProxy is Proxy {

  

  event Upgraded(address indexed implementation);



  

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



  

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  

  function _setImplementation(address newImplementation) internal {

    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  constructor(address _logic, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  event AdminChanged(address previousAdmin, address newAdmin);



  



  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



  

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  

  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    (bool success,) = newImplementation.delegatecall(data);

    require(success);

  }



  

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  function initialize(address _logic, bytes memory _data) public payable {

    require(_implementation() == address(0));

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {

  

  function initialize(address _logic, address _admin, bytes memory _data) public payable {

    require(_implementation() == address(0));

    InitializableUpgradeabilityProxy.initialize(_logic, _data);

    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));

    _setAdmin(_admin);

  }

}



contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



library Roles {

    struct Role {

        mapping (address => bool) bearer;

    }



    

    function add(Role storage role, address account) internal {

        require(!has(role, account), "Roles: account already has role");

        role.bearer[account] = true;

    }



    

    function remove(Role storage role, address account) internal {

        require(has(role, account), "Roles: account does not have role");

        role.bearer[account] = false;

    }



    

    function has(Role storage role, address account) internal view returns (bool) {

        require(account != address(0), "Roles: account is the zero address");

        return role.bearer[account];

    }

}



contract PauserRole is Initializable, Context {

    using Roles for Roles.Role;



    event PauserAdded(address indexed account);

    event PauserRemoved(address indexed account);



    Roles.Role private _pausers;



    function initialize(address sender) public initializer {

        if (!isPauser(sender)) {

            _addPauser(sender);

        }

    }



    modifier onlyPauser() {

        require(isPauser(_msgSender()), "PauserRole: caller does not have the Pauser role");

        _;

    }



    function isPauser(address account) public view returns (bool) {

        return _pausers.has(account);

    }



    function addPauser(address account) public onlyPauser {

        _addPauser(account);

    }



    function renouncePauser() public {

        _removePauser(_msgSender());

    }



    function _addPauser(address account) internal {

        _pausers.add(account);

        emit PauserAdded(account);

    }



    function _removePauser(address account) internal {

        _pausers.remove(account);

        emit PauserRemoved(account);

    }



    uint256[50] private ______gap;

}



contract Pausable is Initializable, Context, PauserRole {

    

    event Paused(address account);



    

    event Unpaused(address account);



    bool private _paused;



    

    function initialize(address sender) public initializer {

        PauserRole.initialize(sender);



        _paused = false;

    }



    

    function paused() public view returns (bool) {

        return _paused;

    }



    

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    

    function pause() public onlyPauser whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    

    function unpause() public onlyPauser whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }



    uint256[50] private ______gap;

}



contract ERC20Pausable is Initializable, ERC20, Pausable {

    function initialize(address sender) public initializer {

        Pausable.initialize(sender);

    }



    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transfer(to, value);

    }



    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transferFrom(from, to, value);

    }



    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {

        return super.approve(spender, value);

    }



    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {

        return super.increaseAllowance(spender, addedValue);

    }



    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {

        return super.decreaseAllowance(spender, subtractedValue);

    }



    uint256[50] private ______gap;

}



contract ERC20Burnable is Initializable, Context, ERC20 {

    

    function burn(uint256 amount) public {

        _burn(_msgSender(), amount);

    }



    

    function burnFrom(address account, uint256 amount) public {

        _burnFrom(account, amount);

    }



    uint256[50] private ______gap;

}



contract RenToken is Ownable, ERC20Detailed, ERC20Pausable, ERC20Burnable {

    string private constant _name = "REN";

    string private constant _symbol = "REN";

    uint8 private constant _decimals = 18;



    uint256 public constant INITIAL_SUPPLY = 1000000000 *

        10**uint256(_decimals);



    

    constructor() public {

        ERC20Pausable.initialize(msg.sender);

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        Ownable.initialize(msg.sender);

        _mint(msg.sender, INITIAL_SUPPLY);

    }



    function transferTokens(address beneficiary, uint256 amount)

        public

        onlyOwner

        returns (bool)

    {

        

        

        require(amount > 0);



        _transfer(msg.sender, beneficiary, amount);

        emit Transfer(msg.sender, beneficiary, amount);



        return true;

    }

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library LinkedList {



    

    address public constant NULL = address(0);



    

    struct Node {

        bool inList;

        address previous;

        address next;

    }



    

    struct List {

        mapping (address => Node) list;

    }



    

    function insertBefore(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address prev = self.list[target].previous;



        self.list[newNode].next = target;

        self.list[newNode].previous = prev;

        self.list[target].previous = newNode;

        self.list[prev].next = newNode;



        self.list[newNode].inList = true;

    }



    

    function insertAfter(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address n = self.list[target].next;



        self.list[newNode].previous = target;

        self.list[newNode].next = n;

        self.list[target].next = newNode;

        self.list[n].previous = newNode;



        self.list[newNode].inList = true;

    }



    

    function remove(List storage self, address node) internal {

        require(isInList(self, node), "LinkedList: not in list");

        

        address p = self.list[node].previous;

        address n = self.list[node].next;



        self.list[p].next = n;

        self.list[n].previous = p;



        

        

        self.list[node].inList = false;

        delete self.list[node];

    }



    

    function prepend(List storage self, address node) internal {

        



        insertBefore(self, begin(self), node);

    }



    

    function append(List storage self, address node) internal {

        



        insertAfter(self, end(self), node);

    }



    function swap(List storage self, address left, address right) internal {

        



        address previousRight = self.list[right].previous;

        remove(self, right);

        insertAfter(self, left, right);

        remove(self, left);

        insertAfter(self, previousRight, left);

    }



    function isInList(List storage self, address node) internal view returns (bool) {

        return self.list[node].inList;

    }



    

    function begin(List storage self) internal view returns (address) {

        return self.list[NULL].next;

    }



    

    function end(List storage self) internal view returns (address) {

        return self.list[NULL].previous;

    }



    function next(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].next;

    }



    function previous(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].previous;

    }



    function elements(List storage self, address _start, uint256 _count) internal view returns (address[] memory) {

        require(_count > 0, "LinkedList: invalid count");

        require(isInList(self, _start) || _start == address(0), "LinkedList: not in list");

        address[] memory elems = new address[](_count);



        

        uint256 n = 0;

        address nextItem = _start;

        if (nextItem == address(0)) {

            nextItem = begin(self);

        }



        while (n < _count) {

            if (nextItem == address(0)) {

                break;

            }

            elems[n] = nextItem;

            nextItem = next(self, nextItem);

            n += 1;

        }

        return elems;

    }

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    

    

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}



contract DarknodeRegistryStore is Claimable, CanReclaimTokens {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    

    

    struct Darknode {

        

        

        

        

        address payable owner;

        

        

        

        uint256 bond;

        

        uint256 registeredAt;

        

        uint256 deregisteredAt;

        

        

        

        

        bytes publicKey;

    }



    

    mapping(address => Darknode) private darknodeRegistry;

    LinkedList.List private darknodes;



    

    RenToken public ren;



    

    

    

    

    constructor(string memory _VERSION, RenToken _ren) public {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;

        ren = _ren;

        blacklistRecoverableToken(address(ren));

    }



    

    

    

    

    

    

    

    

    

    function appendDarknode(

        address _darknodeID,

        address payable _darknodeOperator,

        uint256 _bond,

        bytes calldata _publicKey,

        uint256 _registeredAt,

        uint256 _deregisteredAt

    ) external onlyOwner {

        Darknode memory darknode = Darknode({

            owner: _darknodeOperator,

            bond: _bond,

            publicKey: _publicKey,

            registeredAt: _registeredAt,

            deregisteredAt: _deregisteredAt

        });

        darknodeRegistry[_darknodeID] = darknode;

        LinkedList.append(darknodes, _darknodeID);

    }



    

    function begin() external view onlyOwner returns (address) {

        return LinkedList.begin(darknodes);

    }



    

    

    function next(address darknodeID)

        external

        view

        onlyOwner

        returns (address)

    {

        return LinkedList.next(darknodes, darknodeID);

    }



    

    

    function removeDarknode(address darknodeID) external onlyOwner {

        uint256 bond = darknodeRegistry[darknodeID].bond;

        delete darknodeRegistry[darknodeID];

        LinkedList.remove(darknodes, darknodeID);

        require(

            ren.transfer(owner(), bond),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    

    function updateDarknodeBond(address darknodeID, uint256 decreasedBond)

        external

        onlyOwner

    {

        uint256 previousBond = darknodeRegistry[darknodeID].bond;

        require(

            decreasedBond < previousBond,

            "DarknodeRegistryStore: bond not decreased"

        );

        darknodeRegistry[darknodeID].bond = decreasedBond;

        require(

            ren.transfer(owner(), previousBond.sub(decreasedBond)),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    function updateDarknodeDeregisteredAt(

        address darknodeID,

        uint256 deregisteredAt

    ) external onlyOwner {

        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;

    }



    

    function darknodeOperator(address darknodeID)

        external

        view

        onlyOwner

        returns (address payable)

    {

        return darknodeRegistry[darknodeID].owner;

    }



    

    function darknodeBond(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].bond;

    }



    

    function darknodeRegisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].registeredAt;

    }



    

    function darknodeDeregisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].deregisteredAt;

    }



    

    function darknodePublicKey(address darknodeID)

        external

        view

        onlyOwner

        returns (bytes memory)

    {

        return darknodeRegistry[darknodeID].publicKey;

    }

}



interface IDarknodePaymentStore {}



interface IDarknodePayment {

    function changeCycle() external returns (uint256);

    function store() external view returns (IDarknodePaymentStore);

}



interface IDarknodeSlasher {}



contract DarknodeRegistryStateV1 {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    struct Epoch {

        uint256 epochhash;

        uint256 blocktime;

    }



    uint256 public numDarknodes;

    uint256 public numDarknodesNextEpoch;

    uint256 public numDarknodesPreviousEpoch;



    

    uint256 public minimumBond;

    uint256 public minimumPodSize;

    uint256 public minimumEpochInterval;

    uint256 public deregistrationInterval;



    

    

    

    uint256 public nextMinimumBond;

    uint256 public nextMinimumPodSize;

    uint256 public nextMinimumEpochInterval;



    

    Epoch public currentEpoch;

    Epoch public previousEpoch;



    

    RenToken public ren;



    

    DarknodeRegistryStore public store;



    

    IDarknodePayment public darknodePayment;



    

    IDarknodeSlasher public slasher;

    IDarknodeSlasher public nextSlasher;

}



contract DarknodeRegistryLogicV1 is

    Claimable,

    CanReclaimTokens,

    DarknodeRegistryStateV1

{

    

    

    

    

    event LogDarknodeRegistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _bond

    );



    

    

    

    event LogDarknodeDeregistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID

    );



    

    

    

    event LogDarknodeRefunded(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _amount

    );



    

    

    

    

    

    event LogDarknodeSlashed(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        address indexed _challenger,

        uint256 _percentage

    );



    

    event LogNewEpoch(uint256 indexed epochhash);



    

    event LogMinimumBondUpdated(

        uint256 _previousMinimumBond,

        uint256 _nextMinimumBond

    );

    event LogMinimumPodSizeUpdated(

        uint256 _previousMinimumPodSize,

        uint256 _nextMinimumPodSize

    );

    event LogMinimumEpochIntervalUpdated(

        uint256 _previousMinimumEpochInterval,

        uint256 _nextMinimumEpochInterval

    );

    event LogSlasherUpdated(

        address indexed _previousSlasher,

        address indexed _nextSlasher

    );

    event LogDarknodePaymentUpdated(

        IDarknodePayment indexed _previousDarknodePayment,

        IDarknodePayment indexed _nextDarknodePayment

    );



    

    modifier onlyDarknodeOperator(address _darknodeID) {

        require(

            store.darknodeOperator(_darknodeID) == msg.sender,

            "DarknodeRegistry: must be darknode owner"

        );

        _;

    }



    

    modifier onlyRefunded(address _darknodeID) {

        require(

            isRefunded(_darknodeID),

            "DarknodeRegistry: must be refunded or never registered"

        );

        _;

    }



    

    modifier onlyRefundable(address _darknodeID) {

        require(

            isRefundable(_darknodeID),

            "DarknodeRegistry: must be deregistered for at least one epoch"

        );

        _;

    }



    

    

    modifier onlyDeregisterable(address _darknodeID) {

        require(

            isDeregisterable(_darknodeID),

            "DarknodeRegistry: must be deregisterable"

        );

        _;

    }



    

    modifier onlySlasher() {

        require(

            address(slasher) == msg.sender,

            "DarknodeRegistry: must be slasher"

        );

        _;

    }



    

    

    modifier onlyDarknode(address _darknodeID) {

        require(

            isRegistered(_darknodeID),

            "DarknodeRegistry: invalid darknode"

        );

        _;

    }



    

    

    

    

    

    

    

    

    

    function initialize(

        string memory _VERSION,

        RenToken _renAddress,

        DarknodeRegistryStore _storeAddress,

        uint256 _minimumBond,

        uint256 _minimumPodSize,

        uint256 _minimumEpochIntervalSeconds,

        uint256 _deregistrationIntervalSeconds

    ) public initializer {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;



        store = _storeAddress;

        ren = _renAddress;



        minimumBond = _minimumBond;

        nextMinimumBond = minimumBond;



        minimumPodSize = _minimumPodSize;

        nextMinimumPodSize = minimumPodSize;



        minimumEpochInterval = _minimumEpochIntervalSeconds;

        nextMinimumEpochInterval = minimumEpochInterval;

        deregistrationInterval = _deregistrationIntervalSeconds;



        uint256 epochhash = uint256(blockhash(block.number - 1));

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });

        emit LogNewEpoch(epochhash);

    }



    

    

    

    

    

    

    

    

    

    

    function register(address _darknodeID, bytes calldata _publicKey)

        external

        onlyRefunded(_darknodeID)

    {

        require(

            _darknodeID != address(0),

            "DarknodeRegistry: darknode address cannot be zero"

        );



        

        require(

            ren.transferFrom(msg.sender, address(store), minimumBond),

            "DarknodeRegistry: bond transfer failed"

        );



        

        store.appendDarknode(

            _darknodeID,

            msg.sender,

            minimumBond,

            _publicKey,

            currentEpoch.blocktime.add(minimumEpochInterval),

            0

        );



        numDarknodesNextEpoch = numDarknodesNextEpoch.add(1);



        

        emit LogDarknodeRegistered(msg.sender, _darknodeID, minimumBond);

    }



    

    

    

    

    

    

    function deregister(address _darknodeID)

        external

        onlyDeregisterable(_darknodeID)

        onlyDarknodeOperator(_darknodeID)

    {

        deregisterDarknode(_darknodeID);

    }



    

    

    

    function epoch() external {

        if (previousEpoch.blocktime == 0) {

            

            require(

                msg.sender == owner(),

                "DarknodeRegistry: not authorized to call first epoch"

            );

        }



        

        require(

            block.timestamp >= currentEpoch.blocktime.add(minimumEpochInterval),

            "DarknodeRegistry: epoch interval has not passed"

        );

        uint256 epochhash = uint256(blockhash(block.number - 1));



        

        previousEpoch = currentEpoch;

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });



        

        numDarknodesPreviousEpoch = numDarknodes;

        numDarknodes = numDarknodesNextEpoch;



        

        if (nextMinimumBond != minimumBond) {

            minimumBond = nextMinimumBond;

            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);

        }

        if (nextMinimumPodSize != minimumPodSize) {

            minimumPodSize = nextMinimumPodSize;

            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);

        }

        if (nextMinimumEpochInterval != minimumEpochInterval) {

            minimumEpochInterval = nextMinimumEpochInterval;

            emit LogMinimumEpochIntervalUpdated(

                minimumEpochInterval,

                nextMinimumEpochInterval

            );

        }

        if (nextSlasher != slasher) {

            slasher = nextSlasher;

            emit LogSlasherUpdated(address(slasher), address(nextSlasher));

        }

        if (address(darknodePayment) != address(0x0)) {

            darknodePayment.changeCycle();

        }



        

        emit LogNewEpoch(epochhash);

    }



    

    

    

    function transferStoreOwnership(DarknodeRegistryLogicV1 _newOwner)

        external

        onlyOwner

    {

        store.transferOwnership(address(_newOwner));

        _newOwner.claimStoreOwnership();

    }



    

    

    

    function claimStoreOwnership() external {

        store.claimOwnership();



        

        

        (

            numDarknodesPreviousEpoch,

            numDarknodes,

            numDarknodesNextEpoch

        ) = getDarknodeCountFromEpochs();

    }



    

    

    

    

    function updateDarknodePayment(IDarknodePayment _darknodePayment)

        external

        onlyOwner

    {

        require(

            address(_darknodePayment) != address(0x0),

            "DarknodeRegistry: invalid Darknode Payment address"

        );

        IDarknodePayment previousDarknodePayment = darknodePayment;

        darknodePayment = _darknodePayment;

        emit LogDarknodePaymentUpdated(

            previousDarknodePayment,

            darknodePayment

        );

    }



    

    

    

    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {

        

        nextMinimumBond = _nextMinimumBond;

    }



    

    

    function updateMinimumPodSize(uint256 _nextMinimumPodSize)

        external

        onlyOwner

    {

        

        nextMinimumPodSize = _nextMinimumPodSize;

    }



    

    

    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval)

        external

        onlyOwner

    {

        

        nextMinimumEpochInterval = _nextMinimumEpochInterval;

    }



    

    

    

    function updateSlasher(IDarknodeSlasher _slasher) external onlyOwner {

        require(

            address(_slasher) != address(0),

            "DarknodeRegistry: invalid slasher address"

        );

        nextSlasher = _slasher;

    }



    

    

    

    

    

    function slash(address _guilty, address _challenger, uint256 _percentage)

        external

        onlySlasher

        onlyDarknode(_guilty)

    {

        require(_percentage <= 100, "DarknodeRegistry: invalid percent");



        

        if (isDeregisterable(_guilty)) {

            deregisterDarknode(_guilty);

        }



        uint256 totalBond = store.darknodeBond(_guilty);

        uint256 penalty = totalBond.div(100).mul(_percentage);

        uint256 challengerReward = penalty.div(2);

        uint256 darknodePaymentReward = penalty.sub(challengerReward);

        if (challengerReward > 0) {

            

            store.updateDarknodeBond(_guilty, totalBond.sub(penalty));



            

            require(

                address(darknodePayment) != address(0x0),

                "DarknodeRegistry: invalid payment address"

            );

            require(

                ren.transfer(

                    address(darknodePayment.store()),

                    darknodePaymentReward

                ),

                "DarknodeRegistry: reward transfer failed"

            );

            require(

                ren.transfer(_challenger, challengerReward),

                "DarknodeRegistry: reward transfer failed"

            );

        }



        emit LogDarknodeSlashed(

            store.darknodeOperator(_guilty),

            _guilty,

            _challenger,

            _percentage

        );

    }



    

    

    

    

    

    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        uint256 amount = store.darknodeBond(_darknodeID);



        

        store.removeDarknode(_darknodeID);



        

        require(

            ren.transfer(darknodeOperator, amount),

            "DarknodeRegistry: bond transfer failed"

        );



        

        emit LogDarknodeRefunded(darknodeOperator, _darknodeID, amount);

    }



    

    

    function getDarknodeOperator(address _darknodeID)

        external

        view

        returns (address payable)

    {

        return store.darknodeOperator(_darknodeID);

    }



    

    

    function getDarknodeBond(address _darknodeID)

        external

        view

        returns (uint256)

    {

        return store.darknodeBond(_darknodeID);

    }



    

    

    function getDarknodePublicKey(address _darknodeID)

        external

        view

        returns (bytes memory)

    {

        return store.darknodePublicKey(_darknodeID);

    }



    

    

    

    

    

    

    

    

    

    

    function getDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }

        return getDarknodesFromEpochs(_start, count, false);

    }



    

    

    function getPreviousDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodesPreviousEpoch;

        }

        return getDarknodesFromEpochs(_start, count, true);

    }



    

    

    

    function isPendingRegistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        return registeredAt != 0 && registeredAt > currentEpoch.blocktime;

    }



    

    

    function isPendingDeregistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocktime;

    }



    

    function isDeregistered(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocktime;

    }



    

    

    

    function isDeregisterable(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        

        

        return isRegistered(_darknodeID) && deregisteredAt == 0;

    }



    

    

    

    function isRefunded(address _darknodeID) public view returns (bool) {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return registeredAt == 0 && deregisteredAt == 0;

    }



    

    

    function isRefundable(address _darknodeID) public view returns (bool) {

        return

            isDeregistered(_darknodeID) &&

            store.darknodeDeregisteredAt(_darknodeID) <=

            (previousEpoch.blocktime - deregistrationInterval);

    }



    

    function isRegistered(address _darknodeID) public view returns (bool) {

        return isRegisteredInEpoch(_darknodeID, currentEpoch);

    }



    

    function isRegisteredInPreviousEpoch(address _darknodeID)

        public

        view

        returns (bool)

    {

        return isRegisteredInEpoch(_darknodeID, previousEpoch);

    }



    

    

    

    

    function isRegisteredInEpoch(address _darknodeID, Epoch memory _epoch)

        private

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocktime;

        bool notDeregistered = deregisteredAt == 0 ||

            deregisteredAt > _epoch.blocktime;

        

        

        return registered && notDeregistered;

    }



    

    

    

    

    

    function getDarknodesFromEpochs(

        address _start,

        uint256 _count,

        bool _usePreviousEpoch

    ) private view returns (address[] memory) {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }



        address[] memory nodes = new address[](count);



        

        uint256 n = 0;

        address next = _start;

        if (next == address(0)) {

            next = store.begin();

        }



        

        while (n < count) {

            if (next == address(0)) {

                break;

            }

            

            bool includeNext;

            if (_usePreviousEpoch) {

                includeNext = isRegisteredInPreviousEpoch(next);

            } else {

                includeNext = isRegistered(next);

            }

            if (!includeNext) {

                next = store.next(next);

                continue;

            }

            nodes[n] = next;

            next = store.next(next);

            n += 1;

        }

        return nodes;

    }



    

    function deregisterDarknode(address _darknodeID) private {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        store.updateDarknodeDeregisteredAt(

            _darknodeID,

            currentEpoch.blocktime.add(minimumEpochInterval)

        );

        numDarknodesNextEpoch = numDarknodesNextEpoch.sub(1);



        

        emit LogDarknodeDeregistered(darknodeOperator, _darknodeID);

    }



    function getDarknodeCountFromEpochs()

        private

        view

        returns (uint256, uint256, uint256)

    {

        

        uint256 nPreviousEpoch = 0;

        uint256 nCurrentEpoch = 0;

        uint256 nNextEpoch = 0;

        address next = store.begin();



        

        while (true) {

            

            if (next == address(0)) {

                break;

            }



            if (isRegisteredInPreviousEpoch(next)) {

                nPreviousEpoch += 1;

            }



            if (isRegistered(next)) {

                nCurrentEpoch += 1;

            }



            

            

            if (

                ((isRegistered(next) && !isPendingDeregistration(next)) ||

                    isPendingRegistration(next))

            ) {

                nNextEpoch += 1;

            }

            next = store.next(next);

        }

        return (nPreviousEpoch, nCurrentEpoch, nNextEpoch);

    }

}



contract DarknodeRegistryProxy is InitializableAdminUpgradeabilityProxy {}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\DarknodeRegistryStore.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-03-25

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 9068f80

Repository: https://github.com/renproject/darknode-sol

Issues: https://github.com/renproject/darknode-sol/issues



Licenses

@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE



*/



pragma solidity 0.5.16;





library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library LinkedList {



    

    address public constant NULL = address(0);



    

    struct Node {

        bool inList;

        address previous;

        address next;

    }



    

    struct List {

        mapping (address => Node) list;

    }



    

    function insertBefore(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address prev = self.list[target].previous;



        self.list[newNode].next = target;

        self.list[newNode].previous = prev;

        self.list[target].previous = newNode;

        self.list[prev].next = newNode;



        self.list[newNode].inList = true;

    }



    

    function insertAfter(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address n = self.list[target].next;



        self.list[newNode].previous = target;

        self.list[newNode].next = n;

        self.list[target].next = newNode;

        self.list[n].previous = newNode;



        self.list[newNode].inList = true;

    }



    

    function remove(List storage self, address node) internal {

        require(isInList(self, node), "LinkedList: not in list");

        

        address p = self.list[node].previous;

        address n = self.list[node].next;



        self.list[p].next = n;

        self.list[n].previous = p;



        

        

        self.list[node].inList = false;

        delete self.list[node];

    }



    

    function prepend(List storage self, address node) internal {

        



        insertBefore(self, begin(self), node);

    }



    

    function append(List storage self, address node) internal {

        



        insertAfter(self, end(self), node);

    }



    function swap(List storage self, address left, address right) internal {

        



        address previousRight = self.list[right].previous;

        remove(self, right);

        insertAfter(self, left, right);

        remove(self, left);

        insertAfter(self, previousRight, left);

    }



    function isInList(List storage self, address node) internal view returns (bool) {

        return self.list[node].inList;

    }



    

    function begin(List storage self) internal view returns (address) {

        return self.list[NULL].next;

    }



    

    function end(List storage self) internal view returns (address) {

        return self.list[NULL].previous;

    }



    function next(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].next;

    }



    function previous(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].previous;

    }



    function elements(List storage self, address _start, uint256 _count) internal view returns (address[] memory) {

        require(_count > 0, "LinkedList: invalid count");

        require(isInList(self, _start) || _start == address(0), "LinkedList: not in list");

        address[] memory elems = new address[](_count);



        

        uint256 n = 0;

        address nextItem = _start;

        if (nextItem == address(0)) {

            nextItem = begin(self);

        }



        while (n < _count) {

            if (nextItem == address(0)) {

                break;

            }

            elems[n] = nextItem;

            nextItem = next(self, nextItem);

            n += 1;

        }

        return elems;

    }

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



library Roles {

    struct Role {

        mapping (address => bool) bearer;

    }



    

    function add(Role storage role, address account) internal {

        require(!has(role, account), "Roles: account already has role");

        role.bearer[account] = true;

    }



    

    function remove(Role storage role, address account) internal {

        require(has(role, account), "Roles: account does not have role");

        role.bearer[account] = false;

    }



    

    function has(Role storage role, address account) internal view returns (bool) {

        require(account != address(0), "Roles: account is the zero address");

        return role.bearer[account];

    }

}



contract PauserRole is Initializable, Context {

    using Roles for Roles.Role;



    event PauserAdded(address indexed account);

    event PauserRemoved(address indexed account);



    Roles.Role private _pausers;



    function initialize(address sender) public initializer {

        if (!isPauser(sender)) {

            _addPauser(sender);

        }

    }



    modifier onlyPauser() {

        require(isPauser(_msgSender()), "PauserRole: caller does not have the Pauser role");

        _;

    }



    function isPauser(address account) public view returns (bool) {

        return _pausers.has(account);

    }



    function addPauser(address account) public onlyPauser {

        _addPauser(account);

    }



    function renouncePauser() public {

        _removePauser(_msgSender());

    }



    function _addPauser(address account) internal {

        _pausers.add(account);

        emit PauserAdded(account);

    }



    function _removePauser(address account) internal {

        _pausers.remove(account);

        emit PauserRemoved(account);

    }



    uint256[50] private ______gap;

}



contract Pausable is Initializable, Context, PauserRole {

    

    event Paused(address account);



    

    event Unpaused(address account);



    bool private _paused;



    

    function initialize(address sender) public initializer {

        PauserRole.initialize(sender);



        _paused = false;

    }



    

    function paused() public view returns (bool) {

        return _paused;

    }



    

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    

    function pause() public onlyPauser whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    

    function unpause() public onlyPauser whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }



    uint256[50] private ______gap;

}



contract ERC20Pausable is Initializable, ERC20, Pausable {

    function initialize(address sender) public initializer {

        Pausable.initialize(sender);

    }



    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transfer(to, value);

    }



    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transferFrom(from, to, value);

    }



    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {

        return super.approve(spender, value);

    }



    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {

        return super.increaseAllowance(spender, addedValue);

    }



    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {

        return super.decreaseAllowance(spender, subtractedValue);

    }



    uint256[50] private ______gap;

}



contract ERC20Burnable is Initializable, Context, ERC20 {

    

    function burn(uint256 amount) public {

        _burn(_msgSender(), amount);

    }



    

    function burnFrom(address account, uint256 amount) public {

        _burnFrom(account, amount);

    }



    uint256[50] private ______gap;

}



contract RenToken is Ownable, ERC20Detailed, ERC20Pausable, ERC20Burnable {

    string private constant _name = "REN";

    string private constant _symbol = "REN";

    uint8 private constant _decimals = 18;



    uint256 public constant INITIAL_SUPPLY = 1000000000 *

        10**uint256(_decimals);



    

    constructor() public {

        ERC20Pausable.initialize(msg.sender);

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        Ownable.initialize(msg.sender);

        _mint(msg.sender, INITIAL_SUPPLY);

    }



    function transferTokens(address beneficiary, uint256 amount)

        public

        onlyOwner

        returns (bool)

    {

        

        

        require(amount > 0);



        _transfer(msg.sender, beneficiary, amount);

        emit Transfer(msg.sender, beneficiary, amount);



        return true;

    }

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    

    

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}



contract DarknodeRegistryStore is Claimable, CanReclaimTokens {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    

    

    struct Darknode {

        

        

        

        

        address payable owner;

        

        

        

        uint256 bond;

        

        uint256 registeredAt;

        

        uint256 deregisteredAt;

        

        

        

        

        bytes publicKey;

    }



    

    mapping(address => Darknode) private darknodeRegistry;

    LinkedList.List private darknodes;



    

    RenToken public ren;



    

    

    

    

    constructor(string memory _VERSION, RenToken _ren) public {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;

        ren = _ren;

        blacklistRecoverableToken(address(ren));

    }



    

    

    

    

    

    

    

    

    

    function appendDarknode(

        address _darknodeID,

        address payable _darknodeOperator,

        uint256 _bond,

        bytes calldata _publicKey,

        uint256 _registeredAt,

        uint256 _deregisteredAt

    ) external onlyOwner {

        Darknode memory darknode = Darknode({

            owner: _darknodeOperator,

            bond: _bond,

            publicKey: _publicKey,

            registeredAt: _registeredAt,

            deregisteredAt: _deregisteredAt

        });

        darknodeRegistry[_darknodeID] = darknode;

        LinkedList.append(darknodes, _darknodeID);

    }



    

    function begin() external view onlyOwner returns (address) {

        return LinkedList.begin(darknodes);

    }



    

    

    function next(address darknodeID)

        external

        view

        onlyOwner

        returns (address)

    {

        return LinkedList.next(darknodes, darknodeID);

    }



    

    

    function removeDarknode(address darknodeID) external onlyOwner {

        uint256 bond = darknodeRegistry[darknodeID].bond;

        delete darknodeRegistry[darknodeID];

        LinkedList.remove(darknodes, darknodeID);

        require(

            ren.transfer(owner(), bond),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    

    function updateDarknodeBond(address darknodeID, uint256 decreasedBond)

        external

        onlyOwner

    {

        uint256 previousBond = darknodeRegistry[darknodeID].bond;

        require(

            decreasedBond < previousBond,

            "DarknodeRegistryStore: bond not decreased"

        );

        darknodeRegistry[darknodeID].bond = decreasedBond;

        require(

            ren.transfer(owner(), previousBond.sub(decreasedBond)),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    function updateDarknodeDeregisteredAt(

        address darknodeID,

        uint256 deregisteredAt

    ) external onlyOwner {

        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;

    }



    

    function darknodeOperator(address darknodeID)

        external

        view

        onlyOwner

        returns (address payable)

    {

        return darknodeRegistry[darknodeID].owner;

    }



    

    function darknodeBond(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].bond;

    }



    

    function darknodeRegisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].registeredAt;

    }



    

    function darknodeDeregisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].deregisteredAt;

    }



    

    function darknodePublicKey(address darknodeID)

        external

        view

        onlyOwner

        returns (bytes memory)

    {

        return darknodeRegistry[darknodeID].publicKey;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ECDSA.sol
File type: .sol
pragma solidity ^0.5.0;



/**

 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.

 *

 * These functions can be used to verify that a message was signed by the holder

 * of the private keys of a given address.

 */

library ECDSA {

    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature`. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * NOTE: This call _does not revert_ if the signature is invalid, or

     * if the signer is otherwise unable to be retrieved. In those scenarios,

     * the zero address is returned.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     */

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        // Check the signature length

        if (signature.length != 65) {

            revert("ECDSA: signature length is invalid");

        }



        // Divide the signature in r, s and v variables

        bytes32 r;

        bytes32 s;

        uint8 v;



        // ecrecover takes the signature parameters, and the only way to get them

        // currently is to use assembly.

        // solhint-disable-next-line no-inline-assembly

        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := byte(0, mload(add(signature, 0x60)))

        }



        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature

        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines

        // the valid range for s in (281): 0 < s < secp256k1n ?? 2 + 1, and for v in (282): v ?? {27, 28}. Most

        // signatures from current libraries generate a unique signature with an s-value in the lower half order.

        //

        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value

        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or

        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept

        // these malleable signatures as well.

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            revert("ECDSA: signature.s is in the wrong range");

        }



        if (v != 27 && v != 28) {

            revert("ECDSA: signature.v is in the wrong range");

        }



        // If the signature is valid (and not malleable), return the signer address

        return ecrecover(hash, v, r, s);

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from a `hash`. This

     * replicates the behavior of the

     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]

     * JSON-RPC method.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        // 32 is the length in bytes of hash,

        // enforced by the type signature above

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\EnumerableSetUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Library for managing

 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive

 * types.

 *

 * Sets have the following properties:

 *

 * - Elements are added, removed, and checked for existence in constant time

 * (O(1)).

 * - Elements are enumerated in O(n). No guarantees are made on the ordering.

 *

 * ```

 * contract Example {

 *     // Add the library methods

 *     using EnumerableSet for EnumerableSet.AddressSet;

 *

 *     // Declare a set state variable

 *     EnumerableSet.AddressSet private mySet;

 * }

 * ```

 *

 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)

 * and `uint256` (`UintSet`) are supported.

 */

library EnumerableSetUpgradeable {

    // To implement this library for multiple types with as little code

    // repetition as possible, we write it in terms of a generic Set type with

    // bytes32 values.

    // The Set implementation uses private functions, and user-facing

    // implementations (such as AddressSet) are just wrappers around the

    // underlying Set.

    // This means that we can only create new EnumerableSets for types that fit

    // in bytes32.



    struct Set {

        // Storage of set values

        bytes32[] _values;

        // Position of the value in the `values` array, plus 1 because index 0

        // means a value is not in the set.

        mapping(bytes32 => uint256) _indexes;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            // The value is stored at length-1, but we add 1 to all indexes

            // and use 0 as a sentinel value

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        // We read and store the value's index to prevent multiple reads from the same storage slot

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) {

            // Equivalent to contains(set, value)

            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in

            // the array, and then remove the last element (sometimes called as 'swap and pop').

            // This modifies the order of the array, as noted in {at}.



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            if (lastIndex != toDeleteIndex) {

                bytes32 lastvalue = set._values[lastIndex];



                // Move the last value to the index where the value to delete is

                set._values[toDeleteIndex] = lastvalue;

                // Update the index for the moved value

                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex

            }



            // Delete the slot where the moved value was stored

            set._values.pop();



            // Delete the index for the deleted slot

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



    /**

     * @dev Returns the value stored at position `index` in the set. O(1).

     *

     * Note that there are no guarantees on the ordering of values inside the

     * array, and it may change when more values are added or removed.

     *

     * Requirements:

     *

     * - `index` must be strictly less than {length}.

     */

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        return set._values[index];

    }



    /**

     * @dev Return the entire set in an array

     *

     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed

     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that

     * this function has an unbounded cost, and using it as part of a state-changing function may render the function

     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.

     */

    function _values(Set storage set) private view returns (bytes32[] memory) {

        return set._values;

    }



    // Bytes32Set



    struct Bytes32Set {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {

        return _add(set._inner, value);

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {

        return _remove(set._inner, value);

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {

        return _contains(set._inner, value);

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(Bytes32Set storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



    /**

     * @dev Returns the value stored at position `index` in the set. O(1).

     *

     * Note that there are no guarantees on the ordering of values inside the

     * array, and it may change when more values are added or removed.

     *

     * Requirements:

     *

     * - `index` must be strictly less than {length}.

     */

    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {

        return _at(set._inner, index);

    }



    /**

     * @dev Return the entire set in an array

     *

     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed

     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that

     * this function has an unbounded cost, and using it as part of a state-changing function may render the function

     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.

     */

    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {

        return _values(set._inner);

    }



    // AddressSet



    struct AddressSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(uint160(value))));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(uint160(value))));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(uint160(value))));

    }



    /**

     * @dev Returns the number of values in the set. O(1).

     */

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



    /**

     * @dev Returns the value stored at position `index` in the set. O(1).

     *

     * Note that there are no guarantees on the ordering of values inside the

     * array, and it may change when more values are added or removed.

     *

     * Requirements:

     *

     * - `index` must be strictly less than {length}.

     */

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint160(uint256(_at(set._inner, index))));

    }



    /**

     * @dev Return the entire set in an array

     *

     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed

     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that

     * this function has an unbounded cost, and using it as part of a state-changing function may render the function

     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.

     */

    function values(AddressSet storage set) internal view returns (address[] memory) {

        bytes32[] memory store = _values(set._inner);

        address[] memory result;



        assembly {

            result := store

        }



        return result;

    }



    // UintSet



    struct UintSet {

        Set _inner;

    }



    /**

     * @dev Add a value to a set. O(1).

     *

     * Returns true if the value was added to the set, that is if it was not

     * already present.

     */

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    /**

     * @dev Removes a value from a set. O(1).

     *

     * Returns true if the value was removed from the set, that is if it was

     * present.

     */

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    /**

     * @dev Returns true if the value is in the set. O(1).

     */

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    /**

     * @dev Returns the number of values on the set. O(1).

     */

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



    /**

     * @dev Returns the value stored at position `index` in the set. O(1).

     *

     * Note that there are no guarantees on the ordering of values inside the

     * array, and it may change when more values are added or removed.

     *

     * Requirements:

     *

     * - `index` must be strictly less than {length}.

     */

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }



    /**

     * @dev Return the entire set in an array

     *

     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed

     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that

     * this function has an unbounded cost, and using it as part of a state-changing function may render the function

     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.

     */

    function values(UintSet storage set) internal view returns (uint256[] memory) {

        bytes32[] memory store = _values(set._inner);

        uint256[] memory result;



        assembly {

            result := store

        }



        return result;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check

 * for the additional interface id that will be supported. For example:

 *

 * ```solidity

 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);

 * }

 * ```

 *

 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.

 */

abstract contract ERC165 is IERC165 {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IERC165).interfaceId;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ERC165Upgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165Upgradeable.sol";

import "../../proxy/utils/Initializable.sol";



/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check

 * for the additional interface id that will be supported. For example:

 *

 * ```solidity

 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);

 * }

 * ```

 *

 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.

 */

abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {

    function __ERC165_init() internal initializer {

        __ERC165_init_unchained();

    }



    function __ERC165_init_unchained() internal initializer {

    }

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IERC165Upgradeable).interfaceId;

    }

    uint256[50] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ERC1967Proxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../Proxy.sol";

import "./ERC1967Upgrade.sol";



/**

 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an

 * implementation address that can be changed. This address is stored in storage in the location specified by

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the

 * implementation behind the proxy.

 */

contract ERC1967Proxy is Proxy, ERC1967Upgrade {

    /**

     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.

     *

     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded

     * function call, and allows initializating the storage of the proxy like a Solidity constructor.

     */

    constructor(address _logic, bytes memory _data) payable {

        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));

        _upgradeToAndCall(_logic, _data, false);

    }



    /**

     * @dev Returns the current implementation address.

     */

    function _implementation() internal view virtual override returns (address impl) {

        return ERC1967Upgrade._getImplementation();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ERC1967Upgrade.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.2;



import "../beacon/IBeacon.sol";

import "../../utils/Address.sol";

import "../../utils/StorageSlot.sol";



/**

 * @dev This abstract contract provides getters and event emitting update functions for

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.

 *

 * _Available since v4.1._

 *

 * @custom:oz-upgrades-unsafe-allow delegatecall

 */

abstract contract ERC1967Upgrade {

    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1

    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;



    /**

     * @dev Storage slot with the address of the current implementation.

     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



    /**

     * @dev Emitted when the implementation is upgraded.

     */

    event Upgraded(address indexed implementation);



    /**

     * @dev Returns the current implementation address.

     */

    function _getImplementation() internal view returns (address) {

        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 implementation slot.

     */

    function _setImplementation(address newImplementation) private {

        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

    }



    /**

     * @dev Perform implementation upgrade

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeTo(address newImplementation) internal {

        _setImplementation(newImplementation);

        emit Upgraded(newImplementation);

    }



    /**

     * @dev Perform implementation upgrade with additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCall(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        _upgradeTo(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }

    }



    /**

     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCallSecure(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        address oldImplementation = _getImplementation();



        // Initial upgrade and setup call

        _setImplementation(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }



        // Perform rollback test if not already in progress

        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);

        if (!rollbackTesting.value) {

            // Trigger rollback using upgradeTo from the new implementation

            rollbackTesting.value = true;

            Address.functionDelegateCall(

                newImplementation,

                abi.encodeWithSignature("upgradeTo(address)", oldImplementation)

            );

            rollbackTesting.value = false;

            // Check rollback was effective

            require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");

            // Finally reset to the new implementation and log the upgrade

            _upgradeTo(newImplementation);

        }

    }



    /**

     * @dev Storage slot with the admin of the contract.

     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



    /**

     * @dev Emitted when the admin account has changed.

     */

    event AdminChanged(address previousAdmin, address newAdmin);



    /**

     * @dev Returns the current admin.

     */

    function _getAdmin() internal view returns (address) {

        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 admin slot.

     */

    function _setAdmin(address newAdmin) private {

        require(newAdmin != address(0), "ERC1967: new admin is the zero address");

        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;

    }



    /**

     * @dev Changes the admin of the proxy.

     *

     * Emits an {AdminChanged} event.

     */

    function _changeAdmin(address newAdmin) internal {

        emit AdminChanged(_getAdmin(), newAdmin);

        _setAdmin(newAdmin);

    }



    /**

     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.

     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.

     */

    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;



    /**

     * @dev Emitted when the beacon is upgraded.

     */

    event BeaconUpgraded(address indexed beacon);



    /**

     * @dev Returns the current beacon.

     */

    function _getBeacon() internal view returns (address) {

        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;

    }



    /**

     * @dev Stores a new beacon in the EIP1967 beacon slot.

     */

    function _setBeacon(address newBeacon) private {

        require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");

        require(

            Address.isContract(IBeacon(newBeacon).implementation()),

            "ERC1967: beacon implementation is not a contract"

        );

        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;

    }



    /**

     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does

     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).

     *

     * Emits a {BeaconUpgraded} event.

     */

    function _upgradeBeaconToAndCall(

        address newBeacon,

        bytes memory data,

        bool forceCall

    ) internal {

        _setBeacon(newBeacon);

        emit BeaconUpgraded(newBeacon);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ERC20.sol
File type: .sol
pragma solidity ^0.5.0;



import "@openzeppelin/upgrades/contracts/Initializable.sol";



import "../../GSN/Context.sol";

import "./IERC20.sol";

import "../../math/SafeMath.sol";



/**

 * @dev Implementation of the {IERC20} interface.

 *

 * This implementation is agnostic to the way tokens are created. This means

 * that a supply mechanism has to be added in a derived contract using {_mint}.

 * For a generic mechanism see {ERC20Mintable}.

 *

 * TIP: For a detailed writeup see our guide

 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How

 * to implement supply mechanisms].

 *

 * We have followed general OpenZeppelin guidelines: functions revert instead

 * of returning `false` on failure. This behavior is nonetheless conventional

 * and does not conflict with the expectations of ERC20 applications.

 *

 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.

 * This allows applications to reconstruct the allowance for all accounts just

 * by listening to said events. Other implementations of the EIP may not emit

 * these events, as it isn't required by the specification.

 *

 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}

 * functions have been added to mitigate the well-known issues around setting

 * allowances. See {IERC20-approve}.

 */

contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `recipient` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20};

     *

     * Requirements:

     * - `sender` and `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     * - the caller must have allowance for `sender`'s tokens of at least

     * `amount`.

     */

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    /**

     * @dev Moves tokens `amount` from `sender` to `recipient`.

     *

     * This is internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `sender` cannot be the zero address.

     * - `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     */

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements

     *

     * - `to` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.

     *

     * This is internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted

     * from the caller's allowance.

     *

     * See {_burn} and {_approve}.

     */

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ERC20Detailed.sol
File type: .sol
pragma solidity ^0.5.0;



import "@openzeppelin/upgrades/contracts/Initializable.sol";

import "./IERC20.sol";



/**

 * @dev Optional functions from the ERC20 standard.

 */

contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string internal _symbol;

    uint8 private _decimals;



    /**

     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of

     * these values are immutable: they can only be set once during

     * construction.

     */

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    /**

     * @dev Returns the name of the token.

     */

    function name() public view returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5,05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei.

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ERC20WithPermit.sol
File type: .sol
pragma solidity ^0.5.17;



import "@openzeppelin/upgrades/contracts/Initializable.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol";



/// @notice Taken from the DAI token.

contract ERC20WithPermit is Initializable, ERC20, ERC20Detailed {

    using SafeMath for uint256;



    mapping(address => uint256) public nonces;



    // If the token is redeployed, the version is increased to prevent a permit

    // signature being used on both token instances.

    string public version;



    // --- EIP712 niceties ---

    bytes32 public DOMAIN_SEPARATOR;

    // PERMIT_TYPEHASH is the value returned from

    // keccak256("Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)")

    bytes32 public constant PERMIT_TYPEHASH =

        0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;



    function initialize(

        uint256 _chainId,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        version = _version;

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256(

                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"

                ),

                keccak256(bytes(name())),

                keccak256(bytes(version)),

                _chainId,

                address(this)

            )

        );

    }



    // --- Approve by signature ---

    function permit(

        address holder,

        address spender,

        uint256 nonce,

        uint256 expiry,

        bool allowed,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external {

        bytes32 digest =

            keccak256(

                abi.encodePacked(

                    "\x19\x01",

                    DOMAIN_SEPARATOR,

                    keccak256(

                        abi.encode(

                            PERMIT_TYPEHASH,

                            holder,

                            spender,

                            nonce,

                            expiry,

                            allowed

                        )

                    )

                )

            );



        require(holder != address(0), "ERC20WithRate: address must not be 0x0");

        require(

            holder == ecrecover(digest, v, r, s),

            "ERC20WithRate: invalid signature"

        );

        require(

            expiry == 0 || now <= expiry,

            "ERC20WithRate: permit has expired"

        );

        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");

        uint256 amount = allowed ? uint256(-1) : 0;

        _approve(holder, spender, amount);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ERC20WithRate.sol
File type: .sol
pragma solidity ^0.5.17;



import "@openzeppelin/upgrades/contracts/Initializable.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";



import "../Governance/Claimable.sol";



/// @notice ERC20WithRate allows for a more dynamic fee model by storing a rate

/// that tracks the number of the underlying asset's unit represented by a

/// single ERC20 token.

contract ERC20WithRate is Initializable, Ownable, ERC20 {

    using SafeMath for uint256;



    uint256 public constant _rateScale = 1e18;

    uint256 internal _rate;



    event LogRateChanged(uint256 indexed _rate);



    /* solium-disable-next-line no-empty-blocks */

    function initialize(address _nextOwner, uint256 _initialRate)

        public

        initializer

    {

        Ownable.initialize(_nextOwner);

        _setRate(_initialRate);

    }



    function setExchangeRate(uint256 _nextRate) public onlyOwner {

        _setRate(_nextRate);

    }



    function exchangeRateCurrent() public view returns (uint256) {

        require(_rate != 0, "ERC20WithRate: rate has not been initialized");

        return _rate;

    }



    function _setRate(uint256 _nextRate) internal {

        require(_nextRate > 0, "ERC20WithRate: rate must be greater than zero");

        _rate = _nextRate;

    }



    function balanceOfUnderlying(address _account)

        public

        view

        returns (uint256)

    {

        return toUnderlying(balanceOf(_account));

    }



    function toUnderlying(uint256 _amount) public view returns (uint256) {

        return _amount.mul(_rate).div(_rateScale);

    }



    function fromUnderlying(uint256 _amountUnderlying)

        public

        view

        returns (uint256)

    {

        return _amountUnderlying.mul(_rateScale).div(_rate);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\GatewayLogicV1.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-03-25

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 9068f80

Repository: https://github.com/renproject/darknode-sol

Issues: https://github.com/renproject/darknode-sol/issues



Licenses

@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE



*/



pragma solidity 0.5.16;





contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



library ECDSA {

    

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        

        if (signature.length != 65) {

            revert("ECDSA: signature length is invalid");

        }



        

        bytes32 r;

        bytes32 s;

        uint8 v;



        

        

        

        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := byte(0, mload(add(signature, 0x60)))

        }



        

        

        

        

        

        

        

        

        

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            revert("ECDSA: signature.s is in the wrong range");

        }



        if (v != 27 && v != 28) {

            revert("ECDSA: signature.v is in the wrong range");

        }



        

        return ecrecover(hash, v, r, s);

    }



    

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        

        

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }

}



contract Proxy {

  

  function () payable external {

    _fallback();

  }



  

  function _implementation() internal view returns (address);



  

  function _delegate(address implementation) internal {

    assembly {

      

      

      

      calldatacopy(0, 0, calldatasize)



      

      

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      

      returndatacopy(0, 0, returndatasize)



      switch result

      

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  

  function _willFallback() internal {

  }



  

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



library OpenZeppelinUpgradesAddress {

    

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        

        

        

        

        

        

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



contract BaseUpgradeabilityProxy is Proxy {

  

  event Upgraded(address indexed implementation);



  

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



  

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  

  function _setImplementation(address newImplementation) internal {

    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  constructor(address _logic, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  event AdminChanged(address previousAdmin, address newAdmin);



  



  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



  

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  

  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    (bool success,) = newImplementation.delegatecall(data);

    require(success);

  }



  

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  function initialize(address _logic, bytes memory _data) public payable {

    require(_implementation() == address(0));

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {

  

  function initialize(address _logic, address _admin, bytes memory _data) public payable {

    require(_implementation() == address(0));

    InitializableUpgradeabilityProxy.initialize(_logic, _data);

    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));

    _setAdmin(_admin);

  }

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library String {

    

    

    function fromUint(uint256 _i) internal pure returns (string memory) {

        if (_i == 0) {

            return "0";

        }

        uint256 j = _i;

        uint256 len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint256 k = len - 1;

        while (_i != 0) {

            bstr[k--] = bytes1(uint8(48 + (_i % 10)));

            _i /= 10;

        }

        return string(bstr);

    }



    

    function fromBytes32(bytes32 _value) internal pure returns (string memory) {

        bytes memory alphabet = "0123456789abcdef";



        bytes memory str = new bytes(32 * 2 + 2);

        str[0] = "0";

        str[1] = "x";

        for (uint256 i = 0; i < 32; i++) {

            str[2 + i * 2] = alphabet[uint256(uint8(_value[i] >> 4))];

            str[3 + i * 2] = alphabet[uint256(uint8(_value[i] & 0x0f))];

        }

        return string(str);

    }



    

    function fromAddress(address _addr) internal pure returns (string memory) {

        bytes32 value = bytes32(uint256(_addr));

        bytes memory alphabet = "0123456789abcdef";



        bytes memory str = new bytes(20 * 2 + 2);

        str[0] = "0";

        str[1] = "x";

        for (uint256 i = 0; i < 20; i++) {

            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];

            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];

        }

        return string(str);

    }



    

    function add8(

        string memory a,

        string memory b,

        string memory c,

        string memory d,

        string memory e,

        string memory f,

        string memory g,

        string memory h

    ) internal pure returns (string memory) {

        return string(abi.encodePacked(a, b, c, d, e, f, g, h));

    }

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    

    

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}



contract ERC20WithRate is Initializable, Ownable, ERC20 {

    using SafeMath for uint256;



    uint256 public constant _rateScale = 1e18;

    uint256 internal _rate;



    event LogRateChanged(uint256 indexed _rate);



    

    function initialize(address _nextOwner, uint256 _initialRate)

        public

        initializer

    {

        Ownable.initialize(_nextOwner);

        _setRate(_initialRate);

    }



    function setExchangeRate(uint256 _nextRate) public onlyOwner {

        _setRate(_nextRate);

    }



    function exchangeRateCurrent() public view returns (uint256) {

        require(_rate != 0, "ERC20WithRate: rate has not been initialized");

        return _rate;

    }



    function _setRate(uint256 _nextRate) internal {

        require(_nextRate > 0, "ERC20WithRate: rate must be greater than zero");

        _rate = _nextRate;

    }



    function balanceOfUnderlying(address _account)

        public

        view

        returns (uint256)

    {

        return toUnderlying(balanceOf(_account));

    }



    function toUnderlying(uint256 _amount) public view returns (uint256) {

        return _amount.mul(_rate).div(_rateScale);

    }



    function fromUnderlying(uint256 _amountUnderlying)

        public

        view

        returns (uint256)

    {

        return _amountUnderlying.mul(_rateScale).div(_rate);

    }

}



contract ERC20WithPermit is Initializable, ERC20, ERC20Detailed {

    using SafeMath for uint256;



    mapping(address => uint256) public nonces;



    

    

    string public version;



    

    bytes32 public DOMAIN_SEPARATOR;

    

    

    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;



    function initialize(

        uint256 _chainId,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        version = _version;

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256(

                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"

                ),

                keccak256(bytes(name())),

                keccak256(bytes(version)),

                _chainId,

                address(this)

            )

        );

    }



    

    function permit(

        address holder,

        address spender,

        uint256 nonce,

        uint256 expiry,

        bool allowed,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external {

        bytes32 digest = keccak256(

            abi.encodePacked(

                "\x19\x01",

                DOMAIN_SEPARATOR,

                keccak256(

                    abi.encode(

                        PERMIT_TYPEHASH,

                        holder,

                        spender,

                        nonce,

                        expiry,

                        allowed

                    )

                )

            )

        );



        require(holder != address(0), "ERC20WithRate: address must not be 0x0");

        require(

            holder == ecrecover(digest, v, r, s),

            "ERC20WithRate: invalid signature"

        );

        require(

            expiry == 0 || now <= expiry,

            "ERC20WithRate: permit has expired"

        );

        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");

        uint256 amount = allowed ? uint256(-1) : 0;

        _approve(holder, spender, amount);

    }

}



contract RenERC20LogicV1 is

    Initializable,

    ERC20,

    ERC20Detailed,

    ERC20WithRate,

    ERC20WithPermit,

    Claimable,

    CanReclaimTokens

{

    

    function initialize(

        uint256 _chainId,

        address _nextOwner,

        uint256 _initialRate,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        ERC20WithRate.initialize(_nextOwner, _initialRate);

        ERC20WithPermit.initialize(

            _chainId,

            _version,

            _name,

            _symbol,

            _decimals

        );

        Claimable.initialize(_nextOwner);

        CanReclaimTokens.initialize(_nextOwner);

    }



    

    

    function mint(address _to, uint256 _amount) public onlyOwner {

        _mint(_to, _amount);

    }



    

    

    function burn(address _from, uint256 _amount) public onlyOwner {

        _burn(_from, _amount);

    }



    function transfer(address recipient, uint256 amount) public returns (bool) {

        

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transfer(recipient, amount);

    }



    function transferFrom(address sender, address recipient, uint256 amount)

        public

        returns (bool)

    {

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transferFrom(sender, recipient, amount);

    }

}



contract RenBTC is InitializableAdminUpgradeabilityProxy {}



contract RenZEC is InitializableAdminUpgradeabilityProxy {}



contract RenBCH is InitializableAdminUpgradeabilityProxy {}



interface IMintGateway {

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);

    function mintFee() external view returns (uint256);

}



interface IBurnGateway {

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);

    function burnFee() external view returns (uint256);

}



interface IGateway {

    

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);

    function mintFee() external view returns (uint256);

    

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);

    function burnFee() external view returns (uint256);

}



contract GatewayStateV1 {

    uint256 constant BIPS_DENOMINATOR = 10000;

    uint256 public minimumBurnAmount;



    

    RenERC20LogicV1 public token;



    

    address public mintAuthority;



    

    

    

    

    address public feeRecipient;



    

    uint16 public mintFee;



    

    uint16 public burnFee;



    

    mapping(bytes32 => bool) public status;



    

    

    uint256 public nextN = 0;

}



contract GatewayLogicV1 is

    Initializable,

    Claimable,

    CanReclaimTokens,

    IGateway,

    GatewayStateV1

{

    using SafeMath for uint256;



    event LogMintAuthorityUpdated(address indexed _newMintAuthority);

    event LogMint(

        address indexed _to,

        uint256 _amount,

        uint256 indexed _n,

        bytes32 indexed _signedMessageHash

    );

    event LogBurn(

        bytes _to,

        uint256 _amount,

        uint256 indexed _n,

        bytes indexed _indexedTo

    );



    

    modifier onlyOwnerOrMintAuthority() {

        require(

            msg.sender == mintAuthority || msg.sender == owner(),

            "Gateway: caller is not the owner or mint authority"

        );

        _;

    }



    

    

    

    

    

    

    

    

    function initialize(

        RenERC20LogicV1 _token,

        address _feeRecipient,

        address _mintAuthority,

        uint16 _mintFee,

        uint16 _burnFee,

        uint256 _minimumBurnAmount

    ) public initializer {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        minimumBurnAmount = _minimumBurnAmount;

        token = _token;

        mintFee = _mintFee;

        burnFee = _burnFee;

        updateMintAuthority(_mintAuthority);

        updateFeeRecipient(_feeRecipient);

    }



    



    

    

    

    function claimTokenOwnership() public {

        token.claimOwnership();

    }



    

    function transferTokenOwnership(GatewayLogicV1 _nextTokenOwner)

        public

        onlyOwner

    {

        token.transferOwnership(address(_nextTokenOwner));

        _nextTokenOwner.claimTokenOwnership();

    }



    

    

    

    function updateMintAuthority(address _nextMintAuthority)

        public

        onlyOwnerOrMintAuthority

    {

        

        

        require(

            _nextMintAuthority != address(0),

            "Gateway: mintAuthority cannot be set to address zero"

        );

        mintAuthority = _nextMintAuthority;

        emit LogMintAuthorityUpdated(mintAuthority);

    }



    

    

    

    function updateMinimumBurnAmount(uint256 _minimumBurnAmount)

        public

        onlyOwner

    {

        minimumBurnAmount = _minimumBurnAmount;

    }



    

    

    

    function updateFeeRecipient(address _nextFeeRecipient) public onlyOwner {

        

        require(

            _nextFeeRecipient != address(0x0),

            "Gateway: fee recipient cannot be 0x0"

        );



        feeRecipient = _nextFeeRecipient;

    }



    

    

    

    function updateMintFee(uint16 _nextMintFee) public onlyOwner {

        mintFee = _nextMintFee;

    }



    

    

    

    function updateBurnFee(uint16 _nextBurnFee) public onlyOwner {

        burnFee = _nextBurnFee;

    }



    

    

    

    

    

    

    

    

    

    

    function mint(

        bytes32 _pHash,

        uint256 _amountUnderlying,

        bytes32 _nHash,

        bytes memory _sig

    ) public returns (uint256) {

        

        bytes32 signedMessageHash = hashForSignature(

            _pHash,

            _amountUnderlying,

            msg.sender,

            _nHash

        );

        require(

            status[signedMessageHash] == false,

            "Gateway: nonce hash already spent"

        );

        if (!verifySignature(signedMessageHash, _sig)) {

            

            

            

            revert(

                String.add8(

                    "Gateway: invalid signature. pHash: ",

                    String.fromBytes32(_pHash),

                    ", amount: ",

                    String.fromUint(_amountUnderlying),

                    ", msg.sender: ",

                    String.fromAddress(msg.sender),

                    ", _nHash: ",

                    String.fromBytes32(_nHash)

                )

            );

        }

        status[signedMessageHash] = true;



        uint256 amountScaled = token.fromUnderlying(_amountUnderlying);



        

        uint256 absoluteFeeScaled = amountScaled.mul(mintFee).div(

            BIPS_DENOMINATOR

        );

        uint256 receivedAmountScaled = amountScaled.sub(

            absoluteFeeScaled,

            "Gateway: fee exceeds amount"

        );



        

        token.mint(msg.sender, receivedAmountScaled);

        

        token.mint(feeRecipient, absoluteFeeScaled);



        

        uint256 receivedAmountUnderlying = token.toUnderlying(

            receivedAmountScaled

        );

        emit LogMint(

            msg.sender,

            receivedAmountUnderlying,

            nextN,

            signedMessageHash

        );

        nextN += 1;



        return receivedAmountScaled;

    }



    

    

    

    

    

    

    

    

    

    

    function burn(bytes memory _to, uint256 _amount) public returns (uint256) {

        

        

        require(_to.length != 0, "Gateway: to address is empty");



        

        uint256 fee = _amount.mul(burnFee).div(BIPS_DENOMINATOR);

        uint256 amountAfterFee = _amount.sub(

            fee,

            "Gateway: fee exceeds amount"

        );



        

        

        

        uint256 amountAfterFeeUnderlying = token.toUnderlying(amountAfterFee);



        

        token.burn(msg.sender, _amount);

        token.mint(feeRecipient, fee);



        require(

            

            

            amountAfterFeeUnderlying > minimumBurnAmount,

            "Gateway: amount is less than the minimum burn amount"

        );



        emit LogBurn(_to, amountAfterFeeUnderlying, nextN, _to);

        nextN += 1;



        return amountAfterFeeUnderlying;

    }



    

    

    function verifySignature(bytes32 _signedMessageHash, bytes memory _sig)

        public

        view

        returns (bool)

    {

        return mintAuthority == ECDSA.recover(_signedMessageHash, _sig);

    }



    

    function hashForSignature(

        bytes32 _pHash,

        uint256 _amount,

        address _to,

        bytes32 _nHash

    ) public view returns (bytes32) {

        return

            keccak256(abi.encode(_pHash, _amount, address(token), _to, _nHash));

    }

}



contract BTCGateway is InitializableAdminUpgradeabilityProxy {}



contract ZECGateway is InitializableAdminUpgradeabilityProxy {}



contract BCHGateway is InitializableAdminUpgradeabilityProxy {}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\GatewayRegistry.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import {AccessControlEnumerableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";

import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";

import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

import {StringsUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol";

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";



import {IMintGateway} from "../Gateways/interfaces/IMintGateway.sol";

import {ILockGateway} from "../Gateways/interfaces/ILockGateway.sol";

import {String} from "../libraries/String.sol";

import {RenAssetFactory} from "./RenAssetFactory.sol";

import {StringSet} from "../libraries/StringSet.sol";



contract GatewayRegistryStateV2 {

    struct GatewayDetails {

        address gateway;

        address token;

    }



    StringSet.Set internal mintGatewaySymbols;

    StringSet.Set internal lockGatewaySymbols;



    mapping(address => string) internal mintSymbolByToken;

    mapping(string => GatewayDetails) internal mintGatewayDetailsBySymbol;



    mapping(address => string) internal lockSymbolByToken;

    mapping(string => GatewayDetails) internal lockGatewayDetailsBySymbol;



    address internal _signatureVerifier;



    uint256 internal _chainId;



    address internal _transferContract;



    // Leave a gap so that storage values added in future upgrages don't corrupt

    // the storage of contracts that inherit from this contract.

    // Note that StringSet.Set occupies two slots.

    uint256[39] private __gap;

}



contract GatewayRegistryGettersV2 is GatewayRegistryStateV2 {

    using StringSet for StringSet.Set;



    function getChainId() public view returns (uint256) {

        return _chainId;

    }



    function getSignatureVerifier() public view returns (address) {

        require(_signatureVerifier != address(0x0), "GatewayRegistry: not initialized");

        return _signatureVerifier;

    }



    function getTransferContract() external view returns (address) {

        require(_transferContract != address(0x0), "GatewayRegistry: not initialized");

        return _transferContract;

    }



    /// @dev To get all the registered Gateway contracts set count to `0`.

    function getMintGatewaySymbols(uint256 from, uint256 count) external view returns (string[] memory) {

        return enumerateSet(mintGatewaySymbols, from, count);

    }



    /// @dev To get all the registered tokens set count to `0`.

    function getLockGatewaySymbols(uint256 from, uint256 count) external view returns (string[] memory) {

        return enumerateSet(lockGatewaySymbols, from, count);

    }



    function enumerateSet(

        StringSet.Set storage set,

        uint256 from,

        uint256 count

    ) internal view returns (string[] memory) {

        uint256 length = set.length();



        if (count == 0 || from + count > length) {

            count = length - from;

        }



        string[] memory gateways = new string[](count);



        for (uint256 i = 0; i < count; i++) {

            gateways[i] = set.at(i + from);

        }



        return gateways;

    }



    /// @notice Returns the Gateway contract for the given RenERC20 token

    ///         address.

    ///

    /// @param token The address of the RenERC20 token contract.

    function getMintGatewayByToken(address token) public view returns (IMintGateway) {

        return IMintGateway(mintGatewayDetailsBySymbol[mintSymbolByToken[token]].gateway);

    }



    /// @notice Deprecated in favour of getMintGatewayByToken.

    function getGatewayByToken(address token) external view returns (IMintGateway) {

        return getMintGatewayByToken(token);

    }



    /// @notice Returns the Gateway contract for the given RenERC20 token

    ///         symbol.

    ///

    /// @param tokenSymbol The symbol of the RenERC20 token contract.

    function getMintGatewayBySymbol(string calldata tokenSymbol) public view returns (IMintGateway) {

        return IMintGateway(mintGatewayDetailsBySymbol[tokenSymbol].gateway);

    }



    /// @notice Deprecated in favour of getMintGatewayBySymbol.

    function getGatewayBySymbol(string calldata tokenSymbol) external view returns (IMintGateway) {

        return getMintGatewayBySymbol(tokenSymbol);

    }



    /// @notice Returns the RenERC20 address for the given token symbol.

    ///

    /// @param tokenSymbol The symbol of the RenERC20 token contract to

    ///        lookup.

    function getRenAssetBySymbol(string calldata tokenSymbol) public view returns (IERC20) {

        return IERC20(mintGatewayDetailsBySymbol[tokenSymbol].token);

    }



    /// @notice Deprecated in favour of getRenAssetBySymbol.

    function getTokenBySymbol(string calldata tokenSymbol) external view returns (IERC20) {

        return getRenAssetBySymbol(tokenSymbol);

    }



    function getLockGatewayByToken(address token_) external view returns (ILockGateway) {

        return ILockGateway(lockGatewayDetailsBySymbol[lockSymbolByToken[token_]].gateway);

    }



    function getLockGatewayBySymbol(string calldata tokenSymbol) external view returns (ILockGateway) {

        return ILockGateway(lockGatewayDetailsBySymbol[tokenSymbol].gateway);

    }



    function getLockAssetBySymbol(string calldata tokenSymbol) external view returns (IERC20) {

        return IERC20(lockGatewayDetailsBySymbol[tokenSymbol].token);

    }

}



/// GatewayRegistry is a mapping from assets to their associated

/// RenERC20 and Gateway contracts.

contract GatewayRegistryV2 is

    Initializable,

    AccessControlEnumerableUpgradeable,

    RenAssetFactory,

    GatewayRegistryStateV2,

    GatewayRegistryGettersV2

{

    using StringSet for StringSet.Set;



    string public constant NAME = "GatewayRegistry";

    bytes32 public constant CAN_UPDATE_GATEWAYS = keccak256("CAN_UPDATE_GATEWAYS");

    bytes32 public constant CAN_ADD_GATEWAYS = keccak256("CAN_ADD_GATEWAYS");



    function __GatewayRegistry_init(

        uint256 chainId_,

        address signatureVerifier_,

        address transferContract,

        address renAssetProxyBeacon_,

        address mintGatewayProxyBeacon_,

        address lockGatewayProxyBeacon_,

        address adminAddress,

        address[] calldata gatewayDeployers

    ) external initializer {

        __AccessControlEnumerable_init();

        __RenAssetFactory_init(renAssetProxyBeacon_, mintGatewayProxyBeacon_, lockGatewayProxyBeacon_);

        _chainId = chainId_;

        _signatureVerifier = signatureVerifier_;

        _transferContract = transferContract;



        AccessControlEnumerableUpgradeable._setupRole(AccessControlUpgradeable.DEFAULT_ADMIN_ROLE, adminAddress);

        AccessControlEnumerableUpgradeable._setupRole(CAN_UPDATE_GATEWAYS, adminAddress);

        AccessControlEnumerableUpgradeable._setupRole(CAN_ADD_GATEWAYS, adminAddress);

        for (uint256 i = 0; i < gatewayDeployers.length; ++i) {

            _setupRole(CAN_ADD_GATEWAYS, gatewayDeployers[i]);

        }

    }



    /// @dev The symbol is included twice because strings have to be hashed

    /// first in order to be used as a log index/topic.

    event LogMintGatewayAdded(

        string symbol,

        address indexed token,

        address indexed gatewayContract,

        // Indexed versions of previous parameters.

        string indexed indexedSymbol

    );

    event LogMintGatewayRemoved(

        string symbol,

        // Indexed versions of previous parameters.

        string indexed indexedSymbol

    );

    event LogLockGatewayAdded(

        string symbol,

        address indexed token,

        address indexed gatewayContract,

        // Indexed versions of previous parameters.

        string indexed indexedSymbol

    );

    event LogLockGatewayRemoved(

        string symbol,

        // Indexed versions of previous parameters.

        string indexed indexedSymbol

    );



    event LogSignatureVerifierUpdated(address indexed oldSignatureVerifier, address indexed newSignatureVerifier);

    event LogTransferContractUpdated(address indexed oldTransferContract, address indexed newTransferContract);



    // MODIFIERS ///////////////////////////////////////////////////////////////



    modifier onlyValidString(string calldata str_) {

        require(String.isValidString(str_), "GatewayRegistry: empty or invalid string input");

        _;

    }



    function checkRoleVerbose(

        bytes32 role,

        string memory roleName,

        address account

    ) internal view {

        if (!hasRole(role, account)) {

            revert(

                string(

                    abi.encodePacked(

                        "GatewayRegistry: account ",

                        StringsUpgradeable.toHexString(uint160(account), 20),

                        " is missing role ",

                        roleName

                    )

                )

            );

        }

    }



    modifier onlyRoleVerbose(bytes32 role, string memory roleName) {

        checkRoleVerbose(role, roleName, _msgSender());

        _;

    }



    // GOVERNANCE //////////////////////////////////////////////////////////////



    /// @notice Allow the owner to update the signature verifier contract.

    ///

    /// @param newSignatureVerifier The new verifier contract address.

    function updateSignatureVerifier(address newSignatureVerifier)

        external

        onlyRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS")

    {

        require(newSignatureVerifier != address(0x0), "GatewayRegistry: invalid signature verifier");

        address oldSignatureVerifier = _signatureVerifier;

        _signatureVerifier = newSignatureVerifier;

        emit LogSignatureVerifierUpdated(oldSignatureVerifier, newSignatureVerifier);

    }



    /// @notice Allow the owner to update the TransferContract contract.

    ///

    /// @param newTransferContract The new TransferContract contract address.

    function updateTransferContract(address newTransferContract)

        external

        onlyRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS")

    {

        require(newTransferContract != address(0x0), "GatewayRegistry: invalid transfer with log");

        address oldTransferContract = _transferContract;

        _transferContract = newTransferContract;

        emit LogTransferContractUpdated(oldTransferContract, newTransferContract);

    }



    // MINT GATEWAYS ///////////////////////////////////////////////////////////



    /// @notice Allow the owner to set the Gateway contract for a given

    ///         RenERC20 token contract.

    ///

    /// @param symbol A string that identifies the token and gateway pair.

    /// @param renAsset The address of the RenERC20 token contract.

    /// @param mintGateway The address of the Gateway contract.

    function addMintGateway(

        string calldata symbol,

        address renAsset,

        address mintGateway

    ) public onlyValidString(symbol) onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (mintGatewaySymbols.contains(symbol)) {

            // If there is an existing gateway for the symbol, delete it. The

            // caller must also have the CAN_UPDATE_GATEWAYS role.

            removeMintGateway(symbol);

        }



        // Check that token, Gateway and symbol haven't already been registered.

        if (String.isNotEmpty(mintSymbolByToken[renAsset])) {

            revert(

                string(

                    abi.encodePacked(

                        "GatewayRegistry: ",

                        symbol,

                        " token already registered as ",

                        mintSymbolByToken[renAsset]

                    )

                )

            );

        }



        // Add to list of gateways.

        mintGatewaySymbols.add(symbol);



        mintGatewayDetailsBySymbol[symbol] = GatewayDetails({token: renAsset, gateway: mintGateway});

        mintSymbolByToken[renAsset] = symbol;



        emit LogMintGatewayAdded(symbol, renAsset, mintGateway, symbol);

    }



    function deployMintGateway(

        string calldata symbol,

        address renAsset,

        string calldata version

    ) external onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (mintGatewaySymbols.contains(symbol)) {

            // Check role before expensive contract deployment.

            checkRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS", _msgSender());

        }



        address mintGateway = address(_deployMintGateway(symbol, getSignatureVerifier(), renAsset, version));

        addMintGateway(symbol, renAsset, mintGateway);

    }



    function deployMintGatewayAndRenAsset(

        string calldata symbol,

        string calldata erc20Name,

        string calldata erc20Symbol,

        uint8 erc20Decimals,

        string calldata version

    ) external onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (mintGatewaySymbols.contains(symbol)) {

            // Check role before expensive contract deployment.

            checkRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS", _msgSender());

        }



        address renAsset = address(

            _deployRenAsset(getChainId(), symbol, erc20Name, erc20Symbol, erc20Decimals, version)

        );

        address mintGateway = address(_deployMintGateway(symbol, getSignatureVerifier(), renAsset, version));

        OwnableUpgradeable(renAsset).transferOwnership(mintGateway);

        addMintGateway(symbol, renAsset, mintGateway);

    }



    /// @notice Allows the owner to remove the Gateway contract for a given

    ///         RenERC20 contract.

    ///

    /// @param symbol The symbol of the token to deregister.

    function removeMintGateway(string calldata symbol)

        public

        onlyRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS")

    {

        address renAsset = mintGatewayDetailsBySymbol[symbol].token;

        require(renAsset != address(0x0), "GatewayRegistry: gateway not registered");



        // Remove token and Gateway contract

        delete mintSymbolByToken[renAsset];

        delete mintGatewayDetailsBySymbol[symbol];

        mintGatewaySymbols.remove(symbol);



        emit LogMintGatewayRemoved(symbol, symbol);

    }



    // LOCK GATEWAYS ///////////////////////////////////////////////////////////



    /// @notice Allow the owner to set the Gateway contract for a given

    ///         RenERC20 token contract.

    ///

    /// @param symbol A string that identifies the token and gateway pair.

    /// @param lockAsset The address of the RenERC20 token contract.

    /// @param lockGateway The address of the Gateway contract.

    function addLockGateway(

        string calldata symbol,

        address lockAsset,

        address lockGateway

    ) public onlyValidString(symbol) onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (lockGatewaySymbols.contains(symbol)) {

            // If there is an existing gateway for the symbol, delete it. The

            // caller must also have the CAN_UPDATE_GATEWAYS role.

            removeLockGateway(symbol);

        }



        // Check that token hasn't already been registered.

        if (String.isNotEmpty(lockSymbolByToken[lockAsset])) {

            revert(

                string(

                    abi.encodePacked(

                        "GatewayRegistry: ",

                        symbol,

                        " token already registered as ",

                        lockSymbolByToken[lockAsset]

                    )

                )

            );

        }



        // Add to list of gateways.

        lockGatewaySymbols.add(symbol);



        lockGatewayDetailsBySymbol[symbol] = GatewayDetails({token: lockAsset, gateway: lockGateway});

        lockSymbolByToken[lockAsset] = symbol;



        emit LogLockGatewayAdded(symbol, lockAsset, lockGateway, symbol);

    }



    function deployLockGateway(

        string calldata symbol,

        address lockToken,

        string calldata version

    ) external onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (lockGatewaySymbols.contains(symbol)) {

            // Check role before expensive contract deployment.

            checkRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS", _msgSender());

        }



        address lockGateway = address(_deployLockGateway(symbol, getSignatureVerifier(), lockToken, version));

        addLockGateway(symbol, lockToken, lockGateway);

    }



    /// @notice Allows the owner to remove the Gateway contract for a given

    ///         asset contract.

    ///

    /// @param symbol The symbol of the token to deregister.

    function removeLockGateway(string calldata symbol)

        public

        onlyRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS")

    {

        require(lockGatewaySymbols.contains(symbol), "GatewayRegistry: gateway not registered");



        address lockAsset = lockGatewayDetailsBySymbol[symbol].token;



        // Remove token and Gateway contract

        delete lockSymbolByToken[lockAsset];

        delete lockGatewayDetailsBySymbol[symbol];

        lockGatewaySymbols.remove(symbol);



        emit LogLockGatewayRemoved(symbol, symbol);

    }

}



contract GatewayRegistryProxy is TransparentUpgradeableProxy {

    constructor(

        address logic,

        address admin,

        bytes memory data

    ) payable TransparentUpgradeableProxy(logic, admin, data) {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\GatewayRegistryV3.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import {AccessControlEnumerableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";

import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";

import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

import {StringsUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol";

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {TransparentUpgradeableProxy} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";



import {IMintGateway} from "../Gateways/interfaces/IMintGateway.sol";

import {ILockGateway} from "../Gateways/interfaces/ILockGateway.sol";

import {StringV1} from "../libraries/StringV1.sol";

import {RenAssetFactory} from "./RenAssetFactory.sol";

import {StringSet} from "../libraries/StringSet.sol";

import {GatewayRegistryStateV2, GatewayRegistryGettersV2, GatewayRegistryV2} from "./GatewayRegistry.sol";



/// @dev if any new values are being added, GatewayRegistryStateV3 should

/// be updated to have all the values from GatewayRegistryStateV2 instead of

/// inheriting from it, to that values can be added before the __gap.

contract GatewayRegistryStateV3 is GatewayRegistryStateV2 {



}



contract GatewayRegistryGettersV3 is GatewayRegistryGettersV2, GatewayRegistryStateV3 {}



/// GatewayRegistry is a mapping from assets to their associated

/// RenERC20 and Gateway contracts.

contract GatewayRegistryV3 is

    Initializable,

    AccessControlEnumerableUpgradeable,

    RenAssetFactory,

    GatewayRegistryStateV3,

    GatewayRegistryGettersV3

{

    using StringSet for StringSet.Set;



    string public constant NAME = "GatewayRegistry";

    bytes32 public constant CAN_UPDATE_GATEWAYS = keccak256("CAN_UPDATE_GATEWAYS");

    bytes32 public constant CAN_ADD_GATEWAYS = keccak256("CAN_ADD_GATEWAYS");



    function __GatewayRegistry_init(

        uint256 chainId_,

        address signatureVerifier_,

        address transferContract,

        address renAssetProxyBeacon_,

        address mintGatewayProxyBeacon_,

        address lockGatewayProxyBeacon_,

        address adminAddress,

        address[] calldata gatewayDeployers

    ) external initializer {

        __AccessControlEnumerable_init();

        __RenAssetFactory_init(renAssetProxyBeacon_, mintGatewayProxyBeacon_, lockGatewayProxyBeacon_);

        _chainId = chainId_;

        _signatureVerifier = signatureVerifier_;

        _transferContract = transferContract;



        AccessControlEnumerableUpgradeable._setupRole(AccessControlUpgradeable.DEFAULT_ADMIN_ROLE, adminAddress);

        AccessControlEnumerableUpgradeable._setupRole(CAN_UPDATE_GATEWAYS, adminAddress);

        AccessControlEnumerableUpgradeable._setupRole(CAN_ADD_GATEWAYS, adminAddress);

        for (uint256 i = 0; i < gatewayDeployers.length; ++i) {

            _setupRole(CAN_ADD_GATEWAYS, gatewayDeployers[i]);

        }

    }



    /// @dev The symbol is included twice because strings have to be hashed

    /// first in order to be used as a log index/topic.

    event LogMintGatewayAdded(

        string symbol,

        address indexed token,

        address indexed gatewayContract,

        // Indexed versions of previous parameters.

        string indexed indexedSymbol

    );

    event LogMintGatewayRemoved(

        string symbol,

        // Indexed versions of previous parameters.

        string indexed indexedSymbol

    );

    event LogLockGatewayAdded(

        string symbol,

        address indexed token,

        address indexed gatewayContract,

        // Indexed versions of previous parameters.

        string indexed indexedSymbol

    );

    event LogLockGatewayRemoved(

        string symbol,

        // Indexed versions of previous parameters.

        string indexed indexedSymbol

    );



    event LogSignatureVerifierUpdated(address indexed oldSignatureVerifier, address indexed newSignatureVerifier);

    event LogTransferContractUpdated(address indexed oldTransferContract, address indexed newTransferContract);



    // MODIFIERS ///////////////////////////////////////////////////////////////



    modifier onlyValidString(string calldata str_) {

        require(StringV1.isValidString(str_), "GatewayRegistry: empty or invalid string input");

        _;

    }



    function checkRoleVerbose(

        bytes32 role,

        string memory roleName,

        address account

    ) internal view {

        if (!hasRole(role, account)) {

            revert(

                string(

                    abi.encodePacked(

                        "GatewayRegistry: account ",

                        StringsUpgradeable.toHexString(uint160(account), 20),

                        " is missing role ",

                        roleName

                    )

                )

            );

        }

    }



    modifier onlyRoleVerbose(bytes32 role, string memory roleName) {

        checkRoleVerbose(role, roleName, _msgSender());

        _;

    }



    // GOVERNANCE //////////////////////////////////////////////////////////////



    /// @notice Allow the owner to update the signature verifier contract.

    ///

    /// @param newSignatureVerifier The new verifier contract address.

    function updateSignatureVerifier(address newSignatureVerifier)

        external

        onlyRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS")

    {

        require(newSignatureVerifier != address(0x0), "GatewayRegistry: invalid signature verifier");

        address oldSignatureVerifier = _signatureVerifier;

        _signatureVerifier = newSignatureVerifier;

        emit LogSignatureVerifierUpdated(oldSignatureVerifier, newSignatureVerifier);

    }



    /// @notice Allow the owner to update the TransferContract contract.

    ///

    /// @param newTransferContract The new TransferContract contract address.

    function updateTransferContract(address newTransferContract)

        external

        onlyRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS")

    {

        require(newTransferContract != address(0x0), "GatewayRegistry: invalid transfer with log");

        address oldTransferContract = _transferContract;

        _transferContract = newTransferContract;

        emit LogTransferContractUpdated(oldTransferContract, newTransferContract);

    }



    // MINT GATEWAYS ///////////////////////////////////////////////////////////



    /// @notice Allow the owner to set the Gateway contract for a given

    ///         RenERC20 token contract.

    ///

    /// @param symbol A string that identifies the token and gateway pair.

    /// @param renAsset The address of the RenERC20 token contract.

    /// @param mintGateway The address of the Gateway contract.

    function addMintGateway(

        string calldata symbol,

        address renAsset,

        address mintGateway

    ) public onlyValidString(symbol) onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (mintGatewaySymbols.contains(symbol)) {

            // If there is an existing gateway for the symbol, delete it. The

            // caller must also have the CAN_UPDATE_GATEWAYS role.

            removeMintGateway(symbol);

        }



        // Check that token, Gateway and symbol haven't already been registered.

        if (StringV1.isNotEmpty(mintSymbolByToken[renAsset])) {

            revert(

                string(

                    abi.encodePacked(

                        "GatewayRegistry: ",

                        symbol,

                        " token already registered as ",

                        mintSymbolByToken[renAsset]

                    )

                )

            );

        }



        // Add to list of gateways.

        mintGatewaySymbols.add(symbol);



        mintGatewayDetailsBySymbol[symbol] = GatewayDetails({token: renAsset, gateway: mintGateway});

        mintSymbolByToken[renAsset] = symbol;



        emit LogMintGatewayAdded(symbol, renAsset, mintGateway, symbol);

    }



    function deployMintGateway(

        string calldata symbol,

        address renAsset,

        string calldata version

    ) external onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (mintGatewaySymbols.contains(symbol)) {

            // Check role before expensive contract deployment.

            checkRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS", _msgSender());

        }



        address mintGateway = address(_deployMintGateway(symbol, getSignatureVerifier(), renAsset, version));

        addMintGateway(symbol, renAsset, mintGateway);

    }



    function deployMintGatewayAndRenAsset(

        string calldata symbol,

        string calldata erc20Name,

        string calldata erc20Symbol,

        uint8 erc20Decimals,

        string calldata version

    ) external onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (mintGatewaySymbols.contains(symbol)) {

            // Check role before expensive contract deployment.

            checkRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS", _msgSender());

        }



        address renAsset = address(

            _deployRenAsset(getChainId(), symbol, erc20Name, erc20Symbol, erc20Decimals, version)

        );

        address mintGateway = address(_deployMintGateway(symbol, getSignatureVerifier(), renAsset, version));

        OwnableUpgradeable(renAsset).transferOwnership(mintGateway);

        addMintGateway(symbol, renAsset, mintGateway);

    }



    /// @notice Allows the owner to remove the Gateway contract for a given

    ///         RenERC20 contract.

    ///

    /// @param symbol The symbol of the token to deregister.

    function removeMintGateway(string calldata symbol)

        public

        onlyRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS")

    {

        address renAsset = mintGatewayDetailsBySymbol[symbol].token;

        require(renAsset != address(0x0), "GatewayRegistry: gateway not registered");



        // Remove token and Gateway contract

        delete mintSymbolByToken[renAsset];

        delete mintGatewayDetailsBySymbol[symbol];

        mintGatewaySymbols.remove(symbol);



        emit LogMintGatewayRemoved(symbol, symbol);

    }



    // LOCK GATEWAYS ///////////////////////////////////////////////////////////



    /// @notice Allow the owner to set the Gateway contract for a given

    ///         RenERC20 token contract.

    ///

    /// @param symbol A string that identifies the token and gateway pair.

    /// @param lockAsset The address of the RenERC20 token contract.

    /// @param lockGateway The address of the Gateway contract.

    function addLockGateway(

        string calldata symbol,

        address lockAsset,

        address lockGateway

    ) public onlyValidString(symbol) onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (lockGatewaySymbols.contains(symbol)) {

            // If there is an existing gateway for the symbol, delete it. The

            // caller must also have the CAN_UPDATE_GATEWAYS role.

            removeLockGateway(symbol);

        }



        // Check that token hasn't already been registered.

        if (StringV1.isNotEmpty(lockSymbolByToken[lockAsset])) {

            revert(

                string(

                    abi.encodePacked(

                        "GatewayRegistry: ",

                        symbol,

                        " token already registered as ",

                        lockSymbolByToken[lockAsset]

                    )

                )

            );

        }



        // Add to list of gateways.

        lockGatewaySymbols.add(symbol);



        lockGatewayDetailsBySymbol[symbol] = GatewayDetails({token: lockAsset, gateway: lockGateway});

        lockSymbolByToken[lockAsset] = symbol;



        emit LogLockGatewayAdded(symbol, lockAsset, lockGateway, symbol);

    }



    function deployLockGateway(

        string calldata symbol,

        address lockToken,

        string calldata version

    ) external onlyRoleVerbose(CAN_ADD_GATEWAYS, "CAN_ADD_GATEWAYS") {

        if (lockGatewaySymbols.contains(symbol)) {

            // Check role before expensive contract deployment.

            checkRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS", _msgSender());

        }



        address lockGateway = address(_deployLockGateway(symbol, getSignatureVerifier(), lockToken, version));

        addLockGateway(symbol, lockToken, lockGateway);

    }



    /// @notice Allows the owner to remove the Gateway contract for a given

    ///         asset contract.

    ///

    /// @param symbol The symbol of the token to deregister.

    function removeLockGateway(string calldata symbol)

        public

        onlyRoleVerbose(CAN_UPDATE_GATEWAYS, "CAN_UPDATE_GATEWAYS")

    {

        require(lockGatewaySymbols.contains(symbol), "GatewayRegistry: gateway not registered");



        address lockAsset = lockGatewayDetailsBySymbol[symbol].token;



        // Remove token and Gateway contract

        delete lockSymbolByToken[lockAsset];

        delete lockGatewayDetailsBySymbol[symbol];

        lockGatewaySymbols.remove(symbol);



        emit LogLockGatewayRemoved(symbol, symbol);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IAccessControl.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev External interface of AccessControl declared to support ERC165 detection.

 */

interface IAccessControl {

    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {AccessControl-_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) external view returns (bool);



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {AccessControl-_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) external view returns (bytes32);



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) external;



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) external;



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IAccessControlEnumerableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IAccessControlUpgradeable.sol";



/**

 * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.

 */

interface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {

    /**

     * @dev Returns one of the accounts that have `role`. `index` must be a

     * value between 0 and {getRoleMemberCount}, non-inclusive.

     *

     * Role bearers are not sorted in any particular way, and their ordering may

     * change at any point.

     *

     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure

     * you perform all queries on the same block. See the following

     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]

     * for more information.

     */

    function getRoleMember(bytes32 role, uint256 index) external view returns (address);



    /**

     * @dev Returns the number of accounts that have `role`. Can be used

     * together with {getRoleMember} to enumerate all bearers of a role.

     */

    function getRoleMemberCount(bytes32 role) external view returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IAccessControlUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev External interface of AccessControl declared to support ERC165 detection.

 */

interface IAccessControlUpgradeable {

    /**

     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`

     *

     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite

     * {RoleAdminChanged} not being emitted signaling this.

     *

     * _Available since v3.1._

     */

    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);



    /**

     * @dev Emitted when `account` is granted `role`.

     *

     * `sender` is the account that originated the contract call, an admin role

     * bearer except when using {AccessControl-_setupRole}.

     */

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Emitted when `account` is revoked `role`.

     *

     * `sender` is the account that originated the contract call:

     *   - if using `revokeRole`, it is the admin role bearer

     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)

     */

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



    /**

     * @dev Returns `true` if `account` has been granted `role`.

     */

    function hasRole(bytes32 role, address account) external view returns (bool);



    /**

     * @dev Returns the admin role that controls `role`. See {grantRole} and

     * {revokeRole}.

     *

     * To change a role's admin, use {AccessControl-_setRoleAdmin}.

     */

    function getRoleAdmin(bytes32 role) external view returns (bytes32);



    /**

     * @dev Grants `role` to `account`.

     *

     * If `account` had not been already granted `role`, emits a {RoleGranted}

     * event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function grantRole(bytes32 role, address account) external;



    /**

     * @dev Revokes `role` from `account`.

     *

     * If `account` had been granted `role`, emits a {RoleRevoked} event.

     *

     * Requirements:

     *

     * - the caller must have ``role``'s admin role.

     */

    function revokeRole(bytes32 role, address account) external;



    /**

     * @dev Revokes `role` from the calling account.

     *

     * Roles are often managed via {grantRole} and {revokeRole}: this function's

     * purpose is to provide a mechanism for accounts to lose their privileges

     * if they are compromised (such as when a trusted device is misplaced).

     *

     * If the calling account had been granted `role`, emits a {RoleRevoked}

     * event.

     *

     * Requirements:

     *

     * - the caller must be `account`.

     */

    function renounceRole(bytes32 role, address account) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IBeacon.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev This is the interface that {BeaconProxy} expects of its beacon.

 */

interface IBeacon {

    /**

     * @dev Must return an address that can be used as a delegate call target.

     *

     * {BeaconProxy} will check that this address is a contract.

     */

    function implementation() external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IERC165Upgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165Upgradeable {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IGateway.sol
File type: .sol
pragma solidity ^0.5.17;



interface IMintGateway {

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);



    function mintFee() external view returns (uint256);

}



interface IBurnGateway {

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);



    function burnFee() external view returns (uint256);

}



// TODO: In ^0.6.0, should be `interface IGateway is IMintGateway,IBurnGateway {}`

interface IGateway {

    // is IMintGateway

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);



    function mintFee() external view returns (uint256);



    // is IBurnGateway

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);



    function burnFee() external view returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IGatewayRegistry.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";



import {IMintGateway} from "../../Gateways/interfaces/IMintGateway.sol";

import {ILockGateway} from "../../Gateways/interfaces/ILockGateway.sol";



abstract contract IGatewayRegistry {

    function signatureVerifier() external view virtual returns (address);



    function chainId() external view virtual returns (uint256);



    function chainName() external view virtual returns (string memory);



    function getMintGatewaySymbols(uint256 from, uint256 count) external view virtual returns (string[] memory);



    function getLockGatewaySymbols(uint256 from, uint256 count) external view virtual returns (string[] memory);



    function getMintGatewayByToken(address token) external view virtual returns (IMintGateway);



    function getMintGatewayBySymbol(string calldata tokenSymbol) external view virtual returns (IMintGateway);



    function getRenAssetBySymbol(string calldata tokenSymbol) external view virtual returns (IERC20);



    function getLockGatewayByToken(address token) external view virtual returns (ILockGateway);



    function getLockGatewayBySymbol(string calldata tokenSymbol) external view virtual returns (ILockGateway);



    function getLockAssetBySymbol(string calldata tokenSymbol) external view virtual returns (IERC20);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ILockGateway.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



abstract contract ILockGateway {

    event LogRelease(address indexed recipient, uint256 amount, bytes32 indexed sigHash, bytes32 indexed nHash);

    event LogLockToChain(

        string recipientAddress,

        string recipientChain,

        bytes recipientPayload,

        uint256 amount,

        uint256 indexed lockNonce,

        // Indexed versions of previous parameters.

        string indexed recipientAddressIndexed,

        string indexed recipientChainIndexed

    );



    function lock(

        string calldata recipientAddress,

        string calldata recipientChain,

        bytes calldata recipientPayload,

        uint256 amount

    ) external virtual returns (uint256);



    function release(

        bytes32 pHash,

        uint256 amount,

        bytes32 nHash,

        bytes calldata sig

    ) external virtual returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\IMintGateway.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



abstract contract IMintGateway {

    /// @dev For backwards compatiblity reasons, the sigHash is cast to a

    /// uint256.

    event LogMint(address indexed to, uint256 amount, uint256 indexed sigHash, bytes32 indexed nHash);



    /// @dev Once `LogBurnToChain` is enabled on mainnet, LogBurn may be

    /// replaced by LogBurnToChain with empty payload and chain fields.

    /// @dev For backwards compatibility, `to` is bytes instead of a string.

    event LogBurn(

        bytes to,

        uint256 amount,

        uint256 indexed burnNonce,

        // Indexed versions of previous parameters.

        bytes indexed indexedTo

    );

    event LogBurnToChain(

        string recipientAddress,

        string recipientChain,

        bytes recipientPayload,

        uint256 amount,

        uint256 indexed burnNonce,

        // Indexed versions of previous parameters.

        string indexed recipientAddressIndexed,

        string indexed recipientChainIndexed

    );



    function mint(

        bytes32 pHash,

        uint256 amount,

        bytes32 nHash,

        bytes calldata sig

    ) external virtual returns (uint256);



    function burnWithPayload(

        string calldata recipientAddress,

        string calldata recipientChain,

        bytes calldata recipientPayload,

        uint256 amount

    ) external virtual returns (uint256);



    function burn(string calldata recipient, uint256 amount) external virtual returns (uint256);



    function burn(bytes calldata recipient, uint256 amount) external virtual returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\Initializable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed

 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an

 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer

 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.

 *

 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as

 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.

 *

 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure

 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.

 */

abstract contract Initializable {

    /**

     * @dev Indicates that the contract has been initialized.

     */

    bool private _initialized;



    /**

     * @dev Indicates that the contract is in the process of being initialized.

     */

    bool private _initializing;



    /**

     * @dev Modifier to protect an initializer function from being invoked twice.

     */

    modifier initializer() {

        require(_initializing || !_initialized, "Initializable: contract is already initialized");



        bool isTopLevelCall = !_initializing;

        if (isTopLevelCall) {

            _initializing = true;

            _initialized = true;

        }



        _;



        if (isTopLevelCall) {

            _initializing = false;

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\InitializableAdminUpgradeabilityProxy.sol
File type: .sol
pragma solidity ^0.5.0;



import './BaseAdminUpgradeabilityProxy.sol';

import './InitializableUpgradeabilityProxy.sol';



/**

 * @title InitializableAdminUpgradeabilityProxy

 * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for 

 * initializing the implementation, admin, and init data.

 */

contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {

  /**

   * Contract initializer.

   * @param _logic address of the initial implementation.

   * @param _admin Address of the proxy administrator.

   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.

   * It should include the signature and the parameters of the function to be called, as described in

   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.

   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.

   */

  function initialize(address _logic, address _admin, bytes memory _data) public payable {

    require(_implementation() == address(0));

    InitializableUpgradeabilityProxy.initialize(_logic, _data);

    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));

    _setAdmin(_admin);

  }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\InitializableUpgradeabilityProxy.sol
File type: .sol
pragma solidity ^0.5.0;



import './BaseUpgradeabilityProxy.sol';



/**

 * @title InitializableUpgradeabilityProxy

 * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing

 * implementation and init data.

 */

contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

  /**

   * @dev Contract initializer.

   * @param _logic Address of the initial implementation.

   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.

   * It should include the signature and the parameters of the function to be called, as described in

   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.

   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.

   */

  function initialize(address _logic, bytes memory _data) public payable {

    require(_implementation() == address(0));

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\MintGatewayLogicV1.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-10-30

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 1e106b3

Repository: https://github.com/renproject/gateway-sol

Issues: https://github.com/renproject/gateway-sol/issues



Licenses

@openzeppelin/contracts: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

gateway-sol: https://github.com/renproject/gateway-sol/blob/master/LICENSE



*/



pragma solidity ^0.5.16;





contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



library ECDSA {

    

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        

        if (signature.length != 65) {

            revert("ECDSA: signature length is invalid");

        }



        

        bytes32 r;

        bytes32 s;

        uint8 v;



        

        

        

        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := byte(0, mload(add(signature, 0x60)))

        }



        

        

        

        

        

        

        

        

        

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            revert("ECDSA: signature.s is in the wrong range");

        }



        if (v != 27 && v != 28) {

            revert("ECDSA: signature.v is in the wrong range");

        }



        

        return ecrecover(hash, v, r, s);

    }



    

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        

        

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }

}



contract Proxy {

  

  function () payable external {

    _fallback();

  }



  

  function _implementation() internal view returns (address);



  

  function _delegate(address implementation) internal {

    assembly {

      

      

      

      calldatacopy(0, 0, calldatasize)



      

      

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      

      returndatacopy(0, 0, returndatasize)



      switch result

      

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  

  function _willFallback() internal {

  }



  

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



library OpenZeppelinUpgradesAddress {

    

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        

        

        

        

        

        

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



contract BaseUpgradeabilityProxy is Proxy {

  

  event Upgraded(address indexed implementation);



  

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



  

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  

  function _setImplementation(address newImplementation) internal {

    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  constructor(address _logic, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  event AdminChanged(address previousAdmin, address newAdmin);



  



  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



  

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  

  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    (bool success,) = newImplementation.delegatecall(data);

    require(success);

  }



  

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  function initialize(address _logic, bytes memory _data) public payable {

    require(_implementation() == address(0));

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {

  

  function initialize(address _logic, address _admin, bytes memory _data) public payable {

    require(_implementation() == address(0));

    InitializableUpgradeabilityProxy.initialize(_logic, _data);

    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));

    _setAdmin(_admin);

  }

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library String {

    

    

    function fromUint(uint256 _i) internal pure returns (string memory) {

        if (_i == 0) {

            return "0";

        }

        uint256 j = _i;

        uint256 len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint256 k = len - 1;

        while (_i != 0) {

            bstr[k--] = bytes1(uint8(48 + (_i % 10)));

            _i /= 10;

        }

        return string(bstr);

    }



    

    function fromBytes32(bytes32 _value) internal pure returns (string memory) {

        bytes memory alphabet = "0123456789abcdef";



        bytes memory str = new bytes(32 * 2 + 2);

        str[0] = "0";

        str[1] = "x";

        for (uint256 i = 0; i < 32; i++) {

            str[2 + i * 2] = alphabet[uint256(uint8(_value[i] >> 4))];

            str[3 + i * 2] = alphabet[uint256(uint8(_value[i] & 0x0f))];

        }

        return string(str);

    }



    

    function fromAddress(address _addr) internal pure returns (string memory) {

        bytes32 value = bytes32(uint256(_addr));

        bytes memory alphabet = "0123456789abcdef";



        bytes memory str = new bytes(20 * 2 + 2);

        str[0] = "0";

        str[1] = "x";

        for (uint256 i = 0; i < 20; i++) {

            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];

            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];

        }

        return string(str);

    }



    

    function add8(

        string memory a,

        string memory b,

        string memory c,

        string memory d,

        string memory e,

        string memory f,

        string memory g,

        string memory h

    ) internal pure returns (string memory) {

        return string(abi.encodePacked(a, b, c, d, e, f, g, h));

    }

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    

    

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}



contract ERC20WithRate is Initializable, Ownable, ERC20 {

    using SafeMath for uint256;



    uint256 public constant _rateScale = 1e18;

    uint256 internal _rate;



    event LogRateChanged(uint256 indexed _rate);



    

    function initialize(address _nextOwner, uint256 _initialRate)

        public

        initializer

    {

        Ownable.initialize(_nextOwner);

        _setRate(_initialRate);

    }



    function setExchangeRate(uint256 _nextRate) public onlyOwner {

        _setRate(_nextRate);

    }



    function exchangeRateCurrent() public view returns (uint256) {

        require(_rate != 0, "ERC20WithRate: rate has not been initialized");

        return _rate;

    }



    function _setRate(uint256 _nextRate) internal {

        require(_nextRate > 0, "ERC20WithRate: rate must be greater than zero");

        _rate = _nextRate;

    }



    function balanceOfUnderlying(address _account)

        public

        view

        returns (uint256)

    {

        return toUnderlying(balanceOf(_account));

    }



    function toUnderlying(uint256 _amount) public view returns (uint256) {

        return _amount.mul(_rate).div(_rateScale);

    }



    function fromUnderlying(uint256 _amountUnderlying)

        public

        view

        returns (uint256)

    {

        return _amountUnderlying.mul(_rateScale).div(_rate);

    }

}



contract ERC20WithPermit is Initializable, ERC20, ERC20Detailed {

    using SafeMath for uint256;



    mapping(address => uint256) public nonces;



    

    

    string public version;



    

    bytes32 public DOMAIN_SEPARATOR;

    

    

    bytes32

        public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;



    function initialize(

        uint256 _chainId,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        version = _version;

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256(

                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"

                ),

                keccak256(bytes(name())),

                keccak256(bytes(version)),

                _chainId,

                address(this)

            )

        );

    }



    

    function permit(

        address holder,

        address spender,

        uint256 nonce,

        uint256 expiry,

        bool allowed,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external {

        bytes32 digest = keccak256(

            abi.encodePacked(

                "\x19\x01",

                DOMAIN_SEPARATOR,

                keccak256(

                    abi.encode(

                        PERMIT_TYPEHASH,

                        holder,

                        spender,

                        nonce,

                        expiry,

                        allowed

                    )

                )

            )

        );



        require(holder != address(0), "ERC20WithRate: address must not be 0x0");

        require(

            holder == ecrecover(digest, v, r, s),

            "ERC20WithRate: invalid signature"

        );

        require(

            expiry == 0 || now <= expiry,

            "ERC20WithRate: permit has expired"

        );

        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");

        uint256 amount = allowed ? uint256(-1) : 0;

        _approve(holder, spender, amount);

    }

}



contract RenERC20LogicV1 is

    Initializable,

    ERC20,

    ERC20Detailed,

    ERC20WithRate,

    ERC20WithPermit,

    Claimable,

    CanReclaimTokens

{

    

    function initialize(

        uint256 _chainId,

        address _nextOwner,

        uint256 _initialRate,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        ERC20WithRate.initialize(_nextOwner, _initialRate);

        ERC20WithPermit.initialize(

            _chainId,

            _version,

            _name,

            _symbol,

            _decimals

        );

        Claimable.initialize(_nextOwner);

        CanReclaimTokens.initialize(_nextOwner);

    }



    

    

    function mint(address _to, uint256 _amount) public onlyOwner {

        _mint(_to, _amount);

    }



    

    

    function burn(address _from, uint256 _amount) public onlyOwner {

        _burn(_from, _amount);

    }



    function transfer(address recipient, uint256 amount) public returns (bool) {

        

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transfer(recipient, amount);

    }



    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) public returns (bool) {

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transferFrom(sender, recipient, amount);

    }

}



contract RenERC20Proxy is InitializableAdminUpgradeabilityProxy {



}



interface IMintGateway {

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);



    function mintFee() external view returns (uint256);

}



interface IBurnGateway {

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);



    function burnFee() external view returns (uint256);

}



interface IGateway {

    

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);



    function mintFee() external view returns (uint256);



    

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);



    function burnFee() external view returns (uint256);

}



contract GatewayStateV1 {

    uint256 constant BIPS_DENOMINATOR = 10000;

    uint256 public minimumBurnAmount;



    

    RenERC20LogicV1 public token;



    

    address public mintAuthority;



    

    

    

    

    address public feeRecipient;



    

    uint16 public mintFee;



    

    uint16 public burnFee;



    

    mapping(bytes32 => bool) public status;



    

    

    uint256 public nextN = 0;

}



contract GatewayStateV2 {

    struct Burn {

        uint256 _blocknumber;

        bytes _to;

        uint256 _amount;

        

        string _chain;

        bytes _payload;

    }



    mapping(uint256 => Burn) internal burns;



    bytes32 public selectorHash;

}



contract MintGatewayLogicV1 is

    Initializable,

    Claimable,

    CanReclaimTokens,

    IGateway,

    GatewayStateV1,

    GatewayStateV2

{

    using SafeMath for uint256;



    event LogMintAuthorityUpdated(address indexed _newMintAuthority);

    event LogMint(

        address indexed _to,

        uint256 _amount,

        uint256 indexed _n,

        bytes32 indexed _nHash

    );

    event LogBurn(

        bytes _to,

        uint256 _amount,

        uint256 indexed _n,

        bytes indexed _indexedTo

    );



    

    modifier onlyOwnerOrMintAuthority() {

        require(

            msg.sender == mintAuthority || msg.sender == owner(),

            "MintGateway: caller is not the owner or mint authority"

        );

        _;

    }



    

    

    

    

    

    

    

    

    function initialize(

        RenERC20LogicV1 _token,

        address _feeRecipient,

        address _mintAuthority,

        uint16 _mintFee,

        uint16 _burnFee,

        uint256 _minimumBurnAmount

    ) public initializer {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        minimumBurnAmount = _minimumBurnAmount;

        token = _token;

        mintFee = _mintFee;

        burnFee = _burnFee;

        updateMintAuthority(_mintAuthority);

        updateFeeRecipient(_feeRecipient);

    }



    

    

    

    function updateSelectorHash(bytes32 _selectorHash) public onlyOwner {

        selectorHash = _selectorHash;

    }



    



    

    

    

    function claimTokenOwnership() public {

        token.claimOwnership();

    }



    

    function transferTokenOwnership(MintGatewayLogicV1 _nextTokenOwner)

        public

        onlyOwner

    {

        token.transferOwnership(address(_nextTokenOwner));

        _nextTokenOwner.claimTokenOwnership();

    }



    

    

    

    function updateMintAuthority(address _nextMintAuthority)

        public

        onlyOwnerOrMintAuthority

    {

        

        

        require(

            _nextMintAuthority != address(0),

            "MintGateway: mintAuthority cannot be set to address zero"

        );

        mintAuthority = _nextMintAuthority;

        emit LogMintAuthorityUpdated(mintAuthority);

    }



    

    

    

    function updateMinimumBurnAmount(uint256 _minimumBurnAmount)

        public

        onlyOwner

    {

        minimumBurnAmount = _minimumBurnAmount;

    }



    

    

    

    function updateFeeRecipient(address _nextFeeRecipient) public onlyOwner {

        

        require(

            _nextFeeRecipient != address(0x0),

            "MintGateway: fee recipient cannot be 0x0"

        );



        feeRecipient = _nextFeeRecipient;

    }



    

    

    

    function updateMintFee(uint16 _nextMintFee) public onlyOwner {

        mintFee = _nextMintFee;

    }



    

    

    

    function updateBurnFee(uint16 _nextBurnFee) public onlyOwner {

        burnFee = _nextBurnFee;

    }



    

    

    

    

    

    

    

    

    

    

    function mint(

        bytes32 _pHash,

        uint256 _amountUnderlying,

        bytes32 _nHash,

        bytes memory _sig

    ) public returns (uint256) {

        

        bytes32 sigHash = hashForSignature(

            _pHash,

            _amountUnderlying,

            msg.sender,

            _nHash

        );

        require(

            status[sigHash] == false,

            "MintGateway: nonce hash already spent"

        );

        if (!verifySignature(sigHash, _sig)) {

            

            

            

            revert(

                String.add8(

                    "MintGateway: invalid signature. pHash: ",

                    String.fromBytes32(_pHash),

                    ", amount: ",

                    String.fromUint(_amountUnderlying),

                    ", msg.sender: ",

                    String.fromAddress(msg.sender),

                    ", _nHash: ",

                    String.fromBytes32(_nHash)

                )

            );

        }

        status[sigHash] = true;



        uint256 amountScaled = token.fromUnderlying(_amountUnderlying);



        

        uint256 absoluteFeeScaled = amountScaled.mul(mintFee).div(

            BIPS_DENOMINATOR

        );

        uint256 receivedAmountScaled = amountScaled.sub(

            absoluteFeeScaled,

            "MintGateway: fee exceeds amount"

        );



        

        token.mint(msg.sender, receivedAmountScaled);

        

        token.mint(feeRecipient, absoluteFeeScaled);



        

        uint256 receivedAmountUnderlying = token.toUnderlying(

            receivedAmountScaled

        );

        emit LogMint(msg.sender, receivedAmountUnderlying, nextN, _nHash);

        nextN += 1;



        return receivedAmountScaled;

    }



    

    

    

    

    

    

    

    

    

    

    function burn(bytes memory _to, uint256 _amount) public returns (uint256) {

        

        

        require(_to.length != 0, "MintGateway: to address is empty");



        

        uint256 fee = _amount.mul(burnFee).div(BIPS_DENOMINATOR);

        uint256 amountAfterFee = _amount.sub(

            fee,

            "MintGateway: fee exceeds amount"

        );



        

        

        

        uint256 amountAfterFeeUnderlying = token.toUnderlying(amountAfterFee);



        

        token.burn(msg.sender, _amount);

        token.mint(feeRecipient, fee);



        require(

            

            

            amountAfterFeeUnderlying > minimumBurnAmount,

            "MintGateway: amount is less than the minimum burn amount"

        );



        emit LogBurn(_to, amountAfterFeeUnderlying, nextN, _to);

        bytes memory payload;

        GatewayStateV2.burns[nextN] = Burn({

            _blocknumber: block.number,

            _to: _to,

            _amount: amountAfterFeeUnderlying,

            _chain: "",

            _payload: payload

        });



        nextN += 1;



        return amountAfterFeeUnderlying;

    }



    function getBurn(uint256 _n)

        public

        view

        returns (

            uint256 _blocknumber,

            bytes memory _to,

            uint256 _amount,

            

            string memory _chain,

            bytes memory _payload

        )

    {

        Burn memory burnStruct = GatewayStateV2.burns[_n];

        require(burnStruct._to.length > 0, "MintGateway: burn not found");

        return (

            burnStruct._blocknumber,

            burnStruct._to,

            burnStruct._amount,

            burnStruct._chain,

            burnStruct._payload

        );

    }



    

    

    function verifySignature(bytes32 _sigHash, bytes memory _sig)

        public

        view

        returns (bool)

    {

        return mintAuthority == ECDSA.recover(_sigHash, _sig);

    }



    

    function hashForSignature(

        bytes32 _pHash,

        uint256 _amount,

        address _to,

        bytes32 _nHash

    ) public view returns (bytes32) {

        return

            keccak256(abi.encode(_pHash, _amount, selectorHash, _to, _nHash));

    }

}



contract MintGatewayProxy is InitializableAdminUpgradeabilityProxy {



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\MintGatewayV1.sol
File type: .sol
pragma solidity 0.5.17;



import "@openzeppelin/upgrades/contracts/Initializable.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/cryptography/ECDSA.sol";

import "@openzeppelin/upgrades/contracts/upgradeability/InitializableAdminUpgradeabilityProxy.sol";



import "../Governance/Claimable.sol";

import "../libraries/String.sol";

import "./RenERC20.sol";

import "./interfaces/IGateway.sol";

import "../libraries/CanReclaimTokens.sol";



contract MintGatewayStateV1 {

    uint256 constant BIPS_DENOMINATOR = 10000;

    uint256 public minimumBurnAmount;



    /// @notice Each Gateway is tied to a specific RenERC20 token.

    RenERC20LogicV1 public token;



    /// @notice The mintAuthority is an address that can sign mint requests.

    address public mintAuthority;



    /// @dev feeRecipient is assumed to be an address (or a contract) that can

    /// accept erc20 payments it cannot be 0x0.

    /// @notice When tokens are mint or burnt, a portion of the tokens are

    /// forwarded to a fee recipient.

    address public feeRecipient;



    /// @notice The mint fee in bips.

    uint16 public mintFee;



    /// @notice The burn fee in bips.

    uint16 public burnFee;



    /// @notice Each signature can only be seen once.

    mapping(bytes32 => bool) public status;



    // LogMint and LogBurn contain a unique `n` that identifies

    // the mint or burn event.

    uint256 public nextN = 0;

}



/// @notice Gateway handles verifying mint and burn requests. A mintAuthority

/// approves new assets to be minted by providing a digital signature. An owner

/// of an asset can request for it to be burnt.

contract MintGatewayLogicV1 is

    Initializable,

    Claimable,

    CanReclaimTokens,

    IGateway,

    MintGatewayStateV1

{

    using SafeMath for uint256;



    event LogMintAuthorityUpdated(address indexed _newMintAuthority);

    event LogMint(

        address indexed _to,

        uint256 _amount,

        uint256 indexed _n,

        bytes32 indexed _signedMessageHash

    );

    event LogBurn(

        bytes _to,

        uint256 _amount,

        uint256 indexed _n,

        bytes indexed _indexedTo

    );



    /// @notice Only allow the Darknode Payment contract.

    modifier onlyOwnerOrMintAuthority() {

        require(

            msg.sender == mintAuthority || msg.sender == owner(),

            "Gateway: caller is not the owner or mint authority"

        );

        _;

    }



    /// @param _token The RenERC20 this Gateway is responsible for.

    /// @param _feeRecipient The recipient of burning and minting fees.

    /// @param _mintAuthority The address of the key that can sign mint

    ///        requests.

    /// @param _mintFee The amount subtracted each mint request and

    ///        forwarded to the feeRecipient. In BIPS.

    /// @param _burnFee The amount subtracted each burn request and

    ///        forwarded to the feeRecipient. In BIPS.

    function initialize(

        RenERC20LogicV1 _token,

        address _feeRecipient,

        address _mintAuthority,

        uint16 _mintFee,

        uint16 _burnFee,

        uint256 _minimumBurnAmount

    ) public initializer {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        minimumBurnAmount = _minimumBurnAmount;

        token = _token;

        mintFee = _mintFee;

        burnFee = _burnFee;

        updateMintAuthority(_mintAuthority);

        updateFeeRecipient(_feeRecipient);

    }



    // Public functions ////////////////////////////////////////////////////////



    /// @notice Claims ownership of the token passed in to the constructor.

    /// `transferStoreOwnership` must have previously been called.

    /// Anyone can call this function.

    function claimTokenOwnership() public {

        token.claimOwnership();

    }



    /// @notice Allow the owner to update the owner of the RenERC20 token.

    function transferTokenOwnership(MintGatewayLogicV1 _nextTokenOwner)

        public

        onlyOwner

    {

        token.transferOwnership(address(_nextTokenOwner));

        _nextTokenOwner.claimTokenOwnership();

    }



    /// @notice Allow the owner to update the mint authority.

    ///

    /// @param _nextMintAuthority The new mint authority address.

    function updateMintAuthority(address _nextMintAuthority)

        public

        onlyOwnerOrMintAuthority

    {

        // The mint authority should not be set to 0, which is the result

        // returned by ecrecover for an invalid signature.

        require(

            _nextMintAuthority != address(0),

            "Gateway: mintAuthority cannot be set to address zero"

        );

        mintAuthority = _nextMintAuthority;

        emit LogMintAuthorityUpdated(mintAuthority);

    }



    /// @notice Allow the owner to update the minimum burn amount.

    ///

    /// @param _minimumBurnAmount The new min burn amount.

    function updateMinimumBurnAmount(uint256 _minimumBurnAmount)

        public

        onlyOwner

    {

        minimumBurnAmount = _minimumBurnAmount;

    }



    /// @notice Allow the owner to update the fee recipient.

    ///

    /// @param _nextFeeRecipient The address to start paying fees to.

    function updateFeeRecipient(address _nextFeeRecipient) public onlyOwner {

        // 'mint' and 'burn' will fail if the feeRecipient is 0x0

        require(

            _nextFeeRecipient != address(0x0),

            "Gateway: fee recipient cannot be 0x0"

        );



        feeRecipient = _nextFeeRecipient;

    }



    /// @notice Allow the owner to update the 'mint' fee.

    ///

    /// @param _nextMintFee The new fee for minting and burning.

    function updateMintFee(uint16 _nextMintFee) public onlyOwner {

        mintFee = _nextMintFee;

    }



    /// @notice Allow the owner to update the burn fee.

    ///

    /// @param _nextBurnFee The new fee for minting and burning.

    function updateBurnFee(uint16 _nextBurnFee) public onlyOwner {

        burnFee = _nextBurnFee;

    }



    /// @notice mint verifies a mint approval signature from RenVM and creates

    ///         tokens after taking a fee for the `_feeRecipient`.

    ///

    /// @param _pHash (payload hash) The hash of the payload associated with the

    ///        mint.

    /// @param _amountUnderlying The amount of the token being minted, in its smallest

    ///        value. (e.g. satoshis for BTC).

    /// @param _nHash (nonce hash) The hash of the nonce, amount and pHash.

    /// @param _sig The signature of the hash of the following values:

    ///        (pHash, amount, msg.sender, nHash), signed by the mintAuthority.

    function mint(

        bytes32 _pHash,

        uint256 _amountUnderlying,

        bytes32 _nHash,

        bytes memory _sig

    ) public returns (uint256) {

        // Calculate the hash signed by RenVM.

        bytes32 sigHash =

            hashForSignature(_pHash, _amountUnderlying, msg.sender, _nHash);



        //



        // Check that the signature hasn't been redeemed.

        require(status[sigHash] == false, "Gateway: nonce hash already spent");



        // If the signature fails verification, throw an error. If any one of

        // them passed the verification, continue.

        if (!verifySignature(sigHash, _sig)) {

            // Return a detailed string containing the hash and recovered

            // signer. This is somewhat costly but is only run in the revert

            // branch.

            revert(

                String.add8(

                    "Gateway: invalid signature. pHash: ",

                    String.fromBytes32(_pHash),

                    ", amount: ",

                    String.fromUint(_amountUnderlying),

                    ", msg.sender: ",

                    String.fromAddress(msg.sender),

                    ", _nHash: ",

                    String.fromBytes32(_nHash)

                )

            );

        }



        // Update the status for the signature hash so that it can't be used

        // again.

        status[sigHash] = true;



        uint256 amountScaled = token.fromUnderlying(_amountUnderlying);



        // Mint `amount - fee` for the recipient and mint `fee` for the minter

        uint256 absoluteFeeScaled =

            amountScaled.mul(mintFee).div(BIPS_DENOMINATOR);

        uint256 receivedAmountScaled =

            amountScaled.sub(absoluteFeeScaled, "Gateway: fee exceeds amount");



        // Mint amount minus the fee

        token.mint(msg.sender, receivedAmountScaled);

        // Mint the fee

        token.mint(feeRecipient, absoluteFeeScaled);



        // Emit a log with a unique identifier 'n'.

        uint256 receivedAmountUnderlying =

            token.toUnderlying(receivedAmountScaled);

        emit LogMint(msg.sender, receivedAmountUnderlying, nextN, sigHash);

        nextN += 1;



        return receivedAmountScaled;

    }



    /// @notice burn destroys tokens after taking a fee for the `_feeRecipient`,

    ///         allowing the associated assets to be released on their native

    ///         chain.

    ///

    /// @param _to The address to receive the un-bridged asset. The format of

    ///        this address should be of the destination chain.

    ///        For example, when burning to Bitcoin, _to should be a

    ///        Bitcoin address.

    /// @param _amount The amount of the token being burnt, in its

    ///        smallest value. (e.g. satoshis for BTC)

    function burn(bytes memory _to, uint256 _amount) public returns (uint256) {

        // The recipient must not be empty. Better validation is possible,

        // but would need to be customized for each destination ledger.

        require(_to.length != 0, "Gateway: to address is empty");



        // Calculate fee, subtract it from amount being burnt.

        uint256 fee = _amount.mul(burnFee).div(BIPS_DENOMINATOR);

        uint256 amountAfterFee =

            _amount.sub(fee, "Gateway: fee exceeds amount");



        // If the scaled token can represent more precision than the underlying

        // token, the difference is lost. This won't exceed 1 sat, so is

        // negligible compared to burning and transaction fees.

        uint256 amountAfterFeeUnderlying = token.toUnderlying(amountAfterFee);



        // Burn the whole amount, and then re-mint the fee.

        token.burn(msg.sender, _amount);

        token.mint(feeRecipient, fee);



        require(

            // Must be strictly greater, to that the release transaction is of

            // at least one unit.

            amountAfterFeeUnderlying > minimumBurnAmount,

            "Gateway: amount is less than the minimum burn amount"

        );



        emit LogBurn(_to, amountAfterFeeUnderlying, nextN, _to);

        nextN += 1;



        return amountAfterFeeUnderlying;

    }



    /// @notice verifySignature checks the the provided signature matches the

    /// provided parameters.

    function verifySignature(bytes32 _sigHash, bytes memory _sig)

        public

        view

        returns (bool)

    {

        return mintAuthority == ECDSA.recover(_sigHash, _sig);

    }



    /// @notice hashForSignature hashes the parameters so that they can be

    /// signed.

    function hashForSignature(

        bytes32 _pHash,

        uint256 _amount,

        address _to,

        bytes32 _nHash

    ) public view returns (bytes32) {

        return

            keccak256(abi.encode(_pHash, _amount, address(token), _to, _nHash));

    }

}



contract BTCGateway is InitializableAdminUpgradeabilityProxy {}



contract ZECGateway is InitializableAdminUpgradeabilityProxy {}



contract BCHGateway is InitializableAdminUpgradeabilityProxy {}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\MintGatewayV2.sol
File type: .sol
pragma solidity ^0.5.17;



import "@openzeppelin/upgrades/contracts/Initializable.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/cryptography/ECDSA.sol";

import "@openzeppelin/upgrades/contracts/upgradeability/InitializableAdminUpgradeabilityProxy.sol";



import "../Governance/Claimable.sol";

import "../libraries/String.sol";

import "./RenERC20.sol";

import "./interfaces/IGateway.sol";

import "../libraries/CanReclaimTokens.sol";

import "./MintGatewayV1.sol";



contract MintGatewayStateV2 {

    struct Burn {

        uint256 _blocknumber;

        bytes _to;

        uint256 _amount;

        // Optional

        string _chain;

        bytes _payload;

    }



    mapping(uint256 => Burn) internal burns;



    bytes32 public selectorHash;

}



/// @notice Gateway handles verifying mint and burn requests. A mintAuthority

/// approves new assets to be minted by providing a digital signature. An owner

/// of an asset can request for it to be burnt.

contract MintGatewayLogicV2 is

    Initializable,

    Claimable,

    CanReclaimTokens,

    IGateway,

    MintGatewayStateV1,

    MintGatewayStateV2

{

    using SafeMath for uint256;



    event LogMintAuthorityUpdated(address indexed _newMintAuthority);

    event LogMint(

        address indexed _to,

        uint256 _amount,

        uint256 indexed _n,

        // Log the nHash instead of sHash so that it can be queried without

        // knowing the sHash.

        bytes32 indexed _nHash

    );

    event LogBurn(

        bytes _to,

        uint256 _amount,

        uint256 indexed _n,

        bytes indexed _indexedTo

    );



    /// @notice Only allow the Darknode Payment contract.

    modifier onlyOwnerOrMintAuthority() {

        require(

            msg.sender == mintAuthority || msg.sender == owner(),

            "MintGateway: caller is not the owner or mint authority"

        );

        _;

    }



    /// @param _token The RenERC20 this Gateway is responsible for.

    /// @param _feeRecipient The recipient of burning and minting fees.

    /// @param _mintAuthority The address of the key that can sign mint

    ///        requests.

    /// @param _mintFee The amount subtracted each mint request and

    ///        forwarded to the feeRecipient. In BIPS.

    /// @param _burnFee The amount subtracted each burn request and

    ///        forwarded to the feeRecipient. In BIPS.

    function initialize(

        RenERC20LogicV1 _token,

        address _feeRecipient,

        address _mintAuthority,

        uint16 _mintFee,

        uint16 _burnFee,

        uint256 _minimumBurnAmount

    ) public initializer {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        minimumBurnAmount = _minimumBurnAmount;

        token = _token;

        mintFee = _mintFee;

        burnFee = _burnFee;

        updateMintAuthority(_mintAuthority);

        updateFeeRecipient(_feeRecipient);

    }



    /// @param _selectorHash Hash of the token and chain selector.

    ///        The hash should calculated from

    ///        `SHA256(4 bytes of selector length, selector)`

    function updateSelectorHash(bytes32 _selectorHash) public onlyOwner {

        selectorHash = _selectorHash;

    }



    /// @notice Allow the owner to update the token symbol.

    function updateSymbol(string memory symbol) public onlyOwner {

        token.updateSymbol(symbol);

    }



    // Public functions ////////////////////////////////////////////////////////



    /// @notice Claims ownership of the token passed in to the constructor.

    /// `transferStoreOwnership` must have previously been called.

    /// Anyone can call this function.

    function claimTokenOwnership() public {

        token.claimOwnership();

    }



    /// @notice Allow the owner to update the owner of the RenERC20 token.

    function transferTokenOwnership(MintGatewayLogicV2 _nextTokenOwner)

        public

        onlyOwner

    {

        token.transferOwnership(address(_nextTokenOwner));

        _nextTokenOwner.claimTokenOwnership();

    }



    /// @notice Allow the owner to update the mint authority.

    ///

    /// @param _nextMintAuthority The new mint authority address.

    function updateMintAuthority(address _nextMintAuthority)

        public

        onlyOwnerOrMintAuthority

    {

        // The mint authority should not be set to 0, which is the result

        // returned by ecrecover for an invalid signature.

        require(

            _nextMintAuthority != address(0),

            "MintGateway: mintAuthority cannot be set to address zero"

        );

        mintAuthority = _nextMintAuthority;

        emit LogMintAuthorityUpdated(mintAuthority);

    }



    /// @notice Allow the owner to update the minimum burn amount.

    ///

    /// @param _minimumBurnAmount The new min burn amount.

    function updateMinimumBurnAmount(uint256 _minimumBurnAmount)

        public

        onlyOwner

    {

        minimumBurnAmount = _minimumBurnAmount;

    }



    /// @notice Allow the owner to update the fee recipient.

    ///

    /// @param _nextFeeRecipient The address to start paying fees to.

    function updateFeeRecipient(address _nextFeeRecipient) public onlyOwner {

        // 'mint' and 'burn' will fail if the feeRecipient is 0x0

        require(

            _nextFeeRecipient != address(0x0),

            "MintGateway: fee recipient cannot be 0x0"

        );



        feeRecipient = _nextFeeRecipient;

    }



    /// @notice Allow the owner to update the 'mint' fee.

    ///

    /// @param _nextMintFee The new fee for minting and burning.

    function updateMintFee(uint16 _nextMintFee) public onlyOwner {

        mintFee = _nextMintFee;

    }



    /// @notice Allow the owner to update the burn fee.

    ///

    /// @param _nextBurnFee The new fee for minting and burning.

    function updateBurnFee(uint16 _nextBurnFee) public onlyOwner {

        burnFee = _nextBurnFee;

    }



    /// @notice Allow the owner to update the mint and burn fees.

    ///

    /// @param _nextMintFee The new fee for minting and burning.

    /// @param _nextBurnFee The new fee for minting and burning.

    function updateFees(uint16 _nextMintFee, uint16 _nextBurnFee)

        public

        onlyOwner

    {

        mintFee = _nextMintFee;

        burnFee = _nextBurnFee;

    }



    /// @notice mint verifies a mint approval signature from RenVM and creates

    ///         tokens after taking a fee for the `_feeRecipient`.

    ///

    /// @param _pHash (payload hash) The hash of the payload associated with the

    ///        mint.

    /// @param _amountUnderlying The amount of the token being minted, in its smallest

    ///        value. (e.g. satoshis for BTC).

    /// @param _nHash (nonce hash) The hash of the nonce, amount and pHash.

    /// @param _sig The signature of the hash of the following values:

    ///        (pHash, amount, msg.sender, nHash), signed by the mintAuthority.

    function mint(

        bytes32 _pHash,

        uint256 _amountUnderlying,

        bytes32 _nHash,

        bytes memory _sig

    ) public returns (uint256) {

        // Calculate the hash signed by RenVM.

        bytes32 sigHash =

            hashForSignature(_pHash, _amountUnderlying, msg.sender, _nHash);



        // Calculate the v0.2 signature hash for backwards-compatibility.

        bytes32 legacySigHash =

            _legacy_hashForSignature(

                _pHash,

                _amountUnderlying,

                msg.sender,

                _nHash

            );



        // Check that neither signature has been redeemed.

        require(

            status[sigHash] == false && status[legacySigHash] == false,

            "MintGateway: nonce hash already spent"

        );



        // If both signatures fail verification, throw an error. If any one of

        // them passed the verification, continue.

        if (

            !verifySignature(sigHash, _sig) &&

            !verifySignature(legacySigHash, _sig)

        ) {

            // Return a detailed string containing the hash and recovered

            // signer. This is somewhat costly but is only run in the revert

            // branch.

            revert(

                String.add8(

                    "MintGateway: invalid signature. pHash: ",

                    String.fromBytes32(_pHash),

                    ", amount: ",

                    String.fromUint(_amountUnderlying),

                    ", msg.sender: ",

                    String.fromAddress(msg.sender),

                    ", _nHash: ",

                    String.fromBytes32(_nHash)

                )

            );

        }



        // Update the status for both signature hashes. This is to ensure that

        // legacy signatures can't be re-redeemed if `updateSelectorHash` is

        // ever called - thus changing the result of `sigHash` but not

        // `legacySigHash`.

        status[sigHash] = true;

        status[legacySigHash] = true;



        uint256 amountScaled = token.fromUnderlying(_amountUnderlying);



        // Mint `amount - fee` for the recipient and mint `fee` for the minter

        uint256 absoluteFeeScaled =

            amountScaled.mul(mintFee).div(BIPS_DENOMINATOR);

        uint256 receivedAmountScaled =

            amountScaled.sub(

                absoluteFeeScaled,

                "MintGateway: fee exceeds amount"

            );



        // Mint amount minus the fee

        token.mint(msg.sender, receivedAmountScaled);

        // Mint the fee

        if (absoluteFeeScaled > 0) {

            token.mint(feeRecipient, absoluteFeeScaled);

        }



        // Emit a log with a unique identifier 'n'.

        uint256 receivedAmountUnderlying =

            token.toUnderlying(receivedAmountScaled);

        emit LogMint(msg.sender, receivedAmountUnderlying, nextN, _nHash);

        nextN += 1;



        return receivedAmountScaled;

    }



    /// @notice burn destroys tokens after taking a fee for the `_feeRecipient`,

    ///         allowing the associated assets to be released on their native

    ///         chain.

    ///

    /// @param _to The address to receive the un-bridged asset. The format of

    ///        this address should be of the destination chain.

    ///        For example, when burning to Bitcoin, _to should be a

    ///        Bitcoin address.

    /// @param _amount The amount of the token being burnt, in its

    ///        smallest value. (e.g. satoshis for BTC)

    function burn(bytes memory _to, uint256 _amount) public returns (uint256) {

        // The recipient must not be empty. Better validation is possible,

        // but would need to be customized for each destination ledger.

        require(_to.length != 0, "MintGateway: to address is empty");



        // Calculate fee, subtract it from amount being burnt.

        uint256 fee = _amount.mul(burnFee).div(BIPS_DENOMINATOR);

        uint256 amountAfterFee =

            _amount.sub(fee, "MintGateway: fee exceeds amount");



        // If the scaled token can represent more precision than the underlying

        // token, the difference is lost. This won't exceed 1 sat, so is

        // negligible compared to burning and transaction fees.

        uint256 amountAfterFeeUnderlying = token.toUnderlying(amountAfterFee);



        // Burn the whole amount, and then re-mint the fee.

        token.burn(msg.sender, _amount);

        if (fee > 0) {

            token.mint(feeRecipient, fee);

        }



        require(

            // Must be strictly greater, to that the release transaction is of

            // at least one unit.

            amountAfterFeeUnderlying > minimumBurnAmount,

            "MintGateway: amount is less than the minimum burn amount"

        );



        emit LogBurn(_to, amountAfterFeeUnderlying, nextN, _to);



        // Store burn so that it can be looked up instead of relying on event

        // logs.

        bytes memory payload;

        MintGatewayStateV2.burns[nextN] = Burn({

            _blocknumber: block.number,

            _to: _to,

            _amount: amountAfterFeeUnderlying,

            _chain: "",

            _payload: payload

        });



        nextN += 1;



        return amountAfterFeeUnderlying;

    }



    function getBurn(uint256 _n)

        public

        view

        returns (

            uint256 _blocknumber,

            bytes memory _to,

            uint256 _amount,

            // Optional

            string memory _chain,

            bytes memory _payload

        )

    {

        Burn memory burnStruct = MintGatewayStateV2.burns[_n];

        require(burnStruct._to.length > 0, "MintGateway: burn not found");

        return (

            burnStruct._blocknumber,

            burnStruct._to,

            burnStruct._amount,

            burnStruct._chain,

            burnStruct._payload

        );

    }



    /// @notice verifySignature checks the the provided signature matches the

    /// provided parameters.

    function verifySignature(bytes32 _sigHash, bytes memory _sig)

        public

        view

        returns (bool)

    {

        return mintAuthority == ECDSA.recover(_sigHash, _sig);

    }



    /// @notice hashForSignature hashes the parameters so that they can be

    /// signed.

    function hashForSignature(

        bytes32 _pHash,

        uint256 _amount,

        address _to,

        bytes32 _nHash

    ) public view returns (bytes32) {

        return

            keccak256(abi.encode(_pHash, _amount, selectorHash, _to, _nHash));

    }



    /// @notice _legacy_hashForSignature calculates the signature hash used by

    /// the 0.2 version of RenVM. It's kept here for backwards-compatibility.

    function _legacy_hashForSignature(

        bytes32 _pHash,

        uint256 _amount,

        address _to,

        bytes32 _nHash

    ) public view returns (bytes32) {

        return

            keccak256(abi.encode(_pHash, _amount, address(token), _to, _nHash));

    }

}



/* solium-disable-next-line no-empty-blocks */

contract MintGatewayProxy is InitializableAdminUpgradeabilityProxy {



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/Context.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _setOwner(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _setOwner(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _setOwner(newOwner);

    }



    function _setOwner(address newOwner) private {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\OwnableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/ContextUpgradeable.sol";

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    function __Ownable_init() internal initializer {

        __Context_init_unchained();

        __Ownable_init_unchained();

    }



    function __Ownable_init_unchained() internal initializer {

        _setOwner(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _setOwner(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _setOwner(newOwner);

    }



    function _setOwner(address newOwner) private {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ProtocolLogicV1.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-03-25

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 9068f80

Repository: https://github.com/renproject/darknode-sol

Issues: https://github.com/renproject/darknode-sol/issues



Licenses

@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE



*/



pragma solidity 0.5.16;





contract Proxy {

  

  function () payable external {

    _fallback();

  }



  

  function _implementation() internal view returns (address);



  

  function _delegate(address implementation) internal {

    assembly {

      

      

      

      calldatacopy(0, 0, calldatasize)



      

      

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      

      returndatacopy(0, 0, returndatasize)



      switch result

      

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  

  function _willFallback() internal {

  }



  

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



library OpenZeppelinUpgradesAddress {

    

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        

        

        

        

        

        

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



contract BaseUpgradeabilityProxy is Proxy {

  

  event Upgraded(address indexed implementation);



  

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



  

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  

  function _setImplementation(address newImplementation) internal {

    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  constructor(address _logic, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  event AdminChanged(address previousAdmin, address newAdmin);



  



  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



  

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  

  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    (bool success,) = newImplementation.delegatecall(data);

    require(success);

  }



  

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  function initialize(address _logic, bytes memory _data) public payable {

    require(_implementation() == address(0));

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {

  

  function initialize(address _logic, address _admin, bytes memory _data) public payable {

    require(_implementation() == address(0));

    InitializableUpgradeabilityProxy.initialize(_logic, _data);

    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));

    _setAdmin(_admin);

  }

}



contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



library Math {

    

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        

        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

    }

}



library ERC20WithFees {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    

    

    function safeTransferFromWithFees(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal returns (uint256) {

        uint256 balancesBefore = token.balanceOf(to);

        token.safeTransferFrom(from, to, value);

        uint256 balancesAfter = token.balanceOf(to);

        return Math.min(value, balancesAfter.sub(balancesBefore));

    }

}



contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}



library Roles {

    struct Role {

        mapping (address => bool) bearer;

    }



    

    function add(Role storage role, address account) internal {

        require(!has(role, account), "Roles: account already has role");

        role.bearer[account] = true;

    }



    

    function remove(Role storage role, address account) internal {

        require(has(role, account), "Roles: account does not have role");

        role.bearer[account] = false;

    }



    

    function has(Role storage role, address account) internal view returns (bool) {

        require(account != address(0), "Roles: account is the zero address");

        return role.bearer[account];

    }

}



contract PauserRole is Initializable, Context {

    using Roles for Roles.Role;



    event PauserAdded(address indexed account);

    event PauserRemoved(address indexed account);



    Roles.Role private _pausers;



    function initialize(address sender) public initializer {

        if (!isPauser(sender)) {

            _addPauser(sender);

        }

    }



    modifier onlyPauser() {

        require(isPauser(_msgSender()), "PauserRole: caller does not have the Pauser role");

        _;

    }



    function isPauser(address account) public view returns (bool) {

        return _pausers.has(account);

    }



    function addPauser(address account) public onlyPauser {

        _addPauser(account);

    }



    function renouncePauser() public {

        _removePauser(_msgSender());

    }



    function _addPauser(address account) internal {

        _pausers.add(account);

        emit PauserAdded(account);

    }



    function _removePauser(address account) internal {

        _pausers.remove(account);

        emit PauserRemoved(account);

    }



    uint256[50] private ______gap;

}



contract Pausable is Initializable, Context, PauserRole {

    

    event Paused(address account);



    

    event Unpaused(address account);



    bool private _paused;



    

    function initialize(address sender) public initializer {

        PauserRole.initialize(sender);



        _paused = false;

    }



    

    function paused() public view returns (bool) {

        return _paused;

    }



    

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    

    function pause() public onlyPauser whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    

    function unpause() public onlyPauser whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }



    uint256[50] private ______gap;

}



contract ERC20Pausable is Initializable, ERC20, Pausable {

    function initialize(address sender) public initializer {

        Pausable.initialize(sender);

    }



    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transfer(to, value);

    }



    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transferFrom(from, to, value);

    }



    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {

        return super.approve(spender, value);

    }



    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {

        return super.increaseAllowance(spender, addedValue);

    }



    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {

        return super.decreaseAllowance(spender, subtractedValue);

    }



    uint256[50] private ______gap;

}



contract ERC20Burnable is Initializable, Context, ERC20 {

    

    function burn(uint256 amount) public {

        _burn(_msgSender(), amount);

    }



    

    function burnFrom(address account, uint256 amount) public {

        _burnFrom(account, amount);

    }



    uint256[50] private ______gap;

}



contract RenToken is Ownable, ERC20Detailed, ERC20Pausable, ERC20Burnable {

    string private constant _name = "REN";

    string private constant _symbol = "REN";

    uint8 private constant _decimals = 18;



    uint256 public constant INITIAL_SUPPLY = 1000000000 *

        10**uint256(_decimals);



    

    constructor() public {

        ERC20Pausable.initialize(msg.sender);

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        Ownable.initialize(msg.sender);

        _mint(msg.sender, INITIAL_SUPPLY);

    }



    function transferTokens(address beneficiary, uint256 amount)

        public

        onlyOwner

        returns (bool)

    {

        

        

        require(amount > 0);



        _transfer(msg.sender, beneficiary, amount);

        emit Transfer(msg.sender, beneficiary, amount);



        return true;

    }

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library LinkedList {



    

    address public constant NULL = address(0);



    

    struct Node {

        bool inList;

        address previous;

        address next;

    }



    

    struct List {

        mapping (address => Node) list;

    }



    

    function insertBefore(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address prev = self.list[target].previous;



        self.list[newNode].next = target;

        self.list[newNode].previous = prev;

        self.list[target].previous = newNode;

        self.list[prev].next = newNode;



        self.list[newNode].inList = true;

    }



    

    function insertAfter(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address n = self.list[target].next;



        self.list[newNode].previous = target;

        self.list[newNode].next = n;

        self.list[target].next = newNode;

        self.list[n].previous = newNode;



        self.list[newNode].inList = true;

    }



    

    function remove(List storage self, address node) internal {

        require(isInList(self, node), "LinkedList: not in list");

        

        address p = self.list[node].previous;

        address n = self.list[node].next;



        self.list[p].next = n;

        self.list[n].previous = p;



        

        

        self.list[node].inList = false;

        delete self.list[node];

    }



    

    function prepend(List storage self, address node) internal {

        



        insertBefore(self, begin(self), node);

    }



    

    function append(List storage self, address node) internal {

        



        insertAfter(self, end(self), node);

    }



    function swap(List storage self, address left, address right) internal {

        



        address previousRight = self.list[right].previous;

        remove(self, right);

        insertAfter(self, left, right);

        remove(self, left);

        insertAfter(self, previousRight, left);

    }



    function isInList(List storage self, address node) internal view returns (bool) {

        return self.list[node].inList;

    }



    

    function begin(List storage self) internal view returns (address) {

        return self.list[NULL].next;

    }



    

    function end(List storage self) internal view returns (address) {

        return self.list[NULL].previous;

    }



    function next(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].next;

    }



    function previous(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].previous;

    }



    function elements(List storage self, address _start, uint256 _count) internal view returns (address[] memory) {

        require(_count > 0, "LinkedList: invalid count");

        require(isInList(self, _start) || _start == address(0), "LinkedList: not in list");

        address[] memory elems = new address[](_count);



        

        uint256 n = 0;

        address nextItem = _start;

        if (nextItem == address(0)) {

            nextItem = begin(self);

        }



        while (n < _count) {

            if (nextItem == address(0)) {

                break;

            }

            elems[n] = nextItem;

            nextItem = next(self, nextItem);

            n += 1;

        }

        return elems;

    }

}



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    

    

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}



contract DarknodeRegistryStore is Claimable, CanReclaimTokens {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    

    

    struct Darknode {

        

        

        

        

        address payable owner;

        

        

        

        uint256 bond;

        

        uint256 registeredAt;

        

        uint256 deregisteredAt;

        

        

        

        

        bytes publicKey;

    }



    

    mapping(address => Darknode) private darknodeRegistry;

    LinkedList.List private darknodes;



    

    RenToken public ren;



    

    

    

    

    constructor(string memory _VERSION, RenToken _ren) public {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;

        ren = _ren;

        blacklistRecoverableToken(address(ren));

    }



    

    

    

    

    

    

    

    

    

    function appendDarknode(

        address _darknodeID,

        address payable _darknodeOperator,

        uint256 _bond,

        bytes calldata _publicKey,

        uint256 _registeredAt,

        uint256 _deregisteredAt

    ) external onlyOwner {

        Darknode memory darknode = Darknode({

            owner: _darknodeOperator,

            bond: _bond,

            publicKey: _publicKey,

            registeredAt: _registeredAt,

            deregisteredAt: _deregisteredAt

        });

        darknodeRegistry[_darknodeID] = darknode;

        LinkedList.append(darknodes, _darknodeID);

    }



    

    function begin() external view onlyOwner returns (address) {

        return LinkedList.begin(darknodes);

    }



    

    

    function next(address darknodeID)

        external

        view

        onlyOwner

        returns (address)

    {

        return LinkedList.next(darknodes, darknodeID);

    }



    

    

    function removeDarknode(address darknodeID) external onlyOwner {

        uint256 bond = darknodeRegistry[darknodeID].bond;

        delete darknodeRegistry[darknodeID];

        LinkedList.remove(darknodes, darknodeID);

        require(

            ren.transfer(owner(), bond),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    

    function updateDarknodeBond(address darknodeID, uint256 decreasedBond)

        external

        onlyOwner

    {

        uint256 previousBond = darknodeRegistry[darknodeID].bond;

        require(

            decreasedBond < previousBond,

            "DarknodeRegistryStore: bond not decreased"

        );

        darknodeRegistry[darknodeID].bond = decreasedBond;

        require(

            ren.transfer(owner(), previousBond.sub(decreasedBond)),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    function updateDarknodeDeregisteredAt(

        address darknodeID,

        uint256 deregisteredAt

    ) external onlyOwner {

        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;

    }



    

    function darknodeOperator(address darknodeID)

        external

        view

        onlyOwner

        returns (address payable)

    {

        return darknodeRegistry[darknodeID].owner;

    }



    

    function darknodeBond(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].bond;

    }



    

    function darknodeRegisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].registeredAt;

    }



    

    function darknodeDeregisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].deregisteredAt;

    }



    

    function darknodePublicKey(address darknodeID)

        external

        view

        onlyOwner

        returns (bytes memory)

    {

        return darknodeRegistry[darknodeID].publicKey;

    }

}



interface IDarknodePaymentStore {}



interface IDarknodePayment {

    function changeCycle() external returns (uint256);

    function store() external view returns (IDarknodePaymentStore);

}



interface IDarknodeSlasher {}



contract DarknodeRegistryStateV1 {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    struct Epoch {

        uint256 epochhash;

        uint256 blocktime;

    }



    uint256 public numDarknodes;

    uint256 public numDarknodesNextEpoch;

    uint256 public numDarknodesPreviousEpoch;



    

    uint256 public minimumBond;

    uint256 public minimumPodSize;

    uint256 public minimumEpochInterval;

    uint256 public deregistrationInterval;



    

    

    

    uint256 public nextMinimumBond;

    uint256 public nextMinimumPodSize;

    uint256 public nextMinimumEpochInterval;



    

    Epoch public currentEpoch;

    Epoch public previousEpoch;



    

    RenToken public ren;



    

    DarknodeRegistryStore public store;



    

    IDarknodePayment public darknodePayment;



    

    IDarknodeSlasher public slasher;

    IDarknodeSlasher public nextSlasher;

}



contract DarknodeRegistryLogicV1 is

    Claimable,

    CanReclaimTokens,

    DarknodeRegistryStateV1

{

    

    

    

    

    event LogDarknodeRegistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _bond

    );



    

    

    

    event LogDarknodeDeregistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID

    );



    

    

    

    event LogDarknodeRefunded(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _amount

    );



    

    

    

    

    

    event LogDarknodeSlashed(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        address indexed _challenger,

        uint256 _percentage

    );



    

    event LogNewEpoch(uint256 indexed epochhash);



    

    event LogMinimumBondUpdated(

        uint256 _previousMinimumBond,

        uint256 _nextMinimumBond

    );

    event LogMinimumPodSizeUpdated(

        uint256 _previousMinimumPodSize,

        uint256 _nextMinimumPodSize

    );

    event LogMinimumEpochIntervalUpdated(

        uint256 _previousMinimumEpochInterval,

        uint256 _nextMinimumEpochInterval

    );

    event LogSlasherUpdated(

        address indexed _previousSlasher,

        address indexed _nextSlasher

    );

    event LogDarknodePaymentUpdated(

        IDarknodePayment indexed _previousDarknodePayment,

        IDarknodePayment indexed _nextDarknodePayment

    );



    

    modifier onlyDarknodeOperator(address _darknodeID) {

        require(

            store.darknodeOperator(_darknodeID) == msg.sender,

            "DarknodeRegistry: must be darknode owner"

        );

        _;

    }



    

    modifier onlyRefunded(address _darknodeID) {

        require(

            isRefunded(_darknodeID),

            "DarknodeRegistry: must be refunded or never registered"

        );

        _;

    }



    

    modifier onlyRefundable(address _darknodeID) {

        require(

            isRefundable(_darknodeID),

            "DarknodeRegistry: must be deregistered for at least one epoch"

        );

        _;

    }



    

    

    modifier onlyDeregisterable(address _darknodeID) {

        require(

            isDeregisterable(_darknodeID),

            "DarknodeRegistry: must be deregisterable"

        );

        _;

    }



    

    modifier onlySlasher() {

        require(

            address(slasher) == msg.sender,

            "DarknodeRegistry: must be slasher"

        );

        _;

    }



    

    

    modifier onlyDarknode(address _darknodeID) {

        require(

            isRegistered(_darknodeID),

            "DarknodeRegistry: invalid darknode"

        );

        _;

    }



    

    

    

    

    

    

    

    

    

    function initialize(

        string memory _VERSION,

        RenToken _renAddress,

        DarknodeRegistryStore _storeAddress,

        uint256 _minimumBond,

        uint256 _minimumPodSize,

        uint256 _minimumEpochIntervalSeconds,

        uint256 _deregistrationIntervalSeconds

    ) public initializer {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;



        store = _storeAddress;

        ren = _renAddress;



        minimumBond = _minimumBond;

        nextMinimumBond = minimumBond;



        minimumPodSize = _minimumPodSize;

        nextMinimumPodSize = minimumPodSize;



        minimumEpochInterval = _minimumEpochIntervalSeconds;

        nextMinimumEpochInterval = minimumEpochInterval;

        deregistrationInterval = _deregistrationIntervalSeconds;



        uint256 epochhash = uint256(blockhash(block.number - 1));

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });

        emit LogNewEpoch(epochhash);

    }



    

    

    

    

    

    

    

    

    

    

    function register(address _darknodeID, bytes calldata _publicKey)

        external

        onlyRefunded(_darknodeID)

    {

        require(

            _darknodeID != address(0),

            "DarknodeRegistry: darknode address cannot be zero"

        );



        

        require(

            ren.transferFrom(msg.sender, address(store), minimumBond),

            "DarknodeRegistry: bond transfer failed"

        );



        

        store.appendDarknode(

            _darknodeID,

            msg.sender,

            minimumBond,

            _publicKey,

            currentEpoch.blocktime.add(minimumEpochInterval),

            0

        );



        numDarknodesNextEpoch = numDarknodesNextEpoch.add(1);



        

        emit LogDarknodeRegistered(msg.sender, _darknodeID, minimumBond);

    }



    

    

    

    

    

    

    function deregister(address _darknodeID)

        external

        onlyDeregisterable(_darknodeID)

        onlyDarknodeOperator(_darknodeID)

    {

        deregisterDarknode(_darknodeID);

    }



    

    

    

    function epoch() external {

        if (previousEpoch.blocktime == 0) {

            

            require(

                msg.sender == owner(),

                "DarknodeRegistry: not authorized to call first epoch"

            );

        }



        

        require(

            block.timestamp >= currentEpoch.blocktime.add(minimumEpochInterval),

            "DarknodeRegistry: epoch interval has not passed"

        );

        uint256 epochhash = uint256(blockhash(block.number - 1));



        

        previousEpoch = currentEpoch;

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });



        

        numDarknodesPreviousEpoch = numDarknodes;

        numDarknodes = numDarknodesNextEpoch;



        

        if (nextMinimumBond != minimumBond) {

            minimumBond = nextMinimumBond;

            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);

        }

        if (nextMinimumPodSize != minimumPodSize) {

            minimumPodSize = nextMinimumPodSize;

            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);

        }

        if (nextMinimumEpochInterval != minimumEpochInterval) {

            minimumEpochInterval = nextMinimumEpochInterval;

            emit LogMinimumEpochIntervalUpdated(

                minimumEpochInterval,

                nextMinimumEpochInterval

            );

        }

        if (nextSlasher != slasher) {

            slasher = nextSlasher;

            emit LogSlasherUpdated(address(slasher), address(nextSlasher));

        }

        if (address(darknodePayment) != address(0x0)) {

            darknodePayment.changeCycle();

        }



        

        emit LogNewEpoch(epochhash);

    }



    

    

    

    function transferStoreOwnership(DarknodeRegistryLogicV1 _newOwner)

        external

        onlyOwner

    {

        store.transferOwnership(address(_newOwner));

        _newOwner.claimStoreOwnership();

    }



    

    

    

    function claimStoreOwnership() external {

        store.claimOwnership();



        

        

        (

            numDarknodesPreviousEpoch,

            numDarknodes,

            numDarknodesNextEpoch

        ) = getDarknodeCountFromEpochs();

    }



    

    

    

    

    function updateDarknodePayment(IDarknodePayment _darknodePayment)

        external

        onlyOwner

    {

        require(

            address(_darknodePayment) != address(0x0),

            "DarknodeRegistry: invalid Darknode Payment address"

        );

        IDarknodePayment previousDarknodePayment = darknodePayment;

        darknodePayment = _darknodePayment;

        emit LogDarknodePaymentUpdated(

            previousDarknodePayment,

            darknodePayment

        );

    }



    

    

    

    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {

        

        nextMinimumBond = _nextMinimumBond;

    }



    

    

    function updateMinimumPodSize(uint256 _nextMinimumPodSize)

        external

        onlyOwner

    {

        

        nextMinimumPodSize = _nextMinimumPodSize;

    }



    

    

    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval)

        external

        onlyOwner

    {

        

        nextMinimumEpochInterval = _nextMinimumEpochInterval;

    }



    

    

    

    function updateSlasher(IDarknodeSlasher _slasher) external onlyOwner {

        require(

            address(_slasher) != address(0),

            "DarknodeRegistry: invalid slasher address"

        );

        nextSlasher = _slasher;

    }



    

    

    

    

    

    function slash(address _guilty, address _challenger, uint256 _percentage)

        external

        onlySlasher

        onlyDarknode(_guilty)

    {

        require(_percentage <= 100, "DarknodeRegistry: invalid percent");



        

        if (isDeregisterable(_guilty)) {

            deregisterDarknode(_guilty);

        }



        uint256 totalBond = store.darknodeBond(_guilty);

        uint256 penalty = totalBond.div(100).mul(_percentage);

        uint256 challengerReward = penalty.div(2);

        uint256 darknodePaymentReward = penalty.sub(challengerReward);

        if (challengerReward > 0) {

            

            store.updateDarknodeBond(_guilty, totalBond.sub(penalty));



            

            require(

                address(darknodePayment) != address(0x0),

                "DarknodeRegistry: invalid payment address"

            );

            require(

                ren.transfer(

                    address(darknodePayment.store()),

                    darknodePaymentReward

                ),

                "DarknodeRegistry: reward transfer failed"

            );

            require(

                ren.transfer(_challenger, challengerReward),

                "DarknodeRegistry: reward transfer failed"

            );

        }



        emit LogDarknodeSlashed(

            store.darknodeOperator(_guilty),

            _guilty,

            _challenger,

            _percentage

        );

    }



    

    

    

    

    

    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        uint256 amount = store.darknodeBond(_darknodeID);



        

        store.removeDarknode(_darknodeID);



        

        require(

            ren.transfer(darknodeOperator, amount),

            "DarknodeRegistry: bond transfer failed"

        );



        

        emit LogDarknodeRefunded(darknodeOperator, _darknodeID, amount);

    }



    

    

    function getDarknodeOperator(address _darknodeID)

        external

        view

        returns (address payable)

    {

        return store.darknodeOperator(_darknodeID);

    }



    

    

    function getDarknodeBond(address _darknodeID)

        external

        view

        returns (uint256)

    {

        return store.darknodeBond(_darknodeID);

    }



    

    

    function getDarknodePublicKey(address _darknodeID)

        external

        view

        returns (bytes memory)

    {

        return store.darknodePublicKey(_darknodeID);

    }



    

    

    

    

    

    

    

    

    

    

    function getDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }

        return getDarknodesFromEpochs(_start, count, false);

    }



    

    

    function getPreviousDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodesPreviousEpoch;

        }

        return getDarknodesFromEpochs(_start, count, true);

    }



    

    

    

    function isPendingRegistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        return registeredAt != 0 && registeredAt > currentEpoch.blocktime;

    }



    

    

    function isPendingDeregistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocktime;

    }



    

    function isDeregistered(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocktime;

    }



    

    

    

    function isDeregisterable(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        

        

        return isRegistered(_darknodeID) && deregisteredAt == 0;

    }



    

    

    

    function isRefunded(address _darknodeID) public view returns (bool) {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return registeredAt == 0 && deregisteredAt == 0;

    }



    

    

    function isRefundable(address _darknodeID) public view returns (bool) {

        return

            isDeregistered(_darknodeID) &&

            store.darknodeDeregisteredAt(_darknodeID) <=

            (previousEpoch.blocktime - deregistrationInterval);

    }



    

    function isRegistered(address _darknodeID) public view returns (bool) {

        return isRegisteredInEpoch(_darknodeID, currentEpoch);

    }



    

    function isRegisteredInPreviousEpoch(address _darknodeID)

        public

        view

        returns (bool)

    {

        return isRegisteredInEpoch(_darknodeID, previousEpoch);

    }



    

    

    

    

    function isRegisteredInEpoch(address _darknodeID, Epoch memory _epoch)

        private

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocktime;

        bool notDeregistered = deregisteredAt == 0 ||

            deregisteredAt > _epoch.blocktime;

        

        

        return registered && notDeregistered;

    }



    

    

    

    

    

    function getDarknodesFromEpochs(

        address _start,

        uint256 _count,

        bool _usePreviousEpoch

    ) private view returns (address[] memory) {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }



        address[] memory nodes = new address[](count);



        

        uint256 n = 0;

        address next = _start;

        if (next == address(0)) {

            next = store.begin();

        }



        

        while (n < count) {

            if (next == address(0)) {

                break;

            }

            

            bool includeNext;

            if (_usePreviousEpoch) {

                includeNext = isRegisteredInPreviousEpoch(next);

            } else {

                includeNext = isRegistered(next);

            }

            if (!includeNext) {

                next = store.next(next);

                continue;

            }

            nodes[n] = next;

            next = store.next(next);

            n += 1;

        }

        return nodes;

    }



    

    function deregisterDarknode(address _darknodeID) private {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        store.updateDarknodeDeregisteredAt(

            _darknodeID,

            currentEpoch.blocktime.add(minimumEpochInterval)

        );

        numDarknodesNextEpoch = numDarknodesNextEpoch.sub(1);



        

        emit LogDarknodeDeregistered(darknodeOperator, _darknodeID);

    }



    function getDarknodeCountFromEpochs()

        private

        view

        returns (uint256, uint256, uint256)

    {

        

        uint256 nPreviousEpoch = 0;

        uint256 nCurrentEpoch = 0;

        uint256 nNextEpoch = 0;

        address next = store.begin();



        

        while (true) {

            

            if (next == address(0)) {

                break;

            }



            if (isRegisteredInPreviousEpoch(next)) {

                nPreviousEpoch += 1;

            }



            if (isRegistered(next)) {

                nCurrentEpoch += 1;

            }



            

            

            if (

                ((isRegistered(next) && !isPendingDeregistration(next)) ||

                    isPendingRegistration(next))

            ) {

                nNextEpoch += 1;

            }

            next = store.next(next);

        }

        return (nPreviousEpoch, nCurrentEpoch, nNextEpoch);

    }

}



contract DarknodeRegistryProxy is InitializableAdminUpgradeabilityProxy {}



contract DarknodePaymentStore is Claimable {

    using SafeMath for uint256;

    using SafeERC20 for ERC20;

    using ERC20WithFees for ERC20;



    string public VERSION; 



    

    address public constant ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    

    mapping(address => mapping(address => uint256)) public darknodeBalances;



    

    mapping(address => uint256) public lockedBalances;



    

    

    

    constructor(string memory _VERSION) public {

        Claimable.initialize(msg.sender);

        VERSION = _VERSION;

    }



    

    function() external payable {}



    

    

    

    

    function totalBalance(address _token) public view returns (uint256) {

        if (_token == ETHEREUM) {

            return address(this).balance;

        } else {

            return ERC20(_token).balanceOf(address(this));

        }

    }



    

    

    

    

    

    

    function availableBalance(address _token) public view returns (uint256) {

        return

            totalBalance(_token).sub(

                lockedBalances[_token],

                "DarknodePaymentStore: locked balance exceed total balance"

            );

    }



    

    

    

    

    

    

    function incrementDarknodeBalance(

        address _darknode,

        address _token,

        uint256 _amount

    ) external onlyOwner {

        require(_amount > 0, "DarknodePaymentStore: invalid amount");

        require(

            availableBalance(_token) >= _amount,

            "DarknodePaymentStore: insufficient contract balance"

        );



        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token]

            .add(_amount);

        lockedBalances[_token] = lockedBalances[_token].add(_amount);

    }



    

    

    

    

    

    

    function transfer(

        address _darknode,

        address _token,

        uint256 _amount,

        address payable _recipient

    ) external onlyOwner {

        require(

            darknodeBalances[_darknode][_token] >= _amount,

            "DarknodePaymentStore: insufficient darknode balance"

        );

        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token]

            .sub(

            _amount,

            "DarknodePaymentStore: insufficient darknode balance for transfer"

        );

        lockedBalances[_token] = lockedBalances[_token].sub(

            _amount,

            "DarknodePaymentStore: insufficient token balance for transfer"

        );



        if (_token == ETHEREUM) {

            _recipient.transfer(_amount);

        } else {

            ERC20(_token).safeTransfer(_recipient, _amount);

        }

    }



}



contract DarknodePayment is Claimable {

    using SafeMath for uint256;

    using SafeERC20 for ERC20;

    using ERC20WithFees for ERC20;



    string public VERSION; 



    

    address public constant ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    DarknodeRegistryLogicV1 public darknodeRegistry; 



    

    

    DarknodePaymentStore public store; 



    

    

    address public cycleChanger;



    uint256 public currentCycle;

    uint256 public previousCycle;



    

    

    

    address[] public pendingTokens;



    

    

    address[] public registeredTokens;



    

    

    mapping(address => uint256) public registeredTokenIndex;



    

    

    

    mapping(address => uint256) public unclaimedRewards;



    

    

    mapping(address => uint256) public previousCycleRewardShare;



    

    uint256 public cycleStartTime;



    

    uint256 public nextCyclePayoutPercent;



    

    uint256 public currentCyclePayoutPercent;



    

    

    

    mapping(address => mapping(uint256 => bool)) public rewardClaimed;



    

    

    

    event LogDarknodeClaim(address indexed _darknode, uint256 _cycle);



    

    

    

    

    event LogPaymentReceived(

        address indexed _payer,

        address indexed _token,

        uint256 _amount

    );



    

    

    

    

    

    event LogDarknodeWithdrew(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        address indexed _token,

        uint256 _value

    );



    

    

    

    event LogPayoutPercentChanged(uint256 _newPercent, uint256 _oldPercent);



    

    

    

    event LogCycleChangerChanged(

        address indexed _newCycleChanger,

        address indexed _oldCycleChanger

    );



    

    

    event LogTokenRegistered(address indexed _token);



    

    

    event LogTokenDeregistered(address indexed _token);



    

    

    

    event LogDarknodeRegistryUpdated(

        DarknodeRegistryLogicV1 indexed _previousDarknodeRegistry,

        DarknodeRegistryLogicV1 indexed _nextDarknodeRegistry

    );



    

    modifier onlyDarknode(address _darknode) {

        require(

            darknodeRegistry.isRegistered(_darknode),

            "DarknodePayment: darknode is not registered"

        );

        _;

    }



    

    modifier validPercent(uint256 _percent) {

        require(_percent <= 100, "DarknodePayment: invalid percentage");

        _;

    }



    

    modifier onlyCycleChanger {

        require(

            msg.sender == cycleChanger,

            "DarknodePayment: not cycle changer"

        );

        _;

    }



    

    

    

    

    

    

    

    constructor(

        string memory _VERSION,

        DarknodeRegistryLogicV1 _darknodeRegistry,

        DarknodePaymentStore _darknodePaymentStore,

        uint256 _cyclePayoutPercent

    ) public validPercent(_cyclePayoutPercent) {

        Claimable.initialize(msg.sender);

        VERSION = _VERSION;

        darknodeRegistry = _darknodeRegistry;

        store = _darknodePaymentStore;

        nextCyclePayoutPercent = _cyclePayoutPercent;

        

        cycleChanger = msg.sender;



        

        (currentCycle, cycleStartTime) = darknodeRegistry.currentEpoch();

        currentCyclePayoutPercent = nextCyclePayoutPercent;

    }



    

    

    

    

    function updateDarknodeRegistry(DarknodeRegistryLogicV1 _darknodeRegistry)

        external

        onlyOwner

    {

        require(

            address(_darknodeRegistry) != address(0x0),

            "DarknodePayment: invalid Darknode Registry address"

        );

        DarknodeRegistryLogicV1 previousDarknodeRegistry = darknodeRegistry;

        darknodeRegistry = _darknodeRegistry;

        emit LogDarknodeRegistryUpdated(

            previousDarknodeRegistry,

            darknodeRegistry

        );

    }



    

    

    

    

    

    function withdraw(address _darknode, address _token) public {

        address payable darknodeOperator = darknodeRegistry.getDarknodeOperator(

            _darknode

        );

        require(

            darknodeOperator != address(0x0),

            "DarknodePayment: invalid darknode owner"

        );



        uint256 amount = store.darknodeBalances(_darknode, _token);



        

        if (amount > 0) {

            store.transfer(_darknode, _token, amount, darknodeOperator);

            emit LogDarknodeWithdrew(

                darknodeOperator,

                _darknode,

                _token,

                amount

            );

        }

    }



    function withdrawMultiple(

        address[] calldata _darknodes,

        address[] calldata _tokens

    ) external {

        for (uint256 i = 0; i < _darknodes.length; i++) {

            for (uint256 j = 0; j < _tokens.length; j++) {

                withdraw(_darknodes[i], _tokens[j]);

            }

        }

    }



    

    function() external payable {

        address(store).transfer(msg.value);

        emit LogPaymentReceived(msg.sender, ETHEREUM, msg.value);

    }



    

    

    function currentCycleRewardPool(address _token)

        external

        view

        returns (uint256)

    {

        uint256 total = store.availableBalance(_token).sub(

            unclaimedRewards[_token],

            "DarknodePayment: unclaimed rewards exceed total rewards"

        );

        return total.div(100).mul(currentCyclePayoutPercent);

    }



    function darknodeBalances(address _darknodeID, address _token)

        external

        view

        returns (uint256)

    {

        return store.darknodeBalances(_darknodeID, _token);

    }



    

    function changeCycle() external onlyCycleChanger returns (uint256) {

        

        uint256 arrayLength = registeredTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            _snapshotBalance(registeredTokens[i]);

        }



        

        previousCycle = currentCycle;

        (currentCycle, cycleStartTime) = darknodeRegistry.currentEpoch();

        currentCyclePayoutPercent = nextCyclePayoutPercent;



        

        _updateTokenList();

        return currentCycle;

    }



    

    

    

    

    function deposit(uint256 _value, address _token) external payable {

        uint256 receivedValue;

        if (_token == ETHEREUM) {

            require(

                _value == msg.value,

                "DarknodePayment: mismatched deposit value"

            );

            receivedValue = msg.value;

            address(store).transfer(msg.value);

        } else {

            require(

                msg.value == 0,

                "DarknodePayment: unexpected ether transfer"

            );

            require(

                registeredTokenIndex[_token] != 0,

                "DarknodePayment: token not registered"

            );

            

            receivedValue = ERC20(_token).safeTransferFromWithFees(

                msg.sender,

                address(store),

                _value

            );

        }

        emit LogPaymentReceived(msg.sender, _token, receivedValue);

    }



    

    

    

    

    function forward(address _token) external {

        if (_token == ETHEREUM) {

            

            

            

            

            address(store).transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                address(store),

                ERC20(_token).balanceOf(address(this))

            );

        }

    }



    

    

    function claim(address _darknode) external onlyDarknode(_darknode) {

        require(

            darknodeRegistry.isRegisteredInPreviousEpoch(_darknode),

            "DarknodePayment: cannot claim for this epoch"

        );

        

        _claimDarknodeReward(_darknode);

        emit LogDarknodeClaim(_darknode, previousCycle);

    }



    

    

    

    

    function registerToken(address _token) external onlyOwner {

        require(

            registeredTokenIndex[_token] == 0,

            "DarknodePayment: token already registered"

        );

        require(

            !tokenPendingRegistration(_token),

            "DarknodePayment: token already pending registration"

        );

        pendingTokens.push(_token);

    }



    function tokenPendingRegistration(address _token)

        public

        view

        returns (bool)

    {

        uint256 arrayLength = pendingTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            if (pendingTokens[i] == _token) {

                return true;

            }

        }

        return false;

    }



    

    

    

    

    function deregisterToken(address _token) external onlyOwner {

        require(

            registeredTokenIndex[_token] > 0,

            "DarknodePayment: token not registered"

        );

        _deregisterToken(_token);

    }



    

    

    

    function updateCycleChanger(address _addr) external onlyOwner {

        require(

            _addr != address(0),

            "DarknodePayment: invalid contract address"

        );

        emit LogCycleChangerChanged(_addr, cycleChanger);

        cycleChanger = _addr;

    }



    

    

    

    function updatePayoutPercentage(uint256 _percent)

        external

        onlyOwner

        validPercent(_percent)

    {

        uint256 oldPayoutPercent = nextCyclePayoutPercent;

        nextCyclePayoutPercent = _percent;

        emit LogPayoutPercentChanged(nextCyclePayoutPercent, oldPayoutPercent);

    }



    

    

    

    

    function transferStoreOwnership(DarknodePayment _newOwner)

        external

        onlyOwner

    {

        store.transferOwnership(address(_newOwner));

        _newOwner.claimStoreOwnership();

    }



    

    

    

    function claimStoreOwnership() external {

        store.claimOwnership();

    }



    

    

    

    

    

    function _claimDarknodeReward(address _darknode) private {

        require(

            !rewardClaimed[_darknode][previousCycle],

            "DarknodePayment: reward already claimed"

        );

        rewardClaimed[_darknode][previousCycle] = true;

        uint256 arrayLength = registeredTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            address token = registeredTokens[i];



            

            if (previousCycleRewardShare[token] > 0) {

                unclaimedRewards[token] = unclaimedRewards[token].sub(

                    previousCycleRewardShare[token],

                    "DarknodePayment: share exceeds unclaimed rewards"

                );

                store.incrementDarknodeBalance(

                    _darknode,

                    token,

                    previousCycleRewardShare[token]

                );

            }

        }

    }



    

    

    

    

    function _snapshotBalance(address _token) private {

        uint256 shareCount = darknodeRegistry.numDarknodesPreviousEpoch();

        if (shareCount == 0) {

            unclaimedRewards[_token] = 0;

            previousCycleRewardShare[_token] = 0;

        } else {

            

            uint256 total = store.availableBalance(_token);

            unclaimedRewards[_token] = total.div(100).mul(

                currentCyclePayoutPercent

            );

            previousCycleRewardShare[_token] = unclaimedRewards[_token].div(

                shareCount

            );

        }

    }



    

    

    

    

    function _deregisterToken(address _token) private {

        address lastToken = registeredTokens[registeredTokens.length.sub(

            1,

            "DarknodePayment: no tokens registered"

        )];

        uint256 deletedTokenIndex = registeredTokenIndex[_token].sub(1);

        

        registeredTokens[deletedTokenIndex] = lastToken;

        registeredTokenIndex[lastToken] = registeredTokenIndex[_token];

        

        

        registeredTokens.pop();

        registeredTokenIndex[_token] = 0;



        emit LogTokenDeregistered(_token);

    }



    

    

    function _updateTokenList() private {

        

        uint256 arrayLength = pendingTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            address token = pendingTokens[i];

            registeredTokens.push(token);

            registeredTokenIndex[token] = registeredTokens.length;

            emit LogTokenRegistered(token);

        }

        pendingTokens.length = 0;

    }



}



library ECDSA {

    

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        

        if (signature.length != 65) {

            revert("ECDSA: signature length is invalid");

        }



        

        bytes32 r;

        bytes32 s;

        uint8 v;



        

        

        

        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := byte(0, mload(add(signature, 0x60)))

        }



        

        

        

        

        

        

        

        

        

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            revert("ECDSA: signature.s is in the wrong range");

        }



        if (v != 27 && v != 28) {

            revert("ECDSA: signature.v is in the wrong range");

        }



        

        return ecrecover(hash, v, r, s);

    }



    

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        

        

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }

}



library String {

    

    

    function fromUint(uint256 _i) internal pure returns (string memory) {

        if (_i == 0) {

            return "0";

        }

        uint256 j = _i;

        uint256 len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint256 k = len - 1;

        while (_i != 0) {

            bstr[k--] = bytes1(uint8(48 + (_i % 10)));

            _i /= 10;

        }

        return string(bstr);

    }



    

    function fromBytes32(bytes32 _value) internal pure returns (string memory) {

        bytes memory alphabet = "0123456789abcdef";



        bytes memory str = new bytes(32 * 2 + 2);

        str[0] = "0";

        str[1] = "x";

        for (uint256 i = 0; i < 32; i++) {

            str[2 + i * 2] = alphabet[uint256(uint8(_value[i] >> 4))];

            str[3 + i * 2] = alphabet[uint256(uint8(_value[i] & 0x0f))];

        }

        return string(str);

    }



    

    function fromAddress(address _addr) internal pure returns (string memory) {

        bytes32 value = bytes32(uint256(_addr));

        bytes memory alphabet = "0123456789abcdef";



        bytes memory str = new bytes(20 * 2 + 2);

        str[0] = "0";

        str[1] = "x";

        for (uint256 i = 0; i < 20; i++) {

            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];

            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];

        }

        return string(str);

    }



    

    function add8(

        string memory a,

        string memory b,

        string memory c,

        string memory d,

        string memory e,

        string memory f,

        string memory g,

        string memory h

    ) internal pure returns (string memory) {

        return string(abi.encodePacked(a, b, c, d, e, f, g, h));

    }

}



library Compare {



    function bytesEqual(bytes memory a, bytes memory b) internal pure returns (bool) {

        if (a.length != b.length) {

            return false;

        }

        for (uint i = 0; i < a.length; i ++) {

            if (a[i] != b[i]) {

                return false;

            }

        }

        return true;

    }

}



library Validate {

    

    

    

    

    

    function duplicatePropose(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash1,

        uint256 _validRound1,

        bytes memory _signature1,

        bytes memory _blockhash2,

        uint256 _validRound2,

        bytes memory _signature2

    ) internal pure returns (address) {

        require(

            !Compare.bytesEqual(_signature1, _signature2),

            "Validate: same signature"

        );

        address signer1 = recoverPropose(

            _height,

            _round,

            _blockhash1,

            _validRound1,

            _signature1

        );

        address signer2 = recoverPropose(

            _height,

            _round,

            _blockhash2,

            _validRound2,

            _signature2

        );

        require(signer1 == signer2, "Validate: different signer");

        return signer1;

    }



    function recoverPropose(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash,

        uint256 _validRound,

        bytes memory _signature

    ) internal pure returns (address) {

        return

            ECDSA.recover(

                sha256(

                    proposeMessage(_height, _round, _blockhash, _validRound)

                ),

                _signature

            );

    }



    function proposeMessage(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash,

        uint256 _validRound

    ) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                "Propose(Height=",

                String.fromUint(_height),

                ",Round=",

                String.fromUint(_round),

                ",BlockHash=",

                string(_blockhash),

                ",ValidRound=",

                String.fromUint(_validRound),

                ")"

            );

    }



    

    

    

    

    

    function duplicatePrevote(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash1,

        bytes memory _signature1,

        bytes memory _blockhash2,

        bytes memory _signature2

    ) internal pure returns (address) {

        require(

            !Compare.bytesEqual(_signature1, _signature2),

            "Validate: same signature"

        );

        address signer1 = recoverPrevote(

            _height,

            _round,

            _blockhash1,

            _signature1

        );

        address signer2 = recoverPrevote(

            _height,

            _round,

            _blockhash2,

            _signature2

        );

        require(signer1 == signer2, "Validate: different signer");

        return signer1;

    }



    function recoverPrevote(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash,

        bytes memory _signature

    ) internal pure returns (address) {

        return

            ECDSA.recover(

                sha256(prevoteMessage(_height, _round, _blockhash)),

                _signature

            );

    }



    function prevoteMessage(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash

    ) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                "Prevote(Height=",

                String.fromUint(_height),

                ",Round=",

                String.fromUint(_round),

                ",BlockHash=",

                string(_blockhash),

                ")"

            );

    }



    

    

    

    

    

    function duplicatePrecommit(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash1,

        bytes memory _signature1,

        bytes memory _blockhash2,

        bytes memory _signature2

    ) internal pure returns (address) {

        require(

            !Compare.bytesEqual(_signature1, _signature2),

            "Validate: same signature"

        );

        address signer1 = recoverPrecommit(

            _height,

            _round,

            _blockhash1,

            _signature1

        );

        address signer2 = recoverPrecommit(

            _height,

            _round,

            _blockhash2,

            _signature2

        );

        require(signer1 == signer2, "Validate: different signer");

        return signer1;

    }



    function recoverPrecommit(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash,

        bytes memory _signature

    ) internal pure returns (address) {

        return

            ECDSA.recover(

                sha256(precommitMessage(_height, _round, _blockhash)),

                _signature

            );

    }



    function precommitMessage(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash

    ) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                "Precommit(Height=",

                String.fromUint(_height),

                ",Round=",

                String.fromUint(_round),

                ",BlockHash=",

                string(_blockhash),

                ")"

            );

    }



    function recoverSecret(

        uint256 _a,

        uint256 _b,

        uint256 _c,

        uint256 _d,

        uint256 _e,

        uint256 _f,

        bytes memory _signature

    ) internal pure returns (address) {

        return

            ECDSA.recover(

                sha256(secretMessage(_a, _b, _c, _d, _e, _f)),

                _signature

            );

    }



    function secretMessage(

        uint256 _a,

        uint256 _b,

        uint256 _c,

        uint256 _d,

        uint256 _e,

        uint256 _f

    ) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                "Secret(",

                "ShamirShare(",

                String.fromUint(_a),

                ",",

                String.fromUint(_b),

                ",S256N(",

                String.fromUint(_c),

                "),",

                "S256PrivKey(",

                "S256N(",

                String.fromUint(_d),

                "),",

                "S256P(",

                String.fromUint(_e),

                "),",

                "S256P(",

                String.fromUint(_f),

                ")",

                ")",

                ")",

                ")"

            );

    }

}



contract DarknodeSlasher is Claimable {

    DarknodeRegistryLogicV1 public darknodeRegistry;



    uint256 public blacklistSlashPercent;

    uint256 public maliciousSlashPercent;

    uint256 public secretRevealSlashPercent;



    

    

    mapping(uint256 => mapping(uint256 => mapping(address => bool))) public slashed;



    

    mapping(address => bool) public secretRevealed;



    

    mapping(address => bool) public blacklisted;



    

    

    

    event LogDarknodeRegistryUpdated(

        DarknodeRegistryLogicV1 indexed _previousDarknodeRegistry,

        DarknodeRegistryLogicV1 indexed _nextDarknodeRegistry

    );



    

    modifier validPercent(uint256 _percent) {

        require(_percent <= 100, "DarknodeSlasher: invalid percentage");

        _;

    }



    constructor(DarknodeRegistryLogicV1 _darknodeRegistry) public {

        Claimable.initialize(msg.sender);

        darknodeRegistry = _darknodeRegistry;

    }



    

    

    

    

    function updateDarknodeRegistry(DarknodeRegistryLogicV1 _darknodeRegistry)

        external

        onlyOwner

    {

        require(

            address(_darknodeRegistry) != address(0x0),

            "DarknodeSlasher: invalid Darknode Registry address"

        );

        DarknodeRegistryLogicV1 previousDarknodeRegistry = darknodeRegistry;

        darknodeRegistry = _darknodeRegistry;

        emit LogDarknodeRegistryUpdated(

            previousDarknodeRegistry,

            darknodeRegistry

        );

    }



    function setBlacklistSlashPercent(uint256 _percentage)

        public

        validPercent(_percentage)

        onlyOwner

    {

        blacklistSlashPercent = _percentage;

    }



    function setMaliciousSlashPercent(uint256 _percentage)

        public

        validPercent(_percentage)

        onlyOwner

    {

        maliciousSlashPercent = _percentage;

    }



    function setSecretRevealSlashPercent(uint256 _percentage)

        public

        validPercent(_percentage)

        onlyOwner

    {

        secretRevealSlashPercent = _percentage;

    }



    function slash(address _guilty, address _challenger, uint256 _percentage)

        external

        onlyOwner

    {

        darknodeRegistry.slash(_guilty, _challenger, _percentage);

    }



    function blacklist(address _guilty) external onlyOwner {

        require(!blacklisted[_guilty], "DarknodeSlasher: already blacklisted");

        blacklisted[_guilty] = true;

        darknodeRegistry.slash(_guilty, owner(), blacklistSlashPercent);

    }



    function slashDuplicatePropose(

        uint256 _height,

        uint256 _round,

        bytes calldata _blockhash1,

        uint256 _validRound1,

        bytes calldata _signature1,

        bytes calldata _blockhash2,

        uint256 _validRound2,

        bytes calldata _signature2

    ) external {

        address signer = Validate.duplicatePropose(

            _height,

            _round,

            _blockhash1,

            _validRound1,

            _signature1,

            _blockhash2,

            _validRound2,

            _signature2

        );

        require(

            !slashed[_height][_round][signer],

            "DarknodeSlasher: already slashed"

        );

        slashed[_height][_round][signer] = true;

        darknodeRegistry.slash(signer, msg.sender, maliciousSlashPercent);

    }



    function slashDuplicatePrevote(

        uint256 _height,

        uint256 _round,

        bytes calldata _blockhash1,

        bytes calldata _signature1,

        bytes calldata _blockhash2,

        bytes calldata _signature2

    ) external {

        address signer = Validate.duplicatePrevote(

            _height,

            _round,

            _blockhash1,

            _signature1,

            _blockhash2,

            _signature2

        );

        require(

            !slashed[_height][_round][signer],

            "DarknodeSlasher: already slashed"

        );

        slashed[_height][_round][signer] = true;

        darknodeRegistry.slash(signer, msg.sender, maliciousSlashPercent);

    }



    function slashDuplicatePrecommit(

        uint256 _height,

        uint256 _round,

        bytes calldata _blockhash1,

        bytes calldata _signature1,

        bytes calldata _blockhash2,

        bytes calldata _signature2

    ) external {

        address signer = Validate.duplicatePrecommit(

            _height,

            _round,

            _blockhash1,

            _signature1,

            _blockhash2,

            _signature2

        );

        require(

            !slashed[_height][_round][signer],

            "DarknodeSlasher: already slashed"

        );

        slashed[_height][_round][signer] = true;

        darknodeRegistry.slash(signer, msg.sender, maliciousSlashPercent);

    }



    function slashSecretReveal(

        uint256 _a,

        uint256 _b,

        uint256 _c,

        uint256 _d,

        uint256 _e,

        uint256 _f,

        bytes calldata _signature

    ) external {

        address signer = Validate.recoverSecret(

            _a,

            _b,

            _c,

            _d,

            _e,

            _f,

            _signature

        );

        require(!secretRevealed[signer], "DarknodeSlasher: already slashed");

        secretRevealed[signer] = true;

        darknodeRegistry.slash(signer, msg.sender, secretRevealSlashPercent);

    }

}



contract ERC20WithRate is Initializable, Ownable, ERC20 {

    using SafeMath for uint256;



    uint256 public constant _rateScale = 1e18;

    uint256 internal _rate;



    event LogRateChanged(uint256 indexed _rate);



    

    function initialize(address _nextOwner, uint256 _initialRate)

        public

        initializer

    {

        Ownable.initialize(_nextOwner);

        _setRate(_initialRate);

    }



    function setExchangeRate(uint256 _nextRate) public onlyOwner {

        _setRate(_nextRate);

    }



    function exchangeRateCurrent() public view returns (uint256) {

        require(_rate != 0, "ERC20WithRate: rate has not been initialized");

        return _rate;

    }



    function _setRate(uint256 _nextRate) internal {

        require(_nextRate > 0, "ERC20WithRate: rate must be greater than zero");

        _rate = _nextRate;

    }



    function balanceOfUnderlying(address _account)

        public

        view

        returns (uint256)

    {

        return toUnderlying(balanceOf(_account));

    }



    function toUnderlying(uint256 _amount) public view returns (uint256) {

        return _amount.mul(_rate).div(_rateScale);

    }



    function fromUnderlying(uint256 _amountUnderlying)

        public

        view

        returns (uint256)

    {

        return _amountUnderlying.mul(_rateScale).div(_rate);

    }

}



contract ERC20WithPermit is Initializable, ERC20, ERC20Detailed {

    using SafeMath for uint256;



    mapping(address => uint256) public nonces;



    

    

    string public version;



    

    bytes32 public DOMAIN_SEPARATOR;

    

    

    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;



    function initialize(

        uint256 _chainId,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        version = _version;

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256(

                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"

                ),

                keccak256(bytes(name())),

                keccak256(bytes(version)),

                _chainId,

                address(this)

            )

        );

    }



    

    function permit(

        address holder,

        address spender,

        uint256 nonce,

        uint256 expiry,

        bool allowed,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external {

        bytes32 digest = keccak256(

            abi.encodePacked(

                "\x19\x01",

                DOMAIN_SEPARATOR,

                keccak256(

                    abi.encode(

                        PERMIT_TYPEHASH,

                        holder,

                        spender,

                        nonce,

                        expiry,

                        allowed

                    )

                )

            )

        );



        require(holder != address(0), "ERC20WithRate: address must not be 0x0");

        require(

            holder == ecrecover(digest, v, r, s),

            "ERC20WithRate: invalid signature"

        );

        require(

            expiry == 0 || now <= expiry,

            "ERC20WithRate: permit has expired"

        );

        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");

        uint256 amount = allowed ? uint256(-1) : 0;

        _approve(holder, spender, amount);

    }

}



contract RenERC20LogicV1 is

    Initializable,

    ERC20,

    ERC20Detailed,

    ERC20WithRate,

    ERC20WithPermit,

    Claimable,

    CanReclaimTokens

{

    

    function initialize(

        uint256 _chainId,

        address _nextOwner,

        uint256 _initialRate,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        ERC20WithRate.initialize(_nextOwner, _initialRate);

        ERC20WithPermit.initialize(

            _chainId,

            _version,

            _name,

            _symbol,

            _decimals

        );

        Claimable.initialize(_nextOwner);

        CanReclaimTokens.initialize(_nextOwner);

    }



    

    

    function mint(address _to, uint256 _amount) public onlyOwner {

        _mint(_to, _amount);

    }



    

    

    function burn(address _from, uint256 _amount) public onlyOwner {

        _burn(_from, _amount);

    }



    function transfer(address recipient, uint256 amount) public returns (bool) {

        

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transfer(recipient, amount);

    }



    function transferFrom(address sender, address recipient, uint256 amount)

        public

        returns (bool)

    {

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transferFrom(sender, recipient, amount);

    }

}



contract RenBTC is InitializableAdminUpgradeabilityProxy {}



contract RenZEC is InitializableAdminUpgradeabilityProxy {}



contract RenBCH is InitializableAdminUpgradeabilityProxy {}



interface IMintGateway {

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);

    function mintFee() external view returns (uint256);

}



interface IBurnGateway {

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);

    function burnFee() external view returns (uint256);

}



interface IGateway {

    

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);

    function mintFee() external view returns (uint256);

    

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);

    function burnFee() external view returns (uint256);

}



contract GatewayRegistry is Claimable, CanReclaimTokens {

    constructor() public {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

    }



    

    

    event LogGatewayRegistered(

        string _symbol,

        string indexed _indexedSymbol,

        address indexed _token,

        address indexed _gatewayContract

    );

    event LogGatewayDeregistered(

        string _symbol,

        string indexed _indexedSymbol,

        address indexed _token,

        address indexed _gatewayContract

    );

    event LogGatewayUpdated(

        address indexed _token,

        address indexed _currentGatewayContract,

        address indexed _newGatewayContract

    );



    

    uint256 numGatewayContracts = 0;



    

    LinkedList.List private gatewayContractList;



    

    LinkedList.List private renTokenList;



    

    mapping(address => address) private gatewayByToken;



    

    mapping(string => address) private tokenBySymbol;



    

    

    

    

    

    function setGateway(string calldata _symbol, address _token, address _gatewayContract)

        external

        onlyOwner

    {

        require(symbolIsValid(_symbol), "GatewayRegistry: symbol must be alphanumeric");



        

        require(

            !LinkedList.isInList(gatewayContractList, _gatewayContract),

            "GatewayRegistry: gateway already registered"

        );

        require(

            gatewayByToken[_token] == address(0x0),

            "GatewayRegistry: token already registered"

        );

        require(

            tokenBySymbol[_symbol] == address(0x0),

            "GatewayRegistry: symbol already registered"

        );



        

        LinkedList.append(gatewayContractList, _gatewayContract);



        

        LinkedList.append(renTokenList, _token);



        tokenBySymbol[_symbol] = _token;

        gatewayByToken[_token] = _gatewayContract;

        numGatewayContracts += 1;



        emit LogGatewayRegistered(_symbol, _symbol, _token, _gatewayContract);

    }



    

    

    

    

    

    function updateGateway(address _token, address _newGatewayContract)

        external

        onlyOwner

    {

        

        address currentGateway = gatewayByToken[_token];

        require(

            currentGateway != address(0x0),

            "GatewayRegistry: token not registered"

        );



        

        LinkedList.remove(gatewayContractList, currentGateway);



        

        LinkedList.append(gatewayContractList, _newGatewayContract);



        gatewayByToken[_token] = _newGatewayContract;



        emit LogGatewayUpdated(_token, currentGateway, _newGatewayContract);

    }



    

    

    

    

    function removeGateway(string calldata _symbol) external onlyOwner {

        

        address tokenAddress = tokenBySymbol[_symbol];

        require(

            tokenAddress != address(0x0),

            "GatewayRegistry: symbol not registered"

        );



        

        address gatewayAddress = gatewayByToken[tokenAddress];



        

        delete gatewayByToken[tokenAddress];

        delete tokenBySymbol[_symbol];

        LinkedList.remove(gatewayContractList, gatewayAddress);

        LinkedList.remove(renTokenList, tokenAddress);

        numGatewayContracts -= 1;



        emit LogGatewayDeregistered(

            _symbol,

            _symbol,

            tokenAddress,

            gatewayAddress

        );

    }



    

    function getGateways(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        return

            LinkedList.elements(

                gatewayContractList,

                _start,

                _count == 0 ? numGatewayContracts : _count

            );

    }



    

    function getRenTokens(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        return

            LinkedList.elements(

                renTokenList,

                _start,

                _count == 0 ? numGatewayContracts : _count

            );

    }



    

    

    

    

    function getGatewayByToken(address _token)

        external

        view

        returns (IGateway)

    {

        return IGateway(gatewayByToken[_token]);

    }



    

    

    

    

    function getGatewayBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IGateway)

    {

        return IGateway(gatewayByToken[tokenBySymbol[_tokenSymbol]]);

    }



    

    

    

    

    function getTokenBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IERC20)

    {

        return IERC20(tokenBySymbol[_tokenSymbol]);

    }



    function symbolIsValid(string memory _tokenSymbol) public pure returns (bool) {

        for (uint i = 0; i < bytes(_tokenSymbol).length; i++) {

            uint8 char = uint8(bytes(_tokenSymbol)[i]);

            if (!(

                (char >= 65 && char <= 90) ||

                (char >= 97 && char <= 122) ||

                (char >= 48 && char <= 57)

            )) {

                return false;

            }

        }

        return true;

    }

}



interface IGatewayRegistry {

    

    

    event LogGatewayRegistered(

        string _symbol,

        string indexed _indexedSymbol,

        address indexed _tokenAddress,

        address indexed _gatewayAddress

    );

    event LogGatewayDeregistered(

        string _symbol,

        string indexed _indexedSymbol,

        address indexed _tokenAddress,

        address indexed _gatewayAddress

    );

    event LogGatewayUpdated(

        address indexed _tokenAddress,

        address indexed _currentGatewayAddress,

        address indexed _newGatewayAddress

    );



    

    function getGateways(address _start, uint256 _count)

        external

        view

        returns (address[] memory);



    

    function getRenTokens(address _start, uint256 _count)

        external

        view

        returns (address[] memory);



    

    

    

    

    function getGatewayByToken(address _tokenAddress)

        external

        view

        returns (IGateway);



    

    

    

    

    function getGatewayBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IGateway);



    

    

    

    

    function getTokenBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IERC20);

}



contract ProtocolStateV1 {

    



    

    



    

    

    DarknodeRegistryLogicV1 internal _darknodeRegistry;



    

    GatewayRegistry internal _gatewayRegistry;

}



contract ProtocolLogicV1 is

    Initializable,

    Claimable,

    ProtocolStateV1,

    IGatewayRegistry

{

    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    



    function darknodeRegistry() public view returns (DarknodeRegistryLogicV1) {

        return ProtocolStateV1._darknodeRegistry;

    }



    function darknodeRegistryStore()

        public

        view

        returns (DarknodeRegistryStore)

    {

        return darknodeRegistry().store();

    }



    function renToken() public view returns (RenToken) {

        return darknodeRegistry().ren();

    }



    function darknodePayment() public view returns (DarknodePayment) {

        return

            DarknodePayment(

                _payableAddress(address(darknodeRegistry().darknodePayment()))

            );

    }



    function darknodePaymentStore() public view returns (DarknodePaymentStore) {

        return darknodePayment().store();

    }



    function darknodeSlasher() public view returns (DarknodeSlasher) {

        return

            DarknodeSlasher(

                _payableAddress(address(darknodeRegistry().slasher()))

            );

    }



    



    function gatewayRegistry() public view returns (GatewayRegistry) {

        return ProtocolStateV1._gatewayRegistry;

    }



    function getGateways(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        return gatewayRegistry().getGateways(_start, _count);

    }



    function getRenTokens(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        return gatewayRegistry().getRenTokens(_start, _count);

    }



    function getGatewayByToken(address _tokenAddress)

        external

        view

        returns (IGateway)

    {

        return gatewayRegistry().getGatewayByToken(_tokenAddress);

    }



    function getGatewayBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IGateway)

    {

        return gatewayRegistry().getGatewayBySymbol(_tokenSymbol);

    }



    function getTokenBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IERC20)

    {

        return gatewayRegistry().getTokenBySymbol(_tokenSymbol);

    }



    



    

    

    

    function _updateDarknodeRegistry(

        DarknodeRegistryLogicV1 _newDarknodeRegistry

    ) public onlyOwner {

        ProtocolStateV1._darknodeRegistry = _newDarknodeRegistry;

    }



    

    

    function _updateGatewayRegistry(GatewayRegistry _newGatewayRegistry)

        public

        onlyOwner

    {

        ProtocolStateV1._gatewayRegistry = _newGatewayRegistry;

    }



    



    

    function _payableAddress(address a)

        internal

        pure

        returns (address payable)

    {

        return address(uint160(address(a)));

    }

}



contract ProtocolProxy is InitializableAdminUpgradeabilityProxy {}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ProtocolProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-03-25

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 9068f80

Repository: https://github.com/renproject/darknode-sol

Issues: https://github.com/renproject/darknode-sol/issues



Licenses

@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE



*/



pragma solidity 0.5.16;





contract Proxy {

  

  function () payable external {

    _fallback();

  }



  

  function _implementation() internal view returns (address);



  

  function _delegate(address implementation) internal {

    assembly {

      

      

      

      calldatacopy(0, 0, calldatasize)



      

      

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      

      returndatacopy(0, 0, returndatasize)



      switch result

      

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  

  function _willFallback() internal {

  }



  

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



library OpenZeppelinUpgradesAddress {

    

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        

        

        

        

        

        

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



contract BaseUpgradeabilityProxy is Proxy {

  

  event Upgraded(address indexed implementation);



  

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



  

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  

  function _setImplementation(address newImplementation) internal {

    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  constructor(address _logic, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  event AdminChanged(address previousAdmin, address newAdmin);



  



  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



  

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  

  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    (bool success,) = newImplementation.delegatecall(data);

    require(success);

  }



  

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  function initialize(address _logic, bytes memory _data) public payable {

    require(_implementation() == address(0));

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {

  

  function initialize(address _logic, address _admin, bytes memory _data) public payable {

    require(_implementation() == address(0));

    InitializableUpgradeabilityProxy.initialize(_logic, _data);

    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));

    _setAdmin(_admin);

  }

}



contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



library Math {

    

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        

        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

    }

}



library ERC20WithFees {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    

    

    function safeTransferFromWithFees(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal returns (uint256) {

        uint256 balancesBefore = token.balanceOf(to);

        token.safeTransferFrom(from, to, value);

        uint256 balancesAfter = token.balanceOf(to);

        return Math.min(value, balancesAfter.sub(balancesBefore));

    }

}



contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}



library Roles {

    struct Role {

        mapping (address => bool) bearer;

    }



    

    function add(Role storage role, address account) internal {

        require(!has(role, account), "Roles: account already has role");

        role.bearer[account] = true;

    }



    

    function remove(Role storage role, address account) internal {

        require(has(role, account), "Roles: account does not have role");

        role.bearer[account] = false;

    }



    

    function has(Role storage role, address account) internal view returns (bool) {

        require(account != address(0), "Roles: account is the zero address");

        return role.bearer[account];

    }

}



contract PauserRole is Initializable, Context {

    using Roles for Roles.Role;



    event PauserAdded(address indexed account);

    event PauserRemoved(address indexed account);



    Roles.Role private _pausers;



    function initialize(address sender) public initializer {

        if (!isPauser(sender)) {

            _addPauser(sender);

        }

    }



    modifier onlyPauser() {

        require(isPauser(_msgSender()), "PauserRole: caller does not have the Pauser role");

        _;

    }



    function isPauser(address account) public view returns (bool) {

        return _pausers.has(account);

    }



    function addPauser(address account) public onlyPauser {

        _addPauser(account);

    }



    function renouncePauser() public {

        _removePauser(_msgSender());

    }



    function _addPauser(address account) internal {

        _pausers.add(account);

        emit PauserAdded(account);

    }



    function _removePauser(address account) internal {

        _pausers.remove(account);

        emit PauserRemoved(account);

    }



    uint256[50] private ______gap;

}



contract Pausable is Initializable, Context, PauserRole {

    

    event Paused(address account);



    

    event Unpaused(address account);



    bool private _paused;



    

    function initialize(address sender) public initializer {

        PauserRole.initialize(sender);



        _paused = false;

    }



    

    function paused() public view returns (bool) {

        return _paused;

    }



    

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    

    function pause() public onlyPauser whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    

    function unpause() public onlyPauser whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }



    uint256[50] private ______gap;

}



contract ERC20Pausable is Initializable, ERC20, Pausable {

    function initialize(address sender) public initializer {

        Pausable.initialize(sender);

    }



    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transfer(to, value);

    }



    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {

        return super.transferFrom(from, to, value);

    }



    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {

        return super.approve(spender, value);

    }



    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {

        return super.increaseAllowance(spender, addedValue);

    }



    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {

        return super.decreaseAllowance(spender, subtractedValue);

    }



    uint256[50] private ______gap;

}



contract ERC20Burnable is Initializable, Context, ERC20 {

    

    function burn(uint256 amount) public {

        _burn(_msgSender(), amount);

    }



    

    function burnFrom(address account, uint256 amount) public {

        _burnFrom(account, amount);

    }



    uint256[50] private ______gap;

}



contract RenToken is Ownable, ERC20Detailed, ERC20Pausable, ERC20Burnable {

    string private constant _name = "REN";

    string private constant _symbol = "REN";

    uint8 private constant _decimals = 18;



    uint256 public constant INITIAL_SUPPLY = 1000000000 *

        10**uint256(_decimals);



    

    constructor() public {

        ERC20Pausable.initialize(msg.sender);

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        Ownable.initialize(msg.sender);

        _mint(msg.sender, INITIAL_SUPPLY);

    }



    function transferTokens(address beneficiary, uint256 amount)

        public

        onlyOwner

        returns (bool)

    {

        

        

        require(amount > 0);



        _transfer(msg.sender, beneficiary, amount);

        emit Transfer(msg.sender, beneficiary, amount);



        return true;

    }

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library LinkedList {



    

    address public constant NULL = address(0);



    

    struct Node {

        bool inList;

        address previous;

        address next;

    }



    

    struct List {

        mapping (address => Node) list;

    }



    

    function insertBefore(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address prev = self.list[target].previous;



        self.list[newNode].next = target;

        self.list[newNode].previous = prev;

        self.list[target].previous = newNode;

        self.list[prev].next = newNode;



        self.list[newNode].inList = true;

    }



    

    function insertAfter(List storage self, address target, address newNode) internal {

        require(newNode != address(0), "LinkedList: invalid address");

        require(!isInList(self, newNode), "LinkedList: already in list");

        require(isInList(self, target) || target == NULL, "LinkedList: not in list");



        

        address n = self.list[target].next;



        self.list[newNode].previous = target;

        self.list[newNode].next = n;

        self.list[target].next = newNode;

        self.list[n].previous = newNode;



        self.list[newNode].inList = true;

    }



    

    function remove(List storage self, address node) internal {

        require(isInList(self, node), "LinkedList: not in list");

        

        address p = self.list[node].previous;

        address n = self.list[node].next;



        self.list[p].next = n;

        self.list[n].previous = p;



        

        

        self.list[node].inList = false;

        delete self.list[node];

    }



    

    function prepend(List storage self, address node) internal {

        



        insertBefore(self, begin(self), node);

    }



    

    function append(List storage self, address node) internal {

        



        insertAfter(self, end(self), node);

    }



    function swap(List storage self, address left, address right) internal {

        



        address previousRight = self.list[right].previous;

        remove(self, right);

        insertAfter(self, left, right);

        remove(self, left);

        insertAfter(self, previousRight, left);

    }



    function isInList(List storage self, address node) internal view returns (bool) {

        return self.list[node].inList;

    }



    

    function begin(List storage self) internal view returns (address) {

        return self.list[NULL].next;

    }



    

    function end(List storage self) internal view returns (address) {

        return self.list[NULL].previous;

    }



    function next(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].next;

    }



    function previous(List storage self, address node) internal view returns (address) {

        require(isInList(self, node), "LinkedList: not in list");

        return self.list[node].previous;

    }



    function elements(List storage self, address _start, uint256 _count) internal view returns (address[] memory) {

        require(_count > 0, "LinkedList: invalid count");

        require(isInList(self, _start) || _start == address(0), "LinkedList: not in list");

        address[] memory elems = new address[](_count);



        

        uint256 n = 0;

        address nextItem = _start;

        if (nextItem == address(0)) {

            nextItem = begin(self);

        }



        while (n < _count) {

            if (nextItem == address(0)) {

                break;

            }

            elems[n] = nextItem;

            nextItem = next(self, nextItem);

            n += 1;

        }

        return elems;

    }

}



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    

    

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}



contract DarknodeRegistryStore is Claimable, CanReclaimTokens {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    

    

    struct Darknode {

        

        

        

        

        address payable owner;

        

        

        

        uint256 bond;

        

        uint256 registeredAt;

        

        uint256 deregisteredAt;

        

        

        

        

        bytes publicKey;

    }



    

    mapping(address => Darknode) private darknodeRegistry;

    LinkedList.List private darknodes;



    

    RenToken public ren;



    

    

    

    

    constructor(string memory _VERSION, RenToken _ren) public {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;

        ren = _ren;

        blacklistRecoverableToken(address(ren));

    }



    

    

    

    

    

    

    

    

    

    function appendDarknode(

        address _darknodeID,

        address payable _darknodeOperator,

        uint256 _bond,

        bytes calldata _publicKey,

        uint256 _registeredAt,

        uint256 _deregisteredAt

    ) external onlyOwner {

        Darknode memory darknode = Darknode({

            owner: _darknodeOperator,

            bond: _bond,

            publicKey: _publicKey,

            registeredAt: _registeredAt,

            deregisteredAt: _deregisteredAt

        });

        darknodeRegistry[_darknodeID] = darknode;

        LinkedList.append(darknodes, _darknodeID);

    }



    

    function begin() external view onlyOwner returns (address) {

        return LinkedList.begin(darknodes);

    }



    

    

    function next(address darknodeID)

        external

        view

        onlyOwner

        returns (address)

    {

        return LinkedList.next(darknodes, darknodeID);

    }



    

    

    function removeDarknode(address darknodeID) external onlyOwner {

        uint256 bond = darknodeRegistry[darknodeID].bond;

        delete darknodeRegistry[darknodeID];

        LinkedList.remove(darknodes, darknodeID);

        require(

            ren.transfer(owner(), bond),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    

    function updateDarknodeBond(address darknodeID, uint256 decreasedBond)

        external

        onlyOwner

    {

        uint256 previousBond = darknodeRegistry[darknodeID].bond;

        require(

            decreasedBond < previousBond,

            "DarknodeRegistryStore: bond not decreased"

        );

        darknodeRegistry[darknodeID].bond = decreasedBond;

        require(

            ren.transfer(owner(), previousBond.sub(decreasedBond)),

            "DarknodeRegistryStore: bond transfer failed"

        );

    }



    

    function updateDarknodeDeregisteredAt(

        address darknodeID,

        uint256 deregisteredAt

    ) external onlyOwner {

        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;

    }



    

    function darknodeOperator(address darknodeID)

        external

        view

        onlyOwner

        returns (address payable)

    {

        return darknodeRegistry[darknodeID].owner;

    }



    

    function darknodeBond(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].bond;

    }



    

    function darknodeRegisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].registeredAt;

    }



    

    function darknodeDeregisteredAt(address darknodeID)

        external

        view

        onlyOwner

        returns (uint256)

    {

        return darknodeRegistry[darknodeID].deregisteredAt;

    }



    

    function darknodePublicKey(address darknodeID)

        external

        view

        onlyOwner

        returns (bytes memory)

    {

        return darknodeRegistry[darknodeID].publicKey;

    }

}



interface IDarknodePaymentStore {}



interface IDarknodePayment {

    function changeCycle() external returns (uint256);

    function store() external view returns (IDarknodePaymentStore);

}



interface IDarknodeSlasher {}



contract DarknodeRegistryStateV1 {

    using SafeMath for uint256;



    string public VERSION; 



    

    

    

    struct Epoch {

        uint256 epochhash;

        uint256 blocktime;

    }



    uint256 public numDarknodes;

    uint256 public numDarknodesNextEpoch;

    uint256 public numDarknodesPreviousEpoch;



    

    uint256 public minimumBond;

    uint256 public minimumPodSize;

    uint256 public minimumEpochInterval;

    uint256 public deregistrationInterval;



    

    

    

    uint256 public nextMinimumBond;

    uint256 public nextMinimumPodSize;

    uint256 public nextMinimumEpochInterval;



    

    Epoch public currentEpoch;

    Epoch public previousEpoch;



    

    RenToken public ren;



    

    DarknodeRegistryStore public store;



    

    IDarknodePayment public darknodePayment;



    

    IDarknodeSlasher public slasher;

    IDarknodeSlasher public nextSlasher;

}



contract DarknodeRegistryLogicV1 is

    Claimable,

    CanReclaimTokens,

    DarknodeRegistryStateV1

{

    

    

    

    

    event LogDarknodeRegistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _bond

    );



    

    

    

    event LogDarknodeDeregistered(

        address indexed _darknodeOperator,

        address indexed _darknodeID

    );



    

    

    

    event LogDarknodeRefunded(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        uint256 _amount

    );



    

    

    

    

    

    event LogDarknodeSlashed(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        address indexed _challenger,

        uint256 _percentage

    );



    

    event LogNewEpoch(uint256 indexed epochhash);



    

    event LogMinimumBondUpdated(

        uint256 _previousMinimumBond,

        uint256 _nextMinimumBond

    );

    event LogMinimumPodSizeUpdated(

        uint256 _previousMinimumPodSize,

        uint256 _nextMinimumPodSize

    );

    event LogMinimumEpochIntervalUpdated(

        uint256 _previousMinimumEpochInterval,

        uint256 _nextMinimumEpochInterval

    );

    event LogSlasherUpdated(

        address indexed _previousSlasher,

        address indexed _nextSlasher

    );

    event LogDarknodePaymentUpdated(

        IDarknodePayment indexed _previousDarknodePayment,

        IDarknodePayment indexed _nextDarknodePayment

    );



    

    modifier onlyDarknodeOperator(address _darknodeID) {

        require(

            store.darknodeOperator(_darknodeID) == msg.sender,

            "DarknodeRegistry: must be darknode owner"

        );

        _;

    }



    

    modifier onlyRefunded(address _darknodeID) {

        require(

            isRefunded(_darknodeID),

            "DarknodeRegistry: must be refunded or never registered"

        );

        _;

    }



    

    modifier onlyRefundable(address _darknodeID) {

        require(

            isRefundable(_darknodeID),

            "DarknodeRegistry: must be deregistered for at least one epoch"

        );

        _;

    }



    

    

    modifier onlyDeregisterable(address _darknodeID) {

        require(

            isDeregisterable(_darknodeID),

            "DarknodeRegistry: must be deregisterable"

        );

        _;

    }



    

    modifier onlySlasher() {

        require(

            address(slasher) == msg.sender,

            "DarknodeRegistry: must be slasher"

        );

        _;

    }



    

    

    modifier onlyDarknode(address _darknodeID) {

        require(

            isRegistered(_darknodeID),

            "DarknodeRegistry: invalid darknode"

        );

        _;

    }



    

    

    

    

    

    

    

    

    

    function initialize(

        string memory _VERSION,

        RenToken _renAddress,

        DarknodeRegistryStore _storeAddress,

        uint256 _minimumBond,

        uint256 _minimumPodSize,

        uint256 _minimumEpochIntervalSeconds,

        uint256 _deregistrationIntervalSeconds

    ) public initializer {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

        VERSION = _VERSION;



        store = _storeAddress;

        ren = _renAddress;



        minimumBond = _minimumBond;

        nextMinimumBond = minimumBond;



        minimumPodSize = _minimumPodSize;

        nextMinimumPodSize = minimumPodSize;



        minimumEpochInterval = _minimumEpochIntervalSeconds;

        nextMinimumEpochInterval = minimumEpochInterval;

        deregistrationInterval = _deregistrationIntervalSeconds;



        uint256 epochhash = uint256(blockhash(block.number - 1));

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });

        emit LogNewEpoch(epochhash);

    }



    

    

    

    

    

    

    

    

    

    

    function register(address _darknodeID, bytes calldata _publicKey)

        external

        onlyRefunded(_darknodeID)

    {

        require(

            _darknodeID != address(0),

            "DarknodeRegistry: darknode address cannot be zero"

        );



        

        require(

            ren.transferFrom(msg.sender, address(store), minimumBond),

            "DarknodeRegistry: bond transfer failed"

        );



        

        store.appendDarknode(

            _darknodeID,

            msg.sender,

            minimumBond,

            _publicKey,

            currentEpoch.blocktime.add(minimumEpochInterval),

            0

        );



        numDarknodesNextEpoch = numDarknodesNextEpoch.add(1);



        

        emit LogDarknodeRegistered(msg.sender, _darknodeID, minimumBond);

    }



    

    

    

    

    

    

    function deregister(address _darknodeID)

        external

        onlyDeregisterable(_darknodeID)

        onlyDarknodeOperator(_darknodeID)

    {

        deregisterDarknode(_darknodeID);

    }



    

    

    

    function epoch() external {

        if (previousEpoch.blocktime == 0) {

            

            require(

                msg.sender == owner(),

                "DarknodeRegistry: not authorized to call first epoch"

            );

        }



        

        require(

            block.timestamp >= currentEpoch.blocktime.add(minimumEpochInterval),

            "DarknodeRegistry: epoch interval has not passed"

        );

        uint256 epochhash = uint256(blockhash(block.number - 1));



        

        previousEpoch = currentEpoch;

        currentEpoch = Epoch({

            epochhash: epochhash,

            blocktime: block.timestamp

        });



        

        numDarknodesPreviousEpoch = numDarknodes;

        numDarknodes = numDarknodesNextEpoch;



        

        if (nextMinimumBond != minimumBond) {

            minimumBond = nextMinimumBond;

            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);

        }

        if (nextMinimumPodSize != minimumPodSize) {

            minimumPodSize = nextMinimumPodSize;

            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);

        }

        if (nextMinimumEpochInterval != minimumEpochInterval) {

            minimumEpochInterval = nextMinimumEpochInterval;

            emit LogMinimumEpochIntervalUpdated(

                minimumEpochInterval,

                nextMinimumEpochInterval

            );

        }

        if (nextSlasher != slasher) {

            slasher = nextSlasher;

            emit LogSlasherUpdated(address(slasher), address(nextSlasher));

        }

        if (address(darknodePayment) != address(0x0)) {

            darknodePayment.changeCycle();

        }



        

        emit LogNewEpoch(epochhash);

    }



    

    

    

    function transferStoreOwnership(DarknodeRegistryLogicV1 _newOwner)

        external

        onlyOwner

    {

        store.transferOwnership(address(_newOwner));

        _newOwner.claimStoreOwnership();

    }



    

    

    

    function claimStoreOwnership() external {

        store.claimOwnership();



        

        

        (

            numDarknodesPreviousEpoch,

            numDarknodes,

            numDarknodesNextEpoch

        ) = getDarknodeCountFromEpochs();

    }



    

    

    

    

    function updateDarknodePayment(IDarknodePayment _darknodePayment)

        external

        onlyOwner

    {

        require(

            address(_darknodePayment) != address(0x0),

            "DarknodeRegistry: invalid Darknode Payment address"

        );

        IDarknodePayment previousDarknodePayment = darknodePayment;

        darknodePayment = _darknodePayment;

        emit LogDarknodePaymentUpdated(

            previousDarknodePayment,

            darknodePayment

        );

    }



    

    

    

    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {

        

        nextMinimumBond = _nextMinimumBond;

    }



    

    

    function updateMinimumPodSize(uint256 _nextMinimumPodSize)

        external

        onlyOwner

    {

        

        nextMinimumPodSize = _nextMinimumPodSize;

    }



    

    

    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval)

        external

        onlyOwner

    {

        

        nextMinimumEpochInterval = _nextMinimumEpochInterval;

    }



    

    

    

    function updateSlasher(IDarknodeSlasher _slasher) external onlyOwner {

        require(

            address(_slasher) != address(0),

            "DarknodeRegistry: invalid slasher address"

        );

        nextSlasher = _slasher;

    }



    

    

    

    

    

    function slash(address _guilty, address _challenger, uint256 _percentage)

        external

        onlySlasher

        onlyDarknode(_guilty)

    {

        require(_percentage <= 100, "DarknodeRegistry: invalid percent");



        

        if (isDeregisterable(_guilty)) {

            deregisterDarknode(_guilty);

        }



        uint256 totalBond = store.darknodeBond(_guilty);

        uint256 penalty = totalBond.div(100).mul(_percentage);

        uint256 challengerReward = penalty.div(2);

        uint256 darknodePaymentReward = penalty.sub(challengerReward);

        if (challengerReward > 0) {

            

            store.updateDarknodeBond(_guilty, totalBond.sub(penalty));



            

            require(

                address(darknodePayment) != address(0x0),

                "DarknodeRegistry: invalid payment address"

            );

            require(

                ren.transfer(

                    address(darknodePayment.store()),

                    darknodePaymentReward

                ),

                "DarknodeRegistry: reward transfer failed"

            );

            require(

                ren.transfer(_challenger, challengerReward),

                "DarknodeRegistry: reward transfer failed"

            );

        }



        emit LogDarknodeSlashed(

            store.darknodeOperator(_guilty),

            _guilty,

            _challenger,

            _percentage

        );

    }



    

    

    

    

    

    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        uint256 amount = store.darknodeBond(_darknodeID);



        

        store.removeDarknode(_darknodeID);



        

        require(

            ren.transfer(darknodeOperator, amount),

            "DarknodeRegistry: bond transfer failed"

        );



        

        emit LogDarknodeRefunded(darknodeOperator, _darknodeID, amount);

    }



    

    

    function getDarknodeOperator(address _darknodeID)

        external

        view

        returns (address payable)

    {

        return store.darknodeOperator(_darknodeID);

    }



    

    

    function getDarknodeBond(address _darknodeID)

        external

        view

        returns (uint256)

    {

        return store.darknodeBond(_darknodeID);

    }



    

    

    function getDarknodePublicKey(address _darknodeID)

        external

        view

        returns (bytes memory)

    {

        return store.darknodePublicKey(_darknodeID);

    }



    

    

    

    

    

    

    

    

    

    

    function getDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }

        return getDarknodesFromEpochs(_start, count, false);

    }



    

    

    function getPreviousDarknodes(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodesPreviousEpoch;

        }

        return getDarknodesFromEpochs(_start, count, true);

    }



    

    

    

    function isPendingRegistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        return registeredAt != 0 && registeredAt > currentEpoch.blocktime;

    }



    

    

    function isPendingDeregistration(address _darknodeID)

        public

        view

        returns (bool)

    {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocktime;

    }



    

    function isDeregistered(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocktime;

    }



    

    

    

    function isDeregisterable(address _darknodeID) public view returns (bool) {

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        

        

        return isRegistered(_darknodeID) && deregisteredAt == 0;

    }



    

    

    

    function isRefunded(address _darknodeID) public view returns (bool) {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        return registeredAt == 0 && deregisteredAt == 0;

    }



    

    

    function isRefundable(address _darknodeID) public view returns (bool) {

        return

            isDeregistered(_darknodeID) &&

            store.darknodeDeregisteredAt(_darknodeID) <=

            (previousEpoch.blocktime - deregistrationInterval);

    }



    

    function isRegistered(address _darknodeID) public view returns (bool) {

        return isRegisteredInEpoch(_darknodeID, currentEpoch);

    }



    

    function isRegisteredInPreviousEpoch(address _darknodeID)

        public

        view

        returns (bool)

    {

        return isRegisteredInEpoch(_darknodeID, previousEpoch);

    }



    

    

    

    

    function isRegisteredInEpoch(address _darknodeID, Epoch memory _epoch)

        private

        view

        returns (bool)

    {

        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);

        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);

        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocktime;

        bool notDeregistered = deregisteredAt == 0 ||

            deregisteredAt > _epoch.blocktime;

        

        

        return registered && notDeregistered;

    }



    

    

    

    

    

    function getDarknodesFromEpochs(

        address _start,

        uint256 _count,

        bool _usePreviousEpoch

    ) private view returns (address[] memory) {

        uint256 count = _count;

        if (count == 0) {

            count = numDarknodes;

        }



        address[] memory nodes = new address[](count);



        

        uint256 n = 0;

        address next = _start;

        if (next == address(0)) {

            next = store.begin();

        }



        

        while (n < count) {

            if (next == address(0)) {

                break;

            }

            

            bool includeNext;

            if (_usePreviousEpoch) {

                includeNext = isRegisteredInPreviousEpoch(next);

            } else {

                includeNext = isRegistered(next);

            }

            if (!includeNext) {

                next = store.next(next);

                continue;

            }

            nodes[n] = next;

            next = store.next(next);

            n += 1;

        }

        return nodes;

    }



    

    function deregisterDarknode(address _darknodeID) private {

        address darknodeOperator = store.darknodeOperator(_darknodeID);



        

        store.updateDarknodeDeregisteredAt(

            _darknodeID,

            currentEpoch.blocktime.add(minimumEpochInterval)

        );

        numDarknodesNextEpoch = numDarknodesNextEpoch.sub(1);



        

        emit LogDarknodeDeregistered(darknodeOperator, _darknodeID);

    }



    function getDarknodeCountFromEpochs()

        private

        view

        returns (uint256, uint256, uint256)

    {

        

        uint256 nPreviousEpoch = 0;

        uint256 nCurrentEpoch = 0;

        uint256 nNextEpoch = 0;

        address next = store.begin();



        

        while (true) {

            

            if (next == address(0)) {

                break;

            }



            if (isRegisteredInPreviousEpoch(next)) {

                nPreviousEpoch += 1;

            }



            if (isRegistered(next)) {

                nCurrentEpoch += 1;

            }



            

            

            if (

                ((isRegistered(next) && !isPendingDeregistration(next)) ||

                    isPendingRegistration(next))

            ) {

                nNextEpoch += 1;

            }

            next = store.next(next);

        }

        return (nPreviousEpoch, nCurrentEpoch, nNextEpoch);

    }

}



contract DarknodeRegistryProxy is InitializableAdminUpgradeabilityProxy {}



contract DarknodePaymentStore is Claimable {

    using SafeMath for uint256;

    using SafeERC20 for ERC20;

    using ERC20WithFees for ERC20;



    string public VERSION; 



    

    address public constant ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    

    mapping(address => mapping(address => uint256)) public darknodeBalances;



    

    mapping(address => uint256) public lockedBalances;



    

    

    

    constructor(string memory _VERSION) public {

        Claimable.initialize(msg.sender);

        VERSION = _VERSION;

    }



    

    function() external payable {}



    

    

    

    

    function totalBalance(address _token) public view returns (uint256) {

        if (_token == ETHEREUM) {

            return address(this).balance;

        } else {

            return ERC20(_token).balanceOf(address(this));

        }

    }



    

    

    

    

    

    

    function availableBalance(address _token) public view returns (uint256) {

        return

            totalBalance(_token).sub(

                lockedBalances[_token],

                "DarknodePaymentStore: locked balance exceed total balance"

            );

    }



    

    

    

    

    

    

    function incrementDarknodeBalance(

        address _darknode,

        address _token,

        uint256 _amount

    ) external onlyOwner {

        require(_amount > 0, "DarknodePaymentStore: invalid amount");

        require(

            availableBalance(_token) >= _amount,

            "DarknodePaymentStore: insufficient contract balance"

        );



        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token]

            .add(_amount);

        lockedBalances[_token] = lockedBalances[_token].add(_amount);

    }



    

    

    

    

    

    

    function transfer(

        address _darknode,

        address _token,

        uint256 _amount,

        address payable _recipient

    ) external onlyOwner {

        require(

            darknodeBalances[_darknode][_token] >= _amount,

            "DarknodePaymentStore: insufficient darknode balance"

        );

        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token]

            .sub(

            _amount,

            "DarknodePaymentStore: insufficient darknode balance for transfer"

        );

        lockedBalances[_token] = lockedBalances[_token].sub(

            _amount,

            "DarknodePaymentStore: insufficient token balance for transfer"

        );



        if (_token == ETHEREUM) {

            _recipient.transfer(_amount);

        } else {

            ERC20(_token).safeTransfer(_recipient, _amount);

        }

    }



}



contract DarknodePayment is Claimable {

    using SafeMath for uint256;

    using SafeERC20 for ERC20;

    using ERC20WithFees for ERC20;



    string public VERSION; 



    

    address public constant ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    DarknodeRegistryLogicV1 public darknodeRegistry; 



    

    

    DarknodePaymentStore public store; 



    

    

    address public cycleChanger;



    uint256 public currentCycle;

    uint256 public previousCycle;



    

    

    

    address[] public pendingTokens;



    

    

    address[] public registeredTokens;



    

    

    mapping(address => uint256) public registeredTokenIndex;



    

    

    

    mapping(address => uint256) public unclaimedRewards;



    

    

    mapping(address => uint256) public previousCycleRewardShare;



    

    uint256 public cycleStartTime;



    

    uint256 public nextCyclePayoutPercent;



    

    uint256 public currentCyclePayoutPercent;



    

    

    

    mapping(address => mapping(uint256 => bool)) public rewardClaimed;



    

    

    

    event LogDarknodeClaim(address indexed _darknode, uint256 _cycle);



    

    

    

    

    event LogPaymentReceived(

        address indexed _payer,

        address indexed _token,

        uint256 _amount

    );



    

    

    

    

    

    event LogDarknodeWithdrew(

        address indexed _darknodeOperator,

        address indexed _darknodeID,

        address indexed _token,

        uint256 _value

    );



    

    

    

    event LogPayoutPercentChanged(uint256 _newPercent, uint256 _oldPercent);



    

    

    

    event LogCycleChangerChanged(

        address indexed _newCycleChanger,

        address indexed _oldCycleChanger

    );



    

    

    event LogTokenRegistered(address indexed _token);



    

    

    event LogTokenDeregistered(address indexed _token);



    

    

    

    event LogDarknodeRegistryUpdated(

        DarknodeRegistryLogicV1 indexed _previousDarknodeRegistry,

        DarknodeRegistryLogicV1 indexed _nextDarknodeRegistry

    );



    

    modifier onlyDarknode(address _darknode) {

        require(

            darknodeRegistry.isRegistered(_darknode),

            "DarknodePayment: darknode is not registered"

        );

        _;

    }



    

    modifier validPercent(uint256 _percent) {

        require(_percent <= 100, "DarknodePayment: invalid percentage");

        _;

    }



    

    modifier onlyCycleChanger {

        require(

            msg.sender == cycleChanger,

            "DarknodePayment: not cycle changer"

        );

        _;

    }



    

    

    

    

    

    

    

    constructor(

        string memory _VERSION,

        DarknodeRegistryLogicV1 _darknodeRegistry,

        DarknodePaymentStore _darknodePaymentStore,

        uint256 _cyclePayoutPercent

    ) public validPercent(_cyclePayoutPercent) {

        Claimable.initialize(msg.sender);

        VERSION = _VERSION;

        darknodeRegistry = _darknodeRegistry;

        store = _darknodePaymentStore;

        nextCyclePayoutPercent = _cyclePayoutPercent;

        

        cycleChanger = msg.sender;



        

        (currentCycle, cycleStartTime) = darknodeRegistry.currentEpoch();

        currentCyclePayoutPercent = nextCyclePayoutPercent;

    }



    

    

    

    

    function updateDarknodeRegistry(DarknodeRegistryLogicV1 _darknodeRegistry)

        external

        onlyOwner

    {

        require(

            address(_darknodeRegistry) != address(0x0),

            "DarknodePayment: invalid Darknode Registry address"

        );

        DarknodeRegistryLogicV1 previousDarknodeRegistry = darknodeRegistry;

        darknodeRegistry = _darknodeRegistry;

        emit LogDarknodeRegistryUpdated(

            previousDarknodeRegistry,

            darknodeRegistry

        );

    }



    

    

    

    

    

    function withdraw(address _darknode, address _token) public {

        address payable darknodeOperator = darknodeRegistry.getDarknodeOperator(

            _darknode

        );

        require(

            darknodeOperator != address(0x0),

            "DarknodePayment: invalid darknode owner"

        );



        uint256 amount = store.darknodeBalances(_darknode, _token);



        

        if (amount > 0) {

            store.transfer(_darknode, _token, amount, darknodeOperator);

            emit LogDarknodeWithdrew(

                darknodeOperator,

                _darknode,

                _token,

                amount

            );

        }

    }



    function withdrawMultiple(

        address[] calldata _darknodes,

        address[] calldata _tokens

    ) external {

        for (uint256 i = 0; i < _darknodes.length; i++) {

            for (uint256 j = 0; j < _tokens.length; j++) {

                withdraw(_darknodes[i], _tokens[j]);

            }

        }

    }



    

    function() external payable {

        address(store).transfer(msg.value);

        emit LogPaymentReceived(msg.sender, ETHEREUM, msg.value);

    }



    

    

    function currentCycleRewardPool(address _token)

        external

        view

        returns (uint256)

    {

        uint256 total = store.availableBalance(_token).sub(

            unclaimedRewards[_token],

            "DarknodePayment: unclaimed rewards exceed total rewards"

        );

        return total.div(100).mul(currentCyclePayoutPercent);

    }



    function darknodeBalances(address _darknodeID, address _token)

        external

        view

        returns (uint256)

    {

        return store.darknodeBalances(_darknodeID, _token);

    }



    

    function changeCycle() external onlyCycleChanger returns (uint256) {

        

        uint256 arrayLength = registeredTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            _snapshotBalance(registeredTokens[i]);

        }



        

        previousCycle = currentCycle;

        (currentCycle, cycleStartTime) = darknodeRegistry.currentEpoch();

        currentCyclePayoutPercent = nextCyclePayoutPercent;



        

        _updateTokenList();

        return currentCycle;

    }



    

    

    

    

    function deposit(uint256 _value, address _token) external payable {

        uint256 receivedValue;

        if (_token == ETHEREUM) {

            require(

                _value == msg.value,

                "DarknodePayment: mismatched deposit value"

            );

            receivedValue = msg.value;

            address(store).transfer(msg.value);

        } else {

            require(

                msg.value == 0,

                "DarknodePayment: unexpected ether transfer"

            );

            require(

                registeredTokenIndex[_token] != 0,

                "DarknodePayment: token not registered"

            );

            

            receivedValue = ERC20(_token).safeTransferFromWithFees(

                msg.sender,

                address(store),

                _value

            );

        }

        emit LogPaymentReceived(msg.sender, _token, receivedValue);

    }



    

    

    

    

    function forward(address _token) external {

        if (_token == ETHEREUM) {

            

            

            

            

            address(store).transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                address(store),

                ERC20(_token).balanceOf(address(this))

            );

        }

    }



    

    

    function claim(address _darknode) external onlyDarknode(_darknode) {

        require(

            darknodeRegistry.isRegisteredInPreviousEpoch(_darknode),

            "DarknodePayment: cannot claim for this epoch"

        );

        

        _claimDarknodeReward(_darknode);

        emit LogDarknodeClaim(_darknode, previousCycle);

    }



    

    

    

    

    function registerToken(address _token) external onlyOwner {

        require(

            registeredTokenIndex[_token] == 0,

            "DarknodePayment: token already registered"

        );

        require(

            !tokenPendingRegistration(_token),

            "DarknodePayment: token already pending registration"

        );

        pendingTokens.push(_token);

    }



    function tokenPendingRegistration(address _token)

        public

        view

        returns (bool)

    {

        uint256 arrayLength = pendingTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            if (pendingTokens[i] == _token) {

                return true;

            }

        }

        return false;

    }



    

    

    

    

    function deregisterToken(address _token) external onlyOwner {

        require(

            registeredTokenIndex[_token] > 0,

            "DarknodePayment: token not registered"

        );

        _deregisterToken(_token);

    }



    

    

    

    function updateCycleChanger(address _addr) external onlyOwner {

        require(

            _addr != address(0),

            "DarknodePayment: invalid contract address"

        );

        emit LogCycleChangerChanged(_addr, cycleChanger);

        cycleChanger = _addr;

    }



    

    

    

    function updatePayoutPercentage(uint256 _percent)

        external

        onlyOwner

        validPercent(_percent)

    {

        uint256 oldPayoutPercent = nextCyclePayoutPercent;

        nextCyclePayoutPercent = _percent;

        emit LogPayoutPercentChanged(nextCyclePayoutPercent, oldPayoutPercent);

    }



    

    

    

    

    function transferStoreOwnership(DarknodePayment _newOwner)

        external

        onlyOwner

    {

        store.transferOwnership(address(_newOwner));

        _newOwner.claimStoreOwnership();

    }



    

    

    

    function claimStoreOwnership() external {

        store.claimOwnership();

    }



    

    

    

    

    

    function _claimDarknodeReward(address _darknode) private {

        require(

            !rewardClaimed[_darknode][previousCycle],

            "DarknodePayment: reward already claimed"

        );

        rewardClaimed[_darknode][previousCycle] = true;

        uint256 arrayLength = registeredTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            address token = registeredTokens[i];



            

            if (previousCycleRewardShare[token] > 0) {

                unclaimedRewards[token] = unclaimedRewards[token].sub(

                    previousCycleRewardShare[token],

                    "DarknodePayment: share exceeds unclaimed rewards"

                );

                store.incrementDarknodeBalance(

                    _darknode,

                    token,

                    previousCycleRewardShare[token]

                );

            }

        }

    }



    

    

    

    

    function _snapshotBalance(address _token) private {

        uint256 shareCount = darknodeRegistry.numDarknodesPreviousEpoch();

        if (shareCount == 0) {

            unclaimedRewards[_token] = 0;

            previousCycleRewardShare[_token] = 0;

        } else {

            

            uint256 total = store.availableBalance(_token);

            unclaimedRewards[_token] = total.div(100).mul(

                currentCyclePayoutPercent

            );

            previousCycleRewardShare[_token] = unclaimedRewards[_token].div(

                shareCount

            );

        }

    }



    

    

    

    

    function _deregisterToken(address _token) private {

        address lastToken = registeredTokens[registeredTokens.length.sub(

            1,

            "DarknodePayment: no tokens registered"

        )];

        uint256 deletedTokenIndex = registeredTokenIndex[_token].sub(1);

        

        registeredTokens[deletedTokenIndex] = lastToken;

        registeredTokenIndex[lastToken] = registeredTokenIndex[_token];

        

        

        registeredTokens.pop();

        registeredTokenIndex[_token] = 0;



        emit LogTokenDeregistered(_token);

    }



    

    

    function _updateTokenList() private {

        

        uint256 arrayLength = pendingTokens.length;

        for (uint256 i = 0; i < arrayLength; i++) {

            address token = pendingTokens[i];

            registeredTokens.push(token);

            registeredTokenIndex[token] = registeredTokens.length;

            emit LogTokenRegistered(token);

        }

        pendingTokens.length = 0;

    }



}



library ECDSA {

    

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        

        if (signature.length != 65) {

            revert("ECDSA: signature length is invalid");

        }



        

        bytes32 r;

        bytes32 s;

        uint8 v;



        

        

        

        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := byte(0, mload(add(signature, 0x60)))

        }



        

        

        

        

        

        

        

        

        

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            revert("ECDSA: signature.s is in the wrong range");

        }



        if (v != 27 && v != 28) {

            revert("ECDSA: signature.v is in the wrong range");

        }



        

        return ecrecover(hash, v, r, s);

    }



    

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        

        

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }

}



library String {

    

    

    function fromUint(uint256 _i) internal pure returns (string memory) {

        if (_i == 0) {

            return "0";

        }

        uint256 j = _i;

        uint256 len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint256 k = len - 1;

        while (_i != 0) {

            bstr[k--] = bytes1(uint8(48 + (_i % 10)));

            _i /= 10;

        }

        return string(bstr);

    }



    

    function fromBytes32(bytes32 _value) internal pure returns (string memory) {

        bytes memory alphabet = "0123456789abcdef";



        bytes memory str = new bytes(32 * 2 + 2);

        str[0] = "0";

        str[1] = "x";

        for (uint256 i = 0; i < 32; i++) {

            str[2 + i * 2] = alphabet[uint256(uint8(_value[i] >> 4))];

            str[3 + i * 2] = alphabet[uint256(uint8(_value[i] & 0x0f))];

        }

        return string(str);

    }



    

    function fromAddress(address _addr) internal pure returns (string memory) {

        bytes32 value = bytes32(uint256(_addr));

        bytes memory alphabet = "0123456789abcdef";



        bytes memory str = new bytes(20 * 2 + 2);

        str[0] = "0";

        str[1] = "x";

        for (uint256 i = 0; i < 20; i++) {

            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];

            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];

        }

        return string(str);

    }



    

    function add8(

        string memory a,

        string memory b,

        string memory c,

        string memory d,

        string memory e,

        string memory f,

        string memory g,

        string memory h

    ) internal pure returns (string memory) {

        return string(abi.encodePacked(a, b, c, d, e, f, g, h));

    }

}



library Compare {



    function bytesEqual(bytes memory a, bytes memory b) internal pure returns (bool) {

        if (a.length != b.length) {

            return false;

        }

        for (uint i = 0; i < a.length; i ++) {

            if (a[i] != b[i]) {

                return false;

            }

        }

        return true;

    }

}



library Validate {

    

    

    

    

    

    function duplicatePropose(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash1,

        uint256 _validRound1,

        bytes memory _signature1,

        bytes memory _blockhash2,

        uint256 _validRound2,

        bytes memory _signature2

    ) internal pure returns (address) {

        require(

            !Compare.bytesEqual(_signature1, _signature2),

            "Validate: same signature"

        );

        address signer1 = recoverPropose(

            _height,

            _round,

            _blockhash1,

            _validRound1,

            _signature1

        );

        address signer2 = recoverPropose(

            _height,

            _round,

            _blockhash2,

            _validRound2,

            _signature2

        );

        require(signer1 == signer2, "Validate: different signer");

        return signer1;

    }



    function recoverPropose(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash,

        uint256 _validRound,

        bytes memory _signature

    ) internal pure returns (address) {

        return

            ECDSA.recover(

                sha256(

                    proposeMessage(_height, _round, _blockhash, _validRound)

                ),

                _signature

            );

    }



    function proposeMessage(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash,

        uint256 _validRound

    ) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                "Propose(Height=",

                String.fromUint(_height),

                ",Round=",

                String.fromUint(_round),

                ",BlockHash=",

                string(_blockhash),

                ",ValidRound=",

                String.fromUint(_validRound),

                ")"

            );

    }



    

    

    

    

    

    function duplicatePrevote(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash1,

        bytes memory _signature1,

        bytes memory _blockhash2,

        bytes memory _signature2

    ) internal pure returns (address) {

        require(

            !Compare.bytesEqual(_signature1, _signature2),

            "Validate: same signature"

        );

        address signer1 = recoverPrevote(

            _height,

            _round,

            _blockhash1,

            _signature1

        );

        address signer2 = recoverPrevote(

            _height,

            _round,

            _blockhash2,

            _signature2

        );

        require(signer1 == signer2, "Validate: different signer");

        return signer1;

    }



    function recoverPrevote(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash,

        bytes memory _signature

    ) internal pure returns (address) {

        return

            ECDSA.recover(

                sha256(prevoteMessage(_height, _round, _blockhash)),

                _signature

            );

    }



    function prevoteMessage(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash

    ) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                "Prevote(Height=",

                String.fromUint(_height),

                ",Round=",

                String.fromUint(_round),

                ",BlockHash=",

                string(_blockhash),

                ")"

            );

    }



    

    

    

    

    

    function duplicatePrecommit(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash1,

        bytes memory _signature1,

        bytes memory _blockhash2,

        bytes memory _signature2

    ) internal pure returns (address) {

        require(

            !Compare.bytesEqual(_signature1, _signature2),

            "Validate: same signature"

        );

        address signer1 = recoverPrecommit(

            _height,

            _round,

            _blockhash1,

            _signature1

        );

        address signer2 = recoverPrecommit(

            _height,

            _round,

            _blockhash2,

            _signature2

        );

        require(signer1 == signer2, "Validate: different signer");

        return signer1;

    }



    function recoverPrecommit(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash,

        bytes memory _signature

    ) internal pure returns (address) {

        return

            ECDSA.recover(

                sha256(precommitMessage(_height, _round, _blockhash)),

                _signature

            );

    }



    function precommitMessage(

        uint256 _height,

        uint256 _round,

        bytes memory _blockhash

    ) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                "Precommit(Height=",

                String.fromUint(_height),

                ",Round=",

                String.fromUint(_round),

                ",BlockHash=",

                string(_blockhash),

                ")"

            );

    }



    function recoverSecret(

        uint256 _a,

        uint256 _b,

        uint256 _c,

        uint256 _d,

        uint256 _e,

        uint256 _f,

        bytes memory _signature

    ) internal pure returns (address) {

        return

            ECDSA.recover(

                sha256(secretMessage(_a, _b, _c, _d, _e, _f)),

                _signature

            );

    }



    function secretMessage(

        uint256 _a,

        uint256 _b,

        uint256 _c,

        uint256 _d,

        uint256 _e,

        uint256 _f

    ) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                "Secret(",

                "ShamirShare(",

                String.fromUint(_a),

                ",",

                String.fromUint(_b),

                ",S256N(",

                String.fromUint(_c),

                "),",

                "S256PrivKey(",

                "S256N(",

                String.fromUint(_d),

                "),",

                "S256P(",

                String.fromUint(_e),

                "),",

                "S256P(",

                String.fromUint(_f),

                ")",

                ")",

                ")",

                ")"

            );

    }

}



contract DarknodeSlasher is Claimable {

    DarknodeRegistryLogicV1 public darknodeRegistry;



    uint256 public blacklistSlashPercent;

    uint256 public maliciousSlashPercent;

    uint256 public secretRevealSlashPercent;



    

    

    mapping(uint256 => mapping(uint256 => mapping(address => bool))) public slashed;



    

    mapping(address => bool) public secretRevealed;



    

    mapping(address => bool) public blacklisted;



    

    

    

    event LogDarknodeRegistryUpdated(

        DarknodeRegistryLogicV1 indexed _previousDarknodeRegistry,

        DarknodeRegistryLogicV1 indexed _nextDarknodeRegistry

    );



    

    modifier validPercent(uint256 _percent) {

        require(_percent <= 100, "DarknodeSlasher: invalid percentage");

        _;

    }



    constructor(DarknodeRegistryLogicV1 _darknodeRegistry) public {

        Claimable.initialize(msg.sender);

        darknodeRegistry = _darknodeRegistry;

    }



    

    

    

    

    function updateDarknodeRegistry(DarknodeRegistryLogicV1 _darknodeRegistry)

        external

        onlyOwner

    {

        require(

            address(_darknodeRegistry) != address(0x0),

            "DarknodeSlasher: invalid Darknode Registry address"

        );

        DarknodeRegistryLogicV1 previousDarknodeRegistry = darknodeRegistry;

        darknodeRegistry = _darknodeRegistry;

        emit LogDarknodeRegistryUpdated(

            previousDarknodeRegistry,

            darknodeRegistry

        );

    }



    function setBlacklistSlashPercent(uint256 _percentage)

        public

        validPercent(_percentage)

        onlyOwner

    {

        blacklistSlashPercent = _percentage;

    }



    function setMaliciousSlashPercent(uint256 _percentage)

        public

        validPercent(_percentage)

        onlyOwner

    {

        maliciousSlashPercent = _percentage;

    }



    function setSecretRevealSlashPercent(uint256 _percentage)

        public

        validPercent(_percentage)

        onlyOwner

    {

        secretRevealSlashPercent = _percentage;

    }



    function slash(address _guilty, address _challenger, uint256 _percentage)

        external

        onlyOwner

    {

        darknodeRegistry.slash(_guilty, _challenger, _percentage);

    }



    function blacklist(address _guilty) external onlyOwner {

        require(!blacklisted[_guilty], "DarknodeSlasher: already blacklisted");

        blacklisted[_guilty] = true;

        darknodeRegistry.slash(_guilty, owner(), blacklistSlashPercent);

    }



    function slashDuplicatePropose(

        uint256 _height,

        uint256 _round,

        bytes calldata _blockhash1,

        uint256 _validRound1,

        bytes calldata _signature1,

        bytes calldata _blockhash2,

        uint256 _validRound2,

        bytes calldata _signature2

    ) external {

        address signer = Validate.duplicatePropose(

            _height,

            _round,

            _blockhash1,

            _validRound1,

            _signature1,

            _blockhash2,

            _validRound2,

            _signature2

        );

        require(

            !slashed[_height][_round][signer],

            "DarknodeSlasher: already slashed"

        );

        slashed[_height][_round][signer] = true;

        darknodeRegistry.slash(signer, msg.sender, maliciousSlashPercent);

    }



    function slashDuplicatePrevote(

        uint256 _height,

        uint256 _round,

        bytes calldata _blockhash1,

        bytes calldata _signature1,

        bytes calldata _blockhash2,

        bytes calldata _signature2

    ) external {

        address signer = Validate.duplicatePrevote(

            _height,

            _round,

            _blockhash1,

            _signature1,

            _blockhash2,

            _signature2

        );

        require(

            !slashed[_height][_round][signer],

            "DarknodeSlasher: already slashed"

        );

        slashed[_height][_round][signer] = true;

        darknodeRegistry.slash(signer, msg.sender, maliciousSlashPercent);

    }



    function slashDuplicatePrecommit(

        uint256 _height,

        uint256 _round,

        bytes calldata _blockhash1,

        bytes calldata _signature1,

        bytes calldata _blockhash2,

        bytes calldata _signature2

    ) external {

        address signer = Validate.duplicatePrecommit(

            _height,

            _round,

            _blockhash1,

            _signature1,

            _blockhash2,

            _signature2

        );

        require(

            !slashed[_height][_round][signer],

            "DarknodeSlasher: already slashed"

        );

        slashed[_height][_round][signer] = true;

        darknodeRegistry.slash(signer, msg.sender, maliciousSlashPercent);

    }



    function slashSecretReveal(

        uint256 _a,

        uint256 _b,

        uint256 _c,

        uint256 _d,

        uint256 _e,

        uint256 _f,

        bytes calldata _signature

    ) external {

        address signer = Validate.recoverSecret(

            _a,

            _b,

            _c,

            _d,

            _e,

            _f,

            _signature

        );

        require(!secretRevealed[signer], "DarknodeSlasher: already slashed");

        secretRevealed[signer] = true;

        darknodeRegistry.slash(signer, msg.sender, secretRevealSlashPercent);

    }

}



contract ERC20WithRate is Initializable, Ownable, ERC20 {

    using SafeMath for uint256;



    uint256 public constant _rateScale = 1e18;

    uint256 internal _rate;



    event LogRateChanged(uint256 indexed _rate);



    

    function initialize(address _nextOwner, uint256 _initialRate)

        public

        initializer

    {

        Ownable.initialize(_nextOwner);

        _setRate(_initialRate);

    }



    function setExchangeRate(uint256 _nextRate) public onlyOwner {

        _setRate(_nextRate);

    }



    function exchangeRateCurrent() public view returns (uint256) {

        require(_rate != 0, "ERC20WithRate: rate has not been initialized");

        return _rate;

    }



    function _setRate(uint256 _nextRate) internal {

        require(_nextRate > 0, "ERC20WithRate: rate must be greater than zero");

        _rate = _nextRate;

    }



    function balanceOfUnderlying(address _account)

        public

        view

        returns (uint256)

    {

        return toUnderlying(balanceOf(_account));

    }



    function toUnderlying(uint256 _amount) public view returns (uint256) {

        return _amount.mul(_rate).div(_rateScale);

    }



    function fromUnderlying(uint256 _amountUnderlying)

        public

        view

        returns (uint256)

    {

        return _amountUnderlying.mul(_rateScale).div(_rate);

    }

}



contract ERC20WithPermit is Initializable, ERC20, ERC20Detailed {

    using SafeMath for uint256;



    mapping(address => uint256) public nonces;



    

    

    string public version;



    

    bytes32 public DOMAIN_SEPARATOR;

    

    

    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;



    function initialize(

        uint256 _chainId,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        version = _version;

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256(

                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"

                ),

                keccak256(bytes(name())),

                keccak256(bytes(version)),

                _chainId,

                address(this)

            )

        );

    }



    

    function permit(

        address holder,

        address spender,

        uint256 nonce,

        uint256 expiry,

        bool allowed,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external {

        bytes32 digest = keccak256(

            abi.encodePacked(

                "\x19\x01",

                DOMAIN_SEPARATOR,

                keccak256(

                    abi.encode(

                        PERMIT_TYPEHASH,

                        holder,

                        spender,

                        nonce,

                        expiry,

                        allowed

                    )

                )

            )

        );



        require(holder != address(0), "ERC20WithRate: address must not be 0x0");

        require(

            holder == ecrecover(digest, v, r, s),

            "ERC20WithRate: invalid signature"

        );

        require(

            expiry == 0 || now <= expiry,

            "ERC20WithRate: permit has expired"

        );

        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");

        uint256 amount = allowed ? uint256(-1) : 0;

        _approve(holder, spender, amount);

    }

}



contract RenERC20LogicV1 is

    Initializable,

    ERC20,

    ERC20Detailed,

    ERC20WithRate,

    ERC20WithPermit,

    Claimable,

    CanReclaimTokens

{

    

    function initialize(

        uint256 _chainId,

        address _nextOwner,

        uint256 _initialRate,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        ERC20WithRate.initialize(_nextOwner, _initialRate);

        ERC20WithPermit.initialize(

            _chainId,

            _version,

            _name,

            _symbol,

            _decimals

        );

        Claimable.initialize(_nextOwner);

        CanReclaimTokens.initialize(_nextOwner);

    }



    

    

    function mint(address _to, uint256 _amount) public onlyOwner {

        _mint(_to, _amount);

    }



    

    

    function burn(address _from, uint256 _amount) public onlyOwner {

        _burn(_from, _amount);

    }



    function transfer(address recipient, uint256 amount) public returns (bool) {

        

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transfer(recipient, amount);

    }



    function transferFrom(address sender, address recipient, uint256 amount)

        public

        returns (bool)

    {

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transferFrom(sender, recipient, amount);

    }

}



contract RenBTC is InitializableAdminUpgradeabilityProxy {}



contract RenZEC is InitializableAdminUpgradeabilityProxy {}



contract RenBCH is InitializableAdminUpgradeabilityProxy {}



interface IMintGateway {

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);

    function mintFee() external view returns (uint256);

}



interface IBurnGateway {

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);

    function burnFee() external view returns (uint256);

}



interface IGateway {

    

    function mint(

        bytes32 _pHash,

        uint256 _amount,

        bytes32 _nHash,

        bytes calldata _sig

    ) external returns (uint256);

    function mintFee() external view returns (uint256);

    

    function burn(bytes calldata _to, uint256 _amountScaled)

        external

        returns (uint256);

    function burnFee() external view returns (uint256);

}



contract GatewayRegistry is Claimable, CanReclaimTokens {

    constructor() public {

        Claimable.initialize(msg.sender);

        CanReclaimTokens.initialize(msg.sender);

    }



    

    

    event LogGatewayRegistered(

        string _symbol,

        string indexed _indexedSymbol,

        address indexed _token,

        address indexed _gatewayContract

    );

    event LogGatewayDeregistered(

        string _symbol,

        string indexed _indexedSymbol,

        address indexed _token,

        address indexed _gatewayContract

    );

    event LogGatewayUpdated(

        address indexed _token,

        address indexed _currentGatewayContract,

        address indexed _newGatewayContract

    );



    

    uint256 numGatewayContracts = 0;



    

    LinkedList.List private gatewayContractList;



    

    LinkedList.List private renTokenList;



    

    mapping(address => address) private gatewayByToken;



    

    mapping(string => address) private tokenBySymbol;



    

    

    

    

    

    function setGateway(string calldata _symbol, address _token, address _gatewayContract)

        external

        onlyOwner

    {

        require(symbolIsValid(_symbol), "GatewayRegistry: symbol must be alphanumeric");



        

        require(

            !LinkedList.isInList(gatewayContractList, _gatewayContract),

            "GatewayRegistry: gateway already registered"

        );

        require(

            gatewayByToken[_token] == address(0x0),

            "GatewayRegistry: token already registered"

        );

        require(

            tokenBySymbol[_symbol] == address(0x0),

            "GatewayRegistry: symbol already registered"

        );



        

        LinkedList.append(gatewayContractList, _gatewayContract);



        

        LinkedList.append(renTokenList, _token);



        tokenBySymbol[_symbol] = _token;

        gatewayByToken[_token] = _gatewayContract;

        numGatewayContracts += 1;



        emit LogGatewayRegistered(_symbol, _symbol, _token, _gatewayContract);

    }



    

    

    

    

    

    function updateGateway(address _token, address _newGatewayContract)

        external

        onlyOwner

    {

        

        address currentGateway = gatewayByToken[_token];

        require(

            currentGateway != address(0x0),

            "GatewayRegistry: token not registered"

        );



        

        LinkedList.remove(gatewayContractList, currentGateway);



        

        LinkedList.append(gatewayContractList, _newGatewayContract);



        gatewayByToken[_token] = _newGatewayContract;



        emit LogGatewayUpdated(_token, currentGateway, _newGatewayContract);

    }



    

    

    

    

    function removeGateway(string calldata _symbol) external onlyOwner {

        

        address tokenAddress = tokenBySymbol[_symbol];

        require(

            tokenAddress != address(0x0),

            "GatewayRegistry: symbol not registered"

        );



        

        address gatewayAddress = gatewayByToken[tokenAddress];



        

        delete gatewayByToken[tokenAddress];

        delete tokenBySymbol[_symbol];

        LinkedList.remove(gatewayContractList, gatewayAddress);

        LinkedList.remove(renTokenList, tokenAddress);

        numGatewayContracts -= 1;



        emit LogGatewayDeregistered(

            _symbol,

            _symbol,

            tokenAddress,

            gatewayAddress

        );

    }



    

    function getGateways(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        return

            LinkedList.elements(

                gatewayContractList,

                _start,

                _count == 0 ? numGatewayContracts : _count

            );

    }



    

    function getRenTokens(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        return

            LinkedList.elements(

                renTokenList,

                _start,

                _count == 0 ? numGatewayContracts : _count

            );

    }



    

    

    

    

    function getGatewayByToken(address _token)

        external

        view

        returns (IGateway)

    {

        return IGateway(gatewayByToken[_token]);

    }



    

    

    

    

    function getGatewayBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IGateway)

    {

        return IGateway(gatewayByToken[tokenBySymbol[_tokenSymbol]]);

    }



    

    

    

    

    function getTokenBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IERC20)

    {

        return IERC20(tokenBySymbol[_tokenSymbol]);

    }



    function symbolIsValid(string memory _tokenSymbol) public pure returns (bool) {

        for (uint i = 0; i < bytes(_tokenSymbol).length; i++) {

            uint8 char = uint8(bytes(_tokenSymbol)[i]);

            if (!(

                (char >= 65 && char <= 90) ||

                (char >= 97 && char <= 122) ||

                (char >= 48 && char <= 57)

            )) {

                return false;

            }

        }

        return true;

    }

}



interface IGatewayRegistry {

    

    

    event LogGatewayRegistered(

        string _symbol,

        string indexed _indexedSymbol,

        address indexed _tokenAddress,

        address indexed _gatewayAddress

    );

    event LogGatewayDeregistered(

        string _symbol,

        string indexed _indexedSymbol,

        address indexed _tokenAddress,

        address indexed _gatewayAddress

    );

    event LogGatewayUpdated(

        address indexed _tokenAddress,

        address indexed _currentGatewayAddress,

        address indexed _newGatewayAddress

    );



    

    function getGateways(address _start, uint256 _count)

        external

        view

        returns (address[] memory);



    

    function getRenTokens(address _start, uint256 _count)

        external

        view

        returns (address[] memory);



    

    

    

    

    function getGatewayByToken(address _tokenAddress)

        external

        view

        returns (IGateway);



    

    

    

    

    function getGatewayBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IGateway);



    

    

    

    

    function getTokenBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IERC20);

}



contract ProtocolStateV1 {

    



    

    



    

    

    DarknodeRegistryLogicV1 internal _darknodeRegistry;



    

    GatewayRegistry internal _gatewayRegistry;

}



contract ProtocolLogicV1 is

    Initializable,

    Claimable,

    ProtocolStateV1,

    IGatewayRegistry

{

    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    



    function darknodeRegistry() public view returns (DarknodeRegistryLogicV1) {

        return ProtocolStateV1._darknodeRegistry;

    }



    function darknodeRegistryStore()

        public

        view

        returns (DarknodeRegistryStore)

    {

        return darknodeRegistry().store();

    }



    function renToken() public view returns (RenToken) {

        return darknodeRegistry().ren();

    }



    function darknodePayment() public view returns (DarknodePayment) {

        return

            DarknodePayment(

                _payableAddress(address(darknodeRegistry().darknodePayment()))

            );

    }



    function darknodePaymentStore() public view returns (DarknodePaymentStore) {

        return darknodePayment().store();

    }



    function darknodeSlasher() public view returns (DarknodeSlasher) {

        return

            DarknodeSlasher(

                _payableAddress(address(darknodeRegistry().slasher()))

            );

    }



    



    function gatewayRegistry() public view returns (GatewayRegistry) {

        return ProtocolStateV1._gatewayRegistry;

    }



    function getGateways(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        return gatewayRegistry().getGateways(_start, _count);

    }



    function getRenTokens(address _start, uint256 _count)

        external

        view

        returns (address[] memory)

    {

        return gatewayRegistry().getRenTokens(_start, _count);

    }



    function getGatewayByToken(address _tokenAddress)

        external

        view

        returns (IGateway)

    {

        return gatewayRegistry().getGatewayByToken(_tokenAddress);

    }



    function getGatewayBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IGateway)

    {

        return gatewayRegistry().getGatewayBySymbol(_tokenSymbol);

    }



    function getTokenBySymbol(string calldata _tokenSymbol)

        external

        view

        returns (IERC20)

    {

        return gatewayRegistry().getTokenBySymbol(_tokenSymbol);

    }



    



    

    

    

    function _updateDarknodeRegistry(

        DarknodeRegistryLogicV1 _newDarknodeRegistry

    ) public onlyOwner {

        ProtocolStateV1._darknodeRegistry = _newDarknodeRegistry;

    }



    

    

    function _updateGatewayRegistry(GatewayRegistry _newGatewayRegistry)

        public

        onlyOwner

    {

        ProtocolStateV1._gatewayRegistry = _newGatewayRegistry;

    }



    



    

    function _payableAddress(address a)

        internal

        pure

        returns (address payable)

    {

        return address(uint160(address(a)));

    }

}



contract ProtocolProxy is InitializableAdminUpgradeabilityProxy {}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\Proxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM

 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to

 * be specified by overriding the virtual {_implementation} function.

 *

 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a

 * different contract through the {_delegate} function.

 *

 * The success and return data of the delegated call will be returned back to the caller of the proxy.

 */

abstract contract Proxy {

    /**

     * @dev Delegates the current call to `implementation`.

     *

     * This function does not return to its internall call site, it will return directly to the external caller.

     */

    function _delegate(address implementation) internal virtual {

        assembly {

            // Copy msg.data. We take full control of memory in this inline assembly

            // block because it will not return to Solidity code. We overwrite the

            // Solidity scratch pad at memory position 0.

            calldatacopy(0, 0, calldatasize())



            // Call the implementation.

            // out and outsize are 0 because we don't know the size yet.

            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)



            // Copy the returned data.

            returndatacopy(0, 0, returndatasize())



            switch result

            // delegatecall returns 0 on error.

            case 0 {

                revert(0, returndatasize())

            }

            default {

                return(0, returndatasize())

            }

        }

    }



    /**

     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function

     * and {_fallback} should delegate.

     */

    function _implementation() internal view virtual returns (address);



    /**

     * @dev Delegates the current call to the address returned by `_implementation()`.

     *

     * This function does not return to its internall call site, it will return directly to the external caller.

     */

    function _fallback() internal virtual {

        _beforeFallback();

        _delegate(_implementation());

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other

     * function in the contract matches the call data.

     */

    fallback() external payable virtual {

        _fallback();

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data

     * is empty.

     */

    receive() external payable virtual {

        _fallback();

    }



    /**

     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`

     * call, or as part of the Solidity `fallback` or `receive` functions.

     *

     * If overriden should call `super._beforeFallback()`.

     */

    function _beforeFallback() internal virtual {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\ProxyBeacon.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";

import {UpgradeableBeacon} from "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol";

import {Context} from "@openzeppelin/contracts/utils/Context.sol";

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

import {Address} from "@openzeppelin/contracts/utils/Address.sol";



import {BeaconProxy} from "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol";



contract ProxyBeacon is Context, UpgradeableBeacon {

    event LogProxyDeployerUpdated(address indexed oldProxyDeployer, address indexed newProxyDeployer);



    // Only allow one address to call `deployProxy`.

    address private _proxyDeployer;



    modifier onlyProxyDeployer() {

        address proxyDeployer_ = getProxyDeployer();

        require(

            proxyDeployer_ != address(0x0) && _msgSender() == proxyDeployer_,

            "ProxyBeacon: caller is not the proxy deployer"

        );

        _;

    }



    constructor(address implementation_, address contractOwner) UpgradeableBeacon(implementation_) {

        transferOwnership(contractOwner);

    }



    // GETTERS /////////////////////////////////////////////////////////////////



    function getProxyDeployer() public view returns (address) {

        return _proxyDeployer;

    }



    // GOVERNANCE //////////////////////////////////////////////////////////////



    function updateProxyDeployer(address newProxyDeployer) public onlyOwner {

        require(newProxyDeployer != address(0x0), "ProxyBeacon: invalid proxy deployer");

        address oldProxyDeployer = _proxyDeployer;

        _proxyDeployer = newProxyDeployer;

        emit LogProxyDeployerUpdated(oldProxyDeployer, newProxyDeployer);

    }



    // RESTRICTED //////////////////////////////////////////////////////////////



    /// @notice Deploy a proxy that fetches its implementation from this

    /// ProxyBeacon.

    function deployProxy(bytes32 create2Salt, bytes calldata encodedParameters)

        external

        onlyProxyDeployer

        returns (address)

    {

        // Deploy without initialization code so that the create2 address isn't

        // based on the initialization parameters.

        address proxy = address(new BeaconProxy{salt: create2Salt}(address(this), ""));



        Address.functionCall(address(proxy), encodedParameters);



        return proxy;



    }

}



contract RenAssetProxyBeacon is ProxyBeacon {

    string public constant NAME = "RenAssetProxyBeacon";



    constructor(address implementation, address adminAddress) ProxyBeacon(implementation, adminAddress) {}

}



contract MintGatewayProxyBeacon is ProxyBeacon {

    string public constant NAME = "MintGatewayProxyBeacon";



    constructor(address implementation, address adminAddress) ProxyBeacon(implementation, adminAddress) {}

}



contract LockGatewayProxyBeacon is ProxyBeacon {

    string public constant NAME = "LockGatewayProxyBeacon";



    constructor(address implementation, address adminAddress) ProxyBeacon(implementation, adminAddress) {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\RenAssetFactory.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import {ContextUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";

import {BeaconProxy} from "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol";

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";



import {IMintGateway} from "../Gateways/interfaces/IMintGateway.sol";

import {ILockGateway} from "../Gateways/interfaces/ILockGateway.sol";

import {RenAssetProxyBeacon, MintGatewayProxyBeacon, LockGatewayProxyBeacon} from "./ProxyBeacon.sol";

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";



contract RenAssetFactoryState {

    RenAssetProxyBeacon internal _renAssetProxyBeacon;

    MintGatewayProxyBeacon internal _mintGatewayProxyBeacon;

    LockGatewayProxyBeacon internal _lockGatewayProxyBeacon;

}



abstract contract RenAssetFactory is Initializable, ContextUpgradeable, RenAssetFactoryState {

    event RenAssetProxyDeployed(

        uint256 chainId,

        string asset,

        string name,

        string symbol,

        uint8 decimals,

        string version

    );

    event MintGatewayProxyDeployed(string asset, address signatureVerifier, address token, string version);

    event LockGatewayProxyDeployed(string asset, address signatureVerifier, address token, string version);



    function getRenAssetProxyBeacon() public view returns (RenAssetProxyBeacon) {

        return _renAssetProxyBeacon;

    }



    function getMintGatewayProxyBeacon() public view returns (MintGatewayProxyBeacon) {

        return _mintGatewayProxyBeacon;

    }



    function getLockGatewayProxyBeacon() public view returns (LockGatewayProxyBeacon) {

        return _lockGatewayProxyBeacon;

    }



    function __RenAssetFactory_init(

        address renAssetProxyBeacon_,

        address mintGatewayProxyBeacon_,

        address lockGatewayProxyBeacon_

    ) public initializer {

        __Context_init();

        _renAssetProxyBeacon = RenAssetProxyBeacon(renAssetProxyBeacon_);

        _mintGatewayProxyBeacon = MintGatewayProxyBeacon(mintGatewayProxyBeacon_);

        _lockGatewayProxyBeacon = LockGatewayProxyBeacon(lockGatewayProxyBeacon_);

    }



    function _deployRenAsset(

        uint256 chainId,

        string calldata asset,

        string calldata name,

        string calldata symbol,

        uint8 decimals,

        string calldata version

    ) internal returns (IERC20) {

        bytes memory encodedParameters = abi.encodeWithSignature(

            "__RenAsset_init(uint256,string,string,string,uint8,address)",

            chainId,

            version,

            name,

            symbol,

            decimals,

            // Owner will be transferred to gateway

            address(this)

        );



        bytes32 create2Salt = keccak256(abi.encodePacked(asset, version));



        address renAsset = getRenAssetProxyBeacon().deployProxy(create2Salt, encodedParameters);



        emit RenAssetProxyDeployed(chainId, asset, name, symbol, decimals, version);



        return IERC20(renAsset);

    }



    function _deployMintGateway(

        string calldata asset,

        address signatureVerifier,

        address token,

        string calldata version

    ) internal returns (IMintGateway) {

        bytes memory encodedParameters = abi.encodeWithSignature(

            "__MintGateway_init(string,address,address)",

            asset,

            signatureVerifier,

            token

        );



        bytes32 create2Salt = keccak256(abi.encodePacked(asset, version));



        address mintGateway = getMintGatewayProxyBeacon().deployProxy(create2Salt, encodedParameters);



        emit MintGatewayProxyDeployed(asset, signatureVerifier, token, version);



        return IMintGateway(mintGateway);

    }



    function _deployLockGateway(

        string calldata asset,

        address signatureVerifier,

        address token,

        string calldata version

    ) internal returns (ILockGateway) {

        bytes memory encodedParameters = abi.encodeWithSignature(

            "__LockGateway_init(string,address,address)",

            asset,

            signatureVerifier,

            token

        );



        bytes32 create2Salt = keccak256(abi.encodePacked(asset, version));



        address lockGateway = getLockGatewayProxyBeacon().deployProxy(create2Salt, encodedParameters);



        emit LockGatewayProxyDeployed(asset, signatureVerifier, token, version);



        return ILockGateway(lockGateway);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\RenERC20.sol
File type: .sol
pragma solidity ^0.5.16;



import "@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol";

import "@openzeppelin/upgrades/contracts/upgradeability/InitializableAdminUpgradeabilityProxy.sol";

import "@openzeppelin/upgrades/contracts/Initializable.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol";

import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol";



import "../Governance/Claimable.sol";

import "../libraries/CanReclaimTokens.sol";

import "./ERC20WithRate.sol";

import "./ERC20WithPermit.sol";



/// @notice RenERC20 represents a digital asset that has been bridged on to

/// the Ethereum ledger. It exposes mint and burn functions that can only be

/// called by it's associated Gateway contract.

contract RenERC20LogicV1 is

    Initializable,

    ERC20,

    ERC20Detailed,

    ERC20WithRate,

    ERC20WithPermit,

    Claimable,

    CanReclaimTokens

{

    /* solium-disable-next-line no-empty-blocks */

    function initialize(

        uint256 _chainId,

        address _nextOwner,

        uint256 _initialRate,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        ERC20WithRate.initialize(_nextOwner, _initialRate);

        ERC20WithPermit.initialize(

            _chainId,

            _version,

            _name,

            _symbol,

            _decimals

        );

        Claimable.initialize(_nextOwner);

        CanReclaimTokens.initialize(_nextOwner);

    }



    function updateSymbol(string memory symbol) public onlyOwner {

        ERC20Detailed._symbol = symbol;

    }



    /// @notice mint can only be called by the tokens' associated Gateway

    /// contract. See Gateway's mint function instead.

    function mint(address _to, uint256 _amount) public onlyOwner {

        _mint(_to, _amount);

    }



    /// @notice burn can only be called by the tokens' associated Gateway

    /// contract. See Gateway's burn functions instead.

    function burn(address _from, uint256 _amount) public onlyOwner {

        _burn(_from, _amount);

    }



    function transfer(address recipient, uint256 amount) public returns (bool) {

        // Disallow sending tokens to the ERC20 contract address - a common

        // mistake caused by the Ethereum transaction's `to` needing to be

        // the token's address.

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transfer(recipient, amount);

    }



    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) public returns (bool) {

        // Disallow sending tokens to the ERC20 contract address (see comment

        // in `transfer`).

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transferFrom(sender, recipient, amount);

    }

}



/* solium-disable-next-line no-empty-blocks */

contract RenERC20Proxy is InitializableAdminUpgradeabilityProxy {



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\RenERC20LogicV1.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2020-11-03

*/



/**



Deployed by Ren Project, https://renproject.io



Commit hash: 1e106b3

Repository: https://github.com/renproject/gateway-sol

Issues: https://github.com/renproject/gateway-sol/issues



Licenses

@openzeppelin/contracts: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE

gateway-sol: https://github.com/renproject/gateway-sol/blob/master/LICENSE



*/



pragma solidity ^0.5.16;





contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}



contract Context is Initializable {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}



contract Ownable is Initializable, Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    function initialize(address sender) public initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[50] private ______gap;

}



contract Proxy {

  

  function () payable external {

    _fallback();

  }



  

  function _implementation() internal view returns (address);



  

  function _delegate(address implementation) internal {

    assembly {

      

      

      

      calldatacopy(0, 0, calldatasize)



      

      

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      

      returndatacopy(0, 0, returndatasize)



      switch result

      

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  

  function _willFallback() internal {

  }



  

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



library OpenZeppelinUpgradesAddress {

    

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        

        

        

        

        

        

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



contract BaseUpgradeabilityProxy is Proxy {

  

  event Upgraded(address indexed implementation);



  

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



  

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  

  function _setImplementation(address newImplementation) internal {

    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  constructor(address _logic, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  event AdminChanged(address previousAdmin, address newAdmin);



  



  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



  

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  

  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    (bool success,) = newImplementation.delegatecall(data);

    require(success);

  }



  

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

  

  function initialize(address _logic, bytes memory _data) public payable {

    require(_implementation() == address(0));

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}



contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {

  

  function initialize(address _logic, address _admin, bytes memory _data) public payable {

    require(_implementation() == address(0));

    InitializableUpgradeabilityProxy.initialize(_logic, _data);

    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));

    _setAdmin(_admin);

  }

}



interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract ERC20 is Initializable, Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    uint256[50] private ______gap;

}



contract ERC20Detailed is Initializable, IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    uint256[50] private ______gap;

}



contract Claimable is Initializable, Ownable {

    address public pendingOwner;



    function initialize(address _nextOwner) public initializer {

        Ownable.initialize(_nextOwner);

    }



    modifier onlyPendingOwner() {

        require(

            _msgSender() == pendingOwner,

            "Claimable: caller is not the pending owner"

        );

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(

            newOwner != owner() && newOwner != pendingOwner,

            "Claimable: invalid new owner"

        );

        pendingOwner = newOwner;

    }



    function claimOwnership() public onlyPendingOwner {

        _transferOwnership(pendingOwner);

        delete pendingOwner;

    }

}



library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



contract CanReclaimTokens is Claimable {

    using SafeERC20 for ERC20;



    mapping(address => bool) private recoverableTokensBlacklist;



    function initialize(address _nextOwner) public initializer {

        Claimable.initialize(_nextOwner);

    }



    function blacklistRecoverableToken(address _token) public onlyOwner {

        recoverableTokensBlacklist[_token] = true;

    }



    

    

    function recoverTokens(address _token) external onlyOwner {

        require(

            !recoverableTokensBlacklist[_token],

            "CanReclaimTokens: token is not recoverable"

        );



        if (_token == address(0x0)) {

            msg.sender.transfer(address(this).balance);

        } else {

            ERC20(_token).safeTransfer(

                msg.sender,

                ERC20(_token).balanceOf(address(this))

            );

        }

    }

}



contract ERC20WithRate is Initializable, Ownable, ERC20 {

    using SafeMath for uint256;



    uint256 public constant _rateScale = 1e18;

    uint256 internal _rate;



    event LogRateChanged(uint256 indexed _rate);



    

    function initialize(address _nextOwner, uint256 _initialRate)

        public

        initializer

    {

        Ownable.initialize(_nextOwner);

        _setRate(_initialRate);

    }



    function setExchangeRate(uint256 _nextRate) public onlyOwner {

        _setRate(_nextRate);

    }



    function exchangeRateCurrent() public view returns (uint256) {

        require(_rate != 0, "ERC20WithRate: rate has not been initialized");

        return _rate;

    }



    function _setRate(uint256 _nextRate) internal {

        require(_nextRate > 0, "ERC20WithRate: rate must be greater than zero");

        _rate = _nextRate;

    }



    function balanceOfUnderlying(address _account)

        public

        view

        returns (uint256)

    {

        return toUnderlying(balanceOf(_account));

    }



    function toUnderlying(uint256 _amount) public view returns (uint256) {

        return _amount.mul(_rate).div(_rateScale);

    }



    function fromUnderlying(uint256 _amountUnderlying)

        public

        view

        returns (uint256)

    {

        return _amountUnderlying.mul(_rateScale).div(_rate);

    }

}



contract ERC20WithPermit is Initializable, ERC20, ERC20Detailed {

    using SafeMath for uint256;



    mapping(address => uint256) public nonces;



    

    

    string public version;



    

    bytes32 public DOMAIN_SEPARATOR;

    

    

    bytes32

        public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;



    function initialize(

        uint256 _chainId,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        version = _version;

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256(

                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"

                ),

                keccak256(bytes(name())),

                keccak256(bytes(version)),

                _chainId,

                address(this)

            )

        );

    }



    

    function permit(

        address holder,

        address spender,

        uint256 nonce,

        uint256 expiry,

        bool allowed,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external {

        bytes32 digest = keccak256(

            abi.encodePacked(

                "\x19\x01",

                DOMAIN_SEPARATOR,

                keccak256(

                    abi.encode(

                        PERMIT_TYPEHASH,

                        holder,

                        spender,

                        nonce,

                        expiry,

                        allowed

                    )

                )

            )

        );



        require(holder != address(0), "ERC20WithRate: address must not be 0x0");

        require(

            holder == ecrecover(digest, v, r, s),

            "ERC20WithRate: invalid signature"

        );

        require(

            expiry == 0 || now <= expiry,

            "ERC20WithRate: permit has expired"

        );

        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");

        uint256 amount = allowed ? uint256(-1) : 0;

        _approve(holder, spender, amount);

    }

}



contract RenERC20LogicV1 is

    Initializable,

    ERC20,

    ERC20Detailed,

    ERC20WithRate,

    ERC20WithPermit,

    Claimable,

    CanReclaimTokens

{

    

    function initialize(

        uint256 _chainId,

        address _nextOwner,

        uint256 _initialRate,

        string memory _version,

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) public initializer {

        ERC20Detailed.initialize(_name, _symbol, _decimals);

        ERC20WithRate.initialize(_nextOwner, _initialRate);

        ERC20WithPermit.initialize(

            _chainId,

            _version,

            _name,

            _symbol,

            _decimals

        );

        Claimable.initialize(_nextOwner);

        CanReclaimTokens.initialize(_nextOwner);

    }



    

    

    function mint(address _to, uint256 _amount) public onlyOwner {

        _mint(_to, _amount);

    }



    

    

    function burn(address _from, uint256 _amount) public onlyOwner {

        _burn(_from, _amount);

    }



    function transfer(address recipient, uint256 amount) public returns (bool) {

        

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transfer(recipient, amount);

    }



    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) public returns (bool) {

        

        

        require(

            recipient != address(this),

            "RenERC20: can't transfer to token address"

        );

        return super.transferFrom(sender, recipient, amount);

    }

}



contract RenERC20Proxy is InitializableAdminUpgradeabilityProxy {



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\RepublicToken.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2017-12-31

*/



pragma solidity ^0.4.13;



library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {

    if (a == 0) {

      return 0;

    }

    uint256 c = a * b;

    assert(c / a == b);

    return c;

  }



  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    // assert(b > 0); // Solidity automatically throws when dividing by 0

    uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;

  }



  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function add(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a + b;

    assert(c >= a);

    return c;

  }

}



contract Ownable {

  address public owner;





  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  function Ownable() public {

    owner = msg.sender;

  }





  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }





  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param newOwner The address to transfer ownership to.

   */

  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



}



contract Pausable is Ownable {

  event Pause();

  event Unpause();



  bool public paused = false;





  /**

   * @dev Modifier to make a function callable only when the contract is not paused.

   */

  modifier whenNotPaused() {

    require(!paused);

    _;

  }



  /**

   * @dev Modifier to make a function callable only when the contract is paused.

   */

  modifier whenPaused() {

    require(paused);

    _;

  }



  /**

   * @dev called by the owner to pause, triggers stopped state

   */

  function pause() onlyOwner whenNotPaused public {

    paused = true;

    Pause();

  }



  /**

   * @dev called by the owner to unpause, returns to normal state

   */

  function unpause() onlyOwner whenPaused public {

    paused = false;

    Unpause();

  }

}



contract ERC20Basic {

  uint256 public totalSupply;

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}



contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  /**

  * @dev transfer token for a specified address

  * @param _to The address to transfer to.

  * @param _value The amount to be transferred.

  */

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



    // SafeMath.sub will throw if there is not enough balance.

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

    return true;

  }



  /**

  * @dev Gets the balance of the specified address.

  * @param _owner The address to query the the balance of.

  * @return An uint256 representing the amount owned by the passed address.

  */

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}



contract ERC20 is ERC20Basic {

  function allowance(address owner, address spender) public view returns (uint256);

  function transferFrom(address from, address to, uint256 value) public returns (bool);

  function approve(address spender, uint256 value) public returns (bool);

  event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract StandardToken is ERC20, BasicToken {



  mapping (address => mapping (address => uint256)) internal allowed;





  /**

   * @dev Transfer tokens from one address to another

   * @param _from address The address which you want to send tokens from

   * @param _to address The address which you want to transfer to

   * @param _value uint256 the amount of tokens to be transferred

   */

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[_from]);

    require(_value <= allowed[_from][msg.sender]);



    balances[_from] = balances[_from].sub(_value);

    balances[_to] = balances[_to].add(_value);

    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

    Transfer(_from, _to, _value);

    return true;

  }



  /**

   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

   *

   * Beware that changing an allowance with this method brings the risk that someone may use both the old

   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

   * @param _spender The address which will spend the funds.

   * @param _value The amount of tokens to be spent.

   */

  function approve(address _spender, uint256 _value) public returns (bool) {

    allowed[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);

    return true;

  }



  /**

   * @dev Function to check the amount of tokens that an owner allowed to a spender.

   * @param _owner address The address which owns the funds.

   * @param _spender address The address which will spend the funds.

   * @return A uint256 specifying the amount of tokens still available for the spender.

   */

  function allowance(address _owner, address _spender) public view returns (uint256) {

    return allowed[_owner][_spender];

  }



  /**

   * approve should be called when allowed[_spender] == 0. To increment

   * allowed value is better to use this function to avoid 2 calls (and wait until

   * the first transaction is mined)

   * From MonolithDAO Token.sol

   */

  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {

    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);

    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  }



  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {

    uint oldValue = allowed[msg.sender][_spender];

    if (_subtractedValue > oldValue) {

      allowed[msg.sender][_spender] = 0;

    } else {

      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

    }

    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  }



}



contract BurnableToken is StandardToken {



    event Burn(address indexed burner, uint256 value);



    /**

     * @dev Burns a specific amount of tokens.

     * @param _value The amount of token to be burned.

     */

    function burn(uint256 _value) public {

        require(_value > 0);

        require(_value <= balances[msg.sender]);

        // no need to require value <= totalSupply, since that would imply the

        // sender's balance is greater than the totalSupply, which *should* be an assertion failure



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        Burn(burner, _value);

    }

}



contract PausableToken is StandardToken, Pausable {



  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {

    return super.transfer(_to, _value);

  }



  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {

    return super.transferFrom(_from, _to, _value);

  }



  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {

    return super.approve(_spender, _value);

  }



  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {

    return super.increaseApproval(_spender, _addedValue);

  }



  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {

    return super.decreaseApproval(_spender, _subtractedValue);

  }

}



contract RepublicToken is PausableToken, BurnableToken {



    string public constant name = "Republic Token";

    string public constant symbol = "REN";

    uint8 public constant decimals = 18;

    uint256 public constant INITIAL_SUPPLY = 1000000000 * 10**uint256(decimals);

    

    /**

    * @dev RepublicToken Constructor

    */



    function RepublicToken() public {

        totalSupply = INITIAL_SUPPLY;   

        balances[msg.sender] = INITIAL_SUPPLY;

    }



    function transferTokens(address beneficiary, uint256 amount) public onlyOwner returns (bool) {

        require(amount > 0);



        balances[owner] = balances[owner].sub(amount);

        balances[beneficiary] = balances[beneficiary].add(amount);

        Transfer(owner, beneficiary, amount);



        return true;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC20.sol";

import "../../../utils/Address.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender) + value;

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        unchecked {

            uint256 oldAllowance = token.allowance(address(this), spender);

            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");

            uint256 newAllowance = oldAllowance - value;

            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

        }

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {

            // Return data is optional

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\SafeMath.sol
File type: .sol
pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\StorageSlot.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Library for reading and writing primitive types to specific storage slots.

 *

 * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.

 * This library helps with reading and writing to such slots without the need for inline assembly.

 *

 * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.

 *

 * Example usage to set ERC1967 implementation slot:

 * ```

 * contract ERC1967 {

 *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

 *

 *     function _getImplementation() internal view returns (address) {

 *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

 *     }

 *

 *     function _setImplementation(address newImplementation) internal {

 *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

 *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

 *     }

 * }

 * ```

 *

 * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._

 */

library StorageSlot {

    struct AddressSlot {

        address value;

    }



    struct BooleanSlot {

        bool value;

    }



    struct Bytes32Slot {

        bytes32 value;

    }



    struct Uint256Slot {

        uint256 value;

    }



    /**

     * @dev Returns an `AddressSlot` with member `value` located at `slot`.

     */

    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.

     */

    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.

     */

    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.

     */

    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {

        assembly {

            r.slot := slot

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\String.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



/// Library with common String checks.

library String {

    /// Check that the string only contains alphanumeric characters, to avoid

    /// UTF-8 characters that are indistinguishable from alphanumeric

    /// characters.

    function isAlphanumeric(string memory str) internal pure returns (bool) {

        for (uint256 i = 0; i < bytes(str).length; i++) {

            uint8 char = uint8(bytes(str)[i]);

            if (!((char >= 65 && char <= 90) || (char >= 97 && char <= 122) || (char >= 48 && char <= 57))) {

                return false;

            }

        }

        return true;

    }



    /// Check that the string has at least one character.

    function isNotEmpty(string memory str) internal pure returns (bool) {

        return bytes(str).length > 0;

    }



    /// Check that the string is not empty and only has alphanumeric characters.

    function isValidString(string memory str) internal pure returns (bool) {

        return isNotEmpty(str) && isAlphanumeric(str);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\Strings.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev String operations.

 */

library Strings {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\StringSet.sol
File type: .sol
// SPDX-License-Identifier: MIT



// Modified from @openzeppelin/contracts's EnumerableSet to store strings.



/*



The MIT License (MIT)



Copyright (c) 2016-2020 zOS Global Limited



Permission is hereby granted, free of charge, to any person obtaining

a copy of this software and associated documentation files (the

"Software"), to deal in the Software without restriction, including

without limitation the rights to use, copy, modify, merge, publish,

distribute, sublicense, and/or sell copies of the Software, and to

permit persons to whom the Software is furnished to do so, subject to

the following conditions:



The above copyright notice and this permission notice shall be included

in all copies or substantial portions of the Software.



THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS

OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.

IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY

CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,

TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE

SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



*/



// solhint-disable-next-line

pragma solidity ^0.8.0;



library StringSet {

    struct Set {

        string[] _values;

        mapping(string => uint256) _indexes; // 1-indexed

    }



    function add(Set storage set, string memory value) internal returns (bool) {

        if (!contains(set, value)) {

            set._values.push(value);

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    function remove(Set storage set, string memory value) internal returns (bool) {

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) {

            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            // Swap the item with the last element so that it can be popped.

            if (lastIndex != toDeleteIndex) {

                string memory lastvalue = set._values[lastIndex];

                set._values[toDeleteIndex] = lastvalue;

                set._indexes[lastvalue] = valueIndex;

            }

            set._values.pop();

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    function contains(Set storage set, string memory value) internal view returns (bool) {

        return set._indexes[value] != 0;

    }



    function length(Set storage set) internal view returns (uint256) {

        return set._values.length;

    }



    function at(Set storage set, uint256 index) internal view returns (string memory) {

        return set._values[index];

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\StringsUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev String operations.

 */

library StringsUpgradeable {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\StringV1.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0



// solhint-disable-next-line

pragma solidity ^0.8.0;



/// Updates String.isAlphanumeric to allow underscores.

library StringV1 {

    /// Check that the string only contains alphanumeric characters (and

    /// underscores), to avoid UTF-8 characters that are indistinguishable from

    /// alphanumeric characters.

    function isAlphanumeric(string memory str) internal pure returns (bool) {

        for (uint256 i = 0; i < bytes(str).length; i++) {

            uint8 char = uint8(bytes(str)[i]);

            if (

                !((char >= 65 && char <= 90) || (char >= 97 && char <= 122) || (char >= 48 && char <= 57) || char == 95)

            ) {

                return false;

            }

        }

        return true;

    }



    /// Check that the string has at least one character.

    function isNotEmpty(string memory str) internal pure returns (bool) {

        return bytes(str).length > 0;

    }



    /// Check that the string is not empty and only has alphanumeric characters.

    function isValidString(string memory str) internal pure returns (bool) {

        return isNotEmpty(str) && isAlphanumeric(str);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\TransparentUpgradeableProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../ERC1967/ERC1967Proxy.sol";



/**

 * @dev This contract implements a proxy that is upgradeable by an admin.

 *

 * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector

 * clashing], which can potentially be used in an attack, this contract uses the

 * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two

 * things that go hand in hand:

 *

 * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if

 * that call matches one of the admin functions exposed by the proxy itself.

 * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the

 * implementation. If the admin tries to call a function on the implementation it will fail with an error that says

 * "admin cannot fallback to proxy target".

 *

 * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing

 * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due

 * to sudden errors when trying to call a function from the proxy implementation.

 *

 * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,

 * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.

 */

contract TransparentUpgradeableProxy is ERC1967Proxy {

    /**

     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and

     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.

     */

    constructor(

        address _logic,

        address admin_,

        bytes memory _data

    ) payable ERC1967Proxy(_logic, _data) {

        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));

        _changeAdmin(admin_);

    }



    /**

     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.

     */

    modifier ifAdmin() {

        if (msg.sender == _getAdmin()) {

            _;

        } else {

            _fallback();

        }

    }



    /**

     * @dev Returns the current admin.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.

     *

     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the

     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.

     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`

     */

    function admin() external ifAdmin returns (address admin_) {

        admin_ = _getAdmin();

    }



    /**

     * @dev Returns the current implementation.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.

     *

     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the

     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.

     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`

     */

    function implementation() external ifAdmin returns (address implementation_) {

        implementation_ = _implementation();

    }



    /**

     * @dev Changes the admin of the proxy.

     *

     * Emits an {AdminChanged} event.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.

     */

    function changeAdmin(address newAdmin) external virtual ifAdmin {

        _changeAdmin(newAdmin);

    }



    /**

     * @dev Upgrade the implementation of the proxy.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.

     */

    function upgradeTo(address newImplementation) external ifAdmin {

        _upgradeToAndCall(newImplementation, bytes(""), false);

    }



    /**

     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified

     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the

     * proxied contract.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.

     */

    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {

        _upgradeToAndCall(newImplementation, data, true);

    }



    /**

     * @dev Returns the current admin.

     */

    function _admin() internal view virtual returns (address) {

        return _getAdmin();

    }



    /**

     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.

     */

    function _beforeFallback() internal virtual override {

        require(msg.sender != _getAdmin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target");

        super._beforeFallback();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\UpgradeabilityProxy.sol
File type: .sol
pragma solidity ^0.5.0;



import './BaseUpgradeabilityProxy.sol';



/**

 * @title UpgradeabilityProxy

 * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing

 * implementation and init data.

 */

contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

  /**

   * @dev Contract constructor.

   * @param _logic Address of the initial implementation.

   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.

   * It should include the signature and the parameters of the function to be called, as described in

   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.

   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.

   */

  constructor(address _logic, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_logic);

    if(_data.length > 0) {

      (bool success,) = _logic.delegatecall(_data);

      require(success);

    }

  }  

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\RenBridge\contracts\UpgradeableBeacon.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IBeacon.sol";

import "../../access/Ownable.sol";

import "../../utils/Address.sol";



/**

 * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their

 * implementation contract, which is where they will delegate all function calls.

 *

 * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.

 */

contract UpgradeableBeacon is IBeacon, Ownable {

    address private _implementation;



    /**

     * @dev Emitted when the implementation returned by the beacon is changed.

     */

    event Upgraded(address indexed implementation);



    /**

     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the

     * beacon.

     */

    constructor(address implementation_) {

        _setImplementation(implementation_);

    }



    /**

     * @dev Returns the current implementation address.

     */

    function implementation() public view virtual override returns (address) {

        return _implementation;

    }



    /**

     * @dev Upgrades the beacon to a new implementation.

     *

     * Emits an {Upgraded} event.

     *

     * Requirements:

     *

     * - msg.sender must be the owner of the contract.

     * - `newImplementation` must be a contract.

     */

    function upgradeTo(address newImplementation) public virtual onlyOwner {

        _setImplementation(newImplementation);

        emit Upgraded(newImplementation);

    }



    /**

     * @dev Sets the implementation contract address for this beacon

     *

     * Requirements:

     *

     * - `newImplementation` must be a contract.

     */

    function _setImplementation(address newImplementation) private {

        require(Address.isContract(newImplementation), "UpgradeableBeacon: implementation is not a contract");

        _implementation = newImplementation;

    }

}

--------------------------------------------------
File End
--------------------------------------------------

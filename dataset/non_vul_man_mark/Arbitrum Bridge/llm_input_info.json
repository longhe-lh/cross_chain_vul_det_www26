{
    "src_chain": {
        "MessageDelivered1": [
            {
                "enqueueDelayedMessage": "function enqueueDelayedMessage(\n uint8 kind,\n address sender,\n bytes32 messageDataHash\n ) external payable returns (uint256) {\n if (!allowedDelayedInboxesMap[msg.sender].allowed)\n revert NotDelayedInbox(msg.sender);\n return\n addMessageToDelayedAccumulator(\n kind,\n sender,\n uint64(block.number),\n uint64(block.timestamp), \n block.basefee,\n messageDataHash\n );\n }"
            },
            {
                "addMessageToDelayedAccumulator": "function addMessageToDelayedAccumulator(\n uint8 kind,\n address sender,\n uint64 blockNumber,\n uint64 blockTimestamp,\n uint256 baseFeeL1,\n bytes32 messageDataHash\n ) internal returns (uint256) {\n uint256 count = delayedInboxAccs.length;\n bytes32 messageHash = Messages.messageHash(\n kind,\n sender,\n blockNumber,\n blockTimestamp,\n count,\n baseFeeL1,\n messageDataHash\n );\n bytes32 prevAcc = 0;\n if (count > 0) {\n prevAcc = delayedInboxAccs[count - 1];\n }\n delayedInboxAccs.push(\n Messages.accumulateInboxMessage(prevAcc, messageHash)\n );\n emit MessageDelivered(\n count,\n prevAcc,\n msg.sender,\n kind,\n sender,\n messageDataHash,\n baseFeeL1,\n blockTimestamp\n );\n return count;\n }"
            }
        ],
        "BridgeCallTriggered2": [
            {
                "executeCall": "function executeCall(\n address to,\n uint256 value,\n bytes calldata data\n ) external returns (bool success, bytes memory returnData) {\n if (!allowedOutboxesMap[msg.sender].allowed)\n revert NotOutbox(msg.sender);\n if (data.length > 0 && !to.isContract()) revert NotContract(to);\n address prevOutbox = _activeOutbox;\n _activeOutbox = msg.sender;\n \n \n \n \n (success, returnData) = to.call{value: value}(data);\n _activeOutbox = prevOutbox;\n emit BridgeCallTriggered(msg.sender, to, value, data);\n }"
            }
        ]
    },
    "rel_chain": {
        "SequencerBatchDelivered": [
            {
                "addSequencerL2BatchFromOrigin": "function addSequencerL2BatchFromOrigin(\n uint256 sequenceNumber,\n bytes calldata data,\n uint256 afterDelayedMessagesRead,\n IGasRefunder gasRefunder\n ) external refundsGas(gasRefunder) {\n \n if (msg.sender != tx.origin) revert NotOrigin();\n if (!isBatchPoster[msg.sender]) revert NotBatchPoster();\n (bytes32 dataHash, TimeBounds memory timeBounds) = formDataHash(\n data,\n afterDelayedMessagesRead\n );\n (\n uint256 seqMessageIndex,\n bytes32 beforeAcc,\n bytes32 delayedAcc,\n bytes32 afterAcc\n ) = addSequencerL2BatchImpl(\n dataHash,\n afterDelayedMessagesRead,\n data.length\n );\n if (seqMessageIndex != sequenceNumber)\n revert BadSequencerNumber(seqMessageIndex, sequenceNumber);\n emit SequencerBatchDelivered(\n sequenceNumber,\n beforeAcc,\n afterAcc,\n delayedAcc,\n totalDelayedMessagesRead,\n timeBounds,\n BatchDataLocation.TxInput\n );\n }"
            },
            {
                "addSequencerL2BatchImpl": "function addSequencerL2BatchImpl(\n bytes32 dataHash,\n uint256 afterDelayedMessagesRead,\n uint256 calldataLengthPosted\n )\n internal\n returns (\n uint256 seqMessageIndex,\n bytes32 beforeAcc,\n bytes32 delayedAcc,\n bytes32 acc\n )\n {\n if (afterDelayedMessagesRead < totalDelayedMessagesRead)\n revert DelayedBackwards();\n if (afterDelayedMessagesRead > bridge.delayedMessageCount())\n revert DelayedTooFar();\n (seqMessageIndex, beforeAcc, delayedAcc, acc) = bridge\n .enqueueSequencerMessage(dataHash, afterDelayedMessagesRead);\n totalDelayedMessagesRead = afterDelayedMessagesRead;\n if (calldataLengthPosted > 0) {\n \n \n address batchPoster = msg.sender;\n bytes memory spendingReportMsg = abi.encodePacked(\n block.timestamp,\n batchPoster,\n dataHash,\n seqMessageIndex,\n block.basefee\n );\n uint256 msgNum = bridge.submitBatchSpendingReport(\n batchPoster,\n keccak256(spendingReportMsg)\n );\n \n emit InboxMessageDelivered(msgNum, spendingReportMsg);\n }\n }"
            },
            {
                "enqueueSequencerMessage": "function enqueueSequencerMessage(\n bytes32 dataHash,\n uint256 afterDelayedMessagesRead\n )\n external\n onlySequencerInbox\n returns (\n uint256 seqMessageIndex,\n bytes32 beforeAcc,\n bytes32 delayedAcc,\n bytes32 acc\n )\n {\n seqMessageIndex = sequencerInboxAccs.length;\n if (sequencerInboxAccs.length > 0) {\n beforeAcc = sequencerInboxAccs[sequencerInboxAccs.length - 1];\n }\n if (afterDelayedMessagesRead > 0) {\n delayedAcc = delayedInboxAccs[afterDelayedMessagesRead - 1];\n }\n acc = keccak256(abi.encodePacked(beforeAcc, dataHash, delayedAcc));\n sequencerInboxAccs.push(acc);\n }"
            }
        ],
        "NodeCreated": [
            {
                "createNewNode": "function createNewNode(\n RollupLib.Assertion calldata assertion,\n uint64 prevNodeNum,\n uint256 prevNodeInboxMaxCount,\n bytes32 expectedNodeHash\n ) internal returns (bytes32 newNodeHash) {\n require(\n assertion.afterState.machineStatus == MachineStatus.FINISHED ||\n assertion.afterState.machineStatus == MachineStatus.ERRORED,\n \"BAD_AFTER_STATUS\"\n );\n StakeOnNewNodeFrame memory memoryFrame;\n {\n \n memoryFrame.prevNode = getNode(prevNodeNum);\n memoryFrame.currentInboxSize = bridge.sequencerMessageCount();\n \n require(\n RollupLib.stateHash(\n assertion.beforeState,\n prevNodeInboxMaxCount\n ) == memoryFrame.prevNode.stateHash,\n \"PREV_STATE_HASH\"\n );\n \n uint64 afterInboxCount = assertion\n .afterState\n .globalState\n .getInboxPosition();\n uint64 prevInboxPosition = assertion\n .beforeState\n .globalState\n .getInboxPosition();\n require(afterInboxCount >= prevInboxPosition, \"INBOX_BACKWARDS\");\n if (afterInboxCount == prevInboxPosition) {\n require(\n assertion.afterState.globalState.getPositionInMessage() >=\n assertion\n .beforeState\n .globalState\n .getPositionInMessage(),\n \"INBOX_POS_IN_MSG_BACKWARDS\"\n );\n }\n \n if (\n assertion.afterState.machineStatus == MachineStatus.ERRORED ||\n assertion.afterState.globalState.getPositionInMessage() > 0\n ) {\n \n afterInboxCount++;\n }\n require(\n afterInboxCount <= memoryFrame.currentInboxSize,\n \"INBOX_PAST_END\"\n );\n \n if (afterInboxCount > 0) {\n memoryFrame.sequencerBatchAcc = bridge.sequencerInboxAccs(\n afterInboxCount - 1\n );\n }\n }\n {\n memoryFrame.executionHash = RollupLib.executionHash(assertion);\n memoryFrame.deadlineBlock =\n uint64(block.number) +\n confirmPeriodBlocks;\n memoryFrame.hasSibling = memoryFrame.prevNode.latestChildNumber > 0;\n \n if (memoryFrame.hasSibling) {\n memoryFrame.lastHash = getNodeStorage(\n memoryFrame.prevNode.latestChildNumber\n ).nodeHash;\n } else {\n memoryFrame.lastHash = memoryFrame.prevNode.nodeHash;\n }\n newNodeHash = RollupLib.nodeHash(\n memoryFrame.hasSibling,\n memoryFrame.lastHash,\n memoryFrame.executionHash,\n memoryFrame.sequencerBatchAcc,\n wasmModuleRoot\n );\n require(\n newNodeHash == expectedNodeHash ||\n expectedNodeHash == bytes32(0),\n \"UNEXPECTED_NODE_HASH\"\n );\n memoryFrame.node = NodeLib.createNode(\n RollupLib.stateHash(\n assertion.afterState,\n memoryFrame.currentInboxSize\n ),\n RollupLib.challengeRootHash(\n memoryFrame.executionHash,\n block.number,\n wasmModuleRoot\n ),\n RollupLib.confirmHash(assertion),\n prevNodeNum,\n memoryFrame.deadlineBlock,\n newNodeHash\n );\n }\n {\n uint64 nodeNum = latestNodeCreated() + 1;\n \n \n Node storage prevNode = getNodeStorage(prevNodeNum);\n prevNode.childCreated(nodeNum);\n nodeCreated(memoryFrame.node);\n }\n emit NodeCreated(\n latestNodeCreated(),\n memoryFrame.prevNode.nodeHash,\n newNodeHash,\n memoryFrame.executionHash,\n assertion,\n memoryFrame.sequencerBatchAcc,\n wasmModuleRoot,\n memoryFrame.currentInboxSize\n );\n return newNodeHash;\n }"
            }
        ],
        "ChallengeStarted": [
            {
                "createChallenge": "function createChallenge(\n bytes32 wasmModuleRoot_,\n MachineStatus[2] calldata startAndEndMachineStatuses_,\n GlobalState[2] calldata startAndEndGlobalStates_,\n uint64 numBlocks,\n address asserter_,\n address challenger_,\n uint256 asserterTimeLeft_,\n uint256 challengerTimeLeft_\n ) external override returns (uint64) {\n require(msg.sender == address(resultReceiver), \"ONLY_ROLLUP_CHAL\");\n bytes32[] memory segments = new bytes32[](2);\n segments[0] = ChallengeLib.blockStateHash(\n startAndEndMachineStatuses_[0],\n startAndEndGlobalStates_[0].hash()\n );\n segments[1] = ChallengeLib.blockStateHash(\n startAndEndMachineStatuses_[1],\n startAndEndGlobalStates_[1].hash()\n );\n uint64 challengeIndex = ++totalChallengesCreated;\n \n assert(challengeIndex != NO_CHAL_INDEX);\n ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\n challenge.wasmModuleRoot = wasmModuleRoot_;\n \n uint64 maxInboxMessagesRead = startAndEndGlobalStates_[1]\n .getInboxPosition();\n if (\n startAndEndMachineStatuses_[1] == MachineStatus.ERRORED ||\n startAndEndGlobalStates_[1].getPositionInMessage() > 0\n ) {\n maxInboxMessagesRead++;\n }\n challenge.maxInboxMessages = maxInboxMessagesRead;\n challenge.next = ChallengeLib.Participant({\n addr: asserter_,\n timeLeft: asserterTimeLeft_\n });\n challenge.current = ChallengeLib.Participant({\n addr: challenger_,\n timeLeft: challengerTimeLeft_\n });\n challenge.lastMoveTimestamp = block.timestamp;\n challenge.mode = ChallengeLib.ChallengeMode.BLOCK;\n emit InitiatedChallenge(\n challengeIndex,\n startAndEndGlobalStates_[0],\n startAndEndGlobalStates_[1]\n );\n function completeBisection(...) {...}\ncompleteBisection(challengeIndex, 0, numBlocks, segments);\n return challengeIndex;\n }"
            },
            {
                "completeBisection": "function completeBisection(\n uint64 challengeIndex,\n uint256 challengeStart,\n uint256 challengeLength,\n bytes32[] memory newSegments\n ) private {\n assert(challengeLength >= 1);\n assert(newSegments.length >= 2);\n bytes32 challengeStateHash = ChallengeLib.hashChallengeState(\n challengeStart,\n challengeLength,\n newSegments\n );\n challenges[challengeIndex].challengeStateHash = challengeStateHash;\n emit Bisected(\n challengeIndex,\n challengeStateHash,\n challengeStart,\n challengeLength,\n newSegments\n );\n }"
            }
        ]
    },
    "det_chain": {
        "OutBoxTransactionExecuted1": [
            {
                "executeTransaction": "function executeTransaction(\n bytes32[] calldata proof,\n uint256 index,\n address l2Sender,\n address to,\n uint256 l2Block,\n uint256 l1Block,\n uint256 l2Timestamp,\n uint256 value,\n bytes calldata data\n ) external {\n bytes32 userTx = calculateItemHash(\n l2Sender,\n to,\n l2Block,\n l1Block,\n l2Timestamp,\n value,\n data\n );\n function recordOutputAsSpent(...) {...}\nfunction executeTransactionImpl(...) {...}\nrecordOutputAsSpent(proof, index, userTx);\n executeTransactionImpl(\n index,\n l2Sender,\n to,\n l2Block,\n l1Block,\n l2Timestamp,\n value,\n data\n );\n }"
            },
            {
                "executeTransactionImpl": "function executeTransactionImpl(\n uint256 outputId,\n address l2Sender,\n address to,\n uint256 l2Block,\n uint256 l1Block,\n uint256 l2Timestamp,\n uint256 value,\n bytes calldata data\n ) internal {\n emit OutBoxTransactionExecuted(to, l2Sender, 0, outputId);\n \n \n L2ToL1Context memory prevContext = context;\n context = L2ToL1Context({\n sender: l2Sender,\n l2Block: uint128(l2Block),\n l1Block: uint128(l1Block),\n timestamp: uint128(l2Timestamp),\n outputId: bytes32(outputId)\n });\n \n function executeBridgeCall(...) {...}\nexecuteBridgeCall(to, value, data);\n context = prevContext;\n }"
            },
            {
                "executeBridgeCall": "function executeBridgeCall(\n address to,\n uint256 value,\n bytes memory data\n ) internal {\n (bool success, bytes memory returndata) = bridge.executeCall(\n to,\n value,\n data\n );\n if (!success) {\n if (returndata.length > 0) {\n \n assembly {\n let returndata_size := mload(returndata)\n revert(add(32, returndata), returndata_size)\n }\n } else {\n revert BridgeCallFailed();\n }\n }\n }"
            }
        ],
        "SendRootUpdated2": [
            {
                "updateSendRoot": "function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external {\n if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);\n roots[root] = l2BlockHash;\n emit SendRootUpdated(root, l2BlockHash);\n }"
            }
        ]
    }
}
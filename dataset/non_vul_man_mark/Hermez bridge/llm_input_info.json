{
    "src_chain": {
        "L1UserTxEvent1": [
            {
                "addL1Transaction": "function addL1Transaction(\n uint256 babyPubKey,\n uint48 fromIdx,\n uint40 loadAmountF,\n uint40 amountF,\n uint32 tokenID,\n uint48 toIdx,\n bytes calldata permit\n ) external payable {\n \n require(\n tokenID < tokenList.length,\n \"Hermez::addL1Transaction: TOKEN_NOT_REGISTERED\"\n );\n \n uint256 loadAmount = _float2Fix(loadAmountF);\n require(\n loadAmount < _LIMIT_LOAD_AMOUNT,\n \"Hermez::addL1Transaction: LOADAMOUNT_EXCEED_LIMIT\"\n );\n \n if (loadAmount > 0) {\n if (tokenID == 0) {\n require(\n loadAmount == msg.value,\n \"Hermez::addL1Transaction: LOADAMOUNT_ETH_DOES_NOT_MATCH\"\n );\n } else {\n require(\n msg.value == 0,\n \"Hermez::addL1Transaction: MSG_VALUE_NOT_EQUAL_0\"\n );\n if (permit.length != 0) {\n _permit(tokenList[tokenID], loadAmount, permit);\n }\n uint256 prevBalance = IERC20(tokenList[tokenID]).balanceOf(\n address(this)\n );\n _safeTransferFrom(\n tokenList[tokenID],\n msg.sender,\n address(this),\n loadAmount\n );\n uint256 postBalance = IERC20(tokenList[tokenID]).balanceOf(\n address(this)\n );\n require(\n postBalance - prevBalance == loadAmount,\n \"Hermez::addL1Transaction: LOADAMOUNT_ERC20_DOES_NOT_MATCH\"\n );\n }\n }\n \n _addL1Transaction(\n msg.sender,\n babyPubKey,\n fromIdx,\n loadAmountF,\n amountF,\n tokenID,\n toIdx\n );\n }"
            },
            {
                "_addL1Transaction": "function _addL1Transaction(\n address ethAddress,\n uint256 babyPubKey,\n uint48 fromIdx,\n uint40 loadAmountF,\n uint40 amountF,\n uint32 tokenID,\n uint48 toIdx\n ) internal {\n uint256 amount = _float2Fix(amountF);\n require(\n amount < _LIMIT_L2TRANSFER_AMOUNT,\n \"Hermez::_addL1Transaction: AMOUNT_EXCEED_LIMIT\"\n );\n \n if (toIdx == 0) {\n require(\n (amount == 0),\n \"Hermez::_addL1Transaction: AMOUNT_MUST_BE_0_IF_NOT_TRANSFER\"\n );\n } else {\n if ((toIdx == _EXIT_IDX)) {\n require(\n (loadAmountF == 0),\n \"Hermez::_addL1Transaction: LOADAMOUNT_MUST_BE_0_IF_EXIT\"\n );\n } else {\n require(\n ((toIdx > _RESERVED_IDX) && (toIdx <= lastIdx)),\n \"Hermez::_addL1Transaction: INVALID_TOIDX\"\n );\n }\n }\n \n if (fromIdx == 0) {\n require(\n babyPubKey != 0,\n \"Hermez::_addL1Transaction: INVALID_CREATE_ACCOUNT_WITH_NO_BABYJUB\"\n );\n } else {\n require(\n (fromIdx > _RESERVED_IDX) && (fromIdx <= lastIdx),\n \"Hermez::_addL1Transaction: INVALID_FROMIDX\"\n );\n require(\n babyPubKey == 0,\n \"Hermez::_addL1Transaction: BABYJUB_MUST_BE_0_IF_NOT_CREATE_ACCOUNT\"\n );\n }\n _l1QueueAddTx(\n ethAddress,\n babyPubKey,\n fromIdx,\n loadAmountF,\n amountF,\n tokenID,\n toIdx\n );\n }"
            },
            {
                "_l1QueueAddTx": "function _l1QueueAddTx(\n address ethAddress,\n uint256 babyPubKey,\n uint48 fromIdx,\n uint40 loadAmountF,\n uint40 amountF,\n uint32 tokenID,\n uint48 toIdx\n ) internal {\n bytes memory l1Tx = abi.encodePacked(\n ethAddress,\n babyPubKey,\n fromIdx,\n loadAmountF,\n amountF,\n tokenID,\n toIdx\n );\n uint256 currentPosition = mapL1TxQueue[nextL1FillingQueue].length /\n _L1_USER_TOTALBYTES;\n \n _concatStorage(mapL1TxQueue[nextL1FillingQueue], l1Tx);\n emit L1UserTxEvent(nextL1FillingQueue, uint8(currentPosition), l1Tx);\n if (currentPosition + 1 >= _MAX_L1_USER_TX) {\n nextL1FillingQueue++;\n }\n }"
            }
        ],
        "WithdrawEvent2": [
            {
                "withdrawMerkleProof": "function withdrawMerkleProof(\n uint32 tokenID,\n uint192 amount,\n uint256 babyPubKey,\n uint32 numExitRoot,\n uint256[] memory siblings,\n uint48 idx,\n bool instantWithdraw\n ) external {\n \n \n \n if (instantWithdraw) {\n require(\n _processInstantWithdrawal(tokenList[tokenID], amount),\n \"Hermez::withdrawMerkleProof: INSTANT_WITHDRAW_WASTED_FOR_THIS_USD_RANGE\"\n );\n }\n \n uint256[4] memory arrayState = _buildTreeState(\n tokenID,\n 0,\n amount,\n babyPubKey,\n msg.sender\n );\n uint256 stateHash = _hash4Elements(arrayState);\n \n uint256 exitRoot = exitRootsMap[numExitRoot];\n \n require(\n exitNullifierMap[numExitRoot][idx] == false,\n \"Hermez::withdrawMerkleProof: WITHDRAW_ALREADY_DONE\"\n );\n \n require(\n _smtVerifier(exitRoot, siblings, idx, stateHash) == true,\n \"Hermez::withdrawMerkleProof: SMT_PROOF_INVALID\"\n );\n \n exitNullifierMap[numExitRoot][idx] = true;\n function _withdrawFunds(...) {...}\n_withdrawFunds(amount, tokenID, instantWithdraw);\n emit WithdrawEvent(idx, numExitRoot, instantWithdraw);\n }"
            },
            {
                "_withdrawFunds": "function _withdrawFunds(\n uint192 amount,\n uint32 tokenID,\n bool instantWithdraw\n ) internal {\n if (instantWithdraw) {\n function _safeTransfer(...) {...}\nfunction _safeApprove(...) {...}\n_safeTransfer(tokenList[tokenID], msg.sender, amount);\n } else {\n if (tokenID == 0) {\n withdrawDelayerContract.deposit{value: amount}(\n msg.sender,\n address(0),\n amount\n );\n } else {\n address tokenAddress = tokenList[tokenID];\n _safeApprove(\n tokenAddress,\n address(withdrawDelayerContract),\n amount\n );\n withdrawDelayerContract.deposit(\n msg.sender,\n tokenAddress,\n amount\n );\n }\n }\n }"
            },
            {
                "_safeTransfer": "function _safeTransfer(address token, address to, uint256 value) internal {\n \n if (token == address(0)) {\n \n (bool success, ) = msg.sender.call{value: value}(new bytes(0));\n require(success, \"Hermez::_safeTransfer: ETH_TRANSFER_FAILED\");\n } else {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_TRANSFER_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeTransfer: ERC20_TRANSFER_FAILED\"\n );\n }\n }"
            },
            {
                "_safeApprove": "function _safeApprove(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_APPROVE_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeApprove: ERC20_APPROVE_FAILED\"\n );\n }"
            }
        ]
    },
    "rel_chain": {
        "ForgeBatch": [
            {
                "forgeBatch": "function forgeBatch(\n uint48 newLastIdx,\n uint256 newStRoot,\n uint256 newExitRoot,\n bytes calldata encodedL1CoordinatorTx,\n bytes calldata l1L2TxsData,\n bytes calldata feeIdxCoordinator,\n uint8 verifierIdx,\n bool l1Batch,\n uint256[2] calldata proofA,\n uint256[2][2] calldata proofB,\n uint256[2] calldata proofC\n ) external virtual {\n \n \n \n \n require(\n msg.sender == tx.origin,\n \"Hermez::forgeBatch: INTENAL_TX_NOT_ALLOWED\"\n );\n \n require(\n hermezAuctionContract.canForge(msg.sender, block.number) == true,\n \"Hermez::forgeBatch: AUCTION_DENIED\"\n );\n if (!l1Batch) {\n require(\n block.number < (lastL1L2Batch + forgeL1L2BatchTimeout), \n \"Hermez::forgeBatch: L1L2BATCH_REQUIRED\"\n );\n }\n \n uint256 input = _constructCircuitInput(\n newLastIdx,\n newStRoot,\n newExitRoot,\n l1Batch,\n verifierIdx\n );\n \n require(\n rollupVerifiers[verifierIdx].verifierInterface.verifyProof(\n proofA,\n proofB,\n proofC,\n [input]\n ),\n \"Hermez::forgeBatch: INVALID_PROOF\"\n );\n \n lastForgedBatch++;\n lastIdx = newLastIdx;\n stateRootMap[lastForgedBatch] = newStRoot;\n exitRootsMap[lastForgedBatch] = newExitRoot;\n l1L2TxsDataHashMap[lastForgedBatch] = sha256(l1L2TxsData);\n uint16 l1UserTxsLen;\n if (l1Batch) {\n \n lastL1L2Batch = uint64(block.number);\n \n function _clearQueue(...) {...}\nl1UserTxsLen = _clearQueue();\n }\n \n hermezAuctionContract.forge(msg.sender);\n emit ForgeBatch(lastForgedBatch, l1UserTxsLen);\n }"
            },
            {
                "_clearQueue": "function _clearQueue() internal returns (uint16) {\n uint16 l1UserTxsLen = uint16(\n mapL1TxQueue[nextL1ToForgeQueue].length / _L1_USER_TOTALBYTES\n );\n delete mapL1TxQueue[nextL1ToForgeQueue];\n nextL1ToForgeQueue++;\n if (nextL1ToForgeQueue == nextL1FillingQueue) {\n nextL1FillingQueue++;\n }\n return l1UserTxsLen;\n }"
            }
        ]
    },
    "det_chain": {
        "WithdrawEvent1": [
            {
                "withdrawCircuit": "function withdrawCircuit(\n uint256[2] calldata proofA,\n uint256[2][2] calldata proofB,\n uint256[2] calldata proofC,\n uint32 tokenID,\n uint192 amount,\n uint32 numExitRoot,\n uint48 idx,\n bool instantWithdraw\n ) external {\n \n if (instantWithdraw) {\n require(\n _processInstantWithdrawal(tokenList[tokenID], amount),\n \"Hermez::withdrawCircuit: INSTANT_WITHDRAW_WASTED_FOR_THIS_USD_RANGE\"\n );\n }\n require(\n exitNullifierMap[numExitRoot][idx] == false,\n \"Hermez::withdrawCircuit: WITHDRAW_ALREADY_DONE\"\n );\n \n uint256 exitRoot = exitRootsMap[numExitRoot];\n uint256 input = uint256(\n sha256(abi.encodePacked(exitRoot, msg.sender, tokenID, amount, idx))\n ) % _RFIELD;\n \n require(\n withdrawVerifier.verifyProof(proofA, proofB, proofC, [input]) ==\n true,\n \"Hermez::withdrawCircuit: INVALID_ZK_PROOF\"\n );\n \n exitNullifierMap[numExitRoot][idx] = true;\n function _withdrawFunds(...) {...}\n_withdrawFunds(amount, tokenID, instantWithdraw);\n emit WithdrawEvent(idx, numExitRoot, instantWithdraw);\n }"
            },
            {
                "_withdrawFunds": "function _withdrawFunds(\n uint192 amount,\n uint32 tokenID,\n bool instantWithdraw\n ) internal {\n if (instantWithdraw) {\n function _safeTransfer(...) {...}\nfunction _safeApprove(...) {...}\n_safeTransfer(tokenList[tokenID], msg.sender, amount);\n } else {\n if (tokenID == 0) {\n withdrawDelayerContract.deposit{value: amount}(\n msg.sender,\n address(0),\n amount\n );\n } else {\n address tokenAddress = tokenList[tokenID];\n _safeApprove(\n tokenAddress,\n address(withdrawDelayerContract),\n amount\n );\n withdrawDelayerContract.deposit(\n msg.sender,\n tokenAddress,\n amount\n );\n }\n }\n }"
            },
            {
                "_safeTransfer": "function _safeTransfer(address token, address to, uint256 value) internal {\n \n if (token == address(0)) {\n \n (bool success, ) = msg.sender.call{value: value}(new bytes(0));\n require(success, \"Hermez::_safeTransfer: ETH_TRANSFER_FAILED\");\n } else {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_TRANSFER_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeTransfer: ERC20_TRANSFER_FAILED\"\n );\n }\n }"
            },
            {
                "_safeApprove": "function _safeApprove(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_APPROVE_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeApprove: ERC20_APPROVE_FAILED\"\n );\n }"
            }
        ],
        "L1UserTxEvent2": [
            {
                "addL1Transaction": "function addL1Transaction(\n uint256 babyPubKey,\n uint48 fromIdx,\n uint40 loadAmountF,\n uint40 amountF,\n uint32 tokenID,\n uint48 toIdx,\n bytes calldata permit\n ) external payable {\n \n require(\n tokenID < tokenList.length,\n \"Hermez::addL1Transaction: TOKEN_NOT_REGISTERED\"\n );\n \n uint256 loadAmount = _float2Fix(loadAmountF);\n require(\n loadAmount < _LIMIT_LOAD_AMOUNT,\n \"Hermez::addL1Transaction: LOADAMOUNT_EXCEED_LIMIT\"\n );\n \n if (loadAmount > 0) {\n if (tokenID == 0) {\n require(\n loadAmount == msg.value,\n \"Hermez::addL1Transaction: LOADAMOUNT_ETH_DOES_NOT_MATCH\"\n );\n } else {\n require(\n msg.value == 0,\n \"Hermez::addL1Transaction: MSG_VALUE_NOT_EQUAL_0\"\n );\n if (permit.length != 0) {\n _permit(tokenList[tokenID], loadAmount, permit);\n }\n uint256 prevBalance = IERC20(tokenList[tokenID]).balanceOf(\n address(this)\n );\n _safeTransferFrom(\n tokenList[tokenID],\n msg.sender,\n address(this),\n loadAmount\n );\n uint256 postBalance = IERC20(tokenList[tokenID]).balanceOf(\n address(this)\n );\n require(\n postBalance - prevBalance == loadAmount,\n \"Hermez::addL1Transaction: LOADAMOUNT_ERC20_DOES_NOT_MATCH\"\n );\n }\n }\n \n _addL1Transaction(\n msg.sender,\n babyPubKey,\n fromIdx,\n loadAmountF,\n amountF,\n tokenID,\n toIdx\n );\n }"
            },
            {
                "_addL1Transaction": "function _addL1Transaction(\n address ethAddress,\n uint256 babyPubKey,\n uint48 fromIdx,\n uint40 loadAmountF,\n uint40 amountF,\n uint32 tokenID,\n uint48 toIdx\n ) internal {\n uint256 amount = _float2Fix(amountF);\n require(\n amount < _LIMIT_L2TRANSFER_AMOUNT,\n \"Hermez::_addL1Transaction: AMOUNT_EXCEED_LIMIT\"\n );\n \n if (toIdx == 0) {\n require(\n (amount == 0),\n \"Hermez::_addL1Transaction: AMOUNT_MUST_BE_0_IF_NOT_TRANSFER\"\n );\n } else {\n if ((toIdx == _EXIT_IDX)) {\n require(\n (loadAmountF == 0),\n \"Hermez::_addL1Transaction: LOADAMOUNT_MUST_BE_0_IF_EXIT\"\n );\n } else {\n require(\n ((toIdx > _RESERVED_IDX) && (toIdx <= lastIdx)),\n \"Hermez::_addL1Transaction: INVALID_TOIDX\"\n );\n }\n }\n \n if (fromIdx == 0) {\n require(\n babyPubKey != 0,\n \"Hermez::_addL1Transaction: INVALID_CREATE_ACCOUNT_WITH_NO_BABYJUB\"\n );\n } else {\n require(\n (fromIdx > _RESERVED_IDX) && (fromIdx <= lastIdx),\n \"Hermez::_addL1Transaction: INVALID_FROMIDX\"\n );\n require(\n babyPubKey == 0,\n \"Hermez::_addL1Transaction: BABYJUB_MUST_BE_0_IF_NOT_CREATE_ACCOUNT\"\n );\n }\n _l1QueueAddTx(\n ethAddress,\n babyPubKey,\n fromIdx,\n loadAmountF,\n amountF,\n tokenID,\n toIdx\n );\n }"
            },
            {
                "_l1QueueAddTx": "function _l1QueueAddTx(\n address ethAddress,\n uint256 babyPubKey,\n uint48 fromIdx,\n uint40 loadAmountF,\n uint40 amountF,\n uint32 tokenID,\n uint48 toIdx\n ) internal {\n bytes memory l1Tx = abi.encodePacked(\n ethAddress,\n babyPubKey,\n fromIdx,\n loadAmountF,\n amountF,\n tokenID,\n toIdx\n );\n uint256 currentPosition = mapL1TxQueue[nextL1FillingQueue].length /\n _L1_USER_TOTALBYTES;\n \n _concatStorage(mapL1TxQueue[nextL1FillingQueue], l1Tx);\n emit L1UserTxEvent(nextL1FillingQueue, uint8(currentPosition), l1Tx);\n if (currentPosition + 1 >= _MAX_L1_USER_TX) {\n nextL1FillingQueue++;\n }\n }"
            }
        ]
    }
}
{
    "src_chain": {
        "MessageDispatched1": [
            {
                "dispatchMessage": "function dispatchMessage(uint256 _toChainId, address _to, bytes calldata _data)\n external\n payable\n override\n onlyMultiMessageSender\n returns (bytes32 msgId)\n {\n address receiverAdapter = receiverAdapters[_toChainId];\n if (receiverAdapter == address(0)) {\n revert Error.ZERO_RECEIVER_ADAPTER();\n }\n string memory destinationChain = chainIdMap[_toChainId];\n if (bytes(destinationChain).length <= 0) {\n revert Error.INVALID_DST_CHAIN();\n }\n msgId = _getNewMessageId(_toChainId, _to);\n _callContract(destinationChain, receiverAdapter, msgId, _to, _data);\n emit MessageDispatched(msgId, msg.sender, _toChainId, _to, _data);\n }"
            },
            {
                "_callContract": "function _callContract(\n string memory destinationChain,\n address receiverAdapter,\n bytes32 msgId,\n address multibridgeReceiver,\n bytes calldata data\n ) internal {\n string memory receiverAdapterInString = StringAddressConversion.toString(receiverAdapter);\n bytes memory payload =\n abi.encode(AdapterPayload(msgId, address(msg.sender), receiverAdapter, multibridgeReceiver, data));\n gasService.payNativeGasForContractCall{value: msg.value}(\n msg.sender, destinationChain, receiverAdapterInString, payload, msg.sender\n );\n gateway.callContract(destinationChain, receiverAdapterInString, payload);\n }"
            }
        ],
        "MessageDispatched2": [
            {
                "dispatchMessage": "function dispatchMessage(uint256 _toChainId, address _to, bytes calldata _data)\n external\n payable\n override\n onlyMultiMessageSender\n returns (bytes32 msgId)\n {\n if (_toChainId == 0) {\n revert Error.ZERO_CHAIN_ID();\n }\n address receiverAdapter = receiverAdapters[_toChainId];\n if (receiverAdapter == address(0)) {\n revert Error.ZERO_RECEIVER_ADAPTER();\n }\n msgId = _getNewMessageId(_toChainId, _to);\n bytes memory payload = abi.encode(AdapterPayload(msgId, msg.sender, receiverAdapter, _to, _data));\n IMessageBus(msgBus).sendMessage{value: msg.value}(receiverAdapter, _toChainId, payload);\n emit MessageDispatched(msgId, msg.sender, _toChainId, _to, _data);\n }"
            }
        ]
    },
    "rel_chain": {
        "ContractCall": [
            {
                "execute": "function execute(\n bytes32 commandId,\n string calldata sourceChain,\n string calldata sourceAddress,\n bytes calldata payload\n ) external override {\n \n if (keccak256(bytes(sourceChain)) != keccak256(bytes(senderChain))) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, keccak256(payload))) {\n revert Error.NOT_APPROVED_BY_GATEWAY();\n }\n \n if (sourceAddress.toAddress() != senderAdapter) {\n revert Error.INVALID_SENDER_ADAPTER();\n }\n \n AdapterPayload memory decodedPayload = abi.decode(payload, (AdapterPayload));\n bytes32 msgId = decodedPayload.msgId;\n \n if (commandIdStatus[commandId] || isMessageExecuted[msgId]) {\n revert MessageIdAlreadyExecuted(msgId);\n }\n \n if (decodedPayload.finalDestination != gac.getMultiMessageReceiver(block.chainid)) {\n revert Error.INVALID_FINAL_DESTINATION();\n }\n isMessageExecuted[msgId] = true;\n commandIdStatus[commandId] = true;\n MessageLibrary.Message memory _data = abi.decode(decodedPayload.data, (MessageLibrary.Message));\n try IMultiMessageReceiver(decodedPayload.finalDestination).receiveMessage(_data, name) {\n emit MessageIdExecuted(_data.srcChainId, msgId);\n } catch (bytes memory lowLevelData) {\n revert MessageFailure(msgId, lowLevelData);\n }\n }"
            },
            {
                "receiveMessage": "function receiveMessage(MessageLibrary.Message calldata _message, string memory _bridgeName)\n external\n override\n onlyReceiverAdapter\n {\n if (_message.dstChainId != block.chainid) {\n revert Error.INVALID_DST_CHAIN();\n }\n if (_message.target == address(0)) {\n revert Error.INVALID_TARGET();\n }\n \n if (_message.srcChainId != 1) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n \n bytes32 msgId = MessageLibrary.computeMsgId(_message);\n if (isDuplicateAdapter[msgId][msg.sender]) {\n revert Error.DUPLICATE_MESSAGE_DELIVERY_BY_ADAPTER();\n }\n if (isExecuted[msgId]) {\n revert Error.MSG_ID_ALREADY_EXECUTED();\n }\n isDuplicateAdapter[msgId][msg.sender] = true;\n \n ++messageVotes[msgId];\n \n ExecutionData memory prevStored = msgReceived[msgId];\n \n if (prevStored.target == address(0)) {\n msgReceived[msgId] = ExecutionData(\n _message.target, _message.callData, _message.nativeValue, _message.nonce, _message.expiration\n );\n }\n emit SingleBridgeMsgReceived(msgId, _bridgeName, _message.nonce, msg.sender);\n }"
            }
        ],
        "executeMessage": [
            {
                "executeMessage": "function executeMessage(\n address _srcContract,\n uint64 _srcChainId,\n bytes calldata _message,\n address \n ) external payable override onlyMessageBus returns (ExecutionStatus) {\n \n \n if (_srcChainId != senderChain) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n if (_srcContract != senderAdapter) {\n revert Error.INVALID_SENDER_ADAPTER();\n }\n \n AdapterPayload memory decodedPayload = abi.decode(_message, (AdapterPayload));\n bytes32 msgId = decodedPayload.msgId;\n \n if (isMessageExecuted[msgId]) {\n revert MessageIdAlreadyExecuted(msgId);\n }\n isMessageExecuted[decodedPayload.msgId] = true;\n \n if (decodedPayload.finalDestination != gac.getMultiMessageReceiver(block.chainid)) {\n revert Error.INVALID_FINAL_DESTINATION();\n }\n MessageLibrary.Message memory _data = abi.decode(decodedPayload.data, (MessageLibrary.Message));\n try IMultiMessageReceiver(decodedPayload.finalDestination).receiveMessage(_data, name) {\n emit MessageIdExecuted(_data.srcChainId, msgId);\n } catch (bytes memory lowLevelData) {\n revert MessageFailure(msgId, lowLevelData);\n }\n return ExecutionStatus.Success;\n }"
            },
            {
                "receiveMessage": "function receiveMessage(MessageLibrary.Message calldata _message, string memory _bridgeName)\n external\n override\n onlyReceiverAdapter\n {\n if (_message.dstChainId != block.chainid) {\n revert Error.INVALID_DST_CHAIN();\n }\n if (_message.target == address(0)) {\n revert Error.INVALID_TARGET();\n }\n \n if (_message.srcChainId != 1) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n \n bytes32 msgId = MessageLibrary.computeMsgId(_message);\n if (isDuplicateAdapter[msgId][msg.sender]) {\n revert Error.DUPLICATE_MESSAGE_DELIVERY_BY_ADAPTER();\n }\n if (isExecuted[msgId]) {\n revert Error.MSG_ID_ALREADY_EXECUTED();\n }\n isDuplicateAdapter[msgId][msg.sender] = true;\n \n ++messageVotes[msgId];\n \n ExecutionData memory prevStored = msgReceived[msgId];\n \n if (prevStored.target == address(0)) {\n msgReceived[msgId] = ExecutionData(\n _message.target, _message.callData, _message.nativeValue, _message.nonce, _message.expiration\n );\n }\n emit SingleBridgeMsgReceived(msgId, _bridgeName, _message.nonce, msg.sender);\n }"
            }
        ]
    },
    "det_chain": {
        "MessageIdExecuted1": [
            {
                "executeMessage": "function executeMessage(bytes32 msgId) external {\n ExecutionData memory _execData = msgReceived[msgId];\n \n if (block.timestamp > _execData.expiration) {\n revert Error.MSG_EXECUTION_PASSED_DEADLINE();\n }\n \n if (isExecuted[msgId]) {\n revert Error.MSG_ID_ALREADY_EXECUTED();\n }\n isExecuted[msgId] = true;\n \n if (messageVotes[msgId] < quorum) {\n revert Error.INVALID_QUORUM_FOR_EXECUTION();\n }\n \n IGovernanceTimelock(governanceTimelock).scheduleTransaction(\n _execData.target, _execData.value, _execData.callData\n );\n emit MessageExecuted(msgId, _execData.target, _execData.value, _execData.nonce, _execData.callData);\n }"
            },
            {
                "scheduleTransaction": "function scheduleTransaction(address _target, uint256 _value, bytes memory _data) external override onlyAdmin {\n if (_target == address(0)) {\n revert Error.INVALID_TARGET();\n }\n \n ++txCounter;\n uint256 eta = block.timestamp + delay;\n scheduledTransaction[txCounter] = keccak256(abi.encodePacked(_target, _value, _data, eta));\n emit TransactionScheduled(txCounter, _target, _value, _data, eta);\n }"
            }
        ],
        "MessageIdExecuted2": [
            {
                "executeTransaction": "function executeTransaction(uint256 _txId, address _target, uint256 _value, bytes memory _data, uint256 _eta)\n external\n payable\n override\n {\n \n if (_txId == 0 || _txId > txCounter) {\n revert Error.INVALID_TX_ID();\n }\n \n if (isExecuted[_txId]) {\n revert Error.TX_ALREADY_EXECUTED();\n }\n \n if (scheduledTransaction[_txId] != keccak256(abi.encodePacked(_target, _value, _data, _eta))) {\n revert Error.INVALID_TX_INPUT();\n }\n \n if (_eta > block.timestamp) {\n revert Error.TX_TIMELOCKED();\n }\n \n if (block.timestamp > _eta + GRACE_PERIOD) {\n revert Error.TX_EXPIRED();\n }\n \n if (msg.value != _value) {\n revert Error.INVALID_MSG_VALUE();\n }\n isExecuted[_txId] = true;\n (bool status,) = _target.call{value: _value}(_data);\n if (!status) {\n revert Error.EXECUTION_FAILS_ON_DST();\n }\n emit TransactionExecuted(_txId, _target, _value, _data, _eta);\n }"
            }
        ]
    }
}
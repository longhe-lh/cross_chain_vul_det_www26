{
    "src_chain": {
        "TransitSwapped1": [
            {
                "swap": "function swap(TransitStructs.TransitSwapDescription calldata desc, TransitStructs.CallbytesDescription calldata callbytesDesc) external payable nonReentrant whenNotPaused {\n require(callbytesDesc.calldatas.length > 0, \"TransitSwap: data should be not zero\");\n require(desc.amount > 0, \"TransitSwap: amount should be greater than 0\");\n require(desc.dstReceiver != address(0), \"TransitSwap: receiver should be not address(0)\");\n require(desc.minReturnAmount > 0, \"TransitSwap: minReturnAmount should be greater than 0\");\n if (callbytesDesc.flag == uint8(TransitStructs.Flag.aggregate)) {\n require(desc.srcToken == callbytesDesc.srcToken, \"TransitSwap: invalid callbytesDesc\");\n }\n bool preTradeModel = !_swap_type_mode[desc.swapType];\n function _beforeSwap(...) {...}\nfunction _afterSwap(...) {...}\n(uint256 swapAmount, uint256 fee, uint256 beforeBalance) = _beforeSwap(preTradeModel, desc);\n {\n \n (bool success, bytes memory result) = _transit_swap.call{value:swapAmount}(abi.encodeWithSelector(0xccbe4007, callbytesDesc));\n if (!success) {\n revert(RevertReasonParser.parse(result,\"TransitSwap:\"));\n }\n }\n (uint256 returnAmount, uint256 postFee) = _afterSwap(preTradeModel, desc, beforeBalance);\n if (postFee > fee) {\n fee = postFee;\n }\n _emitTransit(desc, preTradeModel, fee, returnAmount);\n }"
            },
            {
                "_beforeSwap": "function _beforeSwap(bool preTradeModel, TransitStructs.TransitSwapDescription calldata desc) private returns (uint256 swapAmount, uint256 fee, uint256 beforeBalance) {\n if (preTradeModel) {\n fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, desc.amount, desc.swapType, desc.channel);\n }\n if (TransferHelper.isETH(desc.srcToken)) {\n require(msg.value == desc.amount, \"TransitSwap: invalid msg.value\");\n swapAmount = desc.amount.sub(fee);\n } else {\n if (preTradeModel) {\n TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\n TransferHelper.safeTransfer(desc.srcToken, desc.srcReceiver, desc.amount.sub(fee));\n } else {\n TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, desc.srcReceiver, desc.amount);\n }\n }\n if (TransferHelper.isETH(desc.dstToken)) {\n if (preTradeModel) {\n beforeBalance = desc.dstReceiver.balance;\n } else {\n if (desc.swapType == uint8(TransitStructs.SwapTypes.swap)) {\n beforeBalance = IERC20(desc.wrappedNative).balanceOf(address(this));\n } else {\n beforeBalance = address(this).balance;\n }\n }\n } else {\n if (preTradeModel) {\n beforeBalance = IERC20(desc.dstToken).balanceOf(desc.dstReceiver);\n } else {\n beforeBalance = IERC20(desc.dstToken).balanceOf(address(this));\n }\n }\n }"
            },
            {
                "_afterSwap": "function _afterSwap(bool preTradeModel, TransitStructs.TransitSwapDescription calldata desc, uint256 beforeBalance) private returns (uint256 returnAmount, uint256 fee) {\n if (TransferHelper.isETH(desc.dstToken)) {\n if (preTradeModel) {\n returnAmount = desc.dstReceiver.balance.sub(beforeBalance);\n require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n } else {\n if (desc.swapType == uint8(TransitStructs.SwapTypes.swap)) {\n returnAmount = IERC20(desc.wrappedNative).balanceOf(address(this)).sub(beforeBalance);\n TransferHelper.safeWithdraw(desc.wrappedNative, returnAmount);\n } else {\n returnAmount = address(this).balance.sub(beforeBalance);\n }\n fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, returnAmount, desc.swapType, desc.channel);\n returnAmount = returnAmount.sub(fee);\n require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n TransferHelper.safeTransferETH(desc.dstReceiver, returnAmount);\n }\n } else {\n if (preTradeModel) {\n returnAmount = IERC20(desc.dstToken).balanceOf(desc.dstReceiver).sub(beforeBalance);\n require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n } else {\n returnAmount = IERC20(desc.dstToken).balanceOf(address(this)).sub(beforeBalance);\n fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, returnAmount, desc.swapType, desc.channel);\n returnAmount = returnAmount.sub(fee);\n uint256 receiverBeforeBalance = IERC20(desc.dstToken).balanceOf(desc.dstReceiver);\n TransferHelper.safeTransfer(desc.dstToken, desc.dstReceiver, returnAmount);\n returnAmount = IERC20(desc.dstToken).balanceOf(desc.dstReceiver).sub(receiverBeforeBalance);\n require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n }\n } \n }"
            },
            {
                "cross": "function cross(TransitStructs.TransitSwapDescription calldata desc, TransitStructs.CallbytesDescription calldata callbytesDesc) external payable nonReentrant whenNotPaused {\n require(callbytesDesc.calldatas.length > 0, \"TransitSwap: data should be not zero\");\n require(desc.amount > 0, \"TransitSwap: amount should be greater than 0\");\n require(desc.srcToken == callbytesDesc.srcToken, \"TransitSwap: invalid callbytesDesc\");\n function _beforeCross(...) {...}\n(uint256 swapAmount, uint256 fee, uint256 beforeBalance) = _beforeCross(desc);\n {\n \n (bool success, bytes memory result) = _transit_cross.call{value:swapAmount}(abi.encodeWithSelector(0xccbe4007, callbytesDesc));\n if (!success) {\n revert(RevertReasonParser.parse(result,\"TransitSwap:\"));\n }\n }\n if (!TransferHelper.isETH(desc.srcToken)) {\n require(IERC20(desc.srcToken).balanceOf(_transit_cross) >= beforeBalance, \"TransitSwap: invalid cross\");\n }\n _emitTransit(desc, true, fee, 0);\n }"
            },
            {
                "_beforeCross": "function _beforeCross(TransitStructs.TransitSwapDescription calldata desc) private returns (uint256 swapAmount, uint256 fee, uint256 beforeBalance) {\n fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, desc.amount, desc.swapType, desc.channel);\n if (TransferHelper.isETH(desc.srcToken)) {\n require(msg.value == desc.amount, \"TransitSwap: invalid msg.value\");\n swapAmount = desc.amount.sub(fee);\n } else {\n beforeBalance = IERC20(desc.srcToken).balanceOf(_transit_cross);\n if (fee == 0) {\n TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, _transit_cross, desc.amount);\n } else {\n TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\n TransferHelper.safeTransfer(desc.srcToken, _transit_cross, desc.amount.sub(fee));\n }\n }\n }"
            }
        ]
    },
    "rel_chain": {},
    "det_chain": {
        "TransitSwapped1": [
            {
                "_emitTransit": "function _emitTransit(TransitStructs.TransitSwapDescription calldata desc, bool preTradeModel, uint256 fee, uint256 returnAmount) private {\n emit TransitSwapped(\n desc.srcToken, \n desc.dstToken, \n desc.dstReceiver, \n msg.sender, \n preTradeModel, \n desc.amount, \n returnAmount, \n desc.minReturnAmount, \n fee, \n desc.toChainID, \n desc.channel,\n block.timestamp\n );\n }"
            }
        ]
    }
}
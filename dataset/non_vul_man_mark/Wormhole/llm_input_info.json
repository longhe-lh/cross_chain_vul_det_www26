{
    "src_chain": {
        "transferTokens1": [
            {
                "_transferTokens": "function _transferTokens(address token, uint256 amount, uint256 arbiterFee) internal returns (BridgeStructs.TransferResult memory transferResult) {\n\n \n\n uint16 tokenChain;\n\n bytes32 tokenAddress;\n\n if (isWrappedAsset(token)) {\n\n tokenChain = TokenImplementation(token).chainId();\n\n tokenAddress = TokenImplementation(token).nativeContract();\n\n } else {\n\n tokenChain = chainId();\n\n tokenAddress = bytes32(uint256(uint160(token)));\n\n }\n\n\n\n \n\n (,bytes memory queriedDecimals) = token.staticcall(abi.encodeWithSignature(\"decimals()\"));\n\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n\n\n \n\n amount = deNormalizeAmount(normalizeAmount(amount, decimals), decimals);\n\n\n\n if (tokenChain == chainId()) {\n\n \n\n (,bytes memory queriedBalanceBefore) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\n\n uint256 balanceBefore = abi.decode(queriedBalanceBefore, (uint256));\n\n\n\n \n\n SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n\n\n\n \n\n (,bytes memory queriedBalanceAfter) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\n\n uint256 balanceAfter = abi.decode(queriedBalanceAfter, (uint256));\n\n\n\n \n\n amount = balanceAfter - balanceBefore;\n\n } else {\n\n SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n\n\n\n TokenImplementation(token).burn(address(this), amount);\n\n }\n\n\n\n \n\n uint256 normalizedAmount = normalizeAmount(amount, decimals);\n\n uint256 normalizedArbiterFee = normalizeAmount(arbiterFee, decimals);\n\n\n\n \n\n if (tokenChain == chainId()) {\n\n bridgeOut(token, normalizedAmount);\n\n }\n\n\n\n transferResult = BridgeStructs.TransferResult({\n\n tokenChain : tokenChain,\n\n tokenAddress : tokenAddress,\n\n normalizedAmount : normalizedAmount,\n\n normalizedArbiterFee : normalizedArbiterFee,\n\n wormholeFee : msg.value\n\n });\n\n }"
            },
            {
                "logTransfer": "function logTransfer(\n\n uint16 tokenChain,\n\n bytes32 tokenAddress,\n\n uint256 amount,\n\n uint16 recipientChain,\n\n bytes32 recipient,\n\n uint256 fee,\n\n uint256 callValue,\n\n uint32 nonce\n\n ) internal returns (uint64 sequence) {\n\n require(fee <= amount, \"fee exceeds amount\");\n\n\n\n BridgeStructs.Transfer memory transfer = BridgeStructs.Transfer({\n\n payloadID: 1,\n\n amount: amount,\n\n tokenAddress: tokenAddress,\n\n tokenChain: tokenChain,\n\n to: recipient,\n\n toChain: recipientChain,\n\n fee: fee\n\n });\n\n\n\n sequence = wormhole().publishMessage{value: callValue}(\n\n nonce,\n\n encodeTransfer(transfer),\n\n finality()\n\n );\n\n }"
            }
        ],
        "wrapAndTransferETH2": [
            {
                "_wrapAndTransferETH": "function _wrapAndTransferETH(uint256 arbiterFee) internal returns (BridgeStructs.TransferResult memory transferResult) {\n\n uint wormholeFee = wormhole().messageFee();\n\n\n\n require(wormholeFee < msg.value, \"value is smaller than wormhole fee\");\n\n\n\n uint amount = msg.value - wormholeFee;\n\n\n\n require(arbiterFee <= amount, \"fee is bigger than amount minus wormhole fee\");\n\n\n\n uint normalizedAmount = normalizeAmount(amount, 18);\n\n uint normalizedArbiterFee = normalizeAmount(arbiterFee, 18);\n\n\n\n \n\n uint dust = amount - deNormalizeAmount(normalizedAmount, 18);\n\n if (dust > 0) {\n\n payable(msg.sender).transfer(dust);\n\n }\n\n\n\n \n\n WETH().deposit{\n\n value : amount - dust\n\n }();\n\n\n\n \n\n bridgeOut(address(WETH()), normalizedAmount);\n\n\n\n transferResult = BridgeStructs.TransferResult({\n\n tokenChain : chainId(),\n\n tokenAddress : bytes32(uint256(uint160(address(WETH())))),\n\n normalizedAmount : normalizedAmount,\n\n normalizedArbiterFee : normalizedArbiterFee,\n\n wormholeFee : wormholeFee\n\n });\n\n }"
            },
            {
                "logTransfer": "function logTransfer(\n\n uint16 tokenChain,\n\n bytes32 tokenAddress,\n\n uint256 amount,\n\n uint16 recipientChain,\n\n bytes32 recipient,\n\n uint256 fee,\n\n uint256 callValue,\n\n uint32 nonce\n\n ) internal returns (uint64 sequence) {\n\n require(fee <= amount, \"fee exceeds amount\");\n\n\n\n BridgeStructs.Transfer memory transfer = BridgeStructs.Transfer({\n\n payloadID: 1,\n\n amount: amount,\n\n tokenAddress: tokenAddress,\n\n tokenChain: tokenChain,\n\n to: recipient,\n\n toChain: recipientChain,\n\n fee: fee\n\n });\n\n\n\n sequence = wormhole().publishMessage{value: callValue}(\n\n nonce,\n\n encodeTransfer(transfer),\n\n finality()\n\n );\n\n }"
            }
        ],
        "attestToken3": [
            {
                "attestToken": "function attestToken(address tokenAddress, uint32 nonce) public payable returns (uint64 sequence) {\n\n \n\n (,bytes memory queriedDecimals) = tokenAddress.staticcall(abi.encodeWithSignature(\"decimals()\"));\n\n (,bytes memory queriedSymbol) = tokenAddress.staticcall(abi.encodeWithSignature(\"symbol()\"));\n\n (,bytes memory queriedName) = tokenAddress.staticcall(abi.encodeWithSignature(\"name()\"));\n\n\n\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n\n\n string memory symbolString = abi.decode(queriedSymbol, (string));\n\n string memory nameString = abi.decode(queriedName, (string));\n\n\n\n bytes32 symbol;\n\n bytes32 name;\n\n assembly {\n\n \n\n symbol := mload(add(symbolString, 32))\n\n name := mload(add(nameString, 32))\n\n }\n\n\n\n BridgeStructs.AssetMeta memory meta = BridgeStructs.AssetMeta({\n\n payloadID : 2,\n\n tokenAddress : bytes32(uint256(uint160(tokenAddress))), \n\n tokenChain : chainId(), \n\n decimals : decimals, \n\n symbol : symbol, \n\n name : name \n\n });\n\n\n\n function encodeAssetMeta(...) {...}\nbytes memory encoded = encodeAssetMeta(meta);\n\n\n\n sequence = wormhole().publishMessage{\n\n value : msg.value\n\n }(nonce, encoded, finality());\n\n }"
            }
        ]
    },
    "rel_chain": {
        "parseAndVerifyVM": [
            {
                "verifySignatures": "function verifySignatures(\n bytes32 hash,\n Structs.Signature[] memory signatures,\n Structs.GuardianSet memory guardianSet\n ) public pure returns (bool valid, string memory reason) {\n uint8 lastIndex = 0;\n\n uint256 guardianCount = guardianSet.keys.length;\n\n for (uint i = 0; i < signatures.length; i++) {\n Structs.Signature memory sig = signatures[i];\n\n \n\n require(\n i == 0 || sig.guardianIndex > lastIndex,\n \"signature indices must be ascending\"\n );\n\n lastIndex = sig.guardianIndex;\n\n \n\n \n\n \n\n \n\n \n\n \n\n require(\n sig.guardianIndex < guardianCount,\n \"guardian index out of bounds\"\n );\n\n \n\n if (\n ecrecover(hash, sig.v, sig.r, sig.s) !=\n guardianSet.keys[sig.guardianIndex]\n ) {\n return (false, \"VM signature invalid\");\n }\n }\n\n \n\n return (true, \"\");\n }"
            }
        ]
    },
    "det_chain": {
        "completeTransfer1": [
            {
                "_completeTransfer": "function _completeTransfer(bytes memory encodedVm, bool unwrapWETH) internal returns (bytes memory) {\n\n (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n\n\n require(valid, reason);\n\n function verifyBridgeVM(...) {...}\nrequire(verifyBridgeVM(vm), \"invalid emitter\");\n\n\n\n BridgeStructs.Transfer memory transfer = _parseTransferCommon(vm.payload);\n\n\n\n \n\n address transferRecipient = _truncateAddress(transfer.to);\n\n if (transfer.payloadID == 3) {\n\n require(msg.sender == transferRecipient, \"invalid sender\");\n\n }\n\n\n\n require(!isTransferCompleted(vm.hash), \"transfer already completed\");\n\n setTransferCompleted(vm.hash);\n\n\n\n require(transfer.toChain == chainId(), \"invalid target chain\");\n\n\n\n IERC20 transferToken;\n\n if (transfer.tokenChain == chainId()) {\n\n transferToken = IERC20(_truncateAddress(transfer.tokenAddress));\n\n\n\n \n\n bridgedIn(address(transferToken), transfer.amount);\n\n } else {\n\n address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\n\n require(wrapped != address(0), \"no wrapper for this token created yet\");\n\n\n\n transferToken = IERC20(wrapped);\n\n }\n\n\n\n require(unwrapWETH == false || address(transferToken) == address(WETH()), \"invalid token, can only unwrap WETH\");\n\n\n\n \n\n (,bytes memory queriedDecimals) = address(transferToken).staticcall(abi.encodeWithSignature(\"decimals()\"));\n\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n\n\n \n\n uint256 nativeAmount = deNormalizeAmount(transfer.amount, decimals);\n\n uint256 nativeFee = deNormalizeAmount(transfer.fee, decimals);\n\n\n\n \n\n if (nativeFee > 0 && transferRecipient != msg.sender) {\n\n require(nativeFee <= nativeAmount, \"fee higher than transferred amount\");\n\n\n\n if (unwrapWETH) {\n\n WETH().withdraw(nativeFee);\n\n\n\n payable(msg.sender).transfer(nativeFee);\n\n } else {\n\n if (transfer.tokenChain != chainId()) {\n\n \n\n TokenImplementation(address(transferToken)).mint(msg.sender, nativeFee);\n\n } else {\n\n SafeERC20.safeTransfer(transferToken, msg.sender, nativeFee);\n\n }\n\n }\n\n } else {\n\n \n\n nativeFee = 0;\n\n }\n\n\n\n \n\n uint transferAmount = nativeAmount - nativeFee;\n\n\n\n if (unwrapWETH) {\n\n WETH().withdraw(transferAmount);\n\n\n\n payable(transferRecipient).transfer(transferAmount);\n\n } else {\n\n if (transfer.tokenChain != chainId()) {\n\n \n\n TokenImplementation(address(transferToken)).mint(transferRecipient, transferAmount);\n\n } else {\n\n SafeERC20.safeTransfer(transferToken, transferRecipient, transferAmount);\n\n }\n\n }\n\n\n\n return vm.payload;\n\n }"
            }
        ],
        "completeTransferAndUnwrapETH2": [
            {
                "_completeTransfer": "function _completeTransfer(bytes memory encodedVm, bool unwrapWETH) internal returns (bytes memory) {\n\n (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n\n\n require(valid, reason);\n\n function verifyBridgeVM(...) {...}\nrequire(verifyBridgeVM(vm), \"invalid emitter\");\n\n\n\n BridgeStructs.Transfer memory transfer = _parseTransferCommon(vm.payload);\n\n\n\n \n\n address transferRecipient = _truncateAddress(transfer.to);\n\n if (transfer.payloadID == 3) {\n\n require(msg.sender == transferRecipient, \"invalid sender\");\n\n }\n\n\n\n require(!isTransferCompleted(vm.hash), \"transfer already completed\");\n\n setTransferCompleted(vm.hash);\n\n\n\n require(transfer.toChain == chainId(), \"invalid target chain\");\n\n\n\n IERC20 transferToken;\n\n if (transfer.tokenChain == chainId()) {\n\n transferToken = IERC20(_truncateAddress(transfer.tokenAddress));\n\n\n\n \n\n bridgedIn(address(transferToken), transfer.amount);\n\n } else {\n\n address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\n\n require(wrapped != address(0), \"no wrapper for this token created yet\");\n\n\n\n transferToken = IERC20(wrapped);\n\n }\n\n\n\n require(unwrapWETH == false || address(transferToken) == address(WETH()), \"invalid token, can only unwrap WETH\");\n\n\n\n \n\n (,bytes memory queriedDecimals) = address(transferToken).staticcall(abi.encodeWithSignature(\"decimals()\"));\n\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n\n\n \n\n uint256 nativeAmount = deNormalizeAmount(transfer.amount, decimals);\n\n uint256 nativeFee = deNormalizeAmount(transfer.fee, decimals);\n\n\n\n \n\n if (nativeFee > 0 && transferRecipient != msg.sender) {\n\n require(nativeFee <= nativeAmount, \"fee higher than transferred amount\");\n\n\n\n if (unwrapWETH) {\n\n WETH().withdraw(nativeFee);\n\n\n\n payable(msg.sender).transfer(nativeFee);\n\n } else {\n\n if (transfer.tokenChain != chainId()) {\n\n \n\n TokenImplementation(address(transferToken)).mint(msg.sender, nativeFee);\n\n } else {\n\n SafeERC20.safeTransfer(transferToken, msg.sender, nativeFee);\n\n }\n\n }\n\n } else {\n\n \n\n nativeFee = 0;\n\n }\n\n\n\n \n\n uint transferAmount = nativeAmount - nativeFee;\n\n\n\n if (unwrapWETH) {\n\n WETH().withdraw(transferAmount);\n\n\n\n payable(transferRecipient).transfer(transferAmount);\n\n } else {\n\n if (transfer.tokenChain != chainId()) {\n\n \n\n TokenImplementation(address(transferToken)).mint(transferRecipient, transferAmount);\n\n } else {\n\n SafeERC20.safeTransfer(transferToken, transferRecipient, transferAmount);\n\n }\n\n }\n\n\n\n return vm.payload;\n\n }"
            }
        ],
        "updateWrapped3": [
            {
                "updateWrapped": "function updateWrapped(bytes memory encodedVm) external returns (address token) {\n\n (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n\n\n require(valid, reason);\n\n function verifyBridgeVM(...) {...}\nrequire(verifyBridgeVM(vm), \"invalid emitter\");\n\n\n\n BridgeStructs.AssetMeta memory meta = parseAssetMeta(vm.payload);\n\n return _updateWrapped(meta, vm.sequence);\n\n }"
            },
            {
                "_updateWrapped": "function _updateWrapped(BridgeStructs.AssetMeta memory meta, uint64 sequence) internal returns (address token) {\n\n address wrapped = wrappedAsset(meta.tokenChain, meta.tokenAddress);\n\n require(wrapped != address(0), \"wrapped asset does not exists\");\n\n\n\n \n\n TokenImplementation(wrapped).updateDetails(bytes32ToString(meta.name), bytes32ToString(meta.symbol), sequence);\n\n\n\n return wrapped;\n\n }"
            }
        ]
    }
}
Folder Structure
--------------------------------------------------
contracts/
    Address.sol
    BeaconProxy.sol
    Bridge.sol
    BridgeGetters.sol
    BridgeGovernance.sol
    BridgeImplementation.sol
    BridgeSetters.sol
    BridgeState.sol
    BridgeStructs.sol
    BytesLib.sol
    CircleIntegration.sol
    CircleIntegrationGetters.sol
    CircleIntegrationGovernance.sol
    CircleIntegrationImplementation.sol
    CircleIntegrationMessages.sol
    CircleIntegrationProxy.sol
    CircleIntegrationSetters.sol
    CircleIntegrationState.sol
    CircleIntegrationStructs.sol
    Context.sol
    Counters.sol
    draft-IERC1822.sol
    draft-IERC20Permit.sol
    ECDSA.sol
    ERC165.sol
    ERC1967Proxy.sol
    ERC1967Upgrade.sol
    ERC20.sol
    Getters.sol
    Governance.sol
    GovernanceStructs.sol
    IBeacon.sol
    ICircleBridge.sol
    ICircleIntegration.sol
    IERC165.sol
    IERC20.sol
    IERC721.sol
    IERC721Metadata.sol
    IERC721Receiver.sol
    IMessageTransmitter.sol
    Implementation.sol
    ITokenMinter.sol
    IWormhole.sol
    Messages.sol
    NFT.sol
    NFTBridge.sol
    NFTBridgeEntrypoint.sol
    NFTBridgeGetters.sol
    NFTBridgeGovernance.sol
    NFTBridgeImplementation.sol
    NFTBridgeSetters.sol
    NFTBridgeSetup.sol
    NFTBridgeState.sol
    NFTBridgeStructs.sol
    NFTImplementation.sol
    NFTState.sol
    Ownable.sol
    Proxy.sol
    ReentrancyGuard.sol
    SafeERC20.sol
    SafeMath.sol
    Setters.sol
    State.sol
    StorageSlot.sol
    Strings.sol
    Structs.sol
    Token.sol
    TokenBridge.sol
    TokenImplementation.sol
    TokenState.sol
    Wormhole.sol
    WrappedAsset.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\BeaconProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IBeacon.sol";

import "../Proxy.sol";

import "../ERC1967/ERC1967Upgrade.sol";



/**

 * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.

 *

 * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't

 * conflict with the storage layout of the implementation behind the proxy.

 *

 * _Available since v3.4._

 */

contract BeaconProxy is Proxy, ERC1967Upgrade {

    /**

     * @dev Initializes the proxy with `beacon`.

     *

     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This

     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity

     * constructor.

     *

     * Requirements:

     *

     * - `beacon` must be a contract with the interface {IBeacon}.

     */

    constructor(address beacon, bytes memory data) payable {

        assert(_BEACON_SLOT == bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1));

        _upgradeBeaconToAndCall(beacon, data, false);

    }



    /**

     * @dev Returns the current beacon address.

     */

    function _beacon() internal view virtual returns (address) {

        return _getBeacon();

    }



    /**

     * @dev Returns the current implementation address of the associated beacon.

     */

    function _implementation() internal view virtual override returns (address) {

        return IBeacon(_getBeacon()).implementation();

    }



    /**

     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.

     *

     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.

     *

     * Requirements:

     *

     * - `beacon` must be a contract.

     * - The implementation returned by `beacon` must be a contract.

     */

    function _setBeacon(address beacon, bytes memory data) internal virtual {

        _upgradeBeaconToAndCall(beacon, data, false);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Bridge.sol
File type: .sol
// contracts/Bridge.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



import "../libraries/external/BytesLib.sol";



import "./BridgeGetters.sol";

import "./BridgeSetters.sol";

import "./BridgeStructs.sol";

import "./BridgeGovernance.sol";



import "./token/Token.sol";

import "./token/TokenImplementation.sol";



contract Bridge is BridgeGovernance, ReentrancyGuard {

    using BytesLib for bytes;



    /*

     *  @dev Produce a AssetMeta message for a given token

     */

    function attestToken(address tokenAddress, uint32 nonce) public payable returns (uint64 sequence) {

        // decimals, symbol & token are not part of the core ERC20 token standard, so we need to support contracts that dont implement them

        (,bytes memory queriedDecimals) = tokenAddress.staticcall(abi.encodeWithSignature("decimals()"));

        (,bytes memory queriedSymbol) = tokenAddress.staticcall(abi.encodeWithSignature("symbol()"));

        (,bytes memory queriedName) = tokenAddress.staticcall(abi.encodeWithSignature("name()"));



        uint8 decimals = abi.decode(queriedDecimals, (uint8));



        string memory symbolString = abi.decode(queriedSymbol, (string));

        string memory nameString = abi.decode(queriedName, (string));



        bytes32 symbol;

        bytes32 name;

        assembly {

            // first 32 bytes hold string length

            symbol := mload(add(symbolString, 32))

            name := mload(add(nameString, 32))

        }



        BridgeStructs.AssetMeta memory meta = BridgeStructs.AssetMeta({

        payloadID : 2,

        tokenAddress : bytes32(uint256(uint160(tokenAddress))), // Address of the token. Left-zero-padded if shorter than 32 bytes

        tokenChain : chainId(), // Chain ID of the token

        decimals : decimals, // Number of decimals of the token (big-endian uint8)

        symbol : symbol, // Symbol of the token (UTF-8)

        name : name // Name of the token (UTF-8)

        });



        bytes memory encoded = encodeAssetMeta(meta);



        sequence = wormhole().publishMessage{

            value : msg.value

        }(nonce, encoded, finality());

    }



    /*

     *  @notice Send eth through portal by first wrapping it to WETH.

     */

    function wrapAndTransferETH(

        uint16 recipientChain,

        bytes32 recipient,

        uint256 arbiterFee,

        uint32 nonce

    ) public payable returns (uint64 sequence) {

        BridgeStructs.TransferResult

            memory transferResult = _wrapAndTransferETH(arbiterFee);

        sequence = logTransfer(

            transferResult.tokenChain,

            transferResult.tokenAddress,

            transferResult.normalizedAmount,

            recipientChain,

            recipient,

            transferResult.normalizedArbiterFee,

            transferResult.wormholeFee,

            nonce

        );

    }



    /*

     *  @notice Send eth through portal by first wrapping it.

     *

     *  @dev This type of transfer is called a "contract-controlled transfer".

     *  There are three differences from a regular token transfer:

     *  1) Additional arbitrary payload can be attached to the message

     *  2) Only the recipient (typically a contract) can redeem the transaction

     *  3) The sender's address (msg.sender) is also included in the transaction payload

     *

     *  With these three additional components, xDapps can implement cross-chain

     *  composable interactions.

     */

    function wrapAndTransferETHWithPayload(

        uint16 recipientChain,

        bytes32 recipient,

        uint32 nonce,

        bytes memory payload

    ) public payable returns (uint64 sequence) {

        BridgeStructs.TransferResult

            memory transferResult = _wrapAndTransferETH(0);

        sequence = logTransferWithPayload(

            transferResult.tokenChain,

            transferResult.tokenAddress,

            transferResult.normalizedAmount,

            recipientChain,

            recipient,

            transferResult.wormholeFee,

            nonce,

            payload

        );

    }



    function _wrapAndTransferETH(uint256 arbiterFee) internal returns (BridgeStructs.TransferResult memory transferResult) {

        uint wormholeFee = wormhole().messageFee();



        require(wormholeFee < msg.value, "value is smaller than wormhole fee");



        uint amount = msg.value - wormholeFee;



        require(arbiterFee <= amount, "fee is bigger than amount minus wormhole fee");



        uint normalizedAmount = normalizeAmount(amount, 18);

        uint normalizedArbiterFee = normalizeAmount(arbiterFee, 18);



        // refund dust

        uint dust = amount - deNormalizeAmount(normalizedAmount, 18);

        if (dust > 0) {

            payable(msg.sender).transfer(dust);

        }



        // deposit into WETH

        WETH().deposit{

            value : amount - dust

        }();



        // track and check outstanding token amounts

        bridgeOut(address(WETH()), normalizedAmount);



        transferResult = BridgeStructs.TransferResult({

            tokenChain : chainId(),

            tokenAddress : bytes32(uint256(uint160(address(WETH())))),

            normalizedAmount : normalizedAmount,

            normalizedArbiterFee : normalizedArbiterFee,

            wormholeFee : wormholeFee

        });

    }



    /*

     *  @notice Send ERC20 token through portal.

     */

    function transferTokens(

        address token,

        uint256 amount,

        uint16 recipientChain,

        bytes32 recipient,

        uint256 arbiterFee,

        uint32 nonce

    ) public payable nonReentrant returns (uint64 sequence) {

        BridgeStructs.TransferResult memory transferResult = _transferTokens(

            token,

            amount,

            arbiterFee

        );

        sequence = logTransfer(

            transferResult.tokenChain,

            transferResult.tokenAddress,

            transferResult.normalizedAmount,

            recipientChain,

            recipient,

            transferResult.normalizedArbiterFee,

            transferResult.wormholeFee,

            nonce

        );

    }



    /*

     *  @notice Send ERC20 token through portal.

     *

     *  @dev This type of transfer is called a "contract-controlled transfer".

     *  There are three differences from a regular token transfer:

     *  1) Additional arbitrary payload can be attached to the message

     *  2) Only the recipient (typically a contract) can redeem the transaction

     *  3) The sender's address (msg.sender) is also included in the transaction payload

     *

     *  With these three additional components, xDapps can implement cross-chain

     *  composable interactions.

     */

    function transferTokensWithPayload(

        address token,

        uint256 amount,

        uint16 recipientChain,

        bytes32 recipient,

        uint32 nonce,

        bytes memory payload

    ) public payable nonReentrant returns (uint64 sequence) {

        BridgeStructs.TransferResult memory transferResult = _transferTokens(

            token,

            amount,

            0

        );

        sequence = logTransferWithPayload(

            transferResult.tokenChain,

            transferResult.tokenAddress,

            transferResult.normalizedAmount,

            recipientChain,

            recipient,

            transferResult.wormholeFee,

            nonce,

            payload

        );

    }



    /*

     *  @notice Initiate a transfer

     */

    function _transferTokens(address token, uint256 amount, uint256 arbiterFee) internal returns (BridgeStructs.TransferResult memory transferResult) {

        // determine token parameters

        uint16 tokenChain;

        bytes32 tokenAddress;

        if (isWrappedAsset(token)) {

            tokenChain = TokenImplementation(token).chainId();

            tokenAddress = TokenImplementation(token).nativeContract();

        } else {

            tokenChain = chainId();

            tokenAddress = bytes32(uint256(uint160(token)));

        }



        // query tokens decimals

        (,bytes memory queriedDecimals) = token.staticcall(abi.encodeWithSignature("decimals()"));

        uint8 decimals = abi.decode(queriedDecimals, (uint8));



        // don't deposit dust that can not be bridged due to the decimal shift

        amount = deNormalizeAmount(normalizeAmount(amount, decimals), decimals);



        if (tokenChain == chainId()) {

            // query own token balance before transfer

            (,bytes memory queriedBalanceBefore) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));

            uint256 balanceBefore = abi.decode(queriedBalanceBefore, (uint256));



            // transfer tokens

            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);



            // query own token balance after transfer

            (,bytes memory queriedBalanceAfter) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));

            uint256 balanceAfter = abi.decode(queriedBalanceAfter, (uint256));



            // correct amount for potential transfer fees

            amount = balanceAfter - balanceBefore;

        } else {

            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);



            TokenImplementation(token).burn(address(this), amount);

        }



        // normalize amounts decimals

        uint256 normalizedAmount = normalizeAmount(amount, decimals);

        uint256 normalizedArbiterFee = normalizeAmount(arbiterFee, decimals);



        // track and check outstanding token amounts

        if (tokenChain == chainId()) {

            bridgeOut(token, normalizedAmount);

        }



        transferResult = BridgeStructs.TransferResult({

            tokenChain : tokenChain,

            tokenAddress : tokenAddress,

            normalizedAmount : normalizedAmount,

            normalizedArbiterFee : normalizedArbiterFee,

            wormholeFee : msg.value

        });

    }



    function normalizeAmount(uint256 amount, uint8 decimals) internal pure returns(uint256){

        if (decimals > 8) {

            amount /= 10 ** (decimals - 8);

        }

        return amount;

    }



    function deNormalizeAmount(uint256 amount, uint8 decimals) internal pure returns(uint256){

        if (decimals > 8) {

            amount *= 10 ** (decimals - 8);

        }

        return amount;

    }



    function logTransfer(

        uint16 tokenChain,

        bytes32 tokenAddress,

        uint256 amount,

        uint16 recipientChain,

        bytes32 recipient,

        uint256 fee,

        uint256 callValue,

        uint32 nonce

    ) internal returns (uint64 sequence) {

        require(fee <= amount, "fee exceeds amount");



        BridgeStructs.Transfer memory transfer = BridgeStructs.Transfer({

            payloadID: 1,

            amount: amount,

            tokenAddress: tokenAddress,

            tokenChain: tokenChain,

            to: recipient,

            toChain: recipientChain,

            fee: fee

        });



        sequence = wormhole().publishMessage{value: callValue}(

            nonce,

            encodeTransfer(transfer),

            finality()

        );

    }



    /*

     * @dev Publish a token transfer message with payload.

     *

     * @return The sequence number of the published message.

     */

    function logTransferWithPayload(

        uint16 tokenChain,

        bytes32 tokenAddress,

        uint256 amount,

        uint16 recipientChain,

        bytes32 recipient,

        uint256 callValue,

        uint32 nonce,

        bytes memory payload

    ) internal returns (uint64 sequence) {

        BridgeStructs.TransferWithPayload memory transfer = BridgeStructs

            .TransferWithPayload({

                payloadID: 3,

                amount: amount,

                tokenAddress: tokenAddress,

                tokenChain: tokenChain,

                to: recipient,

                toChain: recipientChain,

                fromAddress : bytes32(uint256(uint160(msg.sender))),

                payload: payload

            });



        sequence = wormhole().publishMessage{value: callValue}(

            nonce,

            encodeTransferWithPayload(transfer),

            finality()

        );

    }



    function updateWrapped(bytes memory encodedVm) external returns (address token) {

        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);



        require(valid, reason);

        require(verifyBridgeVM(vm), "invalid emitter");



        BridgeStructs.AssetMeta memory meta = parseAssetMeta(vm.payload);

        return _updateWrapped(meta, vm.sequence);

    }



    function _updateWrapped(BridgeStructs.AssetMeta memory meta, uint64 sequence) internal returns (address token) {

        address wrapped = wrappedAsset(meta.tokenChain, meta.tokenAddress);

        require(wrapped != address(0), "wrapped asset does not exists");



        // Update metadata

        TokenImplementation(wrapped).updateDetails(bytes32ToString(meta.name), bytes32ToString(meta.symbol), sequence);



        return wrapped;

    }



    function createWrapped(bytes memory encodedVm) external returns (address token) {

        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);



        require(valid, reason);

        require(verifyBridgeVM(vm), "invalid emitter");



        BridgeStructs.AssetMeta memory meta = parseAssetMeta(vm.payload);

        return _createWrapped(meta, vm.sequence);

    }



    // Creates a wrapped asset using AssetMeta

    function _createWrapped(BridgeStructs.AssetMeta memory meta, uint64 sequence) internal returns (address token) {

        require(meta.tokenChain != chainId(), "can only wrap tokens from foreign chains");

        require(wrappedAsset(meta.tokenChain, meta.tokenAddress) == address(0), "wrapped asset already exists");



        // initialize the TokenImplementation

        bytes memory initialisationArgs = abi.encodeWithSelector(

            TokenImplementation.initialize.selector,

            bytes32ToString(meta.name),

            bytes32ToString(meta.symbol),

            meta.decimals,

            sequence,



            address(this),



            meta.tokenChain,

            meta.tokenAddress

        );



        // initialize the BeaconProxy

        bytes memory constructorArgs = abi.encode(address(this), initialisationArgs);



        // deployment code

        bytes memory bytecode = abi.encodePacked(type(BridgeToken).creationCode, constructorArgs);



        bytes32 salt = keccak256(abi.encodePacked(meta.tokenChain, meta.tokenAddress));



        assembly {

            token := create2(0, add(bytecode, 0x20), mload(bytecode), salt)



            if iszero(extcodesize(token)) {

                revert(0, 0)

            }

        }



        setWrappedAsset(meta.tokenChain, meta.tokenAddress, token);

    }



    /*

     * @notice Complete a contract-controlled transfer of an ERC20 token.

     *

     * @dev The transaction can only be redeemed by the recipient, typically a

     * contract.

     *

     * @param encodedVm    A byte array containing a VAA signed by the guardians.

     *

     * @return The byte array representing a BridgeStructs.TransferWithPayload.

     */

    function completeTransferWithPayload(bytes memory encodedVm) public returns (bytes memory) {

        return _completeTransfer(encodedVm, false);

    }



    /*

     * @notice Complete a contract-controlled transfer of WETH, and unwrap to ETH.

     *

     * @dev The transaction can only be redeemed by the recipient, typically a

     * contract.

     *

     * @param encodedVm    A byte array containing a VAA signed by the guardians.

     *

     * @return The byte array representing a BridgeStructs.TransferWithPayload.

     */

    function completeTransferAndUnwrapETHWithPayload(bytes memory encodedVm) public returns (bytes memory) {

        return _completeTransfer(encodedVm, true);

    }



    /*

     * @notice Complete a transfer of an ERC20 token.

     *

     * @dev The msg.sender gets paid the associated fee.

     *

     * @param encodedVm A byte array containing a VAA signed by the guardians.

     */

    function completeTransfer(bytes memory encodedVm) public {

        _completeTransfer(encodedVm, false);

    }



    /*

     * @notice Complete a transfer of WETH and unwrap to eth.

     *

     * @dev The msg.sender gets paid the associated fee.

     *

     * @param encodedVm A byte array containing a VAA signed by the guardians.

     */

    function completeTransferAndUnwrapETH(bytes memory encodedVm) public {

        _completeTransfer(encodedVm, true);

    }



    /*

     * @dev Truncate a 32 byte array to a 20 byte address.

     *      Reverts if the array contains non-0 bytes in the first 12 bytes.

     *

     * @param bytes32 bytes The 32 byte array to be converted.

     */

    function _truncateAddress(bytes32 b) internal pure returns (address) {

        require(bytes12(b) == 0, "invalid EVM address");

        return address(uint160(uint256(b)));

    }



    // Execute a Transfer message

    function _completeTransfer(bytes memory encodedVm, bool unwrapWETH) internal returns (bytes memory) {

        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);



        require(valid, reason);

        require(verifyBridgeVM(vm), "invalid emitter");



        BridgeStructs.Transfer memory transfer = _parseTransferCommon(vm.payload);



        // payload 3 must be redeemed by the designated proxy contract

        address transferRecipient = _truncateAddress(transfer.to);

        if (transfer.payloadID == 3) {

            require(msg.sender == transferRecipient, "invalid sender");

        }



        require(!isTransferCompleted(vm.hash), "transfer already completed");

        setTransferCompleted(vm.hash);



        require(transfer.toChain == chainId(), "invalid target chain");



        IERC20 transferToken;

        if (transfer.tokenChain == chainId()) {

            transferToken = IERC20(_truncateAddress(transfer.tokenAddress));



            // track outstanding token amounts

            bridgedIn(address(transferToken), transfer.amount);

        } else {

            address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);

            require(wrapped != address(0), "no wrapper for this token created yet");



            transferToken = IERC20(wrapped);

        }



        require(unwrapWETH == false || address(transferToken) == address(WETH()), "invalid token, can only unwrap WETH");



        // query decimals

        (,bytes memory queriedDecimals) = address(transferToken).staticcall(abi.encodeWithSignature("decimals()"));

        uint8 decimals = abi.decode(queriedDecimals, (uint8));



        // adjust decimals

        uint256 nativeAmount = deNormalizeAmount(transfer.amount, decimals);

        uint256 nativeFee = deNormalizeAmount(transfer.fee, decimals);



        // transfer fee to arbiter

        if (nativeFee > 0 && transferRecipient != msg.sender) {

            require(nativeFee <= nativeAmount, "fee higher than transferred amount");



            if (unwrapWETH) {

                WETH().withdraw(nativeFee);



                payable(msg.sender).transfer(nativeFee);

            } else {

                if (transfer.tokenChain != chainId()) {

                    // mint wrapped asset

                    TokenImplementation(address(transferToken)).mint(msg.sender, nativeFee);

                } else {

                    SafeERC20.safeTransfer(transferToken, msg.sender, nativeFee);

                }

            }

        } else {

            // set fee to zero in case transferRecipient == feeRecipient

            nativeFee = 0;

        }



        // transfer bridged amount to recipient

        uint transferAmount = nativeAmount - nativeFee;



        if (unwrapWETH) {

            WETH().withdraw(transferAmount);



            payable(transferRecipient).transfer(transferAmount);

        } else {

            if (transfer.tokenChain != chainId()) {

                // mint wrapped asset

                TokenImplementation(address(transferToken)).mint(transferRecipient, transferAmount);

            } else {

                SafeERC20.safeTransfer(transferToken, transferRecipient, transferAmount);

            }

        }



        return vm.payload;

    }



    function bridgeOut(address token, uint normalizedAmount) internal {

        uint outstanding = outstandingBridged(token);

        require(outstanding + normalizedAmount <= type(uint64).max, "transfer exceeds max outstanding bridged token amount");

        setOutstandingBridged(token, outstanding + normalizedAmount);

    }



    function bridgedIn(address token, uint normalizedAmount) internal {

        setOutstandingBridged(token, outstandingBridged(token) - normalizedAmount);

    }



    function verifyBridgeVM(IWormhole.VM memory vm) internal view returns (bool){

        require(!isFork(), "invalid fork");

        return bridgeContracts(vm.emitterChainId) == vm.emitterAddress;

    }



    function encodeAssetMeta(BridgeStructs.AssetMeta memory meta) public pure returns (bytes memory encoded) {

        encoded = abi.encodePacked(

            meta.payloadID,

            meta.tokenAddress,

            meta.tokenChain,

            meta.decimals,

            meta.symbol,

            meta.name

        );

    }



    function encodeTransfer(BridgeStructs.Transfer memory transfer) public pure returns (bytes memory encoded) {

        encoded = abi.encodePacked(

            transfer.payloadID,

            transfer.amount,

            transfer.tokenAddress,

            transfer.tokenChain,

            transfer.to,

            transfer.toChain,

            transfer.fee

        );

    }



    function encodeTransferWithPayload(BridgeStructs.TransferWithPayload memory transfer) public pure returns (bytes memory encoded) {

        encoded = abi.encodePacked(

            transfer.payloadID,

            transfer.amount,

            transfer.tokenAddress,

            transfer.tokenChain,

            transfer.to,

            transfer.toChain,

            transfer.fromAddress,

            transfer.payload

        );

    }



    function parsePayloadID(bytes memory encoded) public pure returns (uint8 payloadID) {

        payloadID = encoded.toUint8(0);

    }



    /*

     * @dev Parse a token metadata attestation (payload id 2)

     */

    function parseAssetMeta(bytes memory encoded) public pure returns (BridgeStructs.AssetMeta memory meta) {

        uint index = 0;



        meta.payloadID = encoded.toUint8(index);

        index += 1;



        require(meta.payloadID == 2, "invalid AssetMeta");



        meta.tokenAddress = encoded.toBytes32(index);

        index += 32;



        meta.tokenChain = encoded.toUint16(index);

        index += 2;



        meta.decimals = encoded.toUint8(index);

        index += 1;



        meta.symbol = encoded.toBytes32(index);

        index += 32;



        meta.name = encoded.toBytes32(index);

        index += 32;



        require(encoded.length == index, "invalid AssetMeta");

    }



    /*

     * @dev Parse a token transfer (payload id 1).

     *

     * @params encoded The byte array corresponding to the token transfer (not

     *                 the whole VAA, only the payload)

     */

    function parseTransfer(bytes memory encoded) public pure returns (BridgeStructs.Transfer memory transfer) {

        uint index = 0;



        transfer.payloadID = encoded.toUint8(index);

        index += 1;



        require(transfer.payloadID == 1, "invalid Transfer");



        transfer.amount = encoded.toUint256(index);

        index += 32;



        transfer.tokenAddress = encoded.toBytes32(index);

        index += 32;



        transfer.tokenChain = encoded.toUint16(index);

        index += 2;



        transfer.to = encoded.toBytes32(index);

        index += 32;



        transfer.toChain = encoded.toUint16(index);

        index += 2;



        transfer.fee = encoded.toUint256(index);

        index += 32;



        require(encoded.length == index, "invalid Transfer");

    }



    /*

     * @dev Parse a token transfer with payload (payload id 3).

     *

     * @params encoded The byte array corresponding to the token transfer (not

     *                 the whole VAA, only the payload)

     */

    function parseTransferWithPayload(bytes memory encoded) public pure returns (BridgeStructs.TransferWithPayload memory transfer) {

        uint index = 0;



        transfer.payloadID = encoded.toUint8(index);

        index += 1;



        require(transfer.payloadID == 3, "invalid Transfer");



        transfer.amount = encoded.toUint256(index);

        index += 32;



        transfer.tokenAddress = encoded.toBytes32(index);

        index += 32;



        transfer.tokenChain = encoded.toUint16(index);

        index += 2;



        transfer.to = encoded.toBytes32(index);

        index += 32;



        transfer.toChain = encoded.toUint16(index);

        index += 2;



        transfer.fromAddress = encoded.toBytes32(index);

        index += 32;



        transfer.payload = encoded.slice(index, encoded.length - index);

    }



    /*

     * @dev Parses either a type 1 transfer or a type 3 transfer ("transfer with

     *      payload") as a Transfer struct. The fee is set to 0 for type 3

     *      transfers, since they have no fees associated with them.

     *

     *      The sole purpose of this function is to get around the local

     *      variable count limitation in _completeTransfer.

     */

    function _parseTransferCommon(bytes memory encoded) public pure returns (BridgeStructs.Transfer memory transfer) {

        uint8 payloadID = parsePayloadID(encoded);



        if (payloadID == 1) {

            transfer = parseTransfer(encoded);

        } else if (payloadID == 3) {

            BridgeStructs.TransferWithPayload memory t = parseTransferWithPayload(encoded);

            transfer.payloadID = 3;

            transfer.amount = t.amount;

            transfer.tokenAddress = t.tokenAddress;

            transfer.tokenChain = t.tokenChain;

            transfer.to = t.to;

            transfer.toChain = t.toChain;

            // Type 3 payloads don't have fees.

            transfer.fee = 0;

        } else {

            revert("Invalid payload id");

        }

    }



    function bytes32ToString(bytes32 input) internal pure returns (string memory) {

        uint256 i;

        while (i < 32 && input[i] != 0) {

            i++;

        }

        bytes memory array = new bytes(i);

        for (uint c = 0; c < i; c++) {

            array[c] = input[c];

        }

        return string(array);

    }



    // we need to accept ETH sends to unwrap WETH

    receive() external payable {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\BridgeGetters.sol
File type: .sol
// contracts/Getters.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";



import "../interfaces/IWormhole.sol";



import "./BridgeState.sol";



contract BridgeGetters is BridgeState {

    function governanceActionIsConsumed(bytes32 hash) public view returns (bool) {

        return _state.consumedGovernanceActions[hash];

    }



    function isInitialized(address impl) public view returns (bool) {

        return _state.initializedImplementations[impl];

    }



    function isTransferCompleted(bytes32 hash) public view returns (bool) {

        return _state.completedTransfers[hash];

    }



    function wormhole() public view returns (IWormhole) {

        return IWormhole(_state.wormhole);

    }



    function chainId() public view returns (uint16){

        return _state.provider.chainId;

    }



    function evmChainId() public view returns (uint256) {

        return _state.evmChainId;

    }



    function isFork() public view returns (bool) {

        return evmChainId() != block.chainid;

    }



    function governanceChainId() public view returns (uint16){

        return _state.provider.governanceChainId;

    }



    function governanceContract() public view returns (bytes32){

        return _state.provider.governanceContract;

    }



    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress) public view returns (address){

        return _state.wrappedAssets[tokenChainId][tokenAddress];

    }



    function bridgeContracts(uint16 chainId_) public view returns (bytes32){

        return _state.bridgeImplementations[chainId_];

    }



    function tokenImplementation() public view returns (address){

        return _state.tokenImplementation;

    }



    function WETH() public view returns (IWETH){

        return IWETH(_state.provider.WETH);

    }



    function outstandingBridged(address token) public view returns (uint256){

        return _state.outstandingBridged[token];

    }



    function isWrappedAsset(address token) public view returns (bool){

        return _state.isWrappedAsset[token];

    }



    function finality() public view returns (uint8) {

        return _state.provider.finality;

    }

}



interface IWETH is IERC20 {

    function deposit() external payable;



    function withdraw(uint amount) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\BridgeGovernance.sol
File type: .sol
// contracts/Bridge.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";



import "../libraries/external/BytesLib.sol";



import "./BridgeGetters.sol";

import "./BridgeSetters.sol";

import "./BridgeStructs.sol";



import "./token/Token.sol";

import "./token/TokenImplementation.sol";



import "../interfaces/IWormhole.sol";



contract BridgeGovernance is BridgeGetters, BridgeSetters, ERC1967Upgrade {

    using BytesLib for bytes;



    // "TokenBridge" (left padded)

    bytes32 constant module = 0x000000000000000000000000000000000000000000546f6b656e427269646765;



    // Execute a RegisterChain governance message

    function registerChain(bytes memory encodedVM) public {

        (IWormhole.VM memory vm, bool valid, string memory reason) = verifyGovernanceVM(encodedVM);

        require(valid, reason);



        setGovernanceActionConsumed(vm.hash);



        BridgeStructs.RegisterChain memory chain = parseRegisterChain(vm.payload);



        require((chain.chainId == chainId() && !isFork()) || chain.chainId == 0, "invalid chain id");

        require(bridgeContracts(chain.emitterChainID) == bytes32(0), "chain already registered");



        setBridgeImplementation(chain.emitterChainID, chain.emitterAddress);

    }



    // Execute a UpgradeContract governance message

    function upgrade(bytes memory encodedVM) public {

        require(!isFork(), "invalid fork");



        (IWormhole.VM memory vm, bool valid, string memory reason) = verifyGovernanceVM(encodedVM);

        require(valid, reason);



        setGovernanceActionConsumed(vm.hash);



        BridgeStructs.UpgradeContract memory implementation = parseUpgrade(vm.payload);



        require(implementation.chainId == chainId(), "wrong chain id");



        upgradeImplementation(address(uint160(uint256(implementation.newContract))));

    }



    /**

    * @dev Updates the `chainId` and `evmChainId` on a forked chain via Governance VAA/VM

    */

    function submitRecoverChainId(bytes memory encodedVM) public {

        require(isFork(), "not a fork");



        (IWormhole.VM memory vm, bool valid, string memory reason) = verifyGovernanceVM(encodedVM);

        require(valid, reason);



        setGovernanceActionConsumed(vm.hash);



        BridgeStructs.RecoverChainId memory rci = parseRecoverChainId(vm.payload);



        // Verify the VAA is for this chain

        require(rci.evmChainId == block.chainid, "invalid EVM Chain");



        // Update the chainIds

        setEvmChainId(rci.evmChainId);

        setChainId(rci.newChainId);

    }



    function verifyGovernanceVM(bytes memory encodedVM) internal view returns (IWormhole.VM memory parsedVM, bool isValid, string memory invalidReason){

        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVM);



        if (!valid) {

            return (vm, valid, reason);

        }



        if (vm.emitterChainId != governanceChainId()) {

            return (vm, false, "wrong governance chain");

        }

        if (vm.emitterAddress != governanceContract()) {

            return (vm, false, "wrong governance contract");

        }



        if (governanceActionIsConsumed(vm.hash)) {

            return (vm, false, "governance action already consumed");

        }



        return (vm, true, "");

    }



    event ContractUpgraded(address indexed oldContract, address indexed newContract);



    function upgradeImplementation(address newImplementation) internal {

        address currentImplementation = _getImplementation();



        _upgradeTo(newImplementation);



        // Call initialize function of the new implementation

        (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature("initialize()"));



        require(success, string(reason));



        emit ContractUpgraded(currentImplementation, newImplementation);

    }



    function parseRegisterChain(bytes memory encoded) public pure returns (BridgeStructs.RegisterChain memory chain) {

        uint index = 0;



        // governance header



        chain.module = encoded.toBytes32(index);

        index += 32;

        require(chain.module == module, "wrong module");



        chain.action = encoded.toUint8(index);

        index += 1;

        require(chain.action == 1, "wrong action");



        chain.chainId = encoded.toUint16(index);

        index += 2;



        // payload



        chain.emitterChainID = encoded.toUint16(index);

        index += 2;



        chain.emitterAddress = encoded.toBytes32(index);

        index += 32;



        require(encoded.length == index, "wrong length");

    }



    function parseUpgrade(bytes memory encoded) public pure returns (BridgeStructs.UpgradeContract memory chain) {

        uint index = 0;



        // governance header



        chain.module = encoded.toBytes32(index);

        index += 32;

        require(chain.module == module, "wrong module");



        chain.action = encoded.toUint8(index);

        index += 1;

        require(chain.action == 2, "wrong action");



        chain.chainId = encoded.toUint16(index);

        index += 2;



        // payload



        chain.newContract = encoded.toBytes32(index);

        index += 32;



        require(encoded.length == index, "wrong length");

    }



    /// @dev Parse a recoverChainId (action 3) with minimal validation

    function parseRecoverChainId(bytes memory encodedRecoverChainId) public pure returns (BridgeStructs.RecoverChainId memory rci) {

        uint index = 0;



        rci.module = encodedRecoverChainId.toBytes32(index);

        index += 32;

        require(rci.module == module, "wrong module");



        rci.action = encodedRecoverChainId.toUint8(index);

        index += 1;

        require(rci.action == 3, "wrong action");



        rci.evmChainId = encodedRecoverChainId.toUint256(index);

        index += 32;



        rci.newChainId = encodedRecoverChainId.toUint16(index);

        index += 2;



        require(encodedRecoverChainId.length == index, "wrong length");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\BridgeImplementation.sol
File type: .sol
// contracts/Implementation.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;

pragma experimental ABIEncoderV2;



import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";



import "./Bridge.sol";





contract BridgeImplementation is Bridge {

    // Beacon getter for the token contracts

    function implementation() public view returns (address) {

        return tokenImplementation();

    }



    function initialize() initializer public virtual {

        // this function needs to be exposed for an upgrade to pass

        address tokenContract;

        uint256 evmChainId;

        uint16 chain = chainId();



        // Wormhole chain ids explicitly enumerated

        if        (chain == 2)  { evmChainId = 1;          // ethereum

            setFinality(1);

            tokenContract = 0x0fD04a68d3c3A692d6Fa30384D1A87Ef93554eE6;

        } else if (chain == 4)  { evmChainId = 56;         // bsc

            tokenContract = 0x7f8C5e730121657E17E452c5a1bA3fA1eF96f22a;

        } else if (chain == 5)  { evmChainId = 137;        // polygon

            tokenContract = 0x7C9Fc5741288cDFdD83CeB07f3ea7e22618D79D2;

        } else if (chain == 6)  { evmChainId = 43114;      // avalanche

            tokenContract = 0xe07548528D7c0C470251CF1374eF762345f298eE;

        } else if (chain == 7)  { evmChainId = 42262;      // oasis

            tokenContract = 0x75d520ed7fE263b96cCC7165aCe270097bC11721;

        } else if (chain == 9)  { evmChainId = 1313161554; // aurora

            tokenContract = 0x20F989Ad4C3B6ddcd940A66013d45f45d5c15463;

        } else if (chain == 10) { evmChainId = 250;        // fantom

            tokenContract = 0x99A3385C5AA40B184F6F6898daeBcD752C4b11F8;

        } else if (chain == 11) { evmChainId = 686;        // karura

            tokenContract = 0x7C9Fc5741288cDFdD83CeB07f3ea7e22618D79D2;

        } else if (chain == 12) { evmChainId = 787;        // acala

        } else if (chain == 13) { evmChainId = 8217;       // klaytn

            tokenContract = 0x7Ec2f3742F5D7ecF85817D67Ae3f89fa70164e8F;

        } else if (chain == 14) { evmChainId = 42220;      // celo

            tokenContract = 0x1a81c975d0e69206a45584BB98520f25dEEC7b6C;

        } else if (chain == 16) { evmChainId = 1284;       // moonbeam

            tokenContract = 0xddA94dA500AF7DCd8DE53482a39eD55d4aA3B392;

        } else if (chain == 17) { evmChainId = 245022934;  // neon

        } else if (chain == 23) { evmChainId = 42161;      // arbitrum

        } else if (chain == 24) { evmChainId = 10;         // optimism

        } else if (chain == 25) { evmChainId = 100;        // gnosis

        } else {

            revert("Unknown chain id.");

        }



        setEvmChainId(evmChainId);

        setTokenImplementation(tokenContract);

    }



    modifier initializer() {

        address impl = ERC1967Upgrade._getImplementation();



        require(

            !isInitialized(impl),

            "already initialized"

        );



        setInitialized(impl);



        _;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\BridgeSetters.sol
File type: .sol
// contracts/Setters.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./BridgeState.sol";



contract BridgeSetters is BridgeState {

    function setInitialized(address implementatiom) internal {

        _state.initializedImplementations[implementatiom] = true;

    }



    function setGovernanceActionConsumed(bytes32 hash) internal {

        _state.consumedGovernanceActions[hash] = true;

    }



    function setTransferCompleted(bytes32 hash) internal {

        _state.completedTransfers[hash] = true;

    }



    function setChainId(uint16 chainId) internal {

        _state.provider.chainId = chainId;

    }



    function setGovernanceChainId(uint16 chainId) internal {

        _state.provider.governanceChainId = chainId;

    }



    function setGovernanceContract(bytes32 governanceContract) internal {

        _state.provider.governanceContract = governanceContract;

    }



    function setBridgeImplementation(uint16 chainId, bytes32 bridgeContract) internal {

        _state.bridgeImplementations[chainId] = bridgeContract;

    }



    function setTokenImplementation(address impl) internal {

        _state.tokenImplementation = impl;

    }



    function setWETH(address weth) internal {

        _state.provider.WETH = weth;

    }



    function setWormhole(address wh) internal {

        _state.wormhole = payable(wh);

    }



    function setWrappedAsset(uint16 tokenChainId, bytes32 tokenAddress, address wrapper) internal {

        _state.wrappedAssets[tokenChainId][tokenAddress] = wrapper;

        _state.isWrappedAsset[wrapper] = true;

    }



    function setOutstandingBridged(address token, uint256 outstanding) internal {

        _state.outstandingBridged[token] = outstanding;

    }



    function setFinality(uint8 finality) internal {

        _state.provider.finality = finality;

    }



    function setEvmChainId(uint256 evmChainId) internal {

        require(evmChainId == block.chainid, "invalid evmChainId");

        _state.evmChainId = evmChainId;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\BridgeState.sol
File type: .sol
// contracts/State.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./BridgeStructs.sol";



contract BridgeStorage {

    struct Provider {

        uint16 chainId;

        uint16 governanceChainId;

        // Required number of block confirmations to assume finality

        uint8 finality;

        bytes32 governanceContract;

        address WETH;

    }



    struct Asset {

        uint16 chainId;

        bytes32 assetAddress;

    }



    struct State {

        address payable wormhole;

        address tokenImplementation;



        Provider provider;



        // Mapping of consumed governance actions

        mapping(bytes32 => bool) consumedGovernanceActions;



        // Mapping of consumed token transfers

        mapping(bytes32 => bool) completedTransfers;



        // Mapping of initialized implementations

        mapping(address => bool) initializedImplementations;



        // Mapping of wrapped assets (chainID => nativeAddress => wrappedAddress)

        mapping(uint16 => mapping(bytes32 => address)) wrappedAssets;



        // Mapping to safely identify wrapped assets

        mapping(address => bool) isWrappedAsset;



        // Mapping of native assets to amount outstanding on other chains

        mapping(address => uint256) outstandingBridged;



        // Mapping of bridge contracts on other chains

        mapping(uint16 => bytes32) bridgeImplementations;



        // EIP-155 Chain ID

        uint256 evmChainId;

    }

}



contract BridgeState {

    BridgeStorage.State _state;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\BridgeStructs.sol
File type: .sol
// contracts/Structs.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



contract BridgeStructs {

    struct Transfer {

        // PayloadID uint8 = 1

        uint8 payloadID;

        // Amount being transferred (big-endian uint256)

        uint256 amount;

        // Address of the token. Left-zero-padded if shorter than 32 bytes

        bytes32 tokenAddress;

        // Chain ID of the token

        uint16 tokenChain;

        // Address of the recipient. Left-zero-padded if shorter than 32 bytes

        bytes32 to;

        // Chain ID of the recipient

        uint16 toChain;

        // Amount of tokens (big-endian uint256) that the user is willing to pay as relayer fee. Must be <= Amount.

        uint256 fee;

    }



    struct TransferWithPayload {

        // PayloadID uint8 = 3

        uint8 payloadID;

        // Amount being transferred (big-endian uint256)

        uint256 amount;

        // Address of the token. Left-zero-padded if shorter than 32 bytes

        bytes32 tokenAddress;

        // Chain ID of the token

        uint16 tokenChain;

        // Address of the recipient. Left-zero-padded if shorter than 32 bytes

        bytes32 to;

        // Chain ID of the recipient

        uint16 toChain;

        // Address of the message sender. Left-zero-padded if shorter than 32 bytes

        bytes32 fromAddress;

        // An arbitrary payload

        bytes payload;

    }



    struct TransferResult {

        // Chain ID of the token

        uint16  tokenChain;

        // Address of the token. Left-zero-padded if shorter than 32 bytes

        bytes32 tokenAddress;

        // Amount being transferred (big-endian uint256)

        uint256 normalizedAmount;

        // Amount of tokens (big-endian uint256) that the user is willing to pay as relayer fee. Must be <= Amount.

        uint256 normalizedArbiterFee;

        // Portion of msg.value to be paid as the core bridge fee

        uint wormholeFee;

    }



    struct AssetMeta {

        // PayloadID uint8 = 2

        uint8 payloadID;

        // Address of the token. Left-zero-padded if shorter than 32 bytes

        bytes32 tokenAddress;

        // Chain ID of the token

        uint16 tokenChain;

        // Number of decimals of the token (big-endian uint256)

        uint8 decimals;

        // Symbol of the token (UTF-8)

        bytes32 symbol;

        // Name of the token (UTF-8)

        bytes32 name;

    }



    struct RegisterChain {

        // Governance Header

        // module: "TokenBridge" left-padded

        bytes32 module;

        // governance action: 1

        uint8 action;

        // governance paket chain id: this or 0

        uint16 chainId;



        // Chain ID

        uint16 emitterChainID;

        // Emitter address. Left-zero-padded if shorter than 32 bytes

        bytes32 emitterAddress;

    }



    struct UpgradeContract {

        // Governance Header

        // module: "TokenBridge" left-padded

        bytes32 module;

        // governance action: 2

        uint8 action;

        // governance paket chain id

        uint16 chainId;



        // Address of the new contract

        bytes32 newContract;

    }



    struct RecoverChainId {

        // Governance Header

        // module: "TokenBridge" left-padded

        bytes32 module;

        // governance action: 3

        uint8 action;



        // EIP-155 Chain ID

        uint256 evmChainId;

        // Chain ID

        uint16 newChainId;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\BytesLib.sol
File type: .sol
// SPDX-License-Identifier: Unlicense

/*

 * @title Solidity Bytes Arrays Utils

 * @author Gon?alo S? <goncalo.sa@consensys.net>

 *

 * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.

 *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.

 */

pragma solidity >=0.8.0 <0.9.0;





library BytesLib {

    function concat(

        bytes memory _preBytes,

        bytes memory _postBytes

    )

        internal

        pure

        returns (bytes memory)

    {

        bytes memory tempBytes;



        assembly {

            // Get a location of some free memory and store it in tempBytes as

            // Solidity does for memory variables.

            tempBytes := mload(0x40)



            // Store the length of the first bytes array at the beginning of

            // the memory for tempBytes.

            let length := mload(_preBytes)

            mstore(tempBytes, length)



            // Maintain a memory counter for the current write location in the

            // temp bytes array by adding the 32 bytes for the array length to

            // the starting location.

            let mc := add(tempBytes, 0x20)

            // Stop copying when the memory counter reaches the length of the

            // first bytes array.

            let end := add(mc, length)



            for {

                // Initialize a copy counter to the start of the _preBytes data,

                // 32 bytes into its memory.

                let cc := add(_preBytes, 0x20)

            } lt(mc, end) {

                // Increase both counters by 32 bytes each iteration.

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                // Write the _preBytes data into the tempBytes memory 32 bytes

                // at a time.

                mstore(mc, mload(cc))

            }



            // Add the length of _postBytes to the current length of tempBytes

            // and store it as the new length in the first 32 bytes of the

            // tempBytes memory.

            length := mload(_postBytes)

            mstore(tempBytes, add(length, mload(tempBytes)))



            // Move the memory counter back from a multiple of 0x20 to the

            // actual end of the _preBytes data.

            mc := end

            // Stop copying when the memory counter reaches the new combined

            // length of the arrays.

            end := add(mc, length)



            for {

                let cc := add(_postBytes, 0x20)

            } lt(mc, end) {

                mc := add(mc, 0x20)

                cc := add(cc, 0x20)

            } {

                mstore(mc, mload(cc))

            }



            // Update the free-memory pointer by padding our last write location

            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the

            // next 32 byte block, then round down to the nearest multiple of

            // 32. If the sum of the length of the two arrays is zero then add

            // one before rounding down to leave a blank 32 bytes (the length block with 0).

            mstore(0x40, and(

              add(add(end, iszero(add(length, mload(_preBytes)))), 31),

              not(31) // Round down to the nearest 32 bytes.

            ))

        }



        return tempBytes;

    }



    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {

        assembly {

            // Read the first 32 bytes of _preBytes storage, which is the length

            // of the array. (We don't need to use the offset into the slot

            // because arrays use the entire slot.)

            let fslot := sload(_preBytes.slot)

            // Arrays of 31 bytes or less have an even value in their slot,

            // while longer arrays have an odd value. The actual length is

            // the slot divided by two for odd values, and the lowest order

            // byte divided by two for even values.

            // If the slot is even, bitwise and the slot with 255 and divide by

            // two to get the length. If the slot is odd, bitwise and the slot

            // with -1 and divide by two.

            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)

            let mlength := mload(_postBytes)

            let newlength := add(slength, mlength)

            // slength can contain both the length and contents of the array

            // if length < 32 bytes so let's prepare for that

            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage

            switch add(lt(slength, 32), lt(newlength, 32))

            case 2 {

                // Since the new array still fits in the slot, we just need to

                // update the contents of the slot.

                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length

                sstore(

                    _preBytes.slot,

                    // all the modifications to the slot are inside this

                    // next block

                    add(

                        // we can just add to the slot contents because the

                        // bytes we want to change are the LSBs

                        fslot,

                        add(

                            mul(

                                div(

                                    // load the bytes from memory

                                    mload(add(_postBytes, 0x20)),

                                    // zero all bytes to the right

                                    exp(0x100, sub(32, mlength))

                                ),

                                // and now shift left the number of bytes to

                                // leave space for the length in the slot

                                exp(0x100, sub(32, newlength))

                            ),

                            // increase length by the double of the memory

                            // bytes length

                            mul(mlength, 2)

                        )

                    )

                )

            }

            case 1 {

                // The stored value fits in the slot, but the combined value

                // will exceed it.

                // get the keccak hash to get the contents of the array

                mstore(0x0, _preBytes.slot)

                let sc := add(keccak256(0x0, 0x20), div(slength, 32))



                // save new length

                sstore(_preBytes.slot, add(mul(newlength, 2), 1))



                // The contents of the _postBytes array start 32 bytes into

                // the structure. Our first read should obtain the `submod`

                // bytes that can fit into the unused space in the last word

                // of the stored array. To get this, we read 32 bytes starting

                // from `submod`, so the data we read overlaps with the array

                // contents by `submod` bytes. Masking the lowest-order

                // `submod` bytes allows us to add that value directly to the

                // stored value.



                let submod := sub(32, slength)

                let mc := add(_postBytes, submod)

                let end := add(_postBytes, mlength)

                let mask := sub(exp(0x100, submod), 1)



                sstore(

                    sc,

                    add(

                        and(

                            fslot,

                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00

                        ),

                        and(mload(mc), mask)

                    )

                )



                for {

                    mc := add(mc, 0x20)

                    sc := add(sc, 1)

                } lt(mc, end) {

                    sc := add(sc, 1)

                    mc := add(mc, 0x20)

                } {

                    sstore(sc, mload(mc))

                }



                mask := exp(0x100, sub(mc, end))



                sstore(sc, mul(div(mload(mc), mask), mask))

            }

            default {

                // get the keccak hash to get the contents of the array

                mstore(0x0, _preBytes.slot)

                // Start copying to the last used word of the stored array.

                let sc := add(keccak256(0x0, 0x20), div(slength, 32))



                // save new length

                sstore(_preBytes.slot, add(mul(newlength, 2), 1))



                // Copy over the first `submod` bytes of the new data as in

                // case 1 above.

                let slengthmod := mod(slength, 32)

                let mlengthmod := mod(mlength, 32)

                let submod := sub(32, slengthmod)

                let mc := add(_postBytes, submod)

                let end := add(_postBytes, mlength)

                let mask := sub(exp(0x100, submod), 1)



                sstore(sc, add(sload(sc), and(mload(mc), mask)))



                for {

                    sc := add(sc, 1)

                    mc := add(mc, 0x20)

                } lt(mc, end) {

                    sc := add(sc, 1)

                    mc := add(mc, 0x20)

                } {

                    sstore(sc, mload(mc))

                }



                mask := exp(0x100, sub(mc, end))



                sstore(sc, mul(div(mload(mc), mask), mask))

            }

        }

    }



    function slice(

        bytes memory _bytes,

        uint256 _start,

        uint256 _length

    )

        internal

        pure

        returns (bytes memory)

    {

        require(_length + 31 >= _length, "slice_overflow");

        require(_bytes.length >= _start + _length, "slice_outOfBounds");



        bytes memory tempBytes;



        assembly {

            switch iszero(_length)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                let lengthmod := and(_length, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, _length)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, _length)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)

                //zero out the 32 bytes slice we are about to return

                //we need to do it because Solidity does not garbage collect

                mstore(tempBytes, 0)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return tempBytes;

    }



    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {

        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");

        address tempAddress;



        assembly {

            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)

        }



        return tempAddress;

    }



    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {

        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");

        uint8 tempUint;



        assembly {

            tempUint := mload(add(add(_bytes, 0x1), _start))

        }



        return tempUint;

    }



    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {

        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");

        uint16 tempUint;



        assembly {

            tempUint := mload(add(add(_bytes, 0x2), _start))

        }



        return tempUint;

    }



    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {

        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");

        uint32 tempUint;



        assembly {

            tempUint := mload(add(add(_bytes, 0x4), _start))

        }



        return tempUint;

    }



    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {

        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");

        uint64 tempUint;



        assembly {

            tempUint := mload(add(add(_bytes, 0x8), _start))

        }



        return tempUint;

    }



    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {

        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");

        uint96 tempUint;



        assembly {

            tempUint := mload(add(add(_bytes, 0xc), _start))

        }



        return tempUint;

    }



    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {

        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");

        uint128 tempUint;



        assembly {

            tempUint := mload(add(add(_bytes, 0x10), _start))

        }



        return tempUint;

    }



    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {

        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");

        uint256 tempUint;



        assembly {

            tempUint := mload(add(add(_bytes, 0x20), _start))

        }



        return tempUint;

    }



    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {

        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");

        bytes32 tempBytes32;



        assembly {

            tempBytes32 := mload(add(add(_bytes, 0x20), _start))

        }



        return tempBytes32;

    }



    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {

        bool success = true;



        assembly {

            let length := mload(_preBytes)



            // if lengths don't match the arrays are not equal

            switch eq(length, mload(_postBytes))

            case 1 {

                // cb is a circuit breaker in the for loop since there's

                //  no said feature for inline assembly loops

                // cb = 1 - don't breaker

                // cb = 0 - break

                let cb := 1



                let mc := add(_preBytes, 0x20)

                let end := add(mc, length)



                for {

                    let cc := add(_postBytes, 0x20)

                // the next line is the loop condition:

                // while(uint256(mc < end) + cb == 2)

                } eq(add(lt(mc, end), cb), 2) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    // if any of these checks fails then arrays are not equal

                    if iszero(eq(mload(mc), mload(cc))) {

                        // unsuccess:

                        success := 0

                        cb := 0

                    }

                }

            }

            default {

                // unsuccess:

                success := 0

            }

        }



        return success;

    }



    function equalStorage(

        bytes storage _preBytes,

        bytes memory _postBytes

    )

        internal

        view

        returns (bool)

    {

        bool success = true;



        assembly {

            // we know _preBytes_offset is 0

            let fslot := sload(_preBytes.slot)

            // Decode the length of the stored array like in concatStorage().

            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)

            let mlength := mload(_postBytes)



            // if lengths don't match the arrays are not equal

            switch eq(slength, mlength)

            case 1 {

                // slength can contain both the length and contents of the array

                // if length < 32 bytes so let's prepare for that

                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage

                if iszero(iszero(slength)) {

                    switch lt(slength, 32)

                    case 1 {

                        // blank the last byte which is the length

                        fslot := mul(div(fslot, 0x100), 0x100)



                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {

                            // unsuccess:

                            success := 0

                        }

                    }

                    default {

                        // cb is a circuit breaker in the for loop since there's

                        //  no said feature for inline assembly loops

                        // cb = 1 - don't breaker

                        // cb = 0 - break

                        let cb := 1



                        // get the keccak hash to get the contents of the array

                        mstore(0x0, _preBytes.slot)

                        let sc := keccak256(0x0, 0x20)



                        let mc := add(_postBytes, 0x20)

                        let end := add(mc, mlength)



                        // the next line is the loop condition:

                        // while(uint256(mc < end) + cb == 2)

                        for {} eq(add(lt(mc, end), cb), 2) {

                            sc := add(sc, 1)

                            mc := add(mc, 0x20)

                        } {

                            if iszero(eq(sload(sc), mload(mc))) {

                                // unsuccess:

                                success := 0

                                cb := 0

                            }

                        }

                    }

                }

            }

            default {

                // unsuccess:

                success := 0

            }

        }



        return success;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\CircleIntegration.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import {IWormhole} from "wormhole/interfaces/IWormhole.sol";

import {BytesLib} from "wormhole/libraries/external/BytesLib.sol";



import {ICircleBridge} from "../interfaces/circle/ICircleBridge.sol";



import {CircleIntegrationGovernance} from "./CircleIntegrationGovernance.sol";

import {CircleIntegrationMessages} from "./CircleIntegrationMessages.sol";



/**

 * @notice This contract burns and mints Circle-supported tokens by using Circle's Cross-Chain Transfer Protocol. It also emits

 * Wormhole messages with arbitrary payloads to allow for additional composability when performing cross-chain

 * transfers of Circle-suppored assets.

 */

contract CircleIntegration is CircleIntegrationMessages, CircleIntegrationGovernance, ReentrancyGuard {

    using BytesLib for bytes;



    /**

     * @notice Emitted when Circle-supported assets have been minted to the mintRecipient

     * @param emitterChainId Wormhole chain ID of emitter contract on source chain

     * @param emitterAddress Address (bytes32 zero-left-padded) of emitter on source chain

     * @param sequence Sequence of Wormhole message used to mint tokens

     */

    event Redeemed(uint16 indexed emitterChainId, bytes32 indexed emitterAddress, uint64 indexed sequence);



    /**

     * @notice `transferTokensWithPayload` calls the Circle Bridge contract to burn Circle-supported tokens. It emits

     * a Wormhole message containing a user-specified payload with instructions for what to do with

     * the Circle-supported assets once they have been minted on the target chain.

     * @dev reverts if:

     * - user passes insufficient value to pay Wormhole message fee

     * - `token` is not supported by Circle Bridge

     * - `amount` is zero

     * - `targetChain` is not supported

     * - `mintRecipient` is bytes32(0)

     * @param transferParams Struct containing the following attributes:

     * - `token` Address of the token to be burned

     * - `amount` Amount of `token` to be burned

     * - `targetChain` Wormhole chain ID of the target blockchain

     * - `mintRecipient` The recipient wallet or contract address on the target chain

     * @param batchId ID for Wormhole message batching

     * @param payload Arbitrary payload to be delivered to the target chain via Wormhole

     * @return messageSequence Wormhole sequence number for this contract

     */

    function transferTokensWithPayload(TransferParameters memory transferParams, uint32 batchId, bytes memory payload)

        public

        payable

        nonReentrant

        returns (uint64 messageSequence)

    {

        // cache wormhole instance and fees to save on gas

        IWormhole wormhole = wormhole();

        uint256 wormholeFee = wormhole.messageFee();



        // confirm that the caller has sent enough ether to pay for the wormhole message fee

        require(msg.value == wormholeFee, "insufficient value");



        // Call the circle bridge and `depositForBurnWithCaller`. The `mintRecipient`

        // should be the target contract (or wallet) composing on this contract.

        (uint64 nonce, uint256 amountReceived) = _transferTokens(

            transferParams.token, transferParams.amount, transferParams.targetChain, transferParams.mintRecipient

        );



        // encode DepositWithPayload message

        bytes memory encodedMessage = encodeDepositWithPayload(

            DepositWithPayload({

                token: addressToBytes32(transferParams.token),

                amount: amountReceived,

                sourceDomain: localDomain(),

                targetDomain: getDomainFromChainId(transferParams.targetChain),

                nonce: nonce,

                fromAddress: addressToBytes32(msg.sender),

                mintRecipient: transferParams.mintRecipient,

                payload: payload

            })

        );



        // send the DepositWithPayload wormhole message

        messageSequence = wormhole.publishMessage{value: wormholeFee}(batchId, encodedMessage, wormholeFinality());

    }



    function _transferTokens(address token, uint256 amount, uint16 targetChain, bytes32 mintRecipient)

        internal

        returns (uint64 nonce, uint256 amountReceived)

    {

        // sanity check user input

        require(amount > 0, "amount must be > 0");

        require(mintRecipient != bytes32(0), "invalid mint recipient");

        require(isAcceptedToken(token), "token not accepted");

        require(getRegisteredEmitter(targetChain) != bytes32(0), "target contract not registered");



        // take custody of tokens

        amountReceived = custodyTokens(token, amount);



        // cache Circle Bridge instance

        ICircleBridge circleBridge = circleBridge();



        // approve the Circle Bridge to spend tokens

        SafeERC20.safeApprove(IERC20(token), address(circleBridge), amountReceived);



        // burn tokens on the bridge

        nonce = circleBridge.depositForBurnWithCaller(

            amountReceived, getDomainFromChainId(targetChain), mintRecipient, token, getRegisteredEmitter(targetChain)

        );

    }



    function custodyTokens(address token, uint256 amount) internal returns (uint256) {

        // query own token balance before transfer

        (, bytes memory queriedBalanceBefore) =

            token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));

        uint256 balanceBefore = abi.decode(queriedBalanceBefore, (uint256));



        // deposit tokens

        SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);



        // query own token balance after transfer

        (, bytes memory queriedBalanceAfter) =

            token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));

        uint256 balanceAfter = abi.decode(queriedBalanceAfter, (uint256));



        return balanceAfter - balanceBefore;

    }



    /**

     * @notice `redeemTokensWithPayload` verifies the Wormhole message from the source chain and

     * verifies that the passed Circle Bridge message is valid. It calls the Circle Bridge

     * contract by passing the Circle message and attestation to mint tokens to the specified

     * mint recipient. It also verifies that the caller is the specified mint recipient to ensure

     * atomic execution of the additional instructions in the Wormhole message.

     * @dev reverts if:

     * - Wormhole message is not properly attested

     * - Wormhole message was not emitted from a registered contrat

     * - Wormhole message was already consumed by this contract

     * - msg.sender is not the encoded mintRecipient

     * - Circle Bridge message and Wormhole message are not associated

     * - `receiveMessage` call to Circle Transmitter fails

     * @param params Struct containing the following attributes:

     * - `encodedWormholeMessage` Wormhole message emitted by a registered contract including

     * information regarding the token burn on the source chain and an arbitrary message.

     * - `circleBridgeMessage` Message emitted by Circle Bridge contract with information regarding

     * the token burn on the source chain.

     * - `circleAttestation` Serialized EC Signature attesting the cross-chain transfer

     * @return depositInfo Struct containing the following attributes:

     * - `token` Address (bytes32 left-zero-padded) of token to be minted

     * - `amount` Amount of tokens to be minted

     * - `sourceDomain` Circle domain for the source chain

     * - `targetDomain` Circle domain for the target chain

     * - `nonce` Circle sequence number for the transfer

     * - `fromAddress` Source CircleIntegration contract caller's address

     * - `mintRecipient` Recipient of minted tokens (must be caller of this contract)

     * - `payload` Arbitrary Wormhole message payload

     */

    function redeemTokensWithPayload(RedeemParameters calldata params)

        public

        returns (DepositWithPayload memory depositInfo)

    {

        // verify the wormhole message

        IWormhole.VM memory verifiedMessage = verifyWormholeRedeemMessage(params.encodedWormholeMessage);



        // Decode the message payload into the DepositWithPayload struct. Call the Circle TokenMinter

        // contract to determine the address of the encoded token on this chain.

        depositInfo = decodeDepositWithPayload(verifiedMessage.payload);

        depositInfo.token = fetchLocalTokenAddress(depositInfo.sourceDomain, depositInfo.token);



        // confirm that circle gave us a valid token address

        require(depositInfo.token != bytes32(0), "invalid local token address");



        // confirm that the caller is the `mintRecipient` to ensure atomic execution

        require(addressToBytes32(msg.sender) == depositInfo.mintRecipient, "caller must be mintRecipient");



        // confirm that the caller passed the correct message pair

        require(

            verifyCircleMessage(

                params.circleBridgeMessage, depositInfo.sourceDomain, depositInfo.targetDomain, depositInfo.nonce

            ),

            "invalid message pair"

        );



        // call the circle bridge to mint tokens to the recipient

        bool success = circleTransmitter().receiveMessage(params.circleBridgeMessage, params.circleAttestation);

        require(success, "CIRCLE_INTEGRATION: failed to mint tokens");



        // emit Redeemed event

        emit Redeemed(verifiedMessage.emitterChainId, verifiedMessage.emitterAddress, verifiedMessage.sequence);

    }



    function verifyWormholeRedeemMessage(bytes memory encodedMessage) internal returns (IWormhole.VM memory) {

        require(evmChain() == block.chainid, "invalid evm chain");



        // parse and verify the Wormhole core message

        (IWormhole.VM memory verifiedMessage, bool valid, string memory reason) =

            wormhole().parseAndVerifyVM(encodedMessage);



        // confirm that the core layer verified the message

        require(valid, reason);



        // verify that this message was emitted by a trusted contract

        require(verifyEmitter(verifiedMessage), "unknown emitter");



        // revert if this message has been consumed already

        require(!isMessageConsumed(verifiedMessage.hash), "message already consumed");

        consumeMessage(verifiedMessage.hash);



        return verifiedMessage;

    }



    function verifyEmitter(IWormhole.VM memory vm) internal view returns (bool) {

        // verify that the sender of the wormhole message is a trusted

        return (

            getRegisteredEmitter(vm.emitterChainId) == vm.emitterAddress &&

            vm.emitterAddress != bytes32(0)

        );

    }



    function verifyCircleMessage(bytes memory circleMessage, uint32 sourceDomain, uint32 targetDomain, uint64 nonce)

        internal

        pure

        returns (bool)

    {

        // parse the circle bridge message inline

        uint32 circleSourceDomain = circleMessage.toUint32(4);

        uint32 circleTargetDomain = circleMessage.toUint32(8);

        uint64 circleNonce = circleMessage.toUint64(12);



        // confirm that both the Wormhole message and Circle message share the same transfer info

        return (sourceDomain == circleSourceDomain && targetDomain == circleTargetDomain && nonce == circleNonce);

    }



    /**

     * @notice Fetches the local token address given an address and domain from

     * a different chain.

     * @param sourceDomain Circle domain for the sending chain.

     * @param sourceToken Address of the token for the sending chain.

     * @return Address bytes32 formatted address of the `sourceToken` on this chain.

     */

    function fetchLocalTokenAddress(uint32 sourceDomain, bytes32 sourceToken)

        public

        view

        returns (bytes32)

    {

        return addressToBytes32(

            circleTokenMinter().remoteTokensToLocalTokens(

                keccak256(abi.encodePacked(sourceDomain, sourceToken))

            )

        );

    }



    /**

     * @notice Converts type address to bytes32 (left-zero-padded)

     * @param address_ Address to convert to bytes32

     * @return Address bytes32

     */

    function addressToBytes32(address address_) public pure returns (bytes32) {

        return bytes32(uint256(uint160(address_)));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\CircleIntegrationGetters.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



import {IWormhole} from "wormhole/interfaces/IWormhole.sol";

import {ICircleBridge} from "../interfaces/circle/ICircleBridge.sol";

import {IMessageTransmitter} from "../interfaces/circle/IMessageTransmitter.sol";

import {ITokenMinter} from "../interfaces/circle/ITokenMinter.sol";



import {CircleIntegrationSetters} from "./CircleIntegrationSetters.sol";



contract CircleIntegrationGetters is CircleIntegrationSetters {

    /**

     * @notice isInitialized boolean for implementation (logic) contract

     * @param impl Address of implementation contract

     * @return IsInitialized bool

     */

    function isInitialized(address impl) public view returns (bool) {

        return _state.initializedImplementations[impl];

    }



    /**

     * @notice Wormhole contract interface

     * @return IWormhole interface

     */

    function wormhole() public view returns (IWormhole) {

        return IWormhole(_state.wormhole);

    }



    /**

     * @notice Wormhole chain ID of this chain

     * @return chainId uint16

     */

    function chainId() public view returns (uint16) {

        return _state.chainId;

    }



    /**

     * @notice Wormhole message finality

     * @return wormholeFinality uint8

     */

    function wormholeFinality() public view returns (uint8) {

        return _state.wormholeFinality;

    }



    /**

     * @notice Circle Bridge contract interface

     * @return ICircleBridge interface

     */

    function circleBridge() public view returns (ICircleBridge) {

        return ICircleBridge(_state.circleBridgeAddress);

    }



    /**

     * @notice Circle Transmitter contract interface

     * @return ICircleTransmitter interface

     */

    function circleTransmitter() public view returns (IMessageTransmitter) {

        return IMessageTransmitter(_state.circleTransmitterAddress);

    }



    /**

     * @notice Circle Token Minter contract interface

     * @return ITokenMinter interface

     */

    function circleTokenMinter() public view returns (ITokenMinter) {

        return ITokenMinter(_state.circleTokenMinterAddress);

    }



    /**

     * @notice Registered Circle Integration contracts on other blockchains

     * @param emitterChainId Wormhole chain ID for message sender

     * @return RegisteredEmitter bytes32

     */

    function getRegisteredEmitter(uint16 emitterChainId) public view returns (bytes32) {

        return _state.registeredEmitters[emitterChainId];

    }



    /**

     * @notice Circle Bridge registered token boolean

     * @param token Address of token being checked against the Circle TokenMinter

     * @return AcceptedToken bool

     */

    function isAcceptedToken(address token) public view returns (bool) {

        return circleTokenMinter().burnLimitsPerMessage(token) > 0;

    }



    /**

     * @notice Circle domain to Wormhole chain ID

     * @param chainId_ Wormhole chain ID

     * @return CircleDomain uint32

     */

    function getDomainFromChainId(uint16 chainId_) public view returns (uint32) {

        return _state.chainIdToDomain[chainId_];

    }



    /**

     * @notice Wormhole chain ID to Circle domain

     * @param domain Circle domain

     * @return chainId uint16

     */

    function getChainIdFromDomain(uint32 domain) public view returns (uint16) {

        return _state.domainToChainId[domain];

    }



    /**

     * @notice Checks if Wormhole message was already consumed by this contract

     * @param hash Wormhole message hash

     * @return IsMessageConsumed bool

     */

    function isMessageConsumed(bytes32 hash) public view returns (bool) {

        return _state.consumedMessages[hash];

    }



    /**

     * @notice Circle domain on this chain

     * @return LocalDomain uint32

     */

    function localDomain() public view returns (uint32) {

        return _state.localDomain;

    }



    /**

     * @notice Wormhole governance chain ID

     * @return GovernanceChainId uint16

     */

    function governanceChainId() public view returns (uint16) {

        return _state.governanceChainId;

    }



    /**

     * @notice Wormhole governance contract address (zero-left-padded address less than 32 bytes)

     * @return GovernanceContract bytes32

     */

    function governanceContract() public view returns (bytes32) {

        return _state.governanceContract;

    }



    /**

     * @notice EVM chain ID

     * @return EVMChainID uint256

     */

    function evmChain() public view returns (uint256) {

        return _state.evmChain;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\CircleIntegrationGovernance.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



import {ERC1967Upgrade} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";



import {IWormhole} from "wormhole/interfaces/IWormhole.sol";

import {BytesLib} from "wormhole/libraries/external/BytesLib.sol";



import {CircleIntegrationSetters} from "./CircleIntegrationSetters.sol";

import {CircleIntegrationGetters} from "./CircleIntegrationGetters.sol";

import {CircleIntegrationState} from "./CircleIntegrationState.sol";

import {ICircleIntegration} from "../interfaces/ICircleIntegration.sol";



contract CircleIntegrationGovernance is CircleIntegrationGetters, ERC1967Upgrade {

    using BytesLib for bytes;



    /**

     * @notice Emitted when implementation (logic) contracts are upgraded

     * @param oldContract Previous implementation contract address

     * @param newContract New implementation contract address

     */

    event ContractUpgraded(address indexed oldContract, address indexed newContract);



    /**

     * @notice Emitted when the Wormhole message finality state variable changes

     * @param oldFinality Previous `wormholeFinality` value

     * @param newFinality New `wormholeFinality` value

     */

    event WormholeFinalityUpdated(uint8 indexed oldFinality, uint8 indexed newFinality);



    // "CircleIntegration" (left-zero-padded)

    bytes32 constant GOVERNANCE_MODULE = 0x000000000000000000000000000000436972636c65496e746567726174696f6e;



    // for updating `wormholeFinality`

    uint8 constant GOVERNANCE_UPDATE_WORMHOLE_FINALITY = 1;

    uint256 constant GOVERNANCE_UPDATE_WORMHOLE_FINALITY_LENGTH = 36;



    // for registering an emitter (CircleIntegration contact on other blockchains) and Circle Bridge domain

    uint8 constant GOVERNANCE_REGISTER_EMITTER_AND_DOMAIN = 2;

    uint256 constant GOVERNANCE_REGISTER_EMITTER_AND_DOMAIN_LENGTH = 73;



    // for upgrading implementation (logic) contracts

    uint8 constant GOVERNANCE_UPGRADE_CONTRACT = 3;

    uint256 constant GOVERNANCE_UPGRADE_CONTRACT_LENGTH = 67;



    /**

     * @notice `updateWormholeFinality` changes the wormhole message consistencyLevel.

     * @param encodedMessage Attested Wormhole governance message with the following

     * relevant fields:

     * - Field Bytes Type Index

     * - finality 1 uint8 35

     */

    function updateWormholeFinality(bytes memory encodedMessage) public {

        bytes memory payload = verifyAndConsumeGovernanceMessage(encodedMessage, GOVERNANCE_UPDATE_WORMHOLE_FINALITY);

        require(payload.length == GOVERNANCE_UPDATE_WORMHOLE_FINALITY_LENGTH, "invalid governance payload length");



        // cache the current `wormholeFinality` value

        uint8 currentWormholeFinality = wormholeFinality();



        // updating finality should only be relevant for this contract's chain ID

        require(payload.toUint16(33) == chainId(), "invalid target chain");



        // parse the new `wormholeFinality` value at byte 35

        uint8 newWormholeFinality = payload.toUint8(35);

        require(newWormholeFinality > 0, "invalid finality");



        setWormholeFinality(newWormholeFinality);



        emit WormholeFinalityUpdated(currentWormholeFinality, newWormholeFinality);

    }



    /**

     * @notice `registerEmitterAndDomain` saves trusted CircleIntegration contract addresses

     * and Circle's chain domains.

     * @param encodedMessage Attested Wormhole governance message with the following

     * relevant fields:

     * - Field Bytes Type Index

     * - foreignEmitterChainId 2 uint16 35

     * - foreignEmitterAddress 32 bytes32 37

     * - domain 4 uint32 69

     */

    function registerEmitterAndDomain(bytes memory encodedMessage) public {

        bytes memory payload = verifyAndConsumeGovernanceMessage(encodedMessage, GOVERNANCE_REGISTER_EMITTER_AND_DOMAIN);

        require(payload.length == GOVERNANCE_REGISTER_EMITTER_AND_DOMAIN_LENGTH, "invalid governance payload length");



        // registering emitters should only be relevant for this contract's chain ID

        require(payload.toUint16(33) == chainId(), "invalid target chain");



        // emitterChainId at byte 35

        uint16 emitterChainId = payload.toUint16(35);

        require(emitterChainId > 0 && emitterChainId != chainId(), "invalid chain");

        require(getRegisteredEmitter(emitterChainId) == bytes32(0), "chain already registered");



        // emitterAddress at byte 37

        bytes32 emitterAddress = payload.toBytes32(37);

        require(emitterAddress != bytes32(0), "emitter cannot be zero address");



        // domain at byte 69 (hehe)

        uint32 domain = payload.toUint32(69);

        require(domain != localDomain(), "domain == localDomain()");



        // update the registeredEmitters state variable

        setEmitter(emitterChainId, emitterAddress);



        // update the chainId to domain (and domain to chainId) mappings

        setChainIdToDomain(emitterChainId, domain);

        setDomainToChainId(domain, emitterChainId);

    }



    /**

     * @notice `upgradeContract` upgrades the implementation (logic) contract and

     * initializes the new implementation.

     * @param encodedMessage Attested Wormhole governance message with the following

     * relevant fields:

     * - Field Bytes Type Index

     * - newImplementation 32 bytes32 35

     */

    function upgradeContract(bytes memory encodedMessage) public {

        bytes memory payload = verifyAndConsumeGovernanceMessage(encodedMessage, GOVERNANCE_UPGRADE_CONTRACT);

        require(payload.length == GOVERNANCE_UPGRADE_CONTRACT_LENGTH, "invalid governance payload length");



        // contract upgrades should only be relevant for this contract's chain ID

        require(payload.toUint16(33) == chainId(), "invalid target chain");



        address currentImplementation = _getImplementation();



        // newImplementation at byte 35 (32 bytes, but last 20 is the address)

        address newImplementation = readAddressFromBytes32(payload, 35);

        {

            (, bytes memory queried) =

                newImplementation.staticcall(abi.encodeWithSignature("circleIntegrationImplementation()"));

            require(queried.length == 32, "invalid implementation");

            require(

                abi.decode(queried, (bytes32)) == keccak256("circleIntegrationImplementation()"),

                "invalid implementation"

            );

        }



        _upgradeTo(newImplementation);



        // call initialize function of the new implementation

        (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature("initialize()"));

        require(success, string(reason));



        emit ContractUpgraded(currentImplementation, newImplementation);

    }



    function verifyAndConsumeGovernanceMessage(bytes memory encodedMessage, uint8 action)

        internal

        returns (bytes memory)

    {

        // verify the governance message

        (bytes32 messageHash, bytes memory payload) = verifyGovernanceMessage(encodedMessage, action);



        // store the hash for replay protection

        consumeMessage(messageHash);



        return payload;

    }



    /**

     * @notice `verifyGovernanceMessage` validates governance messages attested by

     * Wormhole's network of guardians.

     * @dev reverts if:

     * - the EVM blockchain has forked

     * - the governance message was not attested

     * - the governance message was generated on the wrong blockchain

     * - the governance message was already consumed

     * - the encoded governance module is incorrect

     * - the encoded governance action is incorrect

     * @param encodedMessage Attested Wormhole governance message with the following

     * relevant fields:

     * - Field Bytes Type Index

     * - governanceModule 32 bytes32 0

     * - governanceAction 1 uint8 32

     * @param action Expected governance action

     * @return messageHash Wormhole governance message hash

     * @return payload Verified Wormhole governance message payload

     */

    function verifyGovernanceMessage(bytes memory encodedMessage, uint8 action)

        public

        view

        returns (bytes32 messageHash, bytes memory payload)

    {

        // make sure the blockchain has not forked

        require(evmChain() == block.chainid, "invalid evm chain");



        // verify the governance message

        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedMessage);

        require(valid, reason);



        // confirm that the governance message was sent from the governance contract

        require(vm.emitterChainId == governanceChainId(), "invalid governance chain");

        require(vm.emitterAddress == governanceContract(), "invalid governance contract");



        // confirm that this governance action has not been consumed already

        require(!isMessageConsumed(vm.hash), "governance action already consumed");



        // module at byte 0

        require(vm.payload.toBytes32(0) == GOVERNANCE_MODULE, "invalid governance module");



        // action at byte 32

        require(vm.payload.toUint8(32) == action, "invalid governance action");



        // set return values

        payload = vm.payload;

        messageHash = vm.hash;

    }



    function readAddressFromBytes32(bytes memory serialized, uint256 start) internal pure returns (address) {

        uint256 end = start + 12;

        for (uint256 i = start; i < end;) {

            require(serialized.toUint8(i) == 0, "invalid address");

            unchecked {

                i += 1;

            }

        }

        return serialized.toAddress(end);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\CircleIntegrationImplementation.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



import {ERC1967Upgrade} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";



import {CircleIntegration} from "./CircleIntegration.sol";



contract CircleIntegrationImplementation is CircleIntegration {

    function initialize() public virtual initializer {

        // this function needs to be exposed for an upgrade to pass

    }



    modifier initializer() {

        address impl = ERC1967Upgrade._getImplementation();



        require(!isInitialized(impl), "already initialized");



        setInitialized(impl);



        _;

    }



    function circleIntegrationImplementation() public pure returns (bytes32) {

        return keccak256("circleIntegrationImplementation()");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\CircleIntegrationMessages.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



import {BytesLib} from "wormhole/libraries/external/BytesLib.sol";



import {CircleIntegrationStructs} from "./CircleIntegrationStructs.sol";



contract CircleIntegrationMessages is CircleIntegrationStructs {

    using BytesLib for bytes;



    /**

     * @notice `encodeDepositWithPayload` encodes the `DepositWithPayload` struct into bytes

     * so that it can be sent as an arbitrary message payload via Wormhole.

     * @param message `DepositWithPayload` struct containing the following attributes:

     * - `token` Address (bytes32 left-zero-padded) of token to be minted

     * - `amount` Amount of tokens to be minted

     * - `sourceDomain` Circle domain for the source chain

     * - `targetDomain` Circle domain for the target chain

     * - `nonce` Circle sequence number for the transfer

     * - `fromAddress` Source CircleIntegration contract caller's address

     * - `mintRecipient` Recipient of minted tokens (must be caller of this contract)

     * - `payload` Arbitrary Wormhole message payload

     * @return EncodedDepositWithPayload bytes

     */

    function encodeDepositWithPayload(DepositWithPayload memory message) public pure returns (bytes memory) {

        return abi.encodePacked(

            uint8(1), // payloadId

            message.token,

            message.amount,

            message.sourceDomain,

            message.targetDomain,

            message.nonce,

            message.fromAddress,

            message.mintRecipient,

            uint16(message.payload.length),

            message.payload

        );

    }



    /**

     * @notice `decodeDepositWithPayload` decodes an encoded `DepositWithPayload` struct

     * @dev reverts if:

     * - the first byte (payloadId) does not equal 1

     * - the length of the payload is short or longer than expected

     * @param encoded Encoded `DepositWithPayload` struct

     * @return message `DepositWithPayload` struct containing the following attributes:

     * - `token` Address (bytes32 left-zero-padded) of token to be minted

     * - `amount` Amount of tokens to be minted

     * - `sourceDomain` Circle domain for the source chain

     * - `targetDomain` Circle domain for the target chain

     * - `nonce` Circle sequence number for the transfer

     * - `fromAddress` Source CircleIntegration contract caller's address

     * - `mintRecipient` Recipient of minted tokens (must be caller of this contract)

     * - `payload` Arbitrary Wormhole message payload

     */

    function decodeDepositWithPayload(bytes memory encoded) public pure returns (DepositWithPayload memory message) {

        // payloadId

        require(encoded.toUint8(0) == 1, "invalid message payloadId");



        uint256 index = 1;



        // token address

        message.token = encoded.toBytes32(index);

        index += 32;



        // token amount

        message.amount = encoded.toUint256(index);

        index += 32;



        // source domain

        message.sourceDomain = encoded.toUint32(index);

        index += 4;



        // target domain

        message.targetDomain = encoded.toUint32(index);

        index += 4;



        // nonce

        message.nonce = encoded.toUint64(index);

        index += 8;



        // fromAddress (contract caller)

        message.fromAddress = encoded.toBytes32(index);

        index += 32;



        // mintRecipient (target contract)

        message.mintRecipient = encoded.toBytes32(index);

        index += 32;



        // message payload length

        uint256 payloadLen = encoded.toUint16(index);

        index += 2;



        // parse the additional payload to confirm the entire message was parsed

        message.payload = encoded.slice(index, payloadLen);

        index += payloadLen;



        // confirm that the message payload is the expected length

        require(index == encoded.length, "invalid message length");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\CircleIntegrationProxy.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";



contract CircleIntegrationProxy is ERC1967Proxy {

    constructor(address implementation, bytes memory initData) ERC1967Proxy(implementation, initData) {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\CircleIntegrationSetters.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



import {CircleIntegrationState} from "./CircleIntegrationState.sol";



contract CircleIntegrationSetters is CircleIntegrationState {

    function setInitialized(address implementatiom) internal {

        _state.initializedImplementations[implementatiom] = true;

    }



    function setWormhole(address wormhole_) internal {

        _state.wormhole = payable(wormhole_);

    }



    function setChainId(uint16 chainId_) internal {

        _state.chainId = chainId_;

    }



    function setWormholeFinality(uint8 finality) internal {

        _state.wormholeFinality = finality;

    }



    function setCircleBridge(address circleBridgeAddress_) internal {

        _state.circleBridgeAddress = circleBridgeAddress_;

    }



    function setCircleTransmitter(address circleTransmitterAddress_) internal {

        _state.circleTransmitterAddress = circleTransmitterAddress_;

    }



    function setCircleTokenMinter(address circleTokenMinterAddress_) internal {

        _state.circleTokenMinterAddress = circleTokenMinterAddress_;

    }



    function setEmitter(uint16 chainId_, bytes32 emitter) internal {

        _state.registeredEmitters[chainId_] = emitter;

    }



    function setChainIdToDomain(uint16 chainId_, uint32 domain) internal {

        _state.chainIdToDomain[chainId_] = domain;

    }



    function setDomainToChainId(uint32 domain, uint16 chainId_) internal {

        _state.domainToChainId[domain] = chainId_;

    }



    function consumeMessage(bytes32 hash) internal {

        _state.consumedMessages[hash] = true;

    }



    function setLocalDomain(uint32 domain) internal {

        _state.localDomain = domain;

    }



    function setGovernance(uint16 governanceChainId, bytes32 governanceContract) internal {

        _state.governanceChainId = governanceChainId;

        _state.governanceContract = governanceContract;

    }



    function setEvmChain(uint256 evmChain) internal {

        _state.evmChain = evmChain;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\CircleIntegrationState.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



contract CircleIntegrationStorage {

    struct State {

        /// Wormhole chain ID of this contract

        uint16 chainId;



        /**

         * The number of block confirmations needed before the wormhole network

         * will attest a message.

         */

        uint8 wormholeFinality;



        /// Circle domain for this blockchain (grabbed from Circle's MessageTransmitter)

        uint32 localDomain;



        /// address of the Wormhole contract on this chain

        address wormhole;



        /// Wormhole governance chain ID

        uint16 governanceChainId;



        /// Wormhole governance contract address (bytes32 zero-left-padded)

        bytes32 governanceContract;



        /// address of the Circle Bridge contract on this chain

        address circleBridgeAddress;



        /// address of the Circle Message Transmitter on this chain

        address circleTransmitterAddress;



        /// address of the Circle Token Minter on this chain

        address circleTokenMinterAddress;



        /// mapping of initialized implementation (logic) contracts

        mapping(address => bool) initializedImplementations;



        /// Wormhole chain ID to known emitter address mapping

        mapping(uint16 => bytes32) registeredEmitters;



        /// Wormhole chain ID to Circle chain domain mapping

        mapping(uint16 => uint32) chainIdToDomain;



        /// Wormhole chain ID to Circle chain domain mapping

        mapping(uint32 => uint16) domainToChainId;



        /// verified Wormhole message hash to boolean

        mapping(bytes32 => bool) consumedMessages;



        /// expected EVM chain ID

        uint256 evmChain;



        /// storage gap for additional state variables in future versions

        uint256[50] ______gap;

    }

}



contract CircleIntegrationState {

    CircleIntegrationStorage.State _state;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\CircleIntegrationStructs.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



contract CircleIntegrationStructs {

    struct TransferParameters {

        address token;

        uint256 amount;

        uint16 targetChain;

        bytes32 mintRecipient;

    }



    struct RedeemParameters {

        bytes encodedWormholeMessage;

        bytes circleBridgeMessage;

        bytes circleAttestation;

    }



    struct DepositWithPayload {

        bytes32 token;

        uint256 amount;

        uint32 sourceDomain;

        uint32 targetDomain;

        uint64 nonce;

        bytes32 fromAddress;

        bytes32 mintRecipient;

        bytes payload;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Counters.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids.

 *

 * Include with `using Counters for Counters.Counter;`

 */

library Counters {

    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        unchecked {

            counter._value += 1;

        }

    }



    function decrement(Counter storage counter) internal {

        uint256 value = counter._value;

        require(value > 0, "Counter: decrement overflow");

        unchecked {

            counter._value = value - 1;

        }

    }



    function reset(Counter storage counter) internal {

        counter._value = 0;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\draft-IERC1822.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)



pragma solidity ^0.8.0;



/**

 * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified

 * proxy whose upgrades are fully controlled by the current implementation.

 */

interface IERC1822Proxiable {

    /**

     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation

     * address.

     *

     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks

     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this

     * function revert if invoked through a proxy.

     */

    function proxiableUUID() external view returns (bytes32);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\draft-IERC20Permit.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in

 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].

 *

 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by

 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't

 * need to send a transaction, and thus is not required to hold Ether at all.

 */

interface IERC20Permit {

    /**

     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,

     * given ``owner``'s signed approval.

     *

     * IMPORTANT: The same issues {IERC20-approve} has related to transaction

     * ordering also apply here.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `deadline` must be a timestamp in the future.

     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`

     * over the EIP712-formatted function arguments.

     * - the signature must use ``owner``'s current nonce (see {nonces}).

     *

     * For more information on the signature format, see the

     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP

     * section].

     */

    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external;



    /**

     * @dev Returns the current nonce for `owner`. This value must be

     * included whenever a signature is generated for {permit}.

     *

     * Every successful call to {permit} increases ``owner``'s nonce by one. This

     * prevents a signature from being used multiple times.

     */

    function nonces(address owner) external view returns (uint256);



    /**

     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.

     */

    // solhint-disable-next-line func-name-mixedcase

    function DOMAIN_SEPARATOR() external view returns (bytes32);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\ECDSA.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.

 *

 * These functions can be used to verify that a message was signed by the holder

 * of the private keys of a given address.

 */

library ECDSA {

    enum RecoverError {

        NoError,

        InvalidSignature,

        InvalidSignatureLength,

        InvalidSignatureS,

        InvalidSignatureV

    }



    function _throwError(RecoverError error) private pure {

        if (error == RecoverError.NoError) {

            return; // no error: do nothing

        } else if (error == RecoverError.InvalidSignature) {

            revert("ECDSA: invalid signature");

        } else if (error == RecoverError.InvalidSignatureLength) {

            revert("ECDSA: invalid signature length");

        } else if (error == RecoverError.InvalidSignatureS) {

            revert("ECDSA: invalid signature 's' value");

        } else if (error == RecoverError.InvalidSignatureV) {

            revert("ECDSA: invalid signature 'v' value");

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature` or error string. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     *

     * Documentation for signature generation:

     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]

     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {

        // Check the signature length

        // - case 65: r,s,v signature (standard)

        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._

        if (signature.length == 65) {

            bytes32 r;

            bytes32 s;

            uint8 v;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            assembly {

                r := mload(add(signature, 0x20))

                s := mload(add(signature, 0x40))

                v := byte(0, mload(add(signature, 0x60)))

            }

            return tryRecover(hash, v, r, s);

        } else if (signature.length == 64) {

            bytes32 r;

            bytes32 vs;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            assembly {

                r := mload(add(signature, 0x20))

                vs := mload(add(signature, 0x40))

            }

            return tryRecover(hash, r, vs);

        } else {

            return (address(0), RecoverError.InvalidSignatureLength);

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature`. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     */

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, signature);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.

     *

     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address, RecoverError) {

        bytes32 s;

        uint8 v;

        assembly {

            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)

            v := add(shr(255, vs), 27)

        }

        return tryRecover(hash, v, r, s);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.

     *

     * _Available since v4.2._

     */

    function recover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, r, vs);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,

     * `r` and `s` signature fields separately.

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address, RecoverError) {

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature

        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines

        // the valid range for s in (301): 0 < s < secp256k1n ?? 2 + 1, and for v in (302): v ?? {27, 28}. Most

        // signatures from current libraries generate a unique signature with an s-value in the lower half order.

        //

        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value

        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or

        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept

        // these malleable signatures as well.

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            return (address(0), RecoverError.InvalidSignatureS);

        }

        if (v != 27 && v != 28) {

            return (address(0), RecoverError.InvalidSignatureV);

        }



        // If the signature is valid (and not malleable), return the signer address

        address signer = ecrecover(hash, v, r, s);

        if (signer == address(0)) {

            return (address(0), RecoverError.InvalidSignature);

        }



        return (signer, RecoverError.NoError);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `v`,

     * `r` and `s` signature fields separately.

     */

    function recover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from a `hash`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        // 32 is the length in bytes of hash,

        // enforced by the type signature above

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }



    /**

     * @dev Returns an Ethereum Signed Typed Data, created from a

     * `domainSeparator` and a `structHash`. This produces hash corresponding

     * to the one signed with the

     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]

     * JSON-RPC method as part of EIP-712.

     *

     * See {recover}.

     */

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\ERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check

 * for the additional interface id that will be supported. For example:

 *

 * ```solidity

 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);

 * }

 * ```

 *

 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.

 */

abstract contract ERC165 is IERC165 {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IERC165).interfaceId;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\ERC1967Proxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../Proxy.sol";

import "./ERC1967Upgrade.sol";



/**

 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an

 * implementation address that can be changed. This address is stored in storage in the location specified by

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the

 * implementation behind the proxy.

 */

contract ERC1967Proxy is Proxy, ERC1967Upgrade {

    /**

     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.

     *

     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded

     * function call, and allows initializating the storage of the proxy like a Solidity constructor.

     */

    constructor(address _logic, bytes memory _data) payable {

        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));

        _upgradeToAndCall(_logic, _data, false);

    }



    /**

     * @dev Returns the current implementation address.

     */

    function _implementation() internal view virtual override returns (address impl) {

        return ERC1967Upgrade._getImplementation();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\ERC1967Upgrade.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.2;



import "../beacon/IBeacon.sol";

import "../../utils/Address.sol";

import "../../utils/StorageSlot.sol";



/**

 * @dev This abstract contract provides getters and event emitting update functions for

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.

 *

 * _Available since v4.1._

 *

 * @custom:oz-upgrades-unsafe-allow delegatecall

 */

abstract contract ERC1967Upgrade {

    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1

    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;



    /**

     * @dev Storage slot with the address of the current implementation.

     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



    /**

     * @dev Emitted when the implementation is upgraded.

     */

    event Upgraded(address indexed implementation);



    /**

     * @dev Returns the current implementation address.

     */

    function _getImplementation() internal view returns (address) {

        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 implementation slot.

     */

    function _setImplementation(address newImplementation) private {

        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

    }



    /**

     * @dev Perform implementation upgrade

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeTo(address newImplementation) internal {

        _setImplementation(newImplementation);

        emit Upgraded(newImplementation);

    }



    /**

     * @dev Perform implementation upgrade with additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCall(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        _upgradeTo(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }

    }



    /**

     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCallSecure(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        address oldImplementation = _getImplementation();



        // Initial upgrade and setup call

        _setImplementation(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }



        // Perform rollback test if not already in progress

        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);

        if (!rollbackTesting.value) {

            // Trigger rollback using upgradeTo from the new implementation

            rollbackTesting.value = true;

            Address.functionDelegateCall(

                newImplementation,

                abi.encodeWithSignature("upgradeTo(address)", oldImplementation)

            );

            rollbackTesting.value = false;

            // Check rollback was effective

            require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");

            // Finally reset to the new implementation and log the upgrade

            _upgradeTo(newImplementation);

        }

    }



    /**

     * @dev Storage slot with the admin of the contract.

     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



    /**

     * @dev Emitted when the admin account has changed.

     */

    event AdminChanged(address previousAdmin, address newAdmin);



    /**

     * @dev Returns the current admin.

     */

    function _getAdmin() internal view returns (address) {

        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 admin slot.

     */

    function _setAdmin(address newAdmin) private {

        require(newAdmin != address(0), "ERC1967: new admin is the zero address");

        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;

    }



    /**

     * @dev Changes the admin of the proxy.

     *

     * Emits an {AdminChanged} event.

     */

    function _changeAdmin(address newAdmin) internal {

        emit AdminChanged(_getAdmin(), newAdmin);

        _setAdmin(newAdmin);

    }



    /**

     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.

     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.

     */

    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;



    /**

     * @dev Emitted when the beacon is upgraded.

     */

    event BeaconUpgraded(address indexed beacon);



    /**

     * @dev Returns the current beacon.

     */

    function _getBeacon() internal view returns (address) {

        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;

    }



    /**

     * @dev Stores a new beacon in the EIP1967 beacon slot.

     */

    function _setBeacon(address newBeacon) private {

        require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");

        require(

            Address.isContract(IBeacon(newBeacon).implementation()),

            "ERC1967: beacon implementation is not a contract"

        );

        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;

    }



    /**

     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does

     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).

     *

     * Emits a {BeaconUpgraded} event.

     */

    function _upgradeBeaconToAndCall(

        address newBeacon,

        bytes memory data,

        bool forceCall

    ) internal {

        _setBeacon(newBeacon);

        emit BeaconUpgraded(newBeacon);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\ERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



import "../../GSN/Context.sol";

import "./IERC20.sol";

import "../../math/SafeMath.sol";

import "../../utils/Address.sol";



/**

 * @dev Implementation of the {IERC20} interface.

 *

 * This implementation is agnostic to the way tokens are created. This means

 * that a supply mechanism has to be added in a derived contract using {_mint}.

 * For a generic mechanism see {ERC20PresetMinterPauser}.

 *

 * TIP: For a detailed writeup see our guide

 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How

 * to implement supply mechanisms].

 *

 * We have followed general OpenZeppelin guidelines: functions revert instead

 * of returning `false` on failure. This behavior is nonetheless conventional

 * and does not conflict with the expectations of ERC20 applications.

 *

 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.

 * This allows applications to reconstruct the allowance for all accounts just

 * by listening to said events. Other implementations of the EIP may not emit

 * these events, as it isn't required by the specification.

 *

 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}

 * functions have been added to mitigate the well-known issues around setting

 * allowances. See {IERC20-approve}.

 */

contract ERC20 is Context, IERC20 {

    using SafeMath for uint256;

    using Address for address;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    string private _name;

    string private _symbol;

    uint8 private _decimals;



    /**

     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with

     * a default value of 18.

     *

     * To select a different value for {decimals}, use {_setupDecimals}.

     *

     * All three of these values are immutable: they can only be set once during

     * construction.

     */

    constructor (string memory name, string memory symbol) public {

        _name = name;

        _symbol = symbol;

        _decimals = 18;

    }



    /**

     * @dev Returns the name of the token.

     */

    function name() public view returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5,05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is

     * called.

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view override returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `recipient` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20};

     *

     * Requirements:

     * - `sender` and `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     * - the caller must have allowance for ``sender``'s tokens of at least

     * `amount`.

     */

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    /**

     * @dev Moves tokens `amount` from `sender` to `recipient`.

     *

     * This is internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `sender` cannot be the zero address.

     * - `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     */

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements

     *

     * - `to` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.

     *

     * This internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(address owner, address spender, uint256 amount) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    /**

     * @dev Sets {decimals} to a value other than the default one of 18.

     *

     * WARNING: This function should only be called from the constructor. Most

     * applications that interact with token contracts will not expect

     * {decimals} to ever change, and may work incorrectly if it does.

     */

    function _setupDecimals(uint8 decimals_) internal {

        _decimals = decimals_;

    }



    /**

     * @dev Hook that is called before any transfer of tokens. This includes

     * minting and burning.

     *

     * Calling conditions:

     *

     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * will be to transferred to `to`.

     * - when `from` is zero, `amount` tokens will be minted for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.

     * - `from` and `to` are never both zero.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Getters.sol
File type: .sol
// contracts/Getters.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./State.sol";



contract Getters is State {

    function getGuardianSet(uint32 index) public view returns (Structs.GuardianSet memory) {

        return _state.guardianSets[index];

    }



    function getCurrentGuardianSetIndex() public view returns (uint32) {

        return _state.guardianSetIndex;

    }



    function getGuardianSetExpiry() public view returns (uint32) {

        return _state.guardianSetExpiry;

    }



    function governanceActionIsConsumed(bytes32 hash) public view returns (bool) {

        return _state.consumedGovernanceActions[hash];

    }



    function isInitialized(address impl) public view returns (bool) {

        return _state.initializedImplementations[impl];

    }



    function chainId() public view returns (uint16) {

        return _state.provider.chainId;

    }



    function evmChainId() public view returns (uint256) {

        return _state.evmChainId;

    }



    function isFork() public view returns (bool) {

        return evmChainId() != block.chainid;

    }



    function governanceChainId() public view returns (uint16){

        return _state.provider.governanceChainId;

    }



    function governanceContract() public view returns (bytes32){

        return _state.provider.governanceContract;

    }



    function messageFee() public view returns (uint256) {

        return _state.messageFee;

    }



    function nextSequence(address emitter) public view returns (uint64) {

        return _state.sequences[emitter];

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Governance.sol
File type: .sol
// contracts/Governance.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./Structs.sol";

import "./GovernanceStructs.sol";

import "./Messages.sol";

import "./Setters.sol";



import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";



/**

 * @dev `Governance` defines a means to enacting changes to the core bridge contract,

 * guardianSets, message fees, and transfer fees

 */

abstract contract Governance is GovernanceStructs, Messages, Setters, ERC1967Upgrade {

    event ContractUpgraded(address indexed oldContract, address indexed newContract);

    event GuardianSetAdded(uint32 indexed index);



    // "Core" (left padded)

    bytes32 constant module = 0x00000000000000000000000000000000000000000000000000000000436f7265;



    /**

     * @dev Upgrades a contract via Governance VAA/VM

     */

    function submitContractUpgrade(bytes memory _vm) public {

        require(!isFork(), "invalid fork");



        Structs.VM memory vm = parseVM(_vm);



        // Verify the VAA is valid before processing it

        (bool isValid, string memory reason) = verifyGovernanceVM(vm);

        require(isValid, reason);



        GovernanceStructs.ContractUpgrade memory upgrade = parseContractUpgrade(vm.payload);



        // Verify the VAA is for this module

        require(upgrade.module == module, "Invalid Module");



        // Verify the VAA is for this chain

        require(upgrade.chain == chainId(), "Invalid Chain");



        // Record the governance action as consumed

        setGovernanceActionConsumed(vm.hash);



        // Upgrades the implementation to the new contract

        upgradeImplementation(upgrade.newContract);

    }



    /**

     * @dev Sets a `messageFee` via Governance VAA/VM

     */

    function submitSetMessageFee(bytes memory _vm) public {

        Structs.VM memory vm = parseVM(_vm);



        // Verify the VAA is valid before processing it

        (bool isValid, string memory reason) = verifyGovernanceVM(vm);

        require(isValid, reason);



        GovernanceStructs.SetMessageFee memory upgrade = parseSetMessageFee(vm.payload);



        // Verify the VAA is for this module

        require(upgrade.module == module, "Invalid Module");



        // Verify the VAA is for this chain

        require(upgrade.chain == chainId() && !isFork(), "Invalid Chain");



        // Record the governance action as consumed to prevent reentry

        setGovernanceActionConsumed(vm.hash);



        // Updates the messageFee

        setMessageFee(upgrade.messageFee);

    }



    /**

     * @dev Deploys a new `guardianSet` via Governance VAA/VM

     */

    function submitNewGuardianSet(bytes memory _vm) public {

        Structs.VM memory vm = parseVM(_vm);



        // Verify the VAA is valid before processing it

        (bool isValid, string memory reason) = verifyGovernanceVM(vm);

        require(isValid, reason);



        GovernanceStructs.GuardianSetUpgrade memory upgrade = parseGuardianSetUpgrade(vm.payload);



        // Verify the VAA is for this module

        require(upgrade.module == module, "invalid Module");



        // Verify the VAA is for this chain

        require((upgrade.chain == chainId() && !isFork()) || upgrade.chain == 0, "invalid Chain");



        // Verify the Guardian Set keys are not empty, this guards

        // against the accidential upgrade to an empty GuardianSet

        require(upgrade.newGuardianSet.keys.length > 0, "new guardian set is empty");



        // Verify that the index is incrementing via a predictable +1 pattern

        require(upgrade.newGuardianSetIndex == getCurrentGuardianSetIndex() + 1, "index must increase in steps of 1");



        // Record the governance action as consumed to prevent reentry

        setGovernanceActionConsumed(vm.hash);



        // Trigger a time-based expiry of current guardianSet

        expireGuardianSet(getCurrentGuardianSetIndex());



        // Add the new guardianSet to guardianSets

        storeGuardianSet(upgrade.newGuardianSet, upgrade.newGuardianSetIndex);



        // Makes the new guardianSet effective

        updateGuardianSetIndex(upgrade.newGuardianSetIndex);

    }



    /**

     * @dev Submits transfer fees to the recipient via Governance VAA/VM

     */

    function submitTransferFees(bytes memory _vm) public {

        Structs.VM memory vm = parseVM(_vm);



        // Verify the VAA is valid before processing it

        (bool isValid, string memory reason) = verifyGovernanceVM(vm);

        require(isValid, reason);



        // Obtains the transfer from the VAA payload

        GovernanceStructs.TransferFees memory transfer = parseTransferFees(vm.payload);



        // Verify the VAA is for this module

        require(transfer.module == module, "invalid Module");



        // Verify the VAA is for this chain

        require((transfer.chain == chainId() && !isFork()) || transfer.chain == 0, "invalid Chain");



        // Record the governance action as consumed to prevent reentry

        setGovernanceActionConsumed(vm.hash);



        // Obtains the recipient address to be paid transfer fees

        address payable recipient = payable(address(uint160(uint256(transfer.recipient))));



        // Transfers transfer fees to the recipient

        recipient.transfer(transfer.amount);

    }



    /**

    * @dev Updates the `chainId` and `evmChainId` on a forked chain via Governance VAA/VM

    */

    function submitRecoverChainId(bytes memory _vm) public {

        require(isFork(), "not a fork");



        Structs.VM memory vm = parseVM(_vm);



        // Verify the VAA is valid before processing it

        (bool isValid, string memory reason) = verifyGovernanceVM(vm);

        require(isValid, reason);



        GovernanceStructs.RecoverChainId memory rci = parseRecoverChainId(vm.payload);



        // Verify the VAA is for this module

        require(rci.module == module, "invalid Module");



        // Verify the VAA is for this chain

        require(rci.evmChainId == block.chainid, "invalid EVM Chain");



        // Record the governance action as consumed to prevent reentry

        setGovernanceActionConsumed(vm.hash);



        // Update the chainIds

        setEvmChainId(rci.evmChainId);

        setChainId(rci.newChainId);

    }



    /**

     * @dev Upgrades the `currentImplementation` with a `newImplementation`

     */

    function upgradeImplementation(address newImplementation) internal {

        address currentImplementation = _getImplementation();



        _upgradeTo(newImplementation);



        // Call initialize function of the new implementation

        (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature("initialize()"));



        require(success, string(reason));



        emit ContractUpgraded(currentImplementation, newImplementation);

    }



    /**

     * @dev Verifies a Governance VAA/VM is valid

     */

    function verifyGovernanceVM(Structs.VM memory vm) internal view returns (bool, string memory){

        // Verify the VAA is valid

        (bool isValid, string memory reason) = verifyVM(vm);

        if (!isValid){

            return (false, reason);

        }



        // only current guardianset can sign governance packets

        if (vm.guardianSetIndex != getCurrentGuardianSetIndex()) {

            return (false, "not signed by current guardian set");

        }



        // Verify the VAA is from the governance chain (Solana)

        if (uint16(vm.emitterChainId) != governanceChainId()) {

            return (false, "wrong governance chain");

        }



        // Verify the emitter contract is the governance contract (0x4 left padded)

        if (vm.emitterAddress != governanceContract()) {

            return (false, "wrong governance contract");

        }



        // Verify this governance action hasn't already been

        // consumed to prevent reentry and replay

        if (governanceActionIsConsumed(vm.hash)){

            return (false, "governance action already consumed");

        }



        // Confirm the governance VAA/VM is valid

        return (true, "");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\GovernanceStructs.sol
File type: .sol
// contracts/GovernanceStructs.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./libraries/external/BytesLib.sol";

import "./Structs.sol";



/**

 * @dev `GovernanceStructs` defines a set of structs and parsing functions

 * for minimal struct validation

 */

contract GovernanceStructs {

    using BytesLib for bytes;



    enum GovernanceAction {

        UpgradeContract,

        UpgradeGuardianset

    }



    struct ContractUpgrade {

        bytes32 module;

        uint8 action;

        uint16 chain;



        address newContract;

    }



    struct GuardianSetUpgrade {

        bytes32 module;

        uint8 action;

        uint16 chain;



        Structs.GuardianSet newGuardianSet;

        uint32 newGuardianSetIndex;

    }



    struct SetMessageFee {

        bytes32 module;

        uint8 action;

        uint16 chain;



        uint256 messageFee;

    }



    struct TransferFees {

        bytes32 module;

        uint8 action;

        uint16 chain;



        uint256 amount;

        bytes32 recipient;

    }



    struct RecoverChainId {

        bytes32 module;

        uint8 action;



        uint256 evmChainId;

        uint16 newChainId;

    }



    /// @dev Parse a contract upgrade (action 1) with minimal validation

    function parseContractUpgrade(bytes memory encodedUpgrade) public pure returns (ContractUpgrade memory cu) {

        uint index = 0;



        cu.module = encodedUpgrade.toBytes32(index);

        index += 32;



        cu.action = encodedUpgrade.toUint8(index);

        index += 1;



        require(cu.action == 1, "invalid ContractUpgrade");



        cu.chain = encodedUpgrade.toUint16(index);

        index += 2;



        cu.newContract = address(uint160(uint256(encodedUpgrade.toBytes32(index))));

        index += 32;



        require(encodedUpgrade.length == index, "invalid ContractUpgrade");

    }



    /// @dev Parse a guardianSet upgrade (action 2) with minimal validation

    function parseGuardianSetUpgrade(bytes memory encodedUpgrade) public pure returns (GuardianSetUpgrade memory gsu) {

        uint index = 0;



        gsu.module = encodedUpgrade.toBytes32(index);

        index += 32;



        gsu.action = encodedUpgrade.toUint8(index);

        index += 1;



        require(gsu.action == 2, "invalid GuardianSetUpgrade");



        gsu.chain = encodedUpgrade.toUint16(index);

        index += 2;



        gsu.newGuardianSetIndex = encodedUpgrade.toUint32(index);

        index += 4;



        uint8 guardianLength = encodedUpgrade.toUint8(index);

        index += 1;



        gsu.newGuardianSet = Structs.GuardianSet({

            keys : new address[](guardianLength),

            expirationTime : 0

        });



        for(uint i = 0; i < guardianLength; i++) {

            gsu.newGuardianSet.keys[i] = encodedUpgrade.toAddress(index);

            index += 20;

        }



        require(encodedUpgrade.length == index, "invalid GuardianSetUpgrade");

    }



    /// @dev Parse a setMessageFee (action 3) with minimal validation

    function parseSetMessageFee(bytes memory encodedSetMessageFee) public pure returns (SetMessageFee memory smf) {

        uint index = 0;



        smf.module = encodedSetMessageFee.toBytes32(index);

        index += 32;



        smf.action = encodedSetMessageFee.toUint8(index);

        index += 1;



        require(smf.action == 3, "invalid SetMessageFee");



        smf.chain = encodedSetMessageFee.toUint16(index);

        index += 2;



        smf.messageFee = encodedSetMessageFee.toUint256(index);

        index += 32;



        require(encodedSetMessageFee.length == index, "invalid SetMessageFee");

    }



    /// @dev Parse a transferFees (action 4) with minimal validation

    function parseTransferFees(bytes memory encodedTransferFees) public pure returns (TransferFees memory tf) {

        uint index = 0;



        tf.module = encodedTransferFees.toBytes32(index);

        index += 32;



        tf.action = encodedTransferFees.toUint8(index);

        index += 1;



        require(tf.action == 4, "invalid TransferFees");



        tf.chain = encodedTransferFees.toUint16(index);

        index += 2;



        tf.amount = encodedTransferFees.toUint256(index);

        index += 32;



        tf.recipient = encodedTransferFees.toBytes32(index);

        index += 32;



        require(encodedTransferFees.length == index, "invalid TransferFees");

    }



    /// @dev Parse a recoverChainId (action 5) with minimal validation

    function parseRecoverChainId(bytes memory encodedRecoverChainId) public pure returns (RecoverChainId memory rci) {

        uint index = 0;



        rci.module = encodedRecoverChainId.toBytes32(index);

        index += 32;



        rci.action = encodedRecoverChainId.toUint8(index);

        index += 1;



        require(rci.action == 5, "invalid RecoverChainId");



        rci.evmChainId = encodedRecoverChainId.toUint256(index);

        index += 32;



        rci.newChainId = encodedRecoverChainId.toUint16(index);

        index += 2;



        require(encodedRecoverChainId.length == index, "invalid RecoverChainId");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\IBeacon.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev This is the interface that {BeaconProxy} expects of its beacon.

 */

interface IBeacon {

    /**

     * @dev Must return an address that can be used as a delegate call target.

     *

     * {BeaconProxy} will check that this address is a contract.

     */

    function implementation() external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\ICircleBridge.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



import {IMessageTransmitter} from "./IMessageTransmitter.sol";

import {ITokenMinter} from "./ITokenMinter.sol";



interface ICircleBridge {

    /**

     * @notice Deposits and burns tokens from sender to be minted on destination domain.

     * Emits a `DepositForBurn` event.

     * @dev reverts if:

     * - given burnToken is not supported

     * - given destinationDomain has no CircleBridge registered

     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance

     * to this contract is less than `amount`.

     * - burn() reverts. For example, if `amount` is 0.

     * - MessageTransmitter returns false or reverts.

     * @param _amount amount of tokens to burn

     * @param _destinationDomain destination domain (ETH = 0, AVAX = 1)

     * @param _mintRecipient address of mint recipient on destination domain

     * @param _burnToken address of contract to burn deposited tokens, on local domain

     * @return _nonce unique nonce reserved by message

     */

    function depositForBurn(uint256 _amount, uint32 _destinationDomain, bytes32 _mintRecipient, address _burnToken)

        external

        returns (uint64 _nonce);



    /**

     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint

     * on the destination domain must be called by `_destinationCaller`.

     * WARNING: if the `_destinationCaller` does not represent a valid address as bytes32, then it will not be possible

     * to broadcast the message on the destination domain. This is an advanced feature, and the standard

     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.

     * Emits a `DepositForBurn` event.

     * @dev reverts if:

     * - given destinationCaller is zero address

     * - given burnToken is not supported

     * - given destinationDomain has no CircleBridge registered

     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance

     * to this contract is less than `amount`.

     * - burn() reverts. For example, if `amount` is 0.

     * - MessageTransmitter returns false or reverts.

     * @param _amount amount of tokens to burn

     * @param _destinationDomain destination domain

     * @param _mintRecipient address of mint recipient on destination domain

     * @param _burnToken address of contract to burn deposited tokens, on local domain

     * @param _destinationCaller caller on the destination domain, as bytes32

     * @return _nonce unique nonce reserved by message

     */

    function depositForBurnWithCaller(

        uint256 _amount,

        uint32 _destinationDomain,

        bytes32 _mintRecipient,

        address _burnToken,

        bytes32 _destinationCaller

    ) external returns (uint64 _nonce);



    function owner() external view returns (address);



    function handleReceiveMessage(uint32 _remoteDomain, bytes32 _sender, bytes memory messageBody)

        external

        view

        returns (bool);



    function localMessageTransmitter() external view returns (IMessageTransmitter);



    function localMinter() external view returns (ITokenMinter);



    function remoteCircleBridges(uint32 domain) external view returns (bytes32);



    // owner only methods

    function transferOwnership(address newOwner) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\ICircleIntegration.sol
File type: .sol
// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.19;



import {IWormhole} from "wormhole/interfaces/IWormhole.sol";

import {ICircleBridge} from "./circle/ICircleBridge.sol";

import {IMessageTransmitter} from "./circle/IMessageTransmitter.sol";



interface ICircleIntegration {

    struct TransferParameters {

        address token;

        uint256 amount;

        uint16 targetChain;

        bytes32 mintRecipient;

    }



    struct RedeemParameters {

        bytes encodedWormholeMessage;

        bytes circleBridgeMessage;

        bytes circleAttestation;

    }



    struct DepositWithPayload {

        bytes32 token;

        uint256 amount;

        uint32 sourceDomain;

        uint32 targetDomain;

        uint64 nonce;

        bytes32 fromAddress;

        bytes32 mintRecipient;

        bytes payload;

    }



    function transferTokensWithPayload(TransferParameters memory transferParams, uint32 batchId, bytes memory payload)

        external

        payable

        returns (uint64 messageSequence);



    function redeemTokensWithPayload(RedeemParameters memory params)

        external

        returns (DepositWithPayload memory depositWithPayload);



    function fetchLocalTokenAddress(uint32 sourceDomain, bytes32 sourceToken)

        external

        view

        returns (bytes32);



    function encodeDepositWithPayload(DepositWithPayload memory message) external pure returns (bytes memory);



    function decodeDepositWithPayload(bytes memory encoded) external pure returns (DepositWithPayload memory message);



    function isInitialized(address impl) external view returns (bool);



    function wormhole() external view returns (IWormhole);



    function chainId() external view returns (uint16);



    function wormholeFinality() external view returns (uint8);



    function circleBridge() external view returns (ICircleBridge);



    function circleTransmitter() external view returns (IMessageTransmitter);



    function getRegisteredEmitter(uint16 emitterChainId) external view returns (bytes32);



    function isAcceptedToken(address token) external view returns (bool);



    function getDomainFromChainId(uint16 chainId_) external view returns (uint32);



    function getChainIdFromDomain(uint32 domain) external view returns (uint16);



    function isMessageConsumed(bytes32 hash) external view returns (bool);



    function localDomain() external view returns (uint32);



    function verifyGovernanceMessage(bytes memory encodedMessage, uint8 action)

        external

        view

        returns (bytes32 messageHash, bytes memory payload);



    function evmChain() external view returns (uint256);



    // guardian governance only

    function updateWormholeFinality(bytes memory encodedMessage) external;



    function registerEmitterAndDomain(bytes memory encodedMessage) external;



    function upgradeContract(bytes memory encodedMessage) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\IERC721.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../../utils/introspection/IERC165.sol";



/**

 * @dev Required interface of an ERC721 compliant contract.

 */

interface IERC721 is IERC165 {

    /**

     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.

     */

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.

     */

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.

     */

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of tokens in ``owner``'s account.

     */

    function balanceOf(address owner) external view returns (uint256 balance);



    /**

     * @dev Returns the owner of the `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function ownerOf(uint256 tokenId) external view returns (address owner);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId

    ) external;



    /**

     * @dev Transfers `tokenId` token from `from` to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address from,

        address to,

        uint256 tokenId

    ) external;



    /**

     * @dev Gives permission to `to` to transfer `tokenId` token to another account.

     * The approval is cleared when the token is transferred.

     *

     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.

     *

     * Requirements:

     *

     * - The caller must own the token or be an approved operator.

     * - `tokenId` must exist.

     *

     * Emits an {Approval} event.

     */

    function approve(address to, uint256 tokenId) external;



    /**

     * @dev Returns the account approved for `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function getApproved(uint256 tokenId) external view returns (address operator);



    /**

     * @dev Approve or remove `operator` as an operator for the caller.

     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.

     *

     * Requirements:

     *

     * - The `operator` cannot be the caller.

     *

     * Emits an {ApprovalForAll} event.

     */

    function setApprovalForAll(address operator, bool _approved) external;



    /**

     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.

     *

     * See {setApprovalForAll}

     */

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId,

        bytes calldata data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\IERC721Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC721.sol";



/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

interface IERC721Metadata is IERC721 {

    /**

     * @dev Returns the token collection name.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the token collection symbol.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.

     */

    function tokenURI(uint256 tokenId) external view returns (string memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\IERC721Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

interface IERC721Receiver {

    /**

     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}

     * by `operator` from `from`, this function is called.

     *

     * It must return its Solidity selector to confirm the token transfer.

     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.

     *

     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.

     */

    function onERC721Received(

        address operator,

        address from,

        uint256 tokenId,

        bytes calldata data

    ) external returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\IMessageTransmitter.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



interface IMessageTransmitter {

    event MessageSent(bytes message);



    /**

     * @notice Emitted when tokens are minted

     * @param _mintRecipient recipient address of minted tokens

     * @param _amount amount of minted tokens

     * @param _mintToken contract address of minted token

     */

    event MintAndWithdraw(address _mintRecipient, uint256 _amount, address _mintToken);



    /**

     * @notice Receive a message. Messages with a given nonce

     * can only be broadcast once for a (sourceDomain, destinationDomain)

     * pair. The message body of a valid message is passed to the

     * specified recipient for further processing.

     *

     * @dev Attestation format:

     * A valid attestation is the concatenated 65-byte signature(s) of exactly

     * `thresholdSignature` signatures, in increasing order of attester address.

     * ***If the attester addresses recovered from signatures are not in

     * increasing order, signature verification will fail.***

     * If incorrect number of signatures or duplicate signatures are supplied,

     * signature verification will fail.

     *

     * Message format:

     * Field Bytes Type Index

     * version 4 uint32 0

     * sourceDomain 4 uint32 4

     * destinationDomain 4 uint32 8

     * nonce 8 uint64 12

     * sender 32 bytes32 20

     * recipient 32 bytes32 52

     * messageBody dynamic bytes 84

     * @param _message Message bytes

     * @param _attestation Concatenated 65-byte signature(s) of `_message`, in increasing order

     * of the attester address recovered from signatures.

     * @return success bool, true if successful

     */

    function receiveMessage(bytes memory _message, bytes calldata _attestation) external returns (bool success);



    function attesterManager() external view returns (address);



    function availableNonces(uint32 domain) external view returns (uint64);



    function getNumEnabledAttesters() external view returns (uint256);



    function isEnabledAttester(address _attester) external view returns (bool);



    function localDomain() external view returns (uint32);



    function maxMessageBodySize() external view returns (uint256);



    function owner() external view returns (address);



    function paused() external view returns (bool);



    function pauser() external view returns (address);



    function rescuer() external view returns (address);



    function version() external view returns (uint32);



    // owner only methods

    function transferOwnership(address newOwner) external;



    function updateAttesterManager(address _newAttesterManager) external;



    // attester manager only methods

    function getEnabledAttester(uint256 _index) external view returns (address);



    function disableAttester(address _attester) external;



    function enableAttester(address _attester) external;



    function setSignatureThreshold(uint256 newSignatureThreshold) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Implementation.sol
File type: .sol
// contracts/Implementation.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;

pragma experimental ABIEncoderV2;



import "./Governance.sol";



import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";



contract Implementation is Governance {

    event LogMessagePublished(address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel);



    // Publish a message to be attested by the Wormhole network

    function publishMessage(

        uint32 nonce,

        bytes memory payload,

        uint8 consistencyLevel

    ) public payable returns (uint64 sequence) {

        // check fee

        require(msg.value == messageFee(), "invalid fee");



        sequence = useSequence(msg.sender);

        // emit log

        emit LogMessagePublished(msg.sender, sequence, nonce, payload, consistencyLevel);

    }



    function useSequence(address emitter) internal returns (uint64 sequence) {

        sequence = nextSequence(emitter);

        setNextSequence(emitter, sequence + 1);

    }



    function initialize() initializer public virtual {

        // this function needs to be exposed for an upgrade to pass

        uint256 evmChainId;

        uint16 chain = chainId();



        // Wormhole chain ids explicitly enumerated

        if        (chain == 2)  { evmChainId = 1;          // ethereum

        } else if (chain == 4)  { evmChainId = 56;         // bsc

        } else if (chain == 5)  { evmChainId = 137;        // polygon

        } else if (chain == 6)  { evmChainId = 43114;      // avalanche

        } else if (chain == 7)  { evmChainId = 42262;      // oasis

        } else if (chain == 9)  { evmChainId = 1313161554; // aurora

        } else if (chain == 10) { evmChainId = 250;        // fantom

        } else if (chain == 11) { evmChainId = 686;        // karura

        } else if (chain == 12) { evmChainId = 787;        // acala

        } else if (chain == 13) { evmChainId = 8217;       // klaytn

        } else if (chain == 14) { evmChainId = 42220;      // celo

        } else if (chain == 16) { evmChainId = 1284;       // moonbeam

        } else if (chain == 17) { evmChainId = 245022934;  // neon

        } else if (chain == 23) { evmChainId = 42161;      // arbitrum

        } else if (chain == 24) { evmChainId = 10;         // optimism

        } else if (chain == 25) { evmChainId = 100;        // gnosis

        } else {

            revert("Unknown chain id.");

        }



        setEvmChainId(evmChainId);

    }



    modifier initializer() {

        address implementation = ERC1967Upgrade._getImplementation();



        require(

            !isInitialized(implementation),

            "already initialized"

        );



        setInitialized(implementation);



        _;

    }



    fallback() external payable {revert("unsupported");}



    receive() external payable {revert("the Wormhole contract does not accept assets");}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\ITokenMinter.sol
File type: .sol
// SPDX-License-Identifier: Apache 2

pragma solidity ^0.8.19;



/**

 * @title ITokenMinter

 * @notice interface for minter of tokens that are mintable, burnable, and interchangeable

 * across domains.

 */

interface ITokenMinter {

    function burnLimitsPerMessage(address token) external view returns (uint256);



    function remoteTokensToLocalTokens(bytes32 sourceIdHash) external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\IWormhole.sol
File type: .sol
// contracts/Messages.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "../Structs.sol";



interface IWormhole is Structs {

    event LogMessagePublished(address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel);



    function publishMessage(

        uint32 nonce,

        bytes memory payload,

        uint8 consistencyLevel

    ) external payable returns (uint64 sequence);



    function parseAndVerifyVM(bytes calldata encodedVM) external view returns (Structs.VM memory vm, bool valid, string memory reason);



    function verifyVM(Structs.VM memory vm) external view returns (bool valid, string memory reason);



    function verifySignatures(bytes32 hash, Structs.Signature[] memory signatures, Structs.GuardianSet memory guardianSet) external pure returns (bool valid, string memory reason) ;



    function parseVM(bytes memory encodedVM) external pure returns (Structs.VM memory vm);



    function getGuardianSet(uint32 index) external view returns (Structs.GuardianSet memory) ;



    function getCurrentGuardianSetIndex() external view returns (uint32) ;



    function getGuardianSetExpiry() external view returns (uint32) ;



    function governanceActionIsConsumed(bytes32 hash) external view returns (bool) ;



    function isInitialized(address impl) external view returns (bool) ;



    function chainId() external view returns (uint16) ;



    function governanceChainId() external view returns (uint16);



    function governanceContract() external view returns (bytes32);



    function messageFee() external view returns (uint256) ;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Messages.sol
File type: .sol
// contracts/Messages.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;

pragma experimental ABIEncoderV2;



import "./Getters.sol";

import "./Structs.sol";

import "./libraries/external/BytesLib.sol";





contract Messages is Getters {

    using BytesLib for bytes;



    /// @dev parseAndVerifyVM serves to parse an encodedVM and wholy validate it for consumption

    function parseAndVerifyVM(bytes calldata encodedVM) public view returns (Structs.VM memory vm, bool valid, string memory reason) {

        vm = parseVM(encodedVM);

        (valid, reason) = verifyVM(vm);

    }



   /**

    * @dev `verifyVM` serves to validate an arbitrary vm against a valid Guardian set

    *  - it aims to make sure the VM is for a known guardianSet

    *  - it aims to ensure the guardianSet is not expired

    *  - it aims to ensure the VM has reached quorum

    *  - it aims to verify the signatures provided against the guardianSet

    */

    function verifyVM(Structs.VM memory vm) public view returns (bool valid, string memory reason) {

        /// @dev Obtain the current guardianSet for the guardianSetIndex provided

        Structs.GuardianSet memory guardianSet = getGuardianSet(vm.guardianSetIndex);



       /**

        * @dev Checks whether the guardianSet has zero keys

        * WARNING: This keys check is critical to ensure the guardianSet has keys present AND to ensure

        * that guardianSet key size doesn't fall to zero and negatively impact quorum assessment.  If guardianSet

        * key length is 0 and vm.signatures length is 0, this could compromise the integrity of both vm and

        * signature verification.

        */

        if(guardianSet.keys.length == 0){

            return (false, "invalid guardian set");

        }



        /// @dev Checks if VM guardian set index matches the current index (unless the current set is expired).

        if(vm.guardianSetIndex != getCurrentGuardianSetIndex() && guardianSet.expirationTime < block.timestamp){

            return (false, "guardian set has expired");

        }



       /**

        * @dev We're using a fixed point number transformation with 1 decimal to deal with rounding.

        *   WARNING: This quorum check is critical to assessing whether we have enough Guardian signatures to validate a VM

        *   if making any changes to this, obtain additional peer review. If guardianSet key length is 0 and

        *   vm.signatures length is 0, this could compromise the integrity of both vm and signature verification.

        */

        if (vm.signatures.length < quorum(guardianSet.keys.length)){

            return (false, "no quorum");

        }



        /// @dev Verify the proposed vm.signatures against the guardianSet

        (bool signaturesValid, string memory invalidReason) = verifySignatures(vm.hash, vm.signatures, guardianSet);

        if(!signaturesValid){

            return (false, invalidReason);

        }



        /// If we are here, we've validated the VM is a valid multi-sig that matches the guardianSet.

        return (true, "");

    }



    /**

     * @dev verifySignatures serves to validate arbitrary sigatures against an arbitrary guardianSet

     *  - it intentionally does not solve for expectations within guardianSet (you should use verifyVM if you need these protections)

     *  - it intentioanlly does not solve for quorum (you should use verifyVM if you need these protections)

     *  - it intentionally returns true when signatures is an empty set (you should use verifyVM if you need these protections)

     */

    function verifySignatures(bytes32 hash, Structs.Signature[] memory signatures, Structs.GuardianSet memory guardianSet) public pure returns (bool valid, string memory reason) {

        uint8 lastIndex = 0;

        uint256 guardianCount = guardianSet.keys.length;

        for (uint i = 0; i < signatures.length; i++) {

            Structs.Signature memory sig = signatures[i];



            /// Ensure that provided signature indices are ascending only

            require(i == 0 || sig.guardianIndex > lastIndex, "signature indices must be ascending");

            lastIndex = sig.guardianIndex;



            /// @dev Ensure that the provided signature index is within the

            /// bounds of the guardianSet. This is implicitly checked by the array

            /// index operation below, so this check is technically redundant.

            /// However, reverting explicitly here ensures that a bug is not

            /// introduced accidentally later due to the nontrivial storage

            /// semantics of solidity.

            require(sig.guardianIndex < guardianCount, "guardian index out of bounds");



            /// Check to see if the signer of the signature does not match a specific Guardian key at the provided index

            if(ecrecover(hash, sig.v, sig.r, sig.s) != guardianSet.keys[sig.guardianIndex]){

                return (false, "VM signature invalid");

            }

        }



        /// If we are here, we've validated that the provided signatures are valid for the provided guardianSet

        return (true, "");

    }



    /**

     * @dev parseVM serves to parse an encodedVM into a vm struct

     *  - it intentionally performs no validation functions, it simply parses raw into a struct

     */

    function parseVM(bytes memory encodedVM) public pure virtual returns (Structs.VM memory vm) {

        uint index = 0;



        vm.version = encodedVM.toUint8(index);

        index += 1;

        // SECURITY: Note that currently the VM.version is not part of the hash 

        // and for reasons described below it cannot be made part of the hash. 

        // This means that this field's integrity is not protected and cannot be trusted. 

        // This is not a problem today since there is only one accepted version, but it 

        // could be a problem if we wanted to allow other versions in the future. 

        require(vm.version == 1, "VM version incompatible"); 



        vm.guardianSetIndex = encodedVM.toUint32(index);

        index += 4;



        // Parse Signatures

        uint256 signersLen = encodedVM.toUint8(index);

        index += 1;

        vm.signatures = new Structs.Signature[](signersLen);

        for (uint i = 0; i < signersLen; i++) {

            vm.signatures[i].guardianIndex = encodedVM.toUint8(index);

            index += 1;



            vm.signatures[i].r = encodedVM.toBytes32(index);

            index += 32;

            vm.signatures[i].s = encodedVM.toBytes32(index);

            index += 32;

            vm.signatures[i].v = encodedVM.toUint8(index) + 27;

            index += 1;

        }



        /*

        Hash the body



        SECURITY: Do not change the way the hash of a VM is computed! 

        Changing it could result into two different hashes for the same observation. 

        But xDapps rely on the hash of an observation for replay protection.

        */

        bytes memory body = encodedVM.slice(index, encodedVM.length - index);

        vm.hash = keccak256(abi.encodePacked(keccak256(body)));



        // Parse the body

        vm.timestamp = encodedVM.toUint32(index);

        index += 4;



        vm.nonce = encodedVM.toUint32(index);

        index += 4;



        vm.emitterChainId = encodedVM.toUint16(index);

        index += 2;



        vm.emitterAddress = encodedVM.toBytes32(index);

        index += 32;



        vm.sequence = encodedVM.toUint64(index);

        index += 8;



        vm.consistencyLevel = encodedVM.toUint8(index);

        index += 1;



        vm.payload = encodedVM.slice(index, encodedVM.length - index);

    }



    /**

     * @dev quorum serves solely to determine the number of signatures required to acheive quorum

     */

    function quorum(uint numGuardians) public pure virtual returns (uint numSignaturesRequiredForQuorum) {

        // The max number of guardians is 255

        require(numGuardians < 256, "too many guardians");

        return ((numGuardians * 2) / 3) + 1;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFT.sol
File type: .sol
// contracts/Structs.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;

import "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol";



contract BridgeNFT is BeaconProxy {

    constructor(address beacon, bytes memory data) BeaconProxy(beacon, data) {



    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTBridge.sol
File type: .sol
// contracts/Bridge.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";



import "../libraries/external/BytesLib.sol";



import "./NFTBridgeGetters.sol";

import "./NFTBridgeSetters.sol";

import "./NFTBridgeStructs.sol";

import "./NFTBridgeGovernance.sol";



import "./token/NFT.sol";

import "./token/NFTImplementation.sol";



contract NFTBridge is NFTBridgeGovernance {

    using BytesLib for bytes;



    // Initiate a Transfer

    function transferNFT(address token, uint256 tokenID, uint16 recipientChain, bytes32 recipient, uint32 nonce) public payable returns (uint64 sequence) {

        // determine token parameters

        uint16 tokenChain;

        bytes32 tokenAddress;

        if (isWrappedAsset(token)) {

            tokenChain = NFTImplementation(token).chainId();

            tokenAddress = NFTImplementation(token).nativeContract();

        } else {

            tokenChain = chainId();

            tokenAddress = bytes32(uint256(uint160(token)));

            // Verify that the correct interfaces are implemented

            require(ERC165(token).supportsInterface(type(IERC721).interfaceId), "must support the ERC721 interface");

            require(ERC165(token).supportsInterface(type(IERC721Metadata).interfaceId), "must support the ERC721-Metadata extension");

        }



        string memory symbolString;

        string memory nameString;

        string memory uriString;

        {

            if (tokenChain != 1) { // SPL tokens use cache

                (,bytes memory queriedSymbol) = token.staticcall(abi.encodeWithSignature("symbol()"));

                (,bytes memory queriedName) = token.staticcall(abi.encodeWithSignature("name()"));

                symbolString = abi.decode(queriedSymbol, (string));

                nameString = abi.decode(queriedName, (string));

            }



            (,bytes memory queriedURI) = token.staticcall(abi.encodeWithSignature("tokenURI(uint256)", tokenID));

            uriString = abi.decode(queriedURI, (string));

        }



        bytes32 symbol;

        bytes32 name;

        if (tokenChain == 1) {

            // use cached SPL token info, as the contracts uses unified values

            NFTBridgeStorage.SPLCache memory cache = splCache(tokenID);

            symbol = cache.symbol;

            name = cache.name;

            clearSplCache(tokenID);

        } else {

            assembly {

            // first 32 bytes hold string length

                symbol := mload(add(symbolString, 32))

                name := mload(add(nameString, 32))

            }

        }



        if (tokenChain == chainId()) {

            IERC721(token).safeTransferFrom(msg.sender, address(this), tokenID);

        } else {

            NFTImplementation(token).burn(tokenID);

        }



        sequence = logTransfer(NFTBridgeStructs.Transfer({

            tokenAddress : tokenAddress,

            tokenChain   : tokenChain,

            name         : name,

            symbol       : symbol,

            tokenID      : tokenID,

            uri          : uriString,

            to           : recipient,

            toChain      : recipientChain

        }), msg.value, nonce);

    }



    function logTransfer(NFTBridgeStructs.Transfer memory transfer, uint256 callValue, uint32 nonce) internal returns (uint64 sequence) {

        bytes memory encoded = encodeTransfer(transfer);



        sequence = wormhole().publishMessage{

            value : callValue

        }(nonce, encoded, 15);

    }



    function completeTransfer(bytes memory encodedVm) public {

        _completeTransfer(encodedVm);

    }



    // Execute a Transfer message

    function _completeTransfer(bytes memory encodedVm) internal {

        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);



        require(valid, reason);

        require(verifyBridgeVM(vm), "invalid emitter");



        NFTBridgeStructs.Transfer memory transfer = parseTransfer(vm.payload);



        require(!isTransferCompleted(vm.hash), "transfer already completed");

        setTransferCompleted(vm.hash);



        require(transfer.toChain == chainId(), "invalid target chain");



        IERC721 transferToken;

        if (transfer.tokenChain == chainId()) {

            transferToken = IERC721(address(uint160(uint256(transfer.tokenAddress))));

        } else {

            address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);



            // If the wrapped asset does not exist yet, create it

            if (wrapped == address(0)) {

                wrapped = _createWrapped(transfer.tokenChain, transfer.tokenAddress, transfer.name, transfer.symbol);

            }



            transferToken = IERC721(wrapped);

        }



        // transfer bridged NFT to recipient

        address transferRecipient = address(uint160(uint256(transfer.to)));



        if (transfer.tokenChain != chainId()) {

            if (transfer.tokenChain == 1) {

                // Cache SPL token info which otherwise would get lost

                setSplCache(transfer.tokenID, NFTBridgeStorage.SPLCache({

                    name : transfer.name,

                    symbol : transfer.symbol

                }));

            }



            // mint wrapped asset

            NFTImplementation(address(transferToken)).mint(transferRecipient, transfer.tokenID, transfer.uri);

        } else {

            transferToken.safeTransferFrom(address(this), transferRecipient, transfer.tokenID);

        }

    }



    // Creates a wrapped asset using AssetMeta

    function _createWrapped(uint16 tokenChain, bytes32 tokenAddress, bytes32 name, bytes32 symbol) internal returns (address token) {

        require(tokenChain != chainId(), "can only wrap tokens from foreign chains");

        require(wrappedAsset(tokenChain, tokenAddress) == address(0), "wrapped asset already exists");



        // SPL NFTs all use the same NFT contract, so unify the name

        if (tokenChain == 1) {

            // "Wormhole Bridged Solana-NFT" - right-padded

            name =   0x576f726d686f6c65204272696467656420536f6c616e612d4e46540000000000;

            // "WORMSPLNFT" - right-padded

            symbol = 0x574f524d53504c4e465400000000000000000000000000000000000000000000;

        }



        // initialize the NFTImplementation

        bytes memory initialisationArgs = abi.encodeWithSelector(

            NFTImplementation.initialize.selector,

            bytes32ToString(name),

            bytes32ToString(symbol),



            address(this),



            tokenChain,

            tokenAddress

        );



        // initialize the BeaconProxy

        bytes memory constructorArgs = abi.encode(address(this), initialisationArgs);



        // deployment code

        bytes memory bytecode = abi.encodePacked(type(BridgeNFT).creationCode, constructorArgs);



        bytes32 salt = keccak256(abi.encodePacked(tokenChain, tokenAddress));



        assembly {

            token := create2(0, add(bytecode, 0x20), mload(bytecode), salt)



            if iszero(extcodesize(token)) {

                revert(0, 0)

            }

        }



        setWrappedAsset(tokenChain, tokenAddress, token);

    }



    function verifyBridgeVM(IWormhole.VM memory vm) internal view returns (bool){

        if (bridgeContracts(vm.emitterChainId) == vm.emitterAddress) {

            return true;

        }



        return false;

    }



    function encodeTransfer(NFTBridgeStructs.Transfer memory transfer) public pure returns (bytes memory encoded) {

        encoded = abi.encodePacked(

            uint8(1),

            transfer.tokenAddress,

            transfer.tokenChain,

            transfer.symbol,

            transfer.name,

            transfer.tokenID,

            uint8(bytes(transfer.uri).length),

            transfer.uri,

            transfer.to,

            transfer.toChain

        );

    }



    function parseTransfer(bytes memory encoded) public pure returns (NFTBridgeStructs.Transfer memory transfer) {

        uint index = 0;



        uint8 payloadID = encoded.toUint8(index);

        index += 1;



        require(payloadID == 1, "invalid Transfer");



        transfer.tokenAddress = encoded.toBytes32(index);

        index += 32;



        transfer.tokenChain = encoded.toUint16(index);

        index += 2;



        transfer.symbol = encoded.toBytes32(index);

        index += 32;



        transfer.name = encoded.toBytes32(index);

        index += 32;



        transfer.tokenID = encoded.toUint256(index);

        index += 32;



        uint8 len_uri = encoded.toUint8(index);

        index += 1;



        transfer.uri = string(encoded.slice(index, len_uri));

        index += len_uri;



        transfer.to = encoded.toBytes32(index);

        index += 32;



        transfer.toChain = encoded.toUint16(index);

        index += 2;



        require(encoded.length == index, "invalid Transfer");

    }



    function onERC721Received(

        address operator,

        address,

        uint256,

        bytes calldata

    ) external view returns (bytes4){

        require(operator == address(this), "can only bridge tokens via transferNFT method");

        return type(IERC721Receiver).interfaceId;

    }



    function bytes32ToString(bytes32 input) internal pure returns (string memory) {

        uint256 i;

        while (i < 32 && input[i] != 0) {

            i++;

        }

        bytes memory array = new bytes(i);

        for (uint c = 0; c < i; c++) {

            array[c] = input[c];

        }

        return string(array);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTBridgeEntrypoint.sol
File type: .sol
// contracts/Wormhole.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";



contract NFTBridgeEntrypoint is ERC1967Proxy {

    constructor (address implementation, bytes memory initData)

        ERC1967Proxy(

            implementation,

            initData

        )

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTBridgeGetters.sol
File type: .sol
// contracts/Getters.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";



import "../interfaces/IWormhole.sol";



import "./NFTBridgeState.sol";



contract NFTBridgeGetters is NFTBridgeState {

    function governanceActionIsConsumed(bytes32 hash) public view returns (bool) {

        return _state.consumedGovernanceActions[hash];

    }



    function isInitialized(address impl) public view returns (bool) {

        return _state.initializedImplementations[impl];

    }



    function isTransferCompleted(bytes32 hash) public view returns (bool) {

        return _state.completedTransfers[hash];

    }



    function wormhole() public view returns (IWormhole) {

        return IWormhole(_state.wormhole);

    }



    function chainId() public view returns (uint16){

        return _state.provider.chainId;

    }



    function governanceChainId() public view returns (uint16){

        return _state.provider.governanceChainId;

    }



    function governanceContract() public view returns (bytes32){

        return _state.provider.governanceContract;

    }



    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress) public view returns (address){

        return _state.wrappedAssets[tokenChainId][tokenAddress];

    }



    function bridgeContracts(uint16 chainId_) public view returns (bytes32){

        return _state.bridgeImplementations[chainId_];

    }



    function tokenImplementation() public view returns (address){

        return _state.tokenImplementation;

    }



    function isWrappedAsset(address token) public view returns (bool){

        return _state.isWrappedAsset[token];

    }



    function splCache(uint256 tokenId) public view returns (NFTBridgeStorage.SPLCache memory) {

        return _state.splCache[tokenId];

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTBridgeGovernance.sol
File type: .sol
// contracts/Bridge.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";



import "../libraries/external/BytesLib.sol";



import "./NFTBridgeGetters.sol";

import "./NFTBridgeSetters.sol";

import "./NFTBridgeStructs.sol";



import "./token/NFT.sol";

import "./token/NFTImplementation.sol";



import "../interfaces/IWormhole.sol";



contract NFTBridgeGovernance is NFTBridgeGetters, NFTBridgeSetters, ERC1967Upgrade {

    using BytesLib for bytes;



    // "NFTBridge" (left padded)

    bytes32 constant module = 0x00000000000000000000000000000000000000000000004e4654427269646765;



    // Execute a RegisterChain governance message

    function registerChain(bytes memory encodedVM) public {

        (IWormhole.VM memory vm, bool valid, string memory reason) = verifyGovernanceVM(encodedVM);

        require(valid, reason);



        setGovernanceActionConsumed(vm.hash);



        NFTBridgeStructs.RegisterChain memory chain = parseRegisterChain(vm.payload);



        require(chain.chainId == chainId() || chain.chainId == 0, "invalid chain id");



        setBridgeImplementation(chain.emitterChainID, chain.emitterAddress);

    }



    // Execute a UpgradeContract governance message

    function upgrade(bytes memory encodedVM) public {

        (IWormhole.VM memory vm, bool valid, string memory reason) = verifyGovernanceVM(encodedVM);

        require(valid, reason);



        setGovernanceActionConsumed(vm.hash);



        NFTBridgeStructs.UpgradeContract memory implementation = parseUpgrade(vm.payload);



        require(implementation.chainId == chainId(), "wrong chain id");



        upgradeImplementation(address(uint160(uint256(implementation.newContract))));

    }



    function verifyGovernanceVM(bytes memory encodedVM) internal view returns (IWormhole.VM memory parsedVM, bool isValid, string memory invalidReason){

        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVM);



        if(!valid){

            return (vm, valid, reason);

        }



        if (vm.emitterChainId != governanceChainId()) {

            return (vm, false, "wrong governance chain");

        }

        if (vm.emitterAddress != governanceContract()) {

            return (vm, false, "wrong governance contract");

        }



        if(governanceActionIsConsumed(vm.hash)){

            return (vm, false, "governance action already consumed");

        }



        return (vm, true, "");

    }



    event ContractUpgraded(address indexed oldContract, address indexed newContract);

    function upgradeImplementation(address newImplementation) internal {

        address currentImplementation = _getImplementation();



        _upgradeTo(newImplementation);



        // Call initialize function of the new implementation

        (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature("initialize()"));



        require(success, string(reason));



        emit ContractUpgraded(currentImplementation, newImplementation);

    }



    function parseRegisterChain(bytes memory encoded) public pure returns(NFTBridgeStructs.RegisterChain memory chain) {

        uint index = 0;



        // governance header



        chain.module = encoded.toBytes32(index);

        index += 32;

        require(chain.module == module, "invalid RegisterChain: wrong module");



        chain.action = encoded.toUint8(index);

        index += 1;

        require(chain.action == 1, "invalid RegisterChain: wrong action");



        chain.chainId = encoded.toUint16(index);

        index += 2;



        // payload



        chain.emitterChainID = encoded.toUint16(index);

        index += 2;



        chain.emitterAddress = encoded.toBytes32(index);

        index += 32;



        require(encoded.length == index, "invalid RegisterChain: wrong length");

    }



    function parseUpgrade(bytes memory encoded) public pure returns(NFTBridgeStructs.UpgradeContract memory chain) {

        uint index = 0;



        // governance header



        chain.module = encoded.toBytes32(index);

        index += 32;

        require(chain.module == module, "invalid UpgradeContract: wrong module");



        chain.action = encoded.toUint8(index);

        index += 1;

        require(chain.action == 2, "invalid UpgradeContract: wrong action");



        chain.chainId = encoded.toUint16(index);

        index += 2;



        // payload



        chain.newContract = encoded.toBytes32(index);

        index += 32;



        require(encoded.length == index, "invalid UpgradeContract: wrong length");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTBridgeImplementation.sol
File type: .sol
// contracts/Implementation.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;

pragma experimental ABIEncoderV2;



import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";



import "./NFTBridge.sol";





contract NFTBridgeImplementation is NFTBridge {

    // Beacon getter for the token contracts

    function implementation() public view returns (address) {

        return tokenImplementation();

    }



    modifier initializer() {

        address impl = ERC1967Upgrade._getImplementation();



        require(

            !isInitialized(impl),

            "already initialized"

        );



        setInitialized(impl);



        _;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTBridgeSetters.sol
File type: .sol
// contracts/Setters.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./NFTBridgeState.sol";



contract NFTBridgeSetters is NFTBridgeState {

    function setInitialized(address implementatiom) internal {

        _state.initializedImplementations[implementatiom] = true;

    }



    function setGovernanceActionConsumed(bytes32 hash) internal {

        _state.consumedGovernanceActions[hash] = true;

    }



    function setTransferCompleted(bytes32 hash) internal {

        _state.completedTransfers[hash] = true;

    }



    function setChainId(uint16 chainId) internal {

        _state.provider.chainId = chainId;

    }



    function setGovernanceChainId(uint16 chainId) internal {

        _state.provider.governanceChainId = chainId;

    }



    function setGovernanceContract(bytes32 governanceContract) internal {

        _state.provider.governanceContract = governanceContract;

    }



    function setBridgeImplementation(uint16 chainId, bytes32 bridgeContract) internal {

        _state.bridgeImplementations[chainId] = bridgeContract;

    }



    function setTokenImplementation(address impl) internal {

        _state.tokenImplementation = impl;

    }



    function setWormhole(address wh) internal {

        _state.wormhole = payable(wh);

    }



    function setWrappedAsset(uint16 tokenChainId, bytes32 tokenAddress, address wrapper) internal {

        _state.wrappedAssets[tokenChainId][tokenAddress] = wrapper;

        _state.isWrappedAsset[wrapper] = true;

    }



    function setSplCache(uint256 tokenId, NFTBridgeStorage.SPLCache memory cache) internal {

        _state.splCache[tokenId] = cache;

    }



    function clearSplCache(uint256 tokenId) internal {

        delete _state.splCache[tokenId];

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTBridgeSetup.sol
File type: .sol
// contracts/BridgeSetup.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;

pragma experimental ABIEncoderV2;



import "./NFTBridgeGovernance.sol";



import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";



contract NFTBridgeSetup is NFTBridgeSetters, ERC1967Upgrade {

    function setup(

        address implementation,

        uint16 chainId,

        address wormhole,

        uint16 governanceChainId,

        bytes32 governanceContract,

        address tokenImplementation

    ) public {

        setChainId(chainId);



        setWormhole(wormhole);



        setGovernanceChainId(governanceChainId);

        setGovernanceContract(governanceContract);



        setTokenImplementation(tokenImplementation);



        // Register Solana contract

        setBridgeImplementation(1, 0x0def15a24423e1edd1a5ab16f557b9060303ddbab8c803d2ee48f4b78a1cfd6b);



        _upgradeTo(implementation);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTBridgeState.sol
File type: .sol
// contracts/State.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./NFTBridgeStructs.sol";



contract NFTBridgeStorage {

    struct Provider {

        uint16 chainId;

        uint16 governanceChainId;

        bytes32 governanceContract;

    }



    struct Asset {

        uint16 chainId;

        bytes32 assetAddress;

    }



    struct SPLCache {

        bytes32 name;

        bytes32 symbol;

    }



    struct State {

        address payable wormhole;

        address tokenImplementation;



        Provider provider;



        // Mapping of consumed governance actions

        mapping(bytes32 => bool) consumedGovernanceActions;



        // Mapping of consumed token transfers

        mapping(bytes32 => bool) completedTransfers;



        // Mapping of initialized implementations

        mapping(address => bool) initializedImplementations;



        // Mapping of wrapped assets (chainID => nativeAddress => wrappedAddress)

        mapping(uint16 => mapping(bytes32 => address)) wrappedAssets;



        // Mapping to safely identify wrapped assets

        mapping(address => bool) isWrappedAsset;



        // Mapping of bridge contracts on other chains

        mapping(uint16 => bytes32) bridgeImplementations;



        // Mapping of spl token info caches (chainID => nativeAddress => SPLCache)

        mapping(uint256 => SPLCache) splCache;

    }

}



contract NFTBridgeState {

    NFTBridgeStorage.State _state;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTBridgeStructs.sol
File type: .sol
// contracts/Structs.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



contract NFTBridgeStructs {

    struct Transfer {

        // PayloadID uint8 = 1

        // Address of the token. Left-zero-padded if shorter than 32 bytes

        bytes32 tokenAddress;

        // Chain ID of the token

        uint16 tokenChain;

        // Symbol of the token (UTF-8)

        bytes32 symbol;

        // Name of the token (UTF-8)

        bytes32 name;

        // TokenID of the token

        uint256 tokenID;

        // URI of the token metadata (UTF-8)

        string uri;

        // Address of the recipient. Left-zero-padded if shorter than 32 bytes

        bytes32 to;

        // Chain ID of the recipient

        uint16 toChain;

    }



    struct RegisterChain {

        // Governance Header

        // module: "NFTBridge" left-padded

        bytes32 module;

        // governance action: 1

        uint8 action;

        // governance paket chain id: this or 0

        uint16 chainId;



        // Chain ID

        uint16 emitterChainID;

        // Emitter address. Left-zero-padded if shorter than 32 bytes

        bytes32 emitterAddress;

    }



    struct UpgradeContract {

        // Governance Header

        // module: "NFTBridge" left-padded

        bytes32 module;

        // governance action: 2

        uint8 action;

        // governance paket chain id

        uint16 chainId;



        // Address of the new contract

        bytes32 newContract;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTImplementation.sol
File type: .sol
// contracts/TokenImplementation.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./NFTState.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/utils/Context.sol";

import "@openzeppelin/contracts/utils/Address.sol";

import "@openzeppelin/contracts/utils/Strings.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";

import "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol";



// Based on the OpenZepplin ERC721 implementation, licensed under MIT

contract NFTImplementation is NFTState, Context, IERC721, IERC721Metadata, ERC165 {

    using Address for address;

    using Strings for uint256;



    function initialize(

        string memory name_,

        string memory symbol_,



        address owner_,



        uint16 chainId_,

        bytes32 nativeContract_

    ) initializer public {

        _state.name = name_;

        _state.symbol = symbol_;



        _state.owner = owner_;



        _state.chainId = chainId_;

        _state.nativeContract = nativeContract_;

    }



    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {

        return

        interfaceId == type(IERC721).interfaceId ||

        interfaceId == type(IERC721Metadata).interfaceId ||

        super.supportsInterface(interfaceId);

    }



    function balanceOf(address owner_) public view override returns (uint256) {

        require(owner_ != address(0), "ERC721: balance query for the zero address");

        return _state.balances[owner_];

    }



    function ownerOf(uint256 tokenId) public view override returns (address) {

        address owner_ = _state.owners[tokenId];

        require(owner_ != address(0), "ERC721: owner query for nonexistent token");

        return owner_;

    }



    function name() public view override returns (string memory) {

        return _state.name;

    }



    function symbol() public view override returns (string memory) {

        return _state.symbol;

    }



    function tokenURI(uint256 tokenId) public view override returns (string memory) {

        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");



        return _state.tokenURIs[tokenId];

    }



    function chainId() public view returns (uint16) {

        return _state.chainId;

    }



    function nativeContract() public view returns (bytes32) {

        return _state.nativeContract;

    }



    function owner() public view returns (address) {

        return _state.owner;

    }



    function approve(address to, uint256 tokenId) public override {

        address owner_ = NFTImplementation.ownerOf(tokenId);

        require(to != owner_, "ERC721: approval to current owner");



        require(

            _msgSender() == owner_ || isApprovedForAll(owner_, _msgSender()),

            "ERC721: approve caller is not owner nor approved for all"

        );



        _approve(to, tokenId);

    }



    function getApproved(uint256 tokenId) public view override returns (address) {

        require(_exists(tokenId), "ERC721: approved query for nonexistent token");



        return _state.tokenApprovals[tokenId];

    }



    function setApprovalForAll(address operator, bool approved) public override {

        require(operator != _msgSender(), "ERC721: approve to caller");



        _state.operatorApprovals[_msgSender()][operator] = approved;

        emit ApprovalForAll(_msgSender(), operator, approved);

    }



    function isApprovedForAll(address owner_, address operator) public view override returns (bool) {

        return _state.operatorApprovals[owner_][operator];

    }



    function transferFrom(

        address from,

        address to,

        uint256 tokenId

    ) public override {

        //solhint-disable-next-line max-line-length

        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");



        _transfer(from, to, tokenId);

    }



    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId

    ) public override {

        safeTransferFrom(from, to, tokenId, "");

    }



    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId,

        bytes memory _data

    ) public override {

        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        _safeTransfer(from, to, tokenId, _data);

    }



    function _safeTransfer(

        address from,

        address to,

        uint256 tokenId,

        bytes memory _data

    ) internal {

        _transfer(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");

    }



    function _exists(uint256 tokenId) internal view returns (bool) {

        return _state.owners[tokenId] != address(0);

    }



    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {

        require(_exists(tokenId), "ERC721: operator query for nonexistent token");

        address owner_ = NFTImplementation.ownerOf(tokenId);

        return (spender == owner_ || getApproved(tokenId) == spender || isApprovedForAll(owner_, spender));

    }



    function mint(address to, uint256 tokenId, string memory uri) public onlyOwner {

        _mint(to, tokenId, uri);

    }



    function _mint(address to, uint256 tokenId, string memory uri) internal {

        require(to != address(0), "ERC721: mint to the zero address");

        require(!_exists(tokenId), "ERC721: token already minted");



        _state.balances[to] += 1;

        _state.owners[tokenId] = to;

        _state.tokenURIs[tokenId] = uri;



        emit Transfer(address(0), to, tokenId);

    }



    function burn(uint256 tokenId) public onlyOwner {

        _burn(tokenId);

    }



    function _burn(uint256 tokenId) internal {

        address owner_ = NFTImplementation.ownerOf(tokenId);



        // Clear approvals

        _approve(address(0), tokenId);



        _state.balances[owner_] -= 1;

        delete _state.owners[tokenId];



        emit Transfer(owner_, address(0), tokenId);

    }



    function _transfer(

        address from,

        address to,

        uint256 tokenId

    ) internal {

        require(NFTImplementation.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");

        require(to != address(0), "ERC721: transfer to the zero address");



        // Clear approvals from the previous owner

        _approve(address(0), tokenId);



        _state.balances[from] -= 1;

        _state.balances[to] += 1;

        _state.owners[tokenId] = to;



        emit Transfer(from, to, tokenId);

    }



    function _approve(address to, uint256 tokenId) internal {

        _state.tokenApprovals[tokenId] = to;

        emit Approval(NFTImplementation.ownerOf(tokenId), to, tokenId);

    }



    function _checkOnERC721Received(

        address from,

        address to,

        uint256 tokenId,

        bytes memory _data

    ) private returns (bool) {

        if (to.isContract()) {

            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {

                return retval == IERC721Receiver.onERC721Received.selector;

            } catch (bytes memory reason) {

                if (reason.length == 0) {

                    revert("ERC721: transfer to non ERC721Receiver implementer");

                } else {

                    assembly {

                        revert(add(32, reason), mload(reason))

                    }

                }

            }

        } else {

            return true;

        }

    }



    modifier onlyOwner() {

        require(owner() == _msgSender(), "caller is not the owner");

        _;

    }



    modifier initializer() {

        require(

            !_state.initialized,

            "Already initialized"

        );



        _state.initialized = true;



        _;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\NFTState.sol
File type: .sol
// contracts/State.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



contract NFTStorage {

    struct State {



        // Token name

        string name;



        // Token symbol

        string symbol;



        // Mapping from token ID to owner address

        mapping(uint256 => address) owners;



        // Mapping owner address to token count

        mapping(address => uint256) balances;



        // Mapping from token ID to approved address

        mapping(uint256 => address) tokenApprovals;



        // Mapping from token ID to URI

        mapping(uint256 => string) tokenURIs;



        // Mapping from owner to operator approvals

        mapping(address => mapping(address => bool)) operatorApprovals;



        address owner;



        bool initialized;



        uint16 chainId;

        bytes32 nativeContract;

    }

}



contract NFTState {

    NFTStorage.State _state;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/Context.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _setOwner(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _setOwner(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _setOwner(newOwner);

    }



    function _setOwner(address newOwner) private {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Proxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM

 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to

 * be specified by overriding the virtual {_implementation} function.

 *

 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a

 * different contract through the {_delegate} function.

 *

 * The success and return data of the delegated call will be returned back to the caller of the proxy.

 */

abstract contract Proxy {

    /**

     * @dev Delegates the current call to `implementation`.

     *

     * This function does not return to its internall call site, it will return directly to the external caller.

     */

    function _delegate(address implementation) internal virtual {

        assembly {

            // Copy msg.data. We take full control of memory in this inline assembly

            // block because it will not return to Solidity code. We overwrite the

            // Solidity scratch pad at memory position 0.

            calldatacopy(0, 0, calldatasize())



            // Call the implementation.

            // out and outsize are 0 because we don't know the size yet.

            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)



            // Copy the returned data.

            returndatacopy(0, 0, returndatasize())



            switch result

            // delegatecall returns 0 on error.

            case 0 {

                revert(0, returndatasize())

            }

            default {

                return(0, returndatasize())

            }

        }

    }



    /**

     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function

     * and {_fallback} should delegate.

     */

    function _implementation() internal view virtual returns (address);



    /**

     * @dev Delegates the current call to the address returned by `_implementation()`.

     *

     * This function does not return to its internall call site, it will return directly to the external caller.

     */

    function _fallback() internal virtual {

        _beforeFallback();

        _delegate(_implementation());

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other

     * function in the contract matches the call data.

     */

    fallback() external payable virtual {

        _fallback();

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data

     * is empty.

     */

    receive() external payable virtual {

        _fallback();

    }



    /**

     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`

     * call, or as part of the Solidity `fallback` or `receive` functions.

     *

     * If overriden should call `super._beforeFallback()`.

     */

    function _beforeFallback() internal virtual {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\ReentrancyGuard.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * TIP: If you would like to learn more about reentrancy and alternative ways

 * to protect against it, check out our blog post

 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].

 */

abstract contract ReentrancyGuard {

    // Booleans are more expensive than uint256 or any type that takes up a full

    // word because each write operation emits an extra SLOAD to first read the

    // slot's contents, replace the bits taken up by the boolean, and then write

    // back. This is the compiler's defense against contract upgrades and

    // pointer aliasing, and it cannot be disabled.



    // The values being non-zero value makes deployment a bit more expensive,

    // but in exchange the refund on every call to nonReentrant will be lower in

    // amount. Since refunds are capped to a percentage of the total

    // transaction's gas, it is best to keep them low in cases like this one, to

    // increase the likelihood of the full refund coming into effect.

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    uint256 private _status;



    constructor() {

        _status = _NOT_ENTERED;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _status = _ENTERED;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _status = _NOT_ENTERED;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC20.sol";

import "../../../utils/Address.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender) + value;

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        unchecked {

            uint256 oldAllowance = token.allowance(address(this), spender);

            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");

            uint256 newAllowance = oldAllowance - value;

            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

        }

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {

            // Return data is optional

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\SafeMath.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Setters.sol
File type: .sol
// contracts/Setters.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./State.sol";



contract Setters is State {

    function updateGuardianSetIndex(uint32 newIndex) internal {

        _state.guardianSetIndex = newIndex;

    }



    function expireGuardianSet(uint32 index) internal {

        _state.guardianSets[index].expirationTime = uint32(block.timestamp) + 86400;

    }



    function storeGuardianSet(Structs.GuardianSet memory set, uint32 index) internal {

        _state.guardianSets[index] = set;

    }



    function setInitialized(address implementatiom) internal {

        _state.initializedImplementations[implementatiom] = true;

    }



    function setGovernanceActionConsumed(bytes32 hash) internal {

        _state.consumedGovernanceActions[hash] = true;

    }



    function setChainId(uint16 chainId) internal {

        _state.provider.chainId = chainId;

    }



    function setGovernanceChainId(uint16 chainId) internal {

        _state.provider.governanceChainId = chainId;

    }



    function setGovernanceContract(bytes32 governanceContract) internal {

        _state.provider.governanceContract = governanceContract;

    }



    function setMessageFee(uint256 newFee) internal {

        _state.messageFee = newFee;

    }



    function setNextSequence(address emitter, uint64 sequence) internal {

        _state.sequences[emitter] = sequence;

    }



    function setEvmChainId(uint256 evmChainId) internal {

        require(evmChainId == block.chainid, "invalid evmChainId");

        _state.evmChainId = evmChainId;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\State.sol
File type: .sol
// contracts/State.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "./Structs.sol";



contract Events {

    event LogGuardianSetChanged(

        uint32 oldGuardianIndex,

        uint32 newGuardianIndex

    );



    event LogMessagePublished(

        address emitter_address,

        uint32 nonce,

        bytes payload

    );

}



contract Storage {

    struct WormholeState {

        Structs.Provider provider;



        // Mapping of guardian_set_index => guardian set

        mapping(uint32 => Structs.GuardianSet) guardianSets;



        // Current active guardian set index

        uint32 guardianSetIndex;



        // Period for which a guardian set stays active after it has been replaced

        uint32 guardianSetExpiry;



        // Sequence numbers per emitter

        mapping(address => uint64) sequences;



        // Mapping of consumed governance actions

        mapping(bytes32 => bool) consumedGovernanceActions;



        // Mapping of initialized implementations

        mapping(address => bool) initializedImplementations;



        uint256 messageFee;



        // EIP-155 Chain ID

        uint256 evmChainId;

    }

}



contract State {

    Storage.WormholeState _state;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\StorageSlot.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Library for reading and writing primitive types to specific storage slots.

 *

 * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.

 * This library helps with reading and writing to such slots without the need for inline assembly.

 *

 * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.

 *

 * Example usage to set ERC1967 implementation slot:

 * ```

 * contract ERC1967 {

 *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

 *

 *     function _getImplementation() internal view returns (address) {

 *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

 *     }

 *

 *     function _setImplementation(address newImplementation) internal {

 *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

 *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

 *     }

 * }

 * ```

 *

 * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._

 */

library StorageSlot {

    struct AddressSlot {

        address value;

    }



    struct BooleanSlot {

        bool value;

    }



    struct Bytes32Slot {

        bytes32 value;

    }



    struct Uint256Slot {

        uint256 value;

    }



    /**

     * @dev Returns an `AddressSlot` with member `value` located at `slot`.

     */

    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.

     */

    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.

     */

    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.

     */

    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {

        assembly {

            r.slot := slot

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Strings.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev String operations.

 */

library Strings {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Structs.sol
File type: .sol
// contracts/Structs.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



interface Structs {

	struct Provider {

		uint16 chainId;

		uint16 governanceChainId;

		bytes32 governanceContract;

	}



	struct GuardianSet {

		address[] keys;

		uint32 expirationTime;

	}



	struct Signature {

		bytes32 r;

		bytes32 s;

		uint8 v;

		uint8 guardianIndex;

	}



	struct VM {

		uint8 version;

		uint32 timestamp;

		uint32 nonce;

		uint16 emitterChainId;

		bytes32 emitterAddress;

		uint64 sequence;

		uint8 consistencyLevel;

		bytes payload;



		uint32 guardianSetIndex;

		Signature[] signatures;



		bytes32 hash;

	}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Token.sol
File type: .sol
// contracts/Structs.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol";



contract BridgeToken is BeaconProxy {

    constructor(address beacon, bytes memory data) BeaconProxy(beacon, data) {



    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\TokenBridge.sol
File type: .sol
// contracts/Wormhole.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";



contract TokenBridge is ERC1967Proxy {

    constructor (address implementation, bytes memory initData)

    ERC1967Proxy(

        implementation,

        initData

    )

    {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\TokenImplementation.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2023-03-24

*/



// SPDX-License-Identifier: Apache 2

// File: @openzeppelin/contracts/utils/Counters.sol





pragma solidity ^0.8.0;



/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids.

 *

 * Include with `using Counters for Counters.Counter;`

 */

library Counters {

    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        unchecked {

            counter._value += 1;

        }

    }



    function decrement(Counter storage counter) internal {

        uint256 value = counter._value;

        require(value > 0, "Counter: decrement overflow");

        unchecked {

            counter._value = value - 1;

        }

    }



    function reset(Counter storage counter) internal {

        counter._value = 0;

    }

}



// File: contracts/bridge/token/TokenState.sol



// contracts/State.sol



pragma solidity ^0.8.0;



contract TokenStorage {

    struct State {

        string name;

        string symbol;



        uint64 metaLastUpdatedSequence;



        uint256 totalSupply;

        uint8 decimals;



        mapping(address => uint256) balances;



        mapping(address => mapping(address => uint256)) allowances;



        address owner;



        bool initialized;



        uint16 chainId;

        bytes32 nativeContract;



        // EIP712

        // Cache the domain separator and salt, but also store the chain id that 

        // it corresponds to, in order to invalidate the cached domain separator

        // if the chain id changes.

        bytes32 cachedDomainSeparator;

        uint256 cachedChainId;

        address cachedThis;

        bytes32 cachedSalt;

        bytes32 cachedHashedName;



        // ERC20Permit draft

        mapping(address => Counters.Counter) nonces;

    }

}



contract TokenState {

    using Counters for Counters.Counter;



    TokenStorage.State _state;



    /**

     * @dev See {IERC20Permit-nonces}.

     */

    function nonces(address owner_) public view returns (uint256) {

        return _state.nonces[owner_].current();

    }



    /**

     * @dev "Consume a nonce": return the current value and increment.

     */

    function _useNonce(address owner_) internal returns (uint256 current) {

        Counters.Counter storage nonce = _state.nonces[owner_];

        current = nonce.current();

        nonce.increment();

    }

}



// File: @openzeppelin/contracts/utils/Context.sol





pragma solidity ^0.8.0;



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}



// File: @openzeppelin/contracts/access/Ownable.sol





pragma solidity ^0.8.0;



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _setOwner(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _setOwner(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _setOwner(newOwner);

    }



    function _setOwner(address newOwner) private {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}



// File: @openzeppelin/contracts/proxy/beacon/IBeacon.sol





pragma solidity ^0.8.0;



/**

 * @dev This is the interface that {BeaconProxy} expects of its beacon.

 */

interface IBeacon {

    /**

     * @dev Must return an address that can be used as a delegate call target.

     *

     * {BeaconProxy} will check that this address is a contract.

     */

    function implementation() external view returns (address);

}



// File: @openzeppelin/contracts/proxy/Proxy.sol





pragma solidity ^0.8.0;



/**

 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM

 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to

 * be specified by overriding the virtual {_implementation} function.

 *

 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a

 * different contract through the {_delegate} function.

 *

 * The success and return data of the delegated call will be returned back to the caller of the proxy.

 */

abstract contract Proxy {

    /**

     * @dev Delegates the current call to `implementation`.

     *

     * This function does not return to its internall call site, it will return directly to the external caller.

     */

    function _delegate(address implementation) internal virtual {

        assembly {

            // Copy msg.data. We take full control of memory in this inline assembly

            // block because it will not return to Solidity code. We overwrite the

            // Solidity scratch pad at memory position 0.

            calldatacopy(0, 0, calldatasize())



            // Call the implementation.

            // out and outsize are 0 because we don't know the size yet.

            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)



            // Copy the returned data.

            returndatacopy(0, 0, returndatasize())



            switch result

            // delegatecall returns 0 on error.

            case 0 {

                revert(0, returndatasize())

            }

            default {

                return(0, returndatasize())

            }

        }

    }



    /**

     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function

     * and {_fallback} should delegate.

     */

    function _implementation() internal view virtual returns (address);



    /**

     * @dev Delegates the current call to the address returned by `_implementation()`.

     *

     * This function does not return to its internall call site, it will return directly to the external caller.

     */

    function _fallback() internal virtual {

        _beforeFallback();

        _delegate(_implementation());

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other

     * function in the contract matches the call data.

     */

    fallback() external payable virtual {

        _fallback();

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data

     * is empty.

     */

    receive() external payable virtual {

        _fallback();

    }



    /**

     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`

     * call, or as part of the Solidity `fallback` or `receive` functions.

     *

     * If overriden should call `super._beforeFallback()`.

     */

    function _beforeFallback() internal virtual {}

}



// File: @openzeppelin/contracts/utils/Address.sol





pragma solidity ^0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/utils/StorageSlot.sol





pragma solidity ^0.8.0;



/**

 * @dev Library for reading and writing primitive types to specific storage slots.

 *

 * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.

 * This library helps with reading and writing to such slots without the need for inline assembly.

 *

 * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.

 *

 * Example usage to set ERC1967 implementation slot:

 * ```

 * contract ERC1967 {

 *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

 *

 *     function _getImplementation() internal view returns (address) {

 *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

 *     }

 *

 *     function _setImplementation(address newImplementation) internal {

 *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

 *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

 *     }

 * }

 * ```

 *

 * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._

 */

library StorageSlot {

    struct AddressSlot {

        address value;

    }



    struct BooleanSlot {

        bool value;

    }



    struct Bytes32Slot {

        bytes32 value;

    }



    struct Uint256Slot {

        uint256 value;

    }



    /**

     * @dev Returns an `AddressSlot` with member `value` located at `slot`.

     */

    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.

     */

    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.

     */

    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.

     */

    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {

        assembly {

            r.slot := slot

        }

    }

}



// File: @openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol





pragma solidity ^0.8.2;







/**

 * @dev This abstract contract provides getters and event emitting update functions for

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.

 *

 * _Available since v4.1._

 *

 * @custom:oz-upgrades-unsafe-allow delegatecall

 */

abstract contract ERC1967Upgrade {

    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1

    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;



    /**

     * @dev Storage slot with the address of the current implementation.

     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



    /**

     * @dev Emitted when the implementation is upgraded.

     */

    event Upgraded(address indexed implementation);



    /**

     * @dev Returns the current implementation address.

     */

    function _getImplementation() internal view returns (address) {

        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 implementation slot.

     */

    function _setImplementation(address newImplementation) private {

        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

    }



    /**

     * @dev Perform implementation upgrade

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeTo(address newImplementation) internal {

        _setImplementation(newImplementation);

        emit Upgraded(newImplementation);

    }



    /**

     * @dev Perform implementation upgrade with additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCall(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        _upgradeTo(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }

    }



    /**

     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCallSecure(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        address oldImplementation = _getImplementation();



        // Initial upgrade and setup call

        _setImplementation(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }



        // Perform rollback test if not already in progress

        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);

        if (!rollbackTesting.value) {

            // Trigger rollback using upgradeTo from the new implementation

            rollbackTesting.value = true;

            Address.functionDelegateCall(

                newImplementation,

                abi.encodeWithSignature("upgradeTo(address)", oldImplementation)

            );

            rollbackTesting.value = false;

            // Check rollback was effective

            require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");

            // Finally reset to the new implementation and log the upgrade

            _upgradeTo(newImplementation);

        }

    }



    /**

     * @dev Storage slot with the admin of the contract.

     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



    /**

     * @dev Emitted when the admin account has changed.

     */

    event AdminChanged(address previousAdmin, address newAdmin);



    /**

     * @dev Returns the current admin.

     */

    function _getAdmin() internal view returns (address) {

        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 admin slot.

     */

    function _setAdmin(address newAdmin) private {

        require(newAdmin != address(0), "ERC1967: new admin is the zero address");

        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;

    }



    /**

     * @dev Changes the admin of the proxy.

     *

     * Emits an {AdminChanged} event.

     */

    function _changeAdmin(address newAdmin) internal {

        emit AdminChanged(_getAdmin(), newAdmin);

        _setAdmin(newAdmin);

    }



    /**

     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.

     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.

     */

    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;



    /**

     * @dev Emitted when the beacon is upgraded.

     */

    event BeaconUpgraded(address indexed beacon);



    /**

     * @dev Returns the current beacon.

     */

    function _getBeacon() internal view returns (address) {

        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;

    }



    /**

     * @dev Stores a new beacon in the EIP1967 beacon slot.

     */

    function _setBeacon(address newBeacon) private {

        require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");

        require(

            Address.isContract(IBeacon(newBeacon).implementation()),

            "ERC1967: beacon implementation is not a contract"

        );

        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;

    }



    /**

     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does

     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).

     *

     * Emits a {BeaconUpgraded} event.

     */

    function _upgradeBeaconToAndCall(

        address newBeacon,

        bytes memory data,

        bool forceCall

    ) internal {

        _setBeacon(newBeacon);

        emit BeaconUpgraded(newBeacon);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);

        }

    }

}



// File: @openzeppelin/contracts/proxy/beacon/BeaconProxy.sol





pragma solidity ^0.8.0;







/**

 * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.

 *

 * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't

 * conflict with the storage layout of the implementation behind the proxy.

 *

 * _Available since v3.4._

 */

contract BeaconProxy is Proxy, ERC1967Upgrade {

    /**

     * @dev Initializes the proxy with `beacon`.

     *

     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This

     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity

     * constructor.

     *

     * Requirements:

     *

     * - `beacon` must be a contract with the interface {IBeacon}.

     */

    constructor(address beacon, bytes memory data) payable {

        assert(_BEACON_SLOT == bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1));

        _upgradeBeaconToAndCall(beacon, data, false);

    }



    /**

     * @dev Returns the current beacon address.

     */

    function _beacon() internal view virtual returns (address) {

        return _getBeacon();

    }



    /**

     * @dev Returns the current implementation address of the associated beacon.

     */

    function _implementation() internal view virtual override returns (address) {

        return IBeacon(_getBeacon()).implementation();

    }



    /**

     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.

     *

     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.

     *

     * Requirements:

     *

     * - `beacon` must be a contract.

     * - The implementation returned by `beacon` must be a contract.

     */

    function _setBeacon(address beacon, bytes memory data) internal virtual {

        _upgradeBeaconToAndCall(beacon, data, false);

    }

}



// File: @openzeppelin/contracts/utils/cryptography/ECDSA.sol





pragma solidity ^0.8.0;



/**

 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.

 *

 * These functions can be used to verify that a message was signed by the holder

 * of the private keys of a given address.

 */

library ECDSA {

    enum RecoverError {

        NoError,

        InvalidSignature,

        InvalidSignatureLength,

        InvalidSignatureS,

        InvalidSignatureV

    }



    function _throwError(RecoverError error) private pure {

        if (error == RecoverError.NoError) {

            return; // no error: do nothing

        } else if (error == RecoverError.InvalidSignature) {

            revert("ECDSA: invalid signature");

        } else if (error == RecoverError.InvalidSignatureLength) {

            revert("ECDSA: invalid signature length");

        } else if (error == RecoverError.InvalidSignatureS) {

            revert("ECDSA: invalid signature 's' value");

        } else if (error == RecoverError.InvalidSignatureV) {

            revert("ECDSA: invalid signature 'v' value");

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature` or error string. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     *

     * Documentation for signature generation:

     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]

     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {

        // Check the signature length

        // - case 65: r,s,v signature (standard)

        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._

        if (signature.length == 65) {

            bytes32 r;

            bytes32 s;

            uint8 v;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            assembly {

                r := mload(add(signature, 0x20))

                s := mload(add(signature, 0x40))

                v := byte(0, mload(add(signature, 0x60)))

            }

            return tryRecover(hash, v, r, s);

        } else if (signature.length == 64) {

            bytes32 r;

            bytes32 vs;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            assembly {

                r := mload(add(signature, 0x20))

                vs := mload(add(signature, 0x40))

            }

            return tryRecover(hash, r, vs);

        } else {

            return (address(0), RecoverError.InvalidSignatureLength);

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature`. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     */

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, signature);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.

     *

     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address, RecoverError) {

        bytes32 s;

        uint8 v;

        assembly {

            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)

            v := add(shr(255, vs), 27)

        }

        return tryRecover(hash, v, r, s);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.

     *

     * _Available since v4.2._

     */

    function recover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, r, vs);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,

     * `r` and `s` signature fields separately.

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address, RecoverError) {

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature

        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines

        // the valid range for s in (301): 0 < s < secp256k1n ?? 2 + 1, and for v in (302): v ?? {27, 28}. Most

        // signatures from current libraries generate a unique signature with an s-value in the lower half order.

        //

        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value

        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or

        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept

        // these malleable signatures as well.

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            return (address(0), RecoverError.InvalidSignatureS);

        }

        if (v != 27 && v != 28) {

            return (address(0), RecoverError.InvalidSignatureV);

        }



        // If the signature is valid (and not malleable), return the signer address

        address signer = ecrecover(hash, v, r, s);

        if (signer == address(0)) {

            return (address(0), RecoverError.InvalidSignature);

        }



        return (signer, RecoverError.NoError);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `v`,

     * `r` and `s` signature fields separately.

     */

    function recover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from a `hash`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        // 32 is the length in bytes of hash,

        // enforced by the type signature above

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }



    /**

     * @dev Returns an Ethereum Signed Typed Data, created from a

     * `domainSeparator` and a `structHash`. This produces hash corresponding

     * to the one signed with the

     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]

     * JSON-RPC method as part of EIP-712.

     *

     * See {recover}.

     */

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));

    }

}



// File: contracts/bridge/token/TokenImplementation.sol



// contracts/TokenImplementation.sol



pragma solidity ^0.8.0;











// Based on the OpenZepplin ERC20 implementation, licensed under MIT

contract TokenImplementation is TokenState, Context {

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);



    function initialize(

        string memory name_,

        string memory symbol_,

        uint8 decimals_,

        uint64 sequence_,

        address owner_,

        uint16 chainId_,

        bytes32 nativeContract_

    ) initializer public {

        _initializeNativeToken(

            name_,

            symbol_,

            decimals_,

            sequence_,

            owner_,

            chainId_,

            nativeContract_

        );



        // initialize w/ EIP712 state variables for domain separator

        _initializePermitStateIfNeeded();

    }



    function _initializeNativeToken(

        string memory name_,

        string memory symbol_,

        uint8 decimals_,

        uint64 sequence_,

        address owner_,

        uint16 chainId_,

        bytes32 nativeContract_

    ) internal {

        _state.name = name_;

        _state.symbol = symbol_;

        _state.decimals = decimals_;

        _state.metaLastUpdatedSequence = sequence_;



        _state.owner = owner_;



        _state.chainId = chainId_;

        _state.nativeContract = nativeContract_;

    }



    function _initializePermitStateIfNeeded() internal {

        // If someone were to change the implementation of name(), we

        // need to make sure we recache.

        bytes32 hashedName = _eip712DomainNameHashed();



        // If for some reason the salt generation changes with newer

        // token implementations, we need to make sure the state reflects

        // the new salt.

        bytes32 salt = _eip712DomainSalt();



        // check cached values

        if (_state.cachedHashedName != hashedName || _state.cachedSalt != salt) {

            _state.cachedChainId = block.chainid;

            _state.cachedThis = address(this);

            _state.cachedDomainSeparator = _buildDomainSeparator(hashedName, salt);

            _state.cachedSalt = salt;

            _state.cachedHashedName = hashedName;

        }

    }



    function name() public view returns (string memory) {

        return _state.name;

    }



    function symbol() public view returns (string memory) {

        return _state.symbol;

    }



    function owner() public view returns (address) {

        return _state.owner;

    }



    function decimals() public view returns (uint8) {

        return _state.decimals;

    }



    function totalSupply() public view returns (uint256) {

        return _state.totalSupply;

    }



    function chainId() public view returns (uint16) {

        return _state.chainId;

    }



    function nativeContract() public view returns (bytes32) {

        return _state.nativeContract;

    }



    function balanceOf(address account_) public view returns (uint256) {

        return _state.balances[account_];

    }



    function transfer(address recipient_, uint256 amount_) public returns (bool) {

        _transfer(_msgSender(), recipient_, amount_);

        return true;

    }



    function allowance(address owner_, address spender_) public view returns (uint256) {

        return _state.allowances[owner_][spender_];

    }



    function approve(address spender_, uint256 amount_) public returns (bool) {

        _approve(_msgSender(), spender_, amount_);

        return true;

    }



    function transferFrom(address sender_, address recipient_, uint256 amount_) public returns (bool) {

        _transfer(sender_, recipient_, amount_);



        uint256 currentAllowance = _state.allowances[sender_][_msgSender()];

        require(currentAllowance >= amount_, "ERC20: transfer amount exceeds allowance");

        _approve(sender_, _msgSender(), currentAllowance - amount_);



        return true;

    }



    function increaseAllowance(address spender_, uint256 addedValue_) public returns (bool) {

        _approve(_msgSender(), spender_, _state.allowances[_msgSender()][spender_] + addedValue_);

        return true;

    }



    function decreaseAllowance(address spender_, uint256 subtractedValue_) public returns (bool) {

        uint256 currentAllowance = _state.allowances[_msgSender()][spender_];

        require(currentAllowance >= subtractedValue_, "ERC20: decreased allowance below zero");

        _approve(_msgSender(), spender_, currentAllowance - subtractedValue_);



        return true;

    }



    function _transfer(address sender_, address recipient_, uint256 amount_) internal {

        require(sender_ != address(0), "ERC20: transfer from the zero address");

        require(recipient_ != address(0), "ERC20: transfer to the zero address");



        uint256 senderBalance = _state.balances[sender_];

        require(senderBalance >= amount_, "ERC20: transfer amount exceeds balance");

        _state.balances[sender_] = senderBalance - amount_;

        _state.balances[recipient_] += amount_;



        emit Transfer(sender_, recipient_, amount_);

    }



    function mint(address account_, uint256 amount_) public onlyOwner {

        _mint(account_, amount_);

    }



    function _mint(address account_, uint256 amount_) internal {

        require(account_ != address(0), "ERC20: mint to the zero address");



        _state.totalSupply += amount_;

        _state.balances[account_] += amount_;

        emit Transfer(address(0), account_, amount_);

    }



    function burn(address account_, uint256 amount_) public onlyOwner {

        _burn(account_, amount_);

    }



    function _burn(address account_, uint256 amount_) internal {

        require(account_ != address(0), "ERC20: burn from the zero address");



        uint256 accountBalance = _state.balances[account_];

        require(accountBalance >= amount_, "ERC20: burn amount exceeds balance");

        _state.balances[account_] = accountBalance - amount_;

        _state.totalSupply -= amount_;



        emit Transfer(account_, address(0), amount_);

    }



    function _approve(address owner_, address spender_, uint256 amount_) internal virtual {

        require(owner_ != address(0), "ERC20: approve from the zero address");

        require(spender_ != address(0), "ERC20: approve to the zero address");



        _state.allowances[owner_][spender_] = amount_;

        emit Approval(owner_, spender_, amount_);

    }



    function updateDetails(string memory name_, string memory symbol_, uint64 sequence_) public onlyOwner {

        require(_state.metaLastUpdatedSequence < sequence_, "current metadata is up to date");



        _state.name = name_;

        _state.symbol = symbol_;

        _state.metaLastUpdatedSequence = sequence_;



        // Because the name is updated, we need to recache the domain separator.

        // For old implementations, none of the caches may have been written to yet.

        _initializePermitStateIfNeeded();

    }



    modifier onlyOwner() {

        require(owner() == _msgSender(), "caller is not the owner");

        _;

    }



    modifier initializer() {

        require(

            !_state.initialized,

            "Already initialized"

        );



        _state.initialized = true;



        _;

    }



    /**

     * @dev Returns the domain separator for the current chain.

     */

    function _domainSeparatorV4() internal view returns (bytes32) {

        if (address(this) == _state.cachedThis && block.chainid == _state.cachedChainId) {

            return _state.cachedDomainSeparator;

        } else {

            return _buildDomainSeparator(

                _eip712DomainNameHashed(), _eip712DomainSalt()

            );

        }

    }



    function _buildDomainSeparator(bytes32 hashedName, bytes32 salt) internal view returns (bytes32) {

        return keccak256(

            abi.encode(

                keccak256(

                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)"

                ),

                hashedName,

                keccak256(abi.encodePacked(_eip712DomainVersion())),

                block.chainid,

                address(this),

                salt

            )

        );

    }



    /**

     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this

     * function returns the hash of the fully encoded EIP712 message for this domain.

     *

     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:

     *

     * ```solidity

     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(

     *     keccak256("Mail(address to,string contents)"),

     *     mailTo,

     *     keccak256(bytes(mailContents))

     * )));

     * address signer = ECDSA.recover(digest, signature);

     * ```

     */

    function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {

        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);

    }



    /**

     * @dev See {IERC20Permit-permit}.

     */

    function permit(

        address owner_,

        address spender_,

        uint256 value_,

        uint256 deadline_,

        uint8 v_,

        bytes32 r_,

        bytes32 s_

    ) public {

        // for those tokens that have been initialized before permit, we need to set

        // the permit state variables if they have not been set before

        _initializePermitStateIfNeeded();



        // permit is only allowed before the signature's deadline

        require(block.timestamp <= deadline_, "ERC20Permit: expired deadline");



        bytes32 structHash = keccak256(

            abi.encode(

                keccak256(

                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"

                ),

                owner_,

                spender_,

                value_,

                _useNonce(owner_),

                deadline_

            )

        );



        bytes32 message = _hashTypedDataV4(structHash);

        address signer = ECDSA.recover(message, v_, r_, s_);



        // if we cannot recover the token owner, signature is invalid

        require(signer == owner_, "ERC20Permit: invalid signature");



        _approve(owner_, spender_, value_);

    }



    /**

     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.

     */

    // solhint-disable-next-line func-name-mixedcase

    function DOMAIN_SEPARATOR() public view returns (bytes32) {

        return _domainSeparatorV4();

    }



    function eip712Domain() public view returns (

        bytes1 domainFields,

        string memory domainName,

        string memory domainVersion,

        uint256 domainChainId,

        address domainVerifyingContract,

        bytes32 domainSalt,

        uint256[] memory domainExtensions

    ) {

        return (

            hex"1F", // 11111

            name(),

            _eip712DomainVersion(),

            block.chainid,

            address(this),

            _eip712DomainSalt(),

            new uint256[](0)

        );

    }



    function _eip712DomainVersion() internal pure returns (string memory) {

        return "1";

    }



    function _eip712DomainNameHashed() internal view returns (bytes32) {

        return keccak256(abi.encodePacked(name()));

    }



    function _eip712DomainSalt() internal view returns (bytes32) {

        return keccak256(abi.encodePacked(_state.chainId, _state.nativeContract));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\TokenState.sol
File type: .sol
// contracts/State.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.8.0;



import "@openzeppelin/contracts/utils/Counters.sol";



contract TokenStorage {

    struct State {

        string name;

        string symbol;



        uint64 metaLastUpdatedSequence;



        uint256 totalSupply;

        uint8 decimals;



        mapping(address => uint256) balances;



        mapping(address => mapping(address => uint256)) allowances;



        address owner;



        bool initialized;



        uint16 chainId;

        bytes32 nativeContract;



        // EIP712

        // Cache the domain separator and salt, but also store the chain id that 

        // it corresponds to, in order to invalidate the cached domain separator

        // if the chain id changes.

        bytes32 cachedDomainSeparator;

        uint256 cachedChainId;

        address cachedThis;

        bytes32 cachedSalt;

        bytes32 cachedHashedName;



        // ERC20Permit draft

        mapping(address => Counters.Counter) nonces;

    }

}



contract TokenState {

    using Counters for Counters.Counter;



    TokenStorage.State _state;



    /**

     * @dev See {IERC20Permit-nonces}.

     */

    function nonces(address owner_) public view returns (uint256) {

        return _state.nonces[owner_].current();

    }



    /**

     * @dev "Consume a nonce": return the current value and increment.

     */

    function _useNonce(address owner_) internal returns (uint256 current) {

        Counters.Counter storage nonce = _state.nonces[owner_];

        current = nonce.current();

        nonce.increment();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\Wormhole.sol
File type: .sol
// contracts/Wormhole.sol

// SPDX-License-Identifier: Apache 2



pragma solidity ^0.6.0;

pragma experimental ABIEncoderV2;



import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

import "@openzeppelin/contracts/math/SafeMath.sol";

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "./BytesLib.sol";

import "./WrappedAsset.sol";



contract Wormhole is ReentrancyGuard {

    using SafeERC20 for IERC20;

    using BytesLib for bytes;

    using SafeMath for uint256;



    uint64 constant MAX_UINT64 = 18_446_744_073_709_551_615;



    // Address of the Wrapped asset template

    address public wrappedAssetMaster;



    // Chain ID of Ethereum

    uint8 CHAIN_ID = 2;



    // Address of the official WETH contract

    address constant WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;



    struct GuardianSet {

        address[] keys;

        uint32 expiration_time;

    }



    event LogGuardianSetChanged(

        uint32 oldGuardianIndex,

        uint32 newGuardianIndex

    );



    event LogTokensLocked(

        uint8 target_chain,

        uint8 token_chain,

        uint8 token_decimals,

        bytes32 indexed token,

        bytes32 indexed sender,

        bytes32 recipient,

        uint256 amount,

        uint32 nonce

    );



    struct ParsedVAA {

        uint8 version;

        bytes32 hash;

        uint32 guardian_set_index;

        uint32 timestamp;

        uint8 action;

        bytes payload;

    }



    // Mapping of guardian_set_index => guardian set

    mapping(uint32 => GuardianSet) public guardian_sets;

    // Current active guardian set

    uint32 public guardian_set_index;



    // Period for which a guardian set stays active after it has been replaced

    uint32 public guardian_set_expirity;



    // Mapping of already consumedVAAs

    mapping(bytes32 => bool) public consumedVAAs;



    // Mapping of wrapped asset ERC20 contracts

    mapping(bytes32 => address) public wrappedAssets;

    mapping(address => bool) public isWrappedAsset;



    constructor(GuardianSet memory initial_guardian_set, address wrapped_asset_master, uint32 _guardian_set_expirity) public {

        guardian_sets[0] = initial_guardian_set;

        // Explicitly set for doc purposes

        guardian_set_index = 0;

        guardian_set_expirity = _guardian_set_expirity;



        wrappedAssetMaster = wrapped_asset_master;

    }



    function getGuardianSet(uint32 idx) view public returns (GuardianSet memory gs) {

        return guardian_sets[idx];

    }



    function submitVAA(

        bytes calldata vaa

    ) public nonReentrant {

        ParsedVAA memory parsed_vaa = parseAndVerifyVAA(vaa);

        // Process VAA

        if (parsed_vaa.action == 0x01) {

            require(parsed_vaa.guardian_set_index == guardian_set_index, "only the current guardian set can change the guardian set");

            vaaUpdateGuardianSet(parsed_vaa.payload);

        } else if (parsed_vaa.action == 0x10) {

            vaaTransfer(parsed_vaa.payload);

        } else {

            revert("invalid VAA action");

        }



        // Set the VAA as consumed

        consumedVAAs[parsed_vaa.hash] = true;

    }



    // parseAndVerifyVAA parses raw VAA data into a struct and verifies whether it contains sufficient signatures of an

    // active guardian set i.e. is valid according to Wormhole consensus rules.

    function parseAndVerifyVAA(bytes calldata vaa) public view returns (ParsedVAA memory parsed_vaa) {

        parsed_vaa.version = vaa.toUint8(0);

        require(parsed_vaa.version == 1, "VAA version incompatible");



        // Load 4 bytes starting from index 1

        parsed_vaa.guardian_set_index = vaa.toUint32(1);



        uint256 len_signers = vaa.toUint8(5);

        uint offset = 6 + 66 * len_signers;



        // Load 4 bytes timestamp

        parsed_vaa.timestamp = vaa.toUint32(offset);



        // Hash the body

        parsed_vaa.hash = keccak256(vaa.slice(offset, vaa.length - offset));

        require(!consumedVAAs[parsed_vaa.hash], "VAA was already executed");



        GuardianSet memory guardian_set = guardian_sets[parsed_vaa.guardian_set_index];

        require(guardian_set.keys.length > 0, "invalid guardian set");

        require(guardian_set.expiration_time == 0 || guardian_set.expiration_time > block.timestamp, "guardian set has expired");

        // We're using a fixed point number transformation with 1 decimal to deal with rounding.

        require(((guardian_set.keys.length * 10 / 3) * 2) / 10 + 1 <= len_signers, "no quorum");



        int16 last_index = - 1;

        for (uint i = 0; i < len_signers; i++) {

            uint8 index = vaa.toUint8(6 + i * 66);

            require(index > last_index, "signature indices must be ascending");

            last_index = int16(index);



            bytes32 r = vaa.toBytes32(7 + i * 66);

            bytes32 s = vaa.toBytes32(39 + i * 66);

            uint8 v = vaa.toUint8(71 + i * 66);

            v += 27;

            require(ecrecover(parsed_vaa.hash, v, r, s) == guardian_set.keys[index], "VAA signature invalid");

        }



        parsed_vaa.action = vaa.toUint8(offset + 4);

        parsed_vaa.payload = vaa.slice(offset + 5, vaa.length - (offset + 5));

    }



    function vaaUpdateGuardianSet(bytes memory data) private {

        uint32 new_guardian_set_index = data.toUint32(0);

        require(new_guardian_set_index == guardian_set_index + 1, "index must increase in steps of 1");

        uint8 len = data.toUint8(4);



        address[] memory new_guardians = new address[](len);

        for (uint i = 0; i < len; i++) {

            address addr = data.toAddress(5 + i * 20);

            new_guardians[i] = addr;

        }



        uint32 old_guardian_set_index = guardian_set_index;

        guardian_set_index = new_guardian_set_index;



        GuardianSet memory new_guardian_set = GuardianSet(new_guardians, 0);

        guardian_sets[guardian_set_index] = new_guardian_set;

        guardian_sets[old_guardian_set_index].expiration_time = uint32(block.timestamp) + guardian_set_expirity;



        emit LogGuardianSetChanged(old_guardian_set_index, guardian_set_index);

    }



    function vaaTransfer(bytes memory data) private {

        //uint32 nonce = data.toUint64(0);

        uint8 source_chain = data.toUint8(4);



        uint8 target_chain = data.toUint8(5);

        //bytes32 source_address = data.toBytes32(6);

        //bytes32 target_address = data.toBytes32(38);

        address target_address = data.toAddress(38 + 12);



        uint8 token_chain = data.toUint8(70);

        //bytes32 token_address = data.toBytes32(71);

        uint256 amount = data.toUint256(104);



        require(source_chain != target_chain, "same chain transfers are not supported");

        require(target_chain == CHAIN_ID, "transfer must be incoming");



        if (token_chain != CHAIN_ID) {

            bytes32 token_address = data.toBytes32(71);

            bytes32 asset_id = keccak256(abi.encodePacked(token_chain, token_address));



            // if yes: mint to address

            // if no: create and mint

            address wrapped_asset = wrappedAssets[asset_id];

            if (wrapped_asset == address(0)) {

                uint8 asset_decimals = data.toUint8(103);

                wrapped_asset = deployWrappedAsset(asset_id, token_chain, token_address, asset_decimals);

            }



            WrappedAsset(wrapped_asset).mint(target_address, amount);

        } else {

            address token_address = data.toAddress(71 + 12);



            uint8 decimals = ERC20(token_address).decimals();



            // Readjust decimals if they've previously been truncated

            if (decimals > 9) {

                amount = amount.mul(10 ** uint256(decimals - 9));

            }

            IERC20(token_address).safeTransfer(target_address, amount);

        }

    }



    function deployWrappedAsset(bytes32 seed, uint8 token_chain, bytes32 token_address, uint8 decimals) private returns (address asset){

        // Taken from https://github.com/OpenZeppelin/openzeppelin-sdk/blob/master/packages/lib/contracts/upgradeability/ProxyFactory.sol

        // Licensed under MIT

        bytes20 targetBytes = bytes20(wrappedAssetMaster);

        assembly {

            let clone := mload(0x40)

            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)

            mstore(add(clone, 0x14), targetBytes)

            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)

            asset := create2(0, clone, 0x37, seed)

        }



        // Call initializer

        WrappedAsset(asset).initialize(token_chain, token_address, decimals);



        // Store address

        wrappedAssets[seed] = asset;

        isWrappedAsset[asset] = true;

    }



    function lockAssets(

        address asset,

        uint256 amount,

        bytes32 recipient,

        uint8 target_chain,

        uint32 nonce,

        bool refund_dust

    ) public nonReentrant {

        require(target_chain != CHAIN_ID, "must not transfer to the same chain");



        uint8 asset_chain = CHAIN_ID;

        bytes32 asset_address;

        uint8 decimals = ERC20(asset).decimals();



        if (isWrappedAsset[asset]) {

            WrappedAsset(asset).burn(msg.sender, amount);

            asset_chain = WrappedAsset(asset).assetChain();

            asset_address = WrappedAsset(asset).assetAddress();

        } else {

            uint256 balanceBefore = IERC20(asset).balanceOf(address(this));

            IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);

            uint256 balanceAfter = IERC20(asset).balanceOf(address(this));



            // The amount that was transferred in is the delta between balance before and after the transfer.

            // This is to properly handle tokens that charge a fee on transfer.

            amount = balanceAfter.sub(balanceBefore);



            // Decimal adjust amount - we keep the dust

            if (decimals > 9) {

                uint256 original_amount = amount;

                amount = amount.div(10 ** uint256(decimals - 9));



                if (refund_dust) {

                    IERC20(asset).safeTransfer(msg.sender, original_amount.mod(10 ** uint256(decimals - 9)));

                }



                decimals = 9;

            }



            require(balanceAfter.div(10 ** uint256(ERC20(asset).decimals() - 9)) <= MAX_UINT64, "bridge balance would exceed maximum");



            asset_address = bytes32(uint256(asset));

        }



        // Check here after truncation

        require(amount != 0, "truncated amount must not be 0");



        emit LogTokensLocked(target_chain, asset_chain, decimals, asset_address, bytes32(uint256(msg.sender)), recipient, amount, nonce);

    }



    function lockETH(

        bytes32 recipient,

        uint8 target_chain,

        uint32 nonce

    ) public payable nonReentrant {

        require(target_chain != CHAIN_ID, "must not transfer to the same chain");



        uint256 remainder = msg.value.mod(10 ** 9);

        uint256 transfer_amount = msg.value.div(10 ** 9);

        require(transfer_amount != 0, "truncated amount must not be 0");



        // Transfer back remainder

        msg.sender.transfer(remainder);



        // Wrap tx value in WETH

        WETH(WETHAddress).deposit{value : msg.value - remainder}();



        // Log deposit of WETH

        emit LogTokensLocked(target_chain, CHAIN_ID, 9, bytes32(uint256(WETHAddress)), bytes32(uint256(msg.sender)), recipient, transfer_amount, nonce);

    }



    fallback() external payable {revert("please use lockETH to transfer ETH to Solana");}



    receive() external payable {revert("please use lockETH to transfer ETH to Solana");}

}





interface WETH is IERC20 {

    function deposit() external payable;



    function withdraw(uint256 amount) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\Wormhole\contracts\WrappedAsset.sol
File type: .sol
// contracts/WrappedAsset.sol

// SPDX-License-Identifier: Apache 2

pragma solidity ^0.6.0;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/math/SafeMath.sol";

import "@openzeppelin/contracts/utils/Address.sol";

import "@openzeppelin/contracts/GSN/Context.sol";



contract WrappedAsset is IERC20, Context {

    uint8 public assetChain;

    bytes32 public assetAddress;

    bool public initialized;

    address public bridge;



    function initialize(uint8 _assetChain, bytes32 _assetAddress, uint8 decimals) public {

        require(!initialized, "already initialized");

        // Set local fields

        assetChain = _assetChain;

        assetAddress = _assetAddress;

        bridge = msg.sender;

        initialized = true;



        _symbol = "WWT";

        _decimals = decimals;

    }



    function mint(address account, uint256 amount) external {

        require(msg.sender == bridge, "mint can only be called by the bridge");



        _mint(account, amount);

    }



    function burn(address account, uint256 amount) external {

        require(msg.sender == bridge, "burn can only be called by the bridge");



        _burn(account, amount);

    }



    // Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol

    // Licensed under MIT



    using SafeMath for uint256;

    using Address for address;



    mapping(address => uint256) private _balances;



    mapping(address => mapping(address => uint256)) private _allowances;



    uint256 private _totalSupply;



    string private _symbol;

    uint8 private _decimals = 18;



    /**

     * @dev Returns the name of the token.

     */

    function name() public view returns (string memory) {

        return string(abi.encodePacked("Wormhole Wrapped - ", uintToString(assetChain), "-", assetAddressString()));

    }



    // https://ethereum.stackexchange.com/a/40977

    function uintToString(uint _i) internal pure returns (string memory _uintAsString) {

        if (_i == 0) {

            return "0";

        }

        uint j = _i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len - 1;

        while (_i != 0) {

            bstr[k--] = byte(uint8(48 + _i % 10));

            _i /= 10;

        }

        return string(bstr);

    }



    // https://ethereum.stackexchange.com/a/58341

    function assetAddressString() private view returns (string memory) {

        bytes memory alphabet = "0123456789abcdef";

        bytes32 data = assetAddress;



        bytes memory str = new bytes(2 + data.length * 2);

        for (uint i = 0; i < data.length; i++) {

            str[i * 2] = alphabet[uint(uint8(data[i] >> 4))];

            str[1 + i * 2] = alphabet[uint(uint8(data[i] & 0x0f))];

        }

        return string(str);

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5,05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is

     * called.

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view override returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `recipient` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address recipient, uint256 amount) public override returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view override returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20};

     *

     * Requirements:

     * - `sender` and `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     * - the caller must have allowance for ``sender``'s tokens of at least

     * `amount`.

     */

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    /**

     * @dev Moves tokens `amount` from `sender` to `recipient`.

     *

     * This is internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `sender` cannot be the zero address.

     * - `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     */

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements

     *

     * - `to` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.

     *

     * This is internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    /**

     * @dev Sets {decimals} to a value other than the default one of 18.

     *

     * WARNING: This function should only be called from the constructor. Most

     * applications that interact with token contracts will not expect

     * {decimals} to ever change, and may work incorrectly if it does.

     */

    function _setupDecimals(uint8 decimals_) internal {

        _decimals = decimals_;

    }

}

--------------------------------------------------
File End
--------------------------------------------------

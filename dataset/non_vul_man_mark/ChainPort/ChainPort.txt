Folder Structure
--------------------------------------------------
contracts/
    Address.sol
    ChainportBridgeEth.sol
    ChainportToken.sol
    Context.sol
    Enum.sol
    ERC1967Proxy.sol
    ERC1967Upgrade.sol
    EtherPaymentFallback.sol
    Executor.sol
    FallbackManager.sol
    GnosisSafe.sol
    GnosisSafeMath.sol
    GnosisSafeProxy.sol
    GuardManager.sol
    IBeacon.sol
    import.sol
    ISignatureValidator.sol
    ModuleManager.sol
    Ownable.sol
    OwnerManager.sol
    Proxiable.sol
    Proxy.sol
    ProxyAdmin.sol
    SecuredTokenTransfer.sol
    SelfAuthorized.sol
    SignatureDecoder.sol
    Singleton.sol
    StorageAccessible.sol
    StorageSlot.sol
    TransparentUpgradeableProxy.sol
    UUPSUpgradeable.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: value }(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.staticcall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.delegatecall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\ChainportBridgeEth.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-05-25

*/



// Sources flattened with hardhat v2.3.0 https://hardhat.org



// File @openzeppelin/contracts/utils/Address.sol@v3.4.0







pragma solidity >=0.6.2 <0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: value }(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.staticcall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.delegatecall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}





// File @openzeppelin/contracts/proxy/Initializable.sol@v3.4.0







// solhint-disable-next-line compiler-version

pragma solidity >=0.4.24 <0.8.0;



/**

 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed

 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an

 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer

 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.

 *

 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as

 * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.

 *

 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure

 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.

 */

abstract contract Initializable {



    /**

     * @dev Indicates that the contract has been initialized.

     */

    bool private _initialized;



    /**

     * @dev Indicates that the contract is in the process of being initialized.

     */

    bool private _initializing;



    /**

     * @dev Modifier to protect an initializer function from being invoked twice.

     */

    modifier initializer() {

        require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");



        bool isTopLevelCall = !_initializing;

        if (isTopLevelCall) {

            _initializing = true;

            _initialized = true;

        }



        _;



        if (isTopLevelCall) {

            _initializing = false;

        }

    }



    /// @dev Returns true if and only if the function is running in the constructor

    function _isConstructor() private view returns (bool) {

        return !Address.isContract(address(this));

    }

}





// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.0







pragma solidity >=0.6.0 <0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}





// File contracts/libraries/SafeMath.sol







pragma solidity >=0.6.0 <0.8.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        uint256 c = a + b;

        if (c < a) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the substraction of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b > a) return (false, 0);

        return (true, a - b);

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) return (true, 0);

        uint256 c = a * b;

        if (c / a != b) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the division of two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a / b);

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a % b);

    }



    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");

        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        return a - b;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) return 0;

        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");

        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: division by zero");

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: modulo by zero");

        return a % b;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {trySub}.

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        return a - b;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryDiv}.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting with custom message when dividing by zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryMod}.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a % b;

    }

}





// File contracts/interfaces/IMaintainersRegistry.sol



pragma solidity ^0.6.12;



/**

 * IMaintainersRegistry contract.

 * @author Nikola Madjarevic

 * Date created: 3.5.21.

 * Github: madjarevicn

 */

interface IMaintainersRegistry {

    function isMaintainer(address _address) external view returns (bool);

}





// File contracts/ChainportMiddleware.sol



pragma solidity ^0.6.12;



/**

 * ChainportMiddleware contract.

 * @author Nikola Madjarevic

 * Date created: 4.5.21.

 * Github: madjarevicn

 */

contract ChainportMiddleware {



    address public chainportCongress;

    IMaintainersRegistry public maintainersRegistry;



    // Only maintainer modifier

    modifier onlyMaintainer {

        require(maintainersRegistry.isMaintainer(msg.sender), "ChainportUpgradables: Restricted only to Maintainer");

        _;

    }



    // Only chainport congress modifier

    modifier onlyChainportCongress {

        require(msg.sender == chainportCongress, "ChainportUpgradables: Restricted only to ChainportCongress");

        _;

    }



    function setCongressAndMaintainers(

        address _chainportCongress,

        address _maintainersRegistry

    )

    internal

    {

        chainportCongress = _chainportCongress;

        maintainersRegistry = IMaintainersRegistry(_maintainersRegistry);

    }



    function setMaintainersRegistry(

        address _maintainersRegistry

    )

    public

    onlyChainportCongress

    {

        maintainersRegistry = IMaintainersRegistry(_maintainersRegistry);

    }

}





// File contracts/interfaces/IValidator.sol





pragma solidity ^0.6.12;



/**

 * IValidator contract.

 * @author Nikola Madjarevic

 * Date created: 3.5.21.

 * Github: madjarevicn

 */

interface IValidator {

    function verifyWithdraw(bytes memory signedMessage, address token, uint256 amount, address beneficiary, uint256 nonce) external view returns (bool);

    function recoverSignature(bytes memory signedMessage, address beneficiary, address token, uint256 amount, uint256 nonce) external view returns (address);

}





// File contracts/ChainportBridgeEth.sol





pragma solidity ^0.6.12;









contract ChainportBridgeEth is Initializable, ChainportMiddleware {



    using SafeMath for uint256;



    IValidator public signatureValidator;



    struct PendingWithdrawal {

        uint256 amount;

        address beneficiary;

        uint256 unlockingTime;

    }



    // Mapping if bridge is Frozen

    bool public isFrozen;

    // Mapping function name to maintainer nonce

    mapping(string => uint256) public functionNameToNonce;

    // Mapping the pending withdrawal which frozen temporarily asset circulation

    mapping(address => PendingWithdrawal) public tokenToPendingWithdrawal;

    // Mapping per token to check if there's any pending withdrawal attempt

    mapping(address => bool) public isTokenHavingPendingWithdrawal;

    // Mapping for marking the assets

    mapping(address => bool) public isAssetProtected;

    // Check if signature is being used

    mapping(bytes => bool) public isSignatureUsed;

    // % of the tokens, must be whole number, no decimals pegging

    uint256 public safetyThreshold;

    // Length of the timeLock

    uint256 public freezeLength;





    // Events

    event TokensUnfreezed(address tokenAddress, address issuer, uint256 amount);

    event TokensFreezed(address tokenAddress, address issuer, uint256 amount);

    event CreatedPendingWithdrawal(address token, address beneficiary, uint256 amount, uint256 unlockingTime);



    event WithdrawalApproved(address token, address beneficiary, uint256 amount);

    event WithdrawalRejected(address token, address beneficiary, uint256 amount);



    event TimeLockLengthChanged(uint256 newTimeLockLength);

    event AssetProtectionChanged(address asset, bool isProtected);

    event SafetyThresholdChanged(uint256 newSafetyThreshold);



    modifier isNotFrozen {

        require(isFrozen == false, "Error: All Bridge actions are currently frozen.");

        _;

    }



    modifier onlyIfAmountGreaterThanZero(uint256 amount) {

        require(amount > 0, "Amount is not greater than zero.");

        _;

    }



    // Initialization function

    function initialize(

        address _maintainersRegistryAddress,

        address _chainportCongress,

        address _signatureValidator,

        uint256 _freezeLength,

        uint256 _safetyThreshold

    )

    public

    initializer

    {

        require(_safetyThreshold > 0 && _safetyThreshold < 100, "Error: % is not valid.");



        setCongressAndMaintainers(_chainportCongress, _maintainersRegistryAddress);

        signatureValidator = IValidator(_signatureValidator);

        freezeLength = _freezeLength;

        safetyThreshold = _safetyThreshold;

    }



    function freezeBridge()

    public

    onlyMaintainer

    {

        isFrozen = true;

    }



    function unfreezeBridge()

    public

    onlyChainportCongress

    {

        isFrozen = false;

    }



    // Function to mark specific asset as protected

    function setAssetProtection(

        address tokenAddress,

        bool _isProtected

    )

    public

    onlyChainportCongress

    {

        isAssetProtected[tokenAddress] = _isProtected;

        emit AssetProtectionChanged(tokenAddress, _isProtected);

    }



    // Function to set timelock

    function setTimeLockLength(

        uint256 length

    )

    public

    onlyChainportCongress

    {

        freezeLength = length;

        emit TimeLockLengthChanged(length);

    }





    // Function to set minimal value that is considered important by quantity

    function setThreshold(

        uint256 _safetyThreshold

    )

    public

    onlyChainportCongress

    {

        // This is representing % of every asset on the contract

        // Example: 32% is safety threshold

        safetyThreshold = _safetyThreshold;

        emit SafetyThresholdChanged(_safetyThreshold);

    }





    function freezeToken(

        address token,

        uint256 amount

    )

    public

    isNotFrozen

    onlyIfAmountGreaterThanZero(amount)

    {

        IERC20 ercToken = IERC20(token);



        bool result = ercToken.transferFrom(address(msg.sender), address(this), amount);

        require(result, "Transfer did not go through.");



        emit TokensFreezed(token, msg.sender, amount);

    }



    function releaseTokensByMaintainer(

        bytes memory signature,

        address token,

        uint256 amount,

        address beneficiary,

        uint256 nonce

    )

    public

    onlyMaintainer

    isNotFrozen

    onlyIfAmountGreaterThanZero(amount)

    {

        require(isTokenHavingPendingWithdrawal[token] == false, "Token is currently having pending withdrawal.");



        require(isSignatureUsed[signature] == false, "Already used signature.");

        isSignatureUsed[signature] = true;



        require(nonce == functionNameToNonce["mintTokens"] + 1);

        functionNameToNonce["mintTokens"] = nonce;



        bool isMessageValid = signatureValidator.verifyWithdraw(signature, token, amount, beneficiary, nonce);

        require(isMessageValid == true, "Error: Signature is not valid.");



        bool result = IERC20(token).transfer(beneficiary, amount);

        require(result, "Transfer did not go through.");



        emit TokensUnfreezed(token, beneficiary, amount);

    }



    function releaseTokensTimelockPassed(

        bytes memory signature,

        address token,

        uint256 amount,

        uint256 nonce

    )

    public

    isNotFrozen

    onlyIfAmountGreaterThanZero(amount)

    {

        require(isSignatureUsed[signature] == false, "Signature already used");

        isSignatureUsed[signature] = true;



        // Check if freeze time has passed and same user is calling again

        if(isTokenHavingPendingWithdrawal[token] == true) {

            PendingWithdrawal memory p = tokenToPendingWithdrawal[token];

            if(p.amount == amount && p.beneficiary == msg.sender && p.unlockingTime <= block.timestamp) {

                // Verify the signature user is submitting

                bool isMessageValid = signatureValidator.verifyWithdraw(signature, token, amount, p.beneficiary, nonce);

                require(isMessageValid == true, "Error: Signature is not valid.");



                bool result = IERC20(token).transfer(p.beneficiary, p.amount);

                require(result, "Transfer did not go through.");



                emit TokensUnfreezed(token, p.beneficiary, p.amount);

                // Clear up the state and remove pending flag

                delete tokenToPendingWithdrawal[token];

                isTokenHavingPendingWithdrawal[token] = false;

            }

        } else {

            revert("Invalid function call");

        }

    }



    // Function to release tokens

    function releaseTokens(

        bytes memory signature,

        address token,

        uint256 amount,

        uint256 nonce

    )

    public

    isNotFrozen

    onlyIfAmountGreaterThanZero(amount)

    {

        require(isTokenHavingPendingWithdrawal[token] == false, "Token is currently having pending withdrawal.");



        require(isSignatureUsed[signature] == false, "Signature already used");

        isSignatureUsed[signature] = true;



        // msg.sender is beneficiary address

        address beneficiary = msg.sender;

        // Verify the signature user is submitting

        bool isMessageValid = signatureValidator.verifyWithdraw(signature, token, amount, beneficiary, nonce);

        // Requiring that signature is valid

        require(isMessageValid == true, "Error: Signature is not valid.");





        if(isAboveThreshold(token, amount) && isAssetProtected[token] == true) {



            PendingWithdrawal memory p = PendingWithdrawal({

                amount: amount,

                beneficiary: beneficiary,

                unlockingTime: now.add(freezeLength)

            });



            tokenToPendingWithdrawal[token] = p;

            isTokenHavingPendingWithdrawal[token] = true;



            // Fire an event

            emit CreatedPendingWithdrawal(token, beneficiary, amount, p.unlockingTime);

        } else {

            bool result = IERC20(token).transfer(beneficiary, amount);

            require(result, "Transfer did not go through.");



            emit TokensUnfreezed(token, beneficiary, amount);

        }

    }



    // Function for congress to approve withdrawal and transfer funds

    function approveWithdrawalAndTransferFunds(

        address token

    )

    public

    onlyChainportCongress

    isNotFrozen

    {

        require(isTokenHavingPendingWithdrawal[token] == true);

        // Get current pending withdrawal attempt

        PendingWithdrawal memory p = tokenToPendingWithdrawal[token];

        // Transfer funds to user

        bool result = IERC20(token).transfer(p.beneficiary, p.amount);

        require(result, "Transfer did not go through.");

        // Emit events

        emit TokensUnfreezed(token, p.beneficiary, p.amount);

        emit WithdrawalApproved(token, p.beneficiary, p.amount);



        // Clear up the state and remove pending flag

        delete tokenToPendingWithdrawal[token];

        isTokenHavingPendingWithdrawal[token] = false;

    }



    // Function to reject withdrawal from congress

    function rejectWithdrawal(

        address token

    )

    public

    onlyChainportCongress

    isNotFrozen

    {

        require(isTokenHavingPendingWithdrawal[token] == true);

        // Get current pending withdrawal attempt

        PendingWithdrawal memory p = tokenToPendingWithdrawal[token];

        emit WithdrawalRejected(token, p.beneficiary, p.amount);

        // Clear up the state and remove pending flag

        delete tokenToPendingWithdrawal[token];

        isTokenHavingPendingWithdrawal[token] = false;

    }



    // Function to check if amount is above threshold

    function isAboveThreshold(address token, uint256 amount) public view returns (bool) {

        return amount >= getTokenBalance(token).mul(safetyThreshold).div(100);

    }



    // Get contract balance of specific token

    function getTokenBalance(address token) internal view returns (uint256) {

        return IERC20(token).balanceOf(address(this));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\ChainportToken.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2022-01-11

*/



// Sources flattened with hardhat v2.3.0 https://hardhat.org



// File @openzeppelin/contracts/token/ERC20/IERC20.sol





pragma solidity >=0.6.0 <0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}





// File @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol





pragma solidity >=0.6.2 <0.8.0;



/**

 * @dev Collection of functions related to the address type

 */

library AddressUpgradeable {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: value }(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.staticcall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}





// File @openzeppelin/contracts-upgradeable/proxy/Initializable.sol





// solhint-disable-next-line compiler-version

pragma solidity >=0.4.24 <0.8.0;



/**

 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed

 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an

 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer

 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.

 *

 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as

 * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.

 *

 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure

 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.

 */

abstract contract Initializable {



    /**

     * @dev Indicates that the contract has been initialized.

     */

    bool private _initialized;



    /**

     * @dev Indicates that the contract is in the process of being initialized.

     */

    bool private _initializing;



    /**

     * @dev Modifier to protect an initializer function from being invoked twice.

     */

    modifier initializer() {

        require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");



        bool isTopLevelCall = !_initializing;

        if (isTopLevelCall) {

            _initializing = true;

            _initialized = true;

        }



        _;



        if (isTopLevelCall) {

            _initializing = false;

        }

    }



    /// @dev Returns true if and only if the function is running in the constructor

    function _isConstructor() private view returns (bool) {

        return !AddressUpgradeable.isContract(address(this));

    }

}





// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol





pragma solidity >=0.6.0 <0.8.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract ContextUpgradeable is Initializable {

    function __Context_init() internal initializer {

        __Context_init_unchained();

    }



    function __Context_init_unchained() internal initializer {

    }

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

    uint256[50] private __gap;

}





// File @openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol





pragma solidity >=0.6.0 <0.8.0;





/**

 * @dev Contract module which allows children to implement an emergency stop

 * mechanism that can be triggered by an authorized account.

 *

 * This module is used through inheritance. It will make available the

 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to

 * the functions of your contract. Note that they will not be pausable by

 * simply including this module, only once the modifiers are put in place.

 */

abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {

    /**

     * @dev Emitted when the pause is triggered by `account`.

     */

    event Paused(address account);



    /**

     * @dev Emitted when the pause is lifted by `account`.

     */

    event Unpaused(address account);



    bool private _paused;



    /**

     * @dev Initializes the contract in unpaused state.

     */

    function __Pausable_init() internal initializer {

        __Context_init_unchained();

        __Pausable_init_unchained();

    }



    function __Pausable_init_unchained() internal initializer {

        _paused = false;

    }



    /**

     * @dev Returns true if the contract is paused, and false otherwise.

     */

    function paused() public view virtual returns (bool) {

        return _paused;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is not paused.

     *

     * Requirements:

     *

     * - The contract must not be paused.

     */

    modifier whenNotPaused() {

        require(!paused(), "Pausable: paused");

        _;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is paused.

     *

     * Requirements:

     *

     * - The contract must be paused.

     */

    modifier whenPaused() {

        require(paused(), "Pausable: not paused");

        _;

    }



    /**

     * @dev Triggers stopped state.

     *

     * Requirements:

     *

     * - The contract must not be paused.

     */

    function _pause() internal virtual whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    /**

     * @dev Returns to normal state.

     *

     * Requirements:

     *

     * - The contract must be paused.

     */

    function _unpause() internal virtual whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }

    uint256[49] private __gap;

}





// File @openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol





pragma solidity >=0.6.0 <0.8.0;



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * TIP: If you would like to learn more about reentrancy and alternative ways

 * to protect against it, check out our blog post

 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].

 */

abstract contract ReentrancyGuardUpgradeable is Initializable {

    // Booleans are more expensive than uint256 or any type that takes up a full

    // word because each write operation emits an extra SLOAD to first read the

    // slot's contents, replace the bits taken up by the boolean, and then write

    // back. This is the compiler's defense against contract upgrades and

    // pointer aliasing, and it cannot be disabled.



    // The values being non-zero value makes deployment a bit more expensive,

    // but in exchange the refund on every call to nonReentrant will be lower in

    // amount. Since refunds are capped to a percentage of the total

    // transaction's gas, it is best to keep them low in cases like this one, to

    // increase the likelihood of the full refund coming into effect.

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    uint256 private _status;



    function __ReentrancyGuard_init() internal initializer {

        __ReentrancyGuard_init_unchained();

    }



    function __ReentrancyGuard_init_unchained() internal initializer {

        _status = _NOT_ENTERED;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _status = _ENTERED;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _status = _NOT_ENTERED;

    }

    uint256[49] private __gap;

}





// File contracts/libraries/SafeMath.sol





pragma solidity >=0.6.0 <0.8.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        uint256 c = a + b;

        if (c < a) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the substraction of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b > a) return (false, 0);

        return (true, a - b);

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) return (true, 0);

        uint256 c = a * b;

        if (c / a != b) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the division of two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a / b);

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a % b);

    }



    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");

        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        return a - b;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) return 0;

        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");

        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: division by zero");

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: modulo by zero");

        return a % b;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {trySub}.

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        return a - b;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryDiv}.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting with custom message when dividing by zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryMod}.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a % b;

    }

}





// File contracts/token/ChainportToken.sol



pragma solidity ^0.6.12;









contract ChainportToken is IERC20, PausableUpgradeable, ReentrancyGuardUpgradeable {



    using SafeMath for uint256;



    // Globals

    address public chainportCongress;

    address public chainportBridge;

    mapping (address => bool) public isBlocked;



    string private constant NAME = "ChainPort Token";

    string private constant SYMBOL = "CPT";

    uint8 private constant DECIMALS = 18;

    uint256 private constant MAX_SUPPLY = 1000000000 * (uint(10) ** DECIMALS);



    uint256 private _totalSupply;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;



    // Events

    event ChainportBridgeChanged(address indexed addr);

    event ChainportCongressChanged(address indexed addr);

    event AddressBlocked(address indexed addr);

    event AddressUnblocked(address indexed addr);

    event BlackFundsDestroyed(address indexed addr, uint256 amount);

    event StuckTokenWithdrawn(address indexed token, address indexed to, uint256 amount);



    /**

	 * @dev Modifier for functions callable only by chainport authorities

     */

    modifier onlyClassifiedAuthority() {

        require(

            msg.sender == chainportBridge || msg.sender == chainportCongress,

            "ChainportToken: Restricted only to classified authorities."

        );

        _;

    }



    /**

	 * @dev Modifier for functions callable only by chainport congress

	 */

    modifier onlyChainportCongress() {

        require(

            msg.sender == chainportCongress,

            "ChainportToken: Restricted only to congress."

        );

        _;

    }



    function initialize(

        address chainportCongress_,

        address chainportBridge_

    )

    external

    initializer

    {

        chainportCongress = chainportCongress_;

        chainportBridge = chainportBridge_;

        _mint(chainportCongress, MAX_SUPPLY);

        __ReentrancyGuard_init();

        __Pausable_init();

    }



    /**

	 * @dev Returns the name of the token.

     */

    function name() public pure returns (string memory) {

        return NAME;

    }



    /**

	 * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public pure returns (string memory) {

        return SYMBOL;

    }



    /**

	 * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5,05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is

     * called.

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public pure returns (uint8) {

        return DECIMALS;

    }



    /**

	 * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view virtual override returns (uint256) {

        return _totalSupply;

    }



    /**

	 * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view virtual override returns (uint256) {

        return _balances[account];

    }



    /**

	 * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `recipient` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    /**

	 * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

	 * @dev See {IERC20-approve}.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    /**

	 * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20}.

     *

     * Requirements:

     *

     * - `sender` and `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     * - the caller must have allowance for ``sender``'s tokens of at least

     * `amount`.

     */

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    /**

	 * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    /**

	 * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    /**

	 * @dev Moves tokens `amount` from `sender` to `recipient`.

     *

     * This is internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `sender` cannot be the zero address.

     * - `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     */

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender);



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    /**

	 * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    /**

	 * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.

     *

     * This internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(address owner, address spender, uint256 amount) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    /**

	 * @dev Destroys `amount` tokens from the caller.

     *

     * See {ERC20-_burn}.

     */

    function burn(uint256 amount) public virtual {

        _burn(_msgSender(), amount);

    }



    /**

	 * @dev Destroys `amount` tokens from `account`, deducting from the caller's

     * allowance.

     *

     * See {ERC20-_burn} and {ERC20-allowance}.

     *

     * Requirements:

     *

     * - the caller must have allowance for ``accounts``'s tokens of at least

     * `amount`.

     */

    function burnFrom(address account, uint256 amount) public virtual {

        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");



        _approve(account, _msgSender(), decreasedAllowance);

        _burn(account, amount);

    }



    /**

	 * @dev See {ERC20-_beforeTokenTransfer}.

     *

     * Requirements:

     * - the contract must not be paused.

     * - 'from' address must not be blocked.

     *

     * Affects:

     * - 'transfer' & 'transferFrom'

     */

    function _beforeTokenTransfer(address from) internal view {

        require(!paused(), "ChainportToken: Token paused.");

        require(!isBlocked[from], "ChainportToken: Sender address blocked.");

    }



    /**

	 * @notice  Function to pause token contract

	 */

    function pause() external onlyClassifiedAuthority {

        _pause();

    }



    /**

	 * @notice  Function to unpause token contract

	 */

    function unpause() external onlyChainportCongress {

        _unpause();

    }



    /**

	 * @notice  Function used to block transfers from malicious address

	 *

	 * @param   addressToBlock is an address that needs to be blocked

	 */

    function blockAddress(address addressToBlock) external onlyClassifiedAuthority {

        isBlocked[addressToBlock] = true;

        emit AddressBlocked(addressToBlock);

    }



    /**

	 * @notice  Function used to unblock an address

	 *

	 * @param   addressToUnblock is an address that needs to be unblocked

	 */

    function unblockAddress(address addressToUnblock) external onlyChainportCongress {

        isBlocked[addressToUnblock] = false;

        emit AddressUnblocked(addressToUnblock);

    }



    /**

	 * @notice  Function for replacing proxy address of main bridge

	 *

	 * @param   chainportBridge_ is new proxy address

	 */

    function setChainportBridge(address chainportBridge_) external onlyChainportCongress {

        require(chainportBridge_ != address(0), "ChainportToken: Address malformed.");

        chainportBridge = chainportBridge_;

        emit ChainportBridgeChanged(chainportBridge);

    }



    /**

	 * @notice  Function for replacing address of chainport congress

	 *

	 * @param   chainportCongress_ is new congress address

	 */

    function setChainportCongress(address chainportCongress_) external onlyChainportCongress {

        require(chainportCongress_ != address(0), "ChainportToken: Address malformed.");

        chainportCongress = chainportCongress_;

        emit ChainportCongressChanged(chainportCongress);

    }



    /**

	 * @notice  Function for removing black funds from malicious address

	 *

	 * @param   maliciousAddress is address containing black funds

	 * @param 	amount is amount of black funds to be destroyed

	 */

    function destroyBlackFunds(address maliciousAddress, uint256 amount) external onlyChainportCongress {

        _burn(maliciousAddress, amount);

        emit BlackFundsDestroyed(maliciousAddress, amount);

    }



    /**

	 * @notice  Function for withdrawal of tokens stuck on contract

	 *

	 * @param   token is token that got stuck

	 * @param   beneficiary is address of token owner/sender

	 */

    function withdrawTokenIfStuck(address token, address beneficiary) external onlyChainportCongress nonReentrant {

        uint256 amount = IERC20(token).balanceOf(address(this));

        IERC20(token).transfer(beneficiary, amount);

        emit StuckTokenWithdrawn(token, beneficiary, amount);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\Enum.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



/// @title Enum - Collection of enums

/// @author Richard Meissner - <richard@gnosis.pm>

contract Enum {

    enum Operation {Call, DelegateCall}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\ERC1967Proxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../Proxy.sol";

import "./ERC1967Upgrade.sol";



/**

 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an

 * implementation address that can be changed. This address is stored in storage in the location specified by

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the

 * implementation behind the proxy.

 */

contract ERC1967Proxy is Proxy, ERC1967Upgrade {

    /**

     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.

     *

     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded

     * function call, and allows initializating the storage of the proxy like a Solidity constructor.

     */

    constructor(address _logic, bytes memory _data) payable {

        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));

        _upgradeToAndCall(_logic, _data, false);

    }



    /**

     * @dev Returns the current implementation address.

     */

    function _implementation() internal view virtual override returns (address impl) {

        return ERC1967Upgrade._getImplementation();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\ERC1967Upgrade.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.2;



import "../beacon/IBeacon.sol";

import "../../utils/Address.sol";

import "../../utils/StorageSlot.sol";



/**

 * @dev This abstract contract provides getters and event emitting update functions for

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.

 *

 * _Available since v4.1._

 *

 * @custom:oz-upgrades-unsafe-allow delegatecall

 */

abstract contract ERC1967Upgrade {

    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1

    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;



    /**

     * @dev Storage slot with the address of the current implementation.

     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



    /**

     * @dev Emitted when the implementation is upgraded.

     */

    event Upgraded(address indexed implementation);



    /**

     * @dev Returns the current implementation address.

     */

    function _getImplementation() internal view returns (address) {

        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 implementation slot.

     */

    function _setImplementation(address newImplementation) private {

        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

    }



    /**

     * @dev Perform implementation upgrade

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeTo(address newImplementation) internal {

        _setImplementation(newImplementation);

        emit Upgraded(newImplementation);

    }



    /**

     * @dev Perform implementation upgrade with additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {

        _setImplementation(newImplementation);

        emit Upgraded(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }

    }



    /**

     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCallSecure(address newImplementation, bytes memory data, bool forceCall) internal {

        address oldImplementation = _getImplementation();



        // Initial upgrade and setup call

        _setImplementation(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }



        // Perform rollback test if not already in progress

        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);

        if (!rollbackTesting.value) {

            // Trigger rollback using upgradeTo from the new implementation

            rollbackTesting.value = true;

            Address.functionDelegateCall(

                newImplementation,

                abi.encodeWithSignature(

                    "upgradeTo(address)",

                    oldImplementation

                )

            );

            rollbackTesting.value = false;

            // Check rollback was effective

            require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");

            // Finally reset to the new implementation and log the upgrade

            _setImplementation(newImplementation);

            emit Upgraded(newImplementation);

        }

    }



    /**

     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does

     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).

     *

     * Emits a {BeaconUpgraded} event.

     */

    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {

        _setBeacon(newBeacon);

        emit BeaconUpgraded(newBeacon);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);

        }

    }



    /**

     * @dev Storage slot with the admin of the contract.

     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



    /**

     * @dev Emitted when the admin account has changed.

     */

    event AdminChanged(address previousAdmin, address newAdmin);



    /**

     * @dev Returns the current admin.

     */

    function _getAdmin() internal view returns (address) {

        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 admin slot.

     */

    function _setAdmin(address newAdmin) private {

        require(newAdmin != address(0), "ERC1967: new admin is the zero address");

        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;

    }



    /**

     * @dev Changes the admin of the proxy.

     *

     * Emits an {AdminChanged} event.

     */

    function _changeAdmin(address newAdmin) internal {

        emit AdminChanged(_getAdmin(), newAdmin);

        _setAdmin(newAdmin);

    }



    /**

     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.

     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.

     */

    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;



    /**

     * @dev Emitted when the beacon is upgraded.

     */

    event BeaconUpgraded(address indexed beacon);



    /**

     * @dev Returns the current beacon.

     */

    function _getBeacon() internal view returns (address) {

        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;

    }



    /**

     * @dev Stores a new beacon in the EIP1967 beacon slot.

     */

    function _setBeacon(address newBeacon) private {

        require(

            Address.isContract(newBeacon),

            "ERC1967: new beacon is not a contract"

        );

        require(

            Address.isContract(IBeacon(newBeacon).implementation()),

            "ERC1967: beacon implementation is not a contract"

        );

        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\EtherPaymentFallback.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments

/// @author Richard Meissner - <richard@gnosis.pm>

contract EtherPaymentFallback {

    event SafeReceived(address indexed sender, uint256 value);



    /// @dev Fallback function accepts Ether transactions.

    receive() external payable {

        emit SafeReceived(msg.sender, msg.value);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\Executor.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;

import "../common/Enum.sol";



/// @title Executor - A contract that can execute transactions

/// @author Richard Meissner - <richard@gnosis.pm>

contract Executor {

    function execute(

        address to,

        uint256 value,

        bytes memory data,

        Enum.Operation operation,

        uint256 txGas

    ) internal returns (bool success) {

        if (operation == Enum.Operation.DelegateCall) {

            // solhint-disable-next-line no-inline-assembly

            assembly {

                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)

            }

        } else {

            // solhint-disable-next-line no-inline-assembly

            assembly {

                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\FallbackManager.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



import "../common/SelfAuthorized.sol";



/// @title Fallback Manager - A contract that manages fallback calls made to this contract

/// @author Richard Meissner - <richard@gnosis.pm>

contract FallbackManager is SelfAuthorized {

    event ChangedFallbackHandler(address handler);



    // keccak256("fallback_manager.handler.address")

    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;



    function internalSetFallbackHandler(address handler) internal {

        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;

        // solhint-disable-next-line no-inline-assembly

        assembly {

            sstore(slot, handler)

        }

    }



    /// @dev Allows to add a contract to handle fallback calls.

    ///      Only fallback calls without value and with data will be forwarded.

    ///      This can only be done via a Safe transaction.

    /// @param handler contract to handle fallbacks calls.

    function setFallbackHandler(address handler) public authorized {

        internalSetFallbackHandler(handler);

        emit ChangedFallbackHandler(handler);

    }



    // solhint-disable-next-line payable-fallback,no-complex-fallback

    fallback() external {

        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;

        // solhint-disable-next-line no-inline-assembly

        assembly {

            let handler := sload(slot)

            if iszero(handler) {

                return(0, 0)

            }

            calldatacopy(0, 0, calldatasize())

            // The msg.sender address is shifted to the left by 12 bytes to remove the padding

            // Then the address without padding is stored right after the calldata

            mstore(calldatasize(), shl(96, caller()))

            // Add 20 bytes for the address appended add the end

            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)

            returndatacopy(0, 0, returndatasize())

            if iszero(success) {

                revert(0, returndatasize())

            }

            return(0, returndatasize())

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\GnosisSafe.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2019-12-26

*/



pragma solidity >=0.5.0 <0.7.0;



/// @title SelfAuthorized - authorizes current contract to perform actions

/// @author Richard Meissner - <richard@gnosis.pm>

contract SelfAuthorized {

    modifier authorized() {

        require(msg.sender == address(this), "Method can only be called from this contract");

        _;

    }

}







/// @title MasterCopy - Base for master copy contracts (should always be first super contract)

///         This contract is tightly coupled to our proxy contract (see `proxies/Proxy.sol`)

/// @author Richard Meissner - <richard@gnosis.io>

contract MasterCopy is SelfAuthorized {



    event ChangedMasterCopy(address masterCopy);



    // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.

    // It should also always be ensured that the address is stored alone (uses a full word)

    address private masterCopy;



    /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.

    /// @param _masterCopy New contract address.

    function changeMasterCopy(address _masterCopy)

        public

        authorized

    {

        // Master copy address cannot be null.

        require(_masterCopy != address(0), "Invalid master copy address provided");

        masterCopy = _masterCopy;

        emit ChangedMasterCopy(_masterCopy);

    }

}





/// @title Module - Base class for modules.

/// @author Stefan George - <stefan@gnosis.pm>

/// @author Richard Meissner - <richard@gnosis.pm>

contract Module is MasterCopy {



    ModuleManager public manager;



    modifier authorized() {

        require(msg.sender == address(manager), "Method can only be called from manager");

        _;

    }



    function setManager()

        internal

    {

        // manager can only be 0 at initalization of contract.

        // Check ensures that setup function can only be called once.

        require(address(manager) == address(0), "Manager has already been set");

        manager = ModuleManager(msg.sender);

    }

}











/// @title Enum - Collection of enums

/// @author Richard Meissner - <richard@gnosis.pm>

contract Enum {

    enum Operation {

        Call,

        DelegateCall

    }

}











/// @title Executor - A contract that can execute transactions

/// @author Richard Meissner - <richard@gnosis.pm>

contract Executor {



    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)

        internal

        returns (bool success)

    {

        if (operation == Enum.Operation.Call)

            success = executeCall(to, value, data, txGas);

        else if (operation == Enum.Operation.DelegateCall)

            success = executeDelegateCall(to, data, txGas);

        else

            success = false;

    }



    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)

        internal

        returns (bool success)

    {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)

        }

    }



    function executeDelegateCall(address to, bytes memory data, uint256 txGas)

        internal

        returns (bool success)

    {

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)

        }

    }

}







/// @title SecuredTokenTransfer - Secure token transfer

/// @author Richard Meissner - <richard@gnosis.pm>

contract SecuredTokenTransfer {



    /// @dev Transfers a token and returns if it was a success

    /// @param token Token that should be transferred

    /// @param receiver Receiver to whom the token should be transferred

    /// @param amount The amount of tokens that should be transferred

    function transferToken (

        address token,

        address receiver,

        uint256 amount

    )

        internal

        returns (bool transferred)

    {

        bytes memory data = abi.encodeWithSignature("transfer(address,uint256)", receiver, amount);

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)

            let ptr := mload(0x40)

            mstore(0x40, add(ptr, returndatasize()))

            returndatacopy(ptr, 0, returndatasize())

            switch returndatasize()

            case 0 { transferred := success }

            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }

            default { transferred := 0 }

        }

    }

}





















/// @title Module Manager - A contract that manages modules that can execute transactions via this contract

/// @author Stefan George - <stefan@gnosis.pm>

/// @author Richard Meissner - <richard@gnosis.pm>

contract ModuleManager is SelfAuthorized, Executor {



    event EnabledModule(Module module);

    event DisabledModule(Module module);

    event ExecutionFromModuleSuccess(address indexed module);

    event ExecutionFromModuleFailure(address indexed module);



    address internal constant SENTINEL_MODULES = address(0x1);



    mapping (address => address) internal modules;



    function setupModules(address to, bytes memory data)

        internal

    {

        require(modules[SENTINEL_MODULES] == address(0), "Modules have already been initialized");

        modules[SENTINEL_MODULES] = SENTINEL_MODULES;

        if (to != address(0))

            // Setup has to complete successfully or transaction fails.

            require(executeDelegateCall(to, data, gasleft()), "Could not finish initialization");

    }



    /// @dev Allows to add a module to the whitelist.

    ///      This can only be done via a Safe transaction.

    /// @param module Module to be whitelisted.

    function enableModule(Module module)

        public

        authorized

    {

        // Module address cannot be null or sentinel.

        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, "Invalid module address provided");

        // Module cannot be added twice.

        require(modules[address(module)] == address(0), "Module has already been added");

        modules[address(module)] = modules[SENTINEL_MODULES];

        modules[SENTINEL_MODULES] = address(module);

        emit EnabledModule(module);

    }



    /// @dev Allows to remove a module from the whitelist.

    ///      This can only be done via a Safe transaction.

    /// @param prevModule Module that pointed to the module to be removed in the linked list

    /// @param module Module to be removed.

    function disableModule(Module prevModule, Module module)

        public

        authorized

    {

        // Validate module address and check that it corresponds to module index.

        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, "Invalid module address provided");

        require(modules[address(prevModule)] == address(module), "Invalid prevModule, module pair provided");

        modules[address(prevModule)] = modules[address(module)];

        modules[address(module)] = address(0);

        emit DisabledModule(module);

    }



    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.

    /// @param to Destination address of module transaction.

    /// @param value Ether value of module transaction.

    /// @param data Data payload of module transaction.

    /// @param operation Operation type of module transaction.

    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)

        public

        returns (bool success)

    {

        // Only whitelisted modules are allowed.

        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), "Method can only be called from an enabled module");

        // Execute transaction without further confirmations.

        success = execute(to, value, data, operation, gasleft());

        if (success) emit ExecutionFromModuleSuccess(msg.sender);

        else emit ExecutionFromModuleFailure(msg.sender);

    }



    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data

    /// @param to Destination address of module transaction.

    /// @param value Ether value of module transaction.

    /// @param data Data payload of module transaction.

    /// @param operation Operation type of module transaction.

    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)

        public

        returns (bool success, bytes memory returnData)

    {

        success = execTransactionFromModule(to, value, data, operation);

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            // Load free memory location

            let ptr := mload(0x40)

            // We allocate memory for the return data by setting the free memory location to

            // current free memory location + data size + 32 bytes for data size value

            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))

            // Store the size

            mstore(ptr, returndatasize())

            // Store the data

            returndatacopy(add(ptr, 0x20), 0, returndatasize())

            // Point the return data to the correct memory location

            returnData := ptr

        }

    }



    /// @dev Returns array of first 10 modules.

    /// @return Array of modules.

    function getModules()

        public

        view

        returns (address[] memory)

    {

        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);

        return array;

    }



    /// @dev Returns array of modules.

    /// @param start Start of the page.

    /// @param pageSize Maximum number of modules that should be returned.

    /// @return Array of modules.

    function getModulesPaginated(address start, uint256 pageSize)

        public

        view

        returns (address[] memory array, address next)

    {

        // Init array with max page size

        array = new address[](pageSize);



        // Populate return array

        uint256 moduleCount = 0;

        address currentModule = modules[start];

        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {

            array[moduleCount] = currentModule;

            currentModule = modules[currentModule];

            moduleCount++;

        }

        next = currentModule;

        // Set correct size of returned array

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            mstore(array, moduleCount)

        }

    }

}









/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.

/// @author Stefan George - <stefan@gnosis.pm>

/// @author Richard Meissner - <richard@gnosis.pm>

contract OwnerManager is SelfAuthorized {



    event AddedOwner(address owner);

    event RemovedOwner(address owner);

    event ChangedThreshold(uint256 threshold);



    address internal constant SENTINEL_OWNERS = address(0x1);



    mapping(address => address) internal owners;

    uint256 ownerCount;

    uint256 internal threshold;



    /// @dev Setup function sets initial storage of contract.

    /// @param _owners List of Safe owners.

    /// @param _threshold Number of required confirmations for a Safe transaction.

    function setupOwners(address[] memory _owners, uint256 _threshold)

        internal

    {

        // Threshold can only be 0 at initialization.

        // Check ensures that setup function can only be called once.

        require(threshold == 0, "Owners have already been setup");

        // Validate that threshold is smaller than number of added owners.

        require(_threshold <= _owners.length, "Threshold cannot exceed owner count");

        // There has to be at least one Safe owner.

        require(_threshold >= 1, "Threshold needs to be greater than 0");

        // Initializing Safe owners.

        address currentOwner = SENTINEL_OWNERS;

        for (uint256 i = 0; i < _owners.length; i++) {

            // Owner address cannot be null.

            address owner = _owners[i];

            require(owner != address(0) && owner != SENTINEL_OWNERS, "Invalid owner address provided");

            // No duplicate owners allowed.

            require(owners[owner] == address(0), "Duplicate owner address provided");

            owners[currentOwner] = owner;

            currentOwner = owner;

        }

        owners[currentOwner] = SENTINEL_OWNERS;

        ownerCount = _owners.length;

        threshold = _threshold;

    }



    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.

    ///      This can only be done via a Safe transaction.

    /// @param owner New owner address.

    /// @param _threshold New threshold.

    function addOwnerWithThreshold(address owner, uint256 _threshold)

        public

        authorized

    {

        // Owner address cannot be null.

        require(owner != address(0) && owner != SENTINEL_OWNERS, "Invalid owner address provided");

        // No duplicate owners allowed.

        require(owners[owner] == address(0), "Address is already an owner");

        owners[owner] = owners[SENTINEL_OWNERS];

        owners[SENTINEL_OWNERS] = owner;

        ownerCount++;

        emit AddedOwner(owner);

        // Change threshold if threshold was changed.

        if (threshold != _threshold)

            changeThreshold(_threshold);

    }



    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.

    ///      This can only be done via a Safe transaction.

    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list

    /// @param owner Owner address to be removed.

    /// @param _threshold New threshold.

    function removeOwner(address prevOwner, address owner, uint256 _threshold)

        public

        authorized

    {

        // Only allow to remove an owner, if threshold can still be reached.

        require(ownerCount - 1 >= _threshold, "New owner count needs to be larger than new threshold");

        // Validate owner address and check that it corresponds to owner index.

        require(owner != address(0) && owner != SENTINEL_OWNERS, "Invalid owner address provided");

        require(owners[prevOwner] == owner, "Invalid prevOwner, owner pair provided");

        owners[prevOwner] = owners[owner];

        owners[owner] = address(0);

        ownerCount--;

        emit RemovedOwner(owner);

        // Change threshold if threshold was changed.

        if (threshold != _threshold)

            changeThreshold(_threshold);

    }



    /// @dev Allows to swap/replace an owner from the Safe with another address.

    ///      This can only be done via a Safe transaction.

    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list

    /// @param oldOwner Owner address to be replaced.

    /// @param newOwner New owner address.

    function swapOwner(address prevOwner, address oldOwner, address newOwner)

        public

        authorized

    {

        // Owner address cannot be null.

        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, "Invalid owner address provided");

        // No duplicate owners allowed.

        require(owners[newOwner] == address(0), "Address is already an owner");

        // Validate oldOwner address and check that it corresponds to owner index.

        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, "Invalid owner address provided");

        require(owners[prevOwner] == oldOwner, "Invalid prevOwner, owner pair provided");

        owners[newOwner] = owners[oldOwner];

        owners[prevOwner] = newOwner;

        owners[oldOwner] = address(0);

        emit RemovedOwner(oldOwner);

        emit AddedOwner(newOwner);

    }



    /// @dev Allows to update the number of required confirmations by Safe owners.

    ///      This can only be done via a Safe transaction.

    /// @param _threshold New threshold.

    function changeThreshold(uint256 _threshold)

        public

        authorized

    {

        // Validate that threshold is smaller than number of owners.

        require(_threshold <= ownerCount, "Threshold cannot exceed owner count");

        // There has to be at least one Safe owner.

        require(_threshold >= 1, "Threshold needs to be greater than 0");

        threshold = _threshold;

        emit ChangedThreshold(threshold);

    }



    function getThreshold()

        public

        view

        returns (uint256)

    {

        return threshold;

    }



    function isOwner(address owner)

        public

        view

        returns (bool)

    {

        return owner != SENTINEL_OWNERS && owners[owner] != address(0);

    }



    /// @dev Returns array of owners.

    /// @return Array of Safe owners.

    function getOwners()

        public

        view

        returns (address[] memory)

    {

        address[] memory array = new address[](ownerCount);



        // populate return array

        uint256 index = 0;

        address currentOwner = owners[SENTINEL_OWNERS];

        while(currentOwner != SENTINEL_OWNERS) {

            array[index] = currentOwner;

            currentOwner = owners[currentOwner];

            index ++;

        }

        return array;

    }

}











/// @title Fallback Manager - A contract that manages fallback calls made to this contract

/// @author Richard Meissner - <richard@gnosis.pm>

contract FallbackManager is SelfAuthorized {



    // keccak256("fallback_manager.handler.address")

    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;



    function internalSetFallbackHandler(address handler) internal {

        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            sstore(slot, handler)

        }

    }



    /// @dev Allows to add a contract to handle fallback calls.

    ///      Only fallback calls without value and with data will be forwarded.

    ///      This can only be done via a Safe transaction.

    /// @param handler contract to handle fallbacks calls.

    function setFallbackHandler(address handler)

        public

        authorized

    {

        internalSetFallbackHandler(handler);

    }



    function ()

        external

        payable

    {

        // Only calls without value and with data will be forwarded

        if (msg.value > 0 || msg.data.length == 0) {

            return;

        }

        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;

        address handler;

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            handler := sload(slot)

        }



        if (handler != address(0)) {

            // solium-disable-next-line security/no-inline-assembly

            assembly {

                calldatacopy(0, 0, calldatasize())

                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)

                returndatacopy(0, 0, returndatasize())

                if eq(success, 0) { revert(0, returndatasize()) }

                return(0, returndatasize())

            }

        }

    }

}















/// @title SignatureDecoder - Decodes signatures that a encoded as bytes

/// @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)

/// @author Richard Meissner - <richard@gnosis.pm>

contract SignatureDecoder {

    

    /// @dev Recovers address who signed the message

    /// @param messageHash operation ethereum signed message hash

    /// @param messageSignature message `txHash` signature

    /// @param pos which signature to read

    function recoverKey (

        bytes32 messageHash,

        bytes memory messageSignature,

        uint256 pos

    )

        internal

        pure

        returns (address)

    {

        uint8 v;

        bytes32 r;

        bytes32 s;

        (v, r, s) = signatureSplit(messageSignature, pos);

        return ecrecover(messageHash, v, r, s);

    }



    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.

    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures

    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access

    /// @param signatures concatenated rsv signatures

    function signatureSplit(bytes memory signatures, uint256 pos)

        internal

        pure

        returns (uint8 v, bytes32 r, bytes32 s)

    {

        // The signature format is a compact form of:

        //   {bytes32 r}{bytes32 s}{uint8 v}

        // Compact means, uint8 is not padded to 32 bytes.

        // solium-disable-next-line security/no-inline-assembly

        assembly {

            let signaturePos := mul(0x41, pos)

            r := mload(add(signatures, add(signaturePos, 0x20)))

            s := mload(add(signatures, add(signaturePos, 0x40)))

            // Here we are loading the last 32 bytes, including 31 bytes

            // of 's'. There is no 'mload8' to do this.

            //

            // 'byte' is not working due to the Solidity parser, so lets

            // use the second best option, 'and'

            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)

        }

    }

}









contract ISignatureValidatorConstants {

    // bytes4(keccak256("isValidSignature(bytes,bytes)")

    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;

}



contract ISignatureValidator is ISignatureValidatorConstants {



    /**

    * @dev Should return whether the signature provided is valid for the provided data

    * @param _data Arbitrary length data signed on the behalf of address(this)

    * @param _signature Signature byte array associated with _data

    *

    * MUST return the bytes4 magic value 0x20c13b0b when function passes.

    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)

    * MUST allow external calls

    */

    function isValidSignature(

        bytes memory _data,

        bytes memory _signature)

        public

        view

        returns (bytes4);

}





/**

 * @title SafeMath

 * @dev Math operations with safety checks that revert on error

 * TODO: remove once open zeppelin update to solc 0.5.0

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, reverts on overflow.

  */

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {

    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (a == 0) {

      return 0;

    }



    uint256 c = a * b;

    require(c / a == b);



    return c;

  }



  /**

  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.

  */

  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    require(b > 0); // Solidity only automatically asserts when dividing by 0

    uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn't hold



    return c;

  }



  /**

  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    require(b <= a);

    uint256 c = a - b;



    return c;

  }



  /**

  * @dev Adds two numbers, reverts on overflow.

  */

  function add(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a + b;

    require(c >= a);



    return c;

  }



  /**

  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),

  * reverts when dividing by zero.

  */

  function mod(uint256 a, uint256 b) internal pure returns (uint256) {

    require(b != 0);

    return a % b;

  }

}



/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.

/// @author Stefan George - <stefan@gnosis.io>

/// @author Richard Meissner - <richard@gnosis.io>

/// @author Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment

contract GnosisSafe

    is MasterCopy, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager {



    using SafeMath for uint256;



    string public constant NAME = "Gnosis Safe";

    string public constant VERSION = "1.1.1";



    //keccak256(

    //    "EIP712Domain(address verifyingContract)"

    //);

    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;



    //keccak256(

    //    "SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)"

    //);

    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;



    //keccak256(

    //    "SafeMessage(bytes message)"

    //);

    bytes32 private constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;



    event ApproveHash(

        bytes32 indexed approvedHash,

        address indexed owner

    );

    event SignMsg(

        bytes32 indexed msgHash

    );

    event ExecutionFailure(

        bytes32 txHash, uint256 payment

    );

    event ExecutionSuccess(

        bytes32 txHash, uint256 payment

    );



    uint256 public nonce;

    bytes32 public domainSeparator;

    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners

    mapping(bytes32 => uint256) public signedMessages;

    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners

    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;



    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts

    constructor() public {

        // By setting the threshold it is not possible to call setup anymore,

        // so we create a Safe with 0 owners and threshold 1.

        // This is an unusable Safe, perfect for the mastercopy

        threshold = 1;

    }



    /// @dev Setup function sets initial storage of contract.

    /// @param _owners List of Safe owners.

    /// @param _threshold Number of required confirmations for a Safe transaction.

    /// @param to Contract address for optional delegate call.

    /// @param data Data payload for optional delegate call.

    /// @param fallbackHandler Handler for fallback calls to this contract

    /// @param paymentToken Token that should be used for the payment (0 is ETH)

    /// @param payment Value that should be paid

    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)

    function setup(

        address[] calldata _owners,

        uint256 _threshold,

        address to,

        bytes calldata data,

        address fallbackHandler,

        address paymentToken,

        uint256 payment,

        address payable paymentReceiver

    )

        external

    {

        require(domainSeparator == 0, "Domain Separator already set!");

        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));

        setupOwners(_owners, _threshold);

        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);

        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules

        setupModules(to, data);



        if (payment > 0) {

            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)

            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment

            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);

        }

    }



    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.

    ///      Note: The fees are always transfered, even if the user transaction fails.

    /// @param to Destination address of Safe transaction.

    /// @param value Ether value of Safe transaction.

    /// @param data Data payload of Safe transaction.

    /// @param operation Operation type of Safe transaction.

    /// @param safeTxGas Gas that should be used for the Safe transaction.

    /// @param baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)

    /// @param gasPrice Gas price that should be used for the payment calculation.

    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.

    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).

    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})

    function execTransaction(

        address to,

        uint256 value,

        bytes calldata data,

        Enum.Operation operation,

        uint256 safeTxGas,

        uint256 baseGas,

        uint256 gasPrice,

        address gasToken,

        address payable refundReceiver,

        bytes calldata signatures

    )

        external

        returns (bool success)

    {

        bytes32 txHash;

        // Use scope here to limit variable lifetime and prevent `stack too deep` errors

        {

            bytes memory txHashData = encodeTransactionData(

                to, value, data, operation, // Transaction info

                safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info

                nonce

            );

            // Increase nonce and execute transaction.

            nonce++;

            txHash = keccak256(txHashData);

            checkSignatures(txHash, txHashData, signatures, true);

        }

        require(gasleft() >= safeTxGas, "Not enough gas to execute safe transaction");

        // Use scope here to limit variable lifetime and prevent `stack too deep` errors

        {

            uint256 gasUsed = gasleft();

            // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used

            success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);

            gasUsed = gasUsed.sub(gasleft());

            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls

            uint256 payment = 0;

            if (gasPrice > 0) {

                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);

            }

            if (success) emit ExecutionSuccess(txHash, payment);

            else emit ExecutionFailure(txHash, payment);

        }

    }



    function handlePayment(

        uint256 gasUsed,

        uint256 baseGas,

        uint256 gasPrice,

        address gasToken,

        address payable refundReceiver

    )

        private

        returns (uint256 payment)

    {

        // solium-disable-next-line security/no-tx-origin

        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;

        if (gasToken == address(0)) {

            // For ETH we will only adjust the gas price to not be higher than the actual used gas price

            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);

            // solium-disable-next-line security/no-send

            require(receiver.send(payment), "Could not pay gas costs with ether");

        } else {

            payment = gasUsed.add(baseGas).mul(gasPrice);

            require(transferToken(gasToken, receiver, payment), "Could not pay gas costs with token");

        }

    }



    /**

    * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.

    * @param dataHash Hash of the data (could be either a message hash or transaction hash)

    * @param data That should be signed (this is passed to an external validator contract)

    * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.

    * @param consumeHash Indicates that in case of an approved hash the storage can be freed to save gas

    */

    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)

        internal

    {

        // Load threshold to avoid multiple storage loads

        uint256 _threshold = threshold;

        // Check that a threshold is set

        require(_threshold > 0, "Threshold needs to be defined!");

        // Check that the provided signature data is not too short

        require(signatures.length >= _threshold.mul(65), "Signatures data too short");

        // There cannot be an owner with address 0.

        address lastOwner = address(0);

        address currentOwner;

        uint8 v;

        bytes32 r;

        bytes32 s;

        uint256 i;

        for (i = 0; i < _threshold; i++) {

            (v, r, s) = signatureSplit(signatures, i);

            // If v is 0 then it is a contract signature

            if (v == 0) {

                // When handling contract signatures the address of the contract is encoded into r

                currentOwner = address(uint256(r));



                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes

                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.

                // Here we only check that the pointer is not pointing inside the part that is being processed

                require(uint256(s) >= _threshold.mul(65), "Invalid contract signature location: inside static part");



                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)

                require(uint256(s).add(32) <= signatures.length, "Invalid contract signature location: length not present");



                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length

                uint256 contractSignatureLen;

                // solium-disable-next-line security/no-inline-assembly

                assembly {

                    contractSignatureLen := mload(add(add(signatures, s), 0x20))

                }

                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, "Invalid contract signature location: data not complete");



                // Check signature

                bytes memory contractSignature;

                // solium-disable-next-line security/no-inline-assembly

                assembly {

                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s

                    contractSignature := add(add(signatures, s), 0x20)

                }

                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, "Invalid contract signature provided");

            // If v is 1 then it is an approved hash

            } else if (v == 1) {

                // When handling approved hashes the address of the approver is encoded into r

                currentOwner = address(uint256(r));

                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction

                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, "Hash has not been approved");

                // Hash has been marked for consumption. If this hash was pre-approved free storage

                if (consumeHash && msg.sender != currentOwner) {

                    approvedHashes[currentOwner][dataHash] = 0;

                }

            } else if (v > 30) {

                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover

                currentOwner = ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", dataHash)), v - 4, r, s);

            } else {

                // Use ecrecover with the messageHash for EOA signatures

                currentOwner = ecrecover(dataHash, v, r, s);

            }

            require (

                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,

                "Invalid owner provided"

            );

            lastOwner = currentOwner;

        }

    }



    /// @dev Allows to estimate a Safe transaction.

    ///      This method is only meant for estimation purpose, therefore two different protection mechanism against execution in a transaction have been made:

    ///      1.) The method can only be called from the safe itself

    ///      2.) The response is returned with a revert

    ///      When estimating set `from` to the address of the safe.

    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`

    /// @param to Destination address of Safe transaction.

    /// @param value Ether value of Safe transaction.

    /// @param data Data payload of Safe transaction.

    /// @param operation Operation type of Safe transaction.

    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).

    function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)

        external

        authorized

        returns (uint256)

    {

        uint256 startGas = gasleft();

        // We don't provide an error message here, as we use it to return the estimate

        // solium-disable-next-line error-reason

        require(execute(to, value, data, operation, gasleft()));

        uint256 requiredGas = startGas - gasleft();

        // Convert response to string and return via error message

        revert(string(abi.encodePacked(requiredGas)));

    }



    /**

    * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.

    * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.

    */

    function approveHash(bytes32 hashToApprove)

        external

    {

        require(owners[msg.sender] != address(0), "Only owners can approve a hash");

        approvedHashes[msg.sender][hashToApprove] = 1;

        emit ApproveHash(hashToApprove, msg.sender);

    }



    /**

    * @dev Marks a message as signed

    * @param _data Arbitrary length data that should be marked as signed on the behalf of address(this)

    */

    function signMessage(bytes calldata _data)

        external

        authorized

    {

        bytes32 msgHash = getMessageHash(_data);

        signedMessages[msgHash] = 1;

        emit SignMsg(msgHash);

    }



    /**

    * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)

    * @dev Should return whether the signature provided is valid for the provided data.

    *       The save does not implement the interface since `checkSignatures` is not a view method.

    *       The method will not perform any state changes (see parameters of `checkSignatures`)

    * @param _data Arbitrary length data signed on the behalf of address(this)

    * @param _signature Signature byte array associated with _data

    * @return a bool upon valid or invalid signature with corresponding _data

    */

    function isValidSignature(bytes calldata _data, bytes calldata _signature)

        external

        returns (bytes4)

    {

        bytes32 messageHash = getMessageHash(_data);

        if (_signature.length == 0) {

            require(signedMessages[messageHash] != 0, "Hash not approved");

        } else {

            // consumeHash needs to be false, as the state should not be changed

            checkSignatures(messageHash, _data, _signature, false);

        }

        return EIP1271_MAGIC_VALUE;

    }



    /// @dev Returns hash of a message that can be signed by owners.

    /// @param message Message that should be hashed

    /// @return Message hash.

    function getMessageHash(

        bytes memory message

    )

        public

        view

        returns (bytes32)

    {

        bytes32 safeMessageHash = keccak256(

            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))

        );

        return keccak256(

            abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)

        );

    }



    /// @dev Returns the bytes that are hashed to be signed by owners.

    /// @param to Destination address.

    /// @param value Ether value.

    /// @param data Data payload.

    /// @param operation Operation type.

    /// @param safeTxGas Fas that should be used for the safe transaction.

    /// @param baseGas Gas costs for data used to trigger the safe transaction.

    /// @param gasPrice Maximum gas price that should be used for this transaction.

    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.

    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).

    /// @param _nonce Transaction nonce.

    /// @return Transaction hash bytes.

    function encodeTransactionData(

        address to,

        uint256 value,

        bytes memory data,

        Enum.Operation operation,

        uint256 safeTxGas,

        uint256 baseGas,

        uint256 gasPrice,

        address gasToken,

        address refundReceiver,

        uint256 _nonce

    )

        public

        view

        returns (bytes memory)

    {

        bytes32 safeTxHash = keccak256(

            abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)

        );

        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);

    }



    /// @dev Returns hash to be signed by owners.

    /// @param to Destination address.

    /// @param value Ether value.

    /// @param data Data payload.

    /// @param operation Operation type.

    /// @param safeTxGas Fas that should be used for the safe transaction.

    /// @param baseGas Gas costs for data used to trigger the safe transaction.

    /// @param gasPrice Maximum gas price that should be used for this transaction.

    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.

    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).

    /// @param _nonce Transaction nonce.

    /// @return Transaction hash.

    function getTransactionHash(

        address to,

        uint256 value,

        bytes memory data,

        Enum.Operation operation,

        uint256 safeTxGas,

        uint256 baseGas,

        uint256 gasPrice,

        address gasToken,

        address refundReceiver,

        uint256 _nonce

    )

        public

        view

        returns (bytes32)

    {

        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\GnosisSafeMath.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



/**

 * @title GnosisSafeMath

 * @dev Math operations with safety checks that revert on error

 * Renamed from SafeMath to GnosisSafeMath to avoid conflicts

 * TODO: remove once open zeppelin update to solc 0.5.0

 */

library GnosisSafeMath {

    /**

     * @dev Multiplies two numbers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two numbers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Returns the largest of two numbers.

     */

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\GnosisSafeProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-07-09

*/



// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain

/// @author Richard Meissner - <richard@gnosis.io>

interface IProxy {

    function masterCopy() external view returns (address);

}



/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.

/// @author Stefan George - <stefan@gnosis.io>

/// @author Richard Meissner - <richard@gnosis.io>

contract GnosisSafeProxy {

    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.

    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`

    address internal singleton;



    /// @dev Constructor function sets address of singleton contract.

    /// @param _singleton Singleton address.

    constructor(address _singleton) {

        require(_singleton != address(0), "Invalid singleton address provided");

        singleton = _singleton;

    }



    /// @dev Fallback function forwards all transactions and returns all received return data.

    fallback() external payable {

        // solhint-disable-next-line no-inline-assembly

        assembly {

            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)

            // 0xa619486e == keccak("masterCopy()"). The value is right padded to 32-bytes with 0s

            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {

                mstore(0, _singleton)

                return(0, 0x20)

            }

            calldatacopy(0, 0, calldatasize())

            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)

            returndatacopy(0, 0, returndatasize())

            if eq(success, 0) {

                revert(0, returndatasize())

            }

            return(0, returndatasize())

        }

    }

}



/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.

/// @author Stefan George - <stefan@gnosis.pm>

contract GnosisSafeProxyFactory {

    event ProxyCreation(GnosisSafeProxy proxy, address singleton);



    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.

    /// @param singleton Address of singleton contract.

    /// @param data Payload for message call sent to new proxy contract.

    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {

        proxy = new GnosisSafeProxy(singleton);

        if (data.length > 0)

            // solhint-disable-next-line no-inline-assembly

            assembly {

                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {

                    revert(0, 0)

                }

            }

        emit ProxyCreation(proxy, singleton);

    }



    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.

    function proxyRuntimeCode() public pure returns (bytes memory) {

        return type(GnosisSafeProxy).runtimeCode;

    }



    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.

    function proxyCreationCode() public pure returns (bytes memory) {

        return type(GnosisSafeProxy).creationCode;

    }



    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.

    ///      This method is only meant as an utility to be called from other methods

    /// @param _singleton Address of singleton contract.

    /// @param initializer Payload for message call sent to new proxy contract.

    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.

    function deployProxyWithNonce(

        address _singleton,

        bytes memory initializer,

        uint256 saltNonce

    ) internal returns (GnosisSafeProxy proxy) {

        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it

        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));

        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));

        // solhint-disable-next-line no-inline-assembly

        assembly {

            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)

        }

        require(address(proxy) != address(0), "Create2 call failed");

    }



    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.

    /// @param _singleton Address of singleton contract.

    /// @param initializer Payload for message call sent to new proxy contract.

    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.

    function createProxyWithNonce(

        address _singleton,

        bytes memory initializer,

        uint256 saltNonce

    ) public returns (GnosisSafeProxy proxy) {

        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);

        if (initializer.length > 0)

            // solhint-disable-next-line no-inline-assembly

            assembly {

                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {

                    revert(0, 0)

                }

            }

        emit ProxyCreation(proxy, _singleton);

    }



    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction

    /// @param _singleton Address of singleton contract.

    /// @param initializer Payload for message call sent to new proxy contract.

    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.

    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.

    function createProxyWithCallback(

        address _singleton,

        bytes memory initializer,

        uint256 saltNonce,

        IProxyCreationCallback callback

    ) public returns (GnosisSafeProxy proxy) {

        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));

        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);

        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);

    }



    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`

    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,

    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.

    /// @param _singleton Address of singleton contract.

    /// @param initializer Payload for message call sent to new proxy contract.

    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.

    function calculateCreateProxyWithNonceAddress(

        address _singleton,

        bytes calldata initializer,

        uint256 saltNonce

    ) external returns (GnosisSafeProxy proxy) {

        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);

        revert(string(abi.encodePacked(proxy)));

    }

}



interface IProxyCreationCallback {

    function proxyCreated(

        GnosisSafeProxy proxy,

        address _singleton,

        bytes calldata initializer,

        uint256 saltNonce

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\GuardManager.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



import "../common/Enum.sol";

import "../common/SelfAuthorized.sol";



interface Guard {

    function checkTransaction(

        address to,

        uint256 value,

        bytes memory data,

        Enum.Operation operation,

        uint256 safeTxGas,

        uint256 baseGas,

        uint256 gasPrice,

        address gasToken,

        address payable refundReceiver,

        bytes memory signatures,

        address msgSender

    ) external;



    function checkAfterExecution(bytes32 txHash, bool success) external;

}



/// @title Fallback Manager - A contract that manages fallback calls made to this contract

/// @author Richard Meissner - <richard@gnosis.pm>

contract GuardManager is SelfAuthorized {

    event ChangedGuard(address guard);

    // keccak256("guard_manager.guard.address")

    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;



    /// @dev Set a guard that checks transactions before execution

    /// @param guard The address of the guard to be used or the 0 address to disable the guard

    function setGuard(address guard) external authorized {

        bytes32 slot = GUARD_STORAGE_SLOT;

        // solhint-disable-next-line no-inline-assembly

        assembly {

            sstore(slot, guard)

        }

        emit ChangedGuard(guard);

    }



    function getGuard() internal view returns (address guard) {

        bytes32 slot = GUARD_STORAGE_SLOT;

        // solhint-disable-next-line no-inline-assembly

        assembly {

            guard := sload(slot)

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\IBeacon.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev This is the interface that {BeaconProxy} expects of its beacon.

 */

interface IBeacon {

    /**

     * @dev Must return an address that can be used as a delegate call target.

     *

     * {BeaconProxy} will check that this address is a contract.

     */

    function implementation() external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\import.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

import "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

import "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";



// Kept for backwards compatibility with older versions of Hardhat and Truffle plugins.

contract AdminUpgradeabilityProxy is TransparentUpgradeableProxy {

    constructor(address logic, address admin, bytes memory data) payable TransparentUpgradeableProxy(logic, admin, data) {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\ISignatureValidator.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



contract ISignatureValidatorConstants {

    // bytes4(keccak256("isValidSignature(bytes,bytes)")

    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;

}



abstract contract ISignatureValidator is ISignatureValidatorConstants {

    /**

     * @dev Should return whether the signature provided is valid for the provided data

     * @param _data Arbitrary length data signed on the behalf of address(this)

     * @param _signature Signature byte array associated with _data

     *

     * MUST return the bytes4 magic value 0x20c13b0b when function passes.

     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)

     * MUST allow external calls

     */

    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\ModuleManager.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;

import "../common/Enum.sol";

import "../common/SelfAuthorized.sol";

import "./Executor.sol";



/// @title Module Manager - A contract that manages modules that can execute transactions via this contract

/// @author Stefan George - <stefan@gnosis.pm>

/// @author Richard Meissner - <richard@gnosis.pm>

contract ModuleManager is SelfAuthorized, Executor {

    event EnabledModule(address module);

    event DisabledModule(address module);

    event ExecutionFromModuleSuccess(address indexed module);

    event ExecutionFromModuleFailure(address indexed module);



    address internal constant SENTINEL_MODULES = address(0x1);



    mapping(address => address) internal modules;



    function setupModules(address to, bytes memory data) internal {

        require(modules[SENTINEL_MODULES] == address(0), "GS100");

        modules[SENTINEL_MODULES] = SENTINEL_MODULES;

        if (to != address(0))

            // Setup has to complete successfully or transaction fails.

            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), "GS000");

    }



    /// @dev Allows to add a module to the whitelist.

    ///      This can only be done via a Safe transaction.

    /// @notice Enables the module `module` for the Safe.

    /// @param module Module to be whitelisted.

    function enableModule(address module) public authorized {

        // Module address cannot be null or sentinel.

        require(module != address(0) && module != SENTINEL_MODULES, "GS101");

        // Module cannot be added twice.

        require(modules[module] == address(0), "GS102");

        modules[module] = modules[SENTINEL_MODULES];

        modules[SENTINEL_MODULES] = module;

        emit EnabledModule(module);

    }



    /// @dev Allows to remove a module from the whitelist.

    ///      This can only be done via a Safe transaction.

    /// @notice Disables the module `module` for the Safe.

    /// @param prevModule Module that pointed to the module to be removed in the linked list

    /// @param module Module to be removed.

    function disableModule(address prevModule, address module) public authorized {

        // Validate module address and check that it corresponds to module index.

        require(module != address(0) && module != SENTINEL_MODULES, "GS101");

        require(modules[prevModule] == module, "GS103");

        modules[prevModule] = modules[module];

        modules[module] = address(0);

        emit DisabledModule(module);

    }



    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.

    /// @param to Destination address of module transaction.

    /// @param value Ether value of module transaction.

    /// @param data Data payload of module transaction.

    /// @param operation Operation type of module transaction.

    function execTransactionFromModule(

        address to,

        uint256 value,

        bytes memory data,

        Enum.Operation operation

    ) public virtual returns (bool success) {

        // Only whitelisted modules are allowed.

        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), "GS104");

        // Execute transaction without further confirmations.

        success = execute(to, value, data, operation, gasleft());

        if (success) emit ExecutionFromModuleSuccess(msg.sender);

        else emit ExecutionFromModuleFailure(msg.sender);

    }



    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data

    /// @param to Destination address of module transaction.

    /// @param value Ether value of module transaction.

    /// @param data Data payload of module transaction.

    /// @param operation Operation type of module transaction.

    function execTransactionFromModuleReturnData(

        address to,

        uint256 value,

        bytes memory data,

        Enum.Operation operation

    ) public returns (bool success, bytes memory returnData) {

        success = execTransactionFromModule(to, value, data, operation);

        // solhint-disable-next-line no-inline-assembly

        assembly {

            // Load free memory location

            let ptr := mload(0x40)

            // We allocate memory for the return data by setting the free memory location to

            // current free memory location + data size + 32 bytes for data size value

            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))

            // Store the size

            mstore(ptr, returndatasize())

            // Store the data

            returndatacopy(add(ptr, 0x20), 0, returndatasize())

            // Point the return data to the correct memory location

            returnData := ptr

        }

    }



    /// @dev Returns if an module is enabled

    /// @return True if the module is enabled

    function isModuleEnabled(address module) public view returns (bool) {

        return SENTINEL_MODULES != module && modules[module] != address(0);

    }



    /// @dev Returns array of modules.

    /// @param start Start of the page.

    /// @param pageSize Maximum number of modules that should be returned.

    /// @return array Array of modules.

    /// @return next Start of the next page.

    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {

        // Init array with max page size

        array = new address[](pageSize);



        // Populate return array

        uint256 moduleCount = 0;

        address currentModule = modules[start];

        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {

            array[moduleCount] = currentModule;

            currentModule = modules[currentModule];

            moduleCount++;

        }

        next = currentModule;

        // Set correct size of returned array

        // solhint-disable-next-line no-inline-assembly

        assembly {

            mstore(array, moduleCount)

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../utils/Context.sol";

/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\OwnerManager.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;

import "../common/SelfAuthorized.sol";



/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.

/// @author Stefan George - <stefan@gnosis.pm>

/// @author Richard Meissner - <richard@gnosis.pm>

contract OwnerManager is SelfAuthorized {

    event AddedOwner(address owner);

    event RemovedOwner(address owner);

    event ChangedThreshold(uint256 threshold);



    address internal constant SENTINEL_OWNERS = address(0x1);



    mapping(address => address) internal owners;

    uint256 internal ownerCount;

    uint256 internal threshold;



    /// @dev Setup function sets initial storage of contract.

    /// @param _owners List of Safe owners.

    /// @param _threshold Number of required confirmations for a Safe transaction.

    function setupOwners(address[] memory _owners, uint256 _threshold) internal {

        // Threshold can only be 0 at initialization.

        // Check ensures that setup function can only be called once.

        require(threshold == 0, "GS200");

        // Validate that threshold is smaller than number of added owners.

        require(_threshold <= _owners.length, "GS201");

        // There has to be at least one Safe owner.

        require(_threshold >= 1, "GS202");

        // Initializing Safe owners.

        address currentOwner = SENTINEL_OWNERS;

        for (uint256 i = 0; i < _owners.length; i++) {

            // Owner address cannot be null.

            address owner = _owners[i];

            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, "GS203");

            // No duplicate owners allowed.

            require(owners[owner] == address(0), "GS204");

            owners[currentOwner] = owner;

            currentOwner = owner;

        }

        owners[currentOwner] = SENTINEL_OWNERS;

        ownerCount = _owners.length;

        threshold = _threshold;

    }



    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.

    ///      This can only be done via a Safe transaction.

    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.

    /// @param owner New owner address.

    /// @param _threshold New threshold.

    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {

        // Owner address cannot be null, the sentinel or the Safe itself.

        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), "GS203");

        // No duplicate owners allowed.

        require(owners[owner] == address(0), "GS204");

        owners[owner] = owners[SENTINEL_OWNERS];

        owners[SENTINEL_OWNERS] = owner;

        ownerCount++;

        emit AddedOwner(owner);

        // Change threshold if threshold was changed.

        if (threshold != _threshold) changeThreshold(_threshold);

    }



    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.

    ///      This can only be done via a Safe transaction.

    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.

    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list

    /// @param owner Owner address to be removed.

    /// @param _threshold New threshold.

    function removeOwner(

        address prevOwner,

        address owner,

        uint256 _threshold

    ) public authorized {

        // Only allow to remove an owner, if threshold can still be reached.

        require(ownerCount - 1 >= _threshold, "GS201");

        // Validate owner address and check that it corresponds to owner index.

        require(owner != address(0) && owner != SENTINEL_OWNERS, "GS203");

        require(owners[prevOwner] == owner, "GS205");

        owners[prevOwner] = owners[owner];

        owners[owner] = address(0);

        ownerCount--;

        emit RemovedOwner(owner);

        // Change threshold if threshold was changed.

        if (threshold != _threshold) changeThreshold(_threshold);

    }



    /// @dev Allows to swap/replace an owner from the Safe with another address.

    ///      This can only be done via a Safe transaction.

    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.

    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list

    /// @param oldOwner Owner address to be replaced.

    /// @param newOwner New owner address.

    function swapOwner(

        address prevOwner,

        address oldOwner,

        address newOwner

    ) public authorized {

        // Owner address cannot be null, the sentinel or the Safe itself.

        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), "GS203");

        // No duplicate owners allowed.

        require(owners[newOwner] == address(0), "GS204");

        // Validate oldOwner address and check that it corresponds to owner index.

        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, "GS203");

        require(owners[prevOwner] == oldOwner, "GS205");

        owners[newOwner] = owners[oldOwner];

        owners[prevOwner] = newOwner;

        owners[oldOwner] = address(0);

        emit RemovedOwner(oldOwner);

        emit AddedOwner(newOwner);

    }



    /// @dev Allows to update the number of required confirmations by Safe owners.

    ///      This can only be done via a Safe transaction.

    /// @notice Changes the threshold of the Safe to `_threshold`.

    /// @param _threshold New threshold.

    function changeThreshold(uint256 _threshold) public authorized {

        // Validate that threshold is smaller than number of owners.

        require(_threshold <= ownerCount, "GS201");

        // There has to be at least one Safe owner.

        require(_threshold >= 1, "GS202");

        threshold = _threshold;

        emit ChangedThreshold(threshold);

    }



    function getThreshold() public view returns (uint256) {

        return threshold;

    }



    function isOwner(address owner) public view returns (bool) {

        return owner != SENTINEL_OWNERS && owners[owner] != address(0);

    }



    /// @dev Returns array of owners.

    /// @return Array of Safe owners.

    function getOwners() public view returns (address[] memory) {

        address[] memory array = new address[](ownerCount);



        // populate return array

        uint256 index = 0;

        address currentOwner = owners[SENTINEL_OWNERS];

        while (currentOwner != SENTINEL_OWNERS) {

            array[index] = currentOwner;

            currentOwner = owners[currentOwner];

            index++;

        }

        return array;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\Proxiable.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.2;



import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";



abstract contract Proxiable is UUPSUpgradeable {

    function _authorizeUpgrade(address newImplementation) internal override {

        _beforeUpgrade(newImplementation);

    }



    function _beforeUpgrade(address newImplementation) internal virtual;

}



contract ChildOfProxiable is Proxiable {

    function _beforeUpgrade(address newImplementation) internal virtual override {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\Proxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM

 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to

 * be specified by overriding the virtual {_implementation} function.

 *

 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a

 * different contract through the {_delegate} function.

 *

 * The success and return data of the delegated call will be returned back to the caller of the proxy.

 */

abstract contract Proxy {

    /**

     * @dev Delegates the current call to `implementation`.

     *

     * This function does not return to its internall call site, it will return directly to the external caller.

     */

    function _delegate(address implementation) internal virtual {

        // solhint-disable-next-line no-inline-assembly

        assembly {

            // Copy msg.data. We take full control of memory in this inline assembly

            // block because it will not return to Solidity code. We overwrite the

            // Solidity scratch pad at memory position 0.

            calldatacopy(0, 0, calldatasize())



            // Call the implementation.

            // out and outsize are 0 because we don't know the size yet.

            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)



            // Copy the returned data.

            returndatacopy(0, 0, returndatasize())



            switch result

            // delegatecall returns 0 on error.

            case 0 { revert(0, returndatasize()) }

            default { return(0, returndatasize()) }

        }

    }



    /**

     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function

     * and {_fallback} should delegate.

     */

    function _implementation() internal view virtual returns (address);



    /**

     * @dev Delegates the current call to the address returned by `_implementation()`.

     *

     * This function does not return to its internall call site, it will return directly to the external caller.

     */

    function _fallback() internal virtual {

        _beforeFallback();

        _delegate(_implementation());

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other

     * function in the contract matches the call data.

     */

    fallback () external payable virtual {

        _fallback();

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data

     * is empty.

     */

    receive () external payable virtual {

        _fallback();

    }



    /**

     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`

     * call, or as part of the Solidity `fallback` or `receive` functions.

     *

     * If overriden should call `super._beforeFallback()`.

     */

    function _beforeFallback() internal virtual {

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\ProxyAdmin.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./TransparentUpgradeableProxy.sol";

import "../../access/Ownable.sol";



/**

 * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an

 * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.

 */

contract ProxyAdmin is Ownable {



    /**

     * @dev Returns the current implementation of `proxy`.

     *

     * Requirements:

     *

     * - This contract must be the admin of `proxy`.

     */

    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {

        // We need to manually run the static call since the getter cannot be flagged as view

        // bytes4(keccak256("implementation()")) == 0x5c60da1b

        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"5c60da1b");

        require(success);

        return abi.decode(returndata, (address));

    }



    /**

     * @dev Returns the current admin of `proxy`.

     *

     * Requirements:

     *

     * - This contract must be the admin of `proxy`.

     */

    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {

        // We need to manually run the static call since the getter cannot be flagged as view

        // bytes4(keccak256("admin()")) == 0xf851a440

        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"f851a440");

        require(success);

        return abi.decode(returndata, (address));

    }



    /**

     * @dev Changes the admin of `proxy` to `newAdmin`.

     *

     * Requirements:

     *

     * - This contract must be the current admin of `proxy`.

     */

    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {

        proxy.changeAdmin(newAdmin);

    }



    /**

     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.

     *

     * Requirements:

     *

     * - This contract must be the admin of `proxy`.

     */

    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {

        proxy.upgradeTo(implementation);

    }



    /**

     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See

     * {TransparentUpgradeableProxy-upgradeToAndCall}.

     *

     * Requirements:

     *

     * - This contract must be the admin of `proxy`.

     */

    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {

        proxy.upgradeToAndCall{value: msg.value}(implementation, data);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\SecuredTokenTransfer.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



/// @title SecuredTokenTransfer - Secure token transfer

/// @author Richard Meissner - <richard@gnosis.pm>

contract SecuredTokenTransfer {

    /// @dev Transfers a token and returns if it was a success

    /// @param token Token that should be transferred

    /// @param receiver Receiver to whom the token should be transferred

    /// @param amount The amount of tokens that should be transferred

    function transferToken(

        address token,

        address receiver,

        uint256 amount

    ) internal returns (bool transferred) {

        // 0xa9059cbb - keccack("transfer(address,uint256)")

        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);

        // solhint-disable-next-line no-inline-assembly

        assembly {

            // We write the return value to scratch space.

            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory

            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)

            switch returndatasize()

                case 0 {

                    transferred := success

                }

                case 0x20 {

                    transferred := iszero(or(iszero(success), iszero(mload(0))))

                }

                default {

                    transferred := 0

                }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\SelfAuthorized.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



/// @title SelfAuthorized - authorizes current contract to perform actions

/// @author Richard Meissner - <richard@gnosis.pm>

contract SelfAuthorized {

    function requireSelfCall() private view {

        require(msg.sender == address(this), "GS031");

    }



    modifier authorized() {

        // This is a function call as it minimized the bytecode size

        requireSelfCall();

        _;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\SignatureDecoder.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



/// @title SignatureDecoder - Decodes signatures that a encoded as bytes

/// @author Richard Meissner - <richard@gnosis.pm>

contract SignatureDecoder {

    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.

    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures

    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access

    /// @param signatures concatenated rsv signatures

    function signatureSplit(bytes memory signatures, uint256 pos)

        internal

        pure

        returns (

            uint8 v,

            bytes32 r,

            bytes32 s

        )

    {

        // The signature format is a compact form of:

        //   {bytes32 r}{bytes32 s}{uint8 v}

        // Compact means, uint8 is not padded to 32 bytes.

        // solhint-disable-next-line no-inline-assembly

        assembly {

            let signaturePos := mul(0x41, pos)

            r := mload(add(signatures, add(signaturePos, 0x20)))

            s := mload(add(signatures, add(signaturePos, 0x40)))

            // Here we are loading the last 32 bytes, including 31 bytes

            // of 's'. There is no 'mload8' to do this.

            //

            // 'byte' is not working due to the Solidity parser, so lets

            // use the second best option, 'and'

            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\Singleton.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



/// @title Singleton - Base for singleton contracts (should always be first super contract)

///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)

/// @author Richard Meissner - <richard@gnosis.io>

contract Singleton {

    // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.

    // It should also always be ensured that the address is stored alone (uses a full word)

    address private singleton;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\StorageAccessible.sol
File type: .sol
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity >=0.7.0 <0.9.0;



/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.

/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol

contract StorageAccessible {

    /**

     * @dev Reads `length` bytes of storage in the currents contract

     * @param offset - the offset in the current contract's storage in words to start reading from

     * @param length - the number of words (32 bytes) of data to read

     * @return the bytes that were read.

     */

    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {

        bytes memory result = new bytes(length * 32);

        for (uint256 index = 0; index < length; index++) {

            // solhint-disable-next-line no-inline-assembly

            assembly {

                let word := sload(add(offset, index))

                mstore(add(add(result, 0x20), mul(index, 0x20)), word)

            }

        }

        return result;

    }



    /**

     * @dev Performs a delegetecall on a targetContract in the context of self.

     * Internally reverts execution to avoid side effects (making it static).

     *

     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.

     * Specifically, the `returndata` after a call to this method will be:

     * `success:bool || response.length:uint256 || response:bytes`.

     *

     * @param targetContract Address of the contract containing the code to execute.

     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).

     */

    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {

        // solhint-disable-next-line no-inline-assembly

        assembly {

            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)



            mstore(0x00, success)

            mstore(0x20, returndatasize())

            returndatacopy(0x40, 0, returndatasize())

            revert(0, add(returndatasize(), 0x40))

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\StorageSlot.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Library for reading and writing primitive types to specific storage slots.

 *

 * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.

 * This library helps with reading and writing to such slots without the need for inline assembly.

 *

 * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.

 *

 * Example usage to set ERC1967 implementation slot:

 * ```

 * contract ERC1967 {

 *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

 *

 *     function _getImplementation() internal view returns (address) {

 *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

 *     }

 *

 *     function _setImplementation(address newImplementation) internal {

 *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

 *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

 *     }

 * }

 * ```

 *

 * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._

 */

library StorageSlot {

    struct AddressSlot {

        address value;

    }



    struct BooleanSlot {

        bool value;

    }



    struct Bytes32Slot {

        bytes32 value;

    }



    struct Uint256Slot {

        uint256 value;

    }



    /**

     * @dev Returns an `AddressSlot` with member `value` located at `slot`.

     */

    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.

     */

    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.

     */

    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.

     */

    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {

        assembly {

            r.slot := slot

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\TransparentUpgradeableProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../ERC1967/ERC1967Proxy.sol";



/**

 * @dev This contract implements a proxy that is upgradeable by an admin.

 *

 * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector

 * clashing], which can potentially be used in an attack, this contract uses the

 * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two

 * things that go hand in hand:

 *

 * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if

 * that call matches one of the admin functions exposed by the proxy itself.

 * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the

 * implementation. If the admin tries to call a function on the implementation it will fail with an error that says

 * "admin cannot fallback to proxy target".

 *

 * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing

 * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due

 * to sudden errors when trying to call a function from the proxy implementation.

 *

 * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,

 * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.

 */

contract TransparentUpgradeableProxy is ERC1967Proxy {

    /**

     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and

     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.

     */

    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {

        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));

        _changeAdmin(admin_);

    }



    /**

     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.

     */

    modifier ifAdmin() {

        if (msg.sender == _getAdmin()) {

            _;

        } else {

            _fallback();

        }

    }



    /**

     * @dev Returns the current admin.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.

     *

     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the

     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.

     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`

     */

    function admin() external ifAdmin returns (address admin_) {

        admin_ = _getAdmin();

    }



    /**

     * @dev Returns the current implementation.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.

     *

     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the

     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.

     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`

     */

    function implementation() external ifAdmin returns (address implementation_) {

        implementation_ = _implementation();

    }



    /**

     * @dev Changes the admin of the proxy.

     *

     * Emits an {AdminChanged} event.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.

     */

    function changeAdmin(address newAdmin) external virtual ifAdmin {

        _changeAdmin(newAdmin);

    }



    /**

     * @dev Upgrade the implementation of the proxy.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.

     */

    function upgradeTo(address newImplementation) external ifAdmin {

        _upgradeToAndCall(newImplementation, bytes(""), false);

    }



    /**

     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified

     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the

     * proxied contract.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.

     */

    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {

        _upgradeToAndCall(newImplementation, data, true);

    }



    /**

     * @dev Returns the current admin.

     */

    function _admin() internal view virtual returns (address) {

        return _getAdmin();

    }



    /**

     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.

     */

    function _beforeFallback() internal virtual override {

        require(msg.sender != _getAdmin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target");

        super._beforeFallback();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\ChainPort\contracts\UUPSUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../ERC1967/ERC1967Upgrade.sol";



/**

 * @dev Base contract for building openzeppelin-upgrades compatible implementations for the {ERC1967Proxy}. It includes

 * publicly available upgrade functions that are called by the plugin and by the secure upgrade mechanism to verify

 * continuation of the upgradability.

 *

 * The {_authorizeUpgrade} function MUST be overridden to include access restriction to the upgrade mechanism.

 *

 * _Available since v4.1._

 */

abstract contract UUPSUpgradeable is ERC1967Upgrade {

    function upgradeTo(address newImplementation) external virtual {

        _authorizeUpgrade(newImplementation);

        _upgradeToAndCallSecure(newImplementation, bytes(""), false);

    }



    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {

        _authorizeUpgrade(newImplementation);

        _upgradeToAndCallSecure(newImplementation, data, true);

    }



    function _authorizeUpgrade(address newImplementation) internal virtual;

}

--------------------------------------------------
File End
--------------------------------------------------

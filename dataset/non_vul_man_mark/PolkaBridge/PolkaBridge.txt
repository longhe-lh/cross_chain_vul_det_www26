Folder Structure
--------------------------------------------------
contracts/
    Address.sol
    Context.sol
    Counters.sol
    DistributeToken.sol
    ERC1155.sol
    ERC165.sol
    ERC20.sol
    ERC20Burnable.sol
    ERC20Detailed.sol
    IERC1155.sol
    IERC1155MetadataURI.sol
    IERC1155Receiver.sol
    IERC165.sol
    IERC20.sol
    IUniswapV2ERC20.sol
    IUniswapV2Factory.sol
    IUniswapV2Pair.sol
    IUniswapV2Router01.sol
    IUniswapV2Router02.sol
    IWETH.sol
    Math.sol
    Ownable.sol
    PolkaBridge.sol
    PolkaBridgeINO.sol
    PolkaBridgeLaunchPad.sol
    PolkabridgeLaunchPadV2.sol
    PolkaBridgeMasterFarm.sol
    PolkaBridgeNFT.sol
    PolkaBridgeStaking.sol
    PolkaBridgeTreasury.sol
    ReentrancyGuard.sol
    RewardPool.sol
    SafeERC20.sol
    SafeMath.sol
    Strings.sol
    SwapToken.sol
    TokenRelease.sol
    TransferHelper.sol
    UniswapV2ERC20.sol
    UniswapV2Factory.sol
    UniswapV2Library.sol
    UniswapV2Pair.sol
    UniswapV2Router02.sol
    UQ112x112.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\Address.sol
File type: .sol
pragma solidity ^0.6.0;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Converts an `address` into `address payable`. Note that this is

     * simply a type cast: the actual underlying value is not changed.

     *

     * _Available since v2.4.0._

     */

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     *

     * _Available since v2.4.0._

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\Context.sol
File type: .sol
pragma solidity ^0.6.0;





contract Context {

  

    constructor () internal { }



    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\Counters.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @title Counters

 * @author Matt Condon (@shrugs)

 * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number

 * of elements in a mapping, issuing ERC721 ids, or counting request ids.

 *

 * Include with `using Counters for Counters.Counter;`

 */

library Counters {

    struct Counter {

        // This variable should never be directly accessed by users of the library: interactions must be restricted to

        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add

        // this feature: see https://github.com/ethereum/solidity/issues/4637

        uint256 _value; // default: 0

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        unchecked {

            counter._value += 1;

        }

    }



    function decrement(Counter storage counter) internal {

        uint256 value = counter._value;

        require(value > 0, "Counter: decrement overflow");

        unchecked {

            counter._value = value - 1;

        }

    }



    function reset(Counter storage counter) internal {

        counter._value = 0;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\DistributeToken.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-05-25

*/



pragma solidity >=0.6.0;





interface IERC20 {

   

    function totalSupply() external view returns (uint256);



  

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);

    function transferWithoutDeflationary(address recipient, uint256 amount) external returns (bool) ;

   

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



library SafeMath {

   

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



   

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



   

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Converts an `address` into `address payable`. Note that this is

     * simply a type cast: the actual underlying value is not changed.

     *

     * _Available since v2.4.0._

     */

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     *

     * _Available since v2.4.0._

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves.



        // A Solidity high level call has three parts:

        //  1. The target address is checked to verify it contains contract code

        //  2. The call itself is made, and success asserted

        //  3. The return value is decoded, which in turn checks the size of the returned data.

        // solhint-disable-next-line max-line-length

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



contract Context {

  

    constructor () internal { }



    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal virtual {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



contract DistributeToken is Ownable {

    string public name = "PolkaBridge: Distribute Token";



    using SafeERC20 for IERC20;

    IERC20 token;



    constructor(IERC20 _tokenAddress) public {

        token = _tokenAddress;

    }



    function changeTokenContract(IERC20 tokenContract) public onlyOwner {

        token = tokenContract;

    }



    function distributeToken(

        address[] memory listUser,

        uint256[] memory listAmount

    ) public onlyOwner {

        for (uint256 i = 0; i < listUser.length; i++) {

            token.transfer(listUser[i], listAmount[i]);

        }

    }



    function distributeToken(address[] memory listUser, uint256 amount)

        public

        onlyOwner

    {

        for (uint256 i = 0; i < listUser.length; i++) {

            token.transfer(listUser[i], amount);

        }

    }



    function withdrawToken() public {

        token.transfer(owner(), token.balanceOf(address(this)));

    }



    receive() external payable {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\ERC1155.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC1155.sol";

import "./IERC1155Receiver.sol";

import "./extensions/IERC1155MetadataURI.sol";

import "../../utils/Address.sol";

import "../../utils/Context.sol";

import "../../utils/introspection/ERC165.sol";



/**

 * @dev Implementation of the basic standard multi-token.

 * See https://eips.ethereum.org/EIPS/eip-1155

 * Originally based on code by Enjin: https://github.com/enjin/erc-1155

 *

 * _Available since v3.1._

 */

contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {

    using Address for address;



    // Mapping from token ID to account balances

    mapping(uint256 => mapping(address => uint256)) private _balances;



    // Mapping from account to operator approvals

    mapping(address => mapping(address => bool)) private _operatorApprovals;



    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json

    string private _uri;



    /**

     * @dev See {_setURI}.

     */

    constructor(string memory uri_) {

        _setURI(uri_);

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {

        return

            interfaceId == type(IERC1155).interfaceId ||

            interfaceId == type(IERC1155MetadataURI).interfaceId ||

            super.supportsInterface(interfaceId);

    }



    /**

     * @dev See {IERC1155MetadataURI-uri}.

     *

     * This implementation returns the same URI for *all* token types. It relies

     * on the token type ID substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * Clients calling this function must replace the `\{id\}` substring with the

     * actual token type ID.

     */

    function uri(uint256) public view virtual override returns (string memory) {

        return _uri;

    }



    /**

     * @dev See {IERC1155-balanceOf}.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {

        require(account != address(0), "ERC1155: balance query for the zero address");

        return _balances[id][account];

    }



    /**

     * @dev See {IERC1155-balanceOfBatch}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)

        public

        view

        virtual

        override

        returns (uint256[] memory)

    {

        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");



        uint256[] memory batchBalances = new uint256[](accounts.length);



        for (uint256 i = 0; i < accounts.length; ++i) {

            batchBalances[i] = balanceOf(accounts[i], ids[i]);

        }



        return batchBalances;

    }



    /**

     * @dev See {IERC1155-setApprovalForAll}.

     */

    function setApprovalForAll(address operator, bool approved) public virtual override {

        require(_msgSender() != operator, "ERC1155: setting approval status for self");



        _operatorApprovals[_msgSender()][operator] = approved;

        emit ApprovalForAll(_msgSender(), operator, approved);

    }



    /**

     * @dev See {IERC1155-isApprovedForAll}.

     */

    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {

        return _operatorApprovals[account][operator];

    }



    /**

     * @dev See {IERC1155-safeTransferFrom}.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) public virtual override {

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: caller is not owner nor approved"

        );

        _safeTransferFrom(from, to, id, amount, data);

    }



    /**

     * @dev See {IERC1155-safeBatchTransferFrom}.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) public virtual override {

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: transfer caller is not owner nor approved"

        );

        _safeBatchTransferFrom(from, to, ids, amounts, data);

    }



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function _safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: transfer to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);



        uint256 fromBalance = _balances[id][from];

        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");

        unchecked {

            _balances[id][from] = fromBalance - amount;

        }

        _balances[id][to] += amount;



        emit TransferSingle(operator, from, to, id, amount);



        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function _safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        require(to != address(0), "ERC1155: transfer to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; ++i) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 fromBalance = _balances[id][from];

            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");

            unchecked {

                _balances[id][from] = fromBalance - amount;

            }

            _balances[id][to] += amount;

        }



        emit TransferBatch(operator, from, to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);

    }



    /**

     * @dev Sets a new URI for all token types, by relying on the token type ID

     * substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * By this mechanism, any occurrence of the `\{id\}` substring in either the

     * URI or any of the amounts in the JSON file at said URI will be replaced by

     * clients with the token type ID.

     *

     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be

     * interpreted by clients as

     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`

     * for token type ID 0x4cce0.

     *

     * See {uri}.

     *

     * Because these URIs cannot be meaningfully represented by the {URI} event,

     * this function emits no events.

     */

    function _setURI(string memory newuri) internal virtual {

        _uri = newuri;

    }



    /**

     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function _mint(

        address account,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        require(account != address(0), "ERC1155: mint to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);



        _balances[id][account] += amount;

        emit TransferSingle(operator, address(0), account, id, amount);



        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function _mintBatch(

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: mint to the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; i++) {

            _balances[ids[i]][to] += amounts[i];

        }



        emit TransferBatch(operator, address(0), to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);

    }



    /**

     * @dev Destroys `amount` tokens of token type `id` from `account`

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens of token type `id`.

     */

    function _burn(

        address account,

        uint256 id,

        uint256 amount

    ) internal virtual {

        require(account != address(0), "ERC1155: burn from the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");



        uint256 accountBalance = _balances[id][account];

        require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");

        unchecked {

            _balances[id][account] = accountBalance - amount;

        }



        emit TransferSingle(operator, account, address(0), id, amount);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     */

    function _burnBatch(

        address account,

        uint256[] memory ids,

        uint256[] memory amounts

    ) internal virtual {

        require(account != address(0), "ERC1155: burn from the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, account, address(0), ids, amounts, "");



        for (uint256 i = 0; i < ids.length; i++) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 accountBalance = _balances[id][account];

            require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");

            unchecked {

                _balances[id][account] = accountBalance - amount;

            }

        }



        emit TransferBatch(operator, account, address(0), ids, amounts);

    }



    /**

     * @dev Hook that is called before any token transfer. This includes minting

     * and burning, as well as batched variants.

     *

     * The same hook is called on both single and batched variants. For single

     * transfers, the length of the `id` and `amount` arrays will be 1.

     *

     * Calling conditions (for each `id` and `amount` pair):

     *

     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * of token type `id` will be  transferred to `to`.

     * - When `from` is zero, `amount` tokens of token type `id` will be minted

     * for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`

     * will be burned.

     * - `from` and `to` are never both zero.

     * - `ids` and `amounts` have the same, non-zero length.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    function _doSafeTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {

                if (response != IERC1155Receiver.onERC1155Received.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _doSafeBatchTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (

                bytes4 response

            ) {

                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {

        uint256[] memory array = new uint256[](1);

        array[0] = element;



        return array;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\ERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "./IERC165.sol";



/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check

 * for the additional interface id that will be supported. For example:

 *

 * ```solidity

 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);

 * }

 * ```

 *

 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.

 */

abstract contract ERC165 is IERC165 {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IERC165).interfaceId;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\ERC20.sol
File type: .sol
pragma solidity ^0.6.0;



import "../../GSN/Context.sol";

import "./IERC20.sol";

import "../../math/SafeMath.sol";



contract ERC20 is Context, IERC20 {

    using SafeMath for uint256;



    struct PoolAddress{

        address poolReward;

        bool isActive;

        bool isExist;



    }



    struct WhitelistTransfer{

        address waddress;

        bool isActived;

        string name;



    }

    mapping (address => uint256) private _balances;



    mapping (address => WhitelistTransfer) public whitelistTransfer;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;

    address[] rewardPool;

    mapping(address=>PoolAddress) mapRewardPool;

   

    address internal tokenOwner;

    uint256 internal beginFarming;



    function addRewardPool(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        require(!mapRewardPool[add].isExist,"Pool already exist");

        mapRewardPool[add].poolReward=add;

        mapRewardPool[add].isActive=true;

        mapRewardPool[add].isExist=true;

        rewardPool.push(add);

    }



    function addWhitelistTransfer(address add, string memory name) public{

         require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

         whitelistTransfer[add].waddress=add;

        whitelistTransfer[add].isActived=true;

        whitelistTransfer[add].name=name;



    }



     function removeWhitelistTransfer(address add) public{

         require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        

        whitelistTransfer[add].isActived=false;

        



    }







    function removeRewardPool(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        mapRewardPool[add].isActive=false;

       

        

    }



    function countActiveRewardPool() public  view returns (uint256){

        uint length=0;

     for(uint i=0;i<rewardPool.length;i++){

         if(mapRewardPool[rewardPool[i]].isActive){

             length++;

         }

     }

      return  length;

    }

   function getRewardPool(uint index) public view  returns (address){

    

        return rewardPool[index];

    }



   

    

    function totalSupply() public view override returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



   

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        if(whitelistTransfer[recipient].isActived || whitelistTransfer[_msgSender()].isActived){//withdraw from exchange will not effect

            _transferWithoutDeflationary(_msgSender(), recipient, amount);

        }

        else{

            _transfer(_msgSender(), recipient, amount);

        }

        

        return true;

    }

 function transferWithoutDeflationary(address recipient, uint256 amount) public virtual override returns (bool) {

        _transferWithoutDeflationary(_msgSender(), recipient, amount);

        return true;

    }

    

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



 

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



 

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



   

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



   

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);

        uint256 burnAmount;

        uint256 rewardAmount;

         uint totalActivePool=countActiveRewardPool();

         if (block.timestamp > beginFarming && totalActivePool>0) {

            (burnAmount,rewardAmount)=_caculateExtractAmount(amount);



        }     

        //div reward

        if(rewardAmount>0){

           

            uint eachPoolShare=rewardAmount.div(totalActivePool);

            for(uint i=0;i<rewardPool.length;i++){

                 if(mapRewardPool[rewardPool[i]].isActive){

                    _balances[rewardPool[i]] = _balances[rewardPool[i]].add(eachPoolShare);

                    emit Transfer(sender, rewardPool[i], eachPoolShare);



                 }

                

       

            }

        }





        //burn token

        if(burnAmount>0){

          _burn(sender,burnAmount);

            _balances[sender] = _balances[sender].add(burnAmount);//because sender balance already sub in burn



        }

      

        

        uint256 newAmount=amount-burnAmount-rewardAmount;



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

      

        _balances[recipient] = _balances[recipient].add(newAmount);

        emit Transfer(sender, recipient, newAmount);



        

        

    }

    

 function _transferWithoutDeflationary(address sender, address recipient, uint256 amount) internal virtual {

          require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

        

    }

    

    function _deploy(address account, uint256 amount,uint256 beginFarmingDate) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");

        tokenOwner = account;

        beginFarming=beginFarmingDate;



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal virtual {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }



    

    function _caculateExtractAmount(uint256 amount)

        internal

        

        returns (uint256, uint256)

    {

       

            uint256 extractAmount = (amount * 5) / 1000;



            uint256 burnAmount = (extractAmount * 10) / 100;

            uint256 rewardAmount = (extractAmount * 90) / 100;



            return (burnAmount, rewardAmount);

      

    }



    function setBeginDeflationFarming(uint256 beginDate) public {

        require(msg.sender == tokenOwner, "ERC20: Only owner can call");

        beginFarming = beginDate;

    }



    function getBeginDeflationary() public view returns (uint256) {

        return beginFarming;

    }



    



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\ERC20Burnable.sol
File type: .sol
pragma solidity ^0.6.0;



import "../../GSN/Context.sol";

import "./ERC20.sol";





contract ERC20Burnable is Context, ERC20 {

    

    function burn(uint256 amount) public virtual {

        _burn(_msgSender(), amount);

    }



  

    function burnFrom(address account, uint256 amount) public virtual {

        _burnFrom(account, amount);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\ERC20Detailed.sol
File type: .sol
pragma solidity ^0.6.0;



import "./IERC20.sol";





abstract contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;





    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



   

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IERC1155.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../../utils/introspection/IERC165.sol";



/**

 * @dev Required interface of an ERC1155 compliant contract, as defined in the

 * https://eips.ethereum.org/EIPS/eip-1155[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155 is IERC165 {

    /**

     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.

     */

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);



    /**

     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all

     * transfers.

     */

    event TransferBatch(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256[] ids,

        uint256[] values

    );



    /**

     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to

     * `approved`.

     */

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);



    /**

     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.

     *

     * If an {URI} event was emitted for `id`, the standard

     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value

     * returned by {IERC1155MetadataURI-uri}.

     */

    event URI(string value, uint256 indexed id);



    /**

     * @dev Returns the amount of tokens of token type `id` owned by `account`.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) external view returns (uint256);



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)

        external

        view

        returns (uint256[] memory);



    /**

     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,

     *

     * Emits an {ApprovalForAll} event.

     *

     * Requirements:

     *

     * - `operator` cannot be the caller.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.

     *

     * See {setApprovalForAll}.

     */

    function isApprovedForAll(address account, address operator) external view returns (bool);



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes calldata data

    ) external;



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IERC1155MetadataURI.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../IERC1155.sol";



/**

 * @dev Interface of the optional ERC1155MetadataExtension interface, as defined

 * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155MetadataURI is IERC1155 {

    /**

     * @dev Returns the URI for token type `id`.

     *

     * If the `\{id\}` substring is present in the URI, it must be replaced by

     * clients with the actual token type ID.

     */

    function uri(uint256 id) external view returns (string memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IERC1155Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



import "../../utils/introspection/IERC165.sol";



/**

 * @dev _Available since v3.1._

 */

interface IERC1155Receiver is IERC165 {

    /**

        @dev Handles the receipt of a single ERC1155 token type. This function is

        called at the end of a `safeTransferFrom` after the balance has been updated.

        To accept the transfer, this must return

        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

        (i.e. 0xf23a6e61, or its own function selector).

        @param operator The address which initiated the transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param id The ID of the token being transferred

        @param value The amount of tokens being transferred

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed

    */

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    ) external returns (bytes4);



    /**

        @dev Handles the receipt of a multiple ERC1155 token types. This function

        is called at the end of a `safeBatchTransferFrom` after the balances have

        been updated. To accept the transfer(s), this must return

        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

        (i.e. 0xbc197c81, or its own function selector).

        @param operator The address which initiated the batch transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param ids An array containing ids of each token being transferred (order and length must match values array)

        @param values An array containing amounts of each token being transferred (order and length must match ids array)

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed

    */

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    ) external returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IERC20.sol
File type: .sol
pragma solidity ^0.6.0;





interface IERC20 {

   

    function totalSupply() external view returns (uint256);



  

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);

   

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IUniswapV2ERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;



interface IUniswapV2ERC20 {

    event Approval(address indexed owner, address indexed spender, uint value);

    event Transfer(address indexed from, address indexed to, uint value);



    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint);

    function balanceOf(address owner) external view returns (uint);

    function allowance(address owner, address spender) external view returns (uint);



    function approve(address spender, uint value) external returns (bool);

    function transfer(address to, uint value) external returns (bool);

    function transferFrom(address from, address to, uint value) external returns (bool);



    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint);



    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IUniswapV2Factory.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;



interface IUniswapV2Factory {



    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    event TreasurySet(address _address);

    



    function setTreasuryAddress(address _address) external;

    

    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs() external view returns (uint);

    // function allPairsLength() external view returns (uint);



    function createPair(address tokenA, address tokenB) external returns (address pair);



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IUniswapV2Pair.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;



import './IUniswapV2ERC20.sol';



interface IUniswapV2Pair is IUniswapV2ERC20 {

    event Mint(address indexed sender, uint amount0, uint amount1);

    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);

    // event BurnETH(address indexed sender, uint amount0, uint amount1, address indexed to, address indexed to1);

    event Swap(

        address indexed sender,

        uint amount0In,

        uint amount1In,

        uint amount0Out,

        uint amount1Out,

        address indexed to

    );

    event Sync(uint112 reserve0, uint112 reserve1);

    // event TreasurySet(address _address);



    // function setTreasuryAddress(address _address) external;



    // function MINIMUM_LIQUIDITY() external pure returns (uint);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

    function price0CumulativeLast() external view returns (uint);

    function price1CumulativeLast() external view returns (uint);

    // function kLast() external view returns (uint);



    function mint(address to) external returns (uint liquidity);

    function burn(address to) external returns (uint amount0, uint amount1);

    // function burnETH(address to, address to1) external returns (uint amount0, uint amount1);

    function swap(uint amount0Out, uint amount1Out, address to) external;

    // function skim(address to) external;

    function sync() external;    

    function initialize(address, address, address) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IUniswapV2Router01.sol
File type: .sol
pragma solidity >=0.6.2;



interface IUniswapV2Router01 {

    function factory() external pure returns (address);

    function WETH() external pure returns (address);



    function addLiquidity(

        address tokenA,

        address tokenB,

        uint amountADesired,

        uint amountBDesired,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline

    ) external returns (uint amountA, uint amountB, uint liquidity);

    function addLiquidityETH(

        address token,

        uint amountTokenDesired,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidity(

        address tokenA,

        address tokenB,

        uint liquidity,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline

    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETH(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external returns (uint amountToken, uint amountETH);

    // function removeLiquidityWithPermit(

    //     address tokenA,

    //     address tokenB,

    //     uint liquidity,

    //     uint amountAMin,

    //     uint amountBMin,

    //     address to,

    //     uint deadline,

    //     bool approveMax, uint8 v, bytes32 r, bytes32 s

    // ) external returns (uint amountA, uint amountB);

    // function removeLiquidityETHWithPermit(

    //     address token,

    //     uint liquidity,

    //     uint amountTokenMin,

    //     uint amountETHMin,

    //     address to,

    //     uint deadline,

    //     bool approveMax, uint8 v, bytes32 r, bytes32 s

    // ) external returns (uint amountToken, uint amountETH);

    function swapExactTokensForTokens(

        uint amountIn,

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external;// returns (uint[] memory amounts);

    function swapTokensForExactTokens(

        uint amountOut,

        uint amountInMax,

        address[] calldata path,

        address to,

        uint deadline

    ) external returns (uint[] memory amounts);

    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)

        external

        payable;

        // returns (uint[] memory amounts);

    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)

        external

        returns (uint[] memory amounts);

    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)

        external;

        // returns (uint[] memory amounts);

    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)

        external

        payable

        returns (uint[] memory amounts);



    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);

    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);

    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IUniswapV2Router02.sol
File type: .sol
pragma solidity >=0.6.2;



import './IUniswapV2Router01.sol';



interface IUniswapV2Router02 is IUniswapV2Router01 {

    // function removeLiquidityETHSupportingFeeOnTransferTokens(

    //     address token,

    //     uint liquidity,

    //     uint amountTokenMin,

    //     uint amountETHMin,

    //     address to,

    //     uint deadline

    // ) external returns (uint amountETH);

    // function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(

    //     address token,

    //     uint liquidity,

    //     uint amountTokenMin,

    //     uint amountETHMin,

    //     address to,

    //     uint deadline,

    //     bool approveMax, uint8 v, bytes32 r, bytes32 s

    // ) external returns (uint amountETH);



    // function swapExactTokensForTokensSupportingFeeOnTransferTokens(

    //     uint amountIn,

    //     uint amountOutMin,

    //     address[] calldata path,

    //     address to,

    //     uint deadline

    // ) external;

    // function swapExactETHForTokensSupportingFeeOnTransferTokens(

    //     uint amountOutMin,

    //     address[] calldata path,

    //     address to,

    //     uint deadline

    // ) external payable;

    // function swapExactTokensForETHSupportingFeeOnTransferTokens(

    //     uint amountIn,

    //     uint amountOutMin,

    //     address[] calldata path,

    //     address to,

    //     uint deadline

    // ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\IWETH.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



interface IWETH {

    function deposit() external payable;

    function transfer(address to, uint value) external returns (bool);

    function withdraw(uint) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\Math.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;



// a library for performing various math operations



library Math {

    function min(uint x, uint y) internal pure returns (uint z) {

        z = x < y ? x : y;

    }



    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)

    function sqrt(uint y) internal pure returns (uint z) {

        if (y > 3) {

            z = y;

            uint x = y / 2 + 1;

            while (x < z) {

                z = x;

                x = (y / x + x) / 2;

            }

        } else if (y != 0) {

            z = 1;

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\Ownable.sol
File type: .sol
pragma solidity ^0.6.0;



import "../GSN/Context.sol";

/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address  private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal virtual {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\PolkaBridge.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-01-22

*/



pragma solidity >=0.6.0;





contract Context {

  

    constructor () internal { }



    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



interface IERC20 {

   

    function totalSupply() external view returns (uint256);



  

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



   

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



library SafeMath {

   

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



   

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



   

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract ERC20 is Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;

    address private rewardPool;

    address private burnPool;

    address private tokenOwner;



    function initRewardContract(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        rewardPool=add;

    }

    function initBurnContract(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        burnPool=add;

    }

    

    function totalSupply() public view override returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



   

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



 

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



 

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



   

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



   

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);

        uint256 burnAmount;

        uint256 rewardAmount;

        (burnAmount,rewardAmount)=_caculateExtractAmount(amount);



        _balances[rewardPool] = _balances[rewardPool].add(rewardAmount);

        _balances[burnPool] = _balances[burnPool].add(burnAmount);



        

        uint256 newAmount=amount-burnAmount-rewardAmount;





        _balances[sender] = _balances[sender].sub(newAmount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(newAmount);

        emit Transfer(sender, recipient, newAmount);

    }



    

    function _deploy(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");

        tokenOwner = account;



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal virtual {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }



    function _caculateExtractAmount(uint256 amount) internal virtual returns(uint256,uint256) { }

}



contract ERC20Burnable is Context, ERC20 {

    

    function burn(uint256 amount) public virtual {

        _burn(_msgSender(), amount);

    }



  

    function burnFrom(address account, uint256 amount) public virtual {

        _burnFrom(account, amount);

    }

}



abstract contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;





    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



   

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}



contract PolkaBridge is ERC20, ERC20Detailed, ERC20Burnable {

    uint256 BeginExtract;



    constructor(uint256 initialSupply)

        public

        ERC20Detailed("PolkaBridge", "PBR", 18)

    {

        _deploy(msg.sender, initialSupply);

        BeginExtract = 1615766400; //15 Mar 2021 1615766400

    }



    function _caculateExtractAmount(uint256 amount)

        internal

        override

        returns (uint256, uint256)

    {

        if (block.timestamp > BeginExtract) {

            uint256 extractAmount = (amount * 5) / 1000;



            uint256 burnAmount = (extractAmount * 10) / 100;

            uint256 rewardAmount = (extractAmount * 90) / 100;



            return (burnAmount, rewardAmount);

        } else {

            return (0, 0);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\PolkaBridgeINO.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

import "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";

// import "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";

import "@openzeppelin/contracts/utils/Counters.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "@openzeppelin/contracts/utils/Strings.sol";

import "./lib/IWETH.sol";

import "./lib/IERC20.sol";

import "./ReentrancyGuard.sol";

import "./PolkaBridgeNFT.sol";



contract PolkaBridgeINO is Ownable, ReentrancyGuard, IERC1155Receiver {

    string public name = "PolkaBridge: INO";

    using SafeMath for uint256;

    using Strings for uint256;

    using Counters for Counters.Counter;

    address public immutable WETH;

    address payable Owner;

    // address payable private ReceiveToken;

    Counters.Counter private tokenCounter;

    PolkaBridgeNFT public polkaBridgeNFT;

   



    constructor(

        // address payable _receiveToken,

        PolkaBridgeNFT _polkaBridgeNFT,

        address payable _owner,

        address _WETH

    ) 

    {

        // ReceiveToken = _receiveToken;

        Owner = payable(_owner);

        WETH = _WETH;



        polkaBridgeNFT = _polkaBridgeNFT;





    }



    receive() external payable {}



    // Pool for INO

    struct INOPool {

        uint256 Id;

        uint256 Begin;

        uint256 End;

        uint256 Type; // 1:public, 2:private

        uint256 AmountPBRRequire; //must e18,important when init

        uint256 LockDuration; //lock after purchase

        uint256 ActivedDate;

        uint256 StopDate;

        uint256 claimType; // 1: claim in PBR INO, 2: claim in other project

        bool IsActived;

        bool IsStopped;

        uint256[] PackageIds;

    }

    // Package

    struct Package {

        uint256 Id;

        uint256 PoolId;

        uint256 TotalSoldCount;

        uint256 MinimumTokenSoldout;

        uint256 TotalItemCount;

        uint256 RatePerETH; // times 1e18

        address[] UsersPurchased;

    }

    // User

    struct User {

        uint256 Id;

        bool IsWhitelist;

        uint256 WhitelistDate;

        uint256 PurchaseTime;

        bool IsClaimed;

        uint256 TotalETHPurchase;

        uint256 PurchasedItemCount;

        uint256[] PurchasedPackageIds;

    }

    mapping(uint256 => mapping(address => User)) public whitelist; // (packageId, userId) -> listuser

    mapping(uint256 => mapping(address => bool)) public purchasecheck; // (packageId, userId) -> purchasecheck

    mapping(address => mapping(uint256 => User)) private users; // (userId, poolId) -> user

    INOPool[] pools;

    Package[] packages;



    // function setURI(string memory uri_) external onlyOwner {

    //     _setURI(uri_);

    // }

    function changeOwner(address payable _owner) external onlyOwner {

        Owner = payable(_owner);

    }



    // function setURI(string memory _uri) external onlyOwner {

    //     polkaBridgeNFT.setURI(_uri);

    // }



    // function getURI(uint256 _id) external view returns(string memory) {

    //     return polkaBridgeNFT.uri(_id);

    // }



    function poolLength() external view returns (uint256) {

        return pools.length;

    }



    function packageLength() external view returns (uint256) {

        return packages.length;

    }



    // Add Whitelist function

    function addWhitelist(address user, uint256 pid) public onlyOwner {

        uint256 poolIndex = pid.sub(1);

        uint256[] memory packageIds = pools[poolIndex].PackageIds;

        uint256 packagesLength = packageIds.length;

        for (uint256 i = 0; i < packagesLength; i++) {

            uint256 packageId = packageIds[i];

            whitelist[packageId][user].Id = pid;

            whitelist[packageId][user].IsWhitelist = true;

            whitelist[packageId][user].WhitelistDate = block.timestamp;

        }

    }



    // Add Multiple Whitelist function

    function addMulWhitelist(address[] memory user, uint256 pid)

        public

        onlyOwner

    {

        uint256 poolIndex = pid.sub(1);

        uint256[] memory packageIds = pools[poolIndex].PackageIds;

        uint256 packagesLength = packageIds.length;

        for (uint256 i = 0; i < user.length; i++) {

            for (uint256 j = 0; j < packagesLength; j++) {

                uint256 packageId = packageIds[j];

                whitelist[packageId][user[i]].Id = pid;

                whitelist[packageId][user[i]].IsWhitelist = true;

                whitelist[packageId][user[i]].WhitelistDate = block.timestamp;

            }

        }

    }



    // Update existing user whitelist condition

    function updateWhitelist(

        address user,

        uint256 pid,

        bool isWhitelist

    ) public onlyOwner {

        uint256 poolIndex = pid.sub(1);

        uint256[] memory packageIds = pools[poolIndex].PackageIds;

        uint256 packagesLength = packageIds.length;

        for (uint256 i = 0; i < packagesLength; i++) {

            uint256 packageId = packageIds[i];

            whitelist[packageId][user].IsWhitelist = isWhitelist;

        }

    }



    // Check if user IsWhitelist

    function IsWhitelist(address user, uint256 pid) public view returns (bool) {

        uint256 poolIndex = pid.sub(1);

        uint256[] memory packageIds = pools[poolIndex].PackageIds;

        return whitelist[packageIds[0]][user].IsWhitelist;

    }



    //Add package to pool

    function addPackageToPool(

        uint256 _PoolId,

        uint256 _MinimumTokenSoldout,

        uint256 _TotalItemCount,

        uint256 _RatePerETH

    ) public onlyOwner {

        uint256 id = packages.length.add(1);

        packages.push(

            Package({

                Id: id,

                PoolId: _PoolId,

                TotalSoldCount: 0,

                MinimumTokenSoldout: _MinimumTokenSoldout,

                TotalItemCount: _TotalItemCount,

                RatePerETH: _RatePerETH,

                UsersPurchased: new address[](0)

            })

        );

        uint256 poolIndex = _PoolId.sub(1);

        pools[poolIndex].PackageIds.push(id);

    }



    //Add Pool

    function addPool(

        uint256 _Begin,

        uint256 _End,

        uint256 _Type, //1:public, 2:private

        uint256 _AmountPBRRequire, //must e18,important when init

        uint256 _LockDuration, //lock after purchase

        uint256 _claimType

    ) public onlyOwner {

        pools.push(

            INOPool({

                Id: pools.length.add(1),

                Begin: _Begin,

                End: _End,

                Type: _Type, //1:public, 2:private

                AmountPBRRequire: _AmountPBRRequire, //must e18,important when init

                LockDuration: _LockDuration, //lock after purchase

                ActivedDate: 0,

                StopDate: 0,

                IsActived: true,

                IsStopped: false,

                claimType: _claimType,

                PackageIds: new uint256[](0)

            })

        );

    }



    // Update the pool

    function updatePool(

        uint256 pid,

        uint256 _Begin,

        uint256 _End,

        uint256 _Type,

        uint256 _AmountPBRRequire,

        uint256 _LockDuration,

        uint256 _claimType

    ) public onlyOwner {

        // require(_claimType == 1 || _claimType == 2, "invalid claim type");

        uint256 poolIndex = pid.sub(1);

        pools[poolIndex].claimType = _claimType;

        if (_Begin > 0) {

            pools[poolIndex].Begin = _Begin;

        }

        if (_End > 0) {

            pools[poolIndex].End = _End;

        }

        if (_Type > 0) {

            pools[poolIndex].Type = _Type;

        }

        if (_AmountPBRRequire > 0) {

            pools[poolIndex].AmountPBRRequire = _AmountPBRRequire;

        }

        if (_LockDuration > 0) {

            pools[poolIndex].LockDuration = _LockDuration;

        }

    }



    // Stopping the pool

    function stopPool(uint256 pid) public onlyOwner {

        uint256 poolIndex = pid.sub(1);

        pools[poolIndex].IsActived = false;

        pools[poolIndex].IsStopped = true;

        pools[poolIndex].StopDate = block.timestamp;

    }



    // Activating the pool

    function activePool(uint256 pid) public onlyOwner {

        uint256 poolIndex = pid.sub(1);

        pools[poolIndex].IsActived = true;

        pools[poolIndex].IsStopped = false;

        pools[poolIndex].ActivedDate = block.timestamp;

        pools[poolIndex].StopDate = 0;

    }



    //Update package

    function updatePackage(

        uint256 _PackageId,

        uint256 _PoolId,

        uint256 _MinimumTokenSoldout,

        uint256 _TotalItemCount,

        uint256 _RatePerETH

    ) public onlyOwner {

        uint256 packageIndex = _PackageId.sub(1);

        packages[packageIndex].PoolId = _PoolId;

        if (_MinimumTokenSoldout > 0) {

            packages[packageIndex].MinimumTokenSoldout = _MinimumTokenSoldout;

        }

        if (_TotalItemCount > 0) {

            packages[packageIndex].TotalItemCount = _TotalItemCount;

        }

        if (_RatePerETH > 0) {

            packages[packageIndex].RatePerETH = _RatePerETH;

        }

    }



    function getBalanceItemByPackageId(uint256 packageId)

        public

        view

        returns (uint256)

    {

        uint256 packageIndex = packageId.sub(1);

        return packages[packageIndex].TotalItemCount;

    }



    function getRemainINOToken(uint256 packageId)

        public

        view

        returns (uint256)

    {

        uint256 packageIndex = packageId.sub(1);

        return

            packages[packageIndex].TotalItemCount.sub(

                packages[packageIndex].TotalSoldCount

            );

    }



    // To Do: Purchase function

    function purchaseINO(uint256 packageId, uint256 quantity)

        public

        payable

        nonReentrant

    {

        uint256 packageIndex = packageId.sub(1);

        uint256 poolId = packages[packageIndex].PoolId;

        uint256 poolIndex = poolId.sub(1);

        require(pools[poolIndex].IsActived, "invalid pool");

        require(

            block.timestamp >= pools[poolIndex].Begin &&

                block.timestamp <= pools[poolIndex].End,

            "invalid time"

        );

        // check user

        if (pools[poolIndex].Type == 2)

            //private

            require(IsWhitelist(msg.sender, poolId), "invalid user");

        // check eth

        uint256 ethAmount = msg.value;

        uint256 calcItemAmount = ethAmount

            .mul(packages[packageIndex].RatePerETH)

            .div(1e18);

        require(calcItemAmount >= quantity, "insufficient funds");

        uint256 restETH;

        if (calcItemAmount > quantity)

            restETH =

                ethAmount -

                quantity

                    .mul(uint256(1).div(packages[packageIndex].RatePerETH))

                    .mul(1e18);

        // check remained token

        uint256 remainToken = getRemainINOToken(packageId);

        require(

            remainToken > packages[packageIndex].MinimumTokenSoldout,

            "INO sold out"

        );

        require(remainToken >= quantity, "INO sold out");

        whitelist[packageId][msg.sender].TotalETHPurchase = whitelist[

            packageId

        ][msg.sender].TotalETHPurchase.add(ethAmount);

        whitelist[packageId][msg.sender].PurchasedItemCount = whitelist[

            packageId

        ][msg.sender].PurchasedItemCount.add(quantity);

        whitelist[packageId][msg.sender].PurchaseTime = block.timestamp;

        if (!purchasecheck[packageId][msg.sender]) {

            packages[packageIndex].UsersPurchased.push(msg.sender);

            purchasecheck[packageId][msg.sender] = true;

            users[msg.sender][poolId].PurchasedPackageIds.push(packageId);

        }

        packages[packageIndex].TotalSoldCount = packages[packageIndex]

            .TotalSoldCount

            .add(quantity);

        IWETH(WETH).deposit{value: ethAmount}();

        IWETH(WETH).withdraw(restETH);

        payable(msg.sender).transfer(restETH);

    }



    // To Do: Claim Pool

    function claimPool(uint256 pid) public nonReentrant {

        uint256 poolIndex = pid.sub(1);

        //check user

        require(pools[poolIndex].claimType == 1, "invalid claim");

        if (pools[poolIndex].Type == 2)

            //private

            require(IsWhitelist(msg.sender, pid), "invalid user");

        require(

            block.timestamp >

                pools[poolIndex].End.add(pools[poolIndex].LockDuration),

            "not on time for claiming NFTs"

        );

        uint256[] memory packageIds = users[msg.sender][pid]

            .PurchasedPackageIds;

        uint256 packagesLength = packageIds.length;

        require(

            !whitelist[packageIds[0]][msg.sender].IsClaimed,

            "user already claimed"

        );

        for (uint256 i = 0; i < packagesLength; i++) {

            uint256 packageId = packageIds[i];

            if (purchasecheck[packageId][msg.sender]) {

                uint256 itemCount = whitelist[packageId][msg.sender]

                    .PurchasedItemCount;

                // _mint(msg.sender, packageId, itemCount, '');

                // polkaBridgeNFT.mintNFT(msg.sender, packageId, itemCount);

                IERC1155(polkaBridgeNFT).safeTransferFrom(

                    address(this),

                    msg.sender,

                    packageId,

                    itemCount,

                    ""

                );

                whitelist[packageId][msg.sender].IsClaimed = true;

            }

        }

    }



    function onERC1155Received(

        address,

        address,

        uint256,

        uint256,

        bytes memory

    ) public virtual override returns (bytes4) {

        return this.onERC1155Received.selector;

    }



    function onERC1155BatchReceived(

        address,

        address,

        uint256[] memory,

        uint256[] memory,

        bytes memory

    ) public virtual override returns (bytes4) {

        return this.onERC1155BatchReceived.selector;

    }



    function onERC721Received(

        address,

        address,

        uint256,

        bytes memory

    ) public virtual returns (bytes4) {

        return this.onERC721Received.selector;

    }



    function supportsInterface(bytes4 interfaceId)

        external

        pure

        override

        returns (bool)

    {

        return interfaceId == this.supportsInterface.selector;

    }



    function getPoolInfo(uint256 pid)

        public

        view

        returns (INOPool memory retSt)

    {

        uint256 poolIndex = pid.sub(1);

        return pools[poolIndex];

    }



    function getPackageInfo(uint256 packageId)

        public

        view

        returns (Package memory retSt)

    {

        uint256 packageIndex = packageId.sub(1);

        return packages[packageIndex];

    }



    function getPurchasedPackageIds(address user_, uint256 pid)

        public

        view

        returns (uint256[] memory)

    {

        return users[user_][pid].PurchasedPackageIds;

    }



    //withdraw ETH after INO

    function withdrawPoolFund() public onlyOwner {

        uint256 ETHbalance = IERC20(WETH).balanceOf(address(this));

        // IWETH(WETH).transfer(Owner, ETHbalance);

        IWETH(WETH).withdraw(ETHbalance);

        Owner.transfer(ETHbalance);

    }



    //withdraw ETH after IDO

    function withdrawETHFund() public onlyOwner {

        uint256 balance = address(this).balance;

        require(balance > 0, "not enough fund");

        Owner.transfer(balance);

    }



    function withdrawErc20(IERC20 token) public {

        token.transfer(Owner, token.balanceOf(address(this)));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\PolkaBridgeLaunchPad.sol
File type: .sol
pragma solidity >=0.6.0;



import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

import "@openzeppelin/contracts/math/SafeMath.sol";

import "@openzeppelin/contracts/ownership/Ownable.sol";

import "./ReentrancyGuard.sol";



contract PolkaBridgeLaunchPad is Ownable, ReentrancyGuard {

    string public name = "PolkaBridge: LaunchPad v2";

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    IERC20 polkaBridgeToken;



    address payable private ReceiveToken;



    struct IDOPool {

        uint256 Id;

        uint256 Begin;

        uint256 End;

        uint256 Type; //1:public, 2:private

        uint256 AmountPBRRequire; //must e18,important when init

        IERC20 IDOToken;

        uint256 MinPurchase;

        uint256 MaxPurchase;

        uint256 TotalCap;

        uint256 MinimumTokenSoldout;

        uint256 TotalToken; //total sale token for this pool

        uint256 RatePerETH;

        bool IsActived;

        bool IsStoped;

        uint256 ActivedDate;

        uint256 StopDate;

        uint256 LockDuration; //lock after purchase

        uint256 TotalSold; //total number of token sold

    }



    struct User {

        uint256 Id;

        address UserAddress;

        bool IsWhitelist;

        uint256 WhitelistDate;

        uint256 TotalTokenPurchase;

        uint256 TotalETHPurchase;

        uint256 PurchaseTime;

        bool IsActived;

        bool IsClaimed;

    }



    mapping(uint256 => mapping(address => User)) public whitelist; //poolid - listuser



    IDOPool[] pools;



    constructor(address payable receiveTokenAdd, IERC20 polkaBridge) public {

        ReceiveToken = receiveTokenAdd;

        polkaBridgeToken = polkaBridge;

    }



    function addWhitelist(address user, uint256 pid) public onlyOwner {

        whitelist[pid][user].Id = pid;

        whitelist[pid][user].UserAddress = user;

        whitelist[pid][user].IsWhitelist = true;

        whitelist[pid][user].WhitelistDate = block.timestamp;

        whitelist[pid][user].IsActived = true;

    }



    function addMulWhitelist(address[] memory user, uint256 pid)

        public

        onlyOwner

    {

        for (uint256 i = 0; i < user.length; i++) {

            whitelist[pid][user[i]].Id = pid;

            whitelist[pid][user[i]].UserAddress = user[i];

            whitelist[pid][user[i]].IsWhitelist = true;

            whitelist[pid][user[i]].WhitelistDate = block.timestamp;

            whitelist[pid][user[i]].IsActived = true;

        }

    }



    function updateWhitelist(

        address user,

        uint256 pid,

        bool isWhitelist,

        bool isActived

    ) public onlyOwner {

        whitelist[pid][user].IsWhitelist = isWhitelist;

        whitelist[pid][user].IsActived = isActived;

    }



    function IsWhitelist(address user, uint256 pid) public view returns (bool) {

        return whitelist[pid][user].IsWhitelist;

    }



    function addPool(

        uint256 begin,

        uint256 end,

        uint256 _type,

        IERC20 idoToken,

        uint256 minPurchase,

        uint256 maxPurchase,

        uint256 totalCap,

        uint256 totalToken,

        uint256 amountPBRRequire,

        uint256 ratePerETH,

        uint256 lockDuration,

        uint256 minimumTokenSoldout

    ) public onlyOwner {

        uint256 id = pools.length.add(1);

        pools.push(

            IDOPool({

                Id: id,

                Begin: begin,

                End: end,

                Type: _type,

                AmountPBRRequire: amountPBRRequire,

                IDOToken: idoToken,

                MinPurchase: minPurchase,

                MaxPurchase: maxPurchase,

                TotalCap: totalCap,

                TotalToken: totalToken,

                RatePerETH: ratePerETH,

                IsActived: true,

                IsStoped: false,

                ActivedDate: block.timestamp,

                StopDate: 0,

                LockDuration: lockDuration,

                TotalSold: 0,

                MinimumTokenSoldout: minimumTokenSoldout

            })

        );

    }



    function updatePool(

        uint256 pid,

        uint256 begin,

        uint256 end,

        uint256 amountPBRRequire,

        uint256 minPurchase,

        uint256 maxPurchase,

        uint256 totalCap,

        uint256 totalToken,

        uint256 ratePerETH,

        uint256 lockDuration,

        IERC20 idoToken,

        uint256 minimumTokenSoldout

    ) public onlyOwner {

        uint256 poolIndex = pid.sub(1);

        if (begin > 0) {

            pools[poolIndex].Begin = begin;

        }

        if (end > 0) {

            pools[poolIndex].End = end;

        }

        if (amountPBRRequire > 0) {

            pools[poolIndex].AmountPBRRequire = amountPBRRequire;

        }

        if (minPurchase > 0) {

            pools[poolIndex].MinPurchase = minPurchase;

        }

        if (maxPurchase > 0) {

            pools[poolIndex].MaxPurchase = maxPurchase;

        }

        if (totalCap > 0) {

            pools[poolIndex].TotalCap = totalCap;

        }

        if (totalToken > 0) {

            pools[poolIndex].TotalToken = totalToken;

        }

        if (ratePerETH > 0) {

            pools[poolIndex].RatePerETH = ratePerETH;

        }

        if (lockDuration > 0) {

            pools[poolIndex].LockDuration = lockDuration;

        }

        if (minimumTokenSoldout > 0) {

            pools[poolIndex].MinimumTokenSoldout = minimumTokenSoldout;

        }

        pools[poolIndex].IDOToken = idoToken;

    }



    function stopPool(uint256 pid) public onlyOwner {

        uint256 poolIndex = pid.sub(1);

        pools[poolIndex].IsActived = false;

        pools[poolIndex].IsStoped = true;



        pools[poolIndex].StopDate = block.timestamp;

    }



    function activePool(uint256 pid) public onlyOwner {

        uint256 poolIndex = pid.sub(1);

        pools[poolIndex].IsActived = true;

        pools[poolIndex].IsStoped = false;



        pools[poolIndex].StopDate = 0;

    }



    //withdraw contract token

    //use for someone send token to contract

    //recuse wrong user



    function withdrawErc20(IERC20 token) public onlyOwner {

        token.transfer(owner(), token.balanceOf(address(this)));

    }



    //withdraw ETH after IDO

    function withdrawPoolFund() public onlyOwner {

        uint256 balance = address(this).balance;

        require(balance > 0, "not enough fund");

        ReceiveToken.transfer(balance);

    }



    function purchaseIDO(uint256 pid) public payable nonReentrant {

        uint256 poolIndex = pid.sub(1);



        require(

            pools[poolIndex].IsActived && !pools[poolIndex].IsStoped,

            "invalid pool"

        );

        require(

            block.timestamp >= pools[poolIndex].Begin &&

                block.timestamp <= pools[poolIndex].End,

            "invalid time"

        );

        //check user

        require(

            whitelist[pid][msg.sender].IsWhitelist &&

                whitelist[pid][msg.sender].IsActived,

            "invalid user"

        );



        //check amount

        uint256 ethAmount = msg.value;

        uint256 tokenAmount =

            ethAmount.mul(pools[poolIndex].RatePerETH).div(1e18);



        require(

            ethAmount <= pools[poolIndex].MaxPurchase,

            "invalid maximum contribute"

        );



        whitelist[pid][msg.sender].TotalETHPurchase = whitelist[pid][msg.sender]

            .TotalETHPurchase

            .add(ethAmount);

        if (

            whitelist[pid][msg.sender].TotalETHPurchase >

            pools[poolIndex].MaxPurchase

        ) {

            revert("invalid maximum contribute"); //already revert state

        }



        uint256 remainToken = getRemainIDOToken(pid);

        require(

            remainToken > pools[poolIndex].MinimumTokenSoldout,

            "IDO sold out"

        );

        require(remainToken >= tokenAmount, "IDO sold out");



        if (pools[poolIndex].Type == 2) //private, check hold PBR

        {

            require(

                polkaBridgeToken.balanceOf(msg.sender) >=

                    pools[poolIndex].AmountPBRRequire,

                "must hold enough PBR"

            );

        }



       



        whitelist[pid][msg.sender].TotalTokenPurchase = whitelist[pid][

            msg.sender

        ]

            .TotalTokenPurchase

            .add(tokenAmount);



        pools[poolIndex].TotalSold = pools[poolIndex].TotalSold.add(

            tokenAmount

        );

    }



    function claimToken(uint256 pid) public nonReentrant {

        require(!whitelist[pid][msg.sender].IsClaimed, "user already claimed");

        uint256 poolIndex = pid.sub(1);



        require(

            block.timestamp >=

                pools[poolIndex].End.add(pools[poolIndex].LockDuration),

            "not on time for claiming token"

        );



        uint256 userBalance = getUserTotalPurchase(pid);



        require(userBalance > 0, "invalid claim");



        pools[poolIndex].IDOToken.transfer(msg.sender, userBalance);

        whitelist[pid][msg.sender].IsClaimed = true;

    }



    function getUserTotalPurchase(uint256 pid) public view returns (uint256) {

        return whitelist[pid][msg.sender].TotalTokenPurchase;

    }



    function getRemainIDOToken(uint256 pid) public view returns (uint256) {

        uint256 poolIndex = pid.sub(1);

        uint256 tokenBalance = getBalanceTokenByPoolId(pid);

        if (pools[poolIndex].TotalSold > tokenBalance) {

            return 0;

        }



        return tokenBalance.sub(pools[poolIndex].TotalSold);

    }



    function getBalanceTokenByPoolId(uint256 pid)

        public

        view

        returns (uint256)

    {

        uint256 poolIndex = pid.sub(1);

        //return pools[poolIndex].IDOToken.balanceOf(address(this));

        return pools[poolIndex].TotalToken;

    }



    function getPoolInfo(uint256 pid)

        public

        view

        returns (

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            bool,

            IERC20

        )

    {

        uint256 poolIndex = pid.sub(1);

        return (

            pools[poolIndex].Begin,

            pools[poolIndex].End,

            pools[poolIndex].Type,

            pools[poolIndex].AmountPBRRequire,

            pools[poolIndex].MaxPurchase,

            pools[poolIndex].RatePerETH,

            pools[poolIndex].LockDuration,

            pools[poolIndex].TotalSold,

            pools[poolIndex].IsActived,

            pools[poolIndex].IDOToken

        );

    }



    function getPoolSoldInfo(uint256 pid)

        public

        view

        returns (uint256, uint256)

    {

        uint256 poolIndex = pid.sub(1);

        return (pools[poolIndex].LockDuration, pools[poolIndex].TotalSold);

    }



    function getWhitelistfo(uint256 pid)

        public

        view

        returns (

            address,

            bool,

            uint256,

            uint256,

            uint256,

            bool

        )

    {

        return (

            whitelist[pid][msg.sender].UserAddress,

            whitelist[pid][msg.sender].IsWhitelist,

            whitelist[pid][msg.sender].WhitelistDate,

            whitelist[pid][msg.sender].TotalTokenPurchase,

            whitelist[pid][msg.sender].TotalETHPurchase,

            whitelist[pid][msg.sender].IsClaimed

        );

    }



    function getUserInfo(uint256 pid, address user)

        public

        view

        returns (

            bool,

            uint256,

            uint256,

            uint256,

            bool

        )

    {

        return (

            whitelist[pid][user].IsWhitelist,

            whitelist[pid][user].WhitelistDate,

            whitelist[pid][user].TotalTokenPurchase,

            whitelist[pid][user].TotalETHPurchase,

            whitelist[pid][user].IsClaimed

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\PolkabridgeLaunchPadV2.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2022-08-15

*/



pragma solidity >=0.6.0;

interface IERC20 {

   

    function totalSupply() external view returns (uint256);



  

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);

    function transferWithoutDeflationary(address recipient, uint256 amount) external returns (bool) ;

   

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

library SafeMath {

   

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



   

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



   

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Converts an `address` into `address payable`. Note that this is

     * simply a type cast: the actual underlying value is not changed.

     *

     * _Available since v2.4.0._

     */

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     *

     * _Available since v2.4.0._

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves.



        // A Solidity high level call has three parts:

        //  1. The target address is checked to verify it contains contract code

        //  2. The call itself is made, and success asserted

        //  3. The return value is decoded, which in turn checks the size of the returned data.

        // solhint-disable-next-line max-line-length

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }



    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal virtual {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

abstract contract ReentrancyGuard {

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    uint256 private _status;



    constructor() internal {

        _status = _NOT_ENTERED;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _status = _ENTERED;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _status = _NOT_ENTERED;

    }

}







library ECDSA {

    /**

     * @dev Recover signer address from a message by using their signature

     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.

     * @param signature bytes signature, the signature is generated using web3.eth.sign()

     */

    function recover(bytes32 hash, bytes memory signature)

        internal

        pure

        returns (address)

    {

        bytes32 r;

        bytes32 s;

        uint8 v;



        // Check the signature length

        if (signature.length != 65) {

            return (address(0));

        }



        // Divide the signature in r, s and v variables with inline assembly.

        assembly {

            r := mload(add(signature, 0x20))

            s := mload(add(signature, 0x40))

            v := byte(0, mload(add(signature, 0x60)))

        }



        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions

        if (v < 27) {

            v += 27;

        }



        // If the version is correct return the signer address

        if (v != 27 && v != 28) {

            return (address(0));

        } else {

            // solium-disable-next-line arg-overflow

            return ecrecover(hash, v, r, s);

        }

    }



    /**

     * toEthSignedMessageHash

     * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"

     * and hash the result

     */

    function toEthSignedMessageHash(bytes32 hash)

        internal

        pure

        returns (bytes32)

    {

        return

            keccak256(

                abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)

            );

    }

}



contract PolkabridgeLaunchPadV2 is Ownable, ReentrancyGuard {

    string public name = "PolkaBridge: LaunchPad V2";

    using SafeMath for uint256;

    using SafeERC20 for IERC20;

    using ECDSA for bytes32;



    address payable private ReceiveToken;

    uint256 MinimumStakeAmount;

    struct IDOPool {

        uint256 Id;

        uint256 Begin;

        uint256 End;

        uint256 Type; //1: comminity round, 2 stackers round, 3 whitelist, 4 guaranteed

        IERC20 IDOToken;

        uint256 MaxPurchaseTier1;

        uint256 MaxPurchaseTier2; //==comminity tier

        uint256 MaxPurchaseTier3;

        uint256 MaxSpecialPurchase;

        uint256 TotalCap;

        uint256 MinimumTokenSoldout;

        uint256 TotalToken; //total sale token for this pool

        uint256 RatePerETH;

        uint256 TotalSold; //total number of token sold

        

    }



    struct ClaimInfo {

        uint256 ClaimTime1;

        uint256 PercentClaim1;

        uint256 ClaimTime2;

        uint256 PercentClaim2;

        uint256 ClaimTime3;

        uint256 PercentClaim3;

        uint256 ClaimTime4;

        uint256 PercentClaim4;

        uint256 ClaimTime5;

        uint256 PercentClaim5;

         uint256 ClaimTime6;

        uint256 PercentClaim6;

         uint256 ClaimTime7;

        uint256 PercentClaim7;

    }



    struct User {

        uint256 Id;

        

        bool IsWhitelist;

        uint256 TotalTokenPurchase;

        uint256 TotalETHPurchase;

        uint256 PurchaseTime;

        uint256 LastClaimed;

        uint256 TotalPercentClaimed;

        uint256 NumberClaimed;

        

        uint256 PurchaseAllocation;

    }



    mapping(uint256 => mapping(address => User)) public users; //poolid - listuser



    IDOPool[] pools;



    mapping(uint256 => ClaimInfo) public claimInfos; //pid



    constructor(address payable receiveTokenAdd) public {

        ReceiveToken = receiveTokenAdd;

        MinimumStakeAmount=10000*1e18;

    }



    function addMulWhitelist(address[] memory user,uint256[] memory allocation, uint256 pid)///need pid in constantfile

        public

        onlyOwner

    {

        for (uint256 i = 0; i < user.length; i++) {

            users[pid][user[i]].Id = pid;

             users[pid][user[i]].PurchaseAllocation = allocation[i];

            users[pid][user[i]].IsWhitelist = true;

           

        }

    }



    function sign(address[] memory user, uint256 pid)///need pid in constantfile

        public

        onlyOwner

    {

        uint256 poolIndex = pid.sub(1);

        uint256 maxSpeical= pools[poolIndex].MaxSpecialPurchase;

        uint256 tokenAmount = maxSpeical.mul(pools[poolIndex].RatePerETH).div(1e18);



        for (uint256 i = 0; i < user.length; i++) {

          

            users[pid][user[i]].TotalTokenPurchase = tokenAmount;

            

        }

    }



    function updateWhitelist(

        address user,

        uint256 pid,

        bool isWhitelist

    ) public onlyOwner {

        users[pid][user].IsWhitelist = isWhitelist;

       

    }



    function updateMinimumStake(

       uint256 _minimum

    ) public onlyOwner {

        MinimumStakeAmount=_minimum;

       

    }



    function IsWhitelist(

        address user,

        uint256 pid,

        uint256 stackAmount

    ) public view returns (bool) {

        uint256 poolIndex = pid.sub(1);

        if (pools[poolIndex].Type == 1) // community round

        {

            return true;

        } else if (pools[poolIndex].Type == 2) // stakers round

        {

            if (stackAmount >= MinimumStakeAmount) return true;

            return false;

        } else if (pools[poolIndex].Type == 3 ) //special round  

        {

            if (users[pid][user].IsWhitelist) return true;

            return false;

        }

        else if (pools[poolIndex].Type ==4) //guaranteed round  

        {

            if (users[pid][user].IsWhitelist && stackAmount >= MinimumStakeAmount) return true;

            return false;

        } else {

            return false;

        }

    }



    function addPool(

        uint256 begin,

        uint256 end,

        uint256 _type,

        IERC20 idoToken,

        uint256 maxPurchaseTier1,

        uint256 maxPurchaseTier2,

        uint256 maxPurchaseTier3,

        uint256 maxSpecialPurchase,

        uint256 totalCap,

        uint256 totalToken,

        uint256 ratePerETH,

        uint256 minimumTokenSoldout

       

    ) public onlyOwner {

        uint256 id = pools.length.add(1);

        pools.push(

            IDOPool({

                Id: id,

                Begin: begin,

                End: end,

                Type: _type,

                IDOToken: idoToken,

                MaxPurchaseTier1: maxPurchaseTier1,

                MaxPurchaseTier2: maxPurchaseTier2,

                MaxPurchaseTier3: maxPurchaseTier3,

                MaxSpecialPurchase:maxSpecialPurchase,

                TotalCap: totalCap,

                TotalToken: totalToken,

                RatePerETH: ratePerETH,

                TotalSold: 0,

                MinimumTokenSoldout: minimumTokenSoldout

               

            })

        );

    }



    function addClaimInfo(

        uint256 percentClaim1,

        uint256 claimTime1,

        uint256 percentClaim2,

        uint256 claimTime2,

        uint256 percentClaim3,

        uint256 claimTime3,

         uint256 percentClaim4,

        uint256 claimTime4,

         uint256 percentClaim5,

        uint256 claimTime5,

         uint256 percentClaim6,

        uint256 claimTime6,

         uint256 percentClaim7,

        uint256 claimTime7,

        uint256 pid

    ) public onlyOwner {

        claimInfos[pid].ClaimTime1 = claimTime1;

        claimInfos[pid].PercentClaim1 = percentClaim1;

        claimInfos[pid].ClaimTime2 = claimTime2;

        claimInfos[pid].PercentClaim2 = percentClaim2;

        claimInfos[pid].ClaimTime3 = claimTime3;

        claimInfos[pid].PercentClaim3 = percentClaim3;

        claimInfos[pid].ClaimTime4 = claimTime4;

        claimInfos[pid].PercentClaim4 = percentClaim4;

        claimInfos[pid].ClaimTime5 = claimTime5;

        claimInfos[pid].PercentClaim5 = percentClaim5;

         claimInfos[pid].ClaimTime6 = claimTime6;

        claimInfos[pid].PercentClaim6 = percentClaim6;

         claimInfos[pid].ClaimTime7 = claimTime7;

        claimInfos[pid].PercentClaim7 = percentClaim7;

    }



    function updateClaimInfo(

        uint256 percentClaim1,

        uint256 claimTime1,

        uint256 percentClaim2,

        uint256 claimTime2,

        uint256 percentClaim3,

        uint256 claimTime3,

          uint256 percentClaim4,

        uint256 claimTime4,

          uint256 percentClaim5,

        uint256 claimTime5,

         uint256 percentClaim6,

        uint256 claimTime6,

         uint256 percentClaim7,

        uint256 claimTime7,

        uint256 pid

    ) public onlyOwner {

        if (claimTime1 > 0) {

            claimInfos[pid].ClaimTime1 = claimTime1;

        }



        if (percentClaim1 > 0) {

            claimInfos[pid].PercentClaim1 = percentClaim1;

        }

        if (claimTime2 > 0) {

            claimInfos[pid].ClaimTime2 = claimTime2;

        }



        if (percentClaim2 > 0) {

            claimInfos[pid].PercentClaim2 = percentClaim2;

        }



        if (claimTime3 > 0) {

            claimInfos[pid].ClaimTime3 = claimTime3;

        }



        if (percentClaim3 > 0) {

            claimInfos[pid].PercentClaim3 = percentClaim3;

        }



          if (claimTime4 > 0) {

            claimInfos[pid].ClaimTime4 = claimTime4;

        }



        if (percentClaim4 > 0) {

            claimInfos[pid].PercentClaim4 = percentClaim4;

        }



           if (claimTime5 > 0) {

            claimInfos[pid].ClaimTime5 = claimTime5;

        }



        if (percentClaim5 > 0) {

            claimInfos[pid].PercentClaim5 = percentClaim5;

        }



           if (claimTime6 > 0) {

            claimInfos[pid].ClaimTime6 = claimTime6;

        }



        if (percentClaim6 > 0) {

            claimInfos[pid].PercentClaim6 = percentClaim6;

        }



           if (claimTime7 > 0) {

            claimInfos[pid].ClaimTime7 = claimTime7;

        }



        if (percentClaim7 > 0) {

            claimInfos[pid].PercentClaim7 = percentClaim7;

        }

    }



    function updatePool(

        uint256 pid,

        uint256 begin,

        uint256 end,

        uint256 maxPurchaseTier1,

        uint256 maxPurchaseTier2,

        uint256 maxPurchaseTier3,

         uint256 maxSpecialPurchase,

        uint256 totalCap,

        uint256 totalToken,

        uint256 ratePerETH,

        IERC20 idoToken,

       

        uint256 pooltype

      

    ) public onlyOwner {

        uint256 poolIndex = pid.sub(1);

        if (begin > 0) {

            pools[poolIndex].Begin = begin;

        }

        if (end > 0) {

            pools[poolIndex].End = end;

        }



        if (maxPurchaseTier1 > 0) {

            pools[poolIndex].MaxPurchaseTier1 = maxPurchaseTier1;

        }

        if (maxPurchaseTier2 > 0) {

            pools[poolIndex].MaxPurchaseTier2 = maxPurchaseTier2;

        }

        if (maxPurchaseTier3 > 0) {

            pools[poolIndex].MaxPurchaseTier3 = maxPurchaseTier3;

        }

          if (maxSpecialPurchase > 0) {

            pools[poolIndex].MaxSpecialPurchase = maxSpecialPurchase;

        }

        if (totalCap > 0) {

            pools[poolIndex].TotalCap = totalCap;

        }

        if (totalToken > 0) {

            pools[poolIndex].TotalToken = totalToken;

        }

        if (ratePerETH > 0) {

            pools[poolIndex].RatePerETH = ratePerETH;

        }



       

      

        if (pooltype > 0) {

            pools[poolIndex].Type = pooltype;

        }

        pools[poolIndex].IDOToken = idoToken;

    }



    function withdrawErc20(IERC20 token) public onlyOwner {

        token.transfer(owner(), token.balanceOf(address(this)));

    }



    //withdraw ETH after IDO

    function withdrawPoolFund() public onlyOwner {

        uint256 balance = address(this).balance;

        require(balance > 0, "not enough fund");

        ReceiveToken.transfer(balance);

    }



    function purchaseIDO(

        uint256 stakeAmount,

        uint256 pid,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) public payable nonReentrant {

        uint256 poolIndex = pid.sub(1);



        // if (pools[poolIndex].Type == 2 || pools[poolIndex].Type == 4) {

        //     bytes32 _hash = keccak256(abi.encodePacked(msg.sender, stakeAmount));

        //     bytes32 messageHash = _hash.toEthSignedMessageHash();



        //     require(

        //         owner() == ecrecover(messageHash, v, r, s),

        //         "owner should sign purchase info"

        //     );

        // }



        require(

            block.timestamp >= pools[poolIndex].Begin &&

                block.timestamp <= pools[poolIndex].End,

            "invalid time"

        );

        //check user

        require(IsWhitelist(msg.sender, pid, stakeAmount), "invalid user");



        //check amount

        uint256 ethAmount = msg.value;

        users[pid][msg.sender].TotalETHPurchase = users[pid][msg.sender]

            .TotalETHPurchase

            .add(ethAmount);



        if (pools[poolIndex].Type == 2) {

            //stackers round

            if (stakeAmount < 1500 * 1e18) {

                require(

                    users[pid][msg.sender].TotalETHPurchase <=

                        pools[poolIndex].MaxPurchaseTier1,

                    "invalid maximum purchase for tier1"

                );

            } else if (

                stakeAmount >= 1500 * 1e18 && stakeAmount < 3000 * 1e18

            ) {

                require(

                    users[pid][msg.sender].TotalETHPurchase <=

                        pools[poolIndex].MaxPurchaseTier2,

                    "invalid maximum purchase for tier2"

                );

            } else {

                require(

                    users[pid][msg.sender].TotalETHPurchase <=

                        pools[poolIndex].MaxPurchaseTier3,

                    "invalid maximum purchase for tier3"

                );

            }

        } else if (pools[poolIndex].Type == 1) {

            //community round



            require(

                users[pid][msg.sender].TotalETHPurchase <=

                    pools[poolIndex].MaxPurchaseTier2,

                "invalid maximum contribute"

            );

        } else  if (pools[poolIndex].Type == 3){//special

            

            require(

                users[pid][msg.sender].TotalETHPurchase <=

                    pools[poolIndex].MaxSpecialPurchase,

                "invalid contribute"

            );

        }else{//4 guaranteed

            

            require(

                users[pid][msg.sender].TotalETHPurchase <=

                     users[pid][msg.sender].PurchaseAllocation,

                "invalid contribute"

            );

        }



        uint256 tokenAmount = ethAmount.mul(pools[poolIndex].RatePerETH).div(

            1e18

        );



        uint256 remainToken = getRemainIDOToken(pid);

        require(

            remainToken > pools[poolIndex].MinimumTokenSoldout,

            "IDO sold out"

        );

        require(remainToken >= tokenAmount, "IDO sold out");



        users[pid][msg.sender].TotalTokenPurchase = users[pid][msg.sender]

            .TotalTokenPurchase

            .add(tokenAmount);



        pools[poolIndex].TotalSold = pools[poolIndex].TotalSold.add(

            tokenAmount

        );

    }



    function claimToken(uint256 pid) public nonReentrant {

        require(

            users[pid][msg.sender].TotalPercentClaimed < 100,

            "you have claimed enough"

        );

        uint256 userBalance = getUserTotalPurchase(pid);

        require(userBalance > 0, "invalid claim");



        uint256 poolIndex = pid.sub(1);

        if (users[pid][msg.sender].NumberClaimed == 0) {

            require(

                block.timestamp >= claimInfos[poolIndex].ClaimTime1,

                "invalid time"

            );

            pools[poolIndex].IDOToken.safeTransfer(

                msg.sender,

                userBalance.mul(claimInfos[poolIndex].PercentClaim1).div(100)

            );

          users[pid][msg.sender].TotalPercentClaimed=  users[pid][msg.sender].TotalPercentClaimed.add(

                claimInfos[poolIndex].PercentClaim1

            );

        } else if (users[pid][msg.sender].NumberClaimed == 1) {

            require(

                block.timestamp >= claimInfos[poolIndex].ClaimTime2,

                "invalid time"

            );

            pools[poolIndex].IDOToken.safeTransfer(

                msg.sender,

                userBalance.mul(claimInfos[poolIndex].PercentClaim2).div(100)

            );

            users[pid][msg.sender].TotalPercentClaimed=users[pid][msg.sender].TotalPercentClaimed.add(

                claimInfos[poolIndex].PercentClaim2

            );

        } else if (users[pid][msg.sender].NumberClaimed == 2) {

            require(

                block.timestamp >= claimInfos[poolIndex].ClaimTime3,

                "invalid time"

            );

            pools[poolIndex].IDOToken.safeTransfer(

                msg.sender,

                userBalance.mul(claimInfos[poolIndex].PercentClaim3).div(100)

            );

           users[pid][msg.sender].TotalPercentClaimed= users[pid][msg.sender].TotalPercentClaimed.add(

                claimInfos[poolIndex].PercentClaim3

            );

        }



         else if (users[pid][msg.sender].NumberClaimed == 3) {

            require(

                block.timestamp >= claimInfos[poolIndex].ClaimTime4,

                "invalid time"

            );

            pools[poolIndex].IDOToken.safeTransfer(

                msg.sender,

                userBalance.mul(claimInfos[poolIndex].PercentClaim4).div(100)

            );

           users[pid][msg.sender].TotalPercentClaimed= users[pid][msg.sender].TotalPercentClaimed.add(

                claimInfos[poolIndex].PercentClaim4

            );

        }

         else if (users[pid][msg.sender].NumberClaimed == 4) {

            require(

                block.timestamp >= claimInfos[poolIndex].ClaimTime5,

                "invalid time"

            );

            pools[poolIndex].IDOToken.safeTransfer(

                msg.sender,

                userBalance.mul(claimInfos[poolIndex].PercentClaim5).div(100)

            );

           users[pid][msg.sender].TotalPercentClaimed= users[pid][msg.sender].TotalPercentClaimed.add(

                claimInfos[poolIndex].PercentClaim5

            );

        }

        else if (users[pid][msg.sender].NumberClaimed == 5) {

            require(

                block.timestamp >= claimInfos[poolIndex].ClaimTime6,

                "invalid time"

            );

            pools[poolIndex].IDOToken.safeTransfer(

                msg.sender,

                userBalance.mul(claimInfos[poolIndex].PercentClaim6).div(100)

            );

           users[pid][msg.sender].TotalPercentClaimed= users[pid][msg.sender].TotalPercentClaimed.add(

                claimInfos[poolIndex].PercentClaim6

            );

        }

        else if (users[pid][msg.sender].NumberClaimed == 6) {

            require(

                block.timestamp >= claimInfos[poolIndex].ClaimTime7,

                "invalid time"

            );

            pools[poolIndex].IDOToken.safeTransfer(

                msg.sender,

                userBalance.mul(claimInfos[poolIndex].PercentClaim7).div(100)

            );

           users[pid][msg.sender].TotalPercentClaimed= users[pid][msg.sender].TotalPercentClaimed.add(

                claimInfos[poolIndex].PercentClaim7

            );

        }



        users[pid][msg.sender].LastClaimed = block.timestamp;

        users[pid][msg.sender].NumberClaimed=users[pid][msg.sender].NumberClaimed.add(1);

    }



    function getUserTotalPurchase(uint256 pid) public view returns (uint256) {

        return users[pid][msg.sender].TotalTokenPurchase;

    }



    function getRemainIDOToken(uint256 pid) public view returns (uint256) {

        uint256 poolIndex = pid.sub(1);

        uint256 tokenBalance = getBalanceTokenByPoolId(pid);

        if (pools[poolIndex].TotalSold > tokenBalance) {

            return 0;

        }



        return tokenBalance.sub(pools[poolIndex].TotalSold);

    }



    function getBalanceTokenByPoolId(uint256 pid)

        public

        view

        returns (uint256)

    {

        uint256 poolIndex = pid.sub(1);



        return pools[poolIndex].TotalToken;

    }



    function getPoolInfo(uint256 pid)

        public

        view

        returns (

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

             uint256,

            IERC20

        )

    {

        uint256 poolIndex = pid.sub(1);

        return (

            pools[poolIndex].Begin,

            pools[poolIndex].End,

            pools[poolIndex].Type,

            pools[poolIndex].RatePerETH,

            pools[poolIndex].TotalSold,

            pools[poolIndex].TotalToken,

            pools[poolIndex].TotalCap,

            pools[poolIndex].IDOToken

        );

    }



    function getClaimInfo(uint256 pid)

        public

        view

        returns (

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256,

            uint256

        )

    {

        uint256 poolIndex = pid.sub(1);

        return (

            claimInfos[poolIndex].ClaimTime1,

            claimInfos[poolIndex].PercentClaim1,

            claimInfos[poolIndex].ClaimTime2,

            claimInfos[poolIndex].PercentClaim2,

            claimInfos[poolIndex].ClaimTime3,

            claimInfos[poolIndex].PercentClaim3,

             claimInfos[poolIndex].ClaimTime4,

            claimInfos[poolIndex].PercentClaim4,

             claimInfos[poolIndex].ClaimTime5,

            claimInfos[poolIndex].PercentClaim5,

             claimInfos[poolIndex].ClaimTime6,

            claimInfos[poolIndex].PercentClaim6

        );

    }



    function getPoolSoldInfo(uint256 pid) public view returns (uint256) {

        uint256 poolIndex = pid.sub(1);

        return (pools[poolIndex].TotalSold);

    }



    function getWhitelistfo(uint256 pid)

        public

        view

        returns (

          

            bool,

            uint256,

            uint256

        )

    {

        return (

           

            users[pid][msg.sender].IsWhitelist,

            users[pid][msg.sender].TotalTokenPurchase,

            users[pid][msg.sender].TotalETHPurchase

        );

    }



    function getUserInfo(uint256 pid, address user)

        public

        view

        returns (

            bool,

            uint256,

            uint256,

            uint256

        )

    {

        return (

            users[pid][user].IsWhitelist,

            users[pid][user].TotalTokenPurchase,

            users[pid][user].TotalETHPurchase,

            users[pid][user].TotalPercentClaimed

        );

    }



    function getUserPurchaseAllocation(uint256 pid, address user)

        public

        view

        returns (

            uint256

        )

    {

        return (

            users[pid][user].PurchaseAllocation

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\PolkaBridgeMasterFarm.sol
File type: .sol
pragma solidity >=0.6.0;



import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

import "@openzeppelin/contracts/math/SafeMath.sol";

import "@openzeppelin/contracts/ownership/Ownable.sol";

import "./PolkaBridge.sol";



// import "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";

//import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

//import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";



contract PolkaBridgeMasterFarm is Ownable {

    string public name = "PolkaBridge: Deflationary Farming";

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    struct UserInfo {

        uint256 amountLP;

        uint256 rewardDebt;

        uint256 rewardDebtAtBlock;

        uint256 rewardClaimed;

    }



    struct PoolInfo {

        IERC20 lpToken;

        IERC20 tokenA;

        IERC20 tokenB;

        uint256 multiplier;

        uint256 lastPoolReward; //history pool reward

        uint256 lastRewardBlock;

        uint256 lastLPBalance;

        uint256 accPBRPerShare;

        uint256 startBlock;

        uint256 stopBlock;

        uint256 totalRewardClaimed;

        bool isActived;

    }



    PolkaBridge public polkaBridge;

    uint256 public START_BLOCK;



    //pool Info

    PoolInfo[] public poolInfo;

    mapping(address => uint256) public poolId1;

    // Info of each user that stakes LP tokens. pid => user address => info

    mapping(uint256 => mapping(address => UserInfo)) public userInfo;



    constructor(PolkaBridge _polkaBridge, uint256 _startBlock) public {

        polkaBridge = _polkaBridge;

        START_BLOCK = _startBlock;

    }



    function poolBalance() public view returns (uint256) {

        return polkaBridge.balanceOf(address(this));

    }



    // Add a new lp to the pool. Can only be called by the owner.

    function add(IERC20 _lpToken,IERC20 _tokenA, IERC20 _tokenB, uint256 _multiplier, uint256 _startBlock) public onlyOwner {

        require(

            poolId1[address(_lpToken)] == 0,

            "PolkaBridgeMasterFarm::add: lp is already in pool"

        );



        uint256 _lastRewardBlock =

            block.number > START_BLOCK ? block.number : START_BLOCK;



        poolId1[address(_lpToken)] = poolInfo.length + 1;

        poolInfo.push(

            PoolInfo({

                lpToken: _lpToken,

                tokenA: _tokenA,

                tokenB: _tokenB,

                multiplier: _multiplier,

                lastRewardBlock: _lastRewardBlock,

                lastPoolReward: 0,

                lastLPBalance: 0,

                accPBRPerShare: 0,

                startBlock: _startBlock > 0 ? _startBlock : block.number,

                stopBlock: 0,

                totalRewardClaimed: 0,

                isActived: true

            })

        );



        massUpdatePools();

    }



    function getChangePoolReward(uint256 _pid, uint256 _totalMultiplier) public view returns (uint256) {

        uint256 changePoolReward;

        if (_totalMultiplier == 0) {

            changePoolReward = 0;

        }

        else {

            uint256 currentPoolBalance = poolBalance();

            uint256 totalLastPoolReward = getTotalLastPoolReward();

            changePoolReward = ((currentPoolBalance.sub(totalLastPoolReward)).mul(poolInfo[_pid].multiplier).mul(1e18)).div(_totalMultiplier);

        }



        if (changePoolReward <= 0) {

            changePoolReward = 0;

        }



        return changePoolReward;

    }



    function massUpdatePools() public {

        uint256 length = poolInfo.length;

        uint256 totalMultiplier = countTotalMultiplier();

        for (uint256 pid = 0; pid < length; pid++) {

            if (poolInfo[pid].isActived) {

                uint256 changePoolReward = getChangePoolReward(pid, totalMultiplier);

                updatePool(pid, changePoolReward, 1);

            }

        }

    }



    function getTotalLastPoolReward() public view returns (uint256) {

        uint256 total;

        uint256 length = poolInfo.length;

        for (uint256 pid = 0; pid < length; pid++) {

            if (poolInfo[pid].isActived) {

                total += poolInfo[pid].lastPoolReward;

            }

        }

        return total;

    }



    // Update reward variables of the given pool to be up-to-date.

    function updatePool(

        uint256 _pid,

        uint256 _changePoolReward,

        uint256 flag

    ) internal {

        PoolInfo storage pool = poolInfo[_pid];

        if (block.number <= pool.lastRewardBlock && flag==1) {

            return;

        }

        uint256 lpSupply = pool.lastLPBalance;

        if (lpSupply == 0) { // first deposit

            pool.accPBRPerShare = 0;

        } else {

            pool.accPBRPerShare = pool.accPBRPerShare.add(

                (_changePoolReward.mul(1e18).div(lpSupply))

            );

        }

        pool.lastRewardBlock = block.number;



        if (flag == 1) {

            pool.lastPoolReward += _changePoolReward;

        } else {

            pool.lastPoolReward -= _changePoolReward;

        }



        pool.lastLPBalance = pool.lpToken.balanceOf(address(this));

    }



    function pendingReward(uint256 _pid, address _user)

        public

        view

        returns (uint256)

    {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_user];

        uint256 lpSupply = pool.lpToken.balanceOf(address(this));

        uint256 temptAccPBRPerShare = pool.accPBRPerShare;

        uint256 totalMultiplier = countTotalMultiplier();



        if (block.number > pool.lastRewardBlock && lpSupply > 0) {

            temptAccPBRPerShare = pool.accPBRPerShare.add(

                (getChangePoolReward(_pid, totalMultiplier).mul(1e18).div(lpSupply))

            );

        }



        uint256 pending = (

                user.amountLP.mul(temptAccPBRPerShare).sub(

                    user.rewardDebt.mul(1e18)

                )

            ).div(1e18);



        return pending;

    }



    function claimReward(uint256 _pid) public {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];



        massUpdatePools();

        _harvest(_pid);



        user.rewardDebt = user.amountLP.mul(pool.accPBRPerShare).div(1e18);

    }



    function _harvest(uint256 _pid) internal {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];



        if (user.amountLP > 0) {

            uint256 pending = pendingReward(_pid, msg.sender);

            uint256 masterBal = poolBalance();



            if (pending > masterBal) {

                pending = masterBal;

            }



            if (pending > 0) {

                polkaBridge.transfer(msg.sender, pending);

                pool.lastPoolReward -= pending;

                pool.totalRewardClaimed += pending;

            }



            user.rewardDebtAtBlock = block.number;

            user.rewardClaimed += pending;

        }

    }



    function deposit(uint256 _pid, uint256 _amount) public {

        require(

            _amount > 0,

            "PolkaBridgeMasterFarmer::deposit: amount must be greater than 0"

        );



        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];



        pool.lpToken.safeTransferFrom(

            address(msg.sender),

            address(this),

            _amount

        );



        massUpdatePools();

        _harvest(_pid);



        if (user.amountLP == 0) {

            user.rewardDebtAtBlock = block.number;

        }



        user.amountLP = user.amountLP.add(_amount);

        user.rewardDebt = user.amountLP.mul(pool.accPBRPerShare).div(1e18);

    }



    function withdraw(uint256 _pid, uint256 _amount) public {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];

        require(

            user.amountLP >= _amount,

            "PolkaBridgeMasterFarmer::withdraw: not good"

        );



        if (_amount > 0) {

            massUpdatePools();

            _harvest(_pid);

            pool.lpToken.safeTransfer(address(msg.sender), _amount);

            pool.lastLPBalance = pool.lpToken.balanceOf(address(this));



            // update pool

            // updatePool(_pid, 0, 1);

            user.amountLP = user.amountLP.sub(_amount);

            user.rewardDebt = user.amountLP.mul(pool.accPBRPerShare).div(1e18);

        }

    }



    function emergencyWithdraw(uint256 _pid) public {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];

        pool.lpToken.safeTransfer(address(msg.sender), user.amountLP);



        user.amountLP = 0;

        user.rewardDebt = 0;

    }



    function getPoolInfo(uint256 _pid)

        public

        view

        returns (

            uint256,

            uint256,

            address,

            uint256,

            uint256,

            uint256,

            // bool,

            uint256

        )

    //uint256

    {

        return (

            poolInfo[_pid].lastRewardBlock,

            poolInfo[_pid].multiplier,

            address(poolInfo[_pid].lpToken),

            poolInfo[_pid].lastPoolReward,

            poolInfo[_pid].startBlock,

            poolInfo[_pid].accPBRPerShare,

            // poolInfo[_pid].isActived,

            poolInfo[_pid].lpToken.balanceOf(address(this))

            //poolInfo[_pid].lastLPBalance

        );

    }



    function getUserInfo(uint256 _pid)

        public

        view

        returns (

            uint256,

            uint256,

            uint256

        )

    {

        UserInfo memory user = userInfo[_pid][msg.sender];

        return (user.amountLP, user.rewardDebt, user.rewardClaimed);

    }



    function stopPool(uint256 pid) public onlyOwner {

        PoolInfo storage pool = poolInfo[pid];

        pool.isActived = false;

        pool.stopBlock = block.number;

    }



    function activePool(uint256 pid) public onlyOwner {

        PoolInfo storage pool = poolInfo[pid];

        pool.isActived = true;

        pool.stopBlock = 0;

    }



    function changeMultiplier(uint256 pid, uint256 _multiplier) public onlyOwner {

        PoolInfo storage pool = poolInfo[pid];

        pool.multiplier = _multiplier;

    }



    function countActivePool() public view returns (uint256) {

        uint256 length = 0;

        for (uint256 i = 0; i < poolInfo.length; i++) {

            if (poolInfo[i].isActived) length++;

        }

        return length;

    }



    function countTotalMultiplier() public view returns (uint256) {

        uint256 totalMultiplier = 0;

        for (uint256 i = 0; i < poolInfo.length; i++) {

            if (poolInfo[i].isActived) totalMultiplier += poolInfo[i].multiplier;

        }

        return totalMultiplier.mul(1e18);

    }



    function totalRewardClaimed(uint256 _pid) public view returns (uint256) {

        return poolInfo[_pid].totalRewardClaimed;

    }



    function avgRewardPerBlock(uint256 _pid) public view returns (uint256) {

        uint256 totalMultiplier = countTotalMultiplier();

        uint256 changePoolReward = getChangePoolReward(_pid, totalMultiplier);

        uint256 totalReward = poolInfo[_pid].totalRewardClaimed + poolInfo[_pid].lastPoolReward + changePoolReward;

        uint256 changeBlock;

        if (block.number <= poolInfo[_pid].lastRewardBlock){

            changeBlock = poolInfo[_pid].lastRewardBlock.sub(poolInfo[_pid].startBlock);

        }

        else {

            changeBlock = block.number.sub(poolInfo[_pid].startBlock);

        }



        return totalReward.div(changeBlock);

    }



    receive() external payable {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\PolkaBridgeNFT.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2022-04-02

*/



// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;





abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _transferOwnership(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _transferOwnership(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Internal function without access restriction.

     */

    function _transferOwnership(address newOwner) internal virtual {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}



library Strings {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}



interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

interface IERC1155 is IERC165 {

    /**

     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.

     */

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);



    /**

     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all

     * transfers.

     */

    event TransferBatch(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256[] ids,

        uint256[] values

    );



    /**

     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to

     * `approved`.

     */

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);



    /**

     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.

     *

     * If an {URI} event was emitted for `id`, the standard

     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value

     * returned by {IERC1155MetadataURI-uri}.

     */

    event URI(string value, uint256 indexed id);



    /**

     * @dev Returns the amount of tokens of token type `id` owned by `account`.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) external view returns (uint256);



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)

        external

        view

        returns (uint256[] memory);



    /**

     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,

     *

     * Emits an {ApprovalForAll} event.

     *

     * Requirements:

     *

     * - `operator` cannot be the caller.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.

     *

     * See {setApprovalForAll}.

     */

    function isApprovedForAll(address account, address operator) external view returns (bool);



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes calldata data

    ) external;



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) external;

}

interface IERC1155Receiver is IERC165 {

    /**

        @dev Handles the receipt of a single ERC1155 token type. This function is

        called at the end of a `safeTransferFrom` after the balance has been updated.

        To accept the transfer, this must return

        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

        (i.e. 0xf23a6e61, or its own function selector).

        @param operator The address which initiated the transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param id The ID of the token being transferred

        @param value The amount of tokens being transferred

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed

    */

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    ) external returns (bytes4);



    /**

        @dev Handles the receipt of a multiple ERC1155 token types. This function

        is called at the end of a `safeBatchTransferFrom` after the balances have

        been updated. To accept the transfer(s), this must return

        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

        (i.e. 0xbc197c81, or its own function selector).

        @param operator The address which initiated the batch transfer (i.e. msg.sender)

        @param from The address which previously owned the token

        @param ids An array containing ids of each token being transferred (order and length must match values array)

        @param values An array containing amounts of each token being transferred (order and length must match ids array)

        @param data Additional data with no specified format

        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed

    */

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    ) external returns (bytes4);

}

interface IERC1155MetadataURI is IERC1155 {

    /**

     * @dev Returns the URI for token type `id`.

     *

     * If the `\{id\}` substring is present in the URI, it must be replaced by

     * clients with the actual token type ID.

     */

    function uri(uint256 id) external view returns (string memory);

}

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

abstract contract ERC165 is IERC165 {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IERC165).interfaceId;

    }

}

contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {

    using Address for address;



    // Mapping from token ID to account balances

    mapping(uint256 => mapping(address => uint256)) private _balances;



    // Mapping from account to operator approvals

    mapping(address => mapping(address => bool)) private _operatorApprovals;



    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json

    string private _uri;



    /**

     * @dev See {_setURI}.

     */

    constructor(string memory uri_) {

        _setURI(uri_);

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {

        return

            interfaceId == type(IERC1155).interfaceId ||

            interfaceId == type(IERC1155MetadataURI).interfaceId ||

            super.supportsInterface(interfaceId);

    }



    /**

     * @dev See {IERC1155MetadataURI-uri}.

     *

     * This implementation returns the same URI for *all* token types. It relies

     * on the token type ID substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * Clients calling this function must replace the `\{id\}` substring with the

     * actual token type ID.

     */

    function uri(uint256) public view virtual override returns (string memory) {

        return _uri;

    }



    /**

     * @dev See {IERC1155-balanceOf}.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {

        require(account != address(0), "ERC1155: balance query for the zero address");

        return _balances[id][account];

    }



    /**

     * @dev See {IERC1155-balanceOfBatch}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)

        public

        view

        virtual

        override

        returns (uint256[] memory)

    {

        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");



        uint256[] memory batchBalances = new uint256[](accounts.length);



        for (uint256 i = 0; i < accounts.length; ++i) {

            batchBalances[i] = balanceOf(accounts[i], ids[i]);

        }



        return batchBalances;

    }



    /**

     * @dev See {IERC1155-setApprovalForAll}.

     */

    function setApprovalForAll(address operator, bool approved) public virtual override {

        _setApprovalForAll(_msgSender(), operator, approved);

    }



    /**

     * @dev See {IERC1155-isApprovedForAll}.

     */

    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {

        return _operatorApprovals[account][operator];

    }



    /**

     * @dev See {IERC1155-safeTransferFrom}.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) public virtual override {

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: caller is not owner nor approved"

        );

        _safeTransferFrom(from, to, id, amount, data);

    }



    /**

     * @dev See {IERC1155-safeBatchTransferFrom}.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) public virtual override {

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: transfer caller is not owner nor approved"

        );

        _safeBatchTransferFrom(from, to, ids, amounts, data);

    }



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function _safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: transfer to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);



        uint256 fromBalance = _balances[id][from];

        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");

        unchecked {

            _balances[id][from] = fromBalance - amount;

        }

        _balances[id][to] += amount;



        emit TransferSingle(operator, from, to, id, amount);



        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function _safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        require(to != address(0), "ERC1155: transfer to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; ++i) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 fromBalance = _balances[id][from];

            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");

            unchecked {

                _balances[id][from] = fromBalance - amount;

            }

            _balances[id][to] += amount;

        }



        emit TransferBatch(operator, from, to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);

    }



    /**

     * @dev Sets a new URI for all token types, by relying on the token type ID

     * substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * By this mechanism, any occurrence of the `\{id\}` substring in either the

     * URI or any of the amounts in the JSON file at said URI will be replaced by

     * clients with the token type ID.

     *

     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be

     * interpreted by clients as

     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`

     * for token type ID 0x4cce0.

     *

     * See {uri}.

     *

     * Because these URIs cannot be meaningfully represented by the {URI} event,

     * this function emits no events.

     */

    function _setURI(string memory newuri) internal virtual {

        _uri = newuri;

    }



    /**

     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function _mint(

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: mint to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);



        _balances[id][to] += amount;

        emit TransferSingle(operator, address(0), to, id, amount);



        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function _mintBatch(

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: mint to the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; i++) {

            _balances[ids[i]][to] += amounts[i];

        }



        emit TransferBatch(operator, address(0), to, ids, amounts);



        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);

    }



    /**

     * @dev Destroys `amount` tokens of token type `id` from `from`

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `from` must have at least `amount` tokens of token type `id`.

     */

    function _burn(

        address from,

        uint256 id,

        uint256 amount

    ) internal virtual {

        require(from != address(0), "ERC1155: burn from the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");



        uint256 fromBalance = _balances[id][from];

        require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");

        unchecked {

            _balances[id][from] = fromBalance - amount;

        }



        emit TransferSingle(operator, from, address(0), id, amount);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     */

    function _burnBatch(

        address from,

        uint256[] memory ids,

        uint256[] memory amounts

    ) internal virtual {

        require(from != address(0), "ERC1155: burn from the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");



        for (uint256 i = 0; i < ids.length; i++) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 fromBalance = _balances[id][from];

            require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");

            unchecked {

                _balances[id][from] = fromBalance - amount;

            }

        }



        emit TransferBatch(operator, from, address(0), ids, amounts);

    }



    /**

     * @dev Approve `operator` to operate on all of `owner` tokens

     *

     * Emits a {ApprovalForAll} event.

     */

    function _setApprovalForAll(

        address owner,

        address operator,

        bool approved

    ) internal virtual {

        require(owner != operator, "ERC1155: setting approval status for self");

        _operatorApprovals[owner][operator] = approved;

        emit ApprovalForAll(owner, operator, approved);

    }



    /**

     * @dev Hook that is called before any token transfer. This includes minting

     * and burning, as well as batched variants.

     *

     * The same hook is called on both single and batched variants. For single

     * transfers, the length of the `id` and `amount` arrays will be 1.

     *

     * Calling conditions (for each `id` and `amount` pair):

     *

     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * of token type `id` will be  transferred to `to`.

     * - When `from` is zero, `amount` tokens of token type `id` will be minted

     * for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`

     * will be burned.

     * - `from` and `to` are never both zero.

     * - `ids` and `amounts` have the same, non-zero length.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    function _doSafeTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {

                if (response != IERC1155Receiver.onERC1155Received.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _doSafeBatchTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (

                bytes4 response

            ) {

                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non ERC1155Receiver implementer");

            }

        }

    }



    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {

        uint256[] memory array = new uint256[](1);

        array[0] = element;



        return array;

    }

}



contract PolkaBridgeNFT is ERC1155, Ownable {

    string public name = "PolkaBridge NFT";

    string public symbol = "PBRNFT";

    constructor(string memory _uri) ERC1155(_uri) {

        _setURI(_uri);

    }



    function setURI(string memory uri_) 

        public onlyOwner {

        _setURI(uri_);

    }



    function mintNFT(address recipient_, uint256 id_, uint256 amount_)

        public onlyOwner {    

        _mint(recipient_, id_, amount_, '');

    }



    function multiMintNFT(address recipient_, uint256[] memory ids_, uint256[] memory amounts_)

        public onlyOwner {

        _mintBatch(recipient_, ids_, amounts_, '');

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\PolkaBridgeStaking.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-05-31

*/



pragma solidity >=0.6.0;





interface IERC20 {

   

    function totalSupply() external view returns (uint256);



  

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);

    function transferWithoutDeflationary(address recipient, uint256 amount) external returns (bool) ;

   

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



library SafeMath {

   

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



   

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



   

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Converts an `address` into `address payable`. Note that this is

     * simply a type cast: the actual underlying value is not changed.

     *

     * _Available since v2.4.0._

     */

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     *

     * _Available since v2.4.0._

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves.



        // A Solidity high level call has three parts:

        //  1. The target address is checked to verify it contains contract code

        //  2. The call itself is made, and success asserted

        //  3. The return value is decoded, which in turn checks the size of the returned data.

        // solhint-disable-next-line max-line-length

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}



contract Context {

  

    constructor () internal { }



    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal virtual {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



contract PolkaBridgeStaking is Ownable {

    string public name = "PolkaBridge: Staking";

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    struct UserInfo {

        uint256 amount;

        uint256 rewardDebt;

        uint256 rewardClaimed;

        uint256 lastBlock;

        uint256 beginTime;

        uint256 endTime;

    }



    // Info of each pool.

    struct PoolInfo {

        IERC20 stakeToken;

        IERC20 rewardToken;

        uint256 allocPoint;

        uint256 lastRewardBlock;

        uint256 accTokenPerShare;

        uint256 rewardPerBlock;

        uint256 totalTokenStaked;

        uint256 totalTokenClaimed;

        uint256 endDate;

    }



    // Info of each pool.

    PoolInfo[] private poolInfo;



    mapping(uint256 => mapping(address => UserInfo)) public userInfo;

    uint256 public totalUser;



    // The block number when staking  starts.

    uint256 public startBlock;



    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);

    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);

    event EmergencyWithdraw(

        address indexed user,

        uint256 indexed pid,

        uint256 amount

    );



    constructor(uint256 _startBlock) public {

        startBlock = _startBlock;

    }



    function poolLength() external view returns (uint256) {

        return poolInfo.length;

    }



    function addPool(

        uint256 _allocPoint,

        IERC20 _stakeToken,

        IERC20 _rewardToken,

        uint256 _rewardPerBlock,

        uint256 _endDate,

        bool _withUpdate

    ) public onlyOwner {

        if (_withUpdate) {

            massUpdatePools();

        }

        uint256 _lastRewardBlock =

            block.number > startBlock ? block.number : startBlock;



        poolInfo.push(

            PoolInfo({

                stakeToken: _stakeToken,

                rewardToken: _rewardToken,

                allocPoint: _allocPoint,

                lastRewardBlock: _lastRewardBlock,

                accTokenPerShare: 0,

                rewardPerBlock: _rewardPerBlock,

                totalTokenStaked: 0,

                totalTokenClaimed: 0,

                endDate: _endDate

            })

        );

    }



    function setPool(

        uint256 _pid,

        uint256 _allocPoint,

        uint256 _rewardPerBlock,

        uint256 _endDate,

        bool _withUpdate

    ) public onlyOwner {

        if (_withUpdate) {

            massUpdatePools();

        }

        if (_allocPoint > 0) {

            poolInfo[_pid].allocPoint = _allocPoint;

        }

        if (_rewardPerBlock > 0) {

            poolInfo[_pid].rewardPerBlock = _rewardPerBlock;

        }

        if (_endDate > 0) {

            poolInfo[_pid].endDate = _endDate;

        }

    }



    // Return reward multiplier over the given _from to _to block.

    function getMultiplier(uint256 _fromBlock, uint256 _toBlock)

        public

        view

        returns (uint256)

    {

        return _toBlock.sub(_fromBlock);

    }



    function getTotalTokenStaked(uint256 _pid) public view returns (uint256) {

        PoolInfo storage pool = poolInfo[_pid];

        return pool.totalTokenStaked;

    }



    function pendingReward(uint256 _pid, address _user)

        external

        view

        returns (uint256)

    {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][_user];

        uint256 accTokenPerShare = pool.accTokenPerShare;

        uint256 totalTokenStaked = getTotalTokenStaked(_pid);



        if (block.number > pool.lastRewardBlock && totalTokenStaked > 0) {

            uint256 multiplier =

                getMultiplier(pool.lastRewardBlock, block.number); //number diff block

            uint256 tokenReward = multiplier.mul(pool.rewardPerBlock);



            accTokenPerShare = accTokenPerShare.add(

                tokenReward.mul(1e18).div(totalTokenStaked)

            );

        }

        return user.amount.mul(accTokenPerShare).div(1e18).sub(user.rewardDebt);

    }



    // Update reward variables for all pools. Be careful of gas spending!

    function massUpdatePools() public {

        uint256 length = poolInfo.length;

        for (uint256 pid = 0; pid < length; ++pid) {

            updatePool(pid);

        }

    }



    // Update reward variables of the given pool to be up-to-date.

    function updatePool(uint256 _pid) public {

        PoolInfo storage pool = poolInfo[_pid];

        if (block.number <= pool.lastRewardBlock) {

            return;

        }

        uint256 totalTokenStaked = getTotalTokenStaked(_pid);



        if (totalTokenStaked == 0 || pool.allocPoint == 0) {

            pool.lastRewardBlock = block.number;

            return;

        }



        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);

        uint256 tokenReward = multiplier.mul(pool.rewardPerBlock);



        pool.accTokenPerShare = pool.accTokenPerShare.add(

            tokenReward.mul(1e18).div(totalTokenStaked)

        );

        pool.lastRewardBlock = block.number;

    }



    function deposit(uint256 _pid, uint256 _amount) public {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];

        require(block.timestamp < pool.endDate, "staking pool already closed");



        updatePool(_pid);



        if (user.amount > 0) {

            uint256 pending =

                user.amount.mul(pool.accTokenPerShare).div(1e18).sub(

                    user.rewardDebt

                );

            if (pending > 0) {

                safeTokenTransfer(msg.sender, pending, _pid);

                pool.totalTokenClaimed = pool.totalTokenClaimed.add(pending);

                user.rewardClaimed = user.rewardClaimed.add(pending);

            }

        } else {

            //new user, or old user unstake all before

            totalUser = totalUser.add(1);

            user.beginTime = block.timestamp;

            user.endTime = 0; //reset endtime

        }

        if (_amount > 0) {

            pool.stakeToken.safeTransferFrom(

                address(msg.sender),

                address(this),

                _amount

            );

            user.amount = user.amount.add(_amount);

            pool.totalTokenStaked = pool.totalTokenStaked.add(_amount);

        }

        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e18);

        user.lastBlock = block.number;

        emit Deposit(msg.sender, _pid, _amount);

    }



    function withdraw(uint256 _pid, uint256 _amount) public {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];

        require(user.amount >= _amount, "withdraw: bad request");

        updatePool(_pid);

        uint256 pending =

            user.amount.mul(pool.accTokenPerShare).div(1e18).sub(

                user.rewardDebt

            );

        if (pending > 0) {

            safeTokenTransfer(msg.sender, pending, _pid);

            pool.totalTokenClaimed = pool.totalTokenClaimed.add(pending);

            user.rewardClaimed = user.rewardClaimed.add(pending);

        }

        if (_amount > 0) {

            user.amount = user.amount.sub(_amount);

            if (user.amount == 0) {

                user.endTime = block.timestamp;

            }

            pool.totalTokenStaked = pool.totalTokenStaked.sub(_amount);



            pool.stakeToken.safeTransfer(address(msg.sender), _amount);

        }

        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e18);

        user.lastBlock = block.number;

        emit Withdraw(msg.sender, _pid, _amount);

    }



    function emergencyWithdraw(uint256 _pid) public {

        PoolInfo storage pool = poolInfo[_pid];

        UserInfo storage user = userInfo[_pid][msg.sender];

        uint256 amount = user.amount;

        user.amount = 0;

        user.rewardDebt = 0;

        pool.stakeToken.safeTransfer(address(msg.sender), amount);

        emit EmergencyWithdraw(msg.sender, _pid, amount);

    }



    function safeTokenTransfer(

        address _to,

        uint256 _amount,

        uint256 _pid

    ) internal {

        PoolInfo storage pool = poolInfo[_pid];

        uint256 totalPoolReward = pool.allocPoint;



        if (_amount > totalPoolReward) {

            pool.rewardToken.transfer(_to, totalPoolReward);

        } else {

            pool.rewardToken.transfer(_to, _amount);

        }

    }



    function getPoolInfo(uint256 _pid)

        public

        view

        returns (

            uint256,

            uint256,

            uint256,

            uint256,

            uint256

        )

    {

        return (

            poolInfo[_pid].accTokenPerShare,

            poolInfo[_pid].lastRewardBlock,

            poolInfo[_pid].rewardPerBlock,

            poolInfo[_pid].totalTokenStaked,

            poolInfo[_pid].totalTokenClaimed

        );

    }



    function getDiffBlock(address user, uint256 pid)

        public

        view

        returns (uint256)

    {

        UserInfo memory user = userInfo[pid][user];

        return block.number.sub(user.lastBlock);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\PolkaBridgeTreasury.sol
File type: .sol
pragma solidity >=0.6.0;



import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";



import "@openzeppelin/contracts/ownership/Ownable.sol";



contract PolkaBridgeTreasury is Ownable {

    string public name = "PolkaBridge: Treasury";



    using SafeERC20 for IERC20;

    address payable private fundOwner;



    constructor(address payable _fundOwner) public {

        fundOwner = _fundOwner;

    }



    function withdrawToken(address asset) public onlyOwner {

        IERC20 token = IERC20(asset);

        token.safeTransfer(owner(), token.balanceOf(address(this)));

    }



    function withdrawFund() public onlyOwner {

        uint256 balance = address(this).balance;

        require(balance > 0);

        fundOwner.transfer(balance);

    }



    receive() external payable {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\ReentrancyGuard.sol
File type: .sol
pragma solidity >=0.6.0;



abstract contract ReentrancyGuard {

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    uint256 private _status;



    constructor() internal {

        _status = _NOT_ENTERED;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _status = _ENTERED;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _status = _NOT_ENTERED;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\RewardPool.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-01-22

*/



pragma solidity >=0.6.0;





contract Context {

  

    constructor () internal { }



    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



interface IERC20 {

   

    function totalSupply() external view returns (uint256);



  

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



   

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



library SafeMath {

   

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



   

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



   

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract ERC20 is Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;

    address private rewardPool;

    address private burnPool;

    address private tokenOwner;



    function initRewardContract(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        rewardPool=add;

    }

    function initBurnContract(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        burnPool=add;

    }

    

    function totalSupply() public view override returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



   

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



 

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



 

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



   

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



   

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);

        uint256 burnAmount;

        uint256 rewardAmount;

        (burnAmount,rewardAmount)=_caculateExtractAmount(amount);



        _balances[rewardPool] = _balances[rewardPool].add(rewardAmount);

        _balances[burnPool] = _balances[burnPool].add(burnAmount);



        

        uint256 newAmount=amount-burnAmount-rewardAmount;





        _balances[sender] = _balances[sender].sub(newAmount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(newAmount);

        emit Transfer(sender, recipient, newAmount);

    }



    

    function _deploy(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");

        tokenOwner = account;



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal virtual {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }



    function _caculateExtractAmount(uint256 amount) internal virtual returns(uint256,uint256) { }

}



contract ERC20Burnable is Context, ERC20 {

    

    function burn(uint256 amount) public virtual {

        _burn(_msgSender(), amount);

    }



  

    function burnFrom(address account, uint256 amount) public virtual {

        _burnFrom(account, amount);

    }

}



abstract contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;





    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



   

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}



contract PolkaBridge is ERC20, ERC20Detailed, ERC20Burnable {

    uint256 BeginExtract;



    constructor(uint256 initialSupply)

        public

        ERC20Detailed("PolkaBridge", "PBR", 18)

    {

        _deploy(msg.sender, initialSupply);

        BeginExtract = 1615766400; //15 Mar 2021 1615766400

    }



    function _caculateExtractAmount(uint256 amount)

        internal

        override

        returns (uint256, uint256)

    {

        if (block.timestamp > BeginExtract) {

            uint256 extractAmount = (amount * 5) / 1000;



            uint256 burnAmount = (extractAmount * 10) / 100;

            uint256 rewardAmount = (extractAmount * 90) / 100;



            return (burnAmount, rewardAmount);

        } else {

            return (0, 0);

        }

    }

}



contract RewardPool {

    using SafeMath for uint256;

    string public name = "RewardPool Contract";

    address payable private owner;



    PolkaBridge private polkaBridge;



    constructor(PolkaBridge _polkaBridge) public {

        polkaBridge = _polkaBridge;

        owner = msg.sender;

    }



    function tokenBalance() public view returns (uint256) {

        return polkaBridge.balanceOf(address(this));

    }



    ///withdraw token to pool reward

    function withdrawToken(address poolAddress, uint256 amount) public {

        require(

            msg.sender == owner,

            "RewardPool: only owner can withdraw token"

        );

        require(amount > 0, "RewardPool: not enough balance");

        require(amount <= tokenBalance(), "RewardPool: not enough balance");

        require(

            poolAddress != address(0),

            "RewardPool: transfer to the zero address"

        );



        polkaBridge.transfer(poolAddress, amount);

    }



    function depositETHtoContract() public payable {}



    function withdrawFund() public {

        require(msg.sender == owner, "only owner can withdraw");

        uint256 balance = address(this).balance;

        require(balance > 0, "not enough fund");

        owner.transfer(balance);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\SafeERC20.sol
File type: .sol
pragma solidity ^0.6.0;



import "./IERC20.sol";

import "../../math/SafeMath.sol";

import "../../utils/Address.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves.



        // A Solidity high level call has three parts:

        //  1. The target address is checked to verify it contains contract code

        //  2. The call itself is made, and success asserted

        //  3. The return value is decoded, which in turn checks the size of the returned data.

        // solhint-disable-next-line max-line-length

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\SafeMath.sol
File type: .sol
pragma solidity ^0.6.0;



library SafeMath {

   

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



   

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



   

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\Strings.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.8.0;



/**

 * @dev String operations.

 */

library Strings {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\SwapToken.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-03-16

*/



pragma solidity >=0.6.0;





contract Context {

  

    constructor () internal { }



    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



interface IERC20 {

   

    function totalSupply() external view returns (uint256);



  

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);

    function transferWithoutDeflationary(address recipient, uint256 amount) external returns (bool) ;

   

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



library SafeMath {

   

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



   

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



   

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract ERC20 is Context, IERC20 {

    using SafeMath for uint256;



    struct PoolAddress{

        address poolReward;

        bool isActive;

        bool isExist;



    }



    struct WhitelistTransfer{

        address waddress;

        bool isActived;

        string name;



    }

    mapping (address => uint256) private _balances;



    mapping (address => WhitelistTransfer) public whitelistTransfer;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;

    address[] rewardPool;

    mapping(address=>PoolAddress) mapRewardPool;

   

    address internal tokenOwner;

    uint256 internal beginFarming;



    function addRewardPool(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        require(!mapRewardPool[add].isExist,"Pool already exist");

        mapRewardPool[add].poolReward=add;

        mapRewardPool[add].isActive=true;

        mapRewardPool[add].isExist=true;

        rewardPool.push(add);

    }



    function addWhitelistTransfer(address add, string memory name) public{

         require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

         whitelistTransfer[add].waddress=add;

        whitelistTransfer[add].isActived=true;

        whitelistTransfer[add].name=name;



    }



     function removeWhitelistTransfer(address add) public{

         require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        

        whitelistTransfer[add].isActived=false;

        



    }







    function removeRewardPool(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        mapRewardPool[add].isActive=false;

       

        

    }



    function countActiveRewardPool() public  view returns (uint256){

        uint length=0;

     for(uint i=0;i<rewardPool.length;i++){

         if(mapRewardPool[rewardPool[i]].isActive){

             length++;

         }

     }

      return  length;

    }

   function getRewardPool(uint index) public view  returns (address){

    

        return rewardPool[index];

    }



   

    

    function totalSupply() public view override returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



   

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        if(whitelistTransfer[recipient].isActived || whitelistTransfer[_msgSender()].isActived){//withdraw from exchange will not effect

            _transferWithoutDeflationary(_msgSender(), recipient, amount);

        }

        else{

            _transfer(_msgSender(), recipient, amount);

        }

        

        return true;

    }

 function transferWithoutDeflationary(address recipient, uint256 amount) public virtual override returns (bool) {

        _transferWithoutDeflationary(_msgSender(), recipient, amount);

        return true;

    }

    

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



 

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



 

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



   

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



   

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);

        uint256 burnAmount;

        uint256 rewardAmount;

         uint totalActivePool=countActiveRewardPool();

         if (block.timestamp > beginFarming && totalActivePool>0) {

            (burnAmount,rewardAmount)=_caculateExtractAmount(amount);



        }     

        //div reward

        if(rewardAmount>0){

           

            uint eachPoolShare=rewardAmount.div(totalActivePool);

            for(uint i=0;i<rewardPool.length;i++){

                 if(mapRewardPool[rewardPool[i]].isActive){

                    _balances[rewardPool[i]] = _balances[rewardPool[i]].add(eachPoolShare);

                    emit Transfer(sender, rewardPool[i], eachPoolShare);



                 }

                

       

            }

        }





        //burn token

        if(burnAmount>0){

          _burn(sender,burnAmount);

            _balances[sender] = _balances[sender].add(burnAmount);//because sender balance already sub in burn



        }

      

        

        uint256 newAmount=amount-burnAmount-rewardAmount;



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

      

        _balances[recipient] = _balances[recipient].add(newAmount);

        emit Transfer(sender, recipient, newAmount);



        

        

    }

    

 function _transferWithoutDeflationary(address sender, address recipient, uint256 amount) internal virtual {

          require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

        

    }

    

    function _deploy(address account, uint256 amount,uint256 beginFarmingDate) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");

        tokenOwner = account;

        beginFarming=beginFarmingDate;



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal virtual {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }



    

    function _caculateExtractAmount(uint256 amount)

        internal

        

        returns (uint256, uint256)

    {

       

            uint256 extractAmount = (amount * 5) / 1000;



            uint256 burnAmount = (extractAmount * 10) / 100;

            uint256 rewardAmount = (extractAmount * 90) / 100;



            return (burnAmount, rewardAmount);

      

    }



    function setBeginDeflationFarming(uint256 beginDate) public {

        require(msg.sender == tokenOwner, "ERC20: Only owner can call");

        beginFarming = beginDate;

    }



    function getBeginDeflationary() public view returns (uint256) {

        return beginFarming;

    }



    



}



contract ERC20Burnable is Context, ERC20 {

    

    function burn(uint256 amount) public virtual {

        _burn(_msgSender(), amount);

    }



  

    function burnFrom(address account, uint256 amount) public virtual {

        _burnFrom(account, amount);

    }

}



abstract contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;





    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



   

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}



contract PolkaBridge is ERC20, ERC20Detailed, ERC20Burnable {

    constructor(uint256 initialSupply)

        public

        ERC20Detailed("PolkaBridge", "PBR", 18)

    {

        _deploy(msg.sender, initialSupply, 1616630400); //25 Mar 2021 1616630400

    }



    //withdraw contract token

    //use for someone send token to contract

    //recuse wrong user



    function withdrawErc20(IERC20 token) public {

        token.transfer(tokenOwner, token.balanceOf(address(this)));

    }

}



contract SwapToken {

    using SafeMath for uint256;

    string public name = "PolkaBridge: Swap from old PBR to new PBR";

    address payable private owner;



    address oldPBRAddress;



    PolkaBridge private polkaBridge;



    constructor(PolkaBridge _polkaBridge) public {

        polkaBridge = _polkaBridge;

        owner = msg.sender;

    }



    function swapOldPBRToNewPBR(uint256 amount) public {

        require(amount > 0, "amount must to > 0");

        require(amount <= tokenContractBalance(), "exceeds amount limit");

        require(amount <= oldTokenBalance(msg.sender), "not enough balance");



        ERC20Burnable(oldPBRAddress).burnFrom(msg.sender, amount);

        //send new POBR token

        polkaBridge.transferWithoutDeflationary(msg.sender, amount);

    }



    function tokenContractBalance() public view returns (uint256) {

        return polkaBridge.balanceOf(address(this));

    }



    function oldTokenBalance(address add) public view returns (uint256) {

        return ERC20Burnable(oldPBRAddress).balanceOf(add);

    }



    function oldTokenAddress() public view returns (address) {

        return oldPBRAddress;

    }



    function burnAllToken() public {

        require(msg.sender == owner, "only owner can burn");



        polkaBridge.burn(tokenContractBalance());

    }



    function burnToken(uint256 amount) public {

        require(msg.sender == owner, "only owner can burn");



        polkaBridge.burn(amount);

    }



    function withdrawFund() public {

        require(msg.sender == owner, "only owner can withdraw");

        uint256 balance = address(this).balance;

        require(balance > 0, "not enough fund");

        owner.transfer(balance);

    }



    //withdraw contract token

    //use for someone send token to contract

    //recuse wrong user



    function withdrawErc20(IERC20 token) public {

        token.transfer(owner, token.balanceOf(address(this)));

    }



    function setOldPBRAddress(address add) public {

        require(msg.sender == owner, "only owner can do it");

        oldPBRAddress = add;

    }



    receive() external payable {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\TokenRelease.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-03-16

*/



pragma solidity >=0.6.0;





library SafeMath {

   

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



   

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



   

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



contract Context {

  

    constructor () internal { }



    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



interface IERC20 {

   

    function totalSupply() external view returns (uint256);



  

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);

    function transferWithoutDeflationary(address recipient, uint256 amount) external returns (bool) ;

   

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



contract ERC20 is Context, IERC20 {

    using SafeMath for uint256;



    struct PoolAddress{

        address poolReward;

        bool isActive;

        bool isExist;



    }



    struct WhitelistTransfer{

        address waddress;

        bool isActived;

        string name;



    }

    mapping (address => uint256) private _balances;



    mapping (address => WhitelistTransfer) public whitelistTransfer;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;

    address[] rewardPool;

    mapping(address=>PoolAddress) mapRewardPool;

   

    address internal tokenOwner;

    uint256 internal beginFarming;



    function addRewardPool(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        require(!mapRewardPool[add].isExist,"Pool already exist");

        mapRewardPool[add].poolReward=add;

        mapRewardPool[add].isActive=true;

        mapRewardPool[add].isExist=true;

        rewardPool.push(add);

    }



    function addWhitelistTransfer(address add, string memory name) public{

         require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

         whitelistTransfer[add].waddress=add;

        whitelistTransfer[add].isActived=true;

        whitelistTransfer[add].name=name;



    }



     function removeWhitelistTransfer(address add) public{

         require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        

        whitelistTransfer[add].isActived=false;

        



    }







    function removeRewardPool(address add) public {

        require(_msgSender() == tokenOwner, "ERC20: Only owner can init");

        mapRewardPool[add].isActive=false;

       

        

    }



    function countActiveRewardPool() public  view returns (uint256){

        uint length=0;

     for(uint i=0;i<rewardPool.length;i++){

         if(mapRewardPool[rewardPool[i]].isActive){

             length++;

         }

     }

      return  length;

    }

   function getRewardPool(uint index) public view  returns (address){

    

        return rewardPool[index];

    }



   

    

    function totalSupply() public view override returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



   

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        if(whitelistTransfer[recipient].isActived || whitelistTransfer[_msgSender()].isActived){//withdraw from exchange will not effect

            _transferWithoutDeflationary(_msgSender(), recipient, amount);

        }

        else{

            _transfer(_msgSender(), recipient, amount);

        }

        

        return true;

    }

 function transferWithoutDeflationary(address recipient, uint256 amount) public virtual override returns (bool) {

        _transferWithoutDeflationary(_msgSender(), recipient, amount);

        return true;

    }

    

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



 

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



 

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



   

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



   

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);

        uint256 burnAmount;

        uint256 rewardAmount;

         uint totalActivePool=countActiveRewardPool();

         if (block.timestamp > beginFarming && totalActivePool>0) {

            (burnAmount,rewardAmount)=_caculateExtractAmount(amount);



        }     

        //div reward

        if(rewardAmount>0){

           

            uint eachPoolShare=rewardAmount.div(totalActivePool);

            for(uint i=0;i<rewardPool.length;i++){

                 if(mapRewardPool[rewardPool[i]].isActive){

                    _balances[rewardPool[i]] = _balances[rewardPool[i]].add(eachPoolShare);

                    emit Transfer(sender, rewardPool[i], eachPoolShare);



                 }

                

       

            }

        }





        //burn token

        if(burnAmount>0){

          _burn(sender,burnAmount);

            _balances[sender] = _balances[sender].add(burnAmount);//because sender balance already sub in burn



        }

      

        

        uint256 newAmount=amount-burnAmount-rewardAmount;



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

      

        _balances[recipient] = _balances[recipient].add(newAmount);

        emit Transfer(sender, recipient, newAmount);



        

        

    }

    

 function _transferWithoutDeflationary(address sender, address recipient, uint256 amount) internal virtual {

          require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

        

    }

    

    function _deploy(address account, uint256 amount,uint256 beginFarmingDate) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");

        tokenOwner = account;

        beginFarming=beginFarmingDate;



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _burnFrom(address account, uint256 amount) internal virtual {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }



    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }



    

    function _caculateExtractAmount(uint256 amount)

        internal

        

        returns (uint256, uint256)

    {

       

            uint256 extractAmount = (amount * 5) / 1000;



            uint256 burnAmount = (extractAmount * 10) / 100;

            uint256 rewardAmount = (extractAmount * 90) / 100;



            return (burnAmount, rewardAmount);

      

    }



    function setBeginDeflationFarming(uint256 beginDate) public {

        require(msg.sender == tokenOwner, "ERC20: Only owner can call");

        beginFarming = beginDate;

    }



    function getBeginDeflationary() public view returns (uint256) {

        return beginFarming;

    }



    



}



contract ERC20Burnable is Context, ERC20 {

    

    function burn(uint256 amount) public virtual {

        _burn(_msgSender(), amount);

    }



  

    function burnFrom(address account, uint256 amount) public virtual {

        _burnFrom(account, amount);

    }

}



abstract contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;





    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



   

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}



contract PolkaBridge is ERC20, ERC20Detailed, ERC20Burnable {

    constructor(uint256 initialSupply)

        public

        ERC20Detailed("PolkaBridge", "PBR", 18)

    {

        _deploy(msg.sender, initialSupply, 1616630400); //25 Mar 2021 1616630400

    }



    //withdraw contract token

    //use for someone send token to contract

    //recuse wrong user



    function withdrawErc20(IERC20 token) public {

        token.transfer(tokenOwner, token.balanceOf(address(this)));

    }

}



contract TokenRelease {

    using SafeMath for uint256;

    PolkaBridge private _polkaBridge;

    event TokensReleased(address beneficiary, uint256 amount);

    address payable private owner;

    // beneficiary of tokens after they are released

    string public name = "PolkaBridge: Token Vesting";



    struct Vesting {

        string Name;

        address Beneficiary;

        uint256 Cliff;

        uint256 Start;

        uint256 AmountReleaseInOne;

        uint256 MaxRelease;

        bool IsExist;

    }

    mapping(address => Vesting) private _vestingList;



    constructor(

        PolkaBridge polkaBridge,

        address team,

        address marketing,

        address eco,

        uint256 cliffTeam,

        uint256 cliffMarketing,

        uint256 cliffEco,

        uint256 amountReleaseInOneTeam,

        uint256 amountReleaseInOneMarketing,

        uint256 amountReleaseInOneEco,

        uint256 maxReleaseTeam,

        uint256 maxReleaseMarketing,

        uint256 maxReleaseEco

    ) public {

        _polkaBridge = polkaBridge;

        _vestingList[team].Name = "Team Fund";

        _vestingList[team].Beneficiary = team;

        _vestingList[team].Cliff = cliffTeam;

        _vestingList[team].Start = 1611248400; //22 jan 2021

        _vestingList[team].AmountReleaseInOne = amountReleaseInOneTeam;

        _vestingList[team].MaxRelease = maxReleaseTeam;

        _vestingList[team].IsExist = true;



        _vestingList[marketing].Name = "Marketing Fund";

        _vestingList[marketing].Beneficiary = marketing;

        _vestingList[marketing].Cliff = cliffMarketing;

        _vestingList[marketing].Start = 1613952000; //22 Feb 2021

        _vestingList[marketing]

            .AmountReleaseInOne = amountReleaseInOneMarketing;

        _vestingList[marketing].MaxRelease = maxReleaseMarketing;

        _vestingList[marketing].IsExist = true;



        _vestingList[eco].Name = "Ecosystem Fund";

        _vestingList[eco].Beneficiary = eco;

        _vestingList[eco].Cliff = cliffEco;

        _vestingList[eco].Start = 1613952000; //22 Feb 2021

        _vestingList[eco].AmountReleaseInOne = amountReleaseInOneEco;

        _vestingList[eco].MaxRelease = maxReleaseEco;

        _vestingList[eco].IsExist = true;



        owner = msg.sender;

    }



    function depositETHtoContract() public payable {}



    function addLockingFund(

        string memory name,

        address beneficiary,

        uint256 cliff,

        uint256 start,

        uint256 amountReleaseInOne,

        uint256 maxRelease

    ) public {

        require(msg.sender == owner, "only owner can addLockingFund");

        _vestingList[beneficiary].Name = name;

        _vestingList[beneficiary].Beneficiary = beneficiary;

        _vestingList[beneficiary].Cliff = cliff;

        _vestingList[beneficiary].Start = start;

        _vestingList[beneficiary].AmountReleaseInOne = amountReleaseInOne;

        _vestingList[beneficiary].MaxRelease = maxRelease;

        _vestingList[beneficiary].IsExist = true;

    }



    function beneficiary(address acc) public view returns (address) {

        return _vestingList[acc].Beneficiary;

    }



    function cliff(address acc) public view returns (uint256) {

        return _vestingList[acc].Cliff;

    }



    function start(address acc) public view returns (uint256) {

        return _vestingList[acc].Start;

    }



    function amountReleaseInOne(address acc) public view returns (uint256) {

        return _vestingList[acc].AmountReleaseInOne;

    }



    function getNumberCycle(address acc) public view returns (uint256) {

        return

            (block.timestamp.sub(_vestingList[acc].Start)).div(

                _vestingList[acc].Cliff

            );

    }



    function getRemainBalance() public view returns (uint256) {

        return _polkaBridge.balanceOf(address(this));

    }



    function getRemainUnlockAmount(address acc) public view returns (uint256) {

        return _vestingList[acc].MaxRelease;

    }



    function isValidBeneficiary(address _wallet) public view returns (bool) {

        return _vestingList[_wallet].IsExist;

    }



    function release(address acc) public {

        require(acc != address(0), "TokenRelease: address 0 not allow");

        require(

            isValidBeneficiary(acc),

            "TokenRelease: invalid release address"

        );



        require(

            _vestingList[acc].MaxRelease > 0,

            "TokenRelease: no more token to release"

        );



        uint256 unreleased = _releasableAmount(acc);



        require(unreleased > 0, "TokenRelease: no tokens are due");



        _polkaBridge.transfer(_vestingList[acc].Beneficiary, unreleased);

        _vestingList[acc].MaxRelease -= unreleased;



        emit TokensReleased(_vestingList[acc].Beneficiary, unreleased);

    }



    function _releasableAmount(address acc) private returns (uint256) {

        uint256 currentBalance = _polkaBridge.balanceOf(address(this));

        if (currentBalance <= 0) return 0;

        uint256 amountRelease = 0;

        //require(_start.add(_cliff) < block.timestamp, "not that time");

        if (

            _vestingList[acc].Start.add(_vestingList[acc].Cliff) >

            block.timestamp

        ) {

            //not on time



            amountRelease = 0;

        } else {

            uint256 numberCycle = getNumberCycle(acc);

            if (numberCycle > 0) {

                amountRelease =

                    numberCycle *

                    _vestingList[acc].AmountReleaseInOne;

            } else {

                amountRelease = 0;

            }



            _vestingList[acc].Start = block.timestamp; //update start

        }

        return amountRelease;

    }



    function withdrawEtherFund() public {

        require(msg.sender == owner, "only owner can withdraw");

        uint256 balance = address(this).balance;

        require(balance > 0, "not enough fund");

        owner.transfer(balance);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\TransferHelper.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-or-later



pragma solidity >=0.6.0;



// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false

library TransferHelper {

    function safeApprove(

        address token,

        address to,

        uint256 value

    ) internal {

        // bytes4(keccak256(bytes('approve(address,uint256)')));

        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));

        require(

            success && (data.length == 0 || abi.decode(data, (bool))),

            'TransferHelper::safeApprove: approve failed'

        );

    }



    function safeTransfer(

        address token,

        address to,

        uint256 value

    ) internal {

        // bytes4(keccak256(bytes('transfer(address,uint256)')));

        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));

        require(

            success && (data.length == 0 || abi.decode(data, (bool))),

            'TransferHelper::safeTransfer: transfer failed'

        );

    }



    function safeTransferFrom(

        address token,

        address from,

        address to,

        uint256 value

    ) internal {

        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));

        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));

        require(

            success && (data.length == 0 || abi.decode(data, (bool))),

            'TransferHelper::transferFrom: transferFrom failed'

        );

    }



    function safeTransferETH(address to, uint256 value) internal {

        (bool success, ) = to.call{value: value}(new bytes(0));

        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\UniswapV2ERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;



import './interfaces/IUniswapV2ERC20.sol';



contract UniswapV2ERC20 is IUniswapV2ERC20 {



    string public override constant name = 'PolkaBridge AMM';

    string public override constant symbol = 'PBRAMM';

    uint8 public override constant decimals = 18;

    uint  public override totalSupply;

    mapping(address => uint) public override balanceOf;

    mapping(address => mapping(address => uint)) public override allowance;



    bytes32 public override DOMAIN_SEPARATOR;

    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");

    bytes32 public override constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    mapping(address => uint) public override nonces;



    constructor() {

        uint chainId;

        assembly {

            chainId := chainid()

        }

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),

                keccak256(bytes(name)),

                keccak256(bytes('1')),

                chainId,

                address(this)

            )

        );

    }



    function _mint(address to, uint value) internal {

        totalSupply = totalSupply + value;

        balanceOf[to] = balanceOf[to] + value;

        emit Transfer(address(0), to, value);

    }



    function _burn(address from, uint value) internal {

        balanceOf[from] = balanceOf[from] - value;

        totalSupply = totalSupply - value;

        emit Transfer(from, address(0), value);

    }



    function _approve(address owner, address spender, uint value) private {

        allowance[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    function _transfer(address from, address to, uint value) private {

        balanceOf[from] = balanceOf[from] - value;

        balanceOf[to] = balanceOf[to] + value;

        emit Transfer(from, to, value);

    }



    function approve(address spender, uint value) external override returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    function transfer(address to, uint value) external override returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    function transferFrom(address from, address to, uint value) external override returns (bool) {

        if (allowance[from][msg.sender] != uint(int(-1))) {

            allowance[from][msg.sender] = allowance[from][msg.sender] - value;

        }

        _transfer(from, to, value);

        return true;

    }



    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {

        require(deadline >= block.timestamp, 'PolkaBridge AMM: EXPIRED');

        bytes32 digest = keccak256(

            abi.encodePacked(

                '\x19\x01',

                DOMAIN_SEPARATOR,

                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))

            )

        );

        address recoveredAddress = ecrecover(digest, v, r, s);

        require(recoveredAddress != address(0) && recoveredAddress == owner, 'PolkaBridge AMM: INVALID_SIGNATURE');

        _approve(owner, spender, value);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\UniswapV2Factory.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;



import './interfaces/IUniswapV2Factory.sol';

import './UniswapV2Pair.sol';



contract UniswapV2Factory is IUniswapV2Factory {

    // address public override feeTo;

    address owner;

    string public name = 'PolkaBridgeAMM: Factory';

    address treasury;



    mapping(address => mapping(address => address)) public override getPair;

    // address[] public allPairs; // storage of all pairs

    bytes32 public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(UniswapV2Pair).creationCode));



    uint256 public override allPairs;

    uint256 releaseTime;

    uint256 lockTime = 2 days;



    constructor(address _owner, address _treasury) {

        owner = _owner;

        treasury = _treasury;

        releaseTime = block.timestamp;

    }



    // function allPairsLength() external view override returns (uint256) {

    //     // return pair length

    //     // return allPairs.length;

    //     return allPairs;

    // }



    function createPair(address tokenA, address tokenB) external override returns (address pair) {

        require(tokenA != tokenB, 'PolkaBridge AMM: IDENTICAL_ADDRESSES');

        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);

        require(token0 != address(0), 'PolkaBridge AMM: ZERO_ADDRESS');

        require(getPair[token0][token1] == address(0), 'PolkaBridge AMM: PAIR_EXISTS'); // single check is sufficient

        bytes memory bytecode = type(UniswapV2Pair).creationCode;

        bytes32 salt = keccak256(abi.encodePacked(token0, token1));

        assembly {

            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)

        }

        IUniswapV2Pair(pair).initialize(token0, token1, treasury); //, owner, treasury);

        getPair[token0][token1] = pair;

        getPair[token1][token0] = pair; // populate mapping in the reverse direction

        // allPairs.push(pair);

        allPairs++;



        emit PairCreated(token0, token1, pair, allPairs);

    }



    function setTreasuryAddress(address _treasury) external override {

        require(msg.sender == owner, 'Only owner can set treasury');

        {

            require(block.timestamp - releaseTime >= lockTime, 'current time is before release time');

            treasury = _treasury;

            releaseTime = block.timestamp;

            emit TreasurySet(_treasury);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\UniswapV2Library.sol
File type: .sol
pragma solidity 0.6.6;



// import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

import '../interfaces/IUniswapV2Pair.sol';



import './SafeMath.sol';



library UniswapV2Library {

    using SafeMath for uint256;



    // returns sorted token addresses, used to handle return values from pairs sorted in this order

    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {

        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');

        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);

        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');

    }



    // calculates the CREATE2 address for a pair without making any external calls

    function pairFor(

        address factory,

        address tokenA,

        address tokenB

    ) internal pure returns (address pair) {

        (address token0, address token1) = sortTokens(tokenA, tokenB);

        pair = address(

            uint256(

                keccak256(

                    abi.encodePacked(

                        hex'ff',

                        factory,

                        keccak256(abi.encodePacked(token0, token1)),

                        hex'8b59d0fbd3a2da5e26f61e1d4b91f355d2c382ec32c993635b0d80dce6e1ef1c' // init code hash of factory

                    )

                )

            )

        );

    }



    // fetches and sorts the reserves for a pair

    function getReserves(

        address factory,

        address tokenA,

        address tokenB

    ) internal view returns (uint256 reserveA, uint256 reserveB) {

        (address token0, ) = sortTokens(tokenA, tokenB);

        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();

        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);

    }



    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset

    function quote(

        uint256 amountA,

        uint256 reserveA,

        uint256 reserveB

    ) internal pure returns (uint256 amountB) {

        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');

        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');

        amountB = amountA.mul(reserveB) / reserveA;

    }



    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset

    function getAmountOut(

        uint256 amountIn,

        uint256 reserveIn,

        uint256 reserveOut

    ) internal pure returns (uint256 amountOut) {

        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');

        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');

        uint256 amountInWithFee = amountIn.mul(998);

        // uint256 amountInWithFee = amountIn.mul(9984);

        uint256 numerator = amountInWithFee.mul(reserveOut);

        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);

        amountOut = numerator / denominator;

    }



    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset

    function getAmountIn(

        uint256 amountOut,

        uint256 reserveIn,

        uint256 reserveOut

    ) internal pure returns (uint256 amountIn) {

        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');

        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');

        // uint256 numerator = reserveIn.mul(amountOut).mul(10000);

        uint256 numerator = reserveIn.mul(amountOut).mul(1000);

        // uint256 denominator = reserveOut.sub(amountOut).mul(9984);

        uint256 denominator = reserveOut.sub(amountOut).mul(998);



        amountIn = (numerator / denominator).add(1);

    }



    // performs chained getAmountOut calculations on any number of pairs

    function getAmountsOut(

        address factory,

        uint256 amountIn,

        address[] memory path

    ) internal view returns (uint256[] memory amounts) {

        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');

        amounts = new uint256[](path.length);

        amounts[0] = amountIn;

        for (uint256 i; i < path.length - 1; i++) {

            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);

            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);

        }

    }



    // performs chained getAmountIn calculations on any number of pairs

    function getAmountsIn(

        address factory,

        uint256 amountOut,

        address[] memory path

    ) internal view returns (uint256[] memory amounts) {

        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');

        amounts = new uint256[](path.length);

        amounts[amounts.length - 1] = amountOut;

        for (uint256 i = path.length - 1; i > 0; i--) {

            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);

            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\UniswapV2Pair.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;



import './interfaces/IUniswapV2Pair.sol';

import './UniswapV2ERC20.sol';

import './libraries/Math.sol';

import './libraries/UQ112x112.sol';

import './interfaces/IERC20.sol';

import './interfaces/IUniswapV2Factory.sol';



contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {

    using UQ112x112 for uint224;

    // string public name = 'PolkaBridgeAMM: Pair';

    // uint256 public constant override MINIMUM_LIQUIDITY = 10**3;

    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));



    address public override factory;

    address public override token0;

    address public override token1;



    // address ownerAddress;



    address treasury;



    uint112 private reserve0; // uses single storage slot, accessible via getReserves

    uint112 private reserve1; // uses single storage slot, accessible via getReserves

    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves



    uint public override price0CumulativeLast;

    uint public override price1CumulativeLast;

    // uint public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event



    uint256 private unlocked = 1;

    uint256 private releaseTime;

    uint256 private lockTime = 2 days;



    modifier lock() {

        require(unlocked == 1, 'PolkaBridge AMM: LOCKED');

        unlocked = 0;

        _;

        unlocked = 1;

    }



    function getReserves()

        public

        view

        override

        returns (

            uint112 _reserve0,

            uint112 _reserve1,

            uint32 _blockTimestampLast

        )

    {

        _reserve0 = reserve0;

        _reserve1 = reserve1;

        _blockTimestampLast = blockTimestampLast;

    }



    function _safeTransfer(

        address token,

        address to,

        uint256 value

    ) private {

        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));

        require(success && (data.length == 0 || abi.decode(data, (bool))), 'PolkaBridge AMM: TRANSFER_FAILED');

    }



    constructor() {

        factory = msg.sender;

    }



    // called once by the factory at time of deployment

    function initialize(address _token0, address _token1, address _treasury) external override {

        require(msg.sender == factory, 'PolkaBridge AMM: FORBIDDEN'); // sufficient check

        token0 = _token0;

        token1 = _token1;

        // ownerAddress = _owner;

        treasury = _treasury;

    }



    // force reserves to match balances

    function sync() external override lock {

        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);

    }



    // update reserves and, on the first call per block, price accumulators

    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {

        require(balance0 <= uint112(int112(-1)) && balance1 <= uint112(int112(-1)), 'PolkaBridge AMM: OVERFLOW');

        uint32 blockTimestamp = uint32(block.timestamp % 2**32);

        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired

        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {

            // * never overflows, and + overflow is desired

            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;

            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;

        }

        reserve0 = uint112(balance0);

        reserve1 = uint112(balance1);

        blockTimestampLast = blockTimestamp;

        emit Sync(reserve0, reserve1);

    }



    // this low-level function should be called from a contract which performs important safety checks

    function mint(address to) external override lock returns (uint256 liquidity) {

        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings

        uint256 balance0 = IERC20(token0).balanceOf(address(this));

        uint256 balance1 = IERC20(token1).balanceOf(address(this));

        uint256 amount0 = balance0 - _reserve0;

        uint256 amount1 = balance1 - _reserve1;



        // bool feeOn = false;//_mintFee(_reserve0, _reserve1);

        // uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

        if (totalSupply == 0) {

            liquidity = Math.sqrt(amount0 * amount1);// - MINIMUM_LIQUIDITY;

            // _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens

        } else {

            liquidity = Math.min(amount0 * totalSupply / _reserve0, amount1 * totalSupply / _reserve1);

        }

        require(liquidity > 0, 'PolkaBridge AMM: INSUFFICIENT_LIQUIDITY_MINTED');

        _mint(to, liquidity);



        _update(balance0, balance1, _reserve0, _reserve1);

        // if (feeOn) kLast = uint(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date

        emit Mint(msg.sender, amount0, amount1);

    }



    // this low-level function should be called from a contract which performs important safety checks

    function burn(address to) external override lock returns (uint256 amount0, uint256 amount1) {

        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings

        address _token0 = token0; // gas savings

        address _token1 = token1; // gas savings

        uint256 balance0 = IERC20(_token0).balanceOf(address(this));

        uint256 balance1 = IERC20(_token1).balanceOf(address(this));

        uint256 liquidity = balanceOf[address(this)];



        // bool feeOn = _mintFee(_reserve0, _reserve1);

        // uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

        amount0 = liquidity * balance0 / totalSupply; // using balances ensures pro-rata distribution

        amount1 = liquidity * balance1 / totalSupply; // using balances ensures pro-rata distribution

        require(amount0 > 0 && amount1 > 0, 'PolkaBridge AMM: INSUFFICIENT_LIQUIDITY_BURNED');

        _burn(address(this), liquidity);

        _safeTransfer(_token0, to, amount0);

        _safeTransfer(_token1, to, amount1);

        balance0 = IERC20(_token0).balanceOf(address(this));

        balance1 = IERC20(_token1).balanceOf(address(this));



        _update(balance0, balance1, _reserve0, _reserve1);

        // if (feeOn) kLast = uint(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date

        emit Burn(msg.sender, amount0, amount1, to);

    }



    // this low-level function should be called from a contract which performs important safety checks

    function swap(uint amount0Out, uint amount1Out, address to) external override lock {

        require(amount0Out > 0 || amount1Out > 0, 'PolkaBridge AMM: INSUFFICIENT_OUTPUT_AMOUNT');

        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'PolkaBridge AMM: INSUFFICIENT_LIQUIDITY');



        uint256 balance0;

        uint256 balance1;

        {

            // scope for _token{0,1}, avoids stack too deep errors

            // address _token0 = token0;

            // address _token1 = token1;

            require(to != token0 && to != token1, 'PolkaBridge AMM: INVALID_TO');



            if (amount0Out > 0) _safeTransfer(token0, to, amount0Out); // optimistically transfer tokens

            if (amount1Out > 0) _safeTransfer(token1, to, amount1Out); // optimistically transfer tokens

            balance0 = IERC20(token0).balanceOf(address(this));

            balance1 = IERC20(token1).balanceOf(address(this));

        }

        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;

        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;

        require(amount0In > 0 || amount1In > 0, 'PolkaBridge AMM: INSUFFICIENT_INPUT_AMOUNT');

        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors

            uint balance0Adjusted = balance0 * 1000 - amount0In * 2;

            uint balance1Adjusted = balance1 * 1000 - amount1In * 2;

            // require(false, string(abi.encodePacked(uint2str(_reserve0), ' : ', uint2str(_reserve1), ' : ', uint2str(balance0), ' : ', uint2str(balance1), ' : ', uint2str(amount0In), ' : ', uint2str(amount1In))));

            require(balance0Adjusted * balance1Adjusted >= uint(_reserve0) * _reserve1 * (1000**2), 'PolkaBridge AMM: K');

        }



        uint256 amount0Treasury = amount0In / 2500; // amount0In * 4 / 10000;

        uint256 amount1Treasury = amount1In / 2500; // amount1In * 4 / 10000;

        if (amount0Treasury > 0) {

            require(treasury != address(0), 'Treasury address error');

            _safeTransfer(token0, treasury, amount0Treasury);

            balance0 = balance0 - amount0Treasury;

        }

        if (amount1Treasury > 0) {

            require(treasury != address(0), 'Treasury address error');

            _safeTransfer(token1, treasury, amount1Treasury);

            balance1 = balance1 - amount1Treasury;

        }



        _update(balance0, balance1, _reserve0, _reserve1);

        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);

    }



}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\UniswapV2Router02.sol
File type: .sol
pragma solidity =0.6.6;



// import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';

import './interfaces/IUniswapV2Pair.sol';

import './interfaces/IUniswapV2Factory.sol';

import '@uniswap/lib/contracts/libraries/TransferHelper.sol';



import './interfaces/IUniswapV2Router02.sol';

import './libraries/UniswapV2Library.sol';

import './libraries/SafeMath.sol';

import './interfaces/IERC20.sol';

import './interfaces/IWETH.sol';



contract UniswapV2Router02 is IUniswapV2Router02 {

    using SafeMath for uint256;

    // string public name = 'PolkaBridgeAMM: Router';

    address public immutable override factory;

    address public immutable override WETH;

    // address public owner;

    // string public debugStr;



    modifier ensure(uint256 deadline) {

        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');

        _;

    }



    // modifier onlyOwner() {

    //     require(msg.sender == owner, 'Only Owner');

    //     _;

    // }

    constructor(address _factory, address _WETH) public {

        factory = _factory;

        WETH = _WETH;

        // owner = msg.sender;

    }



    receive() external payable {

        require(msg.sender == WETH, 'transfer ETH from unexpected sender'); // only accept ETH via fallback from the WETH contract

    }



    // function transferOwnership(address _new_owner) public onlyOwner {

    //     owner = _new_owner;

    // }



    // **** ADD LIQUIDITY ****

    function _addLiquidity(

        address tokenA,

        address tokenB,

        uint256 amountADesired,

        uint256 amountBDesired,

        uint256 amountAMin,

        uint256 amountBMin

    ) internal virtual returns (uint256 amountA, uint256 amountB) {

        // create the pair if it doesn't exist yet

        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {

            IUniswapV2Factory(factory).createPair(tokenA, tokenB);

        }

        (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);

        if (reserveA == 0 && reserveB == 0) {

            (amountA, amountB) = (amountADesired, amountBDesired);

        } else {

            uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);

            if (amountBOptimal <= amountBDesired) {

                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');

                (amountA, amountB) = (amountADesired, amountBOptimal);

            } else {

                uint256 amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);

                require(amountAOptimal <= amountADesired, 'amountA should less or equal than amountB'); // assert(amountAOptimal <= amountADesired);

                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');

                (amountA, amountB) = (amountAOptimal, amountBDesired);

            }

        }

    }



    function addLiquidity(

        address tokenA,

        address tokenB,

        uint256 amountADesired,

        uint256 amountBDesired,

        uint256 amountAMin,

        uint256 amountBMin,

        address to,

        uint256 deadline

    )

        external

        virtual

        override

        ensure(deadline)

        returns (

            uint256 amountA,

            uint256 amountB,

            uint256 liquidity

        )

    {

        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);

        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);



        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);

        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);

        liquidity = IUniswapV2Pair(pair).mint(to);

    }



    function addLiquidityETH(

        address token,

        uint256 amountTokenDesired,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline

    )

        external

        payable

        virtual

        override

        ensure(deadline)

        returns (

            uint256 amountToken,

            uint256 amountETH,

            uint256 liquidity

        )

    {

        (amountToken, amountETH) = _addLiquidity(

            token,

            WETH,

            amountTokenDesired,

            msg.value,

            amountTokenMin,

            amountETHMin

        );

        address pair = UniswapV2Library.pairFor(factory, token, WETH);

        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);

        IWETH(WETH).deposit{value: amountETH}();

        require(IWETH(WETH).transfer(pair, amountETH), 'WETH transfer failed in addLiquidityETH'); // assert(IWETH(WETH).transfer(pair, amountETH));

        liquidity = IUniswapV2Pair(pair).mint(to);

        // refund dust eth, if any

        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);

    }



    // **** REMOVE LIQUIDITY ****

    function removeLiquidity(

        address tokenA,

        address tokenB,

        uint256 liquidity,

        uint256 amountAMin,

        uint256 amountBMin,

        address to,

        uint256 deadline

    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {

        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);

        bool bTransfered = IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity);

        require(bTransfered, 'Failed in sending liquidity to pair'); // send liquidity to pair

        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(to);

        (address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);

        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);

        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');

        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');

    }



    function removeLiquidityETH(

        address token,

        uint256 liquidity,

        uint256 amountTokenMin,

        uint256 amountETHMin,

        address to,

        uint256 deadline

    ) external virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {

        (amountToken, amountETH) = removeLiquidity(

            token,

            WETH,

            liquidity,

            amountTokenMin,

            amountETHMin,

            address(this),

            deadline

        );

        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));

        IWETH(WETH).withdraw(amountETH);

        TransferHelper.safeTransferETH(to, amountETH);

    }



    // function removeLiquidityWithPermit(

    //     address tokenA,

    //     address tokenB,

    //     uint256 liquidity,

    //     uint256 amountAMin,

    //     uint256 amountBMin,

    //     address to,

    //     uint256 deadline,

    //     bool approveMax,

    //     uint8 v,

    //     bytes32 r,

    //     bytes32 s

    // ) external virtual override returns (uint256 amountA, uint256 amountB) {

    //     address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);

    //     uint256 value = approveMax ? uint256(-1) : liquidity;

    //     IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);

    //     (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);

    // }



    // function removeLiquidityETHWithPermit(

    //     address token,

    //     uint256 liquidity,

    //     uint256 amountTokenMin,

    //     uint256 amountETHMin,

    //     address to,

    //     uint256 deadline,

    //     bool approveMax,

    //     uint8 v,

    //     bytes32 r,

    //     bytes32 s

    // ) external virtual override returns (uint256 amountToken, uint256 amountETH) {

    //     address pair = UniswapV2Library.pairFor(factory, token, WETH);

    //     uint256 value = approveMax ? uint256(-1) : liquidity;

    //     IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);

    //     (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);

    // }



    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****

    // function removeLiquidityETHSupportingFeeOnTransferTokens(

    //     address token,

    //     uint256 liquidity,

    //     uint256 amountTokenMin,

    //     uint256 amountETHMin,

    //     address to,

    //     uint256 deadline

    // ) public virtual override ensure(deadline) returns (uint256 amountETH) {

    //     // (, amountETH) = removeLiquidity(token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);

    //     // TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));

    //     // IWETH(WETH).withdraw(amountETH);

    //     // TransferHelper.safeTransferETH(to, amountETH);

    //     (, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);

    // }



    // function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(

    //     address token,

    //     uint256 liquidity,

    //     uint256 amountTokenMin,

    //     uint256 amountETHMin,

    //     address to,

    //     uint256 deadline,

    //     bool approveMax,

    //     uint8 v,

    //     bytes32 r,

    //     bytes32 s

    // ) external virtual override returns (uint256 amountETH) {

    //     address pair = UniswapV2Library.pairFor(factory, token, WETH);

    //     uint256 value = approveMax ? uint256(-1) : liquidity;

    //     IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);

    //     amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(

    //         token,

    //         liquidity,

    //         amountTokenMin,

    //         amountETHMin,

    //         to,

    //         deadline

    //     );

    // }



    // **** SWAP ****

    // requires the initial amount to have already been sent to the first pair

    function _swap(

        uint256[] memory amounts,

        address[] memory path,

        address _to

    ) internal virtual {

        for (uint256 i; i < path.length - 1; i++) {

            (address input, address output) = (path[i], path[i + 1]);

            (address token0, ) = UniswapV2Library.sortTokens(input, output);

            uint256 amountOut = amounts[i + 1];

            (uint256 amount0Out, uint256 amount1Out) = input == token0

                ? (uint256(0), amountOut)

                : (amountOut, uint256(0));

            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;

            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(amount0Out, amount1Out, to);

        }

    }



    function swapExactTokensForTokens(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external virtual override ensure(deadline) { //returns (uint256[] memory amounts) {

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            UniswapV2Library.pairFor(factory, path[0], path[1]),

            amountIn

        );

        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);

        _swapSupportingFeeOnTransferTokens(path, to);

        require(

            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,

            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'

        );

        // amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);

        // require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');

        // TransferHelper.safeTransferFrom(

        //     path[0],

        //     msg.sender,

        //     UniswapV2Library.pairFor(factory, path[0], path[1]),

        //     // amounts[0]

        //     amountIn

        // );

        // _swap(amounts, path, to);

    }



    function swapTokensForExactTokens(

        uint256 amountOut,

        uint256 amountInMax,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {

        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);

        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            UniswapV2Library.pairFor(factory, path[0], path[1]),

            amounts[0]

        );

        _swap(amounts, path, to);

    }



    function swapExactETHForTokens(

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external payable virtual override ensure(deadline) { //returns (uint256[] memory amounts) {

        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');

        uint256 amountIn = msg.value;

        IWETH(WETH).deposit{value: amountIn}();

        require(

            IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn),

            'UniswapV2Router: WETH transfer failed in swapExactETHForTokens'

        ); // assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));

        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);

        _swapSupportingFeeOnTransferTokens(path, to);

        require(

            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,

            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'

        );

        // require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');

        // amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);

        // require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');

        // // IWETH(WETH).deposit{value: amounts[0]}();

        // IWETH(WETH).deposit{value: msg.value}();

        // require(

        //     // IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]),

        //     IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), msg.value),

        //     'UniswapV2Router: WETH transfer failed in swapExactETHForTokens'

        // ); // assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));

        // _swap(amounts, path, to);

    }



    function swapTokensForExactETH(

        uint256 amountOut,

        uint256 amountInMax,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {

        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');

        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);

        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            UniswapV2Library.pairFor(factory, path[0], path[1]),

            amounts[0]

        );

        _swap(amounts, path, address(this));

        IWETH(WETH).withdraw(amounts[amounts.length - 1]);

        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);

    }



    function swapExactTokensForETH(

        uint256 amountIn,

        uint256 amountOutMin,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external virtual override ensure(deadline) { //returns (uint256[] memory amounts) {

        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');

        TransferHelper.safeTransferFrom(

            path[0],

            msg.sender,

            UniswapV2Library.pairFor(factory, path[0], path[1]),

            amountIn

        );

        _swapSupportingFeeOnTransferTokens(path, address(this));

        uint256 amountOut = IERC20(WETH).balanceOf(address(this));

        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');

        IWETH(WETH).withdraw(amountOut);

        TransferHelper.safeTransferETH(to, amountOut);

        // require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');

        // amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);

        // require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');

        // TransferHelper.safeTransferFrom(

        //     path[0],

        //     msg.sender,

        //     UniswapV2Library.pairFor(factory, path[0], path[1]),

        //     // amounts[0]

        //     amountIn

        // );

        // _swap(amounts, path, address(this));

        // IWETH(WETH).withdraw(amounts[amounts.length - 1]);

        // TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);

    }



    function swapETHForExactTokens(

        uint256 amountOut,

        address[] calldata path,

        address to,

        uint256 deadline

    ) external payable virtual override ensure(deadline) returns (uint256[] memory amounts) {

        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');

        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);

        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');

        IWETH(WETH).deposit{value: amounts[0]}();

        require(

            IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]),

            'UniswapV2Router: WETH transfer failed in swapETHForExactTokens'

        ); // assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));

        _swap(amounts, path, to);

        // refund dust eth, if any

        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);

    }



    // **** SWAP (supporting fee-on-transfer tokens) ****

    // requires the initial amount to have already been sent to the first pair

    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {

        for (uint256 i; i < path.length - 1; i++) {

            (address input, address output) = (path[i], path[i + 1]);

            (address token0, ) = UniswapV2Library.sortTokens(input, output);

            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));

            uint256 amountInput;

            uint256 amountOutput;

            {

                // scope to avoid stack too deep errors

                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();

                (uint256 reserveInput, uint256 reserveOutput) = input == token0

                    ? (reserve0, reserve1)

                    : (reserve1, reserve0);

                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);

                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);

            }

            (uint256 amount0Out, uint256 amount1Out) = input == token0

                ? (uint256(0), amountOutput)

                : (amountOutput, uint256(0));

            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;

            pair.swap(amount0Out, amount1Out, to);

        }

    }



    // function swapExactTokensForTokensSupportingFeeOnTransferTokens(

    //     uint256 amountIn,

    //     uint256 amountOutMin,

    //     address[] calldata path,

    //     address to,

    //     uint256 deadline

    // ) external virtual override ensure(deadline) {

    //     TransferHelper.safeTransferFrom(

    //         path[0],

    //         msg.sender,

    //         UniswapV2Library.pairFor(factory, path[0], path[1]),

    //         amountIn

    //     );

    //     uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);

    //     _swapSupportingFeeOnTransferTokens(path, to);

    //     require(

    //         IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,

    //         'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'

    //     );

    // }



    // function swapExactETHForTokensSupportingFeeOnTransferTokens(

    //     uint256 amountOutMin,

    //     address[] calldata path,

    //     address to,

    //     uint256 deadline

    // ) external payable virtual override ensure(deadline) {

    //     require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');

    //     uint256 amountIn = msg.value;

    //     IWETH(WETH).deposit{value: amountIn}();

    //     require(

    //         IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn),

    //         'UniswapV2Router: WETH transfer failed in swapExactETHForTokensSupportingFeeOnTransferTokens'

    //     ); // assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));

    //     uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);

    //     _swapSupportingFeeOnTransferTokens(path, to);

    //     require(

    //         IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,

    //         'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'

    //     );

    // }



    // function swapExactTokensForETHSupportingFeeOnTransferTokens(

    //     uint256 amountIn,

    //     uint256 amountOutMin,

    //     address[] calldata path,

    //     address to,

    //     uint256 deadline

    // ) external virtual override ensure(deadline) {

    //     require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');

    //     TransferHelper.safeTransferFrom(

    //         path[0],

    //         msg.sender,

    //         UniswapV2Library.pairFor(factory, path[0], path[1]),

    //         amountIn

    //     );

    //     _swapSupportingFeeOnTransferTokens(path, address(this));

    //     uint256 amountOut = IERC20(WETH).balanceOf(address(this));

    //     require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');

    //     IWETH(WETH).withdraw(amountOut);

    //     TransferHelper.safeTransferETH(to, amountOut);

    // }



    // **** LIBRARY FUNCTIONS ****

    function quote(

        uint256 amountA,

        uint256 reserveA,

        uint256 reserveB

    ) external pure virtual override returns (uint256 amountB) {

        return UniswapV2Library.quote(amountA, reserveA, reserveB);

    }



    function getAmountOut(

        uint256 amountIn,

        uint256 reserveIn,

        uint256 reserveOut

    ) external pure virtual override returns (uint256 amountOut) {

        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);

    }



    function getAmountIn(

        uint256 amountOut,

        uint256 reserveIn,

        uint256 reserveOut

    ) external pure virtual override returns (uint256 amountIn) {

        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);

    }



    function getAmountsOut(uint256 amountIn, address[] calldata path)

        external

        view

        virtual

        override

        returns (uint256[] memory amounts)

    {

        return UniswapV2Library.getAmountsOut(factory, amountIn, path);

    }



    function getAmountsIn(uint256 amountOut, address[] calldata path)

        external

        view

        virtual

        override

        returns (uint256[] memory amounts)

    {

        return UniswapV2Library.getAmountsIn(factory, amountOut, path);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_721\PolkaBridge\contracts\UQ112x112.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;



// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))



// range: [0, 2**112 - 1]

// resolution: 1 / 2**112



library UQ112x112 {

    uint224 constant Q112 = 2**112;



    // encode a uint112 as a UQ112x112

    function encode(uint112 y) internal pure returns (uint224 z) {

        z = uint224(y) * Q112; // never overflows

    }



    // divide a UQ112x112 by a uint112, returning a UQ112x112

    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {

        z = x / uint224(y);

    }

}

--------------------------------------------------
File End
--------------------------------------------------

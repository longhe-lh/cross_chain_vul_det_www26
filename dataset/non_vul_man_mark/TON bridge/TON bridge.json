{
  "contract": "TON Bridge",
  "source_code_path": "../contracts/",
  "type": "",
  "vulnerable_entry_function": {
    "file": "",
    "name": "",
    "signature": "",
    "lines": "",
    "attack_type": "",
    "vul_reason": "",
    "code_snippet": ""
  },
  "detail": "",
  "blg": {
    "TON Bridge": {
      "interoperability": "heterogeneous",
      "roles": {
        "src_chain": [
          "SwapEthToTon1",
          "SwapTonToEth2"
        ],
        "rel_chain": [
          "voteForMinting",
          "voteForNewOracleSet",
          "voteForSwitchBurn"
        ],
        "det_chain": [
          "SwapTonToEth1",
          "SwapEthToTon2"
        ]
      },
      "src_chain": {
        "chain_name": "TON",
        "events": {
          "SwapEthToTon1": {
            "0": {
              "func_name": "burn",
              "file_name": "WrappedTON.sol",
              "key_ops": [
                "require(allowBurn, \"Burn is currently disabled\");",
                "_burn(msg.sender, amount);"
              ],
              "child": {
                "0": {
                  "func_name": "_burn",
                  "file_name": "ERC20.sol",
                  "key_ops": [
                    "require(account != address(0), \"ERC20: burn from the zero address\");",
                    "uint256 accountBalance = _balances[account];",
                    "require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");",
                    "_balances[account] = accountBalance - amount;",
                    "_totalSupply -= amount;"
                  ],
                  "child": {}
                }
              }
            }
          },
          "SwapTonToEth2": {
            "0": {
              "func_name": "mint",
              "file_name": "WrappedTON.sol",
              "key_ops": [
                "_mint(sd.receiver, sd.amount);"
              ],
              "child": {
                "0": {
                  "func_name": "_mint",
                  "file_name": "ERC20.sol",
                  "key_ops": [
                    "require(account != address(0), \"ERC20: mint to the zero address\");",
                    "_totalSupply += amount;",
                    "_balances[account] += amount;"
                  ],
                  "child": {}
                }
              }
            }
          }
        }
      },
      "rel_chain": {
        "chain_name": "RelayChain",
        "events": {
          "voteForMinting": {
            "0": {
              "func_name": "voteForMinting",
              "file_name": "Bridge.sol",
              "key_ops": [
                "bytes32 _id = getSwapDataId(data);",
                "generalVote(_id, signatures);",
                "executeMinting(data);"
              ],
              "child": {
                "0": {
                  "func_name": "generalVote",
                  "file_name": "Bridge.sol",
                  "key_ops": [
                    "require(signatures.length >= 2 * oraclesSet.length / 3, \"Not enough signatures\");",
                    "require(!finishedVotings[digest], \"Vote is already finished\");",
                    "address signer = signatures[i].signer;",
                    "require(isOracle[signer], \"Unauthorized signer\");",
                    "require(next_signer > last_signer, \"Signatures are not sorted\");",
                    "checkSignature(digest, signatures[i]);"
                  ],
                  "child": {
                    "0": {
                      "func_name": "checkSignature",
                      "file_name": "SignatureChecker.sol",
                      "key_ops": [
                        "if (sig.signature.length != 65) { revert(\"ECDSA: invalid signature length\"); }",
                        "r := mload(add(signature, 0x20))",
                        "s := mload(add(signature, 0x40))",
                        "v := byte(0, mload(add(signature, 0x60)))",
                        "if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) { revert(\"ECDSA: invalid signature 's' value\"); }",
                        "if (v != 27 && v != 28) { revert(\"ECDSA: invalid signature 'v' value\"); }",
                        "bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";",
                        "bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, digest));",
                        "require(ecrecover(prefixedHash, v, r, s) == sig.signer, \"Wrong signature\");"
                      ],
                      "child": {}
                    }
                  }
                },
                "1": {
                  "func_name": "executeMinting",
                  "file_name": "Bridge.sol",
                  "key_ops": [
                    "mint(data);"
                  ],
                  "child": {
                    "0": {
                      "func_name": "mint",
                      "file_name": "WrappedTON.sol",
                      "key_ops": [
                        "_mint(sd.receiver, sd.amount);"
                      ],
                      "child": {
                        "0": {
                          "func_name": "_mint",
                          "file_name": "ERC20.sol",
                          "key_ops": [
                            "require(account != address(0), \"ERC20: mint to the zero address\");",
                            "_totalSupply += amount;",
                            "_balances[account] += amount;"
                          ],
                          "child": {}
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "voteForNewOracleSet": {
            "0": {
              "func_name": "voteForNewOracleSet",
              "file_name": "Bridge.sol",
              "key_ops": [
                "bytes32 _id = getNewSetId(oracleSetHash, newOracles);",
                "require(newOracles.length > 2, \"New set is too short\");",
                "generalVote(_id, signatures);",
                "updateOracleSet(oracleSetHash, newOracles);"
              ],
              "child": {
                "0": {
                  "func_name": "generalVote",
                  "file_name": "Bridge.sol",
                  "key_ops": [
                    "require(signatures.length >= 2 * oraclesSet.length / 3, \"Not enough signatures\");",
                    "require(!finishedVotings[digest], \"Vote is already finished\");",
                    "address signer = signatures[i].signer;",
                    "require(isOracle[signer], \"Unauthorized signer\");",
                    "checkSignature(digest, signatures[i]);"
                  ],
                  "child": {
                    "0": {
                      "func_name": "checkSignature",
                      "file_name": "SignatureChecker.sol",
                      "key_ops": [
                        "if (sig.signature.length != 65) { revert(\"ECDSA: invalid signature length\"); }",
                        "r := mload(add(signature, 0x20))",
                        "s := mload(add(signature, 0x40))",
                        "v := byte(0, mload(add(signature, 0x60)))",
                        "if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) { revert(\"ECDSA: invalid signature 's' value\"); }",
                        "if (v != 27 && v != 28) { revert(\"ECDSA: invalid signature 'v' value\"); }",
                        "bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";",
                        "bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, digest));",
                        "require(ecrecover(prefixedHash, v, r, s) == sig.signer, \"Wrong signature\");"
                      ],
                      "child": {}
                    }
                  }
                },
                "1": {
                  "func_name": "updateOracleSet",
                  "file_name": "Bridge.sol",
                  "key_ops": [
                    "oraclesSet = newSet;",
                    "isOracle[newSet[i]] = true;",
                    "require(!isOracle[newSet[i]], \"Duplicate oracle in Set\");"
                  ],
                  "child": {}
                }
              }
            }
          },
          "voteForSwitchBurn": {
            "0": {
              "func_name": "voteForSwitchBurn",
              "file_name": "Bridge.sol",
              "key_ops": [
                "bytes32 _id = getNewBurnStatusId(newBurnStatus, nonce);",
                "generalVote(_id, signatures);",
                "allowBurn = newBurnStatus;"
              ],
              "child": {
                "0": {
                  "func_name": "generalVote",
                  "file_name": "Bridge.sol",
                  "key_ops": [
                    "require(signatures.length >= 2 * oraclesSet.length / 3, \"Not enough signatures\");",
                    "require(!finishedVotings[digest], \"Vote is already finished\");",
                    "address signer = signatures[i].signer;",
                    "require(isOracle[signer], \"Unauthorized signer\");",
                    "require(next_signer > last_signer, \"Signatures are not sorted\");",
                    "checkSignature(digest, signatures[i]);"
                  ],
                  "child": {
                    "0": {
                      "func_name": "checkSignature",
                      "file_name": "SignatureChecker.sol",
                      "key_ops": [
                        "if (sig.signature.length != 65) { revert(\"ECDSA: invalid signature length\"); }",
                        "r := mload(add(signature, 0x20))",
                        "s := mload(add(signature, 0x40))",
                        "v := byte(0, mload(add(signature, 0x60)))",
                        "if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) { revert(\"ECDSA: invalid signature 's' value\"); }",
                        "if (v != 27 && v != 28) { revert(\"ECDSA: invalid signature 'v' value\"); }",
                        "bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";",
                        "bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, digest));",
                        "require(ecrecover(prefixedHash, v, r, s) == sig.signer, \"Wrong signature\");"
                      ],
                      "child": {}
                    }
                  }
                }
              }
            }
          }
        }
      },
      "det_chain": {
        "chain_name": "EVM",
        "events": {
          "SwapTonToEth1": {
            "0": {
              "func_name": "mint",
              "file_name": "WrappedTON.sol",
              "key_ops": [
                "_mint(sd.receiver, sd.amount);"
              ],
              "child": {
                "0": {
                  "func_name": "_mint",
                  "file_name": "ERC20.sol",
                  "key_ops": [
                    "require(account != address(0), \"ERC20: mint to the zero address\");",
                    "_totalSupply += amount;",
                    "_balances[account] += amount;"
                  ],
                  "child": {}
                }
              }
            }
          },
          "SwapEthToTon2": {
            "0": {
              "func_name": "burn",
              "file_name": "WrappedTON.sol",
              "key_ops": [
                "require(allowBurn, \"Burn is currently disabled\");",
                "_burn(msg.sender, amount);"
              ],
              "child": {
                "0": {
                  "func_name": "_burn",
                  "file_name": "ERC20.sol",
                  "key_ops": [
                    "require(account != address(0), \"ERC20: burn from the zero address\");",
                    "uint256 accountBalance = _balances[account];",
                    "require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");",
                    "_balances[account] = accountBalance - amount;",
                    "_totalSupply -= amount;"
                  ],
                  "child": {}
                }
              }
            }
          }
        }
      }
    }
  },
  "cag": []
}
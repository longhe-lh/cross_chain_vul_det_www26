{
    "src_chain": {
        "TokensDeposited1": [
            {
                "depositERC20": "function depositERC20(\n IERC20 token,\n uint256 amount,\n address receiverAddress,\n uint256 targetChainId\n ) public nonReentrant {\n \n uint256 balanceBefore = token.balanceOf(address(this));\n \n token.safeTransferFrom(_msgSender(), address(this), amount);\n \n require(\n token.balanceOf(address(this)) == balanceBefore + amount,\n \"CrossChainBridgeERC20: deposited token amount incorrect\"\n );\n \n _depositERC20(token, amount, receiverAddress, targetChainId);\n }"
            },
            {
                "_depositERC20": "function _depositERC20(\n IERC20 token,\n uint256 amount,\n address receiverAddress,\n uint256 targetChainId\n ) private whenNotPaused {\n \n require(amount > 0, \"CrossChainBridgeERC20: amount cannot be 0\");\n require(\n receiverAddress != address(0),\n \"CrossChainBridgeERC20: invalid receiverAddress provided\"\n );\n require(\n address(token) != address(0),\n \"CrossChainBridgeERC20: invalid token address provided\"\n );\n (bool exists, ) = liquidityManager.lpTokens(address(token));\n if (!exists) {\n \n liquidityManager.createPool(address(token));\n }\n \n \n depositCount = depositCount + 1;\n \n emit TokensDeposited(\n address(token),\n amount,\n receiverAddress,\n _getChainID(),\n targetChainId,\n depositCount\n );\n }"
            },
            {
                "createPool": "function createPool(address tokenAddress) external override returns (bool) {\n require(\n _msgSender() == address(bridgeERC20),\n \"LiquidityManager: this function can only be called by the ERC20 bridge\"\n );\n return _createPool(tokenAddress);\n }"
            },
            {
                "_createPool": "function _createPool(\n address tokenAddress\n ) private whenNotPaused returns (bool) {\n require(\n !lpTokens[tokenAddress].exists,\n \"LiquidityManager: a pool already exists for this token\"\n );\n \n lpTokens[tokenAddress] = LPToken({\n exists: true,\n token: new MintableERC20(\"Cross-Chain Bridge LPs\", \"Bridge-LP\")\n });\n \n require(\n bridgeERC20.registerTokenTransferApprovals(tokenAddress),\n \"LiquidityManager: error while registering approvals\"\n );\n emit LiquidityPoolCreated(\n tokenAddress,\n address(lpTokens[tokenAddress].token)\n );\n return true;\n }"
            }
        ],
        "TokensReleased2": [
            {
                "_releaseERC20": "function _releaseERC20(\n uint8[] memory sigV,\n bytes32[] memory sigR,\n bytes32[] memory sigS,\n address receiverAddress,\n address sourceNetworkTokenAddress,\n uint256 amount,\n uint256 depositChainId,\n uint256 depositNumber,\n bool keepTokensInBridge\n ) private whenNotPaused returns (uint256 releaseAmountAfterFees) {\n \n require(\n !releasedDeposits[depositChainId][depositNumber],\n \"CrossChainBridgeERC20: Deposit was already processed and released\"\n );\n require(\n receiverAddress != address(0),\n \"CrossChainBridgeERC20: invalid receiverAddress provided\"\n );\n require(\n sourceNetworkTokenAddress != address(0),\n \"CrossChainBridgeERC20: invalid sourceNetworkTokenAddress provided\"\n );\n require(amount > 0, \"CrossChainBridgeERC20: amount cannot be 0\");\n \n require(\n multiSignatureOracle.signaturesCheckERC20(\n sigV,\n sigR,\n sigS,\n receiverAddress,\n sourceNetworkTokenAddress,\n amount,\n depositChainId,\n depositNumber\n ),\n \"CrossChainBridgeERC20: Release not permitted. Not enough signatures from permitted oracles\"\n );\n \n \n address releaseChainTokenAddress = sourceNetworkTokenAddress;\n \n if (outsidePeggedTokens[sourceNetworkTokenAddress] != address(0)) {\n releaseChainTokenAddress = outsidePeggedTokens[\n sourceNetworkTokenAddress\n ];\n }\n IERC20 token = ERC20(releaseChainTokenAddress);\n \n require(\n token.balanceOf(address(this)) >= amount,\n \"CrossChainBridgeERC20: Not enough liquidity in bridge\"\n );\n \n \n uint256 relativeFee = bridgeFees[releaseChainTokenAddress] > 0\n ? bridgeFees[releaseChainTokenAddress]\n : defaultBridgeFee;\n \n \n uint256 bridgingFee = (amount * relativeFee) / 1000000;\n \n uint256 bridgingFeeToCollectAddress = (bridgingFee *\n collectBridgeFeePercentage) / 1000000;\n \n uint256 bridgingFeeToLiquidityMining = (bridgingFee *\n liquidityMiningFeePercentage) / 1000000;\n \n uint256 bridgingFeeToRewardPool = bridgingFee -\n bridgingFeeToCollectAddress -\n bridgingFeeToLiquidityMining;\n \n releasedDeposits[depositChainId][depositNumber] = true;\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(buyBackAndBurn)\n ] += bridgingFeeToCollectAddress;\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] += bridgingFeeToLiquidityMining;\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] += bridgingFeeToRewardPool;\n \n if (\n lastTransferBlock[releaseChainTokenAddress][address(rewardPools)] +\n blocksBetweenFeeTransfersToRewardPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] >\n 0\n ) {\n \n rewardPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(rewardPools)\n ] = block.number;\n } else if (\n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] +\n blocksBetweenFeeTransfersToLiquidityMiningPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] >\n 0\n ) {\n \n \n liquidityMiningPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = block.number;\n }\n releaseAmountAfterFees = amount - bridgingFee;\n \n \n if (!keepTokensInBridge) {\n \n token.safeTransfer(receiverAddress, releaseAmountAfterFees);\n }\n emit TokensReleased(\n sourceNetworkTokenAddress,\n releaseAmountAfterFees,\n receiverAddress,\n depositChainId,\n depositNumber\n );\n }"
            },
            {
                "addRewards": "function addRewards(\n IERC20 token,\n uint256 amount\n ) external whenNotPaused nonReentrant {\n \n require(\n address(token) != address(0),\n \"RewardPoolsV1: invalid address provided\"\n );\n \n if (!rewardPools[address(token)].exists) {\n \n rewardPools[address(token)] = RewardPool({\n rewardToken: token,\n interestBearingToken: new PoolsInterestBearingToken(\n \"Cross-Chain Bridge RP LPs\",\n \"BRIDGE-RP\",\n address(token)\n ),\n minStakeAmount: 1,\n maxStakeAmount: 0,\n maxPoolSize: 0,\n totalStakedAmount: 0,\n totalRewardAmount: 0,\n accRewardPerShare: 0,\n lastRewardAmount: 0,\n exists: true\n });\n \n PoolsInterestBearingToken(\n address(rewardPools[address(token)].interestBearingToken)\n ).setPoolsContract(address(this));\n }\n \n token.safeTransferFrom(_msgSender(), address(this), amount);\n \n \n \n if (rewardPools[address(token)].totalStakedAmount == 0) {\n \n require(\n token.approve(address(buyBackAndBurnContract), amount),\n \"RewardPoolsV1: approval failed\"\n );\n buyBackAndBurnContract.depositERC20(token, amount);\n } else {\n \n rewardPools[address(token)].totalRewardAmount =\n rewardPools[address(token)].totalRewardAmount +\n amount;\n }\n \n emit RewardsAdded(address(token), amount);\n }"
            }
        ]
    },
    "rel_chain": {
        "RoleGranted": [
            {
                "grantRole": "function grantRole(\n bytes32 role,\n address account\n ) public virtual override onlyRole(getRoleAdmin(role)) {\n function _grantRole(...) {...}\n_grantRole(role, account);\n }"
            },
            {
                "_grantRole": "function _grantRole(bytes32 role, address account) private {\n if (!hasRole(role, account)) {\n _roles[role].members[account] = true;\n emit RoleGranted(role, account, _msgSender());\n }\n }"
            }
        ],
        "RoleRevoked": [
            {
                "revokeRole": "function revokeRole(\n bytes32 role,\n address account\n ) public virtual override onlyRole(getRoleAdmin(role)) {\n function _revokeRole(...) {...}\n_revokeRole(role, account);\n }"
            },
            {
                "_revokeRole": "function _revokeRole(bytes32 role, address account) private {\n if (hasRole(role, account)) {\n _roles[role].members[account] = false;\n emit RoleRevoked(role, account, _msgSender());\n }\n }"
            }
        ],
        "Upgraded": [
            {
                "_upgradeTo": "function _upgradeTo(address newImplementation) internal {\n _setImplementation(newImplementation);\n emit Upgraded(newImplementation);\n }"
            }
        ],
        "Transfer": [
            {
                "_transfer": "function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(\n senderBalance >= amount,\n \"ERC20: transfer amount exceeds balance\"\n );\n unchecked {\n _balances[sender] = senderBalance - amount;\n }\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);\n _afterTokenTransfer(sender, recipient, amount);\n }"
            }
        ],
        "Approval": [
            {
                "_approve": "function _approve(\n address owner,\n address spender,\n uint256 amount\n ) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }"
            }
        ]
    },
    "det_chain": {
        "TokensReleased1": [
            {
                "_releaseERC20": "function _releaseERC20(\n uint8[] memory sigV,\n bytes32[] memory sigR,\n bytes32[] memory sigS,\n address receiverAddress,\n address sourceNetworkTokenAddress,\n uint256 amount,\n uint256 depositChainId,\n uint256 depositNumber,\n bool keepTokensInBridge\n ) private whenNotPaused returns (uint256 releaseAmountAfterFees) {\n \n require(\n !releasedDeposits[depositChainId][depositNumber],\n \"CrossChainBridgeERC20: Deposit was already processed and released\"\n );\n require(\n receiverAddress != address(0),\n \"CrossChainBridgeERC20: invalid receiverAddress provided\"\n );\n require(\n sourceNetworkTokenAddress != address(0),\n \"CrossChainBridgeERC20: invalid sourceNetworkTokenAddress provided\"\n );\n require(amount > 0, \"CrossChainBridgeERC20: amount cannot be 0\");\n \n require(\n multiSignatureOracle.signaturesCheckERC20(\n sigV,\n sigR,\n sigS,\n receiverAddress,\n sourceNetworkTokenAddress,\n amount,\n depositChainId,\n depositNumber\n ),\n \"CrossChainBridgeERC20: Release not permitted. Not enough signatures from permitted oracles\"\n );\n \n \n address releaseChainTokenAddress = sourceNetworkTokenAddress;\n \n if (outsidePeggedTokens[sourceNetworkTokenAddress] != address(0)) {\n releaseChainTokenAddress = outsidePeggedTokens[\n sourceNetworkTokenAddress\n ];\n }\n IERC20 token = ERC20(releaseChainTokenAddress);\n \n require(\n token.balanceOf(address(this)) >= amount,\n \"CrossChainBridgeERC20: Not enough liquidity in bridge\"\n );\n \n \n uint256 relativeFee = bridgeFees[releaseChainTokenAddress] > 0\n ? bridgeFees[releaseChainTokenAddress]\n : defaultBridgeFee;\n \n \n uint256 bridgingFee = (amount * relativeFee) / 1000000;\n \n uint256 bridgingFeeToCollectAddress = (bridgingFee *\n collectBridgeFeePercentage) / 1000000;\n \n uint256 bridgingFeeToLiquidityMining = (bridgingFee *\n liquidityMiningFeePercentage) / 1000000;\n \n uint256 bridgingFeeToRewardPool = bridgingFee -\n bridgingFeeToCollectAddress -\n bridgingFeeToLiquidityMining;\n \n releasedDeposits[depositChainId][depositNumber] = true;\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(buyBackAndBurn)\n ] += bridgingFeeToCollectAddress;\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] += bridgingFeeToLiquidityMining;\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] += bridgingFeeToRewardPool;\n \n if (\n lastTransferBlock[releaseChainTokenAddress][address(rewardPools)] +\n blocksBetweenFeeTransfersToRewardPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] >\n 0\n ) {\n \n rewardPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(rewardPools)\n ] = block.number;\n } else if (\n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] +\n blocksBetweenFeeTransfersToLiquidityMiningPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] >\n 0\n ) {\n \n \n liquidityMiningPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = block.number;\n }\n releaseAmountAfterFees = amount - bridgingFee;\n \n \n if (!keepTokensInBridge) {\n \n token.safeTransfer(receiverAddress, releaseAmountAfterFees);\n }\n emit TokensReleased(\n sourceNetworkTokenAddress,\n releaseAmountAfterFees,\n receiverAddress,\n depositChainId,\n depositNumber\n );\n }"
            }
        ],
        "BoughtBackAndBurned2": [
            {
                "buyBackAndBurnERC20": "function buyBackAndBurnERC20(\n address collectedToken\n ) external whenNotPaused nonReentrant {\n \n require(\n collectedToken != address(0),\n \"BuyBackAndBurnV1: invalid token address\"\n );\n \n \n bridgeERC20.sendCollectedTokensToBuyBackAndBurn(IERC20(collectedToken));\n \n uint256 amount = collectedERC20ToBurn[collectedToken];\n require(amount > 0, \"BuyBackAndBurnV1: no tokens to burn\");\n \n if (\n IERC20(collectedToken).allowance(address(this), address(router)) <\n amount\n ) {\n IERC20(collectedToken).approve(address(router), type(uint256).max);\n }\n \n uint256 burnAmount = router.tradeERC20(\n IERC20(collectedToken),\n burnToken,\n amount\n );\n \n uint256 balanceBurnToken = burnToken.balanceOf(address(this));\n ERC20Burnable(address(burnToken)).burn(balanceBurnToken);\n \n collectedERC20ToBurn[collectedToken] = 0;\n \n emit BoughtBackAndBurned(\n collectedToken,\n amount,\n address(burnToken),\n balanceBurnToken\n );\n }"
            }
        ]
    }
}
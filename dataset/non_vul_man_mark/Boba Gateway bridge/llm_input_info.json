{
    "src_chain": {
        "TransactionEnqueued1": [
            {
                "enqueue": "function enqueue(\n address _target,\n uint256 _gasLimit,\n bytes memory _data\n ) external {\n require(\n _data.length <= MAX_ROLLUP_TX_SIZE,\n \"Transaction data size exceeds maximum for rollup transaction.\"\n );\n require(\n _gasLimit <= maxTransactionGasLimit,\n \"Transaction gas limit exceeds maximum for rollup transaction.\"\n );\n require(\n _gasLimit >= MIN_ROLLUP_TX_GAS,\n \"Transaction gas limit too low to enqueue.\"\n );\n \n \n \n \n \n \n \n \n \n \n \n \n if (_gasLimit > enqueueL2GasPrepaid) {\n uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) /\n l2GasDiscountDivisor;\n uint256 startingGas = gasleft();\n \n \n require(\n startingGas > gasToConsume,\n \"Insufficient gas for L2 rate limiting burn.\"\n );\n uint256 i;\n while (startingGas - gasleft() < gasToConsume) {\n i++;\n }\n }\n \n \n \n \n \n address sender;\n if (msg.sender == tx.origin) {\n sender = msg.sender;\n } else {\n sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n }\n bytes32 transactionHash = keccak256(\n abi.encode(sender, _target, _gasLimit, _data)\n );\n queueElements.push(\n Lib_OVMCodec.QueueElement({\n transactionHash: transactionHash,\n timestamp: uint40(block.timestamp),\n blockNumber: uint40(block.number)\n })\n );\n uint256 queueIndex = queueElements.length - 1;\n emit TransactionEnqueued(\n sender,\n _target,\n _gasLimit,\n _data,\n queueIndex,\n block.timestamp\n );\n }"
            }
        ]
    },
    "rel_chain": {
        "TransactionBatchAppended": [
            {
                "appendSequencerBatch": "function appendSequencerBatch() external {\n uint40 shouldStartAtElement;\n uint24 totalElementsToAppend;\n uint24 numContexts;\n assembly {\n shouldStartAtElement := shr(216, calldataload(4))\n totalElementsToAppend := shr(232, calldataload(9))\n numContexts := shr(232, calldataload(12))\n }\n require(\n shouldStartAtElement == getTotalElements(),\n \"Actual batch start index does not match expected start index.\"\n );\n require(\n msg.sender == resolve(\"OVM_Sequencer\"),\n \"Function can only be called by the Sequencer.\"\n );\n uint40 nextTransactionPtr = uint40(\n BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts\n );\n require(\n msg.data.length >= nextTransactionPtr,\n \"Not enough BatchContexts provided.\"\n );\n \n uint32 numSequencerTransactions = 0;\n \n \n \n uint40 nextQueueIndex = _nextQueueIndex;\n BatchContext memory curContext;\n for (uint32 i = 0; i < numContexts; i++) {\n BatchContext memory nextContext = _getBatchContext(i);\n \n curContext = nextContext;\n \n numSequencerTransactions += uint32(\n curContext.numSequencedTransactions\n );\n \n nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);\n }\n require(\n nextQueueIndex <= queueElements.length,\n \"Attempted to append more elements than are available in the queue.\"\n );\n \n uint40 numQueuedTransactions = totalElementsToAppend -\n numSequencerTransactions;\n uint40 blockTimestamp;\n uint40 blockNumber;\n if (curContext.numSubsequentQueueTransactions == 0) {\n \n \n blockTimestamp = uint40(curContext.timestamp);\n blockNumber = uint40(curContext.blockNumber);\n } else {\n \n \n \n \n \n Lib_OVMCodec.QueueElement memory lastElement = queueElements[\n nextQueueIndex - 1\n ];\n blockTimestamp = lastElement.timestamp;\n blockNumber = lastElement.blockNumber;\n }\n \n _appendBatch(\n blockhash(block.number - 1),\n totalElementsToAppend,\n numQueuedTransactions,\n blockTimestamp,\n blockNumber\n );\n emit SequencerBatchAppended(\n nextQueueIndex - numQueuedTransactions,\n numQueuedTransactions,\n getTotalElements()\n );\n \n _nextQueueIndex = nextQueueIndex;\n }"
            },
            {
                "_appendBatch": "function _appendBatch(\n bytes32 _transactionRoot,\n uint256 _batchSize,\n uint256 _numQueuedTransactions,\n uint40 _timestamp,\n uint40 _blockNumber\n ) internal {\n IChainStorageContainer batchesRef = batches();\n (\n uint40 totalElements,\n uint40 nextQueueIndex,\n ,\n ) = _getBatchExtraData();\n Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec\n .ChainBatchHeader({\n batchIndex: batchesRef.length(),\n batchRoot: _transactionRoot,\n batchSize: _batchSize,\n prevTotalElements: totalElements,\n extraData: hex\"\"\n });\n emit TransactionBatchAppended(\n header.batchIndex,\n header.batchRoot,\n header.batchSize,\n header.prevTotalElements,\n header.extraData\n );\n bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\n bytes27 latestBatchContext = _makeBatchExtraData(\n totalElements + uint40(header.batchSize),\n nextQueueIndex + uint40(_numQueuedTransactions),\n _timestamp,\n _blockNumber\n );\n batchesRef.push(batchHeaderHash, latestBatchContext);\n }"
            }
        ]
    },
    "det_chain": {
        "RelayedMessage1": []
    }
}
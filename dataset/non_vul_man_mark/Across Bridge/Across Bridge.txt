Folder Structure
--------------------------------------------------
contracts/
    AcceleratingDistributor.sol
    AcrossConfigStore.sol
    AcrossMerkleDistributor.sol
    AcrossToken.sol
    AdapterInterface.sol
    Address.sol
    AddressWhitelistInterface.sol
    Arbitrum_Adapter.sol
    Boba_Adapter.sol
    ClaimAndStake.sol
    Constants.sol
    Context.sol
    CrossDomainEnabled.sol
    draft-IERC20Permit.sol
    ECDSA.sol
    ERC20.sol
    Ethereum_Adapter.sol
    Ethereum_SpokePool.sol
    ExpandedERC20.sol
    ExpandedIERC20.sol
    FinderInterface.sol
    FixedPoint.sol
    HubPool.sol
    HubPoolInterface.sol
    ICrossDomainMessenger.sol
    IdentifierWhitelistInterface.sol
    IERC20.sol
    IERC20Metadata.sol
    IL1ERC20Bridge.sol
    IL1StandardBridge.sol
    Lockable.sol
    LpTokenFactory.sol
    LpTokenFactoryInterface.sol
    MerkleDistributor.sol
    MerkleDistributorInterface.sol
    MerkleLib.sol
    MerkleProof.sol
    Multicall.sol
    MultiCaller.sol
    MultiRole.sol
    Optimism_Adapter.sol
    OptimisticOracleInterface.sol
    Ownable.sol
    PolygonTokenBridger.sol
    Polygon_Adapter.sol
    ReentrancyGuard.sol
    SafeERC20.sol
    SafeMath.sol
    SignedSafeMath.sol
    SkinnyOptimisticOracleInterface.sol
    SpokePool.sol
    SpokePoolInterface.sol
    StoreInterface.sol
    Strings.sol
    Testable.sol
    Timer.sol
    WETH9.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\AcceleratingDistributor.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/utils/Multicall.sol";



/**

 * @notice Across token distribution contract. Contract is inspired by Synthetix staking contract and Ampleforth geyser.

 * Stakers start by earning their pro-rata share of a baseEmissionRate per second which increases based on how long

 * they have staked in the contract, up to a max emission rate of baseEmissionRate * maxMultiplier. Multiple LP tokens

 * can be staked in this contract enabling depositors to batch stake and claim via multicall. Note that this contract is

 * only compatible with standard ERC20 tokens, and not tokens that charge fees on transfers, dynamically change

 * balance, or have double entry-points. It's up to the contract owner to ensure they only add supported tokens.

 */



contract AcceleratingDistributor is ReentrancyGuard, Ownable, Multicall {

    using SafeERC20 for IERC20;



    IERC20 public immutable rewardToken;



    // Each User deposit is tracked with the information below.

    struct UserDeposit {

        uint256 cumulativeBalance;

        uint256 averageDepositTime;

        uint256 rewardsAccumulatedPerToken;

        uint256 rewardsOutstanding;

    }



    struct StakingToken {

        bool enabled;

        uint256 baseEmissionRate;

        uint256 maxMultiplier;

        uint256 secondsToMaxMultiplier;

        uint256 cumulativeStaked;

        uint256 rewardPerTokenStored;

        uint256 lastUpdateTime;

        mapping(address => UserDeposit) stakingBalances;

    }



    mapping(address => StakingToken) public stakingTokens;



    modifier onlyEnabled(address stakedToken) {

        require(stakingTokens[stakedToken].enabled, "stakedToken not enabled");

        _;

    }



    modifier onlyInitialized(address stakedToken) {

        require(stakingTokens[stakedToken].lastUpdateTime != 0, "stakedToken not initialized");

        _;

    }



    constructor(address _rewardToken) {

        rewardToken = IERC20(_rewardToken);

    }



    function getCurrentTime() public view virtual returns (uint256) {

        return block.timestamp; // solhint-disable-line not-rely-on-time

    }



    /**************************************

     *               EVENTS               *

     **************************************/



    event TokenConfiguredForStaking(

        address indexed token,

        bool enabled,

        uint256 baseEmissionRate,

        uint256 maxMultiplier,

        uint256 secondsToMaxMultiplier,

        uint256 lastUpdateTime

    );

    event RecoverToken(address indexed token, uint256 amount);

    event Stake(

        address indexed token,

        address indexed user,

        uint256 amount,

        uint256 averageDepositTime,

        uint256 cumulativeBalance,

        uint256 tokenCumulativeStaked

    );

    event Unstake(

        address indexed token,

        address indexed user,

        uint256 amount,

        uint256 remainingCumulativeBalance,

        uint256 tokenCumulativeStaked

    );

    event RewardsWithdrawn(

        address indexed token,

        address indexed user,

        uint256 rewardsToSend,

        uint256 tokenLastUpdateTime,

        uint256 tokenRewardPerTokenStored,

        uint256 userRewardsOutstanding,

        uint256 userRewardsPaidPerToken

    );

    event Exit(address indexed token, address indexed user, uint256 tokenCumulativeStaked);



    /**************************************

     *          ADMIN FUNCTIONS           *

     **************************************/



    /**

     * @notice Enable a token for staking.

     * @dev The owner should ensure that the token enabled is a standard ERC20 token to ensure correct functionality.

     * @param stakedToken The address of the token that can be staked.

     * @param enabled Whether the token is enabled for staking.

     * @param baseEmissionRate The base emission rate for staking the token. This is split pro-rata between all users.

     * @param maxMultiplier The maximum multiplier for staking which increases your rewards the longer you stake.

     * @param secondsToMaxMultiplier The number of seconds needed to stake to reach the maximum multiplier.

     */

    function configureStakingToken(

        address stakedToken,

        bool enabled,

        uint256 baseEmissionRate,

        uint256 maxMultiplier,

        uint256 secondsToMaxMultiplier

    ) external onlyOwner {

        // Validate input to ensure system stability and avoid unexpected behavior. Note we dont place a lower bound on

        // the baseEmissionRate. If this value is less than 1e18 then you will slowly loose your staking rewards over time.

        // Because of the way balances are managed, the staked token cannot be the reward token. Otherwise, reward

        // payouts could eat into user balances. We choose not to constrain `maxMultiplier` to be > 1e18 so that

        // admin can choose to allow decreasing emissions over time. This is not the intended use case, but we see no

        // benefit to removing this additional flexibility. If set < 1e18, then user's rewards outstanding will

        // decrease over time. Incentives for stakers would look different if `maxMultiplier` were set < 1e18

        require(stakedToken != address(rewardToken), "Staked token is reward token");

        require(maxMultiplier < 1e36, "maxMultiplier can not be set too large");

        require(secondsToMaxMultiplier > 0, "secondsToMaxMultiplier must be greater than 0");

        require(baseEmissionRate < 1e27, "baseEmissionRate can not be set too large");



        StakingToken storage stakingToken = stakingTokens[stakedToken];



        // If this token is already initialized, make sure we update the rewards before modifying any params.

        if (stakingToken.lastUpdateTime != 0) _updateReward(stakedToken, address(0));



        stakingToken.enabled = enabled;

        stakingToken.baseEmissionRate = baseEmissionRate;

        stakingToken.maxMultiplier = maxMultiplier;

        stakingToken.secondsToMaxMultiplier = secondsToMaxMultiplier;

        stakingToken.lastUpdateTime = getCurrentTime();



        emit TokenConfiguredForStaking(

            stakedToken,

            enabled,

            baseEmissionRate,

            maxMultiplier,

            secondsToMaxMultiplier,

            stakingToken.lastUpdateTime

        );

    }



    /**

     * @notice Enables the owner to recover tokens dropped onto the contract. This could be used to remove unclaimed

     * staking rewards or recover excess LP tokens that were inadvertently dropped onto the contract. Importantly, the

     * contract will only let the owner recover staked excess tokens above what the contract thinks it should have. i.e

     * the owner cant use this method to steal staked tokens, only recover excess ones mistakenly sent to the contract.

     * @param token The address of the token to skim.

     */

    function recoverToken(address token) external onlyOwner {

        // If the token is an enabled staking token then we want to preform a skim action where we send back any extra

        // tokens that are not accounted for in the cumulativeStaked variable. This lets the owner recover extra tokens

        // sent to the contract that were not explicitly staked. if the token is not enabled for staking then we simply

        // send back the full amount of tokens that the contract has.

        uint256 amount = IERC20(token).balanceOf(address(this));

        if (stakingTokens[token].lastUpdateTime != 0) amount -= stakingTokens[token].cumulativeStaked;

        require(amount > 0, "Can't recover 0 tokens");

        IERC20(token).safeTransfer(owner(), amount);

        emit RecoverToken(token, amount);

    }



    /**************************************

     *          STAKER FUNCTIONS          *

     **************************************/



    /**

     * @notice Stake tokens for rewards.

     * @dev The caller of this function must approve this contract to spend amount of stakedToken.

     * @param stakedToken The address of the token to stake.

     * @param amount The amount of the token to stake.

     */

    function stake(address stakedToken, uint256 amount) external nonReentrant onlyEnabled(stakedToken) {

        _stake(stakedToken, amount, msg.sender);

    }



    /**

     * @notice Stake tokens for rewards on behalf of `beneficiary`.

     * @dev The caller of this function must approve this contract to spend amount of stakedToken.

     * @dev The caller of this function is effectively donating their tokens to the beneficiary. The beneficiary

     * can then unstake or claim rewards as they wish.

     * @param stakedToken The address of the token to stake.

     * @param amount The amount of the token to stake.

     * @param beneficiary User that caller wants to stake on behalf of.

     */

    function stakeFor(

        address stakedToken,

        uint256 amount,

        address beneficiary

    ) external nonReentrant onlyEnabled(stakedToken) {

        _stake(stakedToken, amount, beneficiary);

    }



    /**

     * @notice Withdraw staked tokens.

     * @param stakedToken The address of the token to withdraw.

     * @param amount The amount of the token to withdraw.

     */

    function unstake(address stakedToken, uint256 amount) public nonReentrant onlyInitialized(stakedToken) {

        _updateReward(stakedToken, msg.sender);

        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];



        // Note: these will revert if underflow so you cant unstake more than your cumulativeBalance.

        userDeposit.cumulativeBalance -= amount;

        stakingTokens[stakedToken].cumulativeStaked -= amount;



        IERC20(stakedToken).safeTransfer(msg.sender, amount);



        emit Unstake(

            stakedToken,

            msg.sender,

            amount,

            userDeposit.cumulativeBalance,

            stakingTokens[stakedToken].cumulativeStaked

        );

    }



    /**

     * @notice Get entitled rewards for the staker.

     * @dev Calling this method will reset the caller's reward multiplier.

     * @param stakedToken The address of the token to get rewards for.

     */

    function withdrawReward(address stakedToken) public nonReentrant onlyInitialized(stakedToken) {

        _updateReward(stakedToken, msg.sender);

        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];



        uint256 rewardsToSend = userDeposit.rewardsOutstanding;

        if (rewardsToSend > 0) {

            userDeposit.rewardsOutstanding = 0;

            userDeposit.averageDepositTime = getCurrentTime();

            rewardToken.safeTransfer(msg.sender, rewardsToSend);

        }



        emit RewardsWithdrawn(

            stakedToken,

            msg.sender,

            rewardsToSend,

            stakingTokens[stakedToken].lastUpdateTime,

            stakingTokens[stakedToken].rewardPerTokenStored,

            userDeposit.rewardsOutstanding,

            userDeposit.rewardsAccumulatedPerToken

        );

    }



    /**

     * @notice Exits a staking position by unstaking and getting rewards. This totally exits the staking position.

     * @dev Calling this method will reset the caller's reward multiplier.

     * @param stakedToken The address of the token to get rewards for.

     */

    function exit(address stakedToken) external onlyInitialized(stakedToken) {

        _updateReward(stakedToken, msg.sender);

        unstake(stakedToken, stakingTokens[stakedToken].stakingBalances[msg.sender].cumulativeBalance);

        withdrawReward(stakedToken);



        emit Exit(stakedToken, msg.sender, stakingTokens[stakedToken].cumulativeStaked);

    }



    /**************************************

     *           VIEW FUNCTIONS           *

     **************************************/



    /**

     * @notice Returns the total staked for a given stakedToken.

     * @param stakedToken The address of the staked token to query.

     * @return uint256 Total amount staked of the stakedToken.

     */

    function getCumulativeStaked(address stakedToken) external view returns (uint256) {

        return stakingTokens[stakedToken].cumulativeStaked;

    }



    /**

     * @notice Returns all the information associated with a user's stake.

     * @param stakedToken The address of the staked token to query.

     * @param account The address of user to query.

     * @return UserDeposit Struct with: {cumulativeBalance,averageDepositTime,rewardsAccumulatedPerToken,rewardsOutstanding}

     */

    function getUserStake(address stakedToken, address account) external view returns (UserDeposit memory) {

        return stakingTokens[stakedToken].stakingBalances[account];

    }



    /**

     * @notice Returns the base rewards per staked token for a given staking token. This factors in the last time

     * any internal logic was called on this contract to correctly attribute retroactive cumulative rewards.

     * @dev the value returned is represented by a uint256 with fixed precision of 18 decimals.

     * @param stakedToken The address of the staked token to query.

     * @return uint256 Total base reward per token that will be applied, pro-rata, to stakers.

     */

    function baseRewardPerToken(address stakedToken) public view returns (uint256) {

        StakingToken storage stakingToken = stakingTokens[stakedToken];

        if (stakingToken.cumulativeStaked == 0) return stakingToken.rewardPerTokenStored;



        return

            stakingToken.rewardPerTokenStored +

            ((getCurrentTime() - stakingToken.lastUpdateTime) * stakingToken.baseEmissionRate * 1e18) /

            stakingToken.cumulativeStaked;

    }



    /**

     * @notice Returns the multiplier applied to the base reward per staked token for a given staking token and account.

     * The longer a user stakes the higher their multiplier up to maxMultiplier for that given staking token.

     * any internal logic was called on this contract to correctly attribute retroactive cumulative rewards.

     * @dev the value returned is represented by a uint256 with fixed precision of 18 decimals.

     * @param stakedToken The address of the staked token to query.

     * @param account The address of the user to query.

     * @return uint256 User multiplier, applied to the baseRewardPerToken, when claiming rewards.

     */

    function getUserRewardMultiplier(address stakedToken, address account) public view returns (uint256) {

        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];

        if (userDeposit.averageDepositTime == 0 || userDeposit.cumulativeBalance == 0) return 1e18;

        uint256 fractionOfMaxMultiplier = ((getTimeSinceAverageDeposit(stakedToken, account)) * 1e18) /

            stakingTokens[stakedToken].secondsToMaxMultiplier;



        // At maximum, the multiplier should be equal to the maxMultiplier.

        if (fractionOfMaxMultiplier > 1e18) fractionOfMaxMultiplier = 1e18;

        return 1e18 + (fractionOfMaxMultiplier * (stakingTokens[stakedToken].maxMultiplier - 1e18)) / (1e18);

    }



    /**

     * @notice Returns the total outstanding rewards entitled to a user for a given staking token. This factors in the

     * users staking duration (and therefore reward multiplier) and their pro-rata share of the total rewards.

     * @param stakedToken The address of the staked token to query.

     * @param account The address of the user to query.

     * @return uint256 Total outstanding rewards entitled to user.

     */

    function getOutstandingRewards(address stakedToken, address account) public view returns (uint256) {

        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];



        uint256 userRewardMultiplier = getUserRewardMultiplier(stakedToken, account);



        uint256 newUserRewards = (userDeposit.cumulativeBalance *

            (baseRewardPerToken(stakedToken) - userDeposit.rewardsAccumulatedPerToken) *

            userRewardMultiplier) / (1e18 * 1e18);



        return newUserRewards + userDeposit.rewardsOutstanding;

    }



    /**

     * @notice Returns the time that has elapsed between the current time and the last users average deposit time.

     * @param stakedToken The address of the staked token to query.

     * @param account The address of the user to query.

     *@return uint256 Time, in seconds, between the users average deposit time and the current time.

     */

    function getTimeSinceAverageDeposit(address stakedToken, address account) public view returns (uint256) {

        return getCurrentTime() - stakingTokens[stakedToken].stakingBalances[account].averageDepositTime;

    }



    /**

     * @notice Returns a users new average deposit time, considering the addition of a new deposit. This factors in the

     * cumulative previous deposits, new deposit and time from the last deposit.

     * @param stakedToken The address of the staked token to query.

     * @param account The address of the user to query.

     * @return uint256 Average post deposit time, considering all deposits to date.

     */

    function getAverageDepositTimePostDeposit(

        address stakedToken,

        address account,

        uint256 amount

    ) public view returns (uint256) {

        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];

        if (amount == 0) return userDeposit.averageDepositTime;

        uint256 amountWeightedTime = (((amount * 1e18) / (userDeposit.cumulativeBalance + amount)) *

            (getTimeSinceAverageDeposit(stakedToken, account))) / 1e18;

        return userDeposit.averageDepositTime + amountWeightedTime;

    }



    /**************************************

     *         INTERNAL FUNCTIONS         *

     **************************************/



    // Update the internal counters for a given stakedToken and user.

    function _updateReward(address stakedToken, address account) internal {

        StakingToken storage stakingToken = stakingTokens[stakedToken];

        stakingToken.rewardPerTokenStored = baseRewardPerToken(stakedToken);

        stakingToken.lastUpdateTime = getCurrentTime();

        if (account != address(0)) {

            UserDeposit storage userDeposit = stakingToken.stakingBalances[account];

            userDeposit.rewardsOutstanding = getOutstandingRewards(stakedToken, account);

            userDeposit.rewardsAccumulatedPerToken = stakingToken.rewardPerTokenStored;

        }

    }



    function _stake(

        address stakedToken,

        uint256 amount,

        address staker

    ) internal {

        _updateReward(stakedToken, staker);



        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[staker];



        uint256 averageDepositTime = getAverageDepositTimePostDeposit(stakedToken, staker, amount);



        userDeposit.averageDepositTime = averageDepositTime;

        userDeposit.cumulativeBalance += amount;

        stakingTokens[stakedToken].cumulativeStaked += amount;



        IERC20(stakedToken).safeTransferFrom(msg.sender, address(this), amount);

        emit Stake(

            stakedToken,

            staker,

            amount,

            averageDepositTime,

            userDeposit.cumulativeBalance,

            stakingTokens[stakedToken].cumulativeStaked

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\AcrossConfigStore.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "@uma/core/contracts/common/implementation/MultiCaller.sol";

import "@openzeppelin/contracts/access/Ownable.sol";



/**

 * @title Allows admin to set and update configuration settings for full contract system. These settings are designed

 * to be consumed by off-chain bots, rather than by other contracts.

 * @dev This contract should not perform any validation on the setting values and should be owned by the governance

 * system of the full contract suite..

 */

contract AcrossConfigStore is Ownable, MultiCaller {

    // General dictionary where admin can associate variables with specific L1 tokens, like the Rate Model and Token

    // Transfer Thresholds.

    mapping(address => string) public l1TokenConfig;



    // General dictionary where admin can store global variables like `MAX_POOL_REBALANCE_LEAF_SIZE` and

    // `MAX_RELAYER_REPAYMENT_LEAF_SIZE` that off-chain agents can query.

    mapping(bytes32 => string) public globalConfig;



    event UpdatedTokenConfig(address indexed key, string value);

    event UpdatedGlobalConfig(bytes32 indexed key, string value);



    /**

     * @notice Updates token config.

     * @param l1Token the l1 token address to update value for.

     * @param value Value to update.

     */

    function updateTokenConfig(address l1Token, string memory value) external onlyOwner {

        l1TokenConfig[l1Token] = value;

        emit UpdatedTokenConfig(l1Token, value);

    }



    /**

     * @notice Updates global config.

     * @param key Key to update.

     * @param value Value to update.

     */

    function updateGlobalConfig(bytes32 key, string calldata value) external onlyOwner {

        globalConfig[key] = value;

        emit UpdatedGlobalConfig(key, value);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\AcrossMerkleDistributor.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "@uma/core/contracts/merkle-distributor/implementation/MerkleDistributor.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";



/**

 * @title  Extended MerkleDistributor contract.

 * @notice Adds additional constraints governing who can claim leaves from merkle windows.

 */

contract AcrossMerkleDistributor is MerkleDistributor {

    using SafeERC20 for IERC20;



    // Addresses that can claim on user's behalf.

    mapping(address => bool) public whitelistedClaimers;



    /****************************************

     *                EVENTS

     ****************************************/

    event WhitelistedClaimer(address indexed claimer, bool indexed whitelist);

    event ClaimFor(

        address indexed caller,

        uint256 windowIndex,

        address indexed account,

        uint256 accountIndex,

        uint256 amount,

        address indexed rewardToken

    );



    /****************************

     *      ADMIN FUNCTIONS

     ****************************/



    /**

     * @notice Updates whitelisted claimer status.

     * @dev Callable only by owner.

     * @param newContract Reset claimer contract to this address.

     * @param whitelist True to whitelist claimer, False otherwise.

     */

    function whitelistClaimer(address newContract, bool whitelist) external onlyOwner {

        whitelistedClaimers[newContract] = whitelist;

        emit WhitelistedClaimer(newContract, whitelist);

    }



    /****************************

     *    NON-ADMIN FUNCTIONS

     ****************************/



    /**

     * @notice Batch claims to reduce gas versus individual submitting all claims. Method will fail

     *         if any individual claims within the batch would fail.

     * @dev    All claim recipients must be equal to msg.sender.

     * @param claims array of claims to claim.

     */

    function claimMulti(Claim[] memory claims) public override {

        uint256 claimCount = claims.length;

        for (uint256 i = 0; i < claimCount; i++) {

            require(claims[i].account == msg.sender, "invalid claimer");

        }

        super.claimMulti(claims);

    }



    /**

     * @notice Claim amount of reward tokens for account, as described by Claim input object.

     * @dev    Claim recipient must be equal to msg.sender.

     * @param _claim claim object describing amount, accountIndex, account, window index, and merkle proof.

     */

    function claim(Claim memory _claim) public override {

        require(_claim.account == msg.sender, "invalid claimer");

        super.claim(_claim);

    }



    /**

     * @notice Executes merkle leaf claim on behaf of user. This can only be called by a trusted

     *         claimer address. This function is designed to be called atomically with other transactions

     *         that ultimately return the claimed amount to the rightful recipient. For example,

     *         AcceleratingDistributor could call this function and then stake atomically on behalf of the user.

     * @dev    Caller must be in whitelistedClaimers struct set to "true".

     * @param _claim leaf to claim.

     */



    function claimFor(Claim memory _claim) public {

        require(whitelistedClaimers[msg.sender], "unwhitelisted claimer");

        _verifyAndMarkClaimed(_claim);

        merkleWindows[_claim.windowIndex].rewardToken.safeTransfer(msg.sender, _claim.amount);

        emit ClaimFor(

            msg.sender,

            _claim.windowIndex,

            _claim.account,

            _claim.accountIndex,

            _claim.amount,

            address(merkleWindows[_claim.windowIndex].rewardToken)

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\AcrossToken.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import "@openzeppelin/contracts/access/Ownable.sol";



contract AcrossToken is ERC20, Ownable {

    constructor() ERC20("Across Protocol Token", "ACX") {}



    function mint(address _guy, uint256 _wad) external onlyOwner {

        _mint(_guy, _wad);

    }



    function burn(address _guy, uint256 _wad) external onlyOwner {

        _burn(_guy, _wad);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\AdapterInterface.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



/**

 * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.

 */



interface AdapterInterface {

    event MessageRelayed(address target, bytes message);



    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);



    function relayMessage(address target, bytes calldata message) external payable;



    function relayTokens(

        address l1Token,

        address l2Token,

        uint256 amount,

        address to

    ) external payable;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)



pragma solidity ^0.8.1;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     *

     * [IMPORTANT]

     * ====

     * You shouldn't rely on `isContract` to protect against flash loan attacks!

     *

     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets

     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract

     * constructor.

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize/address.code.length, which returns 0

        // for contracts in construction, since the code is only stored at the end

        // of the constructor execution.



        return account.code.length > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\AddressWhitelistInterface.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



interface AddressWhitelistInterface {

    function addToWhitelist(address newElement) external;



    function removeFromWhitelist(address newElement) external;



    function isOnWhitelist(address newElement) external view returns (bool);



    function getWhitelist() external view returns (address[] memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Arbitrum_Adapter.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "../interfaces/AdapterInterface.sol";



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



interface ArbitrumL1InboxLike {

    function createRetryableTicket(

        address destAddr,

        uint256 arbTxCallValue,

        uint256 maxSubmissionCost,

        address submissionRefundAddress,

        address valueRefundAddress,

        uint256 maxGas,

        uint256 gasPriceBid,

        bytes calldata data

    ) external payable returns (uint256);

}



interface ArbitrumL1ERC20GatewayLike {

    function outboundTransfer(

        address _token,

        address _to,

        uint256 _amount,

        uint256 _maxGas,

        uint256 _gasPriceBid,

        bytes calldata _data

    ) external payable returns (bytes memory);



    function getGateway(address _token) external view returns (address);

}



/**

 * @notice Contract containing logic to send messages from L1 to Arbitrum.

 * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be

 * called via delegatecall, which will execute this contract's logic within the context of the originating contract.

 * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods

 * that call this contract's logic guard against reentrancy.

 */



// solhint-disable-next-line contract-name-camelcase

contract Arbitrum_Adapter is AdapterInterface {

    using SafeERC20 for IERC20;



    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to

    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their

    // ticket???s calldata in the retry buffer. (current base submission fee is queryable via

    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address

    // 0x000000000000000000000000000000000000006E.

    uint256 public immutable l2MaxSubmissionCost = 0.01e18;



    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)

    uint256 public immutable l2GasPrice = 5e9; // 5 gWei



    // Gas limit for immediate L2 execution attempt (can be estimated via NodeInterface.estimateRetryableTicket).

    // NodeInterface precompile interface exists at L2 address 0x00000000000000000000000000000000000000C8

    uint32 public immutable l2GasLimit = 2_000_000;



    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.

    address public immutable l2RefundL2Address;



    ArbitrumL1InboxLike public immutable l1Inbox;



    ArbitrumL1ERC20GatewayLike public immutable l1ERC20GatewayRouter;



    /**

     * @notice Constructs new Adapter.

     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.

     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.

     */

    constructor(ArbitrumL1InboxLike _l1ArbitrumInbox, ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter) {

        l1Inbox = _l1ArbitrumInbox;

        l1ERC20GatewayRouter = _l1ERC20GatewayRouter;



        l2RefundL2Address = msg.sender;

    }



    /**

     * @notice Send cross-chain message to target on Arbitrum.

     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox

     * successfully, or the message will get stuck.

     * @param target Contract on Arbitrum that will receive message.

     * @param message Data to send to target.

     */

    function relayMessage(address target, bytes memory message) external payable override {

        uint256 requiredL1CallValue = _contractHasSufficientEthBalance();



        l1Inbox.createRetryableTicket{ value: requiredL1CallValue }(

            target, // destAddr destination L2 contract address

            0, // l2CallValue call value for retryable L2 message

            l2MaxSubmissionCost, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee

            l2RefundL2Address, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2

            l2RefundL2Address, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled

            l2GasLimit, // maxGas Max gas deducted from user's L2 balance to cover L2 execution

            l2GasPrice, // gasPriceBid price bid for L2 execution

            message // data ABI encoded data of L2 message

        );



        emit MessageRelayed(target, message);

    }



    /**

     * @notice Bridge tokens to Arbitrum.

     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox

     * successfully, or the message will get stuck.

     * @param l1Token L1 token to deposit.

     * @param l2Token L2 token to receive.

     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.

     * @param to Bridge recipient.

     */

    function relayTokens(

        address l1Token,

        address l2Token, // l2Token is unused for Arbitrum.

        uint256 amount,

        address to

    ) external payable override {

        uint256 requiredL1CallValue = _contractHasSufficientEthBalance();



        // Approve the gateway, not the router, to spend the hub pool's balance. The gateway, which is different

        // per L1 token, will temporarily escrow the tokens to be bridged and pull them from this contract.

        address erc20Gateway = l1ERC20GatewayRouter.getGateway(l1Token);

        IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);



        // `outboundTransfer` expects that the caller includes a bytes message as the last param that includes the

        // maxSubmissionCost to use when creating an L2 retryable ticket: https://github.com/OffchainLabs/arbitrum/blob/e98d14873dd77513b569771f47b5e05b72402c5e/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L232

        bytes memory data = abi.encode(l2MaxSubmissionCost, "");



        // Note: outboundTransfer() will ultimately create a retryable ticket and set this contract's address as the

        // refund address. This means that the excess ETH to pay for the L2 transaction will be sent to the aliased

        // contract address on L2 and lost.

        l1ERC20GatewayRouter.outboundTransfer{ value: requiredL1CallValue }(

            l1Token,

            to,

            amount,

            l2GasLimit,

            l2GasPrice,

            data

        );



        emit TokensRelayed(l1Token, l2Token, amount, to);

    }



    /**

     * @notice Returns required amount of ETH to send a message via the Inbox.

     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.

     */

    function getL1CallValue() public pure returns (uint256) {

        return l2MaxSubmissionCost + l2GasPrice * l2GasLimit;

    }



    function _contractHasSufficientEthBalance() internal view returns (uint256 requiredL1CallValue) {

        requiredL1CallValue = getL1CallValue();

        require(address(this).balance >= requiredL1CallValue, "Insufficient ETH balance");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Boba_Adapter.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "../interfaces/AdapterInterface.sol";

import "../interfaces/WETH9.sol";



// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need

// this contract's state variables to be `immutable` because of the delegateCall call.

import "./CrossDomainEnabled.sol";

import "@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol";



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



/**

 * @notice Contract containing logic to send messages from L1 to Boba. This is a modified version of the Optimism adapter

 * that excludes the custom bridging logic.

 * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be

 * called via delegatecall, which will execute this contract's logic within the context of the originating contract.

 * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods

 * that call this contract's logic guard against reentrancy.

 */



// solhint-disable-next-line contract-name-camelcase

contract Boba_Adapter is CrossDomainEnabled, AdapterInterface {

    using SafeERC20 for IERC20;

    uint32 public immutable l2GasLimit = 2_000_000;



    WETH9 public immutable l1Weth;



    IL1StandardBridge public immutable l1StandardBridge;



    /**

     * @notice Constructs new Adapter.

     * @param _l1Weth WETH address on L1.

     * @param _crossDomainMessenger XDomainMessenger Boba system contract.

     * @param _l1StandardBridge Standard bridge contract.

     */

    constructor(

        WETH9 _l1Weth,

        address _crossDomainMessenger,

        IL1StandardBridge _l1StandardBridge

    ) CrossDomainEnabled(_crossDomainMessenger) {

        l1Weth = _l1Weth;

        l1StandardBridge = _l1StandardBridge;

    }



    /**

     * @notice Send cross-chain message to target on Boba.

     * @param target Contract on Boba that will receive message.

     * @param message Data to send to target.

     */

    function relayMessage(address target, bytes calldata message) external payable override {

        sendCrossDomainMessage(target, uint32(l2GasLimit), message);

        emit MessageRelayed(target, message);

    }



    /**

     * @notice Bridge tokens to Boba.

     * @param l1Token L1 token to deposit.

     * @param l2Token L2 token to receive.

     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.

     * @param to Bridge recipient.

     */

    function relayTokens(

        address l1Token,

        address l2Token,

        uint256 amount,

        address to

    ) external payable override {

        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.

        if (l1Token == address(l1Weth)) {

            l1Weth.withdraw(amount);

            l1StandardBridge.depositETHTo{ value: amount }(to, l2GasLimit, "");

        } else {

            IL1StandardBridge _l1StandardBridge = l1StandardBridge;



            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);

            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, l2GasLimit, "");

        }

        emit TokensRelayed(l1Token, l2Token, amount, to);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\ClaimAndStake.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/utils/Multicall.sol";

import "@across-protocol/contracts-v2/contracts/merkle-distributor/AcrossMerkleDistributor.sol";

import "./AcceleratingDistributor.sol";



/**

 * @notice Allows claimer to claim tokens from AcrossMerkleDistributor and stake into AcceleratingDistributor

 * atomically in a single transaction. This intermediary contract also removes the need for claimer to approve

 * AcceleratingDistributor to spend its staking tokens.

 */



contract ClaimAndStake is ReentrancyGuard, Multicall {

    using SafeERC20 for IERC20;



    // Contract which rewards tokens to users that they can then stake.

    AcrossMerkleDistributor public immutable merkleDistributor;



    // Contract that user stakes claimed tokens into.

    AcceleratingDistributor public immutable acceleratingDistributor;



    constructor(AcrossMerkleDistributor _merkleDistributor, AcceleratingDistributor _acceleratingDistributor) {

        merkleDistributor = _merkleDistributor;

        acceleratingDistributor = _acceleratingDistributor;

    }



    /**************************************

     *          ADMIN FUNCTIONS           *

     **************************************/



    /**

     * @notice Claim tokens from a MerkleDistributor contract and stake them for rewards in AcceleratingDistributor.

     * @dev Will revert if `merkleDistributor` is not set to valid MerkleDistributor contract.

     * @dev Will revert if the claim recipient account is not equal to caller, or if the reward token

     *      for claim is not a valid staking token.

     * @dev Will revert if this contract is not a "whitelisted claimer" on the MerkleDistributor contract.

     * @param _claim Claim leaf to retrieve from MerkleDistributor.

     */

    function claimAndStake(MerkleDistributorInterface.Claim memory _claim) external nonReentrant {

        require(_claim.account == msg.sender, "claim account not caller");

        address stakedToken = merkleDistributor.getRewardTokenForWindow(_claim.windowIndex);

        merkleDistributor.claimFor(_claim);

        IERC20(stakedToken).safeIncreaseAllowance(address(acceleratingDistributor), _claim.amount);

        acceleratingDistributor.stakeFor(stakedToken, _claim.amount, msg.sender);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Constants.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



/**

 * @title Stores common interface names used throughout the DVM by registration in the Finder.

 */

library OracleInterfaces {

    bytes32 public constant Oracle = "Oracle";

    bytes32 public constant IdentifierWhitelist = "IdentifierWhitelist";

    bytes32 public constant Store = "Store";

    bytes32 public constant FinancialContractsAdmin = "FinancialContractsAdmin";

    bytes32 public constant Registry = "Registry";

    bytes32 public constant CollateralWhitelist = "CollateralWhitelist";

    bytes32 public constant OptimisticOracle = "OptimisticOracle";

    bytes32 public constant Bridge = "Bridge";

    bytes32 public constant GenericHandler = "GenericHandler";

    bytes32 public constant SkinnyOptimisticOracle = "SkinnyOptimisticOracle";

    bytes32 public constant ChildMessenger = "ChildMessenger";

    bytes32 public constant OracleHub = "OracleHub";

    bytes32 public constant OracleSpoke = "OracleSpoke";

}



/**

 * @title Commonly re-used values for contracts associated with the OptimisticOracle.

 */

library OptimisticOracleConstraints {

    // Any price request submitted to the OptimisticOracle must contain ancillary data no larger than this value.

    // This value must be <= the Voting contract's `ancillaryBytesLimit` constant value otherwise it is possible

    // that a price can be requested to the OptimisticOracle successfully, but cannot be resolved by the DVM which

    // refuses to accept a price request made with ancillary data length over a certain size.

    uint256 public constant ancillaryBytesLimit = 8192;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)



pragma solidity ^0.8.0;



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\CrossDomainEnabled.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



/* Interface Imports */

import { ICrossDomainMessenger } from "@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol";



/**

 * @title CrossDomainEnabled

 * @dev Helper contract for contracts performing cross-domain communications between L1 and Optimism.

 * @dev This modifies the eth-optimism/CrossDomainEnabled contract only by changing state variables to be

 * immutable for use in contracts like the Optimism_Adapter which use delegateCall().

 */

contract CrossDomainEnabled {

    // Messenger contract used to send and recieve messages from the other domain.

    address public immutable messenger;



    /**

     * @param _messenger Address of the CrossDomainMessenger on the current layer.

     */

    constructor(address _messenger) {

        messenger = _messenger;

    }



    /**

     * Enforces that the modified function is only callable by a specific cross-domain account.

     * @param _sourceDomainAccount The only account on the originating domain which is

     *  authenticated to call this function.

     */

    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {

        require(msg.sender == address(getCrossDomainMessenger()), "invalid cross domain messenger");



        require(

            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,

            "invalid cross domain sender"

        );



        _;

    }



    /**

     * Gets the messenger, usually from storage. This function is exposed in case a child contract

     * needs to override.

     * @return The address of the cross-domain messenger contract which should be used.

     */

    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {

        return ICrossDomainMessenger(messenger);

    }



    /**

     * Sends a message to an account on another domain

     * @param _crossDomainTarget The intended recipient on the destination domain

     * @param _message The data to send to the target (usually calldata to a function with

     *  onlyFromCrossDomainAccount())

     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.

     */

    function sendCrossDomainMessage(

        address _crossDomainTarget,

        uint32 _gasLimit,

        bytes calldata _message

    ) internal {

        // slither-disable-next-line reentrancy-events, reentrancy-benign

        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\draft-IERC20Permit.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in

 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].

 *

 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by

 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't

 * need to send a transaction, and thus is not required to hold Ether at all.

 */

interface IERC20Permit {

    /**

     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,

     * given ``owner``'s signed approval.

     *

     * IMPORTANT: The same issues {IERC20-approve} has related to transaction

     * ordering also apply here.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `deadline` must be a timestamp in the future.

     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`

     * over the EIP712-formatted function arguments.

     * - the signature must use ``owner``'s current nonce (see {nonces}).

     *

     * For more information on the signature format, see the

     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP

     * section].

     */

    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external;



    /**

     * @dev Returns the current nonce for `owner`. This value must be

     * included whenever a signature is generated for {permit}.

     *

     * Every successful call to {permit} increases ``owner``'s nonce by one. This

     * prevents a signature from being used multiple times.

     */

    function nonces(address owner) external view returns (uint256);



    /**

     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.

     */

    // solhint-disable-next-line func-name-mixedcase

    function DOMAIN_SEPARATOR() external view returns (bytes32);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\ECDSA.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)



pragma solidity ^0.8.0;



import "../Strings.sol";



/**

 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.

 *

 * These functions can be used to verify that a message was signed by the holder

 * of the private keys of a given address.

 */

library ECDSA {

    enum RecoverError {

        NoError,

        InvalidSignature,

        InvalidSignatureLength,

        InvalidSignatureS,

        InvalidSignatureV

    }



    function _throwError(RecoverError error) private pure {

        if (error == RecoverError.NoError) {

            return; // no error: do nothing

        } else if (error == RecoverError.InvalidSignature) {

            revert("ECDSA: invalid signature");

        } else if (error == RecoverError.InvalidSignatureLength) {

            revert("ECDSA: invalid signature length");

        } else if (error == RecoverError.InvalidSignatureS) {

            revert("ECDSA: invalid signature 's' value");

        } else if (error == RecoverError.InvalidSignatureV) {

            revert("ECDSA: invalid signature 'v' value");

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature` or error string. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     *

     * Documentation for signature generation:

     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]

     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {

        // Check the signature length

        // - case 65: r,s,v signature (standard)

        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._

        if (signature.length == 65) {

            bytes32 r;

            bytes32 s;

            uint8 v;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            assembly {

                r := mload(add(signature, 0x20))

                s := mload(add(signature, 0x40))

                v := byte(0, mload(add(signature, 0x60)))

            }

            return tryRecover(hash, v, r, s);

        } else if (signature.length == 64) {

            bytes32 r;

            bytes32 vs;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            assembly {

                r := mload(add(signature, 0x20))

                vs := mload(add(signature, 0x40))

            }

            return tryRecover(hash, r, vs);

        } else {

            return (address(0), RecoverError.InvalidSignatureLength);

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature`. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     */

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, signature);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.

     *

     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address, RecoverError) {

        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);

        uint8 v = uint8((uint256(vs) >> 255) + 27);

        return tryRecover(hash, v, r, s);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.

     *

     * _Available since v4.2._

     */

    function recover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, r, vs);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,

     * `r` and `s` signature fields separately.

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address, RecoverError) {

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature

        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines

        // the valid range for s in (301): 0 < s < secp256k1n ?? 2 + 1, and for v in (302): v ?? {27, 28}. Most

        // signatures from current libraries generate a unique signature with an s-value in the lower half order.

        //

        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value

        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or

        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept

        // these malleable signatures as well.

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            return (address(0), RecoverError.InvalidSignatureS);

        }

        if (v != 27 && v != 28) {

            return (address(0), RecoverError.InvalidSignatureV);

        }



        // If the signature is valid (and not malleable), return the signer address

        address signer = ecrecover(hash, v, r, s);

        if (signer == address(0)) {

            return (address(0), RecoverError.InvalidSignature);

        }



        return (signer, RecoverError.NoError);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `v`,

     * `r` and `s` signature fields separately.

     */

    function recover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from a `hash`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        // 32 is the length in bytes of hash,

        // enforced by the type signature above

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from `s`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));

    }



    /**

     * @dev Returns an Ethereum Signed Typed Data, created from a

     * `domainSeparator` and a `structHash`. This produces hash corresponding

     * to the one signed with the

     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]

     * JSON-RPC method as part of EIP-712.

     *

     * See {recover}.

     */

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\ERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)



pragma solidity ^0.8.0;



import "./IERC20.sol";

import "./extensions/IERC20Metadata.sol";

import "../../utils/Context.sol";



/**

 * @dev Implementation of the {IERC20} interface.

 *

 * This implementation is agnostic to the way tokens are created. This means

 * that a supply mechanism has to be added in a derived contract using {_mint}.

 * For a generic mechanism see {ERC20PresetMinterPauser}.

 *

 * TIP: For a detailed writeup see our guide

 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How

 * to implement supply mechanisms].

 *

 * We have followed general OpenZeppelin Contracts guidelines: functions revert

 * instead returning `false` on failure. This behavior is nonetheless

 * conventional and does not conflict with the expectations of ERC20

 * applications.

 *

 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.

 * This allows applications to reconstruct the allowance for all accounts just

 * by listening to said events. Other implementations of the EIP may not emit

 * these events, as it isn't required by the specification.

 *

 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}

 * functions have been added to mitigate the well-known issues around setting

 * allowances. See {IERC20-approve}.

 */

contract ERC20 is Context, IERC20, IERC20Metadata {

    mapping(address => uint256) private _balances;



    mapping(address => mapping(address => uint256)) private _allowances;



    uint256 private _totalSupply;



    string private _name;

    string private _symbol;



    /**

     * @dev Sets the values for {name} and {symbol}.

     *

     * The default value of {decimals} is 18. To select a different value for

     * {decimals} you should overload it.

     *

     * All two of these values are immutable: they can only be set once during

     * construction.

     */

    constructor(string memory name_, string memory symbol_) {

        _name = name_;

        _symbol = symbol_;

    }



    /**

     * @dev Returns the name of the token.

     */

    function name() public view virtual override returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view virtual override returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5.05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei. This is the value {ERC20} uses, unless this function is

     * overridden;

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view virtual override returns (uint8) {

        return 18;

    }



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view virtual override returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view virtual override returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address to, uint256 amount) public virtual override returns (bool) {

        address owner = _msgSender();

        _transfer(owner, to, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on

     * `transferFrom`. This is semantically equivalent to an infinite approval.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        address owner = _msgSender();

        _approve(owner, spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20}.

     *

     * NOTE: Does not update the allowance if the current allowance

     * is the maximum `uint256`.

     *

     * Requirements:

     *

     * - `from` and `to` cannot be the zero address.

     * - `from` must have a balance of at least `amount`.

     * - the caller must have allowance for ``from``'s tokens of at least

     * `amount`.

     */

    function transferFrom(

        address from,

        address to,

        uint256 amount

    ) public virtual override returns (bool) {

        address spender = _msgSender();

        _spendAllowance(from, spender, amount);

        _transfer(from, to, amount);

        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        address owner = _msgSender();

        _approve(owner, spender, _allowances[owner][spender] + addedValue);

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        address owner = _msgSender();

        uint256 currentAllowance = _allowances[owner][spender];

        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");

        unchecked {

            _approve(owner, spender, currentAllowance - subtractedValue);

        }



        return true;

    }



    /**

     * @dev Moves `amount` of tokens from `sender` to `recipient`.

     *

     * This internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `from` must have a balance of at least `amount`.

     */

    function _transfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual {

        require(from != address(0), "ERC20: transfer from the zero address");

        require(to != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(from, to, amount);



        uint256 fromBalance = _balances[from];

        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");

        unchecked {

            _balances[from] = fromBalance - amount;

        }

        _balances[to] += amount;



        emit Transfer(from, to, amount);



        _afterTokenTransfer(from, to, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply += amount;

        _balances[account] += amount;

        emit Transfer(address(0), account, amount);



        _afterTokenTransfer(address(0), account, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        uint256 accountBalance = _balances[account];

        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");

        unchecked {

            _balances[account] = accountBalance - amount;

        }

        _totalSupply -= amount;



        emit Transfer(account, address(0), amount);



        _afterTokenTransfer(account, address(0), amount);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.

     *

     * This internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(

        address owner,

        address spender,

        uint256 amount

    ) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    /**

     * @dev Spend `amount` form the allowance of `owner` toward `spender`.

     *

     * Does not update the allowance amount in case of infinite allowance.

     * Revert if not enough allowance is available.

     *

     * Might emit an {Approval} event.

     */

    function _spendAllowance(

        address owner,

        address spender,

        uint256 amount

    ) internal virtual {

        uint256 currentAllowance = allowance(owner, spender);

        if (currentAllowance != type(uint256).max) {

            require(currentAllowance >= amount, "ERC20: insufficient allowance");

            unchecked {

                _approve(owner, spender, currentAllowance - amount);

            }

        }

    }



    /**

     * @dev Hook that is called before any transfer of tokens. This includes

     * minting and burning.

     *

     * Calling conditions:

     *

     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * will be transferred to `to`.

     * - when `from` is zero, `amount` tokens will be minted for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.

     * - `from` and `to` are never both zero.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual {}



    /**

     * @dev Hook that is called after any transfer of tokens. This includes

     * minting and burning.

     *

     * Calling conditions:

     *

     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * has been transferred to `to`.

     * - when `from` is zero, `amount` tokens have been minted for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.

     * - `from` and `to` are never both zero.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _afterTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Ethereum_Adapter.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "../interfaces/AdapterInterface.sol";



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



/**

 * @notice Contract containing logic to send messages from L1 to Ethereum SpokePool.

 * @notice This contract should always be deployed on the same chain as the HubPool, as it acts as a pass-through

 * contract between HubPool and SpokePool on the same chain. Its named "Ethereum_Adapter" because a core assumption

 * is that the HubPool will be deployed on Ethereum, so this adapter will be used to communicate between HubPool

 * and the Ethereum_SpokePool.

 * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be

 * called via delegatecall, which will execute this contract's logic within the context of the originating contract.

 * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods

 * that call this contract's logic guard against reentrancy.

 */



// solhint-disable-next-line contract-name-camelcase

contract Ethereum_Adapter is AdapterInterface {

    using SafeERC20 for IERC20;



    /**

     * @notice Send message to target on Ethereum.

     * @notice This function, and contract overall, is not useful in practice except that the HubPool

     * expects to interact with the SpokePool via an Adapter, so when communicating to the Ethereum_SpokePool, it must

     * send messages via this pass-through contract.

     * @param target Contract that will receive message.

     * @param message Data to send to target.

     */

    function relayMessage(address target, bytes calldata message) external payable override {

        _executeCall(target, message);

        emit MessageRelayed(target, message);

    }



    /**

     * @notice Send tokens to target.

     * @param l1Token L1 token to send.

     * @param l2Token Unused parameter in this contract.

     * @param amount Amount of L1 tokens to send.

     * @param to recipient.

     */

    function relayTokens(

        address l1Token,

        address l2Token, // l2Token is unused for ethereum since we are assuming that the HubPool is only deployed

        // on this network.

        uint256 amount,

        address to

    ) external payable override {

        IERC20(l1Token).safeTransfer(to, amount);

        emit TokensRelayed(l1Token, l2Token, amount, to);

    }



    // Note: this snippet of code is copied from Governor.sol. Source: https://github.com/UMAprotocol/protocol/blob/5b37ea818a28479c01e458389a83c3e736306b17/packages/core/contracts/oracle/implementation/Governor.sol#L190-L207

    function _executeCall(address to, bytes memory data) private {

        // Note: this snippet of code is copied from Governor.sol and modified to not include any "value" field.



        bool success;



        // solhint-disable-next-line no-inline-assembly

        assembly {

            let inputData := add(data, 0x20)

            let inputDataSize := mload(data)

            // Hardcode value to be 0 for relayed governance calls in order to avoid addressing complexity of bridging

            // value cross-chain.

            success := call(gas(), to, 0, inputData, inputDataSize, 0, 0)

        }

        require(success, "execute call failed");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Ethereum_SpokePool.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "./SpokePool.sol";

import "@openzeppelin/contracts/access/Ownable.sol";



/**

 * @notice Ethereum L1 specific SpokePool. Used on Ethereum L1 to facilitate L2->L1 transfers.

 */

contract Ethereum_SpokePool is SpokePool, Ownable {

    /**

     * @notice Construct the Ethereum SpokePool.

     * @param _hubPool Hub pool address to set. Can be changed by admin.

     * @param _wethAddress Weth address for this network to set.

     * @param timerAddress Timer address to set.

     */

    constructor(

        address _hubPool,

        address _wethAddress,

        address timerAddress

    ) SpokePool(msg.sender, _hubPool, _wethAddress, timerAddress) {}



    /**************************************

     *          INTERNAL FUNCTIONS           *

     **************************************/



    function _bridgeTokensToHubPool(RelayerRefundLeaf memory relayerRefundLeaf) internal override {

        IERC20(relayerRefundLeaf.l2TokenAddress).transfer(hubPool, relayerRefundLeaf.amountToReturn);

    }



    // Admin is simply owner which should be same account that owns the HubPool deployed on this network. A core

    // assumption of this contract system is that the HubPool is deployed on Ethereum.

    function _requireAdminSender() internal override onlyOwner {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\ExpandedERC20.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import "./MultiRole.sol";

import "../interfaces/ExpandedIERC20.sol";



/**

 * @title An ERC20 with permissioned burning and minting. The contract deployer will initially

 * be the owner who is capable of adding new roles.

 */

contract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {

    enum Roles {

        // Can set the minter and burner.

        Owner,

        // Addresses that can mint new tokens.

        Minter,

        // Addresses that can burn tokens that address owns.

        Burner

    }



    uint8 _decimals;



    /**

     * @notice Constructs the ExpandedERC20.

     * @param _tokenName The name which describes the new token.

     * @param _tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.

     * @param _tokenDecimals The number of decimals to define token precision.

     */

    constructor(

        string memory _tokenName,

        string memory _tokenSymbol,

        uint8 _tokenDecimals

    ) ERC20(_tokenName, _tokenSymbol) {

        _decimals = _tokenDecimals;

        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);

        _createSharedRole(uint256(Roles.Minter), uint256(Roles.Owner), new address[](0));

        _createSharedRole(uint256(Roles.Burner), uint256(Roles.Owner), new address[](0));

    }



    function decimals() public view virtual override(ERC20) returns (uint8) {

        return _decimals;

    }



    /**

     * @dev Mints `value` tokens to `recipient`, returning true on success.

     * @param recipient address to mint to.

     * @param value amount of tokens to mint.

     * @return True if the mint succeeded, or False.

     */

    function mint(address recipient, uint256 value)

        external

        override

        onlyRoleHolder(uint256(Roles.Minter))

        returns (bool)

    {

        _mint(recipient, value);

        return true;

    }



    /**

     * @dev Burns `value` tokens owned by `msg.sender`.

     * @param value amount of tokens to burn.

     */

    function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {

        _burn(msg.sender, value);

    }



    /**

     * @dev Burns `value` tokens owned by `recipient`.

     * @param recipient address to burn tokens from.

     * @param value amount of tokens to burn.

     * @return True if the burn succeeded, or False.

     */

    function burnFrom(address recipient, uint256 value)

        external

        override

        onlyRoleHolder(uint256(Roles.Burner))

        returns (bool)

    {

        _burn(recipient, value);

        return true;

    }



    /**

     * @notice Add Minter role to account.

     * @dev The caller must have the Owner role.

     * @param account The address to which the Minter role is added.

     */

    function addMinter(address account) external virtual override {

        addMember(uint256(Roles.Minter), account);

    }



    /**

     * @notice Add Burner role to account.

     * @dev The caller must have the Owner role.

     * @param account The address to which the Burner role is added.

     */

    function addBurner(address account) external virtual override {

        addMember(uint256(Roles.Burner), account);

    }



    /**

     * @notice Reset Owner role to account.

     * @dev The caller must have the Owner role.

     * @param account The new holder of the Owner role.

     */

    function resetOwner(address account) external virtual override {

        resetMember(uint256(Roles.Owner), account);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\ExpandedIERC20.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";



/**

 * @title ERC20 interface that includes burn and mint methods.

 */

abstract contract ExpandedIERC20 is IERC20 {

    /**

     * @notice Burns a specific amount of the caller's tokens.

     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.

     */

    function burn(uint256 value) external virtual;



    /**

     * @dev Burns `value` tokens owned by `recipient`.

     * @param recipient address to burn tokens from.

     * @param value amount of tokens to burn.

     */

    function burnFrom(address recipient, uint256 value) external virtual returns (bool);



    /**

     * @notice Mints tokens and adds them to the balance of the `to` address.

     * @dev This method should be permissioned to only allow designated parties to mint tokens.

     */

    function mint(address to, uint256 value) external virtual returns (bool);



    function addMinter(address account) external virtual;



    function addBurner(address account) external virtual;



    function resetOwner(address account) external virtual;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\FinderInterface.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



/**

 * @title Provides addresses of the live contracts implementing certain interfaces.

 * @dev Examples are the Oracle or Store interfaces.

 */

interface FinderInterface {

    /**

     * @notice Updates the address of the contract that implements `interfaceName`.

     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.

     * @param implementationAddress address of the deployed contract that implements the interface.

     */

    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;



    /**

     * @notice Gets the address of the contract that implements the given `interfaceName`.

     * @param interfaceName queried interface.

     * @return implementationAddress address of the deployed contract that implements the interface.

     */

    function getImplementationAddress(bytes32 interfaceName) external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\FixedPoint.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "@openzeppelin/contracts/utils/math/SignedSafeMath.sol";



/**

 * @title Library for fixed point arithmetic on uints

 */

library FixedPoint {

    using SafeMath for uint256;

    using SignedSafeMath for int256;



    // Supports 18 decimals. E.g., 1e18 represents "1", 5e17 represents "0.5".

    // For unsigned values:

    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.

    uint256 private constant FP_SCALING_FACTOR = 10**18;



    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------

    struct Unsigned {

        uint256 rawValue;

    }



    /**

     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.

     * @param a uint to convert into a FixedPoint.

     * @return the converted FixedPoint.

     */

    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {

        return Unsigned(a.mul(FP_SCALING_FACTOR));

    }



    /**

     * @notice Whether `a` is equal to `b`.

     * @param a a FixedPoint.

     * @param b a uint256.

     * @return True if equal, or False.

     */

    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {

        return a.rawValue == fromUnscaledUint(b).rawValue;

    }



    /**

     * @notice Whether `a` is equal to `b`.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return True if equal, or False.

     */

    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {

        return a.rawValue == b.rawValue;

    }



    /**

     * @notice Whether `a` is greater than `b`.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return True if `a > b`, or False.

     */

    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {

        return a.rawValue > b.rawValue;

    }



    /**

     * @notice Whether `a` is greater than `b`.

     * @param a a FixedPoint.

     * @param b a uint256.

     * @return True if `a > b`, or False.

     */

    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {

        return a.rawValue > fromUnscaledUint(b).rawValue;

    }



    /**

     * @notice Whether `a` is greater than `b`.

     * @param a a uint256.

     * @param b a FixedPoint.

     * @return True if `a > b`, or False.

     */

    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {

        return fromUnscaledUint(a).rawValue > b.rawValue;

    }



    /**

     * @notice Whether `a` is greater than or equal to `b`.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return True if `a >= b`, or False.

     */

    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {

        return a.rawValue >= b.rawValue;

    }



    /**

     * @notice Whether `a` is greater than or equal to `b`.

     * @param a a FixedPoint.

     * @param b a uint256.

     * @return True if `a >= b`, or False.

     */

    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {

        return a.rawValue >= fromUnscaledUint(b).rawValue;

    }



    /**

     * @notice Whether `a` is greater than or equal to `b`.

     * @param a a uint256.

     * @param b a FixedPoint.

     * @return True if `a >= b`, or False.

     */

    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {

        return fromUnscaledUint(a).rawValue >= b.rawValue;

    }



    /**

     * @notice Whether `a` is less than `b`.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return True if `a < b`, or False.

     */

    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {

        return a.rawValue < b.rawValue;

    }



    /**

     * @notice Whether `a` is less than `b`.

     * @param a a FixedPoint.

     * @param b a uint256.

     * @return True if `a < b`, or False.

     */

    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {

        return a.rawValue < fromUnscaledUint(b).rawValue;

    }



    /**

     * @notice Whether `a` is less than `b`.

     * @param a a uint256.

     * @param b a FixedPoint.

     * @return True if `a < b`, or False.

     */

    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {

        return fromUnscaledUint(a).rawValue < b.rawValue;

    }



    /**

     * @notice Whether `a` is less than or equal to `b`.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return True if `a <= b`, or False.

     */

    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {

        return a.rawValue <= b.rawValue;

    }



    /**

     * @notice Whether `a` is less than or equal to `b`.

     * @param a a FixedPoint.

     * @param b a uint256.

     * @return True if `a <= b`, or False.

     */

    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {

        return a.rawValue <= fromUnscaledUint(b).rawValue;

    }



    /**

     * @notice Whether `a` is less than or equal to `b`.

     * @param a a uint256.

     * @param b a FixedPoint.

     * @return True if `a <= b`, or False.

     */

    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {

        return fromUnscaledUint(a).rawValue <= b.rawValue;

    }



    /**

     * @notice The minimum of `a` and `b`.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return the minimum of `a` and `b`.

     */

    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {

        return a.rawValue < b.rawValue ? a : b;

    }



    /**

     * @notice The maximum of `a` and `b`.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return the maximum of `a` and `b`.

     */

    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {

        return a.rawValue > b.rawValue ? a : b;

    }



    /**

     * @notice Adds two `Unsigned`s, reverting on overflow.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return the sum of `a` and `b`.

     */

    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {

        return Unsigned(a.rawValue.add(b.rawValue));

    }



    /**

     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.

     * @param a a FixedPoint.

     * @param b a uint256.

     * @return the sum of `a` and `b`.

     */

    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {

        return add(a, fromUnscaledUint(b));

    }



    /**

     * @notice Subtracts two `Unsigned`s, reverting on overflow.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return the difference of `a` and `b`.

     */

    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {

        return Unsigned(a.rawValue.sub(b.rawValue));

    }



    /**

     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.

     * @param a a FixedPoint.

     * @param b a uint256.

     * @return the difference of `a` and `b`.

     */

    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {

        return sub(a, fromUnscaledUint(b));

    }



    /**

     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.

     * @param a a uint256.

     * @param b a FixedPoint.

     * @return the difference of `a` and `b`.

     */

    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {

        return sub(fromUnscaledUint(a), b);

    }



    /**

     * @notice Multiplies two `Unsigned`s, reverting on overflow.

     * @dev This will "floor" the product.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return the product of `a` and `b`.

     */

    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {

        // There are two caveats with this computation:

        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is

        // stored internally as a uint256 ~10^59.

        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which

        // would round to 3, but this computation produces the result 2.

        // No need to use SafeMath because FP_SCALING_FACTOR != 0.

        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);

    }



    /**

     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.

     * @dev This will "floor" the product.

     * @param a a FixedPoint.

     * @param b a uint256.

     * @return the product of `a` and `b`.

     */

    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {

        return Unsigned(a.rawValue.mul(b));

    }



    /**

     * @notice Multiplies two `Unsigned`s and "ceil's" the product, reverting on overflow.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return the product of `a` and `b`.

     */

    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {

        uint256 mulRaw = a.rawValue.mul(b.rawValue);

        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;

        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);

        if (mod != 0) {

            return Unsigned(mulFloor.add(1));

        } else {

            return Unsigned(mulFloor);

        }

    }



    /**

     * @notice Multiplies an `Unsigned` and an unscaled uint256 and "ceil's" the product, reverting on overflow.

     * @param a a FixedPoint.

     * @param b a FixedPoint.

     * @return the product of `a` and `b`.

     */

    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {

        // Since b is an uint, there is no risk of truncation and we can just mul it normally

        return Unsigned(a.rawValue.mul(b));

    }



    /**

     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.

     * @dev This will "floor" the quotient.

     * @param a a FixedPoint numerator.

     * @param b a FixedPoint denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {

        // There are two caveats with this computation:

        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.

        // 10^41 is stored internally as a uint256 10^59.

        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which

        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.

        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));

    }



    /**

     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.

     * @dev This will "floor" the quotient.

     * @param a a FixedPoint numerator.

     * @param b a uint256 denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {

        return Unsigned(a.rawValue.div(b));

    }



    /**

     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.

     * @dev This will "floor" the quotient.

     * @param a a uint256 numerator.

     * @param b a FixedPoint denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {

        return div(fromUnscaledUint(a), b);

    }



    /**

     * @notice Divides one `Unsigned` by an `Unsigned` and "ceil's" the quotient, reverting on overflow or division by 0.

     * @param a a FixedPoint numerator.

     * @param b a FixedPoint denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {

        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);

        uint256 divFloor = aScaled.div(b.rawValue);

        uint256 mod = aScaled.mod(b.rawValue);

        if (mod != 0) {

            return Unsigned(divFloor.add(1));

        } else {

            return Unsigned(divFloor);

        }

    }



    /**

     * @notice Divides one `Unsigned` by an unscaled uint256 and "ceil's" the quotient, reverting on overflow or division by 0.

     * @param a a FixedPoint numerator.

     * @param b a uint256 denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {

        // Because it is possible that a quotient gets truncated, we can't just call "Unsigned(a.rawValue.div(b))"

        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.

        // This creates the possibility of overflow if b is very large.

        return divCeil(a, fromUnscaledUint(b));

    }



    /**

     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.

     * @dev This will "floor" the result.

     * @param a a FixedPoint numerator.

     * @param b a uint256 denominator.

     * @return output is `a` to the power of `b`.

     */

    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {

        output = fromUnscaledUint(1);

        for (uint256 i = 0; i < b; i = i.add(1)) {

            output = mul(output, a);

        }

    }



    // ------------------------------------------------- SIGNED -------------------------------------------------------------

    // Supports 18 decimals. E.g., 1e18 represents "1", 5e17 represents "0.5".

    // For signed values:

    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.

    int256 private constant SFP_SCALING_FACTOR = 10**18;



    struct Signed {

        int256 rawValue;

    }



    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {

        require(a.rawValue >= 0, "Negative value provided");

        return Unsigned(uint256(a.rawValue));

    }



    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {

        require(a.rawValue <= uint256(type(int256).max), "Unsigned too large");

        return Signed(int256(a.rawValue));

    }



    /**

     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.

     * @param a int to convert into a FixedPoint.Signed.

     * @return the converted FixedPoint.Signed.

     */

    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {

        return Signed(a.mul(SFP_SCALING_FACTOR));

    }



    /**

     * @notice Whether `a` is equal to `b`.

     * @param a a FixedPoint.Signed.

     * @param b a int256.

     * @return True if equal, or False.

     */

    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {

        return a.rawValue == fromUnscaledInt(b).rawValue;

    }



    /**

     * @notice Whether `a` is equal to `b`.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return True if equal, or False.

     */

    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {

        return a.rawValue == b.rawValue;

    }



    /**

     * @notice Whether `a` is greater than `b`.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return True if `a > b`, or False.

     */

    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {

        return a.rawValue > b.rawValue;

    }



    /**

     * @notice Whether `a` is greater than `b`.

     * @param a a FixedPoint.Signed.

     * @param b an int256.

     * @return True if `a > b`, or False.

     */

    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {

        return a.rawValue > fromUnscaledInt(b).rawValue;

    }



    /**

     * @notice Whether `a` is greater than `b`.

     * @param a an int256.

     * @param b a FixedPoint.Signed.

     * @return True if `a > b`, or False.

     */

    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {

        return fromUnscaledInt(a).rawValue > b.rawValue;

    }



    /**

     * @notice Whether `a` is greater than or equal to `b`.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return True if `a >= b`, or False.

     */

    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {

        return a.rawValue >= b.rawValue;

    }



    /**

     * @notice Whether `a` is greater than or equal to `b`.

     * @param a a FixedPoint.Signed.

     * @param b an int256.

     * @return True if `a >= b`, or False.

     */

    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {

        return a.rawValue >= fromUnscaledInt(b).rawValue;

    }



    /**

     * @notice Whether `a` is greater than or equal to `b`.

     * @param a an int256.

     * @param b a FixedPoint.Signed.

     * @return True if `a >= b`, or False.

     */

    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {

        return fromUnscaledInt(a).rawValue >= b.rawValue;

    }



    /**

     * @notice Whether `a` is less than `b`.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return True if `a < b`, or False.

     */

    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {

        return a.rawValue < b.rawValue;

    }



    /**

     * @notice Whether `a` is less than `b`.

     * @param a a FixedPoint.Signed.

     * @param b an int256.

     * @return True if `a < b`, or False.

     */

    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {

        return a.rawValue < fromUnscaledInt(b).rawValue;

    }



    /**

     * @notice Whether `a` is less than `b`.

     * @param a an int256.

     * @param b a FixedPoint.Signed.

     * @return True if `a < b`, or False.

     */

    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {

        return fromUnscaledInt(a).rawValue < b.rawValue;

    }



    /**

     * @notice Whether `a` is less than or equal to `b`.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return True if `a <= b`, or False.

     */

    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {

        return a.rawValue <= b.rawValue;

    }



    /**

     * @notice Whether `a` is less than or equal to `b`.

     * @param a a FixedPoint.Signed.

     * @param b an int256.

     * @return True if `a <= b`, or False.

     */

    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {

        return a.rawValue <= fromUnscaledInt(b).rawValue;

    }



    /**

     * @notice Whether `a` is less than or equal to `b`.

     * @param a an int256.

     * @param b a FixedPoint.Signed.

     * @return True if `a <= b`, or False.

     */

    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {

        return fromUnscaledInt(a).rawValue <= b.rawValue;

    }



    /**

     * @notice The minimum of `a` and `b`.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return the minimum of `a` and `b`.

     */

    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {

        return a.rawValue < b.rawValue ? a : b;

    }



    /**

     * @notice The maximum of `a` and `b`.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return the maximum of `a` and `b`.

     */

    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {

        return a.rawValue > b.rawValue ? a : b;

    }



    /**

     * @notice Adds two `Signed`s, reverting on overflow.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return the sum of `a` and `b`.

     */

    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {

        return Signed(a.rawValue.add(b.rawValue));

    }



    /**

     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.

     * @param a a FixedPoint.Signed.

     * @param b an int256.

     * @return the sum of `a` and `b`.

     */

    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {

        return add(a, fromUnscaledInt(b));

    }



    /**

     * @notice Subtracts two `Signed`s, reverting on overflow.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return the difference of `a` and `b`.

     */

    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {

        return Signed(a.rawValue.sub(b.rawValue));

    }



    /**

     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.

     * @param a a FixedPoint.Signed.

     * @param b an int256.

     * @return the difference of `a` and `b`.

     */

    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {

        return sub(a, fromUnscaledInt(b));

    }



    /**

     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.

     * @param a an int256.

     * @param b a FixedPoint.Signed.

     * @return the difference of `a` and `b`.

     */

    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {

        return sub(fromUnscaledInt(a), b);

    }



    /**

     * @notice Multiplies two `Signed`s, reverting on overflow.

     * @dev This will "floor" the product.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return the product of `a` and `b`.

     */

    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {

        // There are two caveats with this computation:

        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is

        // stored internally as an int256 ~10^59.

        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which

        // would round to 3, but this computation produces the result 2.

        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.

        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);

    }



    /**

     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.

     * @dev This will "floor" the product.

     * @param a a FixedPoint.Signed.

     * @param b an int256.

     * @return the product of `a` and `b`.

     */

    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {

        return Signed(a.rawValue.mul(b));

    }



    /**

     * @notice Multiplies two `Signed`s and "ceil's" the product, reverting on overflow.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return the product of `a` and `b`.

     */

    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {

        int256 mulRaw = a.rawValue.mul(b.rawValue);

        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;

        // Manual mod because SignedSafeMath doesn't support it.

        int256 mod = mulRaw % SFP_SCALING_FACTOR;

        if (mod != 0) {

            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);

            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);

            return Signed(mulTowardsZero.add(valueToAdd));

        } else {

            return Signed(mulTowardsZero);

        }

    }



    /**

     * @notice Multiplies an `Signed` and an unscaled int256 and "ceil's" the product, reverting on overflow.

     * @param a a FixedPoint.Signed.

     * @param b a FixedPoint.Signed.

     * @return the product of `a` and `b`.

     */

    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {

        // Since b is an int, there is no risk of truncation and we can just mul it normally

        return Signed(a.rawValue.mul(b));

    }



    /**

     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.

     * @dev This will "floor" the quotient.

     * @param a a FixedPoint numerator.

     * @param b a FixedPoint denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {

        // There are two caveats with this computation:

        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.

        // 10^41 is stored internally as an int256 10^59.

        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which

        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.

        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));

    }



    /**

     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.

     * @dev This will "floor" the quotient.

     * @param a a FixedPoint numerator.

     * @param b an int256 denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {

        return Signed(a.rawValue.div(b));

    }



    /**

     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.

     * @dev This will "floor" the quotient.

     * @param a an int256 numerator.

     * @param b a FixedPoint denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {

        return div(fromUnscaledInt(a), b);

    }



    /**

     * @notice Divides one `Signed` by an `Signed` and "ceil's" the quotient, reverting on overflow or division by 0.

     * @param a a FixedPoint numerator.

     * @param b a FixedPoint denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {

        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);

        int256 divTowardsZero = aScaled.div(b.rawValue);

        // Manual mod because SignedSafeMath doesn't support it.

        int256 mod = aScaled % b.rawValue;

        if (mod != 0) {

            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);

            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);

            return Signed(divTowardsZero.add(valueToAdd));

        } else {

            return Signed(divTowardsZero);

        }

    }



    /**

     * @notice Divides one `Signed` by an unscaled int256 and "ceil's" the quotient, reverting on overflow or division by 0.

     * @param a a FixedPoint numerator.

     * @param b an int256 denominator.

     * @return the quotient of `a` divided by `b`.

     */

    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {

        // Because it is possible that a quotient gets truncated, we can't just call "Signed(a.rawValue.div(b))"

        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.

        // This creates the possibility of overflow if b is very large.

        return divAwayFromZero(a, fromUnscaledInt(b));

    }



    /**

     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.

     * @dev This will "floor" the result.

     * @param a a FixedPoint.Signed.

     * @param b a uint256 (negative exponents are not allowed).

     * @return output is `a` to the power of `b`.

     */

    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {

        output = fromUnscaledInt(1);

        for (uint256 i = 0; i < b; i = i.add(1)) {

            output = mul(output, a);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\HubPool.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "./MerkleLib.sol";

import "./HubPoolInterface.sol";

import "./Lockable.sol";



import "./interfaces/LpTokenFactoryInterface.sol";

import "./interfaces/WETH9.sol";



import "@uma/core/contracts/common/implementation/Testable.sol";

import "@uma/core/contracts/common/implementation/MultiCaller.sol";

import "@uma/core/contracts/oracle/implementation/Constants.sol";

import "@uma/core/contracts/common/interfaces/AddressWhitelistInterface.sol";

import "@uma/core/contracts/oracle/interfaces/IdentifierWhitelistInterface.sol";



import "@uma/core/contracts/oracle/interfaces/FinderInterface.sol";

import "@uma/core/contracts/oracle/interfaces/StoreInterface.sol";

import "@uma/core/contracts/oracle/interfaces/SkinnyOptimisticOracleInterface.sol";

import "@uma/core/contracts/common/interfaces/ExpandedIERC20.sol";



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/utils/Address.sol";



/**

 * @notice Contract deployed on Ethereum that houses L1 token liquidity for all SpokePools. A dataworker can interact

 * with merkle roots stored in this contract via inclusion proofs to instruct this contract to send tokens to L2

 * SpokePools via "pool rebalances" that can be used to pay out relayers on those networks. This contract is also

 * responsible for publishing relayer refund and slow relay merkle roots to SpokePools.

 * @notice This contract is meant to act as the cross chain administrator and owner of all L2 spoke pools, so all

 * governance actions and pool rebalances originate from here and bridge instructions to L2s.

 * @dev This contract should be deprecated by the year 2106, at which point uint32 timestamps will roll over. This is

 * an issue for this contract because fee calculations will become bizarre when multiplying by negative time deltas.

 * Before this date, this contract should be paused from accepting new root bundles and all LP tokens should be

 * disabled by the admin.

 */

contract HubPool is HubPoolInterface, Testable, Lockable, MultiCaller, Ownable {

    using SafeERC20 for IERC20;

    using Address for address;



    // Only one root bundle can be stored at a time. Once all pool rebalance leaves are executed, a new proposal

    // can be submitted.

    RootBundle public rootBundleProposal;



    // Mapping of L1 token addresses to the associated pool information.

    mapping(address => PooledToken) public pooledTokens;



    // Stores paths from L1 token + destination ID to destination token. Since different tokens on L1 might map to

    // to the same address on different destinations, we hash (L1 token address, destination ID) to

    // use as a key that maps to a destination token. This mapping is used to direct pool rebalances from

    // HubPool to SpokePool, and also is designed to be used as a lookup for off-chain data workers to determine

    // which L1 tokens to relay to SpokePools to refund relayers. The admin can set the "destination token"

    // to 0x0 to disable a pool rebalance route and block executeRootBundle() from executing.

    mapping(bytes32 => address) private poolRebalanceRoutes;



    // Mapping of chainId to the associated adapter and spokePool contracts.

    mapping(uint256 => CrossChainContract) public crossChainContracts;



    mapping(address => uint256) public unclaimedAccumulatedProtocolFees;



    // Whether the bundle proposal process is paused.

    bool public paused;



    // WETH contract for Ethereum.

    WETH9 public immutable weth;



    // Helper factory to deploy new LP tokens for enabled L1 tokens

    LpTokenFactoryInterface public immutable lpTokenFactory;



    // Finder contract for this network.

    FinderInterface public immutable finder;



    // Address that captures protocol fees. Accumulated protocol fees can be claimed by this address.

    address public protocolFeeCaptureAddress;



    // Token used to bond the data worker for proposing relayer refund bundles.

    IERC20 public bondToken;



    // Each root bundle proposal must stay in liveness for this period of time before it can be considered finalized.

    // It can be disputed only during this period of time. Defaults to 2 hours, like the rest of the UMA ecosystem.

    uint32 public liveness = 7200;



    // When root bundles are disputed a price request is enqueued with the DVM to resolve the resolution.

    bytes32 public identifier = "IS_ACROSS_V2_BUNDLE_VALID";



    // Interest rate payment that scales the amount of pending fees per second paid to LPs. 0.0000015e18 will pay out

    // the full amount of fees entitled to LPs in ~ 7.72 days assuming no contract interactions. If someone interacts

    // with the contract then the LP rewards are smeared sublinearly over the window (i.e spread over the remaining

    // period for each interaction which approximates a decreasing exponential function).

    uint256 public lpFeeRatePerSecond = 1500000000000;



    // Percentage of lpFees that are captured by the protocol and claimable by the protocolFeeCaptureAddress.

    uint256 public protocolFeeCapturePct;



    // The computed bond amount as the UMA Store's final fee multiplied by the bondTokenFinalFeeMultiplier.

    uint256 public bondAmount;



    event Paused(bool indexed isPaused);



    event EmergencyRootBundleDeleted(

        bytes32 indexed poolRebalanceRoot,

        bytes32 indexed relayerRefundRoot,

        bytes32 slowRelayRoot,

        address indexed proposer

    );



    event ProtocolFeeCaptureSet(address indexed newProtocolFeeCaptureAddress, uint256 indexed newProtocolFeeCapturePct);



    event ProtocolFeesCapturedClaimed(address indexed l1Token, uint256 indexed accumulatedFees);



    event BondSet(address indexed newBondToken, uint256 newBondAmount);



    event LivenessSet(uint256 newLiveness);



    event IdentifierSet(bytes32 newIdentifier);



    event CrossChainContractsSet(uint256 l2ChainId, address adapter, address spokePool);



    event L1TokenEnabledForLiquidityProvision(address l1Token, address lpToken);



    event L2TokenDisabledForLiquidityProvision(address l1Token, address lpToken);



    event LiquidityAdded(

        address indexed l1Token,

        uint256 amount,

        uint256 lpTokensMinted,

        address indexed liquidityProvider

    );

    event LiquidityRemoved(

        address indexed l1Token,

        uint256 amount,

        uint256 lpTokensBurnt,

        address indexed liquidityProvider

    );

    event SetPoolRebalanceRoute(

        uint256 indexed destinationChainId,

        address indexed l1Token,

        address indexed destinationToken

    );

    event SetEnableDepositRoute(

        uint256 indexed originChainId,

        uint256 indexed destinationChainId,

        address indexed originToken,

        bool depositsEnabled

    );

    event ProposeRootBundle(

        uint32 challengePeriodEndTimestamp,

        uint8 poolRebalanceLeafCount,

        uint256[] bundleEvaluationBlockNumbers,

        bytes32 indexed poolRebalanceRoot,

        bytes32 indexed relayerRefundRoot,

        bytes32 slowRelayRoot,

        address indexed proposer

    );

    event RootBundleExecuted(

        uint256 groupIndex,

        uint256 indexed leafId,

        uint256 indexed chainId,

        address[] l1Tokens,

        uint256[] bundleLpFees,

        int256[] netSendAmounts,

        int256[] runningBalances,

        address indexed caller

    );

    event SpokePoolAdminFunctionTriggered(uint256 indexed chainId, bytes message);



    event RootBundleDisputed(address indexed disputer, uint256 requestTime);



    event RootBundleCanceled(address indexed disputer, uint256 requestTime);



    modifier noActiveRequests() {

        require(!_activeRequest(), "Proposal has unclaimed leaves");

        _;

    }



    modifier unpaused() {

        require(!paused, "Contract is paused");

        _;

    }



    modifier zeroOptimisticOracleApproval() {

        _;

        bondToken.safeApprove(address(_getOptimisticOracle()), 0);

    }



    /**

     * @notice Construct HubPool.

     * @param _lpTokenFactory LP Token factory address used to deploy LP tokens for new collateral types.

     * @param _finder Finder address.

     * @param _weth WETH address.

     * @param _timer Timer address.

     */

    constructor(

        LpTokenFactoryInterface _lpTokenFactory,

        FinderInterface _finder,

        WETH9 _weth,

        address _timer

    ) Testable(_timer) {

        lpTokenFactory = _lpTokenFactory;

        finder = _finder;

        weth = _weth;

        protocolFeeCaptureAddress = owner();

    }



    /*************************************************

     *                ADMIN FUNCTIONS                *

     *************************************************/



    /**

     * @notice Pauses the bundle proposal and execution process. This is intended to be used during upgrades or when

     * something goes awry.

     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.

     */

    function setPaused(bool pause) public onlyOwner nonReentrant {

        paused = pause;

        emit Paused(pause);

    }



    /**

     * @notice This allows for the deletion of the active proposal in case of emergency.

     * @dev This is primarily intended to rectify situations where an unexecutable bundle gets through liveness in the

     * case of a non-malicious bug in the proposal/dispute code. Without this function, the contract would be

     * indefinitely blocked, migration would be required, and in-progress transfers would never be repaid.

     */

    function emergencyDeleteProposal() public onlyOwner nonReentrant {

        RootBundle memory _rootBundleProposal = rootBundleProposal;

        delete rootBundleProposal;

        if (_rootBundleProposal.unclaimedPoolRebalanceLeafCount > 0)

            bondToken.safeTransfer(_rootBundleProposal.proposer, bondAmount);

        emit EmergencyRootBundleDeleted(

            _rootBundleProposal.poolRebalanceRoot,

            _rootBundleProposal.relayerRefundRoot,

            _rootBundleProposal.slowRelayRoot,

            _rootBundleProposal.proposer

        );

    }



    /**

     * @notice Sends message to SpokePool from this contract. Callable only by owner.

     * @dev This function has permission to call onlyAdmin functions on the SpokePool, so it's imperative that this

     * contract only allows the owner to call this method directly or indirectly.

     * @param chainId Chain with SpokePool to send message to.

     * @param functionData ABI encoded function call to send to SpokePool, but can be any arbitrary data technically.

     */

    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData)

        public

        override

        onlyOwner

        nonReentrant

    {

        _relaySpokePoolAdminFunction(chainId, functionData);

    }



    /**

     * @notice Sets protocolFeeCaptureAddress and protocolFeeCapturePct. Callable only by owner.

     * @param newProtocolFeeCaptureAddress New protocol fee capture address.

     * @param newProtocolFeeCapturePct New protocol fee capture %.

     */

    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct)

        public

        override

        onlyOwner

        nonReentrant

    {

        require(newProtocolFeeCapturePct <= 1e18, "Bad protocolFeeCapturePct");

        require(newProtocolFeeCaptureAddress != address(0), "Bad protocolFeeCaptureAddress");

        protocolFeeCaptureAddress = newProtocolFeeCaptureAddress;

        protocolFeeCapturePct = newProtocolFeeCapturePct;

        emit ProtocolFeeCaptureSet(newProtocolFeeCaptureAddress, newProtocolFeeCapturePct);

    }



    /**

     * @notice Sets bond token and amount. Callable only by owner.

     * @param newBondToken New bond currency.

     * @param newBondAmount New bond amount.

     */

    function setBond(IERC20 newBondToken, uint256 newBondAmount)

        public

        override

        onlyOwner

        noActiveRequests

        nonReentrant

    {

        // Bond should not equal final fee otherwise every proposal will get cancelled in a dispute.

        // In practice we expect that bond amounts are set >> final fees so this shouldn't be an inconvenience.

        // The only way for the bond amount to be equal to the final fee is if the newBondAmount == 0.

        require(newBondAmount != 0, "bond equal to final fee");



        // Check that this token is on the whitelist.

        AddressWhitelistInterface addressWhitelist = AddressWhitelistInterface(

            finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist)

        );

        require(addressWhitelist.isOnWhitelist(address(newBondToken)), "Not on whitelist");



        // The bond should be the passed in bondAmount + the final fee.

        bondToken = newBondToken;

        uint256 _bondAmount = newBondAmount + _getBondTokenFinalFee();

        bondAmount = _bondAmount;

        emit BondSet(address(newBondToken), _bondAmount);

    }



    /**

     * @notice Sets root bundle proposal liveness period. Callable only by owner.

     * @param newLiveness New liveness period.

     */

    function setLiveness(uint32 newLiveness) public override onlyOwner nonReentrant {

        require(newLiveness > 10 minutes, "Liveness too short");

        liveness = newLiveness;

        emit LivenessSet(newLiveness);

    }



    /**

     * @notice Sets identifier for root bundle disputes. Callable only by owner.

     * @param newIdentifier New identifier.

     */

    function setIdentifier(bytes32 newIdentifier) public override onlyOwner noActiveRequests nonReentrant {

        IdentifierWhitelistInterface identifierWhitelist = IdentifierWhitelistInterface(

            finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist)

        );

        require(identifierWhitelist.isIdentifierSupported(newIdentifier), "Identifier not supported");

        identifier = newIdentifier;

        emit IdentifierSet(newIdentifier);

    }



    /**

     * @notice Sets cross chain relay helper contracts for L2 chain ID. Callable only by owner.

     * @dev We do not block setting the adapter or SpokePool to invalid/zero addresses because we want to allow the

     * admin to block relaying roots to the spoke pool for emergency recovery purposes.

     * @param l2ChainId Chain to set contracts for.

     * @param adapter Adapter used to relay messages and tokens to spoke pool. Deployed on current chain.

     * @param spokePool Recipient of relayed messages and tokens on spoke pool. Deployed on l2ChainId.

     */



    function setCrossChainContracts(

        uint256 l2ChainId,

        address adapter,

        address spokePool

    ) public override onlyOwner nonReentrant {

        crossChainContracts[l2ChainId] = CrossChainContract(adapter, spokePool);

        emit CrossChainContractsSet(l2ChainId, adapter, spokePool);

    }



    /**

     * @notice Store canonical destination token counterpart for l1 token. Callable only by owner.

     * @dev Admin can set destinationToken to 0x0 to effectively disable executing any root bundles with leaves

     * containing this l1 token + destination chain ID combination.

     * @param destinationChainId Destination chain where destination token resides.

     * @param l1Token Token enabled for liquidity in this pool, and the L1 counterpart to the destination token on the

     * destination chain ID.

     * @param destinationToken Destination chain counterpart of L1 token.

     */

    function setPoolRebalanceRoute(

        uint256 destinationChainId,

        address l1Token,

        address destinationToken

    ) public override onlyOwner nonReentrant {

        poolRebalanceRoutes[_poolRebalanceRouteKey(l1Token, destinationChainId)] = destinationToken;

        emit SetPoolRebalanceRoute(destinationChainId, l1Token, destinationToken);

    }



    /**

     * @notice Sends cross-chain message to SpokePool on originChainId to enable or disable deposit route from that

     * SpokePool to another one. Callable only by owner.

     * @dev Admin is responsible for ensuring that `originToken` is linked to some L1 token on this contract, via

     * poolRebalanceRoutes(), and that this L1 token also has a counterpart on the destination chain. If either

     * condition fails, then the deposit will be unrelayable by off-chain relayers because they will not know which

     * token to relay to recipients on the destination chain, and data workers wouldn't know which L1 token to send

     * to the destination chain to refund the relayer.

     * @param originChainId Chain where token deposit occurs.

     * @param destinationChainId Chain where token depositor wants to receive funds.

     * @param originToken Token sent in deposit.

     * @param depositsEnabled Set to true to whitelist this route for deposits, set to false if caller just wants to

     * map the origin token + destination ID to the destination token address on the origin chain's SpokePool.

     */

    function setDepositRoute(

        uint256 originChainId,

        uint256 destinationChainId,

        address originToken,

        bool depositsEnabled

    ) public override nonReentrant onlyOwner {

        _relaySpokePoolAdminFunction(

            originChainId,

            abi.encodeWithSignature(

                "setEnableRoute(address,uint256,bool)",

                originToken,

                destinationChainId,

                depositsEnabled

            )

        );

        emit SetEnableDepositRoute(originChainId, destinationChainId, originToken, depositsEnabled);

    }



    /**

     * @notice Enables LPs to provide liquidity for L1 token. Deploys new LP token for L1 token if appropriate.

     * Callable only by owner.

     * @param l1Token Token to provide liquidity for.

     */

    function enableL1TokenForLiquidityProvision(address l1Token) public override onlyOwner nonReentrant {

        // If token is being enabled for the first time, create a new LP token and set the timestamp once. We don't

        // want to ever reset this timestamp otherwise fees that have accrued will be lost since the last update. This

        // could happen for example if an L1 token is enabled, disabled, and then enabled again.

        if (pooledTokens[l1Token].lpToken == address(0)) {

            pooledTokens[l1Token].lpToken = lpTokenFactory.createLpToken(l1Token);

            pooledTokens[l1Token].lastLpFeeUpdate = uint32(getCurrentTime());

        }



        pooledTokens[l1Token].isEnabled = true;



        emit L1TokenEnabledForLiquidityProvision(l1Token, pooledTokens[l1Token].lpToken);

    }



    /**

     * @notice Disables LPs from providing liquidity for L1 token. Callable only by owner.

     * @param l1Token Token to disable liquidity provision for.

     */

    function disableL1TokenForLiquidityProvision(address l1Token) public override onlyOwner nonReentrant {

        pooledTokens[l1Token].isEnabled = false;

        emit L2TokenDisabledForLiquidityProvision(l1Token, pooledTokens[l1Token].lpToken);

    }



    /**

     * @notice Enables the owner of the protocol to haircut reserves in the event of an irrecoverable loss of funds on

     * one of the L2s. Consider funds are leant out onto a L2 that dies irrecoverably. This value will offset the

     * exchangeRateCurrent such that all LPs receive a pro rata loss of the the reserves. Should be used in conjunction

     * with pause logic to prevent LPs from adding/withdrawing liquidity during the haircut process.

     * Callable only by owner.

     * @param l1Token Token to execute the haircut on.

     * @param haircutAmount The amount of reserves to haircut the LPs by.

     */

    function haircutReserves(address l1Token, int256 haircutAmount) public onlyOwner nonReentrant {

        // Note that we do not call sync first in this method. The Owner should call this manually before haircutting.

        // This is done in the event sync is reverting due to too low balanced in the contract relative to bond amount.

        pooledTokens[l1Token].utilizedReserves -= haircutAmount;

    }



    /*************************************************

     *          LIQUIDITY PROVIDER FUNCTIONS         *

     *************************************************/



    /**

     * @notice Deposit liquidity into this contract to earn LP fees in exchange for funding relays on SpokePools.

     * Caller is essentially loaning their funds to be sent from this contract to the SpokePool, where it will be used

     * to repay a relayer, and ultimately receives their loan back after the tokens are bridged back to this contract

     * via the canonical token bridge. Then, the caller's loans are used again. This loan cycle repeats continuously

     * and the caller, or "liquidity provider" earns a continuous fee for their credit that they are extending relayers.

     * @notice Caller will receive an LP token representing their share of this pool. The LP token's redemption value

     * increments from the time that they enter the pool to reflect their accrued fees.

     * @notice The caller of this function must approve this contract to spend l1TokenAmount of l1Token.

     * @param l1Token Token to deposit into this contract.

     * @param l1TokenAmount Amount of liquidity to provide.

     */

    function addLiquidity(address l1Token, uint256 l1TokenAmount) public payable override nonReentrant unpaused {

        require(pooledTokens[l1Token].isEnabled, "Token not enabled");

        // If this is the weth pool and the caller sends msg.value then the msg.value must match the l1TokenAmount.

        // Else, msg.value must be set to 0.

        require(((address(weth) == l1Token) && msg.value == l1TokenAmount) || msg.value == 0, "Bad msg.value");



        // Since _exchangeRateCurrent() reads this contract's balance and updates contract state using it, it must be

        // first before transferring any tokens to this contract to ensure synchronization.

        uint256 lpTokensToMint = (l1TokenAmount * 1e18) / _exchangeRateCurrent(l1Token);

        pooledTokens[l1Token].liquidReserves += l1TokenAmount;

        ExpandedIERC20(pooledTokens[l1Token].lpToken).mint(msg.sender, lpTokensToMint);



        if (address(weth) == l1Token && msg.value > 0) WETH9(address(l1Token)).deposit{ value: msg.value }();

        else IERC20(l1Token).safeTransferFrom(msg.sender, address(this), l1TokenAmount);



        emit LiquidityAdded(l1Token, l1TokenAmount, lpTokensToMint, msg.sender);

    }



    /**

     * @notice Burns LP share to redeem for underlying l1Token original deposit amount plus fees.

     * @param l1Token Token to redeem LP share for.

     * @param lpTokenAmount Amount of LP tokens to burn. Exchange rate between L1 token and LP token can be queried

     * via public exchangeRateCurrent method.

     * @param sendEth Set to True if L1 token is WETH and user wants to receive ETH. Note that if caller

     * is a contract, then the contract should have a way to receive ETH if this value is set to True. Similarly,

     * if this value is set to False, then the calling contract should have a way to handle WETH.

     */

    function removeLiquidity(

        address l1Token,

        uint256 lpTokenAmount,

        bool sendEth

    ) public override nonReentrant unpaused {

        require(address(weth) == l1Token || !sendEth, "Cant send eth");

        uint256 l1TokensToReturn = (lpTokenAmount * _exchangeRateCurrent(l1Token)) / 1e18;



        ExpandedIERC20(pooledTokens[l1Token].lpToken).burnFrom(msg.sender, lpTokenAmount);

        // Note this method does not make any liquidity utilization checks before letting the LP redeem their LP tokens.

        // If they try access more funds than available (i.e l1TokensToReturn > liquidReserves) this will underflow.

        pooledTokens[l1Token].liquidReserves -= l1TokensToReturn;



        if (sendEth) {

            weth.withdraw(l1TokensToReturn);

            Address.sendValue(payable(msg.sender), l1TokensToReturn); // This will revert if the caller is a contract that does not implement a fallback function.

        } else {

            IERC20(address(l1Token)).safeTransfer(msg.sender, l1TokensToReturn);

        }

        emit LiquidityRemoved(l1Token, l1TokensToReturn, lpTokenAmount, msg.sender);

    }



    /**

     * @notice Returns exchange rate of L1 token to LP token.

     * @param l1Token L1 token redeemable by burning LP token.

     * @return Amount of L1 tokens redeemable for 1 unit LP token.

     */

    function exchangeRateCurrent(address l1Token) public override nonReentrant returns (uint256) {

        return _exchangeRateCurrent(l1Token);

    }



    /**

     * @notice Returns % of liquid reserves currently being "used" and sitting in SpokePools.

     * @param l1Token L1 token to query utilization for.

     * @return % of liquid reserves currently being "used" and sitting in SpokePools.

     */

    function liquidityUtilizationCurrent(address l1Token) public override nonReentrant returns (uint256) {

        return _liquidityUtilizationPostRelay(l1Token, 0);

    }



    /**

     * @notice Returns % of liquid reserves currently being "used" and sitting in SpokePools and accounting for

     * relayedAmount of tokens to be withdrawn from the pool.

     * @param l1Token L1 token to query utilization for.

     * @param relayedAmount The higher this amount, the higher the utilization.

     * @return % of liquid reserves currently being "used" and sitting in SpokePools plus the relayedAmount.

     */

    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount)

        public

        nonReentrant

        returns (uint256)

    {

        return _liquidityUtilizationPostRelay(l1Token, relayedAmount);

    }



    /**

     * @notice Synchronize any balance changes in this contract with the utilized & liquid reserves. This should be done

     * at the conclusion of a L2->L1 token transfer via the canonical token bridge, when this contract's reserves do not

     * reflect its true balance due to new tokens being dropped onto the contract at the conclusion of a bridging action.

     */

    function sync(address l1Token) public override nonReentrant {

        _sync(l1Token);

    }



    /*************************************************

     *             DATA WORKER FUNCTIONS             *

     *************************************************/



    /**

     * @notice Publish a new root bundle along with all of the block numbers that the merkle roots are relevant for.

     * This is used to aid off-chain validators in evaluating the correctness of this bundle. Caller stakes a bond that

     * can be slashed if the root bundle proposal is invalid, and they will receive it back if accepted.

     * @notice After proposeRootBundle is called, if the any props are wrong then this proposal can be challenged.

     * Once the challenge period passes, then the roots are no longer disputable, and only executeRootBundle can be

     * called; moreover, this method can't be called again until all leaves are executed.

     * @param bundleEvaluationBlockNumbers should contain the latest block number for all chains, even if there are no

     * relays contained on some of them. The usage of this variable should be defined in an off chain UMIP.

     * @notice The caller of this function must approve this contract to spend bondAmount of bondToken.

     * @param poolRebalanceLeafCount Number of leaves contained in pool rebalance root. Max is # of whitelisted chains.

     * @param poolRebalanceRoot Pool rebalance root containing leaves that sends tokens from this contract to SpokePool.

     * @param relayerRefundRoot Relayer refund root to publish to SpokePool where a data worker can execute leaves to

     * refund relayers on their chosen refund chainId.

     * @param slowRelayRoot Slow relay root to publish to Spoke Pool where a data worker can execute leaves to

     * fulfill slow relays.

     */

    function proposeRootBundle(

        uint256[] calldata bundleEvaluationBlockNumbers,

        uint8 poolRebalanceLeafCount,

        bytes32 poolRebalanceRoot,

        bytes32 relayerRefundRoot,

        bytes32 slowRelayRoot

    ) public override nonReentrant noActiveRequests unpaused {

        // Note: this is to prevent "empty block" style attacks where someone can make empty proposals that are

        // technically valid but not useful. This could also potentially be enforced at the UMIP-level.

        require(poolRebalanceLeafCount > 0, "Bundle must have at least 1 leaf");



        uint32 challengePeriodEndTimestamp = uint32(getCurrentTime()) + liveness;



        delete rootBundleProposal; // Only one bundle of roots can be executed at a time. Delete the previous bundle.



        rootBundleProposal.challengePeriodEndTimestamp = challengePeriodEndTimestamp;

        rootBundleProposal.unclaimedPoolRebalanceLeafCount = poolRebalanceLeafCount;

        rootBundleProposal.poolRebalanceRoot = poolRebalanceRoot;

        rootBundleProposal.relayerRefundRoot = relayerRefundRoot;

        rootBundleProposal.slowRelayRoot = slowRelayRoot;

        rootBundleProposal.proposer = msg.sender;



        // Pull bondAmount of bondToken from the caller.

        bondToken.safeTransferFrom(msg.sender, address(this), bondAmount);



        emit ProposeRootBundle(

            challengePeriodEndTimestamp,

            poolRebalanceLeafCount,

            bundleEvaluationBlockNumbers,

            poolRebalanceRoot,

            relayerRefundRoot,

            slowRelayRoot,

            msg.sender

        );

    }



    /**

     * @notice Executes a pool rebalance leaf as part of the currently published root bundle. Will bridge any tokens

     * from this contract to the SpokePool designated in the leaf, and will also publish relayer refund and slow

     * relay roots to the SpokePool on the network specified in the leaf.

     * @dev In some cases, will instruct spokePool to send funds back to L1.

     * @param chainId ChainId number of the target spoke pool on which the bundle is executed.

     * @param groupIndex If set to 0, then relay roots to SpokePool via cross chain bridge. Used by off-chain validator

     * to organize leaves with the same chain ID and also set which leaves should result in relayed messages.

     * @param bundleLpFees Array representing the total LP fee amount per token in this bundle for all bundled relays.

     * @param netSendAmounts Array representing the amount of tokens to send to the SpokePool on the target chainId.

     * @param runningBalances Array used to track any unsent tokens that are not included in the netSendAmounts.

     * @param leafId Index of this executed leaf within the poolRebalance tree.

     * @param l1Tokens Array of all the tokens associated with the bundleLpFees, nedSendAmounts and runningBalances.

     * @param proof Inclusion proof for this leaf in pool rebalance root in root bundle.

     */



    function executeRootBundle(

        uint256 chainId,

        uint256 groupIndex,

        uint256[] memory bundleLpFees,

        int256[] memory netSendAmounts,

        int256[] memory runningBalances,

        uint8 leafId,

        address[] memory l1Tokens,

        bytes32[] calldata proof

    ) public nonReentrant unpaused {

        require(getCurrentTime() > rootBundleProposal.challengePeriodEndTimestamp, "Not passed liveness");



        // Verify the leafId in the poolRebalanceLeaf has not yet been claimed.

        require(!MerkleLib.isClaimed1D(rootBundleProposal.claimedBitMap, leafId), "Already claimed");



        // Verify the props provided generate a leaf that, along with the proof, are included in the merkle root.

        require(

            MerkleLib.verifyPoolRebalance(

                rootBundleProposal.poolRebalanceRoot,

                PoolRebalanceLeaf({

                    chainId: chainId,

                    groupIndex: groupIndex,

                    bundleLpFees: bundleLpFees,

                    netSendAmounts: netSendAmounts,

                    runningBalances: runningBalances,

                    leafId: leafId,

                    l1Tokens: l1Tokens

                }),

                proof

            ),

            "Bad Proof"

        );

        // Grouping code that uses adapter and spokepool to avoid stack too deep warning.

        // Get cross chain helpers for leaf's destination chain ID. This internal method will revert if either helper

        // is set improperly.

        (address adapter, address spokePool) = _getInitializedCrossChainContracts(chainId);



        // Set the leafId in the claimed bitmap.

        rootBundleProposal.claimedBitMap = MerkleLib.setClaimed1D(rootBundleProposal.claimedBitMap, leafId);



        // Decrement the unclaimedPoolRebalanceLeafCount.

        --rootBundleProposal.unclaimedPoolRebalanceLeafCount;



        // Relay each L1 token to destination chain.

        // Note: if any of the keccak256(l1Tokens, chainId) combinations are not mapped to a destination token address,

        // then this internal method will revert. In this case the admin will have to associate a destination token

        // with each l1 token. If the destination token mapping was missing at the time of the proposal, we assume

        // that the root bundle would have been disputed because the off-chain data worker would have been unable to

        // determine if the relayers used the correct destination token for a given origin token.

        _sendTokensToChainAndUpdatePooledTokenTrackers(

            adapter,

            spokePool,

            chainId,

            l1Tokens,

            netSendAmounts,

            bundleLpFees

        );



        // Check bool used by data worker to prevent relaying redundant roots to SpokePool.

        if (groupIndex == 0) {

            // Relay root bundles to spoke pool on destination chain by

            // performing delegatecall to use the adapter's code with this contract's context.



            // We are ok with this low-level call since the adapter address is set by the admin and we've

            // already checked that its not the zero address.

            // solhint-disable-next-line avoid-low-level-calls

            (bool success, ) = adapter.delegatecall(

                abi.encodeWithSignature(

                    "relayMessage(address,bytes)",

                    spokePool, // target. This should be the spokePool on the L2.

                    abi.encodeWithSignature(

                        "relayRootBundle(bytes32,bytes32)",

                        rootBundleProposal.relayerRefundRoot,

                        rootBundleProposal.slowRelayRoot

                    ) // message

                )

            );

            require(success, "delegatecall failed");

        }



        // Transfer the bondAmount back to the proposer, if this the last executed leaf. Only sending this once all

        // leaves have been executed acts to force the data worker to execute all bundles or they won't receive their bond.

        if (rootBundleProposal.unclaimedPoolRebalanceLeafCount == 0)

            bondToken.safeTransfer(rootBundleProposal.proposer, bondAmount);



        emit RootBundleExecuted(

            groupIndex,

            leafId,

            chainId,

            l1Tokens,

            bundleLpFees,

            netSendAmounts,

            runningBalances,

            msg.sender

        );

    }



    /**

     * @notice Caller stakes a bond to dispute the current root bundle proposal assuming it has not passed liveness

     * yet. The proposal is deleted, allowing a follow-up proposal to be submitted, and the dispute is sent to the

     * optimistic oracle to be adjudicated. Can only be called within the liveness period of the current proposal.

     * @notice The caller of this function must approve this contract to spend bondAmount of l1Token.

     */

    function disputeRootBundle() public nonReentrant zeroOptimisticOracleApproval {

        uint32 currentTime = uint32(getCurrentTime());

        require(currentTime <= rootBundleProposal.challengePeriodEndTimestamp, "Request passed liveness");



        // Request price from OO and dispute it.

        uint256 finalFee = _getBondTokenFinalFee();



        // This method will request a price from the OO and dispute it. Note that we set the ancillary data to

        // the empty string (""). The root bundle that is being disputed was the most recently proposed one with a

        // block number less than or equal to the dispute block time. All of this root bundle data can be found in

        // the ProposeRootBundle event params. Moreover, the optimistic oracle will stamp the requester's address

        // (i.e. this contract address) meaning that ancillary data for a dispute originating from another HubPool

        // will always be distinct from a dispute originating from this HubPool. Moreover, since

        // bundleEvaluationNumbers for a root bundle proposal are not stored in this contract, DVM voters will always

        // have to look up the ProposeRootBundle event to evaluate a dispute, therefore there is no point emitting extra

        // data in this ancillary data that is already included in the ProposeRootBundle event.



        // If the finalFee is larger than the bond amount, the bond amount needs to be reset before a request can go

        // through. Cancel to avoid a revert. Similarly, if the final fee == bond amount, then the proposer bond

        // set in the optimistic oracle would be 0. The optimistic oracle would then default the bond to be equal

        // to the final fee, which would mean that the allowance set to the bondAmount would be insufficient and the

        // requestAndProposePriceFor() call would revert. Source: https://github.com/UMAprotocol/protocol/blob/5b37ea818a28479c01e458389a83c3e736306b17/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L321

        if (finalFee >= bondAmount) {

            _cancelBundle();

            return;

        }



        SkinnyOptimisticOracleInterface optimisticOracle = _getOptimisticOracle();



        // Only approve exact tokens to avoid more tokens than expected being pulled into the OptimisticOracle.

        bondToken.safeIncreaseAllowance(address(optimisticOracle), bondAmount);

        try

            optimisticOracle.requestAndProposePriceFor(

                identifier,

                currentTime,

                "",

                bondToken,

                // Set reward to 0, since we'll settle proposer reward payouts directly from this contract after a root

                // proposal has passed the challenge period.

                0,

                // Set the Optimistic oracle proposer bond for the request. We can assume that bondAmount > finalFee.

                bondAmount - finalFee,

                // Set the Optimistic oracle liveness for the price request.

                liveness,

                rootBundleProposal.proposer,

                // Canonical value representing "True"; i.e. the proposed relay is valid.

                int256(1e18)

            )

        returns (uint256) {

            // Ensure that approval == 0 after the call so the increaseAllowance call below doesn't allow more tokens

            // to transfer than intended.

            bondToken.safeApprove(address(optimisticOracle), 0);

        } catch {

            // Cancel the bundle since the proposal failed.

            _cancelBundle();

            return;

        }



        // Dispute the request that we just sent.

        SkinnyOptimisticOracleInterface.Request memory ooPriceRequest = SkinnyOptimisticOracleInterface.Request({

            proposer: rootBundleProposal.proposer,

            disputer: address(0),

            currency: bondToken,

            settled: false,

            proposedPrice: int256(1e18),

            resolvedPrice: 0,

            expirationTime: currentTime + liveness,

            reward: 0,

            finalFee: finalFee,

            bond: bondAmount - finalFee,

            customLiveness: liveness

        });



        // Finally, delete the state pertaining to the active proposal so that another proposer can submit a new bundle.

        delete rootBundleProposal;



        bondToken.safeTransferFrom(msg.sender, address(this), bondAmount);

        bondToken.safeIncreaseAllowance(address(optimisticOracle), bondAmount);

        optimisticOracle.disputePriceFor(identifier, currentTime, "", ooPriceRequest, msg.sender, address(this));



        emit RootBundleDisputed(msg.sender, currentTime);

    }



    /**

     * @notice Send unclaimed accumulated protocol fees to fee capture address.

     * @param l1Token Token whose protocol fees the caller wants to disburse.

     */

    function claimProtocolFeesCaptured(address l1Token) public override nonReentrant {

        uint256 _unclaimedAccumulatedProtocolFees = unclaimedAccumulatedProtocolFees[l1Token];

        unclaimedAccumulatedProtocolFees[l1Token] = 0;

        IERC20(l1Token).safeTransfer(protocolFeeCaptureAddress, _unclaimedAccumulatedProtocolFees);

        emit ProtocolFeesCapturedClaimed(l1Token, _unclaimedAccumulatedProtocolFees);

    }



    /**

     * @notice Conveniently queries which destination token is mapped to the hash of an l1 token + destination chain ID.

     * @dev Admin must be considerate to the compatibility of originToken and destinationToken within the protocol. Some

     * token implementations will not function correctly within the Across v2 system. For example ERC20s that charge

     * fees will break internal accounting, ERC777 can cause some functions to revert and upgradable tokens can pose

     * risks if the implementation is shifted between whitelisting and usage.

     * @dev If the pool rebalance route is not whitelisted then this will return address(0).

     * @param destinationChainId Where destination token is deployed.

     * @param l1Token Ethereum version token.

     * @return destinationToken address The destination token that is sent to spoke pools after this contract bridges

     * the l1Token to the destination chain.

     */

    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)

        external

        view

        override

        returns (address destinationToken)

    {

        return poolRebalanceRoutes[_poolRebalanceRouteKey(l1Token, destinationChainId)];

    }



    /**

     * @notice This function allows a caller to load the contract with raw ETH to perform L2 calls. This is needed for

     * Arbitrum calls, but may also be needed for others.

     * @dev This function cannot be included in a multicall transaction call because it is payable. A realistic

     * situation where this might be an issue is if the caller is executing a PoolRebalanceLeaf that needs to relay

     * messages to Arbitrum. Relaying messages to Arbitrum requires that this contract has an ETH balance, so in this

     * case the caller would need to pre-load this contract with ETH before multicall-executing the leaf.

     */

    function loadEthForL2Calls() public payable override {

        /* solhint-disable-line no-empty-blocks */

    }



    /*************************************************

     *              INTERNAL FUNCTIONS               *

     *************************************************/



    // Called when a dispute fails due to parameter changes. This effectively resets the state and cancels the request

    // with no loss of funds, thereby enabling a new bundle to be added.

    function _cancelBundle() internal {

        bondToken.transfer(rootBundleProposal.proposer, bondAmount);

        delete rootBundleProposal;

        emit RootBundleCanceled(msg.sender, getCurrentTime());

    }



    function _getOptimisticOracle() internal view returns (SkinnyOptimisticOracleInterface) {

        return

            SkinnyOptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.SkinnyOptimisticOracle));

    }



    function _getBondTokenFinalFee() internal view returns (uint256) {

        return

            StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store))

                .computeFinalFee(address(bondToken))

                .rawValue;

    }



    // Note this method does a lot and wraps together the sending of tokens and updating the pooled token trackers. This

    // is done as a gas saving so we don't need to iterate over the l1Tokens multiple times.

    function _sendTokensToChainAndUpdatePooledTokenTrackers(

        address adapter,

        address spokePool,

        uint256 chainId,

        address[] memory l1Tokens,

        int256[] memory netSendAmounts,

        uint256[] memory bundleLpFees

    ) internal {

        uint256 length = l1Tokens.length;

        for (uint256 i = 0; i < length; ) {

            address l1Token = l1Tokens[i];

            // Validate the L1 -> L2 token route is stored. If it is not then the output of the bridging action

            // could send tokens to the 0x0 address on the L2.

            address l2Token = poolRebalanceRoutes[_poolRebalanceRouteKey(l1Token, chainId)];

            require(l2Token != address(0), "Route not whitelisted");



            // If the net send amount for this token is positive then: 1) send tokens from L1->L2 to facilitate the L2

            // relayer refund, 2) Update the liquidity trackers for the associated pooled tokens.

            if (netSendAmounts[i] > 0) {

                // Perform delegatecall to use the adapter's code with this contract's context. Opt for delegatecall's

                // complexity in exchange for lower gas costs.



                // We are ok with this low-level call since the adapter address is set by the admin and we've

                // already checked that its not the zero address.

                // solhint-disable-next-line avoid-low-level-calls

                (bool success, ) = adapter.delegatecall(

                    abi.encodeWithSignature(

                        "relayTokens(address,address,uint256,address)",

                        l1Token, // l1Token.

                        l2Token, // l2Token.

                        uint256(netSendAmounts[i]), // amount.

                        spokePool // to. This should be the spokePool.

                    )

                );

                require(success, "delegatecall failed");



                // Liquid reserves is decreased by the amount sent. utilizedReserves is increased by the amount sent.

                pooledTokens[l1Token].utilizedReserves += netSendAmounts[i];

                pooledTokens[l1Token].liquidReserves -= uint256(netSendAmounts[i]);

            }



            // Allocate LP fees and protocol fees from the bundle to the associated pooled token trackers.

            _allocateLpAndProtocolFees(l1Token, bundleLpFees[i]);



            // L1 tokens length won't be > types(uint256).length, so use unchecked block to save gas. Based on the

            // stress test results in /test/gas-analytics/HubPool.RootExecution.ts, the UMIP should limit the L1 token

            // count in valid proposals to be ~100 so any PoolRebalanceLeaves with > 100 l1Tokens should not make it

            // to this stage.

            unchecked {

                ++i;

            }

        }

    }



    function _exchangeRateCurrent(address l1Token) internal returns (uint256) {

        PooledToken storage pooledToken = pooledTokens[l1Token]; // Note this is storage so the state can be modified.

        uint256 lpTokenTotalSupply = IERC20(pooledToken.lpToken).totalSupply();

        if (lpTokenTotalSupply == 0) return 1e18; // initial rate is 1:1 between LP tokens and collateral.



        // First, update fee counters and local accounting of finalized transfers from L2 -> L1.

        _updateAccumulatedLpFees(pooledToken); // Accumulate all allocated fees from the last time this method was called.

        _sync(l1Token); // Fetch any balance changes due to token bridging finalization and factor them in.



        // ExchangeRate := (liquidReserves + utilizedReserves - undistributedLpFees) / lpTokenSupply

        // Both utilizedReserves and undistributedLpFees contain assigned LP fees. UndistributedLpFees is gradually

        // decreased over the smear duration using _updateAccumulatedLpFees. This means that the exchange rate will

        // gradually increase over time as undistributedLpFees goes to zero.

        // utilizedReserves can be negative. If this is the case, then liquidReserves is offset by an equal

        // and opposite size. LiquidReserves + utilizedReserves will always be larger than undistributedLpFees so this

        // int will always be positive so there is no risk in underflow in type casting in the return line.

        int256 numerator = int256(pooledToken.liquidReserves) +

            pooledToken.utilizedReserves -

            int256(pooledToken.undistributedLpFees);

        return (uint256(numerator) * 1e18) / lpTokenTotalSupply;

    }



    // Update internal fee counters by adding in any accumulated fees from the last time this logic was called.

    function _updateAccumulatedLpFees(PooledToken storage pooledToken) internal {

        uint256 accumulatedFees = _getAccumulatedFees(pooledToken.undistributedLpFees, pooledToken.lastLpFeeUpdate);

        pooledToken.undistributedLpFees -= accumulatedFees;

        pooledToken.lastLpFeeUpdate = uint32(getCurrentTime());

    }



    // Calculate the unallocated accumulatedFees from the last time the contract was called.

    function _getAccumulatedFees(uint256 undistributedLpFees, uint256 lastLpFeeUpdate) internal view returns (uint256) {

        // accumulatedFees := min(undistributedLpFees * lpFeeRatePerSecond * timeFromLastInteraction, undistributedLpFees)

        // The min acts to pay out all fees in the case the equation returns more than the remaining fees.

        uint256 timeFromLastInteraction = getCurrentTime() - lastLpFeeUpdate;

        uint256 maxUndistributedLpFees = (undistributedLpFees * lpFeeRatePerSecond * timeFromLastInteraction) / (1e18);

        return maxUndistributedLpFees < undistributedLpFees ? maxUndistributedLpFees : undistributedLpFees;

    }



    function _sync(address l1Token) internal {

        // Check if the l1Token balance of the contract is greater than the liquidReserves. If it is then the bridging

        // action from L2 -> L1 has concluded and the local accounting can be updated.

        // Note: this calculation must take into account the bond when it's acting on the bond token and there's an

        // active request.

        uint256 balance = IERC20(l1Token).balanceOf(address(this));

        uint256 balanceSansBond = l1Token == address(bondToken) && _activeRequest() ? balance - bondAmount : balance;

        if (balanceSansBond > pooledTokens[l1Token].liquidReserves) {

            // Note the numerical operation below can send utilizedReserves to negative. This can occur when tokens are

            // dropped onto the contract, exceeding the liquidReserves.

            pooledTokens[l1Token].utilizedReserves -= int256(balanceSansBond - pooledTokens[l1Token].liquidReserves);

            pooledTokens[l1Token].liquidReserves = balanceSansBond;

        }

    }



    function _liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) internal returns (uint256) {

        _sync(l1Token); // Fetch any balance changes due to token bridging finalization and factor them in.



        // liquidityUtilizationRatio := (relayedAmount + max(utilizedReserves,0)) / (liquidReserves + max(utilizedReserves,0))

        // UtilizedReserves has a dual meaning: if it's greater than zero then it represents funds pending in the bridge

        // that will flow from L2 to L1. In this case, we can use it normally in the equation. However, if it is

        // negative, then it is already counted in liquidReserves. This occurs if tokens are transferred directly to the

        // contract. In this case, ignore it as it is captured in liquid reserves and has no meaning in the numerator.

        PooledToken memory pooledL1Token = pooledTokens[l1Token];

        uint256 flooredUtilizedReserves = pooledL1Token.utilizedReserves > 0

            ? uint256(pooledL1Token.utilizedReserves) // If positive: take the uint256 cast utilizedReserves.

            : 0; // Else, if negative, then the is already captured in liquidReserves and should be ignored.

        uint256 numerator = relayedAmount + flooredUtilizedReserves;

        uint256 denominator = pooledL1Token.liquidReserves + flooredUtilizedReserves;



        // If the denominator equals zero, return 1e18 (max utilization).

        if (denominator == 0) return 1e18;



        // In all other cases, return the utilization ratio.

        return (numerator * 1e18) / denominator;

    }



    function _allocateLpAndProtocolFees(address l1Token, uint256 bundleLpFees) internal {

        // Calculate the fraction of bundledLpFees that are allocated to the protocol and to the LPs.

        uint256 protocolFeesCaptured = (bundleLpFees * protocolFeeCapturePct) / 1e18;

        uint256 lpFeesCaptured = bundleLpFees - protocolFeesCaptured;



        // Assign any LP fees included into the bundle to the pooled token. These LP fees are tracked in the

        // undistributedLpFees and within the utilizedReserves. undistributedLpFees is gradually decreased

        // over the smear duration to give the LPs their rewards over a period of time. Adding to utilizedReserves

        // acts to track these rewards after the smear duration. See _exchangeRateCurrent for more details.

        if (lpFeesCaptured > 0) {

            pooledTokens[l1Token].undistributedLpFees += lpFeesCaptured;

            pooledTokens[l1Token].utilizedReserves += int256(lpFeesCaptured);

        }



        // If there are any protocol fees, allocate them to the unclaimed protocol tracker amount.

        if (protocolFeesCaptured > 0) unclaimedAccumulatedProtocolFees[l1Token] += protocolFeesCaptured;

    }



    function _relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) internal {

        (address adapter, address spokePool) = _getInitializedCrossChainContracts(chainId);



        // Perform delegatecall to use the adapter's code with this contract's context.



        // We are ok with this low-level call since the adapter address is set by the admin and we've

        // already checked that its not the zero address.

        // solhint-disable-next-line avoid-low-level-calls

        (bool success, ) = adapter.delegatecall(

            abi.encodeWithSignature(

                "relayMessage(address,bytes)",

                spokePool, // target. This should be the spokePool on the L2.

                functionData

            )

        );

        require(success, "delegatecall failed");

        emit SpokePoolAdminFunctionTriggered(chainId, functionData);

    }



    function _poolRebalanceRouteKey(address l1Token, uint256 destinationChainId) internal pure returns (bytes32) {

        return keccak256(abi.encode(l1Token, destinationChainId));

    }



    function _getInitializedCrossChainContracts(uint256 chainId)

        internal

        view

        returns (address adapter, address spokePool)

    {

        adapter = crossChainContracts[chainId].adapter;

        spokePool = crossChainContracts[chainId].spokePool;

        require(spokePool != address(0), "SpokePool not initialized");

        require(adapter.isContract(), "Adapter not initialized");

    }



    function _activeRequest() internal view returns (bool) {

        return rootBundleProposal.unclaimedPoolRebalanceLeafCount != 0;

    }



    // If functionCallStackOriginatesFromOutsideThisContract is true then this was called by the callback function

    // by dropping ETH onto the contract. In this case, deposit the ETH into WETH. This would happen if ETH was sent

    // over the optimism bridge, for example. If false then this was set as a result of unwinding LP tokens, with the

    // intention of sending ETH to the LP. In this case, do nothing as we intend on sending the ETH to the LP.

    function _depositEthToWeth() internal {

        if (functionCallStackOriginatesFromOutsideThisContract()) weth.deposit{ value: msg.value }();

    }



    // Added to enable the HubPool to receive ETH. This will occur both when the HubPool unwraps WETH to send to LPs and

    // when ETH is sent over the canonical Optimism bridge, which sends ETH.

    fallback() external payable {

        _depositEthToWeth();

    }



    receive() external payable {

        _depositEthToWeth();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\HubPoolInterface.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "./interfaces/AdapterInterface.sol";



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";



/**

 * @notice Concise list of functions in HubPool implementation.

 */

interface HubPoolInterface {

    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.

    struct PoolRebalanceLeaf {

        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to send to).

        uint256 chainId;

        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.

        uint256[] bundleLpFees;

        // Represents the amount to push to or pull from the SpokePool. If +, the pool pays the SpokePool. If negative

        // the SpokePool pays the HubPool. There can be arbitrarily complex rebalancing rules defined offchain. This

        // number is only nonzero when the rules indicate that a rebalancing action should occur. When a rebalance does

        // occur, runningBalances must be set to zero for this token and netSendAmounts should be set to the previous

        // runningBalances + relays - deposits in this bundle. If non-zero then it must be set on the SpokePool's

        // RelayerRefundLeaf amountToReturn as -1 * this value to show if funds are being sent from or to the SpokePool.

        int256[] netSendAmounts;

        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1

        // pool. A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that

        // the SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts.

        int256[] runningBalances;

        // Used by data worker to mark which leaves should relay roots to SpokePools, and to otherwise organize leaves.

        // For example, each leaf should contain all the rebalance information for a single chain, but in the case where

        // the list of l1Tokens is very large such that they all can't fit into a single leaf that can be executed under

        // the block gas limit, then the data worker can use this groupIndex to organize them. Any leaves with

        // a groupIndex equal to 0 will relay roots to the SpokePool, so the data worker should ensure that only one

        // leaf for a specific chainId should have a groupIndex equal to 0.

        uint256 groupIndex;

        // Used as the index in the bitmap to track whether this leaf has been executed or not.

        uint8 leafId;

        // The bundleLpFees, netSendAmounts, and runningBalances are required to be the same length. They are parallel

        // arrays for the given chainId and should be ordered by the l1Tokens field. All whitelisted tokens with nonzero

        // relays on this chain in this bundle in the order of whitelisting.

        address[] l1Tokens;

    }



    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling

    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all contain valid leaves

    // that can be executed later to:

    // - Send funds from this contract to a SpokePool or vice versa

    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit

    // - Send funds from a SpokePool to a deposit recipient to fulfill a "slow" relay

    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the

    // challengePeriodEndTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf

    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and

    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain

    // leaves that can be executed on the SpokePool to pay relayers or recipients.

    struct RootBundle {

        // Contains leaves instructing this contract to send funds to SpokePools.

        bytes32 poolRebalanceRoot;

        // Relayer refund merkle root to be published to a SpokePool.

        bytes32 relayerRefundRoot;

        // Slow relay merkle root to be published to a SpokePool.

        bytes32 slowRelayRoot;

        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.

        uint256 claimedBitMap;

        // Proposer of this root bundle.

        address proposer;

        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number

        // of leaves are executed, a new root bundle can be proposed

        uint8 unclaimedPoolRebalanceLeafCount;

        // When root bundle challenge period passes and this root bundle becomes executable.

        uint32 challengePeriodEndTimestamp;

    }



    // Each whitelisted L1 token has an associated pooledToken struct that contains all information used to track the

    // cumulative LP positions and if this token is enabled for deposits.

    struct PooledToken {

        // LP token given to LPs of a specific L1 token.

        address lpToken;

        // True if accepting new LP's.

        bool isEnabled;

        // Timestamp of last LP fee update.

        uint32 lastLpFeeUpdate;

        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent

        // back later.

        int256 utilizedReserves;

        // Number of LP funds held in contract less utilized reserves.

        uint256 liquidReserves;

        // Number of LP funds reserved to pay out to LPs as fees.

        uint256 undistributedLpFees;

    }



    // Helper contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.

    struct CrossChainContract {

        address adapter;

        address spokePool;

    }



    function setPaused(bool pause) external;



    function emergencyDeleteProposal() external;



    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;



    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;



    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;



    function setLiveness(uint32 newLiveness) external;



    function setIdentifier(bytes32 newIdentifier) external;



    function setCrossChainContracts(

        uint256 l2ChainId,

        address adapter,

        address spokePool

    ) external;



    function enableL1TokenForLiquidityProvision(address l1Token) external;



    function disableL1TokenForLiquidityProvision(address l1Token) external;



    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;



    function removeLiquidity(

        address l1Token,

        uint256 lpTokenAmount,

        bool sendEth

    ) external;



    function exchangeRateCurrent(address l1Token) external returns (uint256);



    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);



    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) external returns (uint256);



    function sync(address l1Token) external;



    function proposeRootBundle(

        uint256[] memory bundleEvaluationBlockNumbers,

        uint8 poolRebalanceLeafCount,

        bytes32 poolRebalanceRoot,

        bytes32 relayerRefundRoot,

        bytes32 slowRelayRoot

    ) external;



    function executeRootBundle(

        uint256 chainId,

        uint256 groupIndex,

        uint256[] memory bundleLpFees,

        int256[] memory netSendAmounts,

        int256[] memory runningBalances,

        uint8 leafId,

        address[] memory l1Tokens,

        bytes32[] memory proof

    ) external;



    function disputeRootBundle() external;



    function claimProtocolFeesCaptured(address l1Token) external;



    function setPoolRebalanceRoute(

        uint256 destinationChainId,

        address l1Token,

        address destinationToken

    ) external;



    function setDepositRoute(

        uint256 originChainId,

        uint256 destinationChainId,

        address originToken,

        bool depositsEnabled

    ) external;



    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)

        external

        view

        returns (address destinationToken);



    function loadEthForL2Calls() external payable;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\ICrossDomainMessenger.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title ICrossDomainMessenger

 */

interface ICrossDomainMessenger {

    /**********

     * Events *

     **********/



    event SentMessage(

        address indexed target,

        address sender,

        bytes message,

        uint256 messageNonce,

        uint256 gasLimit

    );

    event RelayedMessage(bytes32 indexed msgHash);

    event FailedRelayedMessage(bytes32 indexed msgHash);



    /*************

     * Variables *

     *************/



    function xDomainMessageSender() external view returns (address);



    /********************

     * Public Functions *

     ********************/



    /**

     * Sends a cross domain message to the target messenger.

     * @param _target Target contract address.

     * @param _message Message to send to the target.

     * @param _gasLimit Gas limit for the provided message.

     */

    function sendMessage(

        address _target,

        bytes calldata _message,

        uint32 _gasLimit

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\IdentifierWhitelistInterface.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



/**

 * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.

 */

interface IdentifierWhitelistInterface {

    /**

     * @notice Adds the provided identifier as a supported identifier.

     * @dev Price requests using this identifier will succeed after this call.

     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.

     */

    function addSupportedIdentifier(bytes32 identifier) external;



    /**

     * @notice Removes the identifier from the whitelist.

     * @dev Price requests using this identifier will no longer succeed after this call.

     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.

     */

    function removeSupportedIdentifier(bytes32 identifier) external;



    /**

     * @notice Checks whether an identifier is on the whitelist.

     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.

     * @return bool if the identifier is supported (or not).

     */

    function isIdentifierSupported(bytes32 identifier) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `to`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address to, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `from` to `to` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address from,

        address to,

        uint256 amount

    ) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\IERC20Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)



pragma solidity ^0.8.0;



import "../IERC20.sol";



/**

 * @dev Interface for the optional metadata functions from the ERC20 standard.

 *

 * _Available since v4.1._

 */

interface IERC20Metadata is IERC20 {

    /**

     * @dev Returns the name of the token.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the symbol of the token.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the decimals places of the token.

     */

    function decimals() external view returns (uint8);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\IL1ERC20Bridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



/**

 * @title IL1ERC20Bridge

 */

interface IL1ERC20Bridge {

    /**********

     * Events *

     **********/



    event ERC20DepositInitiated(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    event ERC20WithdrawalFinalized(

        address indexed _l1Token,

        address indexed _l2Token,

        address indexed _from,

        address _to,

        uint256 _amount,

        bytes _data

    );



    /********************

     * Public Functions *

     ********************/



    /**

     * @dev get the address of the corresponding L2 bridge contract.

     * @return Address of the corresponding L2 bridge contract.

     */

    function l2TokenBridge() external returns (address);



    /**

     * @dev deposit an amount of the ERC20 to the caller's balance on L2.

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _amount Amount of the ERC20 to deposit

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20(

        address _l1Token,

        address _l2Token,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external;



    /**

     * @dev deposit an amount of ERC20 to a recipient's balance on L2.

     * @param _l1Token Address of the L1 ERC20 we are depositing

     * @param _l2Token Address of the L1 respective L2 ERC20

     * @param _to L2 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositERC20To(

        address _l1Token,

        address _l2Token,

        address _to,

        uint256 _amount,

        uint32 _l2Gas,

        bytes calldata _data

    ) external;



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the

     * L1 ERC20 token.

     * This call will fail if the initialized withdrawal from L2 has not been finalized.

     *

     * @param _l1Token Address of L1 token to finalizeWithdrawal for.

     * @param _l2Token Address of L2 token where withdrawal was initiated.

     * @param _from L2 address initiating the transfer.

     * @param _to L1 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _data Data provided by the sender on L2. This data is provided

     *   solely as a convenience for external contracts. Aside from enforcing a maximum

     *   length, these contracts provide no guarantees about its content.

     */

    function finalizeERC20Withdrawal(

        address _l1Token,

        address _l2Token,

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\IL1StandardBridge.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity >0.5.0 <0.9.0;



import "./IL1ERC20Bridge.sol";



/**

 * @title IL1StandardBridge

 */

interface IL1StandardBridge is IL1ERC20Bridge {

    /**********

     * Events *

     **********/

    event ETHDepositInitiated(

        address indexed _from,

        address indexed _to,

        uint256 _amount,

        bytes _data

    );



    event ETHWithdrawalFinalized(

        address indexed _from,

        address indexed _to,

        uint256 _amount,

        bytes _data

    );



    /********************

     * Public Functions *

     ********************/



    /**

     * @dev Deposit an amount of the ETH to the caller's balance on L2.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;



    /**

     * @dev Deposit an amount of ETH to a recipient's balance on L2.

     * @param _to L2 address to credit the withdrawal to.

     * @param _l2Gas Gas limit required to complete the deposit on L2.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function depositETHTo(

        address _to,

        uint32 _l2Gas,

        bytes calldata _data

    ) external payable;



    /*************************

     * Cross-chain Functions *

     *************************/



    /**

     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the

     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called

     * before the withdrawal is finalized.

     * @param _from L2 address initiating the transfer.

     * @param _to L1 address to credit the withdrawal to.

     * @param _amount Amount of the ERC20 to deposit.

     * @param _data Optional data to forward to L2. This data is provided

     *        solely as a convenience for external contracts. Aside from enforcing a maximum

     *        length, these contracts provide no guarantees about its content.

     */

    function finalizeETHWithdrawal(

        address _from,

        address _to,

        uint256 _amount,

        bytes calldata _data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Lockable.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



/**

 * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract

 * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol

 * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.

 * @dev The reason why we use this local contract instead of importing from uma/contracts is because of the addition

 * of the internal method `functionCallStackOriginatesFromOutsideThisContract` which doesn't exist in the one exported

 * by uma/contracts.

 */

contract Lockable {

    bool internal _notEntered;



    constructor() {

        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every

        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total

        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full

        // refund coming into effect.

        _notEntered = true;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a nonReentrant function from another nonReentrant function is not supported. It is possible to

     * prevent this from happening by making the nonReentrant function external, and making it call a private

     * function that does the actual state modification.

     */

    modifier nonReentrant() {

        _preEntranceCheck();

        _preEntranceSet();

        _;

        _postEntranceReset();

    }



    /**

     * @dev Designed to prevent a view-only method from being re-entered during a call to a nonReentrant() state-changing method.

     */

    modifier nonReentrantView() {

        _preEntranceCheck();

        _;

    }



    /**

     * @dev Returns true if the contract is currently in a non-entered state, meaning that the origination of the call

     * came from outside the contract. This is relevant with fallback/receive methods to see if the call came from ETH

     * being dropped onto the contract externally or due to ETH dropped on the the contract from within a method in this

     * contract, such as unwrapping WETH to ETH within the contract.

     */

    function functionCallStackOriginatesFromOutsideThisContract() internal view returns (bool) {

        return _notEntered;

    }



    // Internal methods are used to avoid copying the require statement's bytecode to every nonReentrant() method.

    // On entry into a function, _preEntranceCheck() should always be called to check if the function is being

    // re-entered. Then, if the function modifies state, it should call _postEntranceSet(), perform its logic, and

    // then call _postEntranceReset().

    // View-only methods can simply call _preEntranceCheck() to make sure that it is not being re-entered.

    function _preEntranceCheck() internal view {

        // On the first call to nonReentrant, _notEntered will be true

        require(_notEntered, "ReentrancyGuard: reentrant call");

    }



    function _preEntranceSet() internal {

        // Any calls to nonReentrant after this point will fail

        _notEntered = false;

    }



    function _postEntranceReset() internal {

        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _notEntered = true;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\LpTokenFactory.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "./interfaces/LpTokenFactoryInterface.sol";



import "@uma/core/contracts/common/implementation/ExpandedERC20.sol";



/**

 * @notice Factory to create new LP ERC20 tokens that represent a liquidity provider's position. HubPool is the

 * intended client of this contract.

 */

contract LpTokenFactory is LpTokenFactoryInterface {

    /**

     * @notice Deploys new LP token for L1 token. Sets caller as minter and burner of token.

     * @param l1Token L1 token to name in LP token name.

     * @return address of new LP token.

     */

    function createLpToken(address l1Token) public returns (address) {

        ExpandedERC20 lpToken = new ExpandedERC20(

            _concatenate("Across V2 ", IERC20Metadata(l1Token).name(), " LP Token"), // LP Token Name

            _concatenate("Av2-", IERC20Metadata(l1Token).symbol(), "-LP"), // LP Token Symbol

            IERC20Metadata(l1Token).decimals() // LP Token Decimals

        );



        lpToken.addMinter(msg.sender); // Set the caller as the LP Token's minter.

        lpToken.addBurner(msg.sender); // Set the caller as the LP Token's burner.

        lpToken.resetOwner(msg.sender); // Set the caller as the LP Token's owner.



        return address(lpToken);

    }



    function _concatenate(

        string memory a,

        string memory b,

        string memory c

    ) internal pure returns (string memory) {

        return string(abi.encodePacked(a, b, c));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\LpTokenFactoryInterface.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



interface LpTokenFactoryInterface {

    function createLpToken(address l1Token) external returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\MerkleDistributor.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./MerkleDistributorInterface.sol";



/**

 * Inspired by:

 * - https://github.com/pie-dao/vested-token-migration-app

 * - https://github.com/Uniswap/merkle-distributor

 * - https://github.com/balancer-labs/erc20-redeemable

 *

 * @title  MerkleDistributor contract.

 * @notice Allows an owner to distribute any reward ERC20 to claimants according to Merkle roots. The owner can specify

 *         multiple Merkle roots distributions with customized reward currencies.

 * @dev    The Merkle trees are not validated in any way, so the system assumes the contract owner behaves honestly.

 */

contract MerkleDistributor is MerkleDistributorInterface, Ownable {

    using SafeERC20 for IERC20;



    // Windows are mapped to arbitrary indices.

    mapping(uint256 => Window) public merkleWindows;



    // Index of next created Merkle root.

    uint256 public nextCreatedIndex;



    // Track which accounts have claimed for each window index.

    // Note: uses a packed array of bools for gas optimization on tracking certain claims. Copied from Uniswap's contract.

    mapping(uint256 => mapping(uint256 => uint256)) private claimedBitMap;



    /****************************************

     *                EVENTS

     ****************************************/

    event Claimed(

        address indexed caller,

        uint256 windowIndex,

        address indexed account,

        uint256 accountIndex,

        uint256 amount,

        address indexed rewardToken

    );

    event CreatedWindow(

        uint256 indexed windowIndex,

        uint256 rewardsDeposited,

        address indexed rewardToken,

        address owner

    );

    event WithdrawRewards(address indexed owner, uint256 amount, address indexed currency);

    event DeleteWindow(uint256 indexed windowIndex, address owner);



    /****************************

     *      ADMIN FUNCTIONS

     ****************************/



    /**

     * @notice Set merkle root for the next available window index and seed allocations.

     * @notice Callable only by owner of this contract. Caller must have approved this contract to transfer

     *      `rewardsToDeposit` amount of `rewardToken` or this call will fail. Importantly, we assume that the

     *      owner of this contract correctly chooses an amount `rewardsToDeposit` that is sufficient to cover all

     *      claims within the `merkleRoot`.

     * @param rewardsToDeposit amount of rewards to deposit to seed this allocation.

     * @param rewardToken ERC20 reward token.

     * @param merkleRoot merkle root describing allocation.

     * @param ipfsHash hash of IPFS object, conveniently stored for clients

     */

    function setWindow(

        uint256 rewardsToDeposit,

        address rewardToken,

        bytes32 merkleRoot,

        string calldata ipfsHash

    ) external onlyOwner {

        uint256 indexToSet = nextCreatedIndex;

        nextCreatedIndex = indexToSet + 1;



        _setWindow(indexToSet, rewardsToDeposit, rewardToken, merkleRoot, ipfsHash);

    }



    /**

     * @notice Delete merkle root at window index.

     * @dev Callable only by owner. Likely to be followed by a withdrawRewards call to clear contract state.

     * @param windowIndex merkle root index to delete.

     */

    function deleteWindow(uint256 windowIndex) external onlyOwner {

        delete merkleWindows[windowIndex];

        emit DeleteWindow(windowIndex, msg.sender);

    }



    /**

     * @notice Emergency method that transfers rewards out of the contract if the contract was configured improperly.

     * @dev Callable only by owner.

     * @param rewardCurrency rewards to withdraw from contract.

     * @param amount amount of rewards to withdraw.

     */

    function withdrawRewards(IERC20 rewardCurrency, uint256 amount) external onlyOwner {

        rewardCurrency.safeTransfer(msg.sender, amount);

        emit WithdrawRewards(msg.sender, amount, address(rewardCurrency));

    }



    /****************************

     *    NON-ADMIN FUNCTIONS

     ****************************/



    /**

     * @notice Batch claims to reduce gas versus individual submitting all claims. Method will fail

     *         if any individual claims within the batch would fail.

     * @dev    Optimistically tries to batch together consecutive claims for the same account and same

     *         reward token to reduce gas. Therefore, the most gas-cost-optimal way to use this method

     *         is to pass in an array of claims sorted by account and reward currency. It also reverts

     *         when any of individual `_claim`'s `amount` exceeds `remainingAmount` for its window.

     * @param claims array of claims to claim.

     */

    function claimMulti(Claim[] memory claims) public virtual override {

        uint256 batchedAmount;

        uint256 claimCount = claims.length;

        for (uint256 i = 0; i < claimCount; i++) {

            Claim memory _claim = claims[i];

            _verifyAndMarkClaimed(_claim);

            batchedAmount += _claim.amount;



            // If the next claim is NOT the same account or the same token (or this claim is the last one),

            // then disburse the `batchedAmount` to the current claim's account for the current claim's reward token.

            uint256 nextI = i + 1;

            IERC20 currentRewardToken = merkleWindows[_claim.windowIndex].rewardToken;

            if (

                nextI == claimCount ||

                // This claim is last claim.

                claims[nextI].account != _claim.account ||

                // Next claim account is different than current one.

                merkleWindows[claims[nextI].windowIndex].rewardToken != currentRewardToken

                // Next claim reward token is different than current one.

            ) {

                currentRewardToken.safeTransfer(_claim.account, batchedAmount);

                batchedAmount = 0;

            }

        }

    }



    /**

     * @notice Claim amount of reward tokens for account, as described by Claim input object.

     * @dev    If the `_claim`'s `amount`, `accountIndex`, and `account` do not exactly match the

     *         values stored in the merkle root for the `_claim`'s `windowIndex` this method

     *         will revert. It also reverts when `_claim`'s `amount` exceeds `remainingAmount` for the window.

     * @param _claim claim object describing amount, accountIndex, account, window index, and merkle proof.

     */

    function claim(Claim memory _claim) public virtual override {

        _verifyAndMarkClaimed(_claim);

        merkleWindows[_claim.windowIndex].rewardToken.safeTransfer(_claim.account, _claim.amount);

    }



    /**

     * @notice Returns True if the claim for `accountIndex` has already been completed for the Merkle root at

     *         `windowIndex`.

     * @dev    This method will only work as intended if all `accountIndex`'s are unique for a given `windowIndex`.

     *         The onus is on the Owner of this contract to submit only valid Merkle roots.

     * @param windowIndex merkle root to check.

     * @param accountIndex account index to check within window index.

     * @return True if claim has been executed already, False otherwise.

     */

    function isClaimed(uint256 windowIndex, uint256 accountIndex) public view returns (bool) {

        uint256 claimedWordIndex = accountIndex / 256;

        uint256 claimedBitIndex = accountIndex % 256;

        uint256 claimedWord = claimedBitMap[windowIndex][claimedWordIndex];

        uint256 mask = (1 << claimedBitIndex);

        return claimedWord & mask == mask;

    }



    /**

     * @notice Returns rewardToken set by admin for windowIndex.

     * @param windowIndex merkle root to check.

     * @return address Reward token address

     */

    function getRewardTokenForWindow(uint256 windowIndex) public view override returns (address) {

        return address(merkleWindows[windowIndex].rewardToken);

    }



    /**

     * @notice Returns True if leaf described by {account, amount, accountIndex} is stored in Merkle root at given

     *         window index.

     * @param _claim claim object describing amount, accountIndex, account, window index, and merkle proof.

     * @return valid True if leaf exists.

     */

    function verifyClaim(Claim memory _claim) public view returns (bool valid) {

        bytes32 leaf = keccak256(abi.encodePacked(_claim.account, _claim.amount, _claim.accountIndex));

        return MerkleProof.verify(_claim.merkleProof, merkleWindows[_claim.windowIndex].merkleRoot, leaf);

    }



    /****************************

     *     PRIVATE FUNCTIONS

     ****************************/



    // Mark claim as completed for `accountIndex` for Merkle root at `windowIndex`.

    function _setClaimed(uint256 windowIndex, uint256 accountIndex) private {

        uint256 claimedWordIndex = accountIndex / 256;

        uint256 claimedBitIndex = accountIndex % 256;

        claimedBitMap[windowIndex][claimedWordIndex] =

            claimedBitMap[windowIndex][claimedWordIndex] |

            (1 << claimedBitIndex);

    }



    // Store new Merkle root at `windowindex`. Pull `rewardsDeposited` from caller to seed distribution for this root.

    function _setWindow(

        uint256 windowIndex,

        uint256 rewardsDeposited,

        address rewardToken,

        bytes32 merkleRoot,

        string memory ipfsHash

    ) private {

        Window storage window = merkleWindows[windowIndex];

        window.merkleRoot = merkleRoot;

        window.remainingAmount = rewardsDeposited;

        window.rewardToken = IERC20(rewardToken);

        window.ipfsHash = ipfsHash;



        emit CreatedWindow(windowIndex, rewardsDeposited, rewardToken, msg.sender);



        window.rewardToken.safeTransferFrom(msg.sender, address(this), rewardsDeposited);

    }



    // Verify claim is valid and mark it as completed in this contract.

    function _verifyAndMarkClaimed(Claim memory _claim) internal {

        // Check claimed proof against merkle window at given index.

        require(verifyClaim(_claim), "Incorrect merkle proof");

        // Check the account has not yet claimed for this window.

        require(!isClaimed(_claim.windowIndex, _claim.accountIndex), "Account has already claimed for this window");



        // Proof is correct and claim has not occurred yet, mark claimed complete.

        _setClaimed(_claim.windowIndex, _claim.accountIndex);

        merkleWindows[_claim.windowIndex].remainingAmount -= _claim.amount;

        emit Claimed(

            msg.sender,

            _claim.windowIndex,

            _claim.account,

            _claim.accountIndex,

            _claim.amount,

            address(merkleWindows[_claim.windowIndex].rewardToken)

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\MerkleDistributorInterface.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";



/**

 * @notice Concise list of functions in MerkleDistributor implementation that would be called by

 * a consuming external contract (such as the Across Protocol's AcceleratingDistributor).

 */

interface MerkleDistributorInterface {

    // A Window maps a Merkle root to a reward token address.

    struct Window {

        // Merkle root describing the distribution.

        bytes32 merkleRoot;

        // Remaining amount of deposited rewards that have not yet been claimed.

        uint256 remainingAmount;

        // Currency in which reward is processed.

        IERC20 rewardToken;

        // IPFS hash of the merkle tree. Can be used to independently fetch recipient proofs and tree. Note that the canonical

        // data type for storing an IPFS hash is a multihash which is the concatenation of  <varint hash function code>

        // <varint digest size in bytes><hash function output>. We opted to store this in a string type to make it easier

        // for users to query the ipfs data without needing to reconstruct the multihash. to view the IPFS data simply

        // go to https://cloudflare-ipfs.com/ipfs/<IPFS-HASH>.

        string ipfsHash;

    }



    // Represents an account's claim for `amount` within the Merkle root located at the `windowIndex`.

    struct Claim {

        uint256 windowIndex;

        uint256 amount;

        uint256 accountIndex; // Used only for bitmap. Assumed to be unique for each claim.

        address account;

        bytes32[] merkleProof;

    }



    function claim(Claim memory _claim) external;



    function claimMulti(Claim[] memory claims) external;



    function getRewardTokenForWindow(uint256 windowIndex) external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\MerkleLib.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "./SpokePoolInterface.sol";

import "./HubPoolInterface.sol";



import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";



/**

 * @notice Library to help with merkle roots, proofs, and claims.

 */

library MerkleLib {

    /**

     * @notice Verifies that a repayment is contained within a merkle root.

     * @param root the merkle root.

     * @param rebalance the rebalance struct.

     * @param proof the merkle proof.

     * @return bool to signal if the pool rebalance proof correctly shows inclusion of the rebalance within the tree.

     */

    function verifyPoolRebalance(

        bytes32 root,

        HubPoolInterface.PoolRebalanceLeaf memory rebalance,

        bytes32[] memory proof

    ) internal pure returns (bool) {

        return MerkleProof.verify(proof, root, keccak256(abi.encode(rebalance)));

    }



    /**

     * @notice Verifies that a relayer refund is contained within a merkle root.

     * @param root the merkle root.

     * @param refund the refund struct.

     * @param proof the merkle proof.

     * @return bool to signal if the relayer refund proof correctly shows inclusion of the refund within the tree.

     */

    function verifyRelayerRefund(

        bytes32 root,

        SpokePoolInterface.RelayerRefundLeaf memory refund,

        bytes32[] memory proof

    ) internal pure returns (bool) {

        return MerkleProof.verify(proof, root, keccak256(abi.encode(refund)));

    }



    /**

     * @notice Verifies that a distribution is contained within a merkle root.

     * @param root the merkle root.

     * @param slowRelayFulfillment the relayData fulfillment struct.

     * @param proof the merkle proof.

     * @return bool to signal if the slow relay's proof correctly shows inclusion of the slow relay within the tree.

     */

    function verifySlowRelayFulfillment(

        bytes32 root,

        SpokePoolInterface.RelayData memory slowRelayFulfillment,

        bytes32[] memory proof

    ) internal pure returns (bool) {

        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));

    }



    // The following functions are primarily copied from

    // https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol with minor changes.



    /**

     * @notice Tests whether a claim is contained within a claimedBitMap mapping.

     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.

     * @param index the index to check in the bitmap.

     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.

     */

    function isClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal view returns (bool) {

        uint256 claimedWordIndex = index / 256;

        uint256 claimedBitIndex = index % 256;

        uint256 claimedWord = claimedBitMap[claimedWordIndex];

        uint256 mask = (1 << claimedBitIndex);

        return claimedWord & mask == mask;

    }



    /**

     * @notice Marks an index in a claimedBitMap as claimed.

     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.

     * @param index the index to mark in the bitmap.

     */

    function setClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal {

        uint256 claimedWordIndex = index / 256;

        uint256 claimedBitIndex = index % 256;

        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);

    }



    /**

     * @notice Tests whether a claim is contained within a 1D claimedBitMap mapping.

     * @param claimedBitMap a simple uint256 value, encoding a 1D bitmap.

     * @param index the index to check in the bitmap. Uint8 type enforces that index can't be > 255.

     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.

     */

    function isClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (bool) {

        uint256 mask = (1 << index);

        return claimedBitMap & mask == mask;

    }



    /**

     * @notice Marks an index in a claimedBitMap as claimed.

     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap. Uint8 type enforces that index

     * can't be > 255.

     * @param index the index to mark in the bitmap.

     * @return uint256 representing the modified input claimedBitMap with the index set to true.

     */

    function setClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (uint256) {

        return claimedBitMap | (1 << index % 256);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\MerkleProof.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)



pragma solidity ^0.8.0;



/**

 * @dev These functions deal with verification of Merkle Trees proofs.

 *

 * The proofs can be generated using the JavaScript library

 * https://github.com/miguelmota/merkletreejs[merkletreejs].

 * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.

 *

 * See `test/utils/cryptography/MerkleProof.test.js` for some examples.

 */

library MerkleProof {

    /**

     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree

     * defined by `root`. For this, a `proof` must be provided, containing

     * sibling hashes on the branch from the leaf to the root of the tree. Each

     * pair of leaves and each pair of pre-images are assumed to be sorted.

     */

    function verify(

        bytes32[] memory proof,

        bytes32 root,

        bytes32 leaf

    ) internal pure returns (bool) {

        return processProof(proof, leaf) == root;

    }



    /**

     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up

     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt

     * hash matches the root of the tree. When processing the proof, the pairs

     * of leafs & pre-images are assumed to be sorted.

     *

     * _Available since v4.4._

     */

    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {

        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {

            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {

                // Hash(current computed hash + current element of the proof)

                computedHash = _efficientHash(computedHash, proofElement);

            } else {

                // Hash(current element of the proof + current computed hash)

                computedHash = _efficientHash(proofElement, computedHash);

            }

        }

        return computedHash;

    }



    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {

        assembly {

            mstore(0x00, a)

            mstore(0x20, b)

            value := keccak256(0x00, 0x40)

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Multicall.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)



pragma solidity ^0.8.0;



import "./Address.sol";



/**

 * @dev Provides a function to batch together multiple calls in a single external call.

 *

 * _Available since v4.1._

 */

abstract contract Multicall {

    /**

     * @dev Receives and executes a batch of function calls on this contract.

     */

    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {

        results = new bytes[](data.length);

        for (uint256 i = 0; i < data.length; i++) {

            results[i] = Address.functionDelegateCall(address(this), data[i]);

        }

        return results;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\MultiCaller.sol
File type: .sol
// This contract is taken from Uniswaps's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)

// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value

// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.

pragma solidity ^0.8.0;



/// @title MultiCaller

/// @notice Enables calling multiple methods in a single call to the contract

contract MultiCaller {

    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results) {

        require(msg.value == 0, "Only multicall with 0 value");

        results = new bytes[](data.length);

        for (uint256 i = 0; i < data.length; i++) {

            (bool success, bytes memory result) = address(this).delegatecall(data[i]);



            if (!success) {

                // Next 5 lines from https://ethereum.stackexchange.com/a/83577

                if (result.length < 68) revert();

                assembly {

                    result := add(result, 0x04)

                }

                revert(abi.decode(result, (string)));

            }



            results[i] = result;

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\MultiRole.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



library Exclusive {

    struct RoleMembership {

        address member;

    }



    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {

        return roleMembership.member == memberToCheck;

    }



    function resetMember(RoleMembership storage roleMembership, address newMember) internal {

        require(newMember != address(0x0), "Cannot set an exclusive role to 0x0");

        roleMembership.member = newMember;

    }



    function getMember(RoleMembership storage roleMembership) internal view returns (address) {

        return roleMembership.member;

    }



    function init(RoleMembership storage roleMembership, address initialMember) internal {

        resetMember(roleMembership, initialMember);

    }

}



library Shared {

    struct RoleMembership {

        mapping(address => bool) members;

    }



    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {

        return roleMembership.members[memberToCheck];

    }



    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {

        require(memberToAdd != address(0x0), "Cannot add 0x0 to a shared role");

        roleMembership.members[memberToAdd] = true;

    }



    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {

        roleMembership.members[memberToRemove] = false;

    }



    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {

        for (uint256 i = 0; i < initialMembers.length; i++) {

            addMember(roleMembership, initialMembers[i]);

        }

    }

}



/**

 * @title Base class to manage permissions for the derived class.

 */

abstract contract MultiRole {

    using Exclusive for Exclusive.RoleMembership;

    using Shared for Shared.RoleMembership;



    enum RoleType { Invalid, Exclusive, Shared }



    struct Role {

        uint256 managingRole;

        RoleType roleType;

        Exclusive.RoleMembership exclusiveRoleMembership;

        Shared.RoleMembership sharedRoleMembership;

    }



    mapping(uint256 => Role) private roles;



    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);

    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);

    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);



    /**

     * @notice Reverts unless the caller is a member of the specified roleId.

     */

    modifier onlyRoleHolder(uint256 roleId) {

        require(holdsRole(roleId, msg.sender), "Sender does not hold required role");

        _;

    }



    /**

     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.

     */

    modifier onlyRoleManager(uint256 roleId) {

        require(holdsRole(roles[roleId].managingRole, msg.sender), "Can only be called by a role manager");

        _;

    }



    /**

     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.

     */

    modifier onlyExclusive(uint256 roleId) {

        require(roles[roleId].roleType == RoleType.Exclusive, "Must be called on an initialized Exclusive role");

        _;

    }



    /**

     * @notice Reverts unless the roleId represents an initialized, shared roleId.

     */

    modifier onlyShared(uint256 roleId) {

        require(roles[roleId].roleType == RoleType.Shared, "Must be called on an initialized Shared role");

        _;

    }



    /**

     * @notice Whether `memberToCheck` is a member of roleId.

     * @dev Reverts if roleId does not correspond to an initialized role.

     * @param roleId the Role to check.

     * @param memberToCheck the address to check.

     * @return True if `memberToCheck` is a member of `roleId`.

     */

    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {

        Role storage role = roles[roleId];

        if (role.roleType == RoleType.Exclusive) {

            return role.exclusiveRoleMembership.isMember(memberToCheck);

        } else if (role.roleType == RoleType.Shared) {

            return role.sharedRoleMembership.isMember(memberToCheck);

        }

        revert("Invalid roleId");

    }



    /**

     * @notice Changes the exclusive role holder of `roleId` to `newMember`.

     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an

     * initialized, ExclusiveRole.

     * @param roleId the ExclusiveRole membership to modify.

     * @param newMember the new ExclusiveRole member.

     */

    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {

        roles[roleId].exclusiveRoleMembership.resetMember(newMember);

        emit ResetExclusiveMember(roleId, newMember, msg.sender);

    }



    /**

     * @notice Gets the current holder of the exclusive role, `roleId`.

     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.

     * @param roleId the ExclusiveRole membership to check.

     * @return the address of the current ExclusiveRole member.

     */

    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {

        return roles[roleId].exclusiveRoleMembership.getMember();

    }



    /**

     * @notice Adds `newMember` to the shared role, `roleId`.

     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the

     * managing role for `roleId`.

     * @param roleId the SharedRole membership to modify.

     * @param newMember the new SharedRole member.

     */

    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {

        roles[roleId].sharedRoleMembership.addMember(newMember);

        emit AddedSharedMember(roleId, newMember, msg.sender);

    }



    /**

     * @notice Removes `memberToRemove` from the shared role, `roleId`.

     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the

     * managing role for `roleId`.

     * @param roleId the SharedRole membership to modify.

     * @param memberToRemove the current SharedRole member to remove.

     */

    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {

        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);

        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);

    }



    /**

     * @notice Removes caller from the role, `roleId`.

     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an

     * initialized, SharedRole.

     * @param roleId the SharedRole membership to modify.

     */

    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {

        roles[roleId].sharedRoleMembership.removeMember(msg.sender);

        emit RemovedSharedMember(roleId, msg.sender, msg.sender);

    }



    /**

     * @notice Reverts if `roleId` is not initialized.

     */

    modifier onlyValidRole(uint256 roleId) {

        require(roles[roleId].roleType != RoleType.Invalid, "Attempted to use an invalid roleId");

        _;

    }



    /**

     * @notice Reverts if `roleId` is initialized.

     */

    modifier onlyInvalidRole(uint256 roleId) {

        require(roles[roleId].roleType == RoleType.Invalid, "Cannot use a pre-existing role");

        _;

    }



    /**

     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.

     * `initialMembers` will be immediately added to the role.

     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already

     * initialized.

     */

    function _createSharedRole(

        uint256 roleId,

        uint256 managingRoleId,

        address[] memory initialMembers

    ) internal onlyInvalidRole(roleId) {

        Role storage role = roles[roleId];

        role.roleType = RoleType.Shared;

        role.managingRole = managingRoleId;

        role.sharedRoleMembership.init(initialMembers);

        require(

            roles[managingRoleId].roleType != RoleType.Invalid,

            "Attempted to use an invalid role to manage a shared role"

        );

    }



    /**

     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.

     * `initialMember` will be immediately added to the role.

     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already

     * initialized.

     */

    function _createExclusiveRole(

        uint256 roleId,

        uint256 managingRoleId,

        address initialMember

    ) internal onlyInvalidRole(roleId) {

        Role storage role = roles[roleId];

        role.roleType = RoleType.Exclusive;

        role.managingRole = managingRoleId;

        role.exclusiveRoleMembership.init(initialMember);

        require(

            roles[managingRoleId].roleType != RoleType.Invalid,

            "Attempted to use an invalid role to manage an exclusive role"

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Optimism_Adapter.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "../interfaces/AdapterInterface.sol";

import "../interfaces/WETH9.sol";



// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need

// this contract's state variables to be `immutable` because of the delegateCall call.

import "./CrossDomainEnabled.sol";

import "@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol";



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



/**

 * @notice Contract containing logic to send messages from L1 to Optimism.

 * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be

 * called via delegatecall, which will execute this contract's logic within the context of the originating contract.

 * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods

 * that call this contract's logic guard against reentrancy.

 */



// solhint-disable-next-line contract-name-camelcase

contract Optimism_Adapter is CrossDomainEnabled, AdapterInterface {

    using SafeERC20 for IERC20;

    uint32 public immutable l2GasLimit = 2_000_000;



    WETH9 public immutable l1Weth;



    IL1StandardBridge public immutable l1StandardBridge;



    // Optimism has the ability to support "custom" bridges. These bridges are not supported by the canonical bridge

    // and so we need to store the address of the custom token and the associated bridge. In the event we want to

    // support a new token that is not supported by Optimism, we can add a new custom bridge for it and re-deploy the

    // adapter. A full list of custom optimism tokens and their associated bridges can be found here:

    // https://github.com/ethereum-optimism/ethereum-optimism.github.io/blob/master/optimism.tokenlist.json

    address public immutable dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

    address public immutable daiOptimismBridge = 0x10E6593CDda8c58a1d0f14C5164B376352a55f2F;

    address public immutable snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;

    address public immutable snxOptimismBridge = 0xCd9D4988C0AE61887B075bA77f08cbFAd2b65068;



    /**

     * @notice Constructs new Adapter.

     * @param _l1Weth WETH address on L1.

     * @param _crossDomainMessenger XDomainMessenger Optimism system contract.

     * @param _l1StandardBridge Standard bridge contract.

     */

    constructor(

        WETH9 _l1Weth,

        address _crossDomainMessenger,

        IL1StandardBridge _l1StandardBridge

    ) CrossDomainEnabled(_crossDomainMessenger) {

        l1Weth = _l1Weth;

        l1StandardBridge = _l1StandardBridge;

    }



    /**

     * @notice Send cross-chain message to target on Optimism.

     * @param target Contract on Optimism that will receive message.

     * @param message Data to send to target.

     */

    function relayMessage(address target, bytes calldata message) external payable override {

        sendCrossDomainMessage(target, uint32(l2GasLimit), message);

        emit MessageRelayed(target, message);

    }



    /**

     * @notice Bridge tokens to Optimism.

     * @param l1Token L1 token to deposit.

     * @param l2Token L2 token to receive.

     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.

     * @param to Bridge recipient.

     */

    function relayTokens(

        address l1Token,

        address l2Token,

        uint256 amount,

        address to

    ) external payable override {

        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.

        if (l1Token == address(l1Weth)) {

            l1Weth.withdraw(amount);

            l1StandardBridge.depositETHTo{ value: amount }(to, l2GasLimit, "");

        } else {

            IL1StandardBridge _l1StandardBridge = l1StandardBridge;



            // Check if the L1 token requires a custom bridge. If so, use that bridge over the standard bridge.

            if (l1Token == dai) _l1StandardBridge = IL1StandardBridge(daiOptimismBridge); // 1. DAI

            if (l1Token == snx) _l1StandardBridge = IL1StandardBridge(snxOptimismBridge); // 2. SNX



            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);

            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, l2GasLimit, "");

        }

        emit TokensRelayed(l1Token, l2Token, amount, to);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\OptimisticOracleInterface.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";



/**

 * @title Financial contract facing Oracle interface.

 * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.

 */

abstract contract OptimisticOracleInterface {

    // Struct representing the state of a price request.

    enum State {

        Invalid, // Never requested.

        Requested, // Requested, no other actions taken.

        Proposed, // Proposed, but not expired or disputed yet.

        Expired, // Proposed, not disputed, past liveness.

        Disputed, // Disputed, but no DVM price returned yet.

        Resolved, // Disputed and DVM price is available.

        Settled // Final price has been set in the contract (can get here from Expired or Resolved).

    }



    // Struct representing a price request.

    struct Request {

        address proposer; // Address of the proposer.

        address disputer; // Address of the disputer.

        IERC20 currency; // ERC20 token used to pay rewards and fees.

        bool settled; // True if the request is settled.

        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.

        int256 proposedPrice; // Price that the proposer submitted.

        int256 resolvedPrice; // Price resolved once the request is settled.

        uint256 expirationTime; // Time at which the request auto-settles without a dispute.

        uint256 reward; // Amount of the currency to pay to the proposer on settlement.

        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.

        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.

        uint256 customLiveness; // Custom liveness value set by the requester.

    }



    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible

    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses

    // to accept a price request made with ancillary data length over a certain size.

    uint256 public constant ancillaryBytesLimit = 8192;



    /**

     * @notice Requests a new price.

     * @param identifier price identifier being requested.

     * @param timestamp timestamp of the price being requested.

     * @param ancillaryData ancillary data representing additional args being passed with the price request.

     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.

     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,

     *               which could make sense if the contract requests and proposes the value in the same call or

     *               provides its own reward system.

     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.

     * This can be changed with a subsequent call to setBond().

     */

    function requestPrice(

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData,

        IERC20 currency,

        uint256 reward

    ) external virtual returns (uint256 totalBond);



    /**

     * @notice Set the proposal bond associated with a price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param bond custom bond amount to set.

     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be

     * changed again with a subsequent call to setBond().

     */

    function setBond(

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData,

        uint256 bond

    ) external virtual returns (uint256 totalBond);



    /**

     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to "hedge" the caller

     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's

     * bond, so there is still profit to be made even if the reward is refunded.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     */

    function setRefundOnDispute(

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData

    ) external virtual;



    /**

     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before

     * being auto-resolved.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param customLiveness new custom liveness.

     */

    function setCustomLiveness(

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData,

        uint256 customLiveness

    ) external virtual;



    /**

     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come

     * from this proposal. However, any bonds are pulled from the caller.

     * @param proposer address to set as the proposer.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param proposedPrice price being proposed.

     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to

     * the proposer once settled if the proposal is correct.

     */

    function proposePriceFor(

        address proposer,

        address requester,

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData,

        int256 proposedPrice

    ) public virtual returns (uint256 totalBond);



    /**

     * @notice Proposes a price value for an existing price request.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param proposedPrice price being proposed.

     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to

     * the proposer once settled if the proposal is correct.

     */

    function proposePrice(

        address requester,

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData,

        int256 proposedPrice

    ) external virtual returns (uint256 totalBond);



    /**

     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will

     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.

     * @param disputer address to set as the disputer.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to

     * the disputer once settled if the dispute was value (the proposal was incorrect).

     */

    function disputePriceFor(

        address disputer,

        address requester,

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData

    ) public virtual returns (uint256 totalBond);



    /**

     * @notice Disputes a price value for an existing price request with an active proposal.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to

     * the disputer once settled if the dispute was valid (the proposal was incorrect).

     */

    function disputePrice(

        address requester,

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData

    ) external virtual returns (uint256 totalBond);



    /**

     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled

     * or settleable. Note: this method is not view so that this call may actually settle the price request if it

     * hasn't been settled.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @return resolved price.

     */

    function settleAndGetPrice(

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData

    ) external virtual returns (int256);



    /**

     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @return payout the amount that the "winner" (proposer or disputer) receives on settlement. This amount includes

     * the returned bonds as well as additional rewards.

     */

    function settle(

        address requester,

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData

    ) external virtual returns (uint256 payout);



    /**

     * @notice Gets the current data structure containing all information about a price request.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @return the Request data structure.

     */

    function getRequest(

        address requester,

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData

    ) public view virtual returns (Request memory);



    /**

     * @notice Returns the state of a price request.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @return the State enum value.

     */

    function getState(

        address requester,

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData

    ) public view virtual returns (State);



    /**

     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @return true if price has resolved or settled, false otherwise.

     */

    function hasPrice(

        address requester,

        bytes32 identifier,

        uint256 timestamp,

        bytes memory ancillaryData

    ) public view virtual returns (bool);



    function stampAncillaryData(bytes memory ancillaryData, address requester)

        public

        view

        virtual

        returns (bytes memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)



pragma solidity ^0.8.0;



import "../utils/Context.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _transferOwnership(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _transferOwnership(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Internal function without access restriction.

     */

    function _transferOwnership(address newOwner) internal virtual {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\PolygonTokenBridger.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "./Lockable.sol";

import "./interfaces/WETH9.sol";



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



// Polygon Registry contract that stores their addresses.

interface PolygonRegistry {

    function erc20Predicate() external returns (address);

}



// Polygon ERC20Predicate contract that handles Plasma exits (only used for Matic).

interface PolygonERC20Predicate {

    function startExitWithBurntTokens(bytes calldata data) external;

}



// ERC20s (on polygon) compatible with polygon's bridge have a withdraw method.

interface PolygonIERC20 is IERC20 {

    function withdraw(uint256 amount) external;

}



interface MaticToken {

    function withdraw(uint256 amount) external payable;

}



/**

 * @notice Contract deployed on Ethereum and Polygon to facilitate token transfers from Polygon to the HubPool and back.

 * @dev Because Polygon only allows withdrawals from a particular address to go to that same address on mainnet, we need to

 * have some sort of contract that can guarantee identical addresses on Polygon and Ethereum. This contract is intended

 * to be completely immutable, so it's guaranteed that the contract on each side is  configured identically as long as

 * it is created via create2. create2 is an alternative creation method that uses a different address determination

 * mechanism from normal create.

 * Normal create: address = hash(deployer_address, deployer_nonce)

 * create2:       address = hash(0xFF, sender, salt, bytecode)

 *  This ultimately allows create2 to generate deterministic addresses that don't depend on the transaction count of the

 * sender.

 */

contract PolygonTokenBridger is Lockable {

    using SafeERC20 for PolygonIERC20;

    using SafeERC20 for IERC20;



    // Gas token for Polygon.

    MaticToken public constant maticToken = MaticToken(0x0000000000000000000000000000000000001010);



    // Should be set to HubPool on Ethereum, or unused on Polygon.

    address public immutable destination;



    // Registry that stores L1 polygon addresses.

    PolygonRegistry public immutable l1PolygonRegistry;



    // WETH contract on Ethereum.

    WETH9 public immutable l1Weth;



    // Wrapped Matic on Polygon

    address public immutable l2WrappedMatic;



    // Chain id for the L1 that this contract is deployed on or communicates with.

    // For example: if this contract were meant to facilitate transfers from polygon to mainnet, this value would be

    // the mainnet chainId 1.

    uint256 public immutable l1ChainId;



    // Chain id for the L2 that this contract is deployed on or communicates with.

    // For example: if this contract were meant to facilitate transfers from polygon to mainnet, this value would be

    // the polygon chainId 137.

    uint256 public immutable l2ChainId;



    modifier onlyChainId(uint256 chainId) {

        _requireChainId(chainId);

        _;

    }



    /**

     * @notice Constructs Token Bridger contract.

     * @param _destination Where to send tokens to for this network.

     * @param _l1PolygonRegistry L1 registry that stores updated addresses of polygon contracts. This should always be

     * set to the L1 registry regardless if whether it's deployed on L2 or L1.

     * @param _l1Weth L1 WETH address.

     * @param _l2WrappedMatic L2 address of wrapped matic token.

     * @param _l1ChainId the chain id for the L1 in this environment.

     * @param _l2ChainId the chain id for the L2 in this environment.

     */

    constructor(

        address _destination,

        PolygonRegistry _l1PolygonRegistry,

        WETH9 _l1Weth,

        address _l2WrappedMatic,

        uint256 _l1ChainId,

        uint256 _l2ChainId

    ) {

        destination = _destination;

        l1PolygonRegistry = _l1PolygonRegistry;

        l1Weth = _l1Weth;

        l2WrappedMatic = _l2WrappedMatic;

        l1ChainId = _l1ChainId;

        l2ChainId = _l2ChainId;

    }



    /**

     * @notice Called by Polygon SpokePool to send tokens over bridge to contract with the same address as this.

     * @notice The caller of this function must approve this contract to spend amount of token.

     * @param token Token to bridge.

     * @param amount Amount to bridge.

     */

    function send(PolygonIERC20 token, uint256 amount) public nonReentrant onlyChainId(l2ChainId) {

        token.safeTransferFrom(msg.sender, address(this), amount);



        // In the wMatic case, this unwraps. For other ERC20s, this is the burn/send action.

        token.withdraw(token.balanceOf(address(this)));



        // This takes the token that was withdrawn and calls withdraw on the "native" ERC20.

        if (address(token) == l2WrappedMatic)

            maticToken.withdraw{ value: address(this).balance }(address(this).balance);

    }



    /**

     * @notice Called by someone to send tokens to the destination, which should be set to the HubPool.

     * @param token Token to send to destination.

     */

    function retrieve(IERC20 token) public nonReentrant onlyChainId(l1ChainId) {

        if (address(token) == address(l1Weth)) {

            // For WETH, there is a pre-deposit step to ensure any ETH that has been sent to the contract is captured.

            l1Weth.deposit{ value: address(this).balance }();

        }

        token.safeTransfer(destination, token.balanceOf(address(this)));

    }



    /**

     * @notice Called to initiate an l1 exit (withdrawal) of matic tokens that have been sent over the plasma bridge.

     * @param data the proof data to trigger the exit. Can be generated using the maticjs-plasma package.

     */

    function callExit(bytes memory data) public nonReentrant onlyChainId(l1ChainId) {

        PolygonERC20Predicate erc20Predicate = PolygonERC20Predicate(l1PolygonRegistry.erc20Predicate());

        erc20Predicate.startExitWithBurntTokens(data);

    }



    receive() external payable {

        // This method is empty to avoid any gas expendatures that might cause transfers to fail.

        // Note: the fact that there is _no_ code in this function means that matic can be erroneously transferred in

        // to the contract on the polygon side. These tokens would be locked indefinitely since the receive function

        // cannot be called on the polygon side. While this does have some downsides, the lack of any functionality

        // in this function means that it has no chance of running out of gas on transfers, which is a much more

        // important benefit. This just makes the matic token risk similar to that of ERC20s that are erroneously

        // sent to the contract.

    }



    function _requireChainId(uint256 chainId) internal view {

        require(block.chainid == chainId, "Cannot run method on this chain");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Polygon_Adapter.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "../interfaces/AdapterInterface.sol";

import "../interfaces/WETH9.sol";



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



interface IRootChainManager {

    function depositEtherFor(address user) external payable;



    function depositFor(

        address user,

        address rootToken,

        bytes calldata depositData

    ) external;

}



interface IFxStateSender {

    function sendMessageToChild(address _receiver, bytes calldata _data) external;

}



interface DepositManager {

    function depositERC20ForUser(

        address token,

        address user,

        uint256 amount

    ) external;

}



/**

 * @notice Sends cross chain messages Polygon L2 network.

 * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be

 * called via delegatecall, which will execute this contract's logic within the context of the originating contract.

 * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods

 * that call this contract's logic guard against reentrancy.

 */



// solhint-disable-next-line contract-name-camelcase

contract Polygon_Adapter is AdapterInterface {

    using SafeERC20 for IERC20;

    IRootChainManager public immutable rootChainManager;

    IFxStateSender public immutable fxStateSender;

    DepositManager public immutable depositManager;

    address public immutable erc20Predicate;

    address public immutable l1Matic;

    WETH9 public immutable l1Weth;



    /**

     * @notice Constructs new Adapter.

     * @param _rootChainManager RootChainManager Polygon system contract to deposit tokens over the PoS bridge.

     * @param _fxStateSender FxStateSender Polygon system contract to send arbitrary messages to L2.

     * @param _depositManager DepositManager Polygon system contract to deposit tokens over the Plasma bridge (Matic).

     * @param _erc20Predicate ERC20Predicate Polygon system contract to approve when depositing to the PoS bridge.

     * @param _l1Matic matic address on l1.

     * @param _l1Weth WETH address on L1.

     */

    constructor(

        IRootChainManager _rootChainManager,

        IFxStateSender _fxStateSender,

        DepositManager _depositManager,

        address _erc20Predicate,

        address _l1Matic,

        WETH9 _l1Weth

    ) {

        rootChainManager = _rootChainManager;

        fxStateSender = _fxStateSender;

        depositManager = _depositManager;

        erc20Predicate = _erc20Predicate;

        l1Matic = _l1Matic;

        l1Weth = _l1Weth;

    }



    /**

     * @notice Send cross-chain message to target on Polygon.

     * @param target Contract on Polygon that will receive message.

     * @param message Data to send to target.

     */



    function relayMessage(address target, bytes calldata message) external payable override {

        fxStateSender.sendMessageToChild(target, message);

        emit MessageRelayed(target, message);

    }



    /**

     * @notice Bridge tokens to Polygon.

     * @param l1Token L1 token to deposit.

     * @param l2Token L2 token to receive.

     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.

     * @param to Bridge recipient.

     */

    function relayTokens(

        address l1Token,

        address l2Token,

        uint256 amount,

        address to

    ) external payable override {

        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.

        if (l1Token == address(l1Weth)) {

            l1Weth.withdraw(amount);

            rootChainManager.depositEtherFor{ value: amount }(to);

        } else if (l1Token == l1Matic) {

            IERC20(l1Token).safeIncreaseAllowance(address(depositManager), amount);

            depositManager.depositERC20ForUser(l1Token, to, amount);

        } else {

            IERC20(l1Token).safeIncreaseAllowance(erc20Predicate, amount);

            rootChainManager.depositFor(to, l1Token, abi.encode(amount));

        }

        emit TokensRelayed(l1Token, l2Token, amount, to);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\ReentrancyGuard.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)



pragma solidity ^0.8.0;



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * TIP: If you would like to learn more about reentrancy and alternative ways

 * to protect against it, check out our blog post

 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].

 */

abstract contract ReentrancyGuard {

    // Booleans are more expensive than uint256 or any type that takes up a full

    // word because each write operation emits an extra SLOAD to first read the

    // slot's contents, replace the bits taken up by the boolean, and then write

    // back. This is the compiler's defense against contract upgrades and

    // pointer aliasing, and it cannot be disabled.



    // The values being non-zero value makes deployment a bit more expensive,

    // but in exchange the refund on every call to nonReentrant will be lower in

    // amount. Since refunds are capped to a percentage of the total

    // transaction's gas, it is best to keep them low in cases like this one, to

    // increase the likelihood of the full refund coming into effect.

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    uint256 private _status;



    constructor() {

        _status = _NOT_ENTERED;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and making it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _status = _ENTERED;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _status = _NOT_ENTERED;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)



pragma solidity ^0.8.0;



import "../IERC20.sol";

import "../../../utils/Address.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender) + value;

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        unchecked {

            uint256 oldAllowance = token.allowance(address(this), spender);

            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");

            uint256 newAllowance = oldAllowance - value;

            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

        }

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {

            // Return data is optional

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\SafeMath.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)



pragma solidity ^0.8.0;



// CAUTION

// This version of SafeMath should only be used with Solidity 0.8 or later,

// because it relies on the compiler's built in overflow checks.



/**

 * @dev Wrappers over Solidity's arithmetic operations.

 *

 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler

 * now has built in overflow checking.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            uint256 c = a + b;

            if (c < a) return (false, 0);

            return (true, c);

        }

    }



    /**

     * @dev Returns the substraction of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            if (b > a) return (false, 0);

            return (true, a - b);

        }

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

            // benefit is lost if 'b' is also tested.

            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

            if (a == 0) return (true, 0);

            uint256 c = a * b;

            if (c / a != b) return (false, 0);

            return (true, c);

        }

    }



    /**

     * @dev Returns the division of two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            if (b == 0) return (false, 0);

            return (true, a / b);

        }

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            if (b == 0) return (false, 0);

            return (true, a % b);

        }

    }



    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        return a + b;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return a - b;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        return a * b;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator.

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return a % b;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {trySub}.

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        unchecked {

            require(b <= a, errorMessage);

            return a - b;

        }

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        unchecked {

            require(b > 0, errorMessage);

            return a / b;

        }

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting with custom message when dividing by zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryMod}.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        unchecked {

            require(b > 0, errorMessage);

            return a % b;

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\SignedSafeMath.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)



pragma solidity ^0.8.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations.

 *

 * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler

 * now has built in overflow checking.

 */

library SignedSafeMath {

    /**

     * @dev Returns the multiplication of two signed integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(int256 a, int256 b) internal pure returns (int256) {

        return a * b;

    }



    /**

     * @dev Returns the integer division of two signed integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator.

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(int256 a, int256 b) internal pure returns (int256) {

        return a / b;

    }



    /**

     * @dev Returns the subtraction of two signed integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(int256 a, int256 b) internal pure returns (int256) {

        return a - b;

    }



    /**

     * @dev Returns the addition of two signed integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(int256 a, int256 b) internal pure returns (int256) {

        return a + b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\SkinnyOptimisticOracleInterface.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "../interfaces/OptimisticOracleInterface.sol";



/**

 * @title Interface for the gas-cost-reduced version of the OptimisticOracle.

 * @notice Differences from normal OptimisticOracle:

 * - refundOnDispute: flag is removed, by default there are no refunds on disputes.

 * - customizing request parameters: In the OptimisticOracle, parameters like `bond` and `customLiveness` can be reset

 *   after a request is already made via `requestPrice`. In the SkinnyOptimisticOracle, these parameters can only be

 *   set in `requestPrice`, which has an expanded input set.

 * - settleAndGetPrice: Replaced by `settle`, which can only be called once per settleable request. The resolved price

 *   can be fetched via the `Settle` event or the return value of `settle`.

 * - general changes to interface: Functions that interact with existing requests all require the parameters of the

 *   request to modify to be passed as input. These parameters must match with the existing request parameters or the

 *   function will revert. This change reflects the internal refactor to store hashed request parameters instead of the

 *   full request struct.

 * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.

 */

abstract contract SkinnyOptimisticOracleInterface {

    // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct

    // in that refundOnDispute is removed.

    struct Request {

        address proposer; // Address of the proposer.

        address disputer; // Address of the disputer.

        IERC20 currency; // ERC20 token used to pay rewards and fees.

        bool settled; // True if the request is settled.

        int256 proposedPrice; // Price that the proposer submitted.

        int256 resolvedPrice; // Price resolved once the request is settled.

        uint256 expirationTime; // Time at which the request auto-settles without a dispute.

        uint256 reward; // Amount of the currency to pay to the proposer on settlement.

        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.

        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.

        uint256 customLiveness; // Custom liveness value set by the requester.

    }



    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible

    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses

    // to accept a price request made with ancillary data length over a certain size.

    uint256 public constant ancillaryBytesLimit = 8192;



    /**

     * @notice Requests a new price.

     * @param identifier price identifier being requested.

     * @param timestamp timestamp of the price being requested.

     * @param ancillaryData ancillary data representing additional args being passed with the price request.

     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.

     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,

     *               which could make sense if the contract requests and proposes the value in the same call or

     *               provides its own reward system.

     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.

     * @param customLiveness custom proposal liveness to set for request.

     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.

     */

    function requestPrice(

        bytes32 identifier,

        uint32 timestamp,

        bytes memory ancillaryData,

        IERC20 currency,

        uint256 reward,

        uint256 bond,

        uint256 customLiveness

    ) external virtual returns (uint256 totalBond);



    /**

     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come

     * from this proposal. However, any bonds are pulled from the caller.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param request price request parameters whose hash must match the request that the caller wants to

     * propose a price for.

     * @param proposer address to set as the proposer.

     * @param proposedPrice price being proposed.

     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to

     * the proposer once settled if the proposal is correct.

     */

    function proposePriceFor(

        address requester,

        bytes32 identifier,

        uint32 timestamp,

        bytes memory ancillaryData,

        Request memory request,

        address proposer,

        int256 proposedPrice

    ) public virtual returns (uint256 totalBond);



    /**

     * @notice Proposes a price value where caller is the proposer.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param request price request parameters whose hash must match the request that the caller wants to

     * propose a price for.

     * @param proposedPrice price being proposed.

     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to

     * the proposer once settled if the proposal is correct.

     */

    function proposePrice(

        address requester,

        bytes32 identifier,

        uint32 timestamp,

        bytes memory ancillaryData,

        Request memory request,

        int256 proposedPrice

    ) external virtual returns (uint256 totalBond);



    /**

     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to

     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer

     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.

     * @dev The caller is the requester, but the proposer can be customized.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.

     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,

     *               which could make sense if the contract requests and proposes the value in the same call or

     *               provides its own reward system.

     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.

     * @param customLiveness custom proposal liveness to set for request.

     * @param proposer address to set as the proposer.

     * @param proposedPrice price being proposed.

     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to

     * the proposer once settled if the proposal is correct.

     */

    function requestAndProposePriceFor(

        bytes32 identifier,

        uint32 timestamp,

        bytes memory ancillaryData,

        IERC20 currency,

        uint256 reward,

        uint256 bond,

        uint256 customLiveness,

        address proposer,

        int256 proposedPrice

    ) external virtual returns (uint256 totalBond);



    /**

     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will

     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param request price request parameters whose hash must match the request that the caller wants to

     * dispute.

     * @param disputer address to set as the disputer.

     * @param requester sender of the initial price request.

     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to

     * the disputer once settled if the dispute was valid (the proposal was incorrect).

     */

    function disputePriceFor(

        bytes32 identifier,

        uint32 timestamp,

        bytes memory ancillaryData,

        Request memory request,

        address disputer,

        address requester

    ) public virtual returns (uint256 totalBond);



    /**

     * @notice Disputes a price request with an active proposal where caller is the disputer.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param request price request parameters whose hash must match the request that the caller wants to

     * dispute.

     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to

     * the disputer once settled if the dispute was valid (the proposal was incorrect).

     */

    function disputePrice(

        address requester,

        bytes32 identifier,

        uint32 timestamp,

        bytes memory ancillaryData,

        Request memory request

    ) external virtual returns (uint256 totalBond);



    /**

     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param request price request parameters whose hash must match the request that the caller wants to

     * settle.

     * @return payout the amount that the "winner" (proposer or disputer) receives on settlement. This amount includes

     * the returned bonds as well as additional rewards.

     * @return resolvedPrice the price that the request settled to.

     */

    function settle(

        address requester,

        bytes32 identifier,

        uint32 timestamp,

        bytes memory ancillaryData,

        Request memory request

    ) external virtual returns (uint256 payout, int256 resolvedPrice);



    /**

     * @notice Computes the current state of a price request. See the State enum for more details.

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param request price request parameters.

     * @return the State.

     */

    function getState(

        address requester,

        bytes32 identifier,

        uint32 timestamp,

        bytes memory ancillaryData,

        Request memory request

    ) external virtual returns (OptimisticOracleInterface.State);



    /**

     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).

     * @param requester sender of the initial price request.

     * @param identifier price identifier to identify the existing request.

     * @param timestamp timestamp to identify the existing request.

     * @param ancillaryData ancillary data of the price being requested.

     * @param request price request parameters. The hash of these parameters must match with the request hash that is

     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method

     * will revert.

     * @return boolean indicating true if price exists and false if not.

     */

    function hasPrice(

        address requester,

        bytes32 identifier,

        uint32 timestamp,

        bytes memory ancillaryData,

        Request memory request

    ) public virtual returns (bool);



    /**

     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.

     * @param ancillaryData ancillary data of the price being requested.

     * @param requester sender of the initial price request.

     * @return the stamped ancillary bytes.

     */

    function stampAncillaryData(bytes memory ancillaryData, address requester)

        public

        pure

        virtual

        returns (bytes memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\SpokePool.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



import "./MerkleLib.sol";

import "./interfaces/WETH9.sol";

import "./Lockable.sol";

import "./SpokePoolInterface.sol";



import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/utils/Address.sol";



import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

import "@uma/core/contracts/common/implementation/Testable.sol";

import "@uma/core/contracts/common/implementation/MultiCaller.sol";



/**

 * @title SpokePool

 * @notice Base contract deployed on source and destination chains enabling depositors to transfer assets from source to

 * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited

 * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount

 * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1 HubPool.

 * Relayers are refunded with destination tokens out of this contract after another off-chain actor, a "data worker",

 * submits a proof that the relayer correctly submitted a relay on this SpokePool.

 */

abstract contract SpokePool is SpokePoolInterface, Testable, Lockable, MultiCaller {

    using SafeERC20 for IERC20;

    using Address for address;



    // Address of the L1 contract that acts as the owner of this SpokePool. If this contract is deployed on Ethereum,

    // then this address should be set to the same owner as the HubPool and the whole system.

    address public crossDomainAdmin;



    // Address of the L1 contract that will send tokens to and receive tokens from this contract to fund relayer

    // refunds and slow relays.

    address public hubPool;



    // Address of wrappedNativeToken contract for this network. If an origin token matches this, then the caller can

    // optionally instruct this contract to wrap native tokens when depositing (ie ETH->WETH or MATIC->WMATIC).

    WETH9 public immutable wrappedNativeToken;



    // Any deposit quote times greater than or less than this value to the current contract time is blocked. Forces

    // caller to use an approximately "current" realized fee. Defaults to 10 minutes.

    uint32 public depositQuoteTimeBuffer = 600;



    // Count of deposits is used to construct a unique deposit identifier for this spoke pool.

    uint32 public numberOfDeposits;



    // This contract can store as many root bundles as the HubPool chooses to publish here.

    RootBundle[] public rootBundles;



    // Origin token to destination token routings can be turned on or off, which can enable or disable deposits.

    mapping(address => mapping(uint256 => bool)) public enabledDepositRoutes;



    // Each relay is associated with the hash of parameters that uniquely identify the original deposit and a relay

    // attempt for that deposit. The relay itself is just represented as the amount filled so far. The total amount to

    // relay, the fees, and the agents are all parameters included in the hash key.

    mapping(bytes32 => uint256) public relayFills;



    /****************************************

     *                EVENTS                *

     ****************************************/

    event SetXDomainAdmin(address indexed newAdmin);

    event SetHubPool(address indexed newHubPool);

    event EnabledDepositRoute(address indexed originToken, uint256 indexed destinationChainId, bool enabled);

    event SetDepositQuoteTimeBuffer(uint32 newBuffer);

    event FundsDeposited(

        uint256 amount,

        uint256 originChainId,

        uint256 destinationChainId,

        uint64 relayerFeePct,

        uint32 indexed depositId,

        uint32 quoteTimestamp,

        address indexed originToken,

        address recipient,

        address indexed depositor

    );

    event RequestedSpeedUpDeposit(

        uint64 newRelayerFeePct,

        uint32 indexed depositId,

        address indexed depositor,

        bytes depositorSignature

    );

    event FilledRelay(

        uint256 amount,

        uint256 totalFilledAmount,

        uint256 fillAmount,

        uint256 repaymentChainId,

        uint256 originChainId,

        uint256 destinationChainId,

        uint64 relayerFeePct,

        uint64 appliedRelayerFeePct,

        uint64 realizedLpFeePct,

        uint32 depositId,

        address destinationToken,

        address indexed relayer,

        address indexed depositor,

        address recipient,

        bool isSlowRelay

    );

    event RelayedRootBundle(

        uint32 indexed rootBundleId,

        bytes32 indexed relayerRefundRoot,

        bytes32 indexed slowRelayRoot

    );

    event ExecutedRelayerRefundRoot(

        uint256 amountToReturn,

        uint256 indexed chainId,

        uint256[] refundAmounts,

        uint32 indexed rootBundleId,

        uint32 indexed leafId,

        address l2TokenAddress,

        address[] refundAddresses,

        address caller

    );

    event TokensBridged(

        uint256 amountToReturn,

        uint256 indexed chainId,

        uint32 indexed leafId,

        address indexed l2TokenAddress,

        address caller

    );

    event EmergencyDeleteRootBundle(uint256 indexed rootBundleId);



    /**

     * @notice Construct the base SpokePool.

     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.

     * @param _hubPool Hub pool address to set. Can be changed by admin.

     * @param _wrappedNativeTokenAddress wrappedNativeToken address for this network to set.

     * @param timerAddress Timer address to set.

     */

    constructor(

        address _crossDomainAdmin,

        address _hubPool,

        address _wrappedNativeTokenAddress,

        address timerAddress

    ) Testable(timerAddress) {

        _setCrossDomainAdmin(_crossDomainAdmin);

        _setHubPool(_hubPool);

        wrappedNativeToken = WETH9(_wrappedNativeTokenAddress);

    }



    /****************************************

     *               MODIFIERS              *

     ****************************************/



    // Implementing contract needs to override _requireAdminSender() to ensure that admin functions are protected

    // appropriately.

    modifier onlyAdmin() {

        _requireAdminSender();

        _;

    }



    /**************************************

     *          ADMIN FUNCTIONS           *

     **************************************/



    /**

     * @notice Change cross domain admin address. Callable by admin only.

     * @param newCrossDomainAdmin New cross domain admin.

     */

    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyAdmin nonReentrant {

        _setCrossDomainAdmin(newCrossDomainAdmin);

    }



    /**

     * @notice Change L1 hub pool address. Callable by admin only.

     * @param newHubPool New hub pool.

     */

    function setHubPool(address newHubPool) public override onlyAdmin nonReentrant {

        _setHubPool(newHubPool);

    }



    /**

     * @notice Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only.

     * @param originToken Token that depositor can deposit to this contract.

     * @param destinationChainId Chain ID for where depositor wants to receive funds.

     * @param enabled True to enable deposits, False otherwise.

     */

    function setEnableRoute(

        address originToken,

        uint256 destinationChainId,

        bool enabled

    ) public override onlyAdmin nonReentrant {

        enabledDepositRoutes[originToken][destinationChainId] = enabled;

        emit EnabledDepositRoute(originToken, destinationChainId, enabled);

    }



    /**

     * @notice Change allowance for deposit quote time to differ from current block time. Callable by admin only.

     * @param newDepositQuoteTimeBuffer New quote time buffer.

     */

    function setDepositQuoteTimeBuffer(uint32 newDepositQuoteTimeBuffer) public override onlyAdmin nonReentrant {

        depositQuoteTimeBuffer = newDepositQuoteTimeBuffer;

        emit SetDepositQuoteTimeBuffer(newDepositQuoteTimeBuffer);

    }



    /**

     * @notice This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill

     * slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is

     * designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.

     * @param relayerRefundRoot Merkle root containing relayer refund leaves that can be individually executed via

     * executeRelayerRefundLeaf().

     * @param slowRelayRoot Merkle root containing slow relay fulfillment leaves that can be individually executed via

     * executeSlowRelayLeaf().

     */

    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) public override onlyAdmin nonReentrant {

        uint32 rootBundleId = uint32(rootBundles.length);

        RootBundle storage rootBundle = rootBundles.push();

        rootBundle.relayerRefundRoot = relayerRefundRoot;

        rootBundle.slowRelayRoot = slowRelayRoot;

        emit RelayedRootBundle(rootBundleId, relayerRefundRoot, slowRelayRoot);

    }



    /**

     * @notice This method is intended to only be used in emergencies where a bad root bundle has reached the

     * SpokePool.

     * @param rootBundleId Index of the root bundle that needs to be deleted. Note: this is intentionally a uint256

     * to ensure that a small input range doesn't limit which indices this method is able to reach.

     */

    function emergencyDeleteRootBundle(uint256 rootBundleId) public override onlyAdmin nonReentrant {

        delete rootBundles[rootBundleId];

        emit EmergencyDeleteRootBundle(rootBundleId);

    }



    /**************************************

     *         DEPOSITOR FUNCTIONS        *

     **************************************/



    /**

     * @notice Called by user to bridge funds from origin to destination chain. Depositor will effectively lock

     * tokens in this contract and receive a destination token on the destination chain. The origin => destination

     * token mapping is stored on the L1 HubPool.

     * @notice The caller must first approve this contract to spend amount of originToken.

     * @notice The originToken => destinationChainId must be enabled.

     * @notice This method is payable because the caller is able to deposit native token if the originToken is

     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.

     * @param recipient Address to receive funds at on destination chain.

     * @param originToken Token to lock into this contract to initiate deposit.

     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.

     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.

     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.

     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid

     * to LP pool on HubPool.

     */

    function deposit(

        address recipient,

        address originToken,

        uint256 amount,

        uint256 destinationChainId,

        uint64 relayerFeePct,

        uint32 quoteTimestamp

    ) public payable override nonReentrant {

        // Check that deposit route is enabled.

        require(enabledDepositRoutes[originToken][destinationChainId], "Disabled route");



        // We limit the relay fees to prevent the user spending all their funds on fees.

        require(relayerFeePct < 0.5e18, "invalid relayer fee");

        // This function assumes that L2 timing cannot be compared accurately and consistently to L1 timing. Therefore,

        // block.timestamp is different from the L1 EVM's. Therefore, the quoteTimestamp must be within a configurable

        // buffer of this contract's block time to allow for this variance.

        // Note also that quoteTimestamp cannot be less than the buffer otherwise the following arithmetic can result

        // in underflow. This isn't a problem as the deposit will revert, but the error might be unexpected for clients.

        require(

            getCurrentTime() >= quoteTimestamp - depositQuoteTimeBuffer &&

                getCurrentTime() <= quoteTimestamp + depositQuoteTimeBuffer,

            "invalid quote time"

        );

        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the

        // transaction then the user is sending ETH. In this case, the ETH should be deposited to wrappedNativeToken.

        if (originToken == address(wrappedNativeToken) && msg.value > 0) {

            require(msg.value == amount, "msg.value must match amount");

            wrappedNativeToken.deposit{ value: msg.value }();

            // Else, it is a normal ERC20. In this case pull the token from the user's wallet as per normal.

            // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them.

            // In this case the msg.value will be set to 0, indicating a "normal" ERC20 bridging action.

        } else IERC20(originToken).safeTransferFrom(msg.sender, address(this), amount);



        _emitDeposit(

            amount,

            chainId(),

            destinationChainId,

            relayerFeePct,

            numberOfDeposits,

            quoteTimestamp,

            originToken,

            recipient,

            msg.sender

        );



        // Increment count of deposits so that deposit ID for this spoke pool is unique.

        // @dev: Use pre-increment to save gas:

        // i++ --> Load, Store, Add, Store

        // ++i --> Load, Add, Store

        ++numberOfDeposits;

    }



    /**

     * @notice Convenience method that depositor can use to signal to relayer to use updated fee.

     * @notice Relayer should only use events emitted by this function to submit fills with updated fees, otherwise they

     * risk their fills getting disputed for being invalid, for example if the depositor never actually signed the

     * update fee message.

     * @notice This function will revert if the depositor did not sign a message containing the updated fee for the

     * deposit ID stored in this contract. If the deposit ID is for another contract, or the depositor address is

     * incorrect, or the updated fee is incorrect, then the signature will not match and this function will revert.

     * @param depositor Signer of the update fee message who originally submitted the deposit. If the deposit doesn't

     * exist, then the relayer will not be able to fill any relay, so the caller should validate that the depositor

     * did in fact submit a relay.

     * @param newRelayerFeePct New relayer fee that relayers can use.

     * @param depositId Deposit to update fee for that originated in this contract.

     * @param depositorSignature Signed message containing the depositor address, this contract chain ID, the updated

     * relayer fee %, and the deposit ID. This signature is produced by signing a hash of data according to the

     * EIP-1271 standard. See more in the _verifyUpdateRelayerFeeMessage() comments.

     */

    function speedUpDeposit(

        address depositor,

        uint64 newRelayerFeePct,

        uint32 depositId,

        bytes memory depositorSignature

    ) public override nonReentrant {

        require(newRelayerFeePct < 0.5e18, "invalid relayer fee");



        _verifyUpdateRelayerFeeMessage(depositor, chainId(), newRelayerFeePct, depositId, depositorSignature);



        // Assuming the above checks passed, a relayer can take the signature and the updated relayer fee information

        // from the following event to submit a fill with an updated fee %.

        emit RequestedSpeedUpDeposit(newRelayerFeePct, depositId, depositor, depositorSignature);

    }



    /**************************************

     *         RELAYER FUNCTIONS          *

     **************************************/



    /**

     * @notice Called by relayer to fulfill part of a deposit by sending destination tokens to the recipient.

     * Relayer is expected to pass in unique identifying information for deposit that they want to fulfill, and this

     * relay submission will be validated by off-chain data workers who can dispute this relay if any part is invalid.

     * If the relay is valid, then the relayer will be refunded on their desired repayment chain. If relay is invalid,

     * then relayer will not receive any refund.

     * @notice All of the deposit data can be found via on-chain events from the origin SpokePool, except for the

     * realizedLpFeePct which is a function of the HubPool's utilization at the deposit quote time. This fee %

     * is deterministic based on the quote time, so the relayer should just compute it using the canonical algorithm

     * as described in a UMIP linked to the HubPool's identifier.

     * @param depositor Depositor on origin chain who set this chain as the destination chain.

     * @param recipient Specified recipient on this chain.

     * @param destinationToken Token to send to recipient. Should be mapped to the origin token, origin chain ID

     * and this chain ID via a mapping on the HubPool.

     * @param amount Full size of the deposit.

     * @param maxTokensToSend Max amount of tokens to send recipient. If higher than amount, then caller will

     * send recipient the full relay amount.

     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has

     * passed.

     * @param originChainId Chain of SpokePool where deposit originated.

     * @param realizedLpFeePct Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on

     * quote time.

     * @param relayerFeePct Fee % to keep as relayer, specified by depositor.

     * @param depositId Unique deposit ID on origin spoke pool.

     */

    function fillRelay(

        address depositor,

        address recipient,

        address destinationToken,

        uint256 amount,

        uint256 maxTokensToSend,

        uint256 repaymentChainId,

        uint256 originChainId,

        uint64 realizedLpFeePct,

        uint64 relayerFeePct,

        uint32 depositId

    ) public nonReentrant {

        // Each relay attempt is mapped to the hash of data uniquely identifying it, which includes the deposit data

        // such as the origin chain ID and the deposit ID, and the data in a relay attempt such as who the recipient

        // is, which chain and currency the recipient wants to receive funds on, and the relay fees.

        SpokePoolInterface.RelayData memory relayData = SpokePoolInterface.RelayData({

            depositor: depositor,

            recipient: recipient,

            destinationToken: destinationToken,

            amount: amount,

            realizedLpFeePct: realizedLpFeePct,

            relayerFeePct: relayerFeePct,

            depositId: depositId,

            originChainId: originChainId,

            destinationChainId: chainId()

        });

        bytes32 relayHash = _getRelayHash(relayData);



        uint256 fillAmountPreFees = _fillRelay(relayHash, relayData, maxTokensToSend, relayerFeePct, false);



        _emitFillRelay(relayHash, fillAmountPreFees, repaymentChainId, relayerFeePct, relayData, false);

    }



    /**

     * @notice Called by relayer to execute same logic as calling fillRelay except that relayer is using an updated

     * relayer fee %. The fee % must have been emitted in a message cryptographically signed by the depositor.

     * @notice By design, the depositor probably emitted the message with the updated fee by calling speedUpRelay().

     * @param depositor Depositor on origin chain who set this chain as the destination chain.

     * @param recipient Specified recipient on this chain.

     * @param destinationToken Token to send to recipient. Should be mapped to the origin token, origin chain ID

     * and this chain ID via a mapping on the HubPool.

     * @param amount Full size of the deposit.

     * @param maxTokensToSend Max amount of tokens to send recipient. If higher than amount, then caller will

     * send recipient the full relay amount.

     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has

     * passed.

     * @param originChainId Chain of SpokePool where deposit originated.

     * @param realizedLpFeePct Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on

     * quote time.

     * @param relayerFeePct Original fee % to keep as relayer set by depositor.

     * @param newRelayerFeePct New fee % to keep as relayer also specified by depositor.

     * @param depositId Unique deposit ID on origin spoke pool.

     * @param depositorSignature Depositor-signed message containing updated fee %.

     */

    function fillRelayWithUpdatedFee(

        address depositor,

        address recipient,

        address destinationToken,

        uint256 amount,

        uint256 maxTokensToSend,

        uint256 repaymentChainId,

        uint256 originChainId,

        uint64 realizedLpFeePct,

        uint64 relayerFeePct,

        uint64 newRelayerFeePct,

        uint32 depositId,

        bytes memory depositorSignature

    ) public override nonReentrant {

        _verifyUpdateRelayerFeeMessage(depositor, originChainId, newRelayerFeePct, depositId, depositorSignature);



        // Now follow the default fillRelay flow with the updated fee and the original relay hash.

        RelayData memory relayData = RelayData({

            depositor: depositor,

            recipient: recipient,

            destinationToken: destinationToken,

            amount: amount,

            realizedLpFeePct: realizedLpFeePct,

            relayerFeePct: relayerFeePct,

            depositId: depositId,

            originChainId: originChainId,

            destinationChainId: chainId()

        });

        bytes32 relayHash = _getRelayHash(relayData);

        uint256 fillAmountPreFees = _fillRelay(relayHash, relayData, maxTokensToSend, newRelayerFeePct, false);



        _emitFillRelay(relayHash, fillAmountPreFees, repaymentChainId, newRelayerFeePct, relayData, false);

    }



    /**************************************

     *         DATA WORKER FUNCTIONS      *

     **************************************/



    /**

     * @notice Executes a slow relay leaf stored as part of a root bundle. Will send the full amount remaining in the

     * relay to the recipient, less fees.

     * @dev This function assumes that the relay's destination chain ID is the current chain ID, which prevents

     * the caller from executing a slow relay intended for another chain on this chain.

     * @param depositor Depositor on origin chain who set this chain as the destination chain.

     * @param recipient Specified recipient on this chain.

     * @param destinationToken Token to send to recipient. Should be mapped to the origin token, origin chain ID

     * and this chain ID via a mapping on the HubPool.

     * @param amount Full size of the deposit.

     * @param originChainId Chain of SpokePool where deposit originated.

     * @param realizedLpFeePct Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on

     * quote time.

     * @param relayerFeePct Original fee % to keep as relayer set by depositor.

     * @param depositId Unique deposit ID on origin spoke pool.

     * @param rootBundleId Unique ID of root bundle containing slow relay root that this leaf is contained in.

     * @param proof Inclusion proof for this leaf in slow relay root in root bundle.

     */

    function executeSlowRelayLeaf(

        address depositor,

        address recipient,

        address destinationToken,

        uint256 amount,

        uint256 originChainId,

        uint64 realizedLpFeePct,

        uint64 relayerFeePct,

        uint32 depositId,

        uint32 rootBundleId,

        bytes32[] memory proof

    ) public virtual override nonReentrant {

        _executeSlowRelayLeaf(

            depositor,

            recipient,

            destinationToken,

            amount,

            originChainId,

            chainId(),

            realizedLpFeePct,

            relayerFeePct,

            depositId,

            rootBundleId,

            proof

        );

    }



    /**

     * @notice Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they

     * sent to the recipient plus a relayer fee.

     * @param rootBundleId Unique ID of root bundle containing relayer refund root that this leaf is contained in.

     * @param relayerRefundLeaf Contains all data necessary to reconstruct leaf contained in root bundle and to

     * refund relayer. This data structure is explained in detail in the SpokePoolInterface.

     * @param proof Inclusion proof for this leaf in relayer refund root in root bundle.

     */

    function executeRelayerRefundLeaf(

        uint32 rootBundleId,

        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,

        bytes32[] memory proof

    ) public virtual override nonReentrant {

        _executeRelayerRefundLeaf(rootBundleId, relayerRefundLeaf, proof);

    }



    /**************************************

     *           VIEW FUNCTIONS           *

     **************************************/



    /**

     * @notice Returns chain ID for this network.

     * @dev Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.

     */

    function chainId() public view virtual override returns (uint256) {

        return block.chainid;

    }



    /**************************************

     *         INTERNAL FUNCTIONS         *

     **************************************/



    // Verifies inclusion proof of leaf in root, sends relayer their refund, and sends to HubPool any rebalance

    // transfers.

    function _executeRelayerRefundLeaf(

        uint32 rootBundleId,

        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,

        bytes32[] memory proof

    ) internal {

        // Check integrity of leaf structure:

        require(relayerRefundLeaf.chainId == chainId(), "Invalid chainId");

        require(relayerRefundLeaf.refundAddresses.length == relayerRefundLeaf.refundAmounts.length, "invalid leaf");



        RootBundle storage rootBundle = rootBundles[rootBundleId];



        // Check that inclusionProof proves that relayerRefundLeaf is contained within the relayer refund root.

        // Note: This should revert if the relayerRefundRoot is uninitialized.

        require(MerkleLib.verifyRelayerRefund(rootBundle.relayerRefundRoot, relayerRefundLeaf, proof), "Bad Proof");



        // Verify the leafId in the leaf has not yet been claimed.

        require(!MerkleLib.isClaimed(rootBundle.claimedBitmap, relayerRefundLeaf.leafId), "Already claimed");



        // Set leaf as claimed in bitmap. This is passed by reference to the storage rootBundle.

        MerkleLib.setClaimed(rootBundle.claimedBitmap, relayerRefundLeaf.leafId);



        // Send each relayer refund address the associated refundAmount for the L2 token address.

        // Note: Even if the L2 token is not enabled on this spoke pool, we should still refund relayers.

        uint256 length = relayerRefundLeaf.refundAmounts.length;

        for (uint256 i = 0; i < length; ) {

            uint256 amount = relayerRefundLeaf.refundAmounts[i];

            if (amount > 0)

                IERC20(relayerRefundLeaf.l2TokenAddress).safeTransfer(relayerRefundLeaf.refundAddresses[i], amount);



            // OK because we assume refund array length won't be > types(uint256).max.

            // Based on the stress test results in /test/gas-analytics/SpokePool.RelayerRefundLeaf.ts, the UMIP should

            // limit the refund count in valid proposals to be ~800 so any RelayerRefundLeaves with > 800 refunds should

            // not make it to this stage.



            unchecked {

                ++i;

            }

        }



        // If leaf's amountToReturn is positive, then send L2 --> L1 message to bridge tokens back via

        // chain-specific bridging method.

        if (relayerRefundLeaf.amountToReturn > 0) {

            _bridgeTokensToHubPool(relayerRefundLeaf);



            emit TokensBridged(

                relayerRefundLeaf.amountToReturn,

                relayerRefundLeaf.chainId,

                relayerRefundLeaf.leafId,

                relayerRefundLeaf.l2TokenAddress,

                msg.sender

            );

        }



        emit ExecutedRelayerRefundRoot(

            relayerRefundLeaf.amountToReturn,

            relayerRefundLeaf.chainId,

            relayerRefundLeaf.refundAmounts,

            rootBundleId,

            relayerRefundLeaf.leafId,

            relayerRefundLeaf.l2TokenAddress,

            relayerRefundLeaf.refundAddresses,

            msg.sender

        );

    }



    // Verifies inclusion proof of leaf in root and sends recipient remainder of relay. Marks relay as filled.

    function _executeSlowRelayLeaf(

        address depositor,

        address recipient,

        address destinationToken,

        uint256 amount,

        uint256 originChainId,

        uint256 destinationChainId,

        uint64 realizedLpFeePct,

        uint64 relayerFeePct,

        uint32 depositId,

        uint32 rootBundleId,

        bytes32[] memory proof

    ) internal {

        RelayData memory relayData = RelayData({

            depositor: depositor,

            recipient: recipient,

            destinationToken: destinationToken,

            amount: amount,

            originChainId: originChainId,

            destinationChainId: destinationChainId,

            realizedLpFeePct: realizedLpFeePct,

            relayerFeePct: relayerFeePct,

            depositId: depositId

        });



        require(

            MerkleLib.verifySlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, relayData, proof),

            "Invalid proof"

        );



        bytes32 relayHash = _getRelayHash(relayData);



        // Note: use relayAmount as the max amount to send, so the relay is always completely filled by the contract's

        // funds in all cases. As this is a slow relay we set the relayerFeePct to 0. This effectively refunds the

        // relayer component of the relayerFee thereby only charging the depositor the LpFee.

        uint256 fillAmountPreFees = _fillRelay(relayHash, relayData, relayData.amount, 0, true);



        // Note: Set repayment chain ID to 0 to indicate that there is no repayment to be made. The off-chain data

        // worker can use repaymentChainId=0 as a signal to ignore such relays for refunds. Also, set the relayerFeePct

        // to 0 as slow relays do not pay the caller of this method (depositor is refunded this fee).

        _emitFillRelay(relayHash, fillAmountPreFees, 0, 0, relayData, true);

    }



    function _setCrossDomainAdmin(address newCrossDomainAdmin) internal {

        require(newCrossDomainAdmin != address(0), "Bad bridge router address");

        crossDomainAdmin = newCrossDomainAdmin;

        emit SetXDomainAdmin(newCrossDomainAdmin);

    }



    function _setHubPool(address newHubPool) internal {

        require(newHubPool != address(0), "Bad hub pool address");

        hubPool = newHubPool;

        emit SetHubPool(newHubPool);

    }



    // Should be overriden by implementing contract depending on how L2 handles sending tokens to L1.

    function _bridgeTokensToHubPool(SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf) internal virtual;



    function _verifyUpdateRelayerFeeMessage(

        address depositor,

        uint256 originChainId,

        uint64 newRelayerFeePct,

        uint32 depositId,

        bytes memory depositorSignature

    ) internal view {

        // A depositor can request to speed up an un-relayed deposit by signing a hash containing the relayer

        // fee % to update to and information uniquely identifying the deposit to relay. This information ensures

        // that this signature cannot be re-used for other deposits. The version string is included as a precaution

        // in case this contract is upgraded.

        // Note: we use encode instead of encodePacked because it is more secure, more in the "warning" section

        // here: https://docs.soliditylang.org/en/v0.8.11/abi-spec.html#non-standard-packed-mode

        bytes32 expectedDepositorMessageHash = keccak256(

            abi.encode("ACROSS-V2-FEE-1.0", newRelayerFeePct, depositId, originChainId)

        );



        // Check the hash corresponding to the https://eth.wiki/json-rpc/API#eth_sign[eth_sign]

        // If the depositor signed a message with a different updated fee (or any other param included in the

        // above keccak156 hash), then this will revert.

        bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(expectedDepositorMessageHash);



        _verifyDepositorUpdateFeeMessage(depositor, ethSignedMessageHash, depositorSignature);

    }



    // This function is isolated and made virtual to allow different L2's to implement chain specific recovery of

    // signers from signatures because some L2s might not support ecrecover. To be safe, consider always reverting

    // this function for L2s where ecrecover is different from how it works on Ethereum, otherwise there is the

    // potential to forge a signature from the depositor using a different private key than the original depositor's.

    function _verifyDepositorUpdateFeeMessage(

        address depositor,

        bytes32 ethSignedMessageHash,

        bytes memory depositorSignature

    ) internal view virtual {

        // Note: We purposefully do not support EIP-1271 signatures (meaning that multisigs and smart contract wallets

        // like Argent are not supported) because of the possibility that a multisig that signed a message on the origin

        // chain does not have a parallel on this destination chain.

        require(depositor == ECDSA.recover(ethSignedMessageHash, depositorSignature), "invalid signature");

    }



    function _computeAmountPreFees(uint256 amount, uint64 feesPct) private pure returns (uint256) {

        return (1e18 * amount) / (1e18 - feesPct);

    }



    function _computeAmountPostFees(uint256 amount, uint64 feesPct) private pure returns (uint256) {

        return (amount * (1e18 - feesPct)) / 1e18;

    }



    function _getRelayHash(SpokePoolInterface.RelayData memory relayData) private pure returns (bytes32) {

        return keccak256(abi.encode(relayData));

    }



    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends wrappedNativeToken.

    function _unwrapwrappedNativeTokenTo(address payable to, uint256 amount) internal {

        if (address(to).isContract()) {

            IERC20(address(wrappedNativeToken)).safeTransfer(to, amount);

        } else {

            wrappedNativeToken.withdraw(amount);

            to.transfer(amount);

        }

    }



    /**

     * @notice Caller specifies the max amount of tokens to send to user. Based on this amount and the amount of the

     * relay remaining (as stored in the relayFills mapping), pull the amount of tokens from the caller

     * and send to the recipient.

     * @dev relayFills keeps track of pre-fee fill amounts as a convenience to relayers who want to specify round

     * numbers for the maxTokensToSend parameter or convenient numbers like 100 (i.e. relayers who will fully

     * fill any relay up to 100 tokens, and partial fill with 100 tokens for larger relays).

     * @dev Caller must approve this contract to transfer up to maxTokensToSend of the relayData.destinationToken.

     * The amount to be sent might end up less if there is insufficient relay amount remaining to be sent.

     */

    function _fillRelay(

        bytes32 relayHash,

        RelayData memory relayData,

        uint256 maxTokensToSend,

        uint64 updatableRelayerFeePct,

        bool useContractFunds

    ) internal returns (uint256 fillAmountPreFees) {

        // We limit the relay fees to prevent the user spending all their funds on fees. Note that 0.5e18 (i.e. 50%)

        // fees are just magic numbers. The important point is to prevent the total fee from being 100%, otherwise

        // computing the amount pre fees runs into divide-by-0 issues.

        require(updatableRelayerFeePct < 0.5e18 && relayData.realizedLpFeePct < 0.5e18, "invalid fees");



        // Check that the relay has not already been completely filled. Note that the relays mapping will point to

        // the amount filled so far for a particular relayHash, so this will start at 0 and increment with each fill.

        require(relayFills[relayHash] < relayData.amount, "relay filled");



        // Stores the equivalent amount to be sent by the relayer before fees have been taken out.

        if (maxTokensToSend == 0) return 0;



        // Derive the amount of the relay filled if the caller wants to send exactly maxTokensToSend tokens to

        // the recipient. For example, if the user wants to send 10 tokens to the recipient, the full relay amount

        // is 100, and the fee %'s total 5%, then this computation would return ~10.5, meaning that to fill 10.5/100

        // of the full relay size, the caller would need to send 10 tokens to the user.

        fillAmountPreFees = _computeAmountPreFees(

            maxTokensToSend,

            (relayData.realizedLpFeePct + updatableRelayerFeePct)

        );

        // If user's specified max amount to send is greater than the amount of the relay remaining pre-fees,

        // we'll pull exactly enough tokens to complete the relay.

        uint256 amountToSend = maxTokensToSend;

        uint256 amountRemainingInRelay = relayData.amount - relayFills[relayHash];

        if (amountRemainingInRelay < fillAmountPreFees) {

            fillAmountPreFees = amountRemainingInRelay;



            // The user will fulfill the remainder of the relay, so we need to compute exactly how many tokens post-fees

            // that they need to send to the recipient. Note that if the relayer is filled using contract funds then

            // this is a slow relay.

            amountToSend = _computeAmountPostFees(

                fillAmountPreFees,

                relayData.realizedLpFeePct + updatableRelayerFeePct

            );

        }



        // relayFills keeps track of pre-fee fill amounts as a convenience to relayers who want to specify round

        // numbers for the maxTokensToSend parameter or convenient numbers like 100 (i.e. relayers who will fully

        // fill any relay up to 100 tokens, and partial fill with 100 tokens for larger relays).

        relayFills[relayHash] += fillAmountPreFees;



        // If relay token is wrappedNativeToken then unwrap and send native token.

        if (relayData.destinationToken == address(wrappedNativeToken)) {

            // Note: useContractFunds is True if we want to send funds to the recipient directly out of this contract,

            // otherwise we expect the caller to send funds to the recipient. If useContractFunds is True and the

            // recipient wants wrappedNativeToken, then we can assume that wrappedNativeToken is already in the

            // contract, otherwise we'll need the user to send wrappedNativeToken to this contract. Regardless, we'll

            // need to unwrap it to native token before sending to the user.

            if (!useContractFunds)

                IERC20(relayData.destinationToken).safeTransferFrom(msg.sender, address(this), amountToSend);

            _unwrapwrappedNativeTokenTo(payable(relayData.recipient), amountToSend);

            // Else, this is a normal ERC20 token. Send to recipient.

        } else {

            // Note: Similar to note above, send token directly from the contract to the user in the slow relay case.

            if (!useContractFunds)

                IERC20(relayData.destinationToken).safeTransferFrom(msg.sender, relayData.recipient, amountToSend);

            else IERC20(relayData.destinationToken).safeTransfer(relayData.recipient, amountToSend);

        }

    }



    // The following internal methods emit events with many params to overcome solidity stack too deep issues.

    function _emitFillRelay(

        bytes32 relayHash,

        uint256 fillAmount,

        uint256 repaymentChainId,

        uint64 appliedRelayerFeePct,

        RelayData memory relayData,

        bool isSlowRelay

    ) internal {

        emit FilledRelay(

            relayData.amount,

            relayFills[relayHash],

            fillAmount,

            repaymentChainId,

            relayData.originChainId,

            relayData.destinationChainId,

            relayData.relayerFeePct,

            appliedRelayerFeePct,

            relayData.realizedLpFeePct,

            relayData.depositId,

            relayData.destinationToken,

            msg.sender,

            relayData.depositor,

            relayData.recipient,

            isSlowRelay

        );

    }



    function _emitDeposit(

        uint256 amount,

        uint256 originChainId,

        uint256 destinationChainId,

        uint64 relayerFeePct,

        uint32 depositId,

        uint32 quoteTimestamp,

        address originToken,

        address recipient,

        address depositor

    ) internal {

        emit FundsDeposited(

            amount,

            originChainId,

            destinationChainId,

            relayerFeePct,

            depositId,

            quoteTimestamp,

            originToken,

            recipient,

            depositor

        );

    }



    // Implementing contract needs to override this to ensure that only the appropriate cross chain admin can execute

    // certain admin functions. For L2 contracts, the cross chain admin refers to some L1 address or contract, and for

    // L1, this would just be the same admin of the HubPool.

    function _requireAdminSender() internal virtual;



    // Added to enable the this contract to receive native token (ETH). Used when unwrapping wrappedNativeToken.

    receive() external payable {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\SpokePoolInterface.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



/**

 * @notice Contains common data structures and functions used by all SpokePool implementations.

 */

interface SpokePoolInterface {

    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.

    struct RelayerRefundLeaf {

        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that

        // is negative. This is just the negative of this value.

        uint256 amountToReturn;

        // Used to verify that this is being executed on the correct destination chainId.

        uint256 chainId;

        // This array designates how much each of those addresses should be refunded.

        uint256[] refundAmounts;

        // Used as the index in the bitmap to track whether this leaf has been executed or not.

        uint32 leafId;

        // The associated L2TokenAddress that these claims apply to.

        address l2TokenAddress;

        // Must be same length as refundAmounts and designates each address that must be refunded.

        address[] refundAddresses;

    }



    // This struct represents the data to fully specify a relay. If any portion of this data differs, the relay is

    // considered to be completely distinct. Only one relay for a particular depositId, chainId pair should be

    // considered valid and repaid. This data is hashed and inserted into the slow relay merkle root so that an off

    // chain validator can choose when to refund slow relayers.

    struct RelayData {

        // The address that made the deposit on the origin chain.

        address depositor;

        // The recipient address on the destination chain.

        address recipient;

        // The corresponding token address on the destination chain.

        address destinationToken;

        // The total relay amount before fees are taken out.

        uint256 amount;

        // Origin chain id.

        uint256 originChainId;

        // Destination chain id.

        uint256 destinationChainId;

        // The LP Fee percentage computed by the relayer based on the deposit's quote timestamp

        // and the HubPool's utilization.

        uint64 realizedLpFeePct;

        // The relayer fee percentage specified in the deposit.

        uint64 relayerFeePct;

        // The id uniquely identifying this deposit on the origin chain.

        uint32 depositId;

    }



    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced

    // by "data workers" via inclusion proofs to execute leaves in the roots.

    struct RootBundle {

        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.

        bytes32 slowRelayRoot;

        // Merkle root of relayer refunds for successful relays.

        bytes32 relayerRefundRoot;

        // This is a 2D bitmap tracking which leaves in the relayer refund root have been claimed, with max size of

        // 256x(2^248) leaves per root.

        mapping(uint256 => uint256) claimedBitmap;

    }



    function setCrossDomainAdmin(address newCrossDomainAdmin) external;



    function setHubPool(address newHubPool) external;



    function setEnableRoute(

        address originToken,

        uint256 destinationChainId,

        bool enable

    ) external;



    function setDepositQuoteTimeBuffer(uint32 buffer) external;



    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;



    function emergencyDeleteRootBundle(uint256 rootBundleId) external;



    function deposit(

        address recipient,

        address originToken,

        uint256 amount,

        uint256 destinationChainId,

        uint64 relayerFeePct,

        uint32 quoteTimestamp

    ) external payable;



    function speedUpDeposit(

        address depositor,

        uint64 newRelayerFeePct,

        uint32 depositId,

        bytes memory depositorSignature

    ) external;



    function fillRelay(

        address depositor,

        address recipient,

        address destinationToken,

        uint256 amount,

        uint256 maxTokensToSend,

        uint256 repaymentChainId,

        uint256 originChainId,

        uint64 realizedLpFeePct,

        uint64 relayerFeePct,

        uint32 depositId

    ) external;



    function fillRelayWithUpdatedFee(

        address depositor,

        address recipient,

        address destinationToken,

        uint256 amount,

        uint256 maxTokensToSend,

        uint256 repaymentChainId,

        uint256 originChainId,

        uint64 realizedLpFeePct,

        uint64 relayerFeePct,

        uint64 newRelayerFeePct,

        uint32 depositId,

        bytes memory depositorSignature

    ) external;



    function executeSlowRelayLeaf(

        address depositor,

        address recipient,

        address destinationToken,

        uint256 amount,

        uint256 originChainId,

        uint64 realizedLpFeePct,

        uint64 relayerFeePct,

        uint32 depositId,

        uint32 rootBundleId,

        bytes32[] memory proof

    ) external;



    function executeRelayerRefundLeaf(

        uint32 rootBundleId,

        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,

        bytes32[] memory proof

    ) external;



    function chainId() external view returns (uint256);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\StoreInterface.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "../../common/implementation/FixedPoint.sol";



/**

 * @title Interface that allows financial contracts to pay oracle fees for their use of the system.

 */

interface StoreInterface {

    /**

     * @notice Pays Oracle fees in ETH to the store.

     * @dev To be used by contracts whose margin currency is ETH.

     */

    function payOracleFees() external payable;



    /**

     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.

     * @dev To be used if the margin currency is an ERC20 token rather than ETH.

     * @param erc20Address address of the ERC20 token used to pay the fee.

     * @param amount number of tokens to transfer. An approval for at least this amount must exist.

     */

    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;



    /**

     * @notice Computes the regular oracle fees that a contract should pay for a period.

     * @param startTime defines the beginning time from which the fee is paid.

     * @param endTime end time until which the fee is paid.

     * @param pfc "profit from corruption", or the maximum amount of margin currency that a

     * token sponsor could extract from the contract through corrupting the price feed in their favor.

     * @return regularFee amount owed for the duration from start to end time for the given pfc.

     * @return latePenalty for paying the fee after the deadline.

     */

    function computeRegularFee(

        uint256 startTime,

        uint256 endTime,

        FixedPoint.Unsigned calldata pfc

    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);



    /**

     * @notice Computes the final oracle fees that a contract should pay at settlement.

     * @param currency token used to pay the final fee.

     * @return finalFee amount due.

     */

    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Strings.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)



pragma solidity ^0.8.0;



/**

 * @dev String operations.

 */

library Strings {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Testable.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



import "./Timer.sol";



/**

 * @title Base class that provides time overrides, but only if being run in test mode.

 */

abstract contract Testable {

    // If the contract is being run in production, then `timerAddress` will be the 0x0 address.

    // Note: this variable should be set on construction and never modified.

    address public timerAddress;



    /**

     * @notice Constructs the Testable contract. Called by child contracts.

     * @param _timerAddress Contract that stores the current time in a testing environment.

     * Must be set to 0x0 for production environments that use live time.

     */

    constructor(address _timerAddress) {

        timerAddress = _timerAddress;

    }



    /**

     * @notice Reverts if not running in test mode.

     */

    modifier onlyIfTest {

        require(timerAddress != address(0x0));

        _;

    }



    /**

     * @notice Sets the current time.

     * @dev Will revert if not running in test mode.

     * @param time timestamp to set current Testable time to.

     */

    function setCurrentTime(uint256 time) external onlyIfTest {

        Timer(timerAddress).setCurrentTime(time);

    }



    /**

     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.

     * Otherwise, it will return the block timestamp.

     * @return uint for the current Testable timestamp.

     */

    function getCurrentTime() public view virtual returns (uint256) {

        if (timerAddress != address(0x0)) {

            return Timer(timerAddress).getCurrentTime();

        } else {

            return block.timestamp; // solhint-disable-line not-rely-on-time

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\Timer.sol
File type: .sol
// SPDX-License-Identifier: AGPL-3.0-only

pragma solidity ^0.8.0;



/**

 * @title Universal store of current contract time for testing environments.

 */

contract Timer {

    uint256 private currentTime;



    constructor() {

        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time

    }



    /**

     * @notice Sets the current time.

     * @dev Will revert if not running in test mode.

     * @param time timestamp to set `currentTime` to.

     */

    function setCurrentTime(uint256 time) external {

        currentTime = time;

    }



    /**

     * @notice Gets the currentTime variable set in the Timer.

     * @return uint256 for the current Testable timestamp.

     */

    function getCurrentTime() public view returns (uint256) {

        return currentTime;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges\dedup_non_vul_bridges_output_aliyun_718\Across Bridge\contracts\WETH9.sol
File type: .sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.0;



interface WETH9 {

    function withdraw(uint256 wad) external;



    function deposit() external payable;



    function balanceOf(address guy) external view returns (uint256 wad);



    function transfer(address guy, uint256 wad) external;

}

--------------------------------------------------
File End
--------------------------------------------------

Folder Structure
--------------------------------------------------
contracts/
    AdditionalZkSync.sol
    Address.sol
    AddressAliasHelper.sol
    AddressUpgradeable.sol
    AllowList.sol
    AllowListed.sol
    Base.sol
    BridgeInitializationHelper.sol
    Bytes.sol
    Config.sol
    Constants.sol
    Context.sol
    ContextUpgradeable.sol
    DefaultOperatorFiltererUpgradeable.sol
    Diamond.sol
    DiamondCut.sol
    DiamondInit.sol
    DiamondProxy.sol
    DiamondUpgradeInit5.sol
    draft-IERC1822.sol
    draft-IERC20Permit.sol
    ECDSAUpgradeable.sol
    ERC1155BurnableUpgradeable.sol
    ERC1155SupplyUpgradeable.sol
    ERC1155Upgradeable.sol
    ERC165Upgradeable.sol
    ERC1967Proxy.sol
    ERC1967Upgrade.sol
    ERC2981Upgradeable.sol
    Events.sol
    Executor.sol
    Getters.sol
    Governance.sol
    IAllowList.sol
    IBeacon.sol
    IDiamondCut.sol
    IERC1155MetadataURIUpgradeable.sol
    IERC1155ReceiverUpgradeable.sol
    IERC1155Upgradeable.sol
    IERC165Upgradeable.sol
    IERC20.sol
    IERC20Metadata.sol
    IERC2981Upgradeable.sol
    IExecutor.sol
    IGetters.sol
    IGovernance.sol
    IL1Bridge.sol
    IL1BridgeLegacy.sol
    IL2Bridge.sol
    IL2ContractDeployer.sol
    IL2ERC20Bridge.sol
    IMailbox.sol
    Initializable.sol
    IOperatorFilterRegistry.sol
    ITrustedTransfarableERC20.sol
    IZkSync.sol
    KeysWithPlonkVerifier.sol
    L1ERC20Bridge.sol
    L2ContractAddresses.sol
    L2ContractHelper.sol
    Mailbox.sol
    Math.sol
    MathUpgradeable.sol
    Merkle.sol
    NFTFactory.sol
    Operations.sol
    OperatorFiltererUpgradeable.sol
    Ownable.sol
    Ownable2Step.sol
    OwnableUpgradeable.sol
    PairingsBn254.sol
    PausableUpgradeable.sol
    Plonk4VerifierWithAccessToDNext.sol
    PlonkCore.sol
    PriorityQueue.sol
    Proxy.sol
    ProxyAdmin.sol
    ReentrancyGuard.sol
    ReentrancyGuardUpgradeable.sol
    SafeCast.sol
    SafeERC20.sol
    SafeMath.sol
    SafeMathUInt128.sol
    Storage.sol
    StorageSlot.sol
    StringsUpgradeable.sol
    TokenGovernance.sol
    TranscriptLib.sol
    TransparentUpgradeableProxy.sol
    UncheckedMath.sol
    UnsafeBytes.sol
    Upgradeable.sol
    UpgradeableMaster.sol
    Utils.sol
    Verifier.sol
    WagmiTraitsUpgradable.sol
    ZkSync.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\AdditionalZkSync.sol
File type: .sol
pragma solidity ^0.7.0;

pragma experimental ABIEncoderV2;



// SPDX-License-Identifier: MIT OR Apache-2.0











import "./ReentrancyGuard.sol";

import "./SafeMath.sol";

import "./SafeMathUInt128.sol";

import "./SafeCast.sol";

import "./Utils.sol";



import "./Storage.sol";

import "./Config.sol";

import "./Events.sol";



import "./Bytes.sol";

import "./Operations.sol";



import "./UpgradeableMaster.sol";



/// @title zkSync additional main contract

/// @author Matter Labs

contract AdditionalZkSync is Storage, Config, Events, ReentrancyGuard {

    using SafeMath for uint256;

    using SafeMathUInt128 for uint128;



    function increaseBalanceToWithdraw(bytes22 _packedBalanceKey, uint128 _amount) internal {

        uint128 balance = pendingBalances[_packedBalanceKey].balanceToWithdraw;

        pendingBalances[_packedBalanceKey] = PendingBalance(balance.add(_amount), FILLED_GAS_RESERVE_VALUE);

    }



    /// @notice Withdraws token from ZkSync to root chain in case of exodus mode. User must provide proof that he owns funds

    /// @param _storedBlockInfo Last verified block

    /// @param _owner Owner of the account

    /// @param _accountId Id of the account in the tree

    /// @param _proof Proof

    /// @param _tokenId Verified token id

    /// @param _amount Amount for owner (must be total amount, not part of it)

    function performExodus(

        StoredBlockInfo memory _storedBlockInfo,

        address _owner,

        uint32 _accountId,

        uint32 _tokenId,

        uint128 _amount,

        uint32 _nftCreatorAccountId,

        address _nftCreatorAddress,

        uint32 _nftSerialId,

        bytes32 _nftContentHash,

        uint256[] calldata _proof

    ) external {

        require(_accountId <= MAX_ACCOUNT_ID, "e");

        require(_accountId != SPECIAL_ACCOUNT_ID, "v");

        require(_tokenId < SPECIAL_NFT_TOKEN_ID, "T");



        require(exodusMode, "s"); // must be in exodus mode

        require(!performedExodus[_accountId][_tokenId], "t"); // already exited

        require(storedBlockHashes[totalBlocksExecuted] == hashStoredBlockInfo(_storedBlockInfo), "u"); // incorrect stored block info



        bool proofCorrect = verifier.verifyExitProof(

            _storedBlockInfo.stateHash,

            _accountId,

            _owner,

            _tokenId,

            _amount,

            _nftCreatorAccountId,

            _nftCreatorAddress,

            _nftSerialId,

            _nftContentHash,

            _proof

        );

        require(proofCorrect, "x");



        if (_tokenId <= MAX_FUNGIBLE_TOKEN_ID) {

            bytes22 packedBalanceKey = packAddressAndTokenId(_owner, uint16(_tokenId));

            increaseBalanceToWithdraw(packedBalanceKey, _amount);

            emit WithdrawalPending(uint16(_tokenId), _owner, _amount);

        } else {

            require(_amount != 0, "Z"); // Unsupported nft amount

            Operations.WithdrawNFT memory withdrawNftOp = Operations.WithdrawNFT(

                _nftCreatorAccountId,

                _nftCreatorAddress,

                _nftSerialId,

                _nftContentHash,

                _owner,

                _tokenId

            );

            pendingWithdrawnNFTs[_tokenId] = withdrawNftOp;

            emit WithdrawalNFTPending(_tokenId);

        }

        performedExodus[_accountId][_tokenId] = true;

    }



    function cancelOutstandingDepositsForExodusMode(uint64 _n, bytes[] calldata _depositsPubdata) external {

        require(exodusMode, "8"); // exodus mode not active

        uint64 toProcess = Utils.minU64(totalOpenPriorityRequests, _n);

        require(toProcess > 0, "9"); // no deposits to process

        uint64 currentDepositIdx = 0;

        for (uint64 id = firstPriorityRequestId; id < firstPriorityRequestId + toProcess; ++id) {

            if (priorityRequests[id].opType == Operations.OpType.Deposit) {

                bytes memory depositPubdata = _depositsPubdata[currentDepositIdx];

                require(Utils.hashBytesToBytes20(depositPubdata) == priorityRequests[id].hashedPubData, "a");

                ++currentDepositIdx;



                Operations.Deposit memory op = Operations.readDepositPubdata(depositPubdata);

                bytes22 packedBalanceKey = packAddressAndTokenId(op.owner, uint16(op.tokenId));

                pendingBalances[packedBalanceKey].balanceToWithdraw += op.amount;

            }

            delete priorityRequests[id];

        }

        firstPriorityRequestId += toProcess;

        totalOpenPriorityRequests -= toProcess;

    }



    uint256 internal constant SECURITY_COUNCIL_THRESHOLD = 9;



    /// @notice processing new approval of decrease upgrade notice period time to zero

    /// @param addr address of the account that approved the reduction of the upgrade notice period to zero

    /// NOTE: does NOT revert if the address is not a security council member or number of approvals is already sufficient

    function approveCutUpgradeNoticePeriod(address addr) internal {

        address payable[SECURITY_COUNCIL_MEMBERS_NUMBER] memory SECURITY_COUNCIL_MEMBERS = [

            0xa2602ea835E03fb39CeD30B43d6b6EAf6aDe1769,0x9D5d6D4BaCCEDf6ECE1883456AA785dc996df607,0x002A5dc50bbB8d5808e418Aeeb9F060a2Ca17346,0x71E805aB236c945165b9Cd0bf95B9f2F0A0488c3,0x76C6cE74EAb57254E785d1DcC3f812D274bCcB11,0xFBfF3FF69D65A9103Bf4fdBf988f5271D12B3190,0xAfC2F2D803479A2AF3A72022D54cc0901a0ec0d6,0x4d1E3089042Ab3A93E03CA88B566b99Bd22438C6,0x19eD6cc20D44e5cF4Bb4894F50162F72402d8567,0x39415255619783A2E71fcF7d8f708A951d92e1b6,0x399a6a13D298CF3F41a562966C1a450136Ea52C2,0xee8AE1F1B4B1E1956C8Bda27eeBCE54Cf0bb5eaB,0xe7CCD4F3feA7df88Cf9B59B30f738ec1E049231f,0xA093284c707e207C36E3FEf9e0B6325fd9d0e33B,0x225d3822De44E58eE935440E0c0B829C4232086e

        ];

        for (uint256 id = 0; id < SECURITY_COUNCIL_MEMBERS_NUMBER; ++id) {

            if (SECURITY_COUNCIL_MEMBERS[id] == addr) {

                // approve cut upgrade notice period if needed

                if (!securityCouncilApproves[id]) {

                    securityCouncilApproves[id] = true;

                    numberOfApprovalsFromSecurityCouncil += 1;

                    emit ApproveCutUpgradeNoticePeriod(addr);



                    if (numberOfApprovalsFromSecurityCouncil >= SECURITY_COUNCIL_THRESHOLD) {

                        if (approvedUpgradeNoticePeriod > 0) {

                            approvedUpgradeNoticePeriod = 0;

                            emit NoticePeriodChange(approvedUpgradeNoticePeriod);

                        }

                    }

                }



                break;

            }

        }

    }



    /// @notice approve to decrease upgrade notice period time to zero

    /// NOTE: ¡ì?an only be called after the start of the upgrade

    function cutUpgradeNoticePeriod(bytes32 targetsHash) external {

        require(upgradeStartTimestamp != 0, "p1");

        require(getUpgradeTargetsHash() == targetsHash, "p3"); // given targets are not in the active upgrade



        approveCutUpgradeNoticePeriod(msg.sender);

    }



    /// @notice approve to decrease upgrade notice period time to zero by signatures

    /// NOTE: Can accept many signatures at a time, thus it is possible

    /// to completely cut the upgrade notice period in one transaction

    function cutUpgradeNoticePeriodBySignature(bytes[] calldata signatures) external {

        require(upgradeStartTimestamp != 0, "p2");



        bytes32 targetsHash = getUpgradeTargetsHash();

        // The Message includes a hash of the addresses of the contracts to which the upgrade will take place to prevent reuse signature.

        bytes32 messageHash = keccak256(

            abi.encodePacked(

                "\x19Ethereum Signed Message:\n110",

                "Approved new ZkSync's target contracts hash\n0x",

                Bytes.bytesToHexASCIIBytes(abi.encodePacked(targetsHash))

            )

        );



        for (uint256 i = 0; i < signatures.length; ++i) {

            address recoveredAddress = Utils.recoverAddressFromEthSignature(signatures[i], messageHash);

            approveCutUpgradeNoticePeriod(recoveredAddress);

        }

    }



    /// @return hash of the concatenation of targets for which there is an upgrade

    /// NOTE: revert if upgrade is not active at this moment

    function getUpgradeTargetsHash() internal returns (bytes32) {

        // Get the addresses of contracts that are being prepared for the upgrade.

        address gatekeeper = 0x38A43F4330f24fe920F943409709fc9A6084C939;

        (bool success0, bytes memory newTarget0) = gatekeeper.staticcall(

            abi.encodeWithSignature("nextTargets(uint256)", 0)

        );

        (bool success1, bytes memory newTarget1) = gatekeeper.staticcall(

            abi.encodeWithSignature("nextTargets(uint256)", 1)

        );

        (bool success2, bytes memory newTarget2) = gatekeeper.staticcall(

            abi.encodeWithSignature("nextTargets(uint256)", 2)

        );



        require(success0 && success1 && success2, "p5"); // failed to get new targets

        address newTargetAddress0 = abi.decode(newTarget0, (address));

        address newTargetAddress1 = abi.decode(newTarget1, (address));

        address newTargetAddress2 = abi.decode(newTarget2, (address));



        return keccak256(abi.encodePacked(newTargetAddress0, newTargetAddress1, newTargetAddress2));

    }



    /// @notice Set data for changing pubkey hash using onchain authorization.

    ///         Transaction author (msg.sender) should be L2 account address

    /// @notice New pubkey hash can be reset, to do that user should send two transactions:

    ///         1) First `setAuthPubkeyHash` transaction for already used `_nonce` will set timer.

    ///         2) After `AUTH_FACT_RESET_TIMELOCK` time is passed second `setAuthPubkeyHash` transaction will reset pubkey hash for `_nonce`.

    /// @param _pubkeyHash New pubkey hash

    /// @param _nonce Nonce of the change pubkey L2 transaction

    function setAuthPubkeyHash(bytes calldata _pubkeyHash, uint32 _nonce) external {

        requireActive();



        require(_pubkeyHash.length == PUBKEY_HASH_BYTES, "y"); // PubKeyHash should be 20 bytes.

        if (authFacts[msg.sender][_nonce] == bytes32(0)) {

            authFacts[msg.sender][_nonce] = keccak256(_pubkeyHash);

        } else {

            uint256 currentResetTimer = authFactsResetTimer[msg.sender][_nonce];

            if (currentResetTimer == 0) {

                authFactsResetTimer[msg.sender][_nonce] = block.timestamp;

            } else {

                require(block.timestamp.sub(currentResetTimer) >= AUTH_FACT_RESET_TIMELOCK, "z");

                authFactsResetTimer[msg.sender][_nonce] = 0;

                authFacts[msg.sender][_nonce] = keccak256(_pubkeyHash);

            }

        }

    }



    /// @notice Reverts unverified blocks

    function revertBlocks(StoredBlockInfo[] calldata _blocksToRevert) external {

        requireActive();



        governance.requireActiveValidator(msg.sender);



        uint32 blocksCommitted = totalBlocksCommitted;

        uint32 blocksToRevert = Utils.minU32(uint32(_blocksToRevert.length), blocksCommitted - totalBlocksExecuted);

        uint64 revertedPriorityRequests = 0;



        for (uint32 i = 0; i < blocksToRevert; ++i) {

            StoredBlockInfo memory storedBlockInfo = _blocksToRevert[i];

            require(storedBlockHashes[blocksCommitted] == hashStoredBlockInfo(storedBlockInfo), "r"); // incorrect stored block info



            delete storedBlockHashes[blocksCommitted];



            --blocksCommitted;

            revertedPriorityRequests += storedBlockInfo.priorityOperations;

        }



        totalBlocksCommitted = blocksCommitted;

        totalCommittedPriorityRequests -= revertedPriorityRequests;

        if (totalBlocksCommitted < totalBlocksProven) {

            totalBlocksProven = totalBlocksCommitted;

        }



        emit BlocksRevert(totalBlocksExecuted, blocksCommitted);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)



pragma solidity ^0.8.1;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     *

     * [IMPORTANT]

     * ====

     * You shouldn't rely on `isContract` to protect against flash loan attacks!

     *

     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets

     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract

     * constructor.

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize/address.code.length, which returns 0

        // for contracts in construction, since the code is only stored at the end

        // of the constructor execution.



        return account.code.length > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResultFromTarget(target, success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResultFromTarget(target, success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResultFromTarget(target, success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling

     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.

     *

     * _Available since v4.8._

     */

    function verifyCallResultFromTarget(

        address target,

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        if (success) {

            if (returndata.length == 0) {

                // only check isContract if the call was successful and the return data is empty

                // otherwise we already know that it was a contract

                require(isContract(target), "Address: call to non-contract");

            }

            return returndata;

        } else {

            _revert(returndata, errorMessage);

        }

    }



    /**

     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason or using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            _revert(returndata, errorMessage);

        }

    }



    function _revert(bytes memory returndata, string memory errorMessage) private pure {

        // Look for revert reason and bubble it up if present

        if (returndata.length > 0) {

            // The easiest way to bubble the revert reason is using memory via assembly

            /// @solidity memory-safe-assembly

            assembly {

                let returndata_size := mload(returndata)

                revert(add(32, returndata), returndata_size)

            }

        } else {

            revert(errorMessage);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\AddressAliasHelper.sol
File type: .sol
pragma solidity ^0.8.0;



// SPDX-License-Identifier: Apache-2.0



/*

 * Copyright 2019-2021, Offchain Labs, Inc.

 *

 * Licensed under the Apache License, Version 2.0 (the "License");

 * you may not use this file except in compliance with the License.

 * You may obtain a copy of the License at

 *

 *    http://www.apache.org/licenses/LICENSE-2.0

 *

 * Unless required by applicable law or agreed to in writing, software

 * distributed under the License is distributed on an "AS IS" BASIS,

 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

 * See the License for the specific language governing permissions and

 * limitations under the License.

 */







library AddressAliasHelper {

    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);



    /// @notice Utility function converts the address that submitted a tx

    /// to the inbox on L1 to the msg.sender viewed on L2

    /// @param l1Address the address in the L1 that triggered the tx to L2

    /// @return l2Address L2 address as viewed in msg.sender

    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {

        unchecked {

            l2Address = address(uint160(l1Address) + offset);

        }

    }



    /// @notice Utility function that converts the msg.sender viewed on L2 to the

    /// address that submitted a tx to the inbox on L1

    /// @param l2Address L2 address as viewed in msg.sender

    /// @return l1Address the address in the L1 that triggered the tx to L2

    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {

        unchecked {

            l1Address = address(uint160(l2Address) - offset);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\AddressUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)



pragma solidity ^0.8.1;



/**

 * @dev Collection of functions related to the address type

 */

library AddressUpgradeable {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     *

     * [IMPORTANT]

     * ====

     * You shouldn't rely on `isContract` to protect against flash loan attacks!

     *

     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets

     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract

     * constructor.

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize/address.code.length, which returns 0

        // for contracts in construction, since the code is only stored at the end

        // of the constructor execution.



        return account.code.length > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResultFromTarget(target, success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResultFromTarget(target, success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling

     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.

     *

     * _Available since v4.8._

     */

    function verifyCallResultFromTarget(

        address target,

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        if (success) {

            if (returndata.length == 0) {

                // only check isContract if the call was successful and the return data is empty

                // otherwise we already know that it was a contract

                require(isContract(target), "Address: call to non-contract");

            }

            return returndata;

        } else {

            _revert(returndata, errorMessage);

        }

    }



    /**

     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the

     * revert reason or using the provided one.

     *

     * _Available since v4.3._

     */

    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            _revert(returndata, errorMessage);

        }

    }



    function _revert(bytes memory returndata, string memory errorMessage) private pure {

        // Look for revert reason and bubble it up if present

        if (returndata.length > 0) {

            // The easiest way to bubble the revert reason is using memory via assembly

            /// @solidity memory-safe-assembly

            assembly {

                let returndata_size := mload(returndata)

                revert(add(32, returndata), returndata_size)

            }

        } else {

            revert(errorMessage);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\AllowList.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "@openzeppelin/contracts/access/Ownable2Step.sol";



import "./interfaces/IAllowList.sol";

import "./libraries/UncheckedMath.sol";



/// @author Matter Labs

/// @notice The smart contract that stores the permissions to call the function on different contracts.

/// @dev The contract is fully controlled by the owner, that can grant and revoke any permissions at any time.

/// @dev The permission list has three different modes:

/// - Closed. The contract can NOT be called by anyone.

/// - SpecialAccessOnly. Only some contract functions can be called by specifically granted addresses.

/// - Public. Access list to call any function from the target contract by any caller

contract AllowList is IAllowList, Ownable2Step {

    using UncheckedMath for uint256;



    /// @notice The Access mode by which it is decided whether the caller has access

    mapping(address => AccessMode) public getAccessMode;



    /// @notice The mapping that stores permissions to call the function on the target address by the caller

    /// @dev caller => target => function signature => permission to call target function for the given caller address

    mapping(address => mapping(address => mapping(bytes4 => bool))) public hasSpecialAccessToCall;



    /// @dev The mapping L1 token address => struct Deposit

    mapping(address => Deposit) public tokenDeposit;



    constructor(address _initialOwner) {

        _transferOwnership(_initialOwner);

    }



    /// @return Whether the caller can call the specific function on the target contract

    /// @param _caller The caller address, who is granted access

    /// @param _target The address of the smart contract which is called

    /// @param _functionSig The function signature (selector), access to which need to check

    function canCall(

        address _caller,

        address _target,

        bytes4 _functionSig

    ) external view returns (bool) {

        AccessMode accessMode = getAccessMode[_target];

        return

            accessMode == AccessMode.Public ||

            (accessMode == AccessMode.SpecialAccessOnly && hasSpecialAccessToCall[_caller][_target][_functionSig]);

    }



    /// @notice Set the permission mode to call the target contract

    /// @param _target The address of the smart contract, of which access to the call is to be changed

    /// @param _accessMode Whether no one, any or only some addresses can call the target contract

    function setAccessMode(address _target, AccessMode _accessMode) external onlyOwner {

        _setAccessMode(_target, _accessMode);

    }



    /// @notice Set many permission modes to call the target contracts

    /// @dev Analogous to function `setAccessMode` but performs a batch of changes

    /// @param _targets The array of smart contract addresses, of which access to the call is to be changed

    /// @param _accessModes The array of new permission modes, whether no one, any or only some addresses can call the target contract

    function setBatchAccessMode(address[] calldata _targets, AccessMode[] calldata _accessModes) external onlyOwner {

        uint256 targetsLength = _targets.length;

        require(targetsLength == _accessModes.length, "yg"); // The size of arrays should be equal



        for (uint256 i = 0; i < targetsLength; i = i.uncheckedInc()) {

            _setAccessMode(_targets[i], _accessModes[i]);

        }

    }



    /// @dev Changes access mode and emit the event if the access was changed

    function _setAccessMode(address _target, AccessMode _accessMode) internal {

        AccessMode accessMode = getAccessMode[_target];



        if (accessMode != _accessMode) {

            getAccessMode[_target] = _accessMode;

            emit UpdateAccessMode(_target, accessMode, _accessMode);

        }

    }



    /// @notice Set many permissions to call the function on the contract to the specified caller address

    /// @param _callers The array of caller addresses, who are granted access

    /// @param _targets The array of smart contract addresses, of which access to the call are to be changed

    /// @param _functionSigs The array of function signatures (selectors), access to which need to be changed

    /// @param _enables The array of boolean flags, whether enable or disable the function access to the corresponding target address

    function setBatchPermissionToCall(

        address[] calldata _callers,

        address[] calldata _targets,

        bytes4[] calldata _functionSigs,

        bool[] calldata _enables

    ) external onlyOwner {

        uint256 callersLength = _callers.length;



        // The size of arrays should be equal

        require(callersLength == _targets.length, "yw");

        require(callersLength == _functionSigs.length, "yx");

        require(callersLength == _enables.length, "yy");



        for (uint256 i = 0; i < callersLength; i = i.uncheckedInc()) {

            _setPermissionToCall(_callers[i], _targets[i], _functionSigs[i], _enables[i]);

        }

    }



    /// @notice Set the permission to call the function on the contract to the specified caller address

    /// @param _caller The caller address, who is granted access

    /// @param _target The address of the smart contract, of which access to the call is to be changed

    /// @param _functionSig The function signature (selector), access to which need to be changed

    /// @param _enable Whether enable or disable the permission

    function setPermissionToCall(

        address _caller,

        address _target,

        bytes4 _functionSig,

        bool _enable

    ) external onlyOwner {

        _setPermissionToCall(_caller, _target, _functionSig, _enable);

    }



    /// @dev Changes permission to call and emits the event if the permission was changed

    function _setPermissionToCall(

        address _caller,

        address _target,

        bytes4 _functionSig,

        bool _enable

    ) internal {

        bool currentPermission = hasSpecialAccessToCall[_caller][_target][_functionSig];



        if (currentPermission != _enable) {

            hasSpecialAccessToCall[_caller][_target][_functionSig] = _enable;

            emit UpdateCallPermission(_caller, _target, _functionSig, _enable);

        }

    }



    /// @dev Set deposit limit data for a token

    /// @param _l1Token The address of L1 token

    /// @param _depositLimitation deposit limitation is active or not

    /// @param _depositCap The maximum amount that can be deposited.

    function setDepositLimit(

        address _l1Token,

        bool _depositLimitation,

        uint256 _depositCap

    ) external onlyOwner {

        tokenDeposit[_l1Token].depositLimitation = _depositLimitation;

        tokenDeposit[_l1Token].depositCap = _depositCap;

    }



    /// @dev Get deposit limit data of a token

    /// @param _l1Token The address of L1 token

    function getTokenDepositLimitData(address _l1Token) external view returns (Deposit memory) {

        return tokenDeposit[_l1Token];

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\AllowListed.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "./interfaces/IAllowList.sol";



/// @author Matter Labs

abstract contract AllowListed {

    modifier senderCanCallFunction(IAllowList _allowList) {

        // Preventing the stack too deep error

        {

            require(_allowList.canCall(msg.sender, address(this), msg.sig), "nr");

        }

        _;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Base.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "../Storage.sol";

import "../../common/ReentrancyGuard.sol";

import "../../common/AllowListed.sol";



/// @title Base contract containing functions accessible to the other facets.

/// @author Matter Labs

contract Base is ReentrancyGuard, AllowListed {

    AppStorage internal s;



    /// @notice Checks that the message sender is an active governor

    modifier onlyGovernor() {

        require(msg.sender == s.governor, "1g"); // only by governor

        _;

    }



    /// @notice Checks if validator is active

    modifier onlyValidator() {

        require(s.validators[msg.sender], "1h"); // validator is not active

        _;

    }



    modifier onlySecurityCouncil() {

        require(msg.sender == s.upgrades.securityCouncil, "a9"); // not a security council

        _;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\BridgeInitializationHelper.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "../../zksync/interfaces/IZkSync.sol";

import "../../vendor/AddressAliasHelper.sol";

import "../../common/libraries/L2ContractHelper.sol";

import "../../common/L2ContractAddresses.sol";

import "../../common/interfaces/IL2ContractDeployer.sol";



/// @author Matter Labs

/// @dev A helper library for initializing L2 bridges in zkSync L2 network.

library BridgeInitializationHelper {

    /// @dev The L2 gas limit for requesting L1 -> L2 transaction of deploying L2 bridge instance.

    /// @dev It is big enough to deploy any contract, so we can use the same value for all bridges.

    /// NOTE: this constant will be accurately calculated in the future.

    uint256 constant DEPLOY_L2_BRIDGE_COUNTERPART_GAS_LIMIT = 10000000;



    /// @dev The default l2GasPricePerPubdata to be used in bridges.

    uint256 constant REQUIRED_L2_GAS_PRICE_PER_PUBDATA = 800;



    /// @notice Requests L2 transaction that will deploy a contract with a given bytecode hash and constructor data.

    /// NOTE: it is always used to deploy via create2 with ZERO salt

    /// @param _deployTransactionFee The fee that will be paid for the L1 -> L2 transaction

    /// @param _bytecodeHash The hash of the bytecode of the contract to be deployed

    /// @param _constructorData The data to be passed to the contract constructor

    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment

    function requestDeployTransaction(

        IZkSync _zkSync,

        uint256 _deployTransactionFee,

        bytes32 _bytecodeHash,

        bytes memory _constructorData,

        bytes[] memory _factoryDeps

    ) internal returns (address deployedAddress) {

        bytes memory deployCalldata = abi.encodeCall(

            IL2ContractDeployer.create2,

            (bytes32(0), _bytecodeHash, _constructorData)

        );

        _zkSync.requestL2Transaction{value: _deployTransactionFee}(

            L2_DEPLOYER_SYSTEM_CONTRACT_ADDR,

            0,

            deployCalldata,

            DEPLOY_L2_BRIDGE_COUNTERPART_GAS_LIMIT,

            REQUIRED_L2_GAS_PRICE_PER_PUBDATA,

            _factoryDeps,

            msg.sender

        );



        deployedAddress = L2ContractHelper.computeCreate2Address(

            // Apply the alias to the address of the bridge contract, to get the `msg.sender` in L2.

            AddressAliasHelper.applyL1ToL2Alias(address(this)),

            bytes32(0), // Zero salt

            _bytecodeHash,

            keccak256(_constructorData)

        );

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Bytes.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: MIT OR Apache-2.0







// Functions named bytesToX, except bytesToBytes20, where X is some type of size N < 32 (size of one word)

// implements the following algorithm:

// f(bytes memory input, uint offset) -> X out

// where byte representation of out is N bytes from input at the given offset

// 1) We compute memory location of the word W such that last N bytes of W is input[offset..offset+N]

// W_address = input + 32 (skip stored length of bytes) + offset - (32 - N) == input + offset + N

// 2) We load W from memory into out, last N bytes of W are placed into out



library Bytes {

    function toBytesFromUInt16(uint16 self) internal pure returns (bytes memory _bts) {

        return toBytesFromUIntTruncated(uint256(self), 2);

    }



    function toBytesFromUInt24(uint24 self) internal pure returns (bytes memory _bts) {

        return toBytesFromUIntTruncated(uint256(self), 3);

    }



    function toBytesFromUInt32(uint32 self) internal pure returns (bytes memory _bts) {

        return toBytesFromUIntTruncated(uint256(self), 4);

    }



    function toBytesFromUInt128(uint128 self) internal pure returns (bytes memory _bts) {

        return toBytesFromUIntTruncated(uint256(self), 16);

    }



    // Copies 'len' lower bytes from 'self' into a new 'bytes memory'.

    // Returns the newly created 'bytes memory'. The returned bytes will be of length 'len'.

    function toBytesFromUIntTruncated(uint256 self, uint8 byteLength) private pure returns (bytes memory bts) {

        require(byteLength <= 32, "Q");

        bts = new bytes(byteLength);

        // Even though the bytes will allocate a full word, we don't want

        // any potential garbage bytes in there.

        uint256 data = self << ((32 - byteLength) * 8);

        assembly {

            mstore(

                add(bts, 32), // BYTES_HEADER_SIZE

                data

            )

        }

    }



    // Copies 'self' into a new 'bytes memory'.

    // Returns the newly created 'bytes memory'. The returned bytes will be of length '20'.

    function toBytesFromAddress(address self) internal pure returns (bytes memory bts) {

        bts = toBytesFromUIntTruncated(uint256(self), 20);

    }



    // See comment at the top of this file for explanation of how this function works.

    // NOTE: theoretically possible overflow of (_start + 20)

    function bytesToAddress(bytes memory self, uint256 _start) internal pure returns (address addr) {

        uint256 offset = _start + 20;

        require(self.length >= offset, "R");

        assembly {

            addr := mload(add(self, offset))

        }

    }



    // Reasoning about why this function works is similar to that of other similar functions, except NOTE below.

    // NOTE: that bytes1..32 is stored in the beginning of the word unlike other primitive types

    // NOTE: theoretically possible overflow of (_start + 20)

    function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {

        require(self.length >= (_start + 20), "S");

        assembly {

            r := mload(add(add(self, 0x20), _start))

        }

    }



    // See comment at the top of this file for explanation of how this function works.

    // NOTE: theoretically possible overflow of (_start + 0x2)

    function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {

        uint256 offset = _start + 0x2;

        require(_bytes.length >= offset, "T");

        assembly {

            r := mload(add(_bytes, offset))

        }

    }



    // See comment at the top of this file for explanation of how this function works.

    // NOTE: theoretically possible overflow of (_start + 0x3)

    function bytesToUInt24(bytes memory _bytes, uint256 _start) internal pure returns (uint24 r) {

        uint256 offset = _start + 0x3;

        require(_bytes.length >= offset, "U");

        assembly {

            r := mload(add(_bytes, offset))

        }

    }



    // NOTE: theoretically possible overflow of (_start + 0x4)

    function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {

        uint256 offset = _start + 0x4;

        require(_bytes.length >= offset, "V");

        assembly {

            r := mload(add(_bytes, offset))

        }

    }



    // NOTE: theoretically possible overflow of (_start + 0x10)

    function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {

        uint256 offset = _start + 0x10;

        require(_bytes.length >= offset, "W");

        assembly {

            r := mload(add(_bytes, offset))

        }

    }



    // See comment at the top of this file for explanation of how this function works.

    // NOTE: theoretically possible overflow of (_start + 0x14)

    function bytesToUInt160(bytes memory _bytes, uint256 _start) internal pure returns (uint160 r) {

        uint256 offset = _start + 0x14;

        require(_bytes.length >= offset, "X");

        assembly {

            r := mload(add(_bytes, offset))

        }

    }



    // NOTE: theoretically possible overflow of (_start + 0x20)

    function bytesToBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 r) {

        uint256 offset = _start + 0x20;

        require(_bytes.length >= offset, "Y");

        assembly {

            r := mload(add(_bytes, offset))

        }

    }



    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228

    // Get slice from bytes arrays

    // Returns the newly created 'bytes memory'

    // NOTE: theoretically possible overflow of (_start + _length)

    function slice(

        bytes memory _bytes,

        uint256 _start,

        uint256 _length

    ) internal pure returns (bytes memory) {

        require(_bytes.length >= (_start + _length), "Z"); // bytes length is less then start byte + length bytes



        bytes memory tempBytes = new bytes(_length);



        if (_length != 0) {

            assembly {

                let slice_curr := add(tempBytes, 0x20)

                let slice_end := add(slice_curr, _length)



                for {

                    let array_current := add(_bytes, add(_start, 0x20))

                } lt(slice_curr, slice_end) {

                    slice_curr := add(slice_curr, 0x20)

                    array_current := add(array_current, 0x20)

                } {

                    mstore(slice_curr, mload(array_current))

                }

            }

        }



        return tempBytes;

    }



    /// Reads byte stream

    /// @return newOffset - offset + amount of bytes read

    /// @return data - actually read data

    // NOTE: theoretically possible overflow of (_offset + _length)

    function read(

        bytes memory _data,

        uint256 _offset,

        uint256 _length

    ) internal pure returns (uint256 newOffset, bytes memory data) {

        data = slice(_data, _offset, _length);

        newOffset = _offset + _length;

    }



    // NOTE: theoretically possible overflow of (_offset + 1)

    function readBool(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bool r) {

        newOffset = _offset + 1;

        r = uint8(_data[_offset]) != 0;

    }



    // NOTE: theoretically possible overflow of (_offset + 1)

    function readUint8(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint8 r) {

        newOffset = _offset + 1;

        r = uint8(_data[_offset]);

    }



    // NOTE: theoretically possible overflow of (_offset + 2)

    function readUInt16(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint16 r) {

        newOffset = _offset + 2;

        r = bytesToUInt16(_data, _offset);

    }



    // NOTE: theoretically possible overflow of (_offset + 3)

    function readUInt24(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint24 r) {

        newOffset = _offset + 3;

        r = bytesToUInt24(_data, _offset);

    }



    // NOTE: theoretically possible overflow of (_offset + 4)

    function readUInt32(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint32 r) {

        newOffset = _offset + 4;

        r = bytesToUInt32(_data, _offset);

    }



    // NOTE: theoretically possible overflow of (_offset + 16)

    function readUInt128(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint128 r) {

        newOffset = _offset + 16;

        r = bytesToUInt128(_data, _offset);

    }



    // NOTE: theoretically possible overflow of (_offset + 20)

    function readUInt160(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint160 r) {

        newOffset = _offset + 20;

        r = bytesToUInt160(_data, _offset);

    }



    // NOTE: theoretically possible overflow of (_offset + 20)

    function readAddress(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, address r) {

        newOffset = _offset + 20;

        r = bytesToAddress(_data, _offset);

    }



    // NOTE: theoretically possible overflow of (_offset + 20)

    function readBytes20(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bytes20 r) {

        newOffset = _offset + 20;

        r = bytesToBytes20(_data, _offset);

    }



    // NOTE: theoretically possible overflow of (_offset + 32)

    function readBytes32(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bytes32 r) {

        newOffset = _offset + 32;

        r = bytesToBytes32(_data, _offset);

    }



    /// Trim bytes into single word

    function trim(bytes memory _data, uint256 _newLength) internal pure returns (uint256 r) {

        require(_newLength <= 0x20, "10"); // new_length is longer than word

        require(_data.length >= _newLength, "11"); // data is to short



        uint256 a;

        assembly {

            a := mload(add(_data, 0x20)) // load bytes into uint256

        }



        return a >> ((0x20 - _newLength) * 8);

    }



    // Helper function for hex conversion.

    function halfByteToHex(bytes1 _byte) internal pure returns (bytes1 _hexByte) {

        require(uint8(_byte) < 0x10, "hbh11"); // half byte's value is out of 0..15 range.



        // "FEDCBA9876543210" ASCII-encoded, shifted and automatically truncated.

        return bytes1(uint8(0x66656463626139383736353433323130 >> (uint8(_byte) * 8)));

    }



    // Convert bytes to ASCII hex representation

    function bytesToHexASCIIBytes(bytes memory _input) internal pure returns (bytes memory _output) {

        bytes memory outStringBytes = new bytes(_input.length * 2);



        // code in `assembly` construction is equivalent of the next code:

        // for (uint i = 0; i < _input.length; ++i) {

        //     outStringBytes[i*2] = halfByteToHex(_input[i] >> 4);

        //     outStringBytes[i*2+1] = halfByteToHex(_input[i] & 0x0f);

        // }

        assembly {

            let input_curr := add(_input, 0x20)

            let input_end := add(input_curr, mload(_input))



            for {

                let out_curr := add(outStringBytes, 0x20)

            } lt(input_curr, input_end) {

                input_curr := add(input_curr, 0x01)

                out_curr := add(out_curr, 0x02)

            } {

                let curr_input_byte := shr(0xf8, mload(input_curr))

                // here outStringByte from each half of input byte calculates by the next:

                //

                // "FEDCBA9876543210" ASCII-encoded, shifted and automatically truncated.

                // outStringByte = byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byteHalf) * 8)))

                mstore(

                    out_curr,

                    shl(0xf8, shr(mul(shr(0x04, curr_input_byte), 0x08), 0x66656463626139383736353433323130))

                )

                mstore(

                    add(out_curr, 0x01),

                    shl(0xf8, shr(mul(and(0x0f, curr_input_byte), 0x08), 0x66656463626139383736353433323130))

                )

            }

        }

        return outStringBytes;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Config.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







/// @dev `keccak256("")`

bytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;



/// @dev Bytes in raw L2 log

/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBlock, address sender, bytes32 key, bytes32 value)

uint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;



/// @dev The maximum length of the bytes array with L2 -> L1 logs

uint256 constant MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;



/// @dev L2 -> L1 logs Merkle tree height

uint256 constant L2_TO_L1_LOG_MERKLE_TREE_HEIGHT = 9;



/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree

/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree

/// @dev Actually equal to the `keccak256(new bytes(L2_TO_L1_LOG_SERIALIZE_SIZE))`

bytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;



/// @dev Number of bytes in a one initial storage change

/// @dev Equal to the bytes size of the tuple - (bytes32 key, bytes32 value)

uint256 constant INITIAL_STORAGE_CHANGE_SERIALIZE_SIZE = 64;



/// @dev The maximum length of the bytes array with initial storage changes

uint256 constant MAX_INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + INITIAL_STORAGE_CHANGE_SERIALIZE_SIZE * 4765;



/// @dev Number of bytes in a one repeated storage change

/// @dev Equal to the bytes size of the tuple - (bytes8 key, bytes32 value)

uint256 constant REPEATED_STORAGE_CHANGE_SERIALIZE_SIZE = 40;



/// @dev The maximum length of the bytes array with repeated storage changes

uint256 constant MAX_REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + REPEATED_STORAGE_CHANGE_SERIALIZE_SIZE * 7564;



// TODO: change constant to the real root hash of empty Merkle tree (SMA-184)

bytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);



/// @dev Denotes the first byte of the zkSync transaction that came from L1.

uint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;



/// @dev The amount of time in seconds the validator has to process the priority transaction

/// NOTE: The constant is set to zero for the Alpha release period

uint256 constant PRIORITY_EXPIRATION = 0 days;



/// @dev Notice period before activation preparation status of upgrade mode (in seconds)

/// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.

uint256 constant UPGRADE_NOTICE_PERIOD = 0;



/// @dev Timestamp - seconds since unix epoch

uint256 constant COMMIT_TIMESTAMP_NOT_OLDER = 365 days;



/// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)

/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)

uint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 365 days;



/// @dev Bit mask to apply for verifier public input before verifying.

uint256 constant INPUT_MASK = 452312848583266388373324160190187140051835877600158453279131187530910662655;



/// @dev The maximum number of L2 gas that a user can request for an L2 transaction

uint256 constant L2_TX_MAX_GAS_LIMIT = 80000000;



/// @dev The maximum number of the pubdata an L2 operation should be allowed to use.

uint256 constant MAX_PUBDATA_PER_BLOCK = 110000;



/// @dev The maximum number of the pubdata an priority operation should be allowed to use.

/// For now, it is somewhat lower than the maximum number of pubdata allowed for an L2 transaction,

/// to ensure that the transaction is definitely processable on L2 despite any potential overhead.

uint256 constant PRIORITY_TX_MAX_PUBDATA = 99000;



/// @dev The default price per L2 gas to be used for L1->L2 transactions

uint256 constant FAIR_L2_GAS_PRICE = 500000000;



/// @dev Even though the price for 1 byte of pubdata is 16 L1 gas, we have a slightly increased

/// value.

uint256 constant L1_GAS_PER_PUBDATA_BYTE = 17;



/// @dev The computational overhead of processing an L2 block.

uint256 constant BLOCK_OVERHEAD_L2_GAS = 1200000;



/// @dev The overhead in L1 gas of interacting with the L1

uint256 constant BLOCK_OVERHEAD_L1_GAS = 1000000;



/// @dev The equivalent in L1 pubdata of L1 gas used for working with L1

uint256 constant BLOCK_OVERHEAD_PUBDATA = BLOCK_OVERHEAD_L1_GAS / L1_GAS_PER_PUBDATA_BYTE;



/// @dev The maximum number of transactions in L2 block:

uint256 constant MAX_TRANSACTIONS_IN_BLOCK = 1024;



/// @dev The size of the bootloader memory dedicated to the encodings of transactions

uint256 constant BOOTLOADER_TX_ENCODING_SPACE = 485225;



/// @dev The intrinsic cost of the L1->l2 transaction in computational L2 gas

uint256 constant L1_TX_INTRINSIC_L2_GAS = 167157;



/// @dev The intrinsic cost of the L1->l2 transaction in pubdata

uint256 constant L1_TX_INTRINSIC_PUBDATA = 88;



/// @dev The minimal base price for L1 transaction

uint256 constant L1_TX_MIN_L2_GAS_BASE = 173484;



/// @dev The number of L2 gas the transaction starts costing more with each 544 bytes of encoding

uint256 constant L1_TX_DELTA_544_ENCODING_BYTES = 1656;



/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency

uint256 constant L1_TX_DELTA_FACTORY_DEPS_L2_GAS = 2473;



/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency

uint256 constant L1_TX_DELTA_FACTORY_DEPS_PUBDATA = 64;



/// @dev The number of pubdata an L1->L2 transaction requires with each new factory dependency

uint256 constant MAX_NEW_FACTORY_DEPS = 32;



/// @dev The L2 gasPricePerPubdata required to be used in bridges.

uint256 constant REQUIRED_L2_GAS_PRICE_PER_PUBDATA = 800;

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Constants.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;



address constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;

address constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)



pragma solidity ^0.8.0;



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ContextUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)



pragma solidity ^0.8.0;

import "../proxy/utils/Initializable.sol";



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract ContextUpgradeable is Initializable {

    function __Context_init() internal onlyInitializing {

    }



    function __Context_init_unchained() internal onlyInitializing {

    }

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[50] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\DefaultOperatorFiltererUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;



import {OperatorFiltererUpgradeable} from "./OperatorFiltererUpgradeable.sol";

import {CANONICAL_CORI_SUBSCRIPTION} from "../lib/Constants.sol";



/**

 * @title  DefaultOperatorFiltererUpgradeable

 * @notice Inherits from OperatorFiltererUpgradeable and automatically subscribes to the default OpenSea subscription

 *         when the init function is called.

 */

abstract contract DefaultOperatorFiltererUpgradeable is OperatorFiltererUpgradeable {

    /// @dev The upgradeable initialize function that should be called when the contract is being deployed.

    function __DefaultOperatorFilterer_init() internal onlyInitializing {

        OperatorFiltererUpgradeable.__OperatorFilterer_init(CANONICAL_CORI_SUBSCRIPTION, true);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Diamond.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../common/libraries/UncheckedMath.sol";



/// @author Matter Labs

/// @notice The helper library for managing the EIP-2535 diamond proxy.

library Diamond {

    using UncheckedMath for uint256;

    using SafeCast for uint256;



    /// @dev Magic value that should be returned by diamond cut initialize contracts.

    /// @dev Used to distinguish calls to contracts that were supposed to be used as diamond initializer from other contracts.

    bytes32 constant DIAMOND_INIT_SUCCESS_RETURN_VALUE =

        0x33774e659306e47509050e97cb651e731180a42d458212294d30751925c551a2; // keccak256("diamond.zksync.init") - 1



    /// @dev Storage position of `DiamondStorage` structure.

    bytes32 constant DIAMOND_STORAGE_POSITION = 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b; // keccak256("diamond.standard.diamond.storage") - 1;



    event DiamondCut(FacetCut[] facetCuts, address initAddress, bytes initCalldata);



    /// @dev Utility struct that contains associated facet & meta information of selector

    /// @param facetAddress address of the facet which is connected with selector

    /// @param selectorPosition index in `FacetToSelectors.selectors` array, where is selector stored

    /// @param isFreezable denotes whether the selector can be frozen.

    struct SelectorToFacet {

        address facetAddress;

        uint16 selectorPosition;

        bool isFreezable;

    }



    /// @dev Utility struct that contains associated selectors & meta information of facet

    /// @param selectors list of all selectors that belong to the facet

    /// @param facetPosition index in `DiamondStorage.facets` array, where is facet stored

    struct FacetToSelectors {

        bytes4[] selectors;

        uint16 facetPosition;

    }



    /// @notice The structure that holds all diamond proxy associated parameters

    /// @dev According to the EIP-2535 should be stored on a special storage key - `DIAMOND_STORAGE_POSITION`

    /// @param selectorToFacet A mapping from the selector to the facet address and its meta information

    /// @param facetToSelectors A mapping from facet address to its selector with meta information

    /// @param facets The array of all unique facet addresses that belong to the diamond proxy

    /// @param isFrozen Denotes whether the diamond proxy is frozen and all freezable facets are not accessible

    struct DiamondStorage {

        mapping(bytes4 => SelectorToFacet) selectorToFacet;

        mapping(address => FacetToSelectors) facetToSelectors;

        address[] facets;

        bool isFrozen;

    }



    /// @dev Parameters for diamond changes that touch one of the facets

    /// @param facet The address of facet that's affected by the cut

    /// @param action The action that is made on the facet

    /// @param isFreezable Denotes whether the facet & all their selectors can be frozen

    /// @param selectors An array of unique selectors that belongs to the facet address

    struct FacetCut {

        address facet;

        Action action;

        bool isFreezable;

        bytes4[] selectors;

    }



    /// @dev Structure of the diamond proxy changes

    /// @param facetCuts The set of changes (adding/removing/replacement) of implementation contracts

    /// @param initAddress The address that's delegate called after setting up new facet changes

    /// @param initCalldata Calldata for the delegate call to `initAddress`

    struct DiamondCutData {

        FacetCut[] facetCuts;

        address initAddress;

        bytes initCalldata;

    }



    /// @dev Type of change over diamond: add/replace/remove facets

    enum Action {

        Add,

        Replace,

        Remove

    }



    /// @return diamondStorage The pointer to the storage where all specific diamond proxy parameters stored

    function getDiamondStorage() internal pure returns (DiamondStorage storage diamondStorage) {

        bytes32 position = DIAMOND_STORAGE_POSITION;

        assembly {

            diamondStorage.slot := position

        }

    }



    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall

    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall

    function diamondCut(DiamondCutData memory _diamondCut) internal {

        FacetCut[] memory facetCuts = _diamondCut.facetCuts;

        address initAddress = _diamondCut.initAddress;

        bytes memory initCalldata = _diamondCut.initCalldata;

        uint256 facetCutsLength = facetCuts.length;

        for (uint256 i = 0; i < facetCutsLength; i = i.uncheckedInc()) {

            Action action = facetCuts[i].action;

            address facet = facetCuts[i].facet;

            bool isFacetFreezable = facetCuts[i].isFreezable;

            bytes4[] memory selectors = facetCuts[i].selectors;



            require(selectors.length > 0, "B"); // no functions for diamond cut



            if (action == Action.Add) {

                _addFunctions(facet, selectors, isFacetFreezable);

            } else if (action == Action.Replace) {

                _replaceFunctions(facet, selectors, isFacetFreezable);

            } else if (action == Action.Remove) {

                _removeFunctions(facet, selectors);

            } else {

                revert("C"); // undefined diamond cut action

            }

        }



        _initializeDiamondCut(initAddress, initCalldata);

        emit DiamondCut(facetCuts, initAddress, initCalldata);

    }



    /// @dev Add new functions to the diamond proxy

    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array

    function _addFunctions(

        address _facet,

        bytes4[] memory _selectors,

        bool _isFacetFreezable

    ) private {

        DiamondStorage storage ds = getDiamondStorage();



        require(_facet != address(0), "G"); // facet with zero address cannot be added



        // Add facet to the list of facets if the facet address is new one

        _saveFacetIfNew(_facet);



        uint256 selectorsLength = _selectors.length;

        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {

            bytes4 selector = _selectors[i];

            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];

            require(oldFacet.facetAddress == address(0), "J"); // facet for this selector already exists



            _addOneFunction(_facet, selector, _isFacetFreezable);

        }

    }



    /// @dev Change associated facets to already known function selectors

    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array

    function _replaceFunctions(

        address _facet,

        bytes4[] memory _selectors,

        bool _isFacetFreezable

    ) private {

        DiamondStorage storage ds = getDiamondStorage();



        require(_facet != address(0), "K"); // cannot replace facet with zero address



        uint256 selectorsLength = _selectors.length;

        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {

            bytes4 selector = _selectors[i];

            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];

            require(oldFacet.facetAddress != address(0), "L"); // it is impossible to replace the facet with zero address



            _removeOneFunction(oldFacet.facetAddress, selector);

            // Add facet to the list of facets if the facet address is a new one

            _saveFacetIfNew(_facet);

            _addOneFunction(_facet, selector, _isFacetFreezable);

        }

    }



    /// @dev Remove association with function and facet

    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array

    function _removeFunctions(address _facet, bytes4[] memory _selectors) private {

        DiamondStorage storage ds = getDiamondStorage();



        require(_facet == address(0), "a1"); // facet address must be zero



        uint256 selectorsLength = _selectors.length;

        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {

            bytes4 selector = _selectors[i];

            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];

            require(oldFacet.facetAddress != address(0), "a2"); // Can't delete a non-existent facet



            _removeOneFunction(oldFacet.facetAddress, selector);

        }

    }



    /// @dev Add address to the list of known facets if it is not on the list yet

    /// NOTE: should be called ONLY before adding a new selector associated with the address

    function _saveFacetIfNew(address _facet) private {

        DiamondStorage storage ds = getDiamondStorage();



        uint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;

        // If there are no selectors associated with facet then save facet as new one

        if (selectorsLength == 0) {

            ds.facetToSelectors[_facet].facetPosition = ds.facets.length.toUint16();

            ds.facets.push(_facet);

        }

    }



    /// @dev Add one function to the already known facet

    /// NOTE: It is expected but NOT enforced that:

    /// - `_facet` is NON-ZERO address

    /// - `_facet` is already stored address in `DiamondStorage.facets`

    /// - `_selector` is NOT associated by another facet

    function _addOneFunction(

        address _facet,

        bytes4 _selector,

        bool _isSelectorFreezable

    ) private {

        DiamondStorage storage ds = getDiamondStorage();



        uint16 selectorPosition = (ds.facetToSelectors[_facet].selectors.length).toUint16();



        // if selectorPosition is nonzero, it means it is not a new facet

        // so the freezability of the first selector must be matched to _isSelectorFreezable

        // so all the selectors in a facet will have the same freezability

        if (selectorPosition != 0) {

            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];

            require(_isSelectorFreezable == ds.selectorToFacet[selector0].isFreezable, "J1");

        }



        ds.selectorToFacet[_selector] = SelectorToFacet({

            facetAddress: _facet,

            selectorPosition: selectorPosition,

            isFreezable: _isSelectorFreezable

        });

        ds.facetToSelectors[_facet].selectors.push(_selector);

    }



    /// @dev Remove one associated function with facet

    /// NOTE: It is expected but NOT enforced that `_facet` is NON-ZERO address

    function _removeOneFunction(address _facet, bytes4 _selector) private {

        DiamondStorage storage ds = getDiamondStorage();



        // Get index of `FacetToSelectors.selectors` of the selector and last element of array

        uint256 selectorPosition = ds.selectorToFacet[_selector].selectorPosition;

        uint256 lastSelectorPosition = ds.facetToSelectors[_facet].selectors.length - 1;



        // If the selector is not at the end of the array then move the last element to the selector position

        if (selectorPosition != lastSelectorPosition) {

            bytes4 lastSelector = ds.facetToSelectors[_facet].selectors[lastSelectorPosition];



            ds.facetToSelectors[_facet].selectors[selectorPosition] = lastSelector;

            ds.selectorToFacet[lastSelector].selectorPosition = selectorPosition.toUint16();

        }



        // Remove last element from the selectors array

        ds.facetToSelectors[_facet].selectors.pop();



        // Finally, clean up the association with facet

        delete ds.selectorToFacet[_selector];



        // If there are no selectors for facet then remove the facet from the list of known facets

        if (lastSelectorPosition == 0) {

            _removeFacet(_facet);

        }

    }



    /// @dev remove facet from the list of known facets

    /// NOTE: It is expected but NOT enforced that there are no selectors associated with `_facet`

    function _removeFacet(address _facet) private {

        DiamondStorage storage ds = getDiamondStorage();



        // Get index of `DiamondStorage.facets` of the facet and last element of array

        uint256 facetPosition = ds.facetToSelectors[_facet].facetPosition;

        uint256 lastFacetPosition = ds.facets.length - 1;



        // If the facet is not at the end of the array then move the last element to the facet position

        if (facetPosition != lastFacetPosition) {

            address lastFacet = ds.facets[lastFacetPosition];



            ds.facets[facetPosition] = lastFacet;

            ds.facetToSelectors[lastFacet].facetPosition = facetPosition.toUint16();

        }



        // Remove last element from the facets array

        ds.facets.pop();

    }



    /// @dev Delegates call to the initialization address with provided calldata

    /// @dev Used as a final step of diamond cut to execute the logic of the initialization for changed facets

    function _initializeDiamondCut(address _init, bytes memory _calldata) private {

        if (_init == address(0)) {

            require(_calldata.length == 0, "H"); // Non-empty calldata for zero address

        } else {

            // Do not check whether `_init` is a contract since later we check that it returns data.

            (bool success, bytes memory data) = _init.delegatecall(_calldata);

            require(success, "I"); // delegatecall failed



            // Check that called contract returns magic value to make sure that contract logic

            // supposed to be used as diamond cut initializer.

            require(data.length == 32, "lp");

            require(abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, "lp1");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\DiamondCut.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "../../common/libraries/UncheckedMath.sol";

import "../interfaces/IDiamondCut.sol";

import "../libraries/Diamond.sol";

import "../Config.sol";

import "./Base.sol";



/// @title DiamondCutFacet - contract responsible for the management of upgrades.

/// @author Matter Labs

contract DiamondCutFacet is Base, IDiamondCut {

    using UncheckedMath for uint256;



    modifier upgradeProposed() {

        require(s.upgrades.state != UpgradeState.None, "a3"); // Proposal doesn't exist

        _;

    }



    modifier noUpgradeProposed() {

        require(s.upgrades.state == UpgradeState.None, "a8"); // Proposal already exists

        _;

    }



    /*//////////////////////////////////////////////////////////////

                            UPGRADE PROPOSING

    //////////////////////////////////////////////////////////////*/



    /// @notice Propose a fully transparent upgrade, providing upgrade data on-chain

    /// @notice The governor will be able to execute the proposal either

    /// - With a `UPGRADE_NOTICE_PERIOD` timelock on its own

    /// - With security council approvals instantly

    /// @dev Only the current governor can propose an upgrade

    /// @param _diamondCut The diamond cut parameters will be executed with the upgrade

    function proposeTransparentUpgrade(Diamond.DiamondCutData calldata _diamondCut, uint40 _proposalId)

        external

        onlyGovernor

        noUpgradeProposed

    {

        // Set the default value for proposal salt, since the proposal is fully transparent it doesn't change anything

        bytes32 proposalSalt;

        uint40 expectedProposalId = s.upgrades.currentProposalId + 1;

        // Input proposal ID should be equal to the expected proposal id

        require(_proposalId == expectedProposalId, "yb");

        s.upgrades.proposedUpgradeHash = upgradeProposalHash(_diamondCut, expectedProposalId, proposalSalt);

        s.upgrades.proposedUpgradeTimestamp = uint40(block.timestamp);

        s.upgrades.currentProposalId = expectedProposalId;

        s.upgrades.state = UpgradeState.Transparent;



        emit ProposeTransparentUpgrade(_diamondCut, expectedProposalId, proposalSalt);

    }



    /// @notice Propose "shadow" upgrade, upgrade data is not publishing on-chain

    /// @notice The governor will be able to execute the proposal only:

    /// - With security council approvals instantly

    /// @dev Only the current governor can propose an upgrade

    /// @param _proposalHash Upgrade proposal hash (see `upgradeProposalHash` function)

    /// @param _proposalId An expected value for the current proposal Id

    function proposeShadowUpgrade(bytes32 _proposalHash, uint40 _proposalId) external onlyGovernor noUpgradeProposed {

        require(_proposalHash != bytes32(0), "mi");



        s.upgrades.proposedUpgradeHash = _proposalHash;

        s.upgrades.proposedUpgradeTimestamp = uint40(block.timestamp); // Safe to cast

        s.upgrades.state = UpgradeState.Shadow;



        uint256 currentProposalId = s.upgrades.currentProposalId;

        // Expected proposal ID should be one more than the current saved proposal ID value

        require(_proposalId == currentProposalId.uncheckedInc(), "ya");

        s.upgrades.currentProposalId = _proposalId;



        emit ProposeShadowUpgrade(_proposalId, _proposalHash);

    }



    /*//////////////////////////////////////////////////////////////

                            UPGRADE CANCELING

    //////////////////////////////////////////////////////////////*/



    /// @notice Cancel the proposed upgrade

    /// @dev Only the current governor can remove the proposal

    /// @param _proposedUpgradeHash Expected upgrade hash value to be canceled

    function cancelUpgradeProposal(bytes32 _proposedUpgradeHash) external onlyGovernor upgradeProposed {

        bytes32 currentUpgradeHash = s.upgrades.proposedUpgradeHash;

        // Soft check that the governor is not mistaken about canceling proposals

        require(_proposedUpgradeHash == currentUpgradeHash, "rx");



        _resetProposal();

        emit CancelUpgradeProposal(s.upgrades.currentProposalId, currentUpgradeHash);

    }



    /*//////////////////////////////////////////////////////////////

                            SECURITY COUNCIL

    //////////////////////////////////////////////////////////////*/



    /// @notice Approves the instant upgrade by the security council

    /// @param _upgradeProposalHash The upgrade proposal hash that security council members want to approve. Needed to prevent unintentional approvals, including reorg attacks

    function securityCouncilUpgradeApprove(bytes32 _upgradeProposalHash) external onlySecurityCouncil upgradeProposed {

        require(s.upgrades.proposedUpgradeHash == _upgradeProposalHash, "un");

        s.upgrades.approvedBySecurityCouncil = true;



        emit SecurityCouncilUpgradeApprove(s.upgrades.currentProposalId, _upgradeProposalHash);

    }



    /*//////////////////////////////////////////////////////////////

                            UPGRADE EXECUTION

    //////////////////////////////////////////////////////////////*/



    /// @notice Executes a proposed governor upgrade

    /// @dev Only the current governor can execute the upgrade

    /// @param _diamondCut The diamond cut parameters to be executed

    /// @param _proposalSalt The committed 32 bytes salt for upgrade proposal data

    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut, bytes32 _proposalSalt) external onlyGovernor {

        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();



        bool approvedBySecurityCouncil = s.upgrades.approvedBySecurityCouncil;

        UpgradeState upgradeState = s.upgrades.state;

        if (upgradeState == UpgradeState.Transparent) {

            bool upgradeNoticePeriodPassed = block.timestamp >=

                s.upgrades.proposedUpgradeTimestamp + UPGRADE_NOTICE_PERIOD;

            require(upgradeNoticePeriodPassed || approvedBySecurityCouncil, "va");

            require(_proposalSalt == bytes32(0), "po"); // The transparent upgrade may be initiated only with zero salt

        } else if (upgradeState == UpgradeState.Shadow) {

            require(approvedBySecurityCouncil, "av");

            require(_proposalSalt != bytes32(0), "op"); // Shadow upgrade should be initialized with "random" salt

        } else {

            revert("ab"); // There is no active upgrade

        }



        require(approvedBySecurityCouncil || !diamondStorage.isFrozen, "f3");

        // Should not be frozen or should have enough security council approvals



        uint256 currentProposalId = s.upgrades.currentProposalId;

        bytes32 executingProposalHash = upgradeProposalHash(_diamondCut, currentProposalId, _proposalSalt);

        require(s.upgrades.proposedUpgradeHash == executingProposalHash, "a4"); // Proposal should be created

        _resetProposal();



        if (diamondStorage.isFrozen) {

            diamondStorage.isFrozen = false;

            emit Unfreeze();

        }



        Diamond.diamondCut(_diamondCut);

        emit ExecuteUpgrade(currentProposalId, executingProposalHash, _proposalSalt);

    }



    /*//////////////////////////////////////////////////////////////

                            CONTRACT FREEZING

    //////////////////////////////////////////////////////////////*/



    /// @notice Instantly pause the functionality of all freezable facets & their selectors

    function freezeDiamond() external onlyGovernor {

        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();



        require(!diamondStorage.isFrozen, "a9"); // diamond proxy is frozen already

        _resetProposal();

        diamondStorage.isFrozen = true;



        emit Freeze();

    }



    /// @notice Unpause the functionality of all freezable facets & their selectors

    function unfreezeDiamond() external onlyGovernor {

        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();



        require(diamondStorage.isFrozen, "a7"); // diamond proxy is not frozen

        _resetProposal();

        diamondStorage.isFrozen = false;



        emit Unfreeze();

    }



    /*//////////////////////////////////////////////////////////////

                            GETTERS & HELPERS

    //////////////////////////////////////////////////////////////*/



    /// @notice Generate the upgrade proposal hash

    /// @param _diamondCut The diamond cut parameters will be executed with the upgrade

    /// @param _proposalId The current proposal ID, to set a unique upgrade hash depending on the upgrades order

    /// @param _salt The arbitrary 32 bytes, primarily used in shadow upgrades to prevent guessing the upgrade proposal content by its hash

    /// @return The upgrade proposal hash

    function upgradeProposalHash(

        Diamond.DiamondCutData calldata _diamondCut,

        uint256 _proposalId,

        bytes32 _salt

    ) public pure returns (bytes32) {

        return keccak256(abi.encode(_diamondCut, _proposalId, _salt));

    }



    /// @dev Set up the proposed upgrade state to the default values

    function _resetProposal() internal {

        delete s.upgrades.state;

        delete s.upgrades.proposedUpgradeHash;

        delete s.upgrades.proposedUpgradeTimestamp;

        delete s.upgrades.approvedBySecurityCouncil;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\DiamondInit.sol
File type: .sol
pragma solidity ^0.8.0;



// SPDX-License-Identifier: MIT







import "../common/interfaces/IAllowList.sol";

import "./interfaces/IExecutor.sol";

import "./libraries/Diamond.sol";

import "./facets/Base.sol";

import "./Config.sol";



/// @author Matter Labs

/// @dev The contract is used only once to initialize the diamond proxy.

/// @dev The deployment process takes care of this contract's initialization.

contract DiamondInit is Base {

    /// @dev Initialize the implementation to prevent any possibility of a Parity hack.

    constructor() reentrancyGuardInitializer {}



    /// @notice zkSync contract initialization

    /// @param _verifier address of Verifier contract

    /// @param _governor address who can manage the contract

    /// @param _validator address who can make blocks

    /// @param _genesisBlockHash Block hash of the genesis (initial) block

    /// @param _genesisIndexRepeatedStorageChanges The serial number of the shortcut storage key for genesis block

    /// @param _genesisBlockCommitment The zk-proof commitment for the genesis block

    /// @param _allowList The address of the allow list smart contract

    /// @param _verifierParams Verifier config parameters that describes the circuit to be verified

    /// @param _zkPorterIsAvailable The availability of zk porter shard

    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode

    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode

    /// @param _priorityTxMaxGasLimit maximum number of the L2 gas that a user can request for L1 -> L2 transactions

    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy initializer

    function initialize(

        Verifier _verifier,

        address _governor,

        address _validator,

        bytes32 _genesisBlockHash,

        uint64 _genesisIndexRepeatedStorageChanges,

        bytes32 _genesisBlockCommitment,

        IAllowList _allowList,

        VerifierParams calldata _verifierParams,

        bool _zkPorterIsAvailable,

        bytes32 _l2BootloaderBytecodeHash,

        bytes32 _l2DefaultAccountBytecodeHash,

        uint256 _priorityTxMaxGasLimit

    ) external reentrancyGuardInitializer returns (bytes32) {

        require(address(_verifier) != address(0), "vt");

        require(_governor != address(0), "vy");



        s.verifier = _verifier;

        s.governor = _governor;

        s.validators[_validator] = true;



        // We need to initialize the state hash because it is used in the commitment of the next block

        IExecutor.StoredBlockInfo memory storedBlockZero = IExecutor.StoredBlockInfo(

            0,

            _genesisBlockHash,

            _genesisIndexRepeatedStorageChanges,

            0,

            EMPTY_STRING_KECCAK,

            DEFAULT_L2_LOGS_TREE_ROOT_HASH,

            0,

            _genesisBlockCommitment

        );



        s.storedBlockHashes[0] = keccak256(abi.encode(storedBlockZero));

        s.allowList = _allowList;

        s.verifierParams = _verifierParams;

        s.zkPorterIsAvailable = _zkPorterIsAvailable;

        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;

        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;

        s.priorityTxMaxGasLimit = _priorityTxMaxGasLimit;



        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\DiamondProxy.sol
File type: .sol
pragma solidity ^0.8.0;



// SPDX-License-Identifier: MIT







import "./libraries/Diamond.sol";



/// @title Diamond Proxy Contract (EIP-2535)

/// @author Matter Labs

contract DiamondProxy {

    constructor(uint256 _chainId, Diamond.DiamondCutData memory _diamondCut) {

        // Check that the contract is deployed on the expected chain.

        // Thus, the contract deployed by the same Create2 factory on the different chain will have different addresses!

        require(_chainId == block.chainid, "pr");

        Diamond.diamondCut(_diamondCut);

    }



    /// @dev 1. Find the facet for the function that is called.

    /// @dev 2. Delegate the execution to the found facet via `delegatecall`.

    fallback() external payable {

        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();

        // Check whether the data contains a "full" selector or it is empty.

        // Required because Diamond proxy finds a facet by function signature,

        // which is not defined for data length in range [1, 3].

        require(msg.data.length >= 4 || msg.data.length == 0, "Ut");

        // Get facet from function selector

        Diamond.SelectorToFacet memory facet = diamondStorage.selectorToFacet[msg.sig];

        address facetAddress = facet.facetAddress;



        require(facetAddress != address(0), "F"); // Proxy has no facet for this selector

        require(!diamondStorage.isFrozen || !facet.isFreezable, "q1"); // Facet is frozen



        assembly {

            // The pointer to the free memory slot

            let ptr := mload(0x40)

            // Copy function signature and arguments from calldata at zero position into memory at pointer position

            calldatacopy(ptr, 0, calldatasize())

            // Delegatecall method of the implementation contract returns 0 on error

            let result := delegatecall(gas(), facetAddress, ptr, calldatasize(), 0, 0)

            // Get the size of the last return data

            let size := returndatasize()

            // Copy the size length of bytes from return data at zero position to pointer position

            returndatacopy(ptr, 0, size)

            // Depending on the result value

            switch result

            case 0 {

                // End execution and revert state changes

                revert(ptr, size)

            }

            default {

                // Return data with length of size at pointers position

                return(ptr, size)

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\DiamondUpgradeInit5.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "../Config.sol";

import "../facets/Mailbox.sol";

import "../libraries/Diamond.sol";

import "../../common/libraries/L2ContractHelper.sol";

import "../../common/L2ContractAddresses.sol";



/// @author Matter Labs

contract DiamondUpgradeInit5 is MailboxFacet {

    function forceDeploy(

        bytes calldata _upgradeDeployerCalldata,

        bytes calldata _upgradeSystemContractsCalldata,

        bytes[] calldata _factoryDeps

    ) external payable returns (bytes32) {

        // 1. Update bytecode for the deployer smart contract

        _requestL2Transaction(

            L2_FORCE_DEPLOYER_ADDR,

            L2_DEPLOYER_SYSTEM_CONTRACT_ADDR,

            0,

            _upgradeDeployerCalldata,

            72000000,

            REQUIRED_L2_GAS_PRICE_PER_PUBDATA,

            _factoryDeps,

            true,

            address(0)

        );



        // 2. Redeploy system contracts by one priority transaction

        _requestL2Transaction(

            L2_FORCE_DEPLOYER_ADDR,

            L2_DEPLOYER_SYSTEM_CONTRACT_ADDR,

            0,

            _upgradeSystemContractsCalldata,

            72000000,

            REQUIRED_L2_GAS_PRICE_PER_PUBDATA,

            _factoryDeps,

            true,

            address(0)

        );



        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\draft-IERC1822.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)



pragma solidity ^0.8.0;



/**

 * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified

 * proxy whose upgrades are fully controlled by the current implementation.

 */

interface IERC1822Proxiable {

    /**

     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation

     * address.

     *

     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks

     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this

     * function revert if invoked through a proxy.

     */

    function proxiableUUID() external view returns (bytes32);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\draft-IERC20Permit.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in

 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].

 *

 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by

 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't

 * need to send a transaction, and thus is not required to hold Ether at all.

 */

interface IERC20Permit {

    /**

     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,

     * given ``owner``'s signed approval.

     *

     * IMPORTANT: The same issues {IERC20-approve} has related to transaction

     * ordering also apply here.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `deadline` must be a timestamp in the future.

     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`

     * over the EIP712-formatted function arguments.

     * - the signature must use ``owner``'s current nonce (see {nonces}).

     *

     * For more information on the signature format, see the

     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP

     * section].

     */

    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external;



    /**

     * @dev Returns the current nonce for `owner`. This value must be

     * included whenever a signature is generated for {permit}.

     *

     * Every successful call to {permit} increases ``owner``'s nonce by one. This

     * prevents a signature from being used multiple times.

     */

    function nonces(address owner) external view returns (uint256);



    /**

     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.

     */

    // solhint-disable-next-line func-name-mixedcase

    function DOMAIN_SEPARATOR() external view returns (bytes32);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ECDSAUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)



pragma solidity ^0.8.0;



import "../StringsUpgradeable.sol";



/**

 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.

 *

 * These functions can be used to verify that a message was signed by the holder

 * of the private keys of a given address.

 */

library ECDSAUpgradeable {

    enum RecoverError {

        NoError,

        InvalidSignature,

        InvalidSignatureLength,

        InvalidSignatureS,

        InvalidSignatureV // Deprecated in v4.8

    }



    function _throwError(RecoverError error) private pure {

        if (error == RecoverError.NoError) {

            return; // no error: do nothing

        } else if (error == RecoverError.InvalidSignature) {

            revert("ECDSA: invalid signature");

        } else if (error == RecoverError.InvalidSignatureLength) {

            revert("ECDSA: invalid signature length");

        } else if (error == RecoverError.InvalidSignatureS) {

            revert("ECDSA: invalid signature 's' value");

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature` or error string. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     *

     * Documentation for signature generation:

     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]

     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {

        if (signature.length == 65) {

            bytes32 r;

            bytes32 s;

            uint8 v;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            /// @solidity memory-safe-assembly

            assembly {

                r := mload(add(signature, 0x20))

                s := mload(add(signature, 0x40))

                v := byte(0, mload(add(signature, 0x60)))

            }

            return tryRecover(hash, v, r, s);

        } else {

            return (address(0), RecoverError.InvalidSignatureLength);

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature`. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     */

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, signature);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.

     *

     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address, RecoverError) {

        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);

        uint8 v = uint8((uint256(vs) >> 255) + 27);

        return tryRecover(hash, v, r, s);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.

     *

     * _Available since v4.2._

     */

    function recover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, r, vs);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,

     * `r` and `s` signature fields separately.

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address, RecoverError) {

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature

        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines

        // the valid range for s in (301): 0 < s < secp256k1n ?? 2 + 1, and for v in (302): v ?? {27, 28}. Most

        // signatures from current libraries generate a unique signature with an s-value in the lower half order.

        //

        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value

        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or

        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept

        // these malleable signatures as well.

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            return (address(0), RecoverError.InvalidSignatureS);

        }



        // If the signature is valid (and not malleable), return the signer address

        address signer = ecrecover(hash, v, r, s);

        if (signer == address(0)) {

            return (address(0), RecoverError.InvalidSignature);

        }



        return (signer, RecoverError.NoError);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `v`,

     * `r` and `s` signature fields separately.

     */

    function recover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from a `hash`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        // 32 is the length in bytes of hash,

        // enforced by the type signature above

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from `s`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", StringsUpgradeable.toString(s.length), s));

    }



    /**

     * @dev Returns an Ethereum Signed Typed Data, created from a

     * `domainSeparator` and a `structHash`. This produces hash corresponding

     * to the one signed with the

     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]

     * JSON-RPC method as part of EIP-712.

     *

     * See {recover}.

     */

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ERC1155BurnableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/extensions/ERC1155Burnable.sol)



pragma solidity ^0.8.0;



import "../ERC1155Upgradeable.sol";

import "../../../proxy/utils/Initializable.sol";



/**

 * @dev Extension of {ERC1155} that allows token holders to destroy both their

 * own tokens and those that they have been approved to use.

 *

 * _Available since v3.1._

 */

abstract contract ERC1155BurnableUpgradeable is Initializable, ERC1155Upgradeable {

    function __ERC1155Burnable_init() internal onlyInitializing {

    }



    function __ERC1155Burnable_init_unchained() internal onlyInitializing {

    }

    function burn(

        address account,

        uint256 id,

        uint256 value

    ) public virtual {

        require(

            account == _msgSender() || isApprovedForAll(account, _msgSender()),

            "ERC1155: caller is not token owner or approved"

        );



        _burn(account, id, value);

    }



    function burnBatch(

        address account,

        uint256[] memory ids,

        uint256[] memory values

    ) public virtual {

        require(

            account == _msgSender() || isApprovedForAll(account, _msgSender()),

            "ERC1155: caller is not token owner or approved"

        );



        _burnBatch(account, ids, values);

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[50] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ERC1155SupplyUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)



pragma solidity ^0.8.0;



import "../ERC1155Upgradeable.sol";

import "../../../proxy/utils/Initializable.sol";



/**

 * @dev Extension of ERC1155 that adds tracking of total supply per id.

 *

 * Useful for scenarios where Fungible and Non-fungible tokens have to be

 * clearly identified. Note: While a totalSupply of 1 might mean the

 * corresponding is an NFT, there is no guarantees that no other token with the

 * same id are not going to be minted.

 */

abstract contract ERC1155SupplyUpgradeable is Initializable, ERC1155Upgradeable {

    function __ERC1155Supply_init() internal onlyInitializing {

    }



    function __ERC1155Supply_init_unchained() internal onlyInitializing {

    }

    mapping(uint256 => uint256) private _totalSupply;



    /**

     * @dev Total amount of tokens in with a given id.

     */

    function totalSupply(uint256 id) public view virtual returns (uint256) {

        return _totalSupply[id];

    }



    /**

     * @dev Indicates whether any token exist with a given id, or not.

     */

    function exists(uint256 id) public view virtual returns (bool) {

        return ERC1155SupplyUpgradeable.totalSupply(id) > 0;

    }



    /**

     * @dev See {ERC1155-_beforeTokenTransfer}.

     */

    function _beforeTokenTransfer(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual override {

        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);



        if (from == address(0)) {

            for (uint256 i = 0; i < ids.length; ++i) {

                _totalSupply[ids[i]] += amounts[i];

            }

        }



        if (to == address(0)) {

            for (uint256 i = 0; i < ids.length; ++i) {

                uint256 id = ids[i];

                uint256 amount = amounts[i];

                uint256 supply = _totalSupply[id];

                require(supply >= amount, "ERC1155: burn amount exceeds totalSupply");

                unchecked {

                    _totalSupply[id] = supply - amount;

                }

            }

        }

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ERC1155Upgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)



pragma solidity ^0.8.0;



import "./IERC1155Upgradeable.sol";

import "./IERC1155ReceiverUpgradeable.sol";

import "./extensions/IERC1155MetadataURIUpgradeable.sol";

import "../../utils/AddressUpgradeable.sol";

import "../../utils/ContextUpgradeable.sol";

import "../../utils/introspection/ERC165Upgradeable.sol";

import "../../proxy/utils/Initializable.sol";



/**

 * @dev Implementation of the basic standard multi-token.

 * See https://eips.ethereum.org/EIPS/eip-1155

 * Originally based on code by Enjin: https://github.com/enjin/erc-1155

 *

 * _Available since v3.1._

 */

contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {

    using AddressUpgradeable for address;



    // Mapping from token ID to account balances

    mapping(uint256 => mapping(address => uint256)) private _balances;



    // Mapping from account to operator approvals

    mapping(address => mapping(address => bool)) private _operatorApprovals;



    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json

    string private _uri;



    /**

     * @dev See {_setURI}.

     */

    function __ERC1155_init(string memory uri_) internal onlyInitializing {

        __ERC1155_init_unchained(uri_);

    }



    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {

        _setURI(uri_);

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {

        return

            interfaceId == type(IERC1155Upgradeable).interfaceId ||

            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||

            super.supportsInterface(interfaceId);

    }



    /**

     * @dev See {IERC1155MetadataURI-uri}.

     *

     * This implementation returns the same URI for *all* token types. It relies

     * on the token type ID substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * Clients calling this function must replace the `\{id\}` substring with the

     * actual token type ID.

     */

    function uri(uint256) public view virtual override returns (string memory) {

        return _uri;

    }



    /**

     * @dev See {IERC1155-balanceOf}.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {

        require(account != address(0), "ERC1155: address zero is not a valid owner");

        return _balances[id][account];

    }



    /**

     * @dev See {IERC1155-balanceOfBatch}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)

        public

        view

        virtual

        override

        returns (uint256[] memory)

    {

        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");



        uint256[] memory batchBalances = new uint256[](accounts.length);



        for (uint256 i = 0; i < accounts.length; ++i) {

            batchBalances[i] = balanceOf(accounts[i], ids[i]);

        }



        return batchBalances;

    }



    /**

     * @dev See {IERC1155-setApprovalForAll}.

     */

    function setApprovalForAll(address operator, bool approved) public virtual override {

        _setApprovalForAll(_msgSender(), operator, approved);

    }



    /**

     * @dev See {IERC1155-isApprovedForAll}.

     */

    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {

        return _operatorApprovals[account][operator];

    }



    /**

     * @dev See {IERC1155-safeTransferFrom}.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) public virtual override {

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: caller is not token owner or approved"

        );

        _safeTransferFrom(from, to, id, amount, data);

    }



    /**

     * @dev See {IERC1155-safeBatchTransferFrom}.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) public virtual override {

        require(

            from == _msgSender() || isApprovedForAll(from, _msgSender()),

            "ERC1155: caller is not token owner or approved"

        );

        _safeBatchTransferFrom(from, to, ids, amounts, data);

    }



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function _safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: transfer to the zero address");



        address operator = _msgSender();

        uint256[] memory ids = _asSingletonArray(id);

        uint256[] memory amounts = _asSingletonArray(amount);



        _beforeTokenTransfer(operator, from, to, ids, amounts, data);



        uint256 fromBalance = _balances[id][from];

        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");

        unchecked {

            _balances[id][from] = fromBalance - amount;

        }

        _balances[id][to] += amount;



        emit TransferSingle(operator, from, to, id, amount);



        _afterTokenTransfer(operator, from, to, ids, amounts, data);



        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function _safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        require(to != address(0), "ERC1155: transfer to the zero address");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; ++i) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 fromBalance = _balances[id][from];

            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");

            unchecked {

                _balances[id][from] = fromBalance - amount;

            }

            _balances[id][to] += amount;

        }



        emit TransferBatch(operator, from, to, ids, amounts);



        _afterTokenTransfer(operator, from, to, ids, amounts, data);



        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);

    }



    /**

     * @dev Sets a new URI for all token types, by relying on the token type ID

     * substitution mechanism

     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].

     *

     * By this mechanism, any occurrence of the `\{id\}` substring in either the

     * URI or any of the amounts in the JSON file at said URI will be replaced by

     * clients with the token type ID.

     *

     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be

     * interpreted by clients as

     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`

     * for token type ID 0x4cce0.

     *

     * See {uri}.

     *

     * Because these URIs cannot be meaningfully represented by the {URI} event,

     * this function emits no events.

     */

    function _setURI(string memory newuri) internal virtual {

        _uri = newuri;

    }



    /**

     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function _mint(

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: mint to the zero address");



        address operator = _msgSender();

        uint256[] memory ids = _asSingletonArray(id);

        uint256[] memory amounts = _asSingletonArray(amount);



        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);



        _balances[id][to] += amount;

        emit TransferSingle(operator, address(0), to, id, amount);



        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);



        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function _mintBatch(

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        require(to != address(0), "ERC1155: mint to the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);



        for (uint256 i = 0; i < ids.length; i++) {

            _balances[ids[i]][to] += amounts[i];

        }



        emit TransferBatch(operator, address(0), to, ids, amounts);



        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);



        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);

    }



    /**

     * @dev Destroys `amount` tokens of token type `id` from `from`

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `from` must have at least `amount` tokens of token type `id`.

     */

    function _burn(

        address from,

        uint256 id,

        uint256 amount

    ) internal virtual {

        require(from != address(0), "ERC1155: burn from the zero address");



        address operator = _msgSender();

        uint256[] memory ids = _asSingletonArray(id);

        uint256[] memory amounts = _asSingletonArray(amount);



        _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");



        uint256 fromBalance = _balances[id][from];

        require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");

        unchecked {

            _balances[id][from] = fromBalance - amount;

        }



        emit TransferSingle(operator, from, address(0), id, amount);



        _afterTokenTransfer(operator, from, address(0), ids, amounts, "");

    }



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     */

    function _burnBatch(

        address from,

        uint256[] memory ids,

        uint256[] memory amounts

    ) internal virtual {

        require(from != address(0), "ERC1155: burn from the zero address");

        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");



        address operator = _msgSender();



        _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");



        for (uint256 i = 0; i < ids.length; i++) {

            uint256 id = ids[i];

            uint256 amount = amounts[i];



            uint256 fromBalance = _balances[id][from];

            require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");

            unchecked {

                _balances[id][from] = fromBalance - amount;

            }

        }



        emit TransferBatch(operator, from, address(0), ids, amounts);



        _afterTokenTransfer(operator, from, address(0), ids, amounts, "");

    }



    /**

     * @dev Approve `operator` to operate on all of `owner` tokens

     *

     * Emits an {ApprovalForAll} event.

     */

    function _setApprovalForAll(

        address owner,

        address operator,

        bool approved

    ) internal virtual {

        require(owner != operator, "ERC1155: setting approval status for self");

        _operatorApprovals[owner][operator] = approved;

        emit ApprovalForAll(owner, operator, approved);

    }



    /**

     * @dev Hook that is called before any token transfer. This includes minting

     * and burning, as well as batched variants.

     *

     * The same hook is called on both single and batched variants. For single

     * transfers, the length of the `ids` and `amounts` arrays will be 1.

     *

     * Calling conditions (for each `id` and `amount` pair):

     *

     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * of token type `id` will be  transferred to `to`.

     * - When `from` is zero, `amount` tokens of token type `id` will be minted

     * for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`

     * will be burned.

     * - `from` and `to` are never both zero.

     * - `ids` and `amounts` have the same, non-zero length.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _beforeTokenTransfer(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    /**

     * @dev Hook that is called after any token transfer. This includes minting

     * and burning, as well as batched variants.

     *

     * The same hook is called on both single and batched variants. For single

     * transfers, the length of the `id` and `amount` arrays will be 1.

     *

     * Calling conditions (for each `id` and `amount` pair):

     *

     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens

     * of token type `id` will be  transferred to `to`.

     * - When `from` is zero, `amount` tokens of token type `id` will be minted

     * for `to`.

     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`

     * will be burned.

     * - `from` and `to` are never both zero.

     * - `ids` and `amounts` have the same, non-zero length.

     *

     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].

     */

    function _afterTokenTransfer(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    function _doSafeTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {

                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non-ERC1155Receiver implementer");

            }

        }

    }



    function _doSafeBatchTransferAcceptanceCheck(

        address operator,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) private {

        if (to.isContract()) {

            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (

                bytes4 response

            ) {

                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {

                    revert("ERC1155: ERC1155Receiver rejected tokens");

                }

            } catch Error(string memory reason) {

                revert(reason);

            } catch {

                revert("ERC1155: transfer to non-ERC1155Receiver implementer");

            }

        }

    }



    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {

        uint256[] memory array = new uint256[](1);

        array[0] = element;



        return array;

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[47] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ERC165Upgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)



pragma solidity ^0.8.0;



import "./IERC165Upgradeable.sol";

import "../../proxy/utils/Initializable.sol";



/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check

 * for the additional interface id that will be supported. For example:

 *

 * ```solidity

 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);

 * }

 * ```

 *

 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.

 */

abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {

    function __ERC165_init() internal onlyInitializing {

    }



    function __ERC165_init_unchained() internal onlyInitializing {

    }

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IERC165Upgradeable).interfaceId;

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[50] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ERC1967Proxy.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)



pragma solidity ^0.8.0;



import "../Proxy.sol";

import "./ERC1967Upgrade.sol";



/**

 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an

 * implementation address that can be changed. This address is stored in storage in the location specified by

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the

 * implementation behind the proxy.

 */

contract ERC1967Proxy is Proxy, ERC1967Upgrade {

    /**

     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.

     *

     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded

     * function call, and allows initializing the storage of the proxy like a Solidity constructor.

     */

    constructor(address _logic, bytes memory _data) payable {

        _upgradeToAndCall(_logic, _data, false);

    }



    /**

     * @dev Returns the current implementation address.

     */

    function _implementation() internal view virtual override returns (address impl) {

        return ERC1967Upgrade._getImplementation();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ERC1967Upgrade.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)



pragma solidity ^0.8.2;



import "../beacon/IBeacon.sol";

import "../../interfaces/draft-IERC1822.sol";

import "../../utils/Address.sol";

import "../../utils/StorageSlot.sol";



/**

 * @dev This abstract contract provides getters and event emitting update functions for

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.

 *

 * _Available since v4.1._

 *

 * @custom:oz-upgrades-unsafe-allow delegatecall

 */

abstract contract ERC1967Upgrade {

    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1

    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;



    /**

     * @dev Storage slot with the address of the current implementation.

     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



    /**

     * @dev Emitted when the implementation is upgraded.

     */

    event Upgraded(address indexed implementation);



    /**

     * @dev Returns the current implementation address.

     */

    function _getImplementation() internal view returns (address) {

        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 implementation slot.

     */

    function _setImplementation(address newImplementation) private {

        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

    }



    /**

     * @dev Perform implementation upgrade

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeTo(address newImplementation) internal {

        _setImplementation(newImplementation);

        emit Upgraded(newImplementation);

    }



    /**

     * @dev Perform implementation upgrade with additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCall(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        _upgradeTo(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }

    }



    /**

     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCallUUPS(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        // Upgrades from old implementations will perform a rollback test. This test requires the new

        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing

        // this special case will break upgrade paths from old UUPS implementation to new ones.

        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {

            _setImplementation(newImplementation);

        } else {

            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {

                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");

            } catch {

                revert("ERC1967Upgrade: new implementation is not UUPS");

            }

            _upgradeToAndCall(newImplementation, data, forceCall);

        }

    }



    /**

     * @dev Storage slot with the admin of the contract.

     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



    /**

     * @dev Emitted when the admin account has changed.

     */

    event AdminChanged(address previousAdmin, address newAdmin);



    /**

     * @dev Returns the current admin.

     */

    function _getAdmin() internal view returns (address) {

        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 admin slot.

     */

    function _setAdmin(address newAdmin) private {

        require(newAdmin != address(0), "ERC1967: new admin is the zero address");

        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;

    }



    /**

     * @dev Changes the admin of the proxy.

     *

     * Emits an {AdminChanged} event.

     */

    function _changeAdmin(address newAdmin) internal {

        emit AdminChanged(_getAdmin(), newAdmin);

        _setAdmin(newAdmin);

    }



    /**

     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.

     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.

     */

    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;



    /**

     * @dev Emitted when the beacon is upgraded.

     */

    event BeaconUpgraded(address indexed beacon);



    /**

     * @dev Returns the current beacon.

     */

    function _getBeacon() internal view returns (address) {

        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;

    }



    /**

     * @dev Stores a new beacon in the EIP1967 beacon slot.

     */

    function _setBeacon(address newBeacon) private {

        require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");

        require(

            Address.isContract(IBeacon(newBeacon).implementation()),

            "ERC1967: beacon implementation is not a contract"

        );

        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;

    }



    /**

     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does

     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).

     *

     * Emits a {BeaconUpgraded} event.

     */

    function _upgradeBeaconToAndCall(

        address newBeacon,

        bytes memory data,

        bool forceCall

    ) internal {

        _setBeacon(newBeacon);

        emit BeaconUpgraded(newBeacon);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ERC2981Upgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)



pragma solidity ^0.8.0;



import "../../interfaces/IERC2981Upgradeable.sol";

import "../../utils/introspection/ERC165Upgradeable.sol";

import "../../proxy/utils/Initializable.sol";



/**

 * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.

 *

 * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for

 * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.

 *

 * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the

 * fee is specified in basis points by default.

 *

 * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See

 * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to

 * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.

 *

 * _Available since v4.5._

 */

abstract contract ERC2981Upgradeable is Initializable, IERC2981Upgradeable, ERC165Upgradeable {

    function __ERC2981_init() internal onlyInitializing {

    }



    function __ERC2981_init_unchained() internal onlyInitializing {

    }

    struct RoyaltyInfo {

        address receiver;

        uint96 royaltyFraction;

    }



    RoyaltyInfo private _defaultRoyaltyInfo;

    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {

        return interfaceId == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId);

    }



    /**

     * @inheritdoc IERC2981Upgradeable

     */

    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {

        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];



        if (royalty.receiver == address(0)) {

            royalty = _defaultRoyaltyInfo;

        }



        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();



        return (royalty.receiver, royaltyAmount);

    }



    /**

     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a

     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an

     * override.

     */

    function _feeDenominator() internal pure virtual returns (uint96) {

        return 10000;

    }



    /**

     * @dev Sets the royalty information that all ids in this contract will default to.

     *

     * Requirements:

     *

     * - `receiver` cannot be the zero address.

     * - `feeNumerator` cannot be greater than the fee denominator.

     */

    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {

        require(feeNumerator <= _feeDenominator(), "ERC2981: royalty fee will exceed salePrice");

        require(receiver != address(0), "ERC2981: invalid receiver");



        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);

    }



    /**

     * @dev Removes default royalty information.

     */

    function _deleteDefaultRoyalty() internal virtual {

        delete _defaultRoyaltyInfo;

    }



    /**

     * @dev Sets the royalty information for a specific token id, overriding the global default.

     *

     * Requirements:

     *

     * - `receiver` cannot be the zero address.

     * - `feeNumerator` cannot be greater than the fee denominator.

     */

    function _setTokenRoyalty(

        uint256 tokenId,

        address receiver,

        uint96 feeNumerator

    ) internal virtual {

        require(feeNumerator <= _feeDenominator(), "ERC2981: royalty fee will exceed salePrice");

        require(receiver != address(0), "ERC2981: Invalid parameters");



        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);

    }



    /**

     * @dev Resets royalty information for the token id back to the global default.

     */

    function _resetTokenRoyalty(uint256 tokenId) internal virtual {

        delete _tokenRoyaltyInfo[tokenId];

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[48] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Events.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: MIT OR Apache-2.0







import "./Upgradeable.sol";

import "./Operations.sol";



/// @title zkSync events

/// @author Matter Labs

interface Events {

    /// @notice Event emitted when a block is committed

    event BlockCommit(uint32 indexed blockNumber);



    /// @notice Event emitted when a block is verified

    event BlockVerification(uint32 indexed blockNumber);



    /// @notice Event emitted when user funds are withdrawn from the zkSync state and contract

    event Withdrawal(uint16 indexed tokenId, uint128 amount);



    /// @notice Event emitted when user funds are withdrawn from the zkSync state but not from contract

    event WithdrawalPending(uint16 indexed tokenId, address indexed recepient, uint128 amount);



    /// @notice Event emitted when user NFT is withdrawn from the zkSync state and contract

    event WithdrawalNFT(uint32 indexed tokenId);



    /// @notice Event emitted when user NFT is withdrawn from the zkSync state but not from contract

    event WithdrawalNFTPending(uint32 indexed tokenId);



    /// @notice Event emitted when user funds are deposited to the zkSync contract

    event Deposit(uint16 indexed tokenId, uint128 amount);



    /// @notice Event emitted when user sends a authentication fact (e.g. pub-key hash)

    event FactAuth(address indexed sender, uint32 nonce, bytes fact);



    /// @notice Event emitted when blocks are reverted

    event BlocksRevert(uint32 totalBlocksVerified, uint32 totalBlocksCommitted);



    /// @notice Exodus mode entered event

    event ExodusMode();



    /// @notice New priority request event. Emitted when a request is placed into mapping

    event NewPriorityRequest(

        address sender,

        uint64 serialId,

        Operations.OpType opType,

        bytes pubData,

        uint256 expirationBlock

    );



    /// @notice Deposit committed event.

    event DepositCommit(

        uint32 indexed zkSyncBlockId,

        uint32 indexed accountId,

        address owner,

        uint16 indexed tokenId,

        uint128 amount

    );



    /// @notice Full exit committed event.

    event FullExitCommit(

        uint32 indexed zkSyncBlockId,

        uint32 indexed accountId,

        address owner,

        uint16 indexed tokenId,

        uint128 amount

    );



    /// @notice Approve cut of upgrade notice period by addr

    event ApproveCutUpgradeNoticePeriod(address indexed addr);



    /// @notice Notice period changed

    event NoticePeriodChange(uint256 newNoticePeriod);

}



/// @title Upgrade events

/// @author Matter Labs

interface UpgradeEvents {

    /// @notice Event emitted when new upgradeable contract is added to upgrade gatekeeper's list of managed contracts

    event NewUpgradable(uint256 indexed versionId, address indexed upgradeable);



    /// @notice Upgrade mode enter event

    event NoticePeriodStart(

        uint256 indexed versionId,

        address[] newTargets,

        uint256 noticePeriod // notice period (in seconds)

    );



    /// @notice Upgrade mode cancel event

    event UpgradeCancel(uint256 indexed versionId);



    /// @notice Upgrade mode preparation status event

    event PreparationStart(uint256 indexed versionId);



    /// @notice Upgrade mode complete event

    event UpgradeComplete(uint256 indexed versionId, address[] newTargets);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Executor.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "./Base.sol";

import "../Config.sol";

import "../interfaces/IExecutor.sol";

import "../libraries/PairingsBn254.sol";

import "../libraries/PriorityQueue.sol";

import "../../common/libraries/UncheckedMath.sol";

import "../../common/libraries/UnsafeBytes.sol";

import "../../common/libraries/L2ContractHelper.sol";

import "../../common/L2ContractAddresses.sol";



/// @title zkSync Executor contract capable of processing events emitted in the zkSync protocol.

/// @author Matter Labs

contract ExecutorFacet is Base, IExecutor {

    using UncheckedMath for uint256;

    using PriorityQueue for PriorityQueue.Queue;



    /// @dev Process one block commit using the previous block StoredBlockInfo

    /// @dev returns new block StoredBlockInfo

    /// @notice Does not change storage

    function _commitOneBlock(StoredBlockInfo memory _previousBlock, CommitBlockInfo calldata _newBlock)

        internal

        view

        returns (StoredBlockInfo memory)

    {

        require(_newBlock.blockNumber == _previousBlock.blockNumber + 1, "f"); // only commit next block



        // Check that block contain all meta information for L2 logs.

        // Get the chained hash of priority transaction hashes.

        (

            uint256 expectedNumberOfLayer1Txs,

            bytes32 expectedPriorityOperationsHash,

            bytes32 previousBlockHash,

            uint256 l2BlockTimestamp

        ) = _processL2Logs(_newBlock);



        require(_previousBlock.blockHash == previousBlockHash, "l");

        // Check that the priority operation hash in the L2 logs is as expected

        require(expectedPriorityOperationsHash == _newBlock.priorityOperationsHash, "t");

        // Check that the number of processed priority operations is as expected

        require(expectedNumberOfLayer1Txs == _newBlock.numberOfLayer1Txs, "ta");

        // Check that the timestamp that came from the Bootloader is expected

        require(l2BlockTimestamp == _newBlock.timestamp, "tb");



        // Preventing "stack too deep error"

        {

            // Check the timestamp of the new block

            bool timestampNotTooSmall = block.timestamp - COMMIT_TIMESTAMP_NOT_OLDER <= l2BlockTimestamp;

            bool timestampNotTooBig = l2BlockTimestamp <= block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA;

            require(timestampNotTooSmall, "h"); // New block timestamp is too small

            require(timestampNotTooBig, "h1"); // New block timestamp is too big



            // Check the index of repeated storage writes

            uint256 newStorageChangesIndexes = uint256(uint32(bytes4(_newBlock.initialStorageChanges[:4])));

            require(

                _previousBlock.indexRepeatedStorageChanges + newStorageChangesIndexes ==

                    _newBlock.indexRepeatedStorageChanges,

                "yq"

            );



            // NOTE: We don't check that _newBlock.timestamp > _previousBlock.timestamp, it is checked inside the L2

        }



        // Create block commitment for the proof verification

        bytes32 commitment = _createBlockCommitment(_newBlock);



        return

            StoredBlockInfo(

                _newBlock.blockNumber,

                _newBlock.newStateRoot,

                _newBlock.indexRepeatedStorageChanges,

                _newBlock.numberOfLayer1Txs,

                _newBlock.priorityOperationsHash,

                _newBlock.l2LogsTreeRoot,

                _newBlock.timestamp,

                commitment

            );

    }



    /// @dev Check that L2 logs are proper and block contain all meta information for them

    function _processL2Logs(CommitBlockInfo calldata _newBlock)

        internal

        pure

        returns (

            uint256 numberOfLayer1Txs,

            bytes32 chainedPriorityTxsHash,

            bytes32 previousBlockHash,

            uint256 blockTimestamp

        )

    {

        // Copy L2 to L1 logs into memory.

        bytes memory emittedL2Logs = _newBlock.l2Logs[4:];

        bytes[] calldata l2Messages = _newBlock.l2ArbitraryLengthMessages;

        uint256 currentMessage;

        // Auxiliary variable that is needed to enforce that `previousBlockHash` and `blockTimestamp` was read exactly one time

        bool isSystemContextLogProcessed;

        bytes[] calldata factoryDeps = _newBlock.factoryDeps;

        uint256 currentBytecode;



        chainedPriorityTxsHash = EMPTY_STRING_KECCAK;



        // linear traversal of the logs

        for (uint256 i = 0; i < emittedL2Logs.length; i = i.uncheckedAdd(L2_TO_L1_LOG_SERIALIZE_SIZE)) {

            (address logSender, ) = UnsafeBytes.readAddress(emittedL2Logs, i + 4);



            // show preimage for hashed message stored in log

            if (logSender == L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR) {

                (bytes32 hashedMessage, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 56);

                require(keccak256(l2Messages[currentMessage]) == hashedMessage, "k2");



                currentMessage = currentMessage.uncheckedInc();

            } else if (logSender == L2_BOOTLOADER_ADDRESS) {

                (bytes32 canonicalTxHash, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 24);

                chainedPriorityTxsHash = keccak256(abi.encode(chainedPriorityTxsHash, canonicalTxHash));



                // Overflow is not realistic

                numberOfLayer1Txs = numberOfLayer1Txs.uncheckedInc();

            } else if (logSender == L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR) {

                // Make sure that the system context log wasn't processed yet, to

                // avoid accident double reading `blockTimestamp` and `previousBlockHash`

                require(!isSystemContextLogProcessed, "fx");

                (blockTimestamp, ) = UnsafeBytes.readUint256(emittedL2Logs, i + 24);

                (previousBlockHash, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 56);

                // Mark system context log as processed

                isSystemContextLogProcessed = true;

            } else if (logSender == L2_KNOWN_CODE_STORAGE_SYSTEM_CONTRACT_ADDR) {

                (bytes32 bytecodeHash, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 24);

                require(bytecodeHash == L2ContractHelper.hashL2Bytecode(factoryDeps[currentBytecode]), "k3");



                currentBytecode = currentBytecode.uncheckedInc();

            }

        }

        // To check that only relevant preimages have been included in the calldata

        require(currentBytecode == factoryDeps.length, "ym");

        require(currentMessage == l2Messages.length, "pl");

        // `blockTimestamp` and `previousBlockHash` wasn't read from L2 logs

        require(isSystemContextLogProcessed, "by");

    }



    /// @notice Commit block

    /// @notice 1. Checks timestamp.

    /// @notice 2. Process L2 logs.

    /// @notice 3. Store block commitments.

    function commitBlocks(StoredBlockInfo memory _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)

        external

        override

        nonReentrant

        onlyValidator

    {

        // Check that we commit blocks after last committed block

        require(s.storedBlockHashes[s.totalBlocksCommitted] == _hashStoredBlockInfo(_lastCommittedBlockData), "i"); // incorrect previous block data



        uint256 blocksLength = _newBlocksData.length;

        for (uint256 i = 0; i < blocksLength; i = i.uncheckedInc()) {

            _lastCommittedBlockData = _commitOneBlock(_lastCommittedBlockData, _newBlocksData[i]);

            s.storedBlockHashes[_lastCommittedBlockData.blockNumber] = _hashStoredBlockInfo(_lastCommittedBlockData);



            emit BlockCommit(

                _lastCommittedBlockData.blockNumber,

                _lastCommittedBlockData.blockHash,

                _lastCommittedBlockData.commitment

            );

        }



        s.totalBlocksCommitted = s.totalBlocksCommitted + blocksLength;

    }



    /// @dev Pops the priority operations from the priority queue and returns a rolling hash of operations

    function _collectOperationsFromPriorityQueue(uint256 _nPriorityOps) internal returns (bytes32 concatHash) {

        concatHash = EMPTY_STRING_KECCAK;



        for (uint256 i = 0; i < _nPriorityOps; i = i.uncheckedInc()) {

            PriorityOperation memory priorityOp = s.priorityQueue.popFront();

            concatHash = keccak256(abi.encode(concatHash, priorityOp.canonicalTxHash));

        }

    }



    /// @dev Executes one block

    /// @dev 1. Processes all pending operations (Complete priority requests)

    /// @dev 2. Finalizes block on Ethereum

    /// @dev _executedBlockIdx is an index in the array of the blocks that we want to execute together

    function _executeOneBlock(StoredBlockInfo memory _storedBlock, uint256 _executedBlockIdx) internal {

        uint256 currentBlockNumber = _storedBlock.blockNumber;

        require(currentBlockNumber == s.totalBlocksExecuted + _executedBlockIdx + 1, "k"); // Execute blocks in order

        require(

            _hashStoredBlockInfo(_storedBlock) == s.storedBlockHashes[currentBlockNumber],

            "exe10" // executing block should be committed

        );



        bytes32 priorityOperationsHash = _collectOperationsFromPriorityQueue(_storedBlock.numberOfLayer1Txs);

        require(priorityOperationsHash == _storedBlock.priorityOperationsHash, "x"); // priority operations hash does not match to expected



        // Save root hash of L2 -> L1 logs tree

        s.l2LogsRootHashes[currentBlockNumber] = _storedBlock.l2LogsTreeRoot;

    }



    /// @notice Execute blocks, complete priority operations and process withdrawals.

    /// @notice 1. Processes all pending operations (Complete priority requests)

    /// @notice 2. Finalizes block on Ethereum

    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external nonReentrant onlyValidator {

        uint256 nBlocks = _blocksData.length;

        for (uint256 i = 0; i < nBlocks; i = i.uncheckedInc()) {

            _executeOneBlock(_blocksData[i], i);

            emit BlockExecution(_blocksData[i].blockNumber, _blocksData[i].blockHash, _blocksData[i].commitment);

        }



        s.totalBlocksExecuted = s.totalBlocksExecuted + nBlocks;

        require(s.totalBlocksExecuted <= s.totalBlocksVerified, "n"); // Can't execute blocks more than committed and proven currently.

    }



    /// @notice Blocks commitment verification.

    /// @notice Only verifies block commitments without any other processing

    function proveBlocks(

        StoredBlockInfo calldata _prevBlock,

        StoredBlockInfo[] calldata _committedBlocks,

        ProofInput calldata _proof

    ) external nonReentrant onlyValidator {

        // Save the variables into the stack to save gas on reading them later

        uint256 currentTotalBlocksVerified = s.totalBlocksVerified;

        uint256 committedBlocksLength = _committedBlocks.length;



        // Save the variable from the storage to memory to save gas

        VerifierParams memory verifierParams = s.verifierParams;



        // Initialize the array, that will be used as public input to the ZKP

        uint256[] memory proofPublicInput = new uint256[](committedBlocksLength);



        // Check that the block passed by the validator is indeed the first unverified block

        require(_hashStoredBlockInfo(_prevBlock) == s.storedBlockHashes[currentTotalBlocksVerified], "t1");



        bytes32 prevBlockCommitment = _prevBlock.commitment;

        for (uint256 i = 0; i < committedBlocksLength; i = i.uncheckedInc()) {

            currentTotalBlocksVerified = currentTotalBlocksVerified.uncheckedInc();

            require(_hashStoredBlockInfo(_committedBlocks[i]) == s.storedBlockHashes[currentTotalBlocksVerified], "o1");



            bytes32 currentBlockCommitment = _committedBlocks[i].commitment;

            proofPublicInput[i] = _getBlockProofPublicInput(

                prevBlockCommitment,

                currentBlockCommitment,

                _proof,

                verifierParams

            );



            prevBlockCommitment = currentBlockCommitment;

        }

        require(currentTotalBlocksVerified <= s.totalBlocksCommitted, "q");



        bool successVerifyProof = s.verifier.verify_serialized_proof(proofPublicInput, _proof.serializedProof);

        require(successVerifyProof, "p"); // Proof verification fail



        // Verify the recursive part that was given to us through the public input

        bool successProofAggregation = _verifyRecursivePartOfProof(_proof.recursiveAggregationInput);

        require(successProofAggregation, "hh"); // Proof aggregation must be valid



        emit BlocksVerification(s.totalBlocksVerified, currentTotalBlocksVerified);

        s.totalBlocksVerified = currentTotalBlocksVerified;

    }



    /// @dev Gets zk proof public input

    function _getBlockProofPublicInput(

        bytes32 _prevBlockCommitment,

        bytes32 _currentBlockCommitment,

        ProofInput calldata _proof,

        VerifierParams memory _verifierParams

    ) internal pure returns (uint256) {

        return

            uint256(

                keccak256(

                    abi.encodePacked(

                        _prevBlockCommitment,

                        _currentBlockCommitment,

                        _verifierParams.recursionNodeLevelVkHash,

                        _verifierParams.recursionLeafLevelVkHash,

                        _verifierParams.recursionCircuitsSetVksHash,

                        _proof.recursiveAggregationInput

                    )

                )

            ) & INPUT_MASK;

    }



    /// @dev Verify a part of the zkp, that is responsible for the aggregation

    function _verifyRecursivePartOfProof(uint256[] calldata _recursiveAggregationInput) internal view returns (bool) {

        require(_recursiveAggregationInput.length == 4, "vr");



        PairingsBn254.G1Point memory pairWithGen = PairingsBn254.new_g1_checked(

            _recursiveAggregationInput[0],

            _recursiveAggregationInput[1]

        );

        PairingsBn254.G1Point memory pairWithX = PairingsBn254.new_g1_checked(

            _recursiveAggregationInput[2],

            _recursiveAggregationInput[3]

        );



        PairingsBn254.G2Point memory g2Gen = PairingsBn254.new_g2(

            [

                0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,

                0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed

            ],

            [

                0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,

                0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa

            ]

        );

        PairingsBn254.G2Point memory g2X = PairingsBn254.new_g2(

            [

                0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,

                0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0

            ],

            [

                0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,

                0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55

            ]

        );



        return PairingsBn254.pairingProd2(pairWithGen, g2Gen, pairWithX, g2X);

    }



    /// @notice Reverts unexecuted blocks

    /// @param _newLastBlock block number after which blocks should be reverted

    /// NOTE: Doesn't delete the stored data about blocks, but only decreases

    /// counters that are responsible for the number of blocks

    function revertBlocks(uint256 _newLastBlock) external nonReentrant onlyValidator {

        require(s.totalBlocksCommitted > _newLastBlock, "v1"); // The last committed block is less than new last block

        uint256 newTotalBlocksCommitted = _maxU256(_newLastBlock, s.totalBlocksExecuted);



        if (newTotalBlocksCommitted < s.totalBlocksVerified) {

            s.totalBlocksVerified = newTotalBlocksCommitted;

        }

        s.totalBlocksCommitted = newTotalBlocksCommitted;



        emit BlocksRevert(s.totalBlocksCommitted, s.totalBlocksVerified, s.totalBlocksExecuted);

    }



    /// @notice Returns larger of two values

    function _maxU256(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? b : a;

    }



    /// @dev Creates block commitment from its data

    function _createBlockCommitment(CommitBlockInfo calldata _newBlockData) internal view returns (bytes32) {

        bytes32 passThroughDataHash = keccak256(_blockPassThroughData(_newBlockData));

        bytes32 metadataHash = keccak256(_blockMetaParameters());

        bytes32 auxiliaryOutputHash = keccak256(_blockAuxiliaryOutput(_newBlockData));



        return keccak256(abi.encode(passThroughDataHash, metadataHash, auxiliaryOutputHash));

    }



    function _blockPassThroughData(CommitBlockInfo calldata _block) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                _block.indexRepeatedStorageChanges,

                _block.newStateRoot,

                uint64(0), // index repeated storage changes in zkPorter

                bytes32(0) // zkPorter block hash

            );

    }



    function _blockMetaParameters() internal view returns (bytes memory) {

        return abi.encodePacked(s.zkPorterIsAvailable, s.l2BootloaderBytecodeHash, s.l2DefaultAccountBytecodeHash);

    }



    function _blockAuxiliaryOutput(CommitBlockInfo calldata _block) internal pure returns (bytes memory) {

        require(_block.initialStorageChanges.length <= MAX_INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES, "pf");

        require(_block.repeatedStorageChanges.length <= MAX_REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES, "py");

        require(_block.l2Logs.length <= MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES, "pu");



        bytes32 initialStorageChangesHash = keccak256(_block.initialStorageChanges);

        bytes32 repeatedStorageChangesHash = keccak256(_block.repeatedStorageChanges);

        bytes32 l2ToL1LogsHash = keccak256(_block.l2Logs);



        return abi.encode(_block.l2LogsTreeRoot, l2ToL1LogsHash, initialStorageChangesHash, repeatedStorageChangesHash);

    }



    /// @notice Returns the keccak hash of the ABI-encoded StoredBlockInfo

    function _hashStoredBlockInfo(StoredBlockInfo memory _storedBlockInfo) internal pure returns (bytes32) {

        return keccak256(abi.encode(_storedBlockInfo));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Getters.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "./Base.sol";

import "../libraries/Diamond.sol";

import "../libraries/PriorityQueue.sol";

import "../../common/libraries/UncheckedMath.sol";

import "../interfaces/IGetters.sol";



/// @title Getters Contract implements functions for getting contract state from outside the blockchain.

/// @author Matter Labs

contract GettersFacet is Base, IGetters {

    using UncheckedMath for uint256;

    using PriorityQueue for PriorityQueue.Queue;



    /*//////////////////////////////////////////////////////////////

                            CUSTOM GETTERS

    //////////////////////////////////////////////////////////////*/



    /// @return The address of the verifier smart contract

    function getVerifier() external view returns (address) {

        return address(s.verifier);

    }



    /// @return The address of the current governor

    function getGovernor() external view returns (address) {

        return s.governor;

    }



    /// @return The address of the pending governor

    function getPendingGovernor() external view returns (address) {

        return s.pendingGovernor;

    }



    /// @return The total number of blocks that were committed

    function getTotalBlocksCommitted() external view returns (uint256) {

        return s.totalBlocksCommitted;

    }



    /// @return The total number of blocks that were committed & verified

    function getTotalBlocksVerified() external view returns (uint256) {

        return s.totalBlocksVerified;

    }



    /// @return The total number of blocks that were committed & verified & executed

    function getTotalBlocksExecuted() external view returns (uint256) {

        return s.totalBlocksExecuted;

    }



    /// @return The total number of priority operations that were added to the priority queue, including all processed ones

    function getTotalPriorityTxs() external view returns (uint256) {

        return s.priorityQueue.getTotalPriorityTxs();

    }



    /// @notice Returns zero if and only if no operations were processed from the queue

    /// @notice Reverts if there are no unprocessed priority transactions

    /// @return Index of the oldest priority operation that wasn't processed yet

    function getFirstUnprocessedPriorityTx() external view returns (uint256) {

        return s.priorityQueue.getFirstUnprocessedPriorityTx();

    }



    /// @return The number of priority operations currently in the queue

    function getPriorityQueueSize() external view returns (uint256) {

        return s.priorityQueue.getSize();

    }



    /// @return The first unprocessed priority operation from the queue

    function priorityQueueFrontOperation() external view returns (PriorityOperation memory) {

        return s.priorityQueue.front();

    }



    /// @return Whether the address has a validator access

    function isValidator(address _address) external view returns (bool) {

        return s.validators[_address];

    }



    /// @return Merkle root of the tree with L2 logs for the selected block

    function l2LogsRootHash(uint256 _blockNumber) external view returns (bytes32) {

        return s.l2LogsRootHashes[_blockNumber];

    }



    /// @notice For unfinalized (non executed) blocks may change

    /// @dev returns zero for non-committed blocks

    /// @return The hash of committed L2 block.

    function storedBlockHash(uint256 _blockNumber) external view returns (bytes32) {

        return s.storedBlockHashes[_blockNumber];

    }



    /// @return Bytecode hash of bootloader program.

    function getL2BootloaderBytecodeHash() external view returns (bytes32) {

        return s.l2BootloaderBytecodeHash;

    }



    /// @return Bytecode hash of default account (bytecode for EOA).

    function getL2DefaultAccountBytecodeHash() external view returns (bytes32) {

        return s.l2DefaultAccountBytecodeHash;

    }



    /// @return Verifier parameters.

    function getVerifierParams() external view returns (VerifierParams memory) {

        return s.verifierParams;

    }



    /// @return The address of the security council multisig

    function getSecurityCouncil() external view returns (address) {

        return s.upgrades.securityCouncil;

    }



    /// @return Current upgrade proposal state

    function getUpgradeProposalState() external view returns (UpgradeState) {

        return s.upgrades.state;

    }



    /// @return The upgrade proposal hash if there is an active one and zero otherwise

    function getProposedUpgradeHash() external view returns (bytes32) {

        return s.upgrades.proposedUpgradeHash;

    }



    /// @return The timestamp when the upgrade was proposed, zero if there are no active proposals

    function getProposedUpgradeTimestamp() external view returns (uint256) {

        return s.upgrades.proposedUpgradeTimestamp;

    }



    /// @return The serial number of a proposed upgrade, increments when proposing a new one

    function getCurrentProposalId() external view returns (uint256) {

        return s.upgrades.currentProposalId;

    }



    /// @return The number of received upgrade approvals from the security council

    function isApprovedBySecurityCouncil() external view returns (bool) {

        return s.upgrades.approvedBySecurityCouncil;

    }



    /// @return Whether the diamond is frozen or not

    function isDiamondStorageFrozen() external view returns (bool) {

        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();

        return ds.isFrozen;

    }



    /// @return isFreezable Whether the facet can be frozen by the governor or always accessible

    function isFacetFreezable(address _facet) external view returns (bool isFreezable) {

        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();



        // There is no direct way to get whether the facet address is freezable,

        // so we get it from one of the selectors that are associated with the facet.

        uint256 selectorsArrayLen = ds.facetToSelectors[_facet].selectors.length;

        if (selectorsArrayLen != 0) {

            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];

            isFreezable = ds.selectorToFacet[selector0].isFreezable;

        }

    }



    /// @return The maximum number of L2 gas that a user can request for L1 -> L2 transactions

    function getPriorityTxMaxGasLimit() external view returns (uint256) {

        return s.priorityTxMaxGasLimit;

    }



    /// @return The allow list smart contract

    function getAllowList() external view returns (address) {

        return address(s.allowList);

    }



    /// @return Whether the selector can be frozen by the governor or always accessible

    function isFunctionFreezable(bytes4 _selector) external view returns (bool) {

        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();

        require(ds.selectorToFacet[_selector].facetAddress != address(0), "g2");

        return ds.selectorToFacet[_selector].isFreezable;

    }



    /// @return Whether a withdrawal has been finalized.

    /// @param _l2BlockNumber The L2 block number within which the withdrawal happened.

    /// @param _l2MessageIndex The index of the L2->L1 message denoting the withdrawal.

    function isEthWithdrawalFinalized(uint256 _l2BlockNumber, uint256 _l2MessageIndex) external view returns (bool) {

        return s.isEthWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex];

    }



    /*//////////////////////////////////////////////////////////////

                            DIAMOND LOUPE

     //////////////////////////////////////////////////////////////*/



    /// @return result All facet addresses and their function selectors

    function facets() external view returns (Facet[] memory result) {

        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();



        uint256 facetsLen = ds.facets.length;

        result = new Facet[](facetsLen);



        for (uint256 i = 0; i < facetsLen; i = i.uncheckedInc()) {

            address facetAddr = ds.facets[i];

            Diamond.FacetToSelectors memory facetToSelectors = ds.facetToSelectors[facetAddr];



            result[i] = Facet(facetAddr, facetToSelectors.selectors);

        }

    }



    /// @return NON-sorted array with function selectors supported by a specific facet

    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory) {

        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();

        return ds.facetToSelectors[_facet].selectors;

    }



    /// @return NON-sorted array of facet addresses supported on diamond

    function facetAddresses() external view returns (address[] memory) {

        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();

        return ds.facets;

    }



    /// @return Facet address associated with a selector. Zero if the selector is not added to the diamond

    function facetAddress(bytes4 _selector) external view returns (address) {

        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();

        return ds.selectorToFacet[_selector].facetAddress;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Governance.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: MIT OR Apache-2.0







import "./Config.sol";

import "./Utils.sol";

import "./NFTFactory.sol";

import "./TokenGovernance.sol";



/// @title Governance Contract

/// @author Matter Labs

contract Governance is Config {

    /// @notice Token added to Franklin net

    event NewToken(address indexed token, uint16 indexed tokenId);



    /// @notice Default nft factory has set

    event SetDefaultNFTFactory(address indexed factory);



    /// @notice NFT factory registered new creator account

    event NFTFactoryRegisteredCreator(

        uint32 indexed creatorAccountId,

        address indexed creatorAddress,

        address factoryAddress

    );



    /// @notice Governor changed

    event NewGovernor(address newGovernor);



    /// @notice Token Governance changed

    event NewTokenGovernance(TokenGovernance newTokenGovernance);



    /// @notice Validator's status changed

    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);



    event TokenPausedUpdate(address indexed token, bool paused);



    /// @notice Address which will exercise governance over the network i.e. add tokens, change validator set, conduct upgrades

    address public networkGovernor;



    /// @notice Total number of ERC20 tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)

    uint16 public totalTokens;



    /// @notice List of registered tokens by tokenId

    mapping(uint16 => address) public tokenAddresses;



    /// @notice List of registered tokens by address

    mapping(address => uint16) public tokenIds;



    /// @notice List of permitted validators

    mapping(address => bool) public validators;



    /// @notice Paused tokens list, deposits are impossible to create for paused tokens

    mapping(uint16 => bool) public pausedTokens;



    /// @notice Address that is authorized to add tokens to the Governance.

    TokenGovernance public tokenGovernance;



    /// @notice NFT Creator address to factory address mapping

    mapping(uint32 => mapping(address => NFTFactory)) public nftFactories;



    /// @notice Address which will be used if NFT token has no factories

    NFTFactory public defaultFactory;



    /// @notice Governance contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.

    /// @param initializationParameters Encoded representation of initialization parameters:

    ///     _networkGovernor The address of network governor

    function initialize(bytes calldata initializationParameters) external {

        address _networkGovernor = abi.decode(initializationParameters, (address));



        networkGovernor = _networkGovernor;

    }



    /// @notice Governance contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.

    /// @param upgradeParameters Encoded representation of upgrade parameters

    // solhint-disable-next-line no-empty-blocks

    function upgrade(bytes calldata upgradeParameters) external {}



    /// @notice Change current governor

    /// @param _newGovernor Address of the new governor

    function changeGovernor(address _newGovernor) external {

        requireGovernor(msg.sender);

        if (networkGovernor != _newGovernor) {

            networkGovernor = _newGovernor;

            emit NewGovernor(_newGovernor);

        }

    }



    /// @notice Change current token governance

    /// @param _newTokenGovernance Address of the new token governor

    function changeTokenGovernance(TokenGovernance _newTokenGovernance) external {

        requireGovernor(msg.sender);

        if (tokenGovernance != _newTokenGovernance) {

            tokenGovernance = _newTokenGovernance;

            emit NewTokenGovernance(_newTokenGovernance);

        }

    }



    /// @notice Add token to the list of networks tokens

    /// @param _token Token address

    function addToken(address _token) external {

        require(msg.sender == address(tokenGovernance), "1E");

        require(tokenIds[_token] == 0, "1e"); // token exists

        require(totalTokens < MAX_AMOUNT_OF_REGISTERED_TOKENS, "1f"); // no free identifiers for tokens



        totalTokens++;

        uint16 newTokenId = totalTokens; // it is not `totalTokens - 1` because tokenId = 0 is reserved for eth



        tokenAddresses[newTokenId] = _token;

        tokenIds[_token] = newTokenId;

        emit NewToken(_token, newTokenId);

    }



    /// @notice Pause token deposits for the given token

    /// @param _tokenAddr Token address

    /// @param _tokenPaused Token paused status

    function setTokenPaused(address _tokenAddr, bool _tokenPaused) external {

        requireGovernor(msg.sender);



        uint16 tokenId = this.validateTokenAddress(_tokenAddr);

        if (pausedTokens[tokenId] != _tokenPaused) {

            pausedTokens[tokenId] = _tokenPaused;

            emit TokenPausedUpdate(_tokenAddr, _tokenPaused);

        }

    }



    /// @notice Change validator status (active or not active)

    /// @param _validator Validator address

    /// @param _active Active flag

    function setValidator(address _validator, bool _active) external {

        requireGovernor(msg.sender);

        if (validators[_validator] != _active) {

            validators[_validator] = _active;

            emit ValidatorStatusUpdate(_validator, _active);

        }

    }



    /// @notice Check if specified address is is governor

    /// @param _address Address to check

    function requireGovernor(address _address) public view {

        require(_address == networkGovernor, "1g"); // only by governor

    }



    /// @notice Checks if validator is active

    /// @param _address Validator address

    function requireActiveValidator(address _address) external view {

        require(validators[_address], "1h"); // validator is not active

    }



    /// @notice Validate token id (must be less than or equal to total tokens amount)

    /// @param _tokenId Token id

    /// @return bool flag that indicates if token id is less than or equal to total tokens amount

    function isValidTokenId(uint16 _tokenId) external view returns (bool) {

        return _tokenId <= totalTokens;

    }



    /// @notice Validate token address

    /// @param _tokenAddr Token address

    /// @return tokens id

    function validateTokenAddress(address _tokenAddr) external view returns (uint16) {

        uint16 tokenId = tokenIds[_tokenAddr];

        require(tokenId != 0, "1i"); // 0 is not a valid token

        return tokenId;

    }



    function packRegisterNFTFactoryMsg(

        uint32 _creatorAccountId,

        address _creatorAddress,

        address _factoryAddress

    ) internal pure returns (bytes memory) {

        return

            abi.encodePacked(

                "\x19Ethereum Signed Message:\n141",

                "\nCreator's account ID in zkSync: ",

                Bytes.bytesToHexASCIIBytes(abi.encodePacked((_creatorAccountId))),

                "\nCreator: ",

                Bytes.bytesToHexASCIIBytes(abi.encodePacked((_creatorAddress))),

                "\nFactory: ",

                Bytes.bytesToHexASCIIBytes(abi.encodePacked((_factoryAddress)))

            );

    }



    /// @notice Register creator corresponding to the factory

    /// @param _creatorAccountId Creator's zkSync account ID

    /// @param _creatorAddress NFT creator address

    /// @param _signature Creator's signature

    function registerNFTFactoryCreator(

        uint32 _creatorAccountId,

        address _creatorAddress,

        bytes memory _signature

    ) external {

        require(address(nftFactories[_creatorAccountId][_creatorAddress]) == address(0), "Q");

        bytes32 messageHash = keccak256(packRegisterNFTFactoryMsg(_creatorAccountId, _creatorAddress, msg.sender));



        address recoveredAddress = Utils.recoverAddressFromEthSignature(_signature, messageHash);

        require(recoveredAddress == _creatorAddress, "ws");

        nftFactories[_creatorAccountId][_creatorAddress] = NFTFactory(msg.sender);

        emit NFTFactoryRegisteredCreator(_creatorAccountId, _creatorAddress, msg.sender);

    }



    /// @notice Set default factory for our contract. This factory will be used to mint an NFT token that has no factory

    /// @param _factory Address of NFT factory

    function setDefaultNFTFactory(address _factory) external {

        requireGovernor(msg.sender);

        require(address(_factory) != address(0), "mb1"); // Factory should be non zero

        require(address(defaultFactory) == address(0), "mb2"); // NFTFactory is already set

        defaultFactory = NFTFactory(_factory);

        emit SetDefaultNFTFactory(_factory);

    }



    function getNFTFactory(uint32 _creatorAccountId, address _creatorAddress) external view returns (NFTFactory) {

        NFTFactory _factory = nftFactories[_creatorAccountId][_creatorAddress];

        // even if the factory is undefined or has been destroyed, the user can mint NFT

        if (address(_factory) == address(0) || !isContract(address(_factory))) {

            require(address(defaultFactory) != address(0), "fs"); // NFTFactory does not set

            return defaultFactory;

        } else {

            return _factory;

        }

    }



    /// @return whether the address is a contract or not

    /// NOTE: for smart contracts that called `selfdestruct` will return a negative result

    function isContract(address _address) internal view returns (bool) {

        uint256 contractSize;

        assembly {

            contractSize := extcodesize(_address)

        }



        return contractSize != 0;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IAllowList.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







interface IAllowList {

    /*//////////////////////////////////////////////////////////////

                            EVENTS

    //////////////////////////////////////////////////////////////*/



    /// @notice Access mode of target contract is changed

    event UpdateAccessMode(address indexed target, AccessMode previousMode, AccessMode newMode);



    /// @notice Permission to call is changed

    event UpdateCallPermission(address indexed caller, address indexed target, bytes4 indexed functionSig, bool status);



    /// @notice Type of access to a specific contract includes three different modes

    /// @param Closed No one has access to the contract

    /// @param SpecialAccessOnly Any address with granted special access can interact with a contract (see `hasSpecialAccessToCall`)

    /// @param Public Everyone can interact with a contract

    enum AccessMode {

        Closed,

        SpecialAccessOnly,

        Public

    }



    /// @dev A struct that contains deposit limit data of a token

    /// @param depositLimitation Whether any deposit limitation is placed or not

    /// @param depositCap The maximum amount that can be deposited.

    struct Deposit {

        bool depositLimitation;

        uint256 depositCap;

    }



    /*//////////////////////////////////////////////////////////////

                            GETTERS

    //////////////////////////////////////////////////////////////*/



    function getAccessMode(address _target) external view returns (AccessMode);



    function hasSpecialAccessToCall(

        address _caller,

        address _target,

        bytes4 _functionSig

    ) external view returns (bool);



    function canCall(

        address _caller,

        address _target,

        bytes4 _functionSig

    ) external view returns (bool);



    function getTokenDepositLimitData(address _l1Token) external view returns (Deposit memory);



    /*//////////////////////////////////////////////////////////////

                           ALLOW LIST LOGIC

    //////////////////////////////////////////////////////////////*/



    function setBatchAccessMode(address[] calldata _targets, AccessMode[] calldata _accessMode) external;



    function setAccessMode(address _target, AccessMode _accessMode) external;



    function setBatchPermissionToCall(

        address[] calldata _callers,

        address[] calldata _targets,

        bytes4[] calldata _functionSigs,

        bool[] calldata _enables

    ) external;



    function setPermissionToCall(

        address _caller,

        address _target,

        bytes4 _functionSig,

        bool _enable

    ) external;



    /*//////////////////////////////////////////////////////////////

                           DEPOSIT LIMIT LOGIC

    //////////////////////////////////////////////////////////////*/



    function setDepositLimit(

        address _l1Token,

        bool _depositLimitation,

        uint256 _depositCap

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IBeacon.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)



pragma solidity ^0.8.0;



/**

 * @dev This is the interface that {BeaconProxy} expects of its beacon.

 */

interface IBeacon {

    /**

     * @dev Must return an address that can be used as a delegate call target.

     *

     * {BeaconProxy} will check that this address is a contract.

     */

    function implementation() external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IDiamondCut.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "../libraries/Diamond.sol";



interface IDiamondCut {

    function proposeTransparentUpgrade(Diamond.DiamondCutData calldata _diamondCut, uint40 _proposalId) external;



    function proposeShadowUpgrade(bytes32 _proposalHash, uint40 _proposalId) external;



    function cancelUpgradeProposal(bytes32 _proposedUpgradeHash) external;



    function securityCouncilUpgradeApprove(bytes32 _upgradeProposalHash) external;



    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut, bytes32 _proposalSalt) external;



    function freezeDiamond() external;



    function unfreezeDiamond() external;



    function upgradeProposalHash(

        Diamond.DiamondCutData calldata _diamondCut,

        uint256 _proposalId,

        bytes32 _salt

    ) external pure returns (bytes32);



    event ProposeTransparentUpgrade(

        Diamond.DiamondCutData diamondCut,

        uint256 indexed proposalId,

        bytes32 proposalSalt

    );



    event ProposeShadowUpgrade(uint256 indexed proposalId, bytes32 indexed proposalHash);



    event CancelUpgradeProposal(uint256 indexed proposalId, bytes32 indexed proposalHash);



    event SecurityCouncilUpgradeApprove(uint256 indexed proposalId, bytes32 indexed proposalHash);



    event ExecuteUpgrade(uint256 indexed proposalId, bytes32 indexed proposalHash, bytes32 proposalSalt);



    event Freeze();



    event Unfreeze();

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IERC1155MetadataURIUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)



pragma solidity ^0.8.0;



import "../IERC1155Upgradeable.sol";



/**

 * @dev Interface of the optional ERC1155MetadataExtension interface, as defined

 * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {

    /**

     * @dev Returns the URI for token type `id`.

     *

     * If the `\{id\}` substring is present in the URI, it must be replaced by

     * clients with the actual token type ID.

     */

    function uri(uint256 id) external view returns (string memory);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IERC1155ReceiverUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)



pragma solidity ^0.8.0;



import "../../utils/introspection/IERC165Upgradeable.sol";



/**

 * @dev _Available since v3.1._

 */

interface IERC1155ReceiverUpgradeable is IERC165Upgradeable {

    /**

     * @dev Handles the receipt of a single ERC1155 token type. This function is

     * called at the end of a `safeTransferFrom` after the balance has been updated.

     *

     * NOTE: To accept the transfer, this must return

     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

     * (i.e. 0xf23a6e61, or its own function selector).

     *

     * @param operator The address which initiated the transfer (i.e. msg.sender)

     * @param from The address which previously owned the token

     * @param id The ID of the token being transferred

     * @param value The amount of tokens being transferred

     * @param data Additional data with no specified format

     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed

     */

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    ) external returns (bytes4);



    /**

     * @dev Handles the receipt of a multiple ERC1155 token types. This function

     * is called at the end of a `safeBatchTransferFrom` after the balances have

     * been updated.

     *

     * NOTE: To accept the transfer(s), this must return

     * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

     * (i.e. 0xbc197c81, or its own function selector).

     *

     * @param operator The address which initiated the batch transfer (i.e. msg.sender)

     * @param from The address which previously owned the token

     * @param ids An array containing ids of each token being transferred (order and length must match values array)

     * @param values An array containing amounts of each token being transferred (order and length must match ids array)

     * @param data Additional data with no specified format

     * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed

     */

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    ) external returns (bytes4);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IERC1155Upgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)



pragma solidity ^0.8.0;



import "../../utils/introspection/IERC165Upgradeable.sol";



/**

 * @dev Required interface of an ERC1155 compliant contract, as defined in the

 * https://eips.ethereum.org/EIPS/eip-1155[EIP].

 *

 * _Available since v3.1._

 */

interface IERC1155Upgradeable is IERC165Upgradeable {

    /**

     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.

     */

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);



    /**

     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all

     * transfers.

     */

    event TransferBatch(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256[] ids,

        uint256[] values

    );



    /**

     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to

     * `approved`.

     */

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);



    /**

     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.

     *

     * If an {URI} event was emitted for `id`, the standard

     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value

     * returned by {IERC1155MetadataURI-uri}.

     */

    event URI(string value, uint256 indexed id);



    /**

     * @dev Returns the amount of tokens of token type `id` owned by `account`.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) external view returns (uint256);



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)

        external

        view

        returns (uint256[] memory);



    /**

     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,

     *

     * Emits an {ApprovalForAll} event.

     *

     * Requirements:

     *

     * - `operator` cannot be the caller.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.

     *

     * See {setApprovalForAll}.

     */

    function isApprovedForAll(address account, address operator) external view returns (bool);



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes calldata data

    ) external;



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IERC165Upgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165Upgradeable {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)



pragma solidity ^0.8.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);



    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `to`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address to, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `from` to `to` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address from,

        address to,

        uint256 amount

    ) external returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IERC20Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)



pragma solidity ^0.8.0;



import "../IERC20.sol";



/**

 * @dev Interface for the optional metadata functions from the ERC20 standard.

 *

 * _Available since v4.1._

 */

interface IERC20Metadata is IERC20 {

    /**

     * @dev Returns the name of the token.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the symbol of the token.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the decimals places of the token.

     */

    function decimals() external view returns (uint8);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IERC2981Upgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)



pragma solidity ^0.8.0;



import "../utils/introspection/IERC165Upgradeable.sol";



/**

 * @dev Interface for the NFT Royalty Standard.

 *

 * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal

 * support for royalty payments across all NFT marketplaces and ecosystem participants.

 *

 * _Available since v4.5._

 */

interface IERC2981Upgradeable is IERC165Upgradeable {

    /**

     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of

     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.

     */

    function royaltyInfo(uint256 tokenId, uint256 salePrice)

        external

        view

        returns (address receiver, uint256 royaltyAmount);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IExecutor.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







interface IExecutor {

    /// @notice Rollup block stored data

    /// @param blockNumber Rollup block number

    /// @param blockHash Hash of L2 block

    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more

    /// @param numberOfLayer1Txs Number of priority operations to be processed

    /// @param priorityOperationsHash Hash of all priority operations from this block

    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this block

    /// @param timestamp Rollup block timestamp, have the same format as Ethereum block constant

    /// @param commitment Verified input for the zkSync circuit

    struct StoredBlockInfo {

        uint64 blockNumber;

        bytes32 blockHash;

        uint64 indexRepeatedStorageChanges;

        uint256 numberOfLayer1Txs;

        bytes32 priorityOperationsHash;

        bytes32 l2LogsTreeRoot;

        uint256 timestamp;

        bytes32 commitment;

    }



    /// @notice Data needed to commit new block

    /// @param blockNumber Number of the committed block

    /// @param timestamp Unix timestamp denoting the start of the block execution

    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more

    /// @param newStateRoot The state root of the full state tree

    /// @param numberOfLayer1Txs Number of priority operations to be processed

    /// @param l2LogsTreeRoot The root hash of the tree that contains all L2 -> L1 logs in the block

    /// @param priorityOperationsHash Hash of all priority operations from this block

    /// @param initialStorageChanges Storage write access as a concatenation key-value

    /// @param repeatedStorageChanges Storage write access as a concatenation index-value

    /// @param l2Logs concatenation of all L2 -> L1 logs in the block

    /// @param l2ArbitraryLengthMessages array of hash preimages that were sent as value of L2 logs by special system L2 contract

    /// @param factoryDeps array of l2 bytecodes that were marked as known on L2

    struct CommitBlockInfo {

        uint64 blockNumber;

        uint64 timestamp;

        uint64 indexRepeatedStorageChanges;

        bytes32 newStateRoot;

        uint256 numberOfLayer1Txs;

        bytes32 l2LogsTreeRoot;

        bytes32 priorityOperationsHash;

        bytes initialStorageChanges;

        bytes repeatedStorageChanges;

        bytes l2Logs;

        bytes[] l2ArbitraryLengthMessages;

        bytes[] factoryDeps;

    }



    /// @notice Recursive proof input data (individual commitments are constructed onchain)

    struct ProofInput {

        uint256[] recursiveAggregationInput;

        uint256[] serializedProof;

    }



    function commitBlocks(StoredBlockInfo calldata _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)

        external;



    function proveBlocks(

        StoredBlockInfo calldata _prevBlock,

        StoredBlockInfo[] calldata _committedBlocks,

        ProofInput calldata _proof

    ) external;



    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external;



    function revertBlocks(uint256 _newLastBlock) external;



    /// @notice Event emitted when a block is committed

    event BlockCommit(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);



    /// @notice Event emitted when blocks are verified

    event BlocksVerification(uint256 indexed previousLastVerifiedBlock, uint256 indexed currentLastVerifiedBlock);



    /// @notice Event emitted when a block is executed

    event BlockExecution(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);



    /// @notice Event emitted when blocks are reverted

    event BlocksRevert(uint256 totalBlocksCommitted, uint256 totalBlocksVerified, uint256 totalBlocksExecuted);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IGetters.sol
File type: .sol
pragma solidity ^0.8.13;

// SPDX-License-Identifier: MIT



import "../Storage.sol";
import "../libraries/PriorityQueue.sol";
import {VerifierParams} from "../Storage.sol";

interface IGetters {
    /*//////////////////////////////////////////////////////////////
                            CUSTOM GETTERS
    //////////////////////////////////////////////////////////////*/

    function getVerifier() external view returns (address);

    function getGovernor() external view returns (address);

    function getPendingGovernor() external view returns (address);

    function getTotalBlocksCommitted() external view returns (uint256);

    function getTotalBlocksVerified() external view returns (uint256);

    function getTotalBlocksExecuted() external view returns (uint256);

    function getTotalPriorityTxs() external view returns (uint256);

    function getFirstUnprocessedPriorityTx() external view returns (uint256);

    function getPriorityQueueSize() external view returns (uint256);

    function priorityQueueFrontOperation() external view returns (PriorityOperation memory);

    function isValidator(address _address) external view returns (bool);

    function l2LogsRootHash(uint256 _blockNumber) external view returns (bytes32 hash);

    function storedBlockHash(uint256 _blockNumber) external view returns (bytes32);

    function getL2BootloaderBytecodeHash() external view returns (bytes32);

    function getL2DefaultAccountBytecodeHash() external view returns (bytes32);

    function getVerifierParams() external view returns (VerifierParams memory);

    function isDiamondStorageFrozen() external view returns (bool);

    function getSecurityCouncil() external view returns (address);

    function getUpgradeProposalState() external view returns (UpgradeState);

    function getProposedUpgradeHash() external view returns (bytes32);

    function getProposedUpgradeTimestamp() external view returns (uint256);

    function getCurrentProposalId() external view returns (uint256);

    function isApprovedBySecurityCouncil() external view returns (bool);

    function getPriorityTxMaxGasLimit() external view returns (uint256);

    function getAllowList() external view returns (address);

    function isEthWithdrawalFinalized(uint256 _l2BlockNumber, uint256 _l2MessageIndex) external view returns (bool);

    /*//////////////////////////////////////////////////////////////
                            DIAMOND LOUPE
    //////////////////////////////////////////////////////////////*/

    /// @notice Fa¡ª?et structure compatible with the EIP-2535 diamond loupe
    /// @param addr The address of the facet contract
    /// @param selectors The NON-sorted array with selectors associated with facet
    struct Facet {
        address addr;
        bytes4[] selectors;
    }

    function facets() external view returns (Facet[] memory);

    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory);

    function facetAddresses() external view returns (address[] memory facets);

    function facetAddress(bytes4 _selector) external view returns (address facet);

    function isFunctionFreezable(bytes4 _selector) external view returns (bool);

    function isFacetFreezable(address _facet) external view returns (bool isFreezable);
}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IGovernance.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "../../common/interfaces/IAllowList.sol";

import "../Verifier.sol";

import "../Storage.sol";



interface IGovernance {

    function setPendingGovernor(address _newPendingGovernor) external;



    function acceptGovernor() external;



    function setValidator(address _validator, bool _active) external;



    function setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) external;



    function setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) external;



    function setPorterAvailability(bool _zkPorterIsAvailable) external;



    function setVerifier(Verifier _newVerifier) external;



    function setVerifierParams(VerifierParams calldata _newVerifierParams) external;



    function setAllowList(IAllowList _newAllowList) external;



    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external;



    /// @notice ¡ì?hanges to the bytecode that is used in L2 as a bootloader (start program)

    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);



    /// @notice ¡ì?hanges to the bytecode that is used in L2 as a default account

    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);



    /// @notice Porter availability status changes

    event IsPorterAvailableStatusUpdate(bool isPorterAvailable);



    /// @notice Validator's status changed

    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);



    /// @notice pendingGovernor is changed

    /// @dev Also emitted when new governor is accepted and in this case, `newPendingGovernor` would be zero address

    event NewPendingGovernor(address indexed oldPendingGovernor, address indexed newPendingGovernor);



    /// @notice Governor changed

    event NewGovernor(address indexed oldGovernor, address indexed newGovernor);



    /// @notice Verifier address changed

    event NewVerifier(address indexed oldVerifier, address indexed newVerifier);



    /// @notice Verifier address changed

    event NewVerifierParams(VerifierParams oldVerifierParams, VerifierParams newVerifierParams);



    /// @notice Allow list address changed

    event NewAllowList(address indexed oldAllowList, address indexed newAllowList);



    /// @notice Priority transaction max L2 gas limit changed

    event NewPriorityTxMaxGasLimit(uint256 oldPriorityTxMaxGasLimit, uint256 newPriorityTxMaxGasLimit);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IL1Bridge.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







/// @author Matter Labs

interface IL1Bridge {

    event DepositInitiated(

        bytes32 indexed l2DepositTxHash,

        address indexed from,

        address indexed to,

        address l1Token,

        uint256 amount

    );



    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);



    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);



    function isWithdrawalFinalized(uint256 _l2BlockNumber, uint256 _l2MessageIndex) external view returns (bool);



    function deposit(

        address _l2Receiver,

        address _l1Token,

        uint256 _amount,

        uint256 _l2TxGasLimit,

        uint256 _l2TxGasPerPubdataByte,

        address _refundRecipient

    ) external payable returns (bytes32 txHash);



    function claimFailedDeposit(

        address _depositSender,

        address _l1Token,

        bytes32 _l2TxHash,

        uint256 _l2BlockNumber,

        uint256 _l2MessageIndex,

        uint16 _l2TxNumberInBlock,

        bytes32[] calldata _merkleProof

    ) external;



    function finalizeWithdrawal(

        uint256 _l2BlockNumber,

        uint256 _l2MessageIndex,

        uint16 _l2TxNumberInBlock,

        bytes calldata _message,

        bytes32[] calldata _merkleProof

    ) external;



    function l2TokenAddress(address _l1Token) external view returns (address);



    function l2Bridge() external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IL1BridgeLegacy.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







/// @author Matter Labs

interface IL1BridgeLegacy {

    function deposit(

        address _l2Receiver,

        address _l1Token,

        uint256 _amount,

        uint256 _l2TxGasLimit,

        uint256 _l2TxGasPerPubdataByte

    ) external payable returns (bytes32 txHash);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IL2Bridge.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







/// @author Matter Labs

interface IL2Bridge {

    function finalizeDeposit(

        address _l1Sender,

        address _l2Receiver,

        address _l1Token,

        uint256 _amount,

        bytes calldata _data

    ) external;



    function withdraw(

        address _l1Receiver,

        address _l2Token,

        uint256 _amount

    ) external;



    function l1TokenAddress(address _l2Token) external view returns (address);



    function l2TokenAddress(address _l1Token) external view returns (address);



    function l1Bridge() external view returns (address);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IL2ContractDeployer.sol
File type: .sol
pragma solidity ^0.8.0;



// SPDX-License-Identifier: MIT







/**

 * @author Matter Labs

 * @notice System smart contract that is responsible for deploying other smart contracts on zkSync.

 */

interface IL2ContractDeployer {

    /// @notice A struct that describes a forced deployment on an address.

    /// @param bytecodeHash The bytecode hash to put on an address.

    /// @param newAddress The address on which to deploy the bytecodehash to.

    /// @param callConstructor Whether to run the constructor on the force deployment.

    /// @param value The `msg.value` with which to initialize a contract.

    /// @param input The constructor calldata.

    struct ForceDeployment {

        bytes32 bytecodeHash;

        address newAddress;

        bool callConstructor;

        uint256 value;

        bytes input;

    }



    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.

    function forceDeployOnAddresses(ForceDeployment[] calldata _deployParams) external;



    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.

    /// @param _salt The create2 salt.

    /// @param _bytecodeHash The correctly formatted hash of the bytecode.

    /// @param _input The constructor calldata.

    function create2(

        bytes32 _salt,

        bytes32 _bytecodeHash,

        bytes calldata _input

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IL2ERC20Bridge.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







/// @author Matter Labs

interface IL2ERC20Bridge {

    function initialize(

        address _l1Bridge,

        bytes32 _l2TokenProxyBytecodeHash,

        address _governor

    ) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IMailbox.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import {L2Log, L2Message} from "../Storage.sol";



/// @dev The enum that represents the transaction execution status

/// @param Failure The transaction execution failed

/// @param Success The transaction execution succeeded

enum TxStatus {

    Failure,

    Success

}



interface IMailbox {

    /// @dev Structure that includes all fields of the L2 transaction

    /// @dev The hash of this structure is the "canonical L2 transaction hash" and can be used as a unique identifier of a tx

    /// @param txType The tx type number, depending on which the L2 transaction can be interpreted differently

    /// @param from The sender's address. `uint256` type for possible address format changes and maintaining backward compatibility

    /// @param to The recipient's address. `uint256` type for possible address format changes and maintaining backward compatibility

    /// @param gasLimit The L2 gas limit for L2 transaction. Analog to the `gasLimit` on an L1 transactions

    /// @param gasPerPubdataByteLimit Maximum number of L2 gas that will cost one byte of pubdata (every piece of data that will be stored on L1 as calldata)

    /// @param maxFeePerGas The absolute maximum sender willing to pay per unit of L2 gas to get the transaction included in a block. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions

    /// @param maxPriorityFeePerGas The additional fee that is paid directly to the validator to incentivize them to include the transaction in a block. Analog to the EIP-1559 `maxPriorityFeePerGas` on an L1 transactions

    /// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the transaction. `uint256` type for possible address format changes and maintaining backward compatibility

    /// @param nonce The nonce of the transaction. For L1->L2 transactions it is the priority operation Id.

    /// @param value The value to pass with the transaction

    /// @param reserved The fixed-length fields for usage in a future extension of transaction formats

    /// @param data The calldata that is transmitted for the transaction call

    /// @param signature An abstract set of bytes that are used for transaction authorization

    /// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1

    /// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call

    /// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats

    struct L2CanonicalTransaction {

        uint256 txType;

        uint256 from;

        uint256 to;

        uint256 gasLimit;

        uint256 gasPerPubdataByteLimit;

        uint256 maxFeePerGas;

        uint256 maxPriorityFeePerGas;

        uint256 paymaster;

        uint256 nonce;

        uint256 value;

        // In the future, we might want to add some

        // new fields to the struct. The `txData` struct

        // is to be passed to account and any changes to its structure

        // would mean a breaking change to these accounts. To prevent this,

        // we should keep some fields as "reserved".

        // It is also recommended that their length is fixed, since

        // it would allow easier proof integration (in case we will need

        // some special circuit for preprocessing transactions).

        uint256[4] reserved;

        bytes data;

        bytes signature;

        uint256[] factoryDeps;

        bytes paymasterInput;

        // Reserved dynamic type for the future use-case. Using it should be avoided,

        // But it is still here, just in case we want to enable some additional functionality.

        bytes reservedDynamic;

    }



    /// @dev Internal structure that contains the parameters for the writePriorityOp

    /// internal function.

    /// @param sender The sender's address.

    /// @param txId The id of the priority transaction.

    /// @param l2Value The msg.value of the L2 transaction.

    /// @param contractAddressL2 The address of the contract on L2 to call.

    /// @param expirationTimestamp The timestamp by which the priority operation must be processed by the operator.

    /// @param l2GasLimit The limit of the L2 gas for the L2 transaction

    /// @param l2GasPricePerPubdata The price for a single pubdata byte in L2 gas.

    /// @param valueToMint The amount of ether that should be minted on L2 as the result of this transaction.

    /// @param refundRecipient The recipient of the refund for the transaction on L2. If the transaction fails, then

    /// this address will receive the `l2Value`.

    struct WritePriorityOpParams {

        address sender;

        uint256 txId;

        uint256 l2Value;

        address contractAddressL2;

        uint64 expirationTimestamp;

        uint256 l2GasLimit;

        uint256 l2GasPrice;

        uint256 l2GasPricePerPubdata;

        uint256 valueToMint;

        address refundRecipient;

    }



    function proveL2MessageInclusion(

        uint256 _blockNumber,

        uint256 _index,

        L2Message calldata _message,

        bytes32[] calldata _proof

    ) external view returns (bool);



    function proveL2LogInclusion(

        uint256 _blockNumber,

        uint256 _index,

        L2Log memory _log,

        bytes32[] calldata _proof

    ) external view returns (bool);



    function proveL1ToL2TransactionStatus(

        bytes32 _l2TxHash,

        uint256 _l2BlockNumber,

        uint256 _l2MessageIndex,

        uint16 _l2TxNumberInBlock,

        bytes32[] calldata _merkleProof,

        TxStatus _status

    ) external view returns (bool);



    function finalizeEthWithdrawal(

        uint256 _l2BlockNumber,

        uint256 _l2MessageIndex,

        uint16 _l2TxNumberInBlock,

        bytes calldata _message,

        bytes32[] calldata _merkleProof

    ) external;



    function requestL2Transaction(

        address _contractL2,

        uint256 _l2Value,

        bytes calldata _calldata,

        uint256 _l2GasLimit,

        uint256 _l2GasPerPubdataByteLimit,

        bytes[] calldata _factoryDeps,

        address _refundRecipient

    ) external payable returns (bytes32 canonicalTxHash);



    function l2TransactionBaseCost(

        uint256 _gasPrice,

        uint256 _l2GasLimit,

        uint256 _l2GasPerPubdataByteLimit

    ) external view returns (uint256);



    /// @notice New priority request event. Emitted when a request is placed into the priority queue

    /// @param txId Serial number of the priority operation

    /// @param txHash keccak256 hash of encoded transaction representation

    /// @param expirationTimestamp Timestamp up to which priority request should be processed

    /// @param transaction The whole transaction structure that is requested to be executed on L2

    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data. Will be marked as known bytecodes in L2

    event NewPriorityRequest(

        uint256 txId,

        bytes32 txHash,

        uint64 expirationTimestamp,

        L2CanonicalTransaction transaction,

        bytes[] factoryDeps

    );



    /// @notice Emitted when the withdrawal is finalized on L1 and funds are released.

    /// @param to The address to which the funds were sent

    /// @param amount The amount of funds that were sent

    event EthWithdrawalFinalized(address indexed to, uint256 amount);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Initializable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)



pragma solidity ^0.8.2;



import "../../utils/AddressUpgradeable.sol";



/**

 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed

 * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an

 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer

 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.

 *

 * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be

 * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in

 * case an upgrade adds a module that needs to be initialized.

 *

 * For example:

 *

 * [.hljs-theme-light.nopadding]

 * ```

 * contract MyToken is ERC20Upgradeable {

 *     function initialize() initializer public {

 *         __ERC20_init("MyToken", "MTK");

 *     }

 * }

 * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {

 *     function initializeV2() reinitializer(2) public {

 *         __ERC20Permit_init("MyToken");

 *     }

 * }

 * ```

 *

 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as

 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.

 *

 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure

 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.

 *

 * [CAUTION]

 * ====

 * Avoid leaving a contract uninitialized.

 *

 * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation

 * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke

 * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:

 *

 * [.hljs-theme-light.nopadding]

 * ```

 * /// @custom:oz-upgrades-unsafe-allow constructor

 * constructor() {

 *     _disableInitializers();

 * }

 * ```

 * ====

 */

abstract contract Initializable {

    /**

     * @dev Indicates that the contract has been initialized.

     * @custom:oz-retyped-from bool

     */

    uint8 private _initialized;



    /**

     * @dev Indicates that the contract is in the process of being initialized.

     */

    bool private _initializing;



    /**

     * @dev Triggered when the contract has been initialized or reinitialized.

     */

    event Initialized(uint8 version);



    /**

     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,

     * `onlyInitializing` functions can be used to initialize parent contracts.

     *

     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a

     * constructor.

     *

     * Emits an {Initialized} event.

     */

    modifier initializer() {

        bool isTopLevelCall = !_initializing;

        require(

            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),

            "Initializable: contract is already initialized"

        );

        _initialized = 1;

        if (isTopLevelCall) {

            _initializing = true;

        }

        _;

        if (isTopLevelCall) {

            _initializing = false;

            emit Initialized(1);

        }

    }



    /**

     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the

     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be

     * used to initialize parent contracts.

     *

     * A reinitializer may be used after the original initialization step. This is essential to configure modules that

     * are added through upgrades and that require initialization.

     *

     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`

     * cannot be nested. If one is invoked in the context of another, execution will revert.

     *

     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in

     * a contract, executing them in the right order is up to the developer or operator.

     *

     * WARNING: setting the version to 255 will prevent any future reinitialization.

     *

     * Emits an {Initialized} event.

     */

    modifier reinitializer(uint8 version) {

        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");

        _initialized = version;

        _initializing = true;

        _;

        _initializing = false;

        emit Initialized(version);

    }



    /**

     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the

     * {initializer} and {reinitializer} modifiers, directly or indirectly.

     */

    modifier onlyInitializing() {

        require(_initializing, "Initializable: contract is not initializing");

        _;

    }



    /**

     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.

     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized

     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called

     * through proxies.

     *

     * Emits an {Initialized} event the first time it is successfully executed.

     */

    function _disableInitializers() internal virtual {

        require(!_initializing, "Initializable: contract is initializing");

        if (_initialized < type(uint8).max) {

            _initialized = type(uint8).max;

            emit Initialized(type(uint8).max);

        }

    }



    /**

     * @dev Internal function that returns the initialized version. Returns `_initialized`

     */

    function _getInitializedVersion() internal view returns (uint8) {

        return _initialized;

    }



    /**

     * @dev Internal function that returns the initialized version. Returns `_initializing`

     */

    function _isInitializing() internal view returns (bool) {

        return _initializing;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IOperatorFilterRegistry.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;



interface IOperatorFilterRegistry {

    /**

     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns

     *         true if supplied registrant address is not registered.

     */

    function isOperatorAllowed(address registrant, address operator) external view returns (bool);



    /**

     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.

     */

    function register(address registrant) external;



    /**

     * @notice Registers an address with the registry and "subscribes" to another address's filtered operators and codeHashes.

     */

    function registerAndSubscribe(address registrant, address subscription) external;



    /**

     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another

     *         address without subscribing.

     */

    function registerAndCopyEntries(address registrant, address registrantToCopy) external;



    /**

     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.

     *         Note that this does not remove any filtered addresses or codeHashes.

     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.

     */

    function unregister(address addr) external;



    /**

     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.

     */

    function updateOperator(address registrant, address operator, bool filtered) external;



    /**

     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.

     */

    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;



    /**

     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.

     */

    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;



    /**

     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.

     */

    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;



    /**

     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous

     *         subscription if present.

     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,

     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be

     *         used.

     */

    function subscribe(address registrant, address registrantToSubscribe) external;



    /**

     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.

     */

    function unsubscribe(address registrant, bool copyExistingEntries) external;



    /**

     * @notice Get the subscription address of a given registrant, if any.

     */

    function subscriptionOf(address addr) external returns (address registrant);



    /**

     * @notice Get the set of addresses subscribed to a given registrant.

     *         Note that order is not guaranteed as updates are made.

     */

    function subscribers(address registrant) external returns (address[] memory);



    /**

     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.

     *         Note that order is not guaranteed as updates are made.

     */

    function subscriberAt(address registrant, uint256 index) external returns (address);



    /**

     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.

     */

    function copyEntriesOf(address registrant, address registrantToCopy) external;



    /**

     * @notice Returns true if operator is filtered by a given address or its subscription.

     */

    function isOperatorFiltered(address registrant, address operator) external returns (bool);



    /**

     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.

     */

    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);



    /**

     * @notice Returns true if a codeHash is filtered by a given address or its subscription.

     */

    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);



    /**

     * @notice Returns a list of filtered operators for a given address or its subscription.

     */

    function filteredOperators(address addr) external returns (address[] memory);



    /**

     * @notice Returns the set of filtered codeHashes for a given address or its subscription.

     *         Note that order is not guaranteed as updates are made.

     */

    function filteredCodeHashes(address addr) external returns (bytes32[] memory);



    /**

     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or

     *         its subscription.

     *         Note that order is not guaranteed as updates are made.

     */

    function filteredOperatorAt(address registrant, uint256 index) external returns (address);



    /**

     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or

     *         its subscription.

     *         Note that order is not guaranteed as updates are made.

     */

    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);



    /**

     * @notice Returns true if an address has registered

     */

    function isRegistered(address addr) external returns (bool);



    /**

     * @dev Convenience method to compute the code hash of an arbitrary contract

     */

    function codeHashOf(address addr) external returns (bytes32);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ITrustedTransfarableERC20.sol
File type: .sol
/// @dev Interface of the ERC20 standard as defined in the EIP.

/// 1. Implements only `transfer` and `transferFrom` methods

/// 2. These methods return a boolean value in case of a non-revert call

/// NOTE: It is expected that if the function returns true, then the user's balance has

/// changed exactly by `amount` according to the ERC20 standard.

/// Note: Used to perform transfers for tokens that explicitly return a boolean value

/// (if the token returns any other data or does not return at all, then the function call will be reverted)

interface ITrustedTransfarableERC20 {

    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\IZkSync.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "./IMailbox.sol";

import "./IGovernance.sol";

import "./IExecutor.sol";

import "./IDiamondCut.sol";

import "./IGetters.sol";



interface IZkSync is IMailbox, IGovernance, IExecutor, IDiamondCut, IGetters {}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\KeysWithPlonkVerifier.sol
File type: .sol
pragma solidity ^0.7.0;

pragma experimental ABIEncoderV2;



// SPDX-License-Identifier: MIT OR Apache-2.0











import "./PlonkCore.sol";



// Hardcoded constants to avoid accessing store

contract KeysWithPlonkVerifier is VerifierWithDeserialize {



    uint256 constant VK_TREE_ROOT = 0x1ffdc7ebe04681d451ae0658a6ad27feb63835b0edf90bdfa203cd8d12282ace;

    uint8 constant VK_MAX_INDEX = 3;



    function getVkAggregated(uint32 _proofs) internal pure returns (VerificationKey memory vk) {

        if (_proofs == uint32(1)) { return getVkAggregated1(); }

        else if (_proofs == uint32(4)) { return getVkAggregated4(); }

        else if (_proofs == uint32(8)) { return getVkAggregated8(); }

    }



    

    function getVkAggregated1() internal pure returns(VerificationKey memory vk) {

        vk.domain_size = 4194304;

        vk.num_inputs = 1;

        vk.omega = PairingsBn254.new_fr(0x18c95f1ae6514e11a1b30fd7923947c5ffcec5347f16e91b4dd654168326bede);

        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(

            0x16782f42f191b0b1841c2b6a42b7f0564af065d04818526df6c3ad41fe35f8da,

            0x125b9c68c0b931578f8a18fd23ce08e7b7c082ad76404ccece796fa9b3ec0cb0

        );

        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(

            0x2511833eee308a3936b23b27c929942a60aa780747bf32143dc183e873144bfd,

            0x1b8d88d78fcc4a36ebe90fbbdc4547442411e0c8d484727d5c7c6eec27ad2df0

        );

        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(

            0x2945641d0c5556aa333ef6c8431e24379b73eccbed7ff3e9425cc64aee1e92ed,

            0x25bbf079192cc83f160da9375e7aec3d3d2caac8d831a29b50f5497071fc14c6

        );

        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(

            0x09b3c361e5895a8e074eb9b9a9e57af59966f0464068460adc3f64e58544afa4,

            0x0412a017f775dd05af16cf387a1e822c2a7e0f8b7cfabd0eb4eb0f67b20e4ada

        );

        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(

            0x244b30447ab3e56bb5a5a7f0ef8463a4047476ea269735a887b3de568b3401a3,

            0x2ba860198d5e6e0fd93355cb5f309e7e4c1113a57222830961999b79b83d700f

        );

        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(

            0x0e13af99775bf5555c366e9c8d4af25a2e195807b766b422856525c01a38b12d,

            0x1787389894222dba5371ab55d512460c5205c1baa0421fc877b183025079a472

        );

        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(

            0x233a03f89c094cf39c89020772d9b912bd0c303d211002ee5afc5c59e241f02b,

            0x04fa51fca1b17399bbbf2b99f17bbce6af1f50b085add4c41ac4ea64f65f4674

        );

        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(

            0x1ca088ed531e65b722c8b48568359bbe11051b86f1a8e8951eacc615d9faed3b,

            0x074b06c09de93dd79e070a9ded635e21a34d7178e9a670766e8208149c28e339

        );

        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(

            0x2b4c77c0d47676559061b47968a044aec625cb907181457428e5d08df9b27ef8,

            0x1c1be561bdc3eba16162886a2943882157f98ed8246f2063028497f1c108fa93

        );

        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(

            0x238fd7f2cbc3c3e5899483633c78f051e6d6d25f31aaa6b32b863d55b20d641a,

            0x1f9877b625eaae7a084582a2ffce326a6a5558f3efdb3367037098c4ca25a647

        );

        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(

            0x0b126f60653e371f3f2a85301f16e9cf4af04922a2725fc131b17e90e13d0d84,

            0x13bc3f0c7475b74591827463943b35cfd05adb7094a79eeeee2067e8e28a8e84

        );

        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(

            0x06cae3c1e5b43afb4dda3243c99da693a27eba065fd61a873e99e2c85fd22719,

            0x14343c6bdcc85b01b053f26aa3c473cb2f24747ba6d6b90b2323b24f3dfd127e

        );

        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(

            0x217564e2c710d050161b57ef2700e1676251a6d457c4b0d94c41a4492d6dcea3,

            0x2365779642d63803d0265a7cc666b3af6ad92b7e9ef38d9113db1208b83f0732

        );

        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(

            0x0000000000000000000000000000000000000000000000000000000000000005

        );

        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(

            0x0000000000000000000000000000000000000000000000000000000000000007

        );

        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(

            0x000000000000000000000000000000000000000000000000000000000000000a

        );



        vk.g2_x = PairingsBn254.new_g2(

            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,

            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],

            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,

            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]

        );

    }

    

    function getVkAggregated4() internal pure returns(VerificationKey memory vk) {

        vk.domain_size = 8388608;

        vk.num_inputs = 1;

        vk.omega = PairingsBn254.new_fr(0x1283ba6f4b7b1a76ba2008fe823128bea4adb9269cbfd7c41c223be65bc60863);

        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(

            0x1878d6c837a0f16cb055d3a4e79fba0d85de670dacd708dadd55407b0619796d,

            0x0b3282e52a38ecec63ba42710e8d1ad5c8715c7ed07ce217a3eec747a3f37d76

        );

        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(

            0x07425bcaf480e377886678d5b5432f0945e3fc952126503a7b672dc4b03f2c26,

            0x155b8003ea27945bf43fb5f43291f76e2aa361e0ec81550c0af66dcd1dc8077e

        );

        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(

            0x1292b8795f05fc50782ea7303e2b65a7b2f0e1cc3dead51dfa0b9d2183e5d907,

            0x220d344a384ac53f682e1be6c69407a1fadd0a589de36b95ddc4da05693ba679

        );

        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(

            0x283412c1942c0cb3fffc935aab313a37510888bd5ae5972d8d67edc2312af895,

            0x1040e655967354e7ae9227c6200c2256cdcbb707e7158b66462aba23d96b8de2

        );

        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(

            0x2abe282377038904420434202c11a4f849e64babd436b93192d8d9c34d28ce44,

            0x19f0ed010326da1cf8ac93a0f73617ab7c9acb30a0c23a26db9ec19ab6a52fcb

        );

        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(

            0x236f01e67b19be0e7487100a14fd04a05a83a5660966ace987c5248f8c883459,

            0x0ebe824fb1e778491bcb8091d2adbc18dceda4fa9ee191b71c5834a71c533c41

        );

        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(

            0x2ad3c37aa0b1335f6c70d0e10f0a123a28ea012e857df30e3ced524ef6562c71,

            0x1b52d7ac4ee6082438deab8ab0f2944c9fd53258de305065f8323a3767dd8234

        );

        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(

            0x173c39587688a8967e915959df613aecf44ad0c7d2019ec32311bccdf542c78e,

            0x2421a36a67559ed89afbff081cd45b318835e2b0233c047d030abc48b5011c22

        );

        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(

            0x177d8ef11cac24105d4b38e035b891986d163d9df717fce12d18af324f86d2dc,

            0x02cd01ba1c82c85b4f0f8c7304254de64516857ac4f7bb60f052bb2af98132c5

        );

        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(

            0x21da2c0f2b7849d4c44dbc487d370cccbae78fbd979e79575e04b7a983f2f68a,

            0x14ffb806769ccf0d2c692cd93653491966525554d79efc37cfba5a5c08b15039

        );

        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(

            0x184cc2f37e687a9be2404cd367536f14a505f086fd597cb966c5b753f325adb4,

            0x20aaed49755efed4814025ac679570f62b8c98a1b8d977969242c3ffa67884d6

        );

        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(

            0x0a2dee920031d9cd5ed499dc3cb901657079f6a2dfb0ba389b0181803bb91e24,

            0x272ac2a214f46be0ed7d2b4cf125504ef82d929b1c1ec0a81655c66f39403cd1

        );

        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(

            0x07e360365c7a5363389b2d2449b9471754591f01a623fd5553c5cfe6bad19aaf,

            0x1b814914958835ef86de3c26c6c4bdc27e947f38cb0d2bfaa421d66cabfb7d55

        );

        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(

            0x0000000000000000000000000000000000000000000000000000000000000005

        );

        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(

            0x0000000000000000000000000000000000000000000000000000000000000007

        );

        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(

            0x000000000000000000000000000000000000000000000000000000000000000a

        );



        vk.g2_x = PairingsBn254.new_g2(

            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,

            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],

            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,

            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]

        );

    }

    

    function getVkAggregated8() internal pure returns(VerificationKey memory vk) {

        vk.domain_size = 16777216;

        vk.num_inputs = 1;

        vk.omega = PairingsBn254.new_fr(0x1951441010b2b95a6e47a6075066a50a036f5ba978c050f2821df86636c0facb);

        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(

            0x1aab46b9aa3adcac623c360e4d075572e3f56f4c75ac3b8663a7b059bd9b1857,

            0x166ac39283efa3d6cb36423e83e2360f006e5fa374b454dea5fe92cc50d4193f

        );

        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(

            0x13bce0a7bfbf2e7a81f18e84966c32422446b01f54cc7dc2ad3f64e92fe94cad,

            0x0247234b0cdfd8c95a767f84303c3dd65ce7b15856c2840635d9d4754ba99479

        );

        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(

            0x08742bad9a7cbcc9dbb49a25bebce179295d1cf70fd8f9c8e82b8a658ee0b67c,

            0x2a467983257850c5fa27f2f52f0c5c5fc98e7d2e0d440a8fd954ad981ff0ce9f

        );

        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(

            0x16ebdd4b95b872cd09c13b6b54a8b8bf81a01529a71234db26e3b22c6d632723,

            0x034219d7ad9ef204cfb3e32c4a47af82eea40504c2b1bac785104731722ed617

        );

        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(

            0x2e3a7c4458a8dc1535e68bac5dd5c1c9ff3886df4156bad4a08fcd08ebf1db26,

            0x173859705317db06e5b7d260898ab08e72fae987c272b82345105d72bfd00ab8

        );

        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(

            0x0b830132e3325eaaea73c1095e615358db38dfb39248c90f8ff4afde169e7657,

            0x0bfedf8cfce7260c16bb1f76ad9a39f73a68087e5c68e841020aeaa5ba301a9f

        );

        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(

            0x1660c850da793add523f7990b983896e50d5549eec7990ec26aabc220ca58d52,

            0x0ba698e78dee0d41cf8aefde82c5bfda38be071e11025b56db779ddb40a4fe92

        );

        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(

            0x024fe4ce02dd48937e4642b66308ae15d731e0ea82fc5430a0470d9a5dab3694,

            0x177cac2d79a8bfa6aba134e24bded06d06219979c18b2fa4fe71baea9885985d

        );

        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(

            0x00a848bc76c52faf7d4e7cc4086b50e3ccc9b1cebef130ac1bbf1816502df59d,

            0x02f42f326f82b33cb9e4e7cfb332889eec95c2813f7968b3a50d838b3cbfa676

        );

        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(

            0x20c176738979e0d1ea9541bf26e6209d3091b618ae94f3c72e13e954a1614f60,

            0x2a7019c81009c00a7412b6a303b2eb118a362a558837e9ecdb912589bc11ff83

        );

        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(

            0x10a92b3fa2b8280030c9de5cbcab4da3cf9b5b3f63f3ad60284ecded63cc54ea,

            0x1bde2a83db435b8c74e4239b4f8416da88008331a758d8c68a9104f2dfc3e237

        );

        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(

            0x08e2e513d1e548a627e2d4f74d28dea916d8598415b70543bb3e92429f0111cb,

            0x2fb46898f77e32d7fd646fe31b60320423aa4698501e329e206b6acfcfb01337

        );

        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(

            0x145b88d324270872b13784fbb7ccdee6e5593d2d5cbc81f4aaa9b4268cfc5094,

            0x197d826aaf2a9853ca98ec9c0e55376eec1a6a0f5dbbbe02afeb1b567d8eafa0

        );

        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(

            0x0000000000000000000000000000000000000000000000000000000000000005

        );

        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(

            0x0000000000000000000000000000000000000000000000000000000000000007

        );

        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(

            0x000000000000000000000000000000000000000000000000000000000000000a

        );



        vk.g2_x = PairingsBn254.new_g2(

            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,

            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],

            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,

            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]

        );

    }

    



}



// Hardcoded constants to avoid accessing store

contract KeysWithPlonkVerifierOld is VerifierWithDeserializeOld {



    

    function getVkExit() internal pure returns(VerificationKeyOld memory vk) {

        vk.domain_size = 524288;

        vk.num_inputs = 1;

        vk.omega = PairingsBn254.new_fr(0x0cf1526aaafac6bacbb67d11a4077806b123f767e4b0883d14cc0193568fc082);

        vk.selector_commitments[0] = PairingsBn254.new_g1(

            0x114dd473f77a15b602201577dd4b64a32a783cb32fbc02911e512df6a219695d,

            0x04c68f82a5dd7d0cc90318bdff493b3d552d148ad859c373ffe55275e043c43b

        );

        vk.selector_commitments[1] = PairingsBn254.new_g1(

            0x245e8c882af503cb5421f5135b4295a920ccf68b42ae7fb967f044f54e2aaa29,

            0x071322ee387a9ce49fe7ef2edb6e9237203dee49ec47483af85e356b79fb06fd

        );

        vk.selector_commitments[2] = PairingsBn254.new_g1(

            0x0187754ab593b07a420b3b4d215c20ed49acf90fc4c97e4b06e8f5bc0a2eb3f4,

            0x0170f9286ce950286a16ea25136c163c0b32019f31b89c256a612d40b863d0b6

        );

        vk.selector_commitments[3] = PairingsBn254.new_g1(

            0x0defecfae1d2b9ec9b2ee4d4798c625fa50f6a4ddb7747a7293df0c17fcb90c2,

            0x0f91d08fceebf85fb80f12cda78cefa1ee9dbf5cfe7c4f0704b3c6620fa50c55

        );

        vk.selector_commitments[4] = PairingsBn254.new_g1(

            0x2f7fef3b3fb64af6640f93803a18b3e5ce4e0e60aecd4f924c833fa6fa6da961,

            0x03908fc737113ac7f3529fe3b36efca200c66d1d85d2fc081973214c586de732

        );

        vk.selector_commitments[5] = PairingsBn254.new_g1(

            0x14ce3c0e9b78fc331327249e707f58fa4bb0ed746bdc9c2262ad0cf905609627,

            0x09e64fdac452b424e98fc4a92f7222693d0d84ab48aadd9c46151dbe5f1a34a9

        );



        // we only have access to value of the d(x) witness polynomial on the next

        // trace step, so we only need one element here and deal with it in other places

        // by having this in mind

        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(

            0x1d10bfd923c17d9623ec02db00099355b373021432ae1edef69b0f5f461f78d6,

            0x24e370a93f65f42888781d0158bb6ef9136c8bbd047d7993b8276bc8df8b640a

        );



        vk.permutation_commitments[0] = PairingsBn254.new_g1(

            0x1fd1755ed4d06d91d50db4771d332cfa2bc2ca0e10ac8b77e0d6b73b993e788e,

            0x0bdbf3b7f0d3cffdcf818f1fba18b90914eda59b454bd1858c6c0916b817f883

        );

        vk.permutation_commitments[1] = PairingsBn254.new_g1(

            0x1f3b8d12ffa2ceb2bb42d232ad2cf11bce3183472b622e11cc841d26f42ad507,

            0x0ce815e32b3bd14311cde210cda1bd351617d539ed3e9d96a8605f364f3a29b0

        );

        vk.permutation_commitments[2] = PairingsBn254.new_g1(

            0x123afa8c1cec1956d7330db062498a2a3e3a9862926c02e1228d9cfb63d3c301,

            0x0f5af15ff0a3e35486c541f72956b53ff6d0740384ef6463c866146c1bd2afc8

        );

        vk.permutation_commitments[3] = PairingsBn254.new_g1(

            0x01069e38ea6396af1623921101d3d3d14ee46942fb23bf1d110efb994c3ee573,

            0x232a8ce7151e69601a7867f9dcac8e2de4dd8352d119c90bbb0fb84720c02513

        );



        vk.permutation_non_residues[0] = PairingsBn254.new_fr(

            0x0000000000000000000000000000000000000000000000000000000000000005

        );

        vk.permutation_non_residues[1] = PairingsBn254.new_fr(

            0x0000000000000000000000000000000000000000000000000000000000000007

        );

        vk.permutation_non_residues[2] = PairingsBn254.new_fr(

            0x000000000000000000000000000000000000000000000000000000000000000a

        );



        vk.g2_x = PairingsBn254.new_g2(

            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1, 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],

            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4, 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]

        );

    }

    

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\L1ERC20Bridge.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";



import "./interfaces/IL1BridgeLegacy.sol";

import "./interfaces/IL1Bridge.sol";

import "./interfaces/IL2Bridge.sol";

import "./interfaces/IL2ERC20Bridge.sol";



import "./libraries/BridgeInitializationHelper.sol";



import "../zksync/interfaces/IZkSync.sol";

import "../common/interfaces/IL2ContractDeployer.sol";

import "../common/interfaces/IAllowList.sol";

import "../common/AllowListed.sol";

import "../common/libraries/UnsafeBytes.sol";

import "../common/libraries/L2ContractHelper.sol";

import "../common/L2ContractAddresses.sol";

import "../common/ReentrancyGuard.sol";

import "../vendor/AddressAliasHelper.sol";



/// @author Matter Labs

/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to zkSync v2.0

/// @dev It is standard implementation of ERC20 Bridge that can be used as a reference

/// for any other custom token bridges.

contract L1ERC20Bridge is IL1Bridge, IL1BridgeLegacy, AllowListed, ReentrancyGuard {

    using SafeERC20 for IERC20;



    /// @dev The smart contract that manages the list with permission to call contract functions

    IAllowList immutable allowList;



    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication

    IZkSync immutable zkSync;



    /// @dev A mapping L2 block number => message number => flag

    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed

    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;



    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount

    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail

    mapping(address => mapping(address => mapping(bytes32 => uint256))) depositAmount;



    /// @dev The address of deployed L2 bridge counterpart

    address public l2Bridge;



    /// @dev The address of the factory that deploys proxy for L2 tokens

    address public l2TokenBeacon;



    /// @dev The bytecode hash of the L2 token contract

    bytes32 public l2TokenProxyBytecodeHash;



    mapping(address => uint256) public __DEPRECATED_lastWithdrawalLimitReset;



    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window

    mapping(address => uint256) public __DEPRECATED_withdrawnAmountInWindow;



    /// @dev The accumulated deposited amount per user.

    /// @dev A mapping L1 token address => user address => the total deposited amount by the user

    mapping(address => mapping(address => uint256)) public totalDepositedAmountPerUser;



    /// @dev Contract is expected to be used as proxy implementation.

    /// @dev Initialize the implementation to prevent Parity hack.

    constructor(IZkSync _zkSync, IAllowList _allowList) reentrancyGuardInitializer {

        zkSync = _zkSync;

        allowList = _allowList;

    }



    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy

    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it

    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge

    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation

    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge

    /// @notice _factoryDeps[2] == a raw bytecode of token proxy

    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon

    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address

    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function

    /// @param _governor Address which can change L2 token implementation and upgrade the bridge

    function initialize(

        bytes[] calldata _factoryDeps,

        address _l2TokenBeacon,

        address _governor,

        uint256 _deployBridgeImplementationFee,

        uint256 _deployBridgeProxyFee

    ) external payable reentrancyGuardInitializer {

        require(_l2TokenBeacon != address(0), "nf");

        require(_governor != address(0), "nh");

        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge

        require(_factoryDeps.length == 3, "mk");

        // The caller miscalculated deploy transactions fees

        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");

        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[2]);

        l2TokenBeacon = _l2TokenBeacon;



        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);

        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);



        // Deploy L2 bridge implementation contract

        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(

            zkSync,

            _deployBridgeImplementationFee,

            l2BridgeImplementationBytecodeHash,

            "", // Empty constructor data

            _factoryDeps // All factory deps are needed for L2 bridge

        );



        // Prepare the proxy constructor data

        bytes memory l2BridgeProxyConstructorData;

        {

            // Data to be used in delegate call to initialize the proxy

            bytes memory proxyInitializationParams = abi.encodeCall(

                IL2ERC20Bridge.initialize,

                (address(this), l2TokenProxyBytecodeHash, _governor)

            );

            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);

        }



        // Deploy L2 bridge proxy contract

        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(

            zkSync,

            _deployBridgeProxyFee,

            l2BridgeProxyBytecodeHash,

            l2BridgeProxyConstructorData,

            new bytes[](0) // No factory deps are needed for L2 bridge proxy, because it is already passed in previous step

        );

    }



    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.

    /// @dev Initiates a deposit by locking funds on the contract and sending the request

    /// of processing an L2 transaction where tokens would be minted

    /// @param _l2Receiver The account address that should receive funds on L2

    /// @param _l1Token The L1 token address which is deposited

    /// @param _amount The total amount of tokens to be bridged

    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction

    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction

    /// @return l2TxHash The L2 transaction hash of deposit finalization

    /// NOTE: the function doesn't use `nonreentrant` and `senderCanCallFunction` modifiers, because the inner method do.

    function deposit(

        address _l2Receiver,

        address _l1Token,

        uint256 _amount,

        uint256 _l2TxGasLimit,

        uint256 _l2TxGasPerPubdataByte

    ) external payable returns (bytes32 l2TxHash) {

        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));

    }



    /// @notice Initiates a deposit by locking funds on the contract and sending the request

    /// of processing an L2 transaction where tokens would be minted

    /// @param _l2Receiver The account address that should receive funds on L2

    /// @param _l1Token The L1 token address which is deposited

    /// @param _amount The total amount of tokens to be bridged

    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction

    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction

    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction. If the transaction fails,

    /// it will also be the address to receive `_l2Value`. If zero, the refund will be sent to the sender of the transaction.

    /// @return l2TxHash The L2 transaction hash of deposit finalization

    function deposit(

        address _l2Receiver,

        address _l1Token,

        uint256 _amount,

        uint256 _l2TxGasLimit,

        uint256 _l2TxGasPerPubdataByte,

        address _refundRecipient

    ) public payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 l2TxHash) {

        require(_amount != 0, "2T"); // empty deposit amount

        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);

        require(amount == _amount, "1T"); // The token has non-standard transfer logic

        // verify the deposit amount is allowed

        _verifyDepositLimit(_l1Token, msg.sender, _amount, false);



        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount);

        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.

        // Otherwise, the refund will be sent to the specified address.

        // Please note, if the recipient is a contract (the only exception is a contracting contract, but it is shooting in the leg).

        address refundRecipient = _refundRecipient;

        if (_refundRecipient == address(0)) {

            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;

        }

        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(

            l2Bridge,

            0, // L2 msg.value

            l2TxCalldata,

            _l2TxGasLimit,

            _l2TxGasPerPubdataByte,

            new bytes[](0),

            refundRecipient

        );



        // Save the deposited amount to claim funds on L1 if the deposit failed on L2

        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;



        emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);

    }



    /// @dev Transfers tokens from the depositor address to the smart contract address

    /// @return The difference between the contract balance before and after the transferring of funds

    function _depositFunds(

        address _from,

        IERC20 _token,

        uint256 _amount

    ) internal returns (uint256) {

        uint256 balanceBefore = _token.balanceOf(address(this));

        _token.safeTransferFrom(_from, address(this), _amount);

        uint256 balanceAfter = _token.balanceOf(address(this));



        return balanceAfter - balanceBefore;

    }



    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract

    function _getDepositL2Calldata(

        address _l1Sender,

        address _l2Receiver,

        address _l1Token,

        uint256 _amount

    ) internal view returns (bytes memory txCalldata) {

        bytes memory gettersData = _getERC20Getters(_l1Token);



        txCalldata = abi.encodeCall(

            IL2Bridge.finalizeDeposit,

            (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)

        );

    }



    /// @dev Receives and parses (name, symbol, decimals) from the token contract

    function _getERC20Getters(address _token) internal view returns (bytes memory data) {

        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));

        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));

        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));

        data = abi.encode(data1, data2, data3);

    }



    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2

    /// @param _depositSender The address of the deposit initiator

    /// @param _l1Token The address of the deposited L1 ERC20 token

    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization

    /// @param _l2BlockNumber The L2 block number where the deposit finalization was processed

    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message

    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent

    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization

    function claimFailedDeposit(

        address _depositSender,

        address _l1Token,

        bytes32 _l2TxHash,

        uint256 _l2BlockNumber,

        uint256 _l2MessageIndex,

        uint16 _l2TxNumberInBlock,

        bytes32[] calldata _merkleProof

    ) external nonReentrant senderCanCallFunction(allowList) {

        bool proofValid = zkSync.proveL1ToL2TransactionStatus(

            _l2TxHash,

            _l2BlockNumber,

            _l2MessageIndex,

            _l2TxNumberInBlock,

            _merkleProof,

            TxStatus.Failure

        );

        require(proofValid, "yn");



        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];

        require(amount > 0, "y1");



        // Change the total deposited amount by the user

        _verifyDepositLimit(_l1Token, _depositSender, amount, true);



        delete depositAmount[_depositSender][_l1Token][_l2TxHash];

        // Withdraw funds

        IERC20(_l1Token).safeTransfer(_depositSender, amount);



        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);

    }



    /// @notice Finalize the withdrawal and release funds

    /// @param _l2BlockNumber The L2 block number where the withdrawal was processed

    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message

    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent

    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message

    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization

    function finalizeWithdrawal(

        uint256 _l2BlockNumber,

        uint256 _l2MessageIndex,

        uint16 _l2TxNumberInBlock,

        bytes calldata _message,

        bytes32[] calldata _merkleProof

    ) external nonReentrant senderCanCallFunction(allowList) {

        require(!isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex], "pw");



        L2Message memory l2ToL1Message = L2Message({

            txNumberInBlock: _l2TxNumberInBlock,

            sender: l2Bridge,

            data: _message

        });



        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);

        // Preventing the stack too deep error

        {

            bool success = zkSync.proveL2MessageInclusion(_l2BlockNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);

            require(success, "nq");

        }



        isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex] = true;

        // Withdraw funds

        IERC20(l1Token).safeTransfer(l1Receiver, amount);



        emit WithdrawalFinalized(l1Receiver, l1Token, amount);

    }



    /// @dev Decode the withdraw message that came from L2

    function _parseL2WithdrawalMessage(bytes memory _l2ToL1message)

        internal

        pure

        returns (

            address l1Receiver,

            address l1Token,

            uint256 amount

        )

    {

        // Check that the message length is correct.

        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 = 76 (bytes).

        require(_l2ToL1message.length == 76, "kk");



        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);

        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");



        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);

        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);

        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);

    }



    /// @dev Verify the deposit limit is reached to its cap or not

    function _verifyDepositLimit(

        address _l1Token,

        address _depositor,

        uint256 _amount,

        bool _claiming

    ) internal {

        IAllowList.Deposit memory limitData = IAllowList(allowList).getTokenDepositLimitData(_l1Token);

        if (!limitData.depositLimitation) return; // no deposit limitation is placed for this token



        if (_claiming) {

            totalDepositedAmountPerUser[_l1Token][_depositor] -= _amount;

        } else {

            require(totalDepositedAmountPerUser[_l1Token][_depositor] + _amount <= limitData.depositCap, "d1");

            totalDepositedAmountPerUser[_l1Token][_depositor] += _amount;

        }

    }



    /// @return The L2 token address that would be minted for deposit of the given L1 token

    function l2TokenAddress(address _l1Token) public view returns (address) {

        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), ""));

        bytes32 salt = bytes32(uint256(uint160(_l1Token)));



        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\L2ContractAddresses.sol
File type: .sol
pragma solidity ^0.8.0;



// SPDX-License-Identifier: MIT







/// @dev The address of the L2 deployer system contract.

address constant L2_DEPLOYER_SYSTEM_CONTRACT_ADDR = address(0x8006);



/// @dev The special reserved L2 address. It is located in the system contracts space but doesn't have deployed bytecode.

/// @dev The L2 deployer system contract allows changing bytecodes on any address if the `msg.sender` is this address.

/// @dev So, whenever the governor wants to redeploy system contracts, it just initiates the L1 upgrade call deployer system contract

/// via the L1 -> L2 transaction with `sender == L2_FORCE_DEPLOYER_ADDR`. For more details see the `diamond-initializers` contracts.

address constant L2_FORCE_DEPLOYER_ADDR = address(0x8007);



/// @dev The address of the special smart contract that can send arbitrary length message as an L2 log

address constant L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR = address(0x8008);



/// @dev The formal address of the initial program of the system: the bootloader

address constant L2_BOOTLOADER_ADDRESS = address(0x8001);



/// @dev The address of the eth token system contract

address constant L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR = address(0x800a);



/// @dev The address of the known code storage system contract

address constant L2_KNOWN_CODE_STORAGE_SYSTEM_CONTRACT_ADDR = address(0x8004);



/// @dev The address of the context system contract

address constant L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR = address(0x800b);

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\L2ContractHelper.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







/**

 * @author Matter Labs

 * @notice Helper library for working with L2 contracts on L1.

 */

library L2ContractHelper {

    /// @dev The prefix used to create CREATE2 addresses.

    bytes32 constant CREATE2_PREFIX = keccak256("zksyncCreate2");



    /// @notice Validate the bytecode format and calculate its hash.

    /// @param _bytecode The bytecode to hash.

    /// @return hashedBytecode The 32-byte hash of the bytecode.

    /// Note: The function reverts the execution if the bytecode has non expected format:

    /// - Bytecode bytes length is not a multiple of 32

    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)

    /// - Bytecode words length is not odd

    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {

        // Note that the length of the bytecode must be provided in 32-byte words.

        require(_bytecode.length % 32 == 0, "po");



        uint256 bytecodeLenInWords = _bytecode.length / 32;

        require(bytecodeLenInWords < 2**16, "pp"); // bytecode length must be less than 2^16 words

        require(bytecodeLenInWords % 2 == 1, "pr"); // bytecode length in words must be odd

        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

        // Setting the version of the hash

        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));

        // Setting the length

        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);

    }



    /// @notice Validates the format of the given bytecode hash.

    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.

    /// @dev The function reverts on invalid bytecode hash formam.

    /// @param _bytecodeHash The hash of the bytecode to validate.

    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {

        uint8 version = uint8(_bytecodeHash[0]);

        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash



        require(_bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd

    }



    /// @notice Returns the length of the bytecode associated with the given hash.

    /// @param _bytecodeHash The hash of the bytecode.

    /// @return codeLengthInWords The length of the bytecode in words.

    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {

        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));

    }



    /// @notice Computes the create2 address for a Layer 2 contract.

    /// @param _sender The address of the sender.

    /// @param _salt The salt value to use in the create2 address computation.

    /// @param _bytecodeHash The contract bytecode hash.

    /// @param _constructorInputHash The hash of the constructor input data.

    /// @return The create2 address of the contract.

    /// NOTE: L2 create2 derivation is different from L1 derivation!

    function computeCreate2Address(

        address _sender,

        bytes32 _salt,

        bytes32 _bytecodeHash,

        bytes32 _constructorInputHash

    ) internal pure returns (address) {

        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));

        bytes32 data = keccak256(

            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)

        );



        return address(uint160(uint256(data)));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Mailbox.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "@openzeppelin/contracts/utils/math/Math.sol";



import "../interfaces/IMailbox.sol";

import "../libraries/Merkle.sol";

import "../libraries/PriorityQueue.sol";

import "../Storage.sol";

import "../Config.sol";

import "../../common/libraries/UncheckedMath.sol";

import "../../common/libraries/UnsafeBytes.sol";

import "../../common/libraries/L2ContractHelper.sol";

import "../../common/L2ContractAddresses.sol";

import "../../vendor/AddressAliasHelper.sol";

import "./Base.sol";



/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.

/// @author Matter Labs

contract MailboxFacet is Base, IMailbox {

    using UncheckedMath for uint256;

    using PriorityQueue for PriorityQueue.Queue;



    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 block number

    /// @param _blockNumber The executed L2 block number in which the message appeared

    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message

    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 block where the message was sent

    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message

    /// @return Whether the proof is valid

    function proveL2MessageInclusion(

        uint256 _blockNumber,

        uint256 _index,

        L2Message memory _message,

        bytes32[] calldata _proof

    ) public view returns (bool) {

        return _proveL2LogInclusion(_blockNumber, _index, _L2MessageToLog(_message), _proof);

    }



    /// @notice Prove that a specific L2 log was sent in a specific L2 block

    /// @param _blockNumber The executed L2 block number in which the log appeared

    /// @param _index The position of the l2log in the L2 logs Merkle tree

    /// @param _log Information about the sent log

    /// @param _proof Merkle proof for inclusion of the L2 log

    /// @return Whether the proof is correct and L2 log is included in block

    function proveL2LogInclusion(

        uint256 _blockNumber,

        uint256 _index,

        L2Log memory _log,

        bytes32[] calldata _proof

    ) external view returns (bool) {

        return _proveL2LogInclusion(_blockNumber, _index, _log, _proof);

    }



    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.

    /// @param _l2TxHash The L2 canonical transaction hash

    /// @param _l2BlockNumber The L2 block number where the transaction was processed

    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message

    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent

    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction

    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)

    /// @return Whether the proof is correct and the transaction was actually executed with provided status

    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!

    function proveL1ToL2TransactionStatus(

        bytes32 _l2TxHash,

        uint256 _l2BlockNumber,

        uint256 _l2MessageIndex,

        uint16 _l2TxNumberInBlock,

        bytes32[] calldata _merkleProof,

        TxStatus _status

    ) public view override returns (bool) {

        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.

        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 block with specified status.

        //

        // The semantics of such L2 -> L1 log is always:

        // - sender = L2_BOOTLOADER_ADDRESS

        // - key = hash(L1ToL2Transaction)

        // - value = status of the processing transaction (1 - success & 0 - fail)

        // - isService = true (just a conventional value)

        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)

        // - txNumberInBlock = number of transaction in the block

        L2Log memory l2Log = L2Log({

            l2ShardId: 0,

            isService: true,

            txNumberInBlock: _l2TxNumberInBlock,

            sender: L2_BOOTLOADER_ADDRESS,

            key: _l2TxHash,

            value: bytes32(uint256(_status))

        });

        return _proveL2LogInclusion(_l2BlockNumber, _l2MessageIndex, l2Log, _merkleProof);

    }



    /// @notice Transfer ether from the contract to the receiver

    /// @dev Reverts only if the transfer call failed

    function _withdrawFunds(address _to, uint256 _amount) internal {

        bool callSuccess;

        // Low-level assembly call, to avoid any memory copying (save gas)

        assembly {

            callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)

        }

        require(callSuccess, "pz");

    }



    /// @dev Prove that a specific L2 log was sent in a specific L2 block number

    function _proveL2LogInclusion(

        uint256 _blockNumber,

        uint256 _index,

        L2Log memory _log,

        bytes32[] calldata _proof

    ) internal view returns (bool) {

        require(_blockNumber <= s.totalBlocksExecuted, "xx");



        bytes32 hashedLog = keccak256(

            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBlock, _log.sender, _log.key, _log.value)

        );

        // Check that hashed log is not the default one,

        // otherwise it means that the value is out of range of sent L2 -> L1 logs

        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");

        // Check that the proof length is exactly the same as tree height, to prevent

        // any shorter/longer paths attack on the Merkle path validation

        require(_proof.length == L2_TO_L1_LOG_MERKLE_TREE_HEIGHT, "rz");



        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);

        bytes32 actualRootHash = s.l2LogsRootHashes[_blockNumber];



        return actualRootHash == calculatedRootHash;

    }



    /// @dev Convert arbitrary-length message to the raw l2 log

    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {

        return

            L2Log({

                l2ShardId: 0,

                isService: true,

                txNumberInBlock: _message.txNumberInBlock,

                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,

                key: bytes32(uint256(uint160(_message.sender))),

                value: keccak256(_message.data)

            });

    }



    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1

    /// @return The estimated L2 gas for the transaction to be paid

    function l2TransactionBaseCost(

        uint256 _gasPrice,

        uint256 _l2GasLimit,

        uint256 _l2GasPerPubdataByteLimit

    ) public pure returns (uint256) {

        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);

        return l2GasPrice * _l2GasLimit;

    }



    /// @notice Derives the price for L2 gas in ETH to be paid.

    /// @param _l1GasPrice The gas price on L1.

    /// @param _gasPricePerPubdata The price for each pubdata byte in L2 gas

    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPricePerPubdata) internal pure returns (uint256) {

        uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;

        uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;



        return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);

    }



    /// @notice Finalize the withdrawal and release funds

    /// @param _l2BlockNumber The L2 block number where the withdrawal was processed

    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message

    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent

    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message

    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization

    function finalizeEthWithdrawal(

        uint256 _l2BlockNumber,

        uint256 _l2MessageIndex,

        uint16 _l2TxNumberInBlock,

        bytes calldata _message,

        bytes32[] calldata _merkleProof

    ) external override nonReentrant senderCanCallFunction(s.allowList) {

        require(!s.isEthWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex], "jj");



        L2Message memory l2ToL1Message = L2Message({

            txNumberInBlock: _l2TxNumberInBlock,

            sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,

            data: _message

        });



        (address _l1WithdrawReceiver, uint256 _amount) = _parseL2WithdrawalMessage(_message);



        bool proofValid = proveL2MessageInclusion(_l2BlockNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);

        require(proofValid, "pi"); // Failed to verify that withdrawal was actually initialized on L2



        s.isEthWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex] = true;

        _withdrawFunds(_l1WithdrawReceiver, _amount);



        emit EthWithdrawalFinalized(_l1WithdrawReceiver, _amount);

    }



    /// @notice Request execution of L2 transaction from L1.

    /// @param _contractL2 The L2 receiver address

    /// @param _l2Value `msg.value` of L2 transaction

    /// @param _calldata The input of the L2 transaction

    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2

    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.

    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2

    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction. If the transaction fails,

    /// it will also be the address to receive `_l2Value`.

    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status

    function requestL2Transaction(

        address _contractL2,

        uint256 _l2Value,

        bytes calldata _calldata,

        uint256 _l2GasLimit,

        uint256 _l2GasPerPubdataByteLimit,

        bytes[] calldata _factoryDeps,

        address _refundRecipient

    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {

        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.

        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.

        address sender = msg.sender;

        if (sender != tx.origin) {

            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);

        }



        // Enforcing that `_l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed

        // to ensure that users do not get used to using "exotic" numbers for _l2GasPerPubdataByteLimit, e.g. 1-2, etc.

        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the

        // ability to provide `_l2GasPerPubdataByteLimit` for each independent transaction.

        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.

        require(_l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");



        // The L1 -> L2 transaction may be failed and funds will be sent to the `_refundRecipient`,

        // so we use `msg.value` instead of `_l2Value` as the bridged amount.

        _verifyDepositLimit(msg.sender, msg.value);

        canonicalTxHash = _requestL2Transaction(

            sender,

            _contractL2,

            _l2Value,

            _calldata,

            _l2GasLimit,

            _l2GasPerPubdataByteLimit,

            _factoryDeps,

            false,

            _refundRecipient

        );

    }



    function _verifyDepositLimit(address _depositor, uint256 _amount) internal {

        IAllowList.Deposit memory limitData = IAllowList(s.allowList).getTokenDepositLimitData(address(0)); // address(0) denotes the ETH

        if (!limitData.depositLimitation) return; // no deposit limitation is placed for ETH



        require(s.totalDepositedAmountPerUser[_depositor] + _amount <= limitData.depositCap, "d2");

        s.totalDepositedAmountPerUser[_depositor] += _amount;

    }



    function _requestL2Transaction(

        address _sender,

        address _contractAddressL2,

        uint256 _l2Value,

        bytes calldata _calldata,

        uint256 _l2GasLimit,

        uint256 _l2GasPerPubdataByteLimit,

        bytes[] calldata _factoryDeps,

        bool _isFree,

        address _refundRecipient

    ) internal returns (bytes32 canonicalTxHash) {

        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");

        uint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast

        uint256 txId = s.priorityQueue.getTotalPriorityTxs();



        // Here we manually assign fields for the struct to prevent "stack too deep" error

        WritePriorityOpParams memory params;



        // Checking that the user provided enough ether to pay for the transaction.

        // Using a new scope to prevent "stack too deep" error

        {

            params.l2GasPrice = _isFree ? 0 : _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);

            uint256 baseCost = params.l2GasPrice * _l2GasLimit;

            require(msg.value >= baseCost + _l2Value, "mv"); // The `msg.value` doesn't cover the transaction cost

        }



        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.

        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;

        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.

        if (refundRecipient.code.length > 0) {

            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);

        }



        params.sender = _sender;

        params.txId = txId;

        params.l2Value = _l2Value;

        params.contractAddressL2 = _contractAddressL2;

        params.expirationTimestamp = expirationTimestamp;

        params.l2GasLimit = _l2GasLimit;

        params.l2GasPricePerPubdata = _l2GasPerPubdataByteLimit;

        params.valueToMint = msg.value;

        params.refundRecipient = refundRecipient;



        canonicalTxHash = _writePriorityOp(params, _calldata, _factoryDeps);

    }



    function _serializeL2Transaction(

        WritePriorityOpParams memory _priorityOpParams,

        bytes calldata _calldata,

        bytes[] calldata _factoryDeps

    ) internal pure returns (L2CanonicalTransaction memory transaction) {

        transaction = L2CanonicalTransaction({

            txType: PRIORITY_OPERATION_L2_TX_TYPE,

            from: uint256(uint160(_priorityOpParams.sender)),

            to: uint256(uint160(_priorityOpParams.contractAddressL2)),

            gasLimit: _priorityOpParams.l2GasLimit,

            gasPerPubdataByteLimit: _priorityOpParams.l2GasPricePerPubdata,

            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),

            maxPriorityFeePerGas: uint256(0),

            paymaster: uint256(0),

            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions

            nonce: uint256(_priorityOpParams.txId),

            value: _priorityOpParams.l2Value,

            reserved: [_priorityOpParams.valueToMint, uint256(uint160(_priorityOpParams.refundRecipient)), 0, 0],

            data: _calldata,

            signature: new bytes(0),

            factoryDeps: _hashFactoryDeps(_factoryDeps),

            paymasterInput: new bytes(0),

            reservedDynamic: new bytes(0)

        });

    }



    /// @notice Stores a transaction record in storage & send event about that

    function _writePriorityOp(

        WritePriorityOpParams memory _priorityOpParams,

        bytes calldata _calldata,

        bytes[] calldata _factoryDeps

    ) internal returns (bytes32 canonicalTxHash) {

        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams, _calldata, _factoryDeps);



        bytes memory transactionEncoding = abi.encode(transaction);



        uint256 l2GasForTxBody = _getTransactionBodyGasLimit(

            _priorityOpParams.l2GasLimit,

            _priorityOpParams.l2GasPricePerPubdata,

            transactionEncoding.length

        );



        // Ensuring that the transaction is provable

        require(l2GasForTxBody <= s.priorityTxMaxGasLimit, "ui");

        // Ensuring that the transaction can not output more pubdata than is processable

        require(l2GasForTxBody / _priorityOpParams.l2GasPricePerPubdata <= PRIORITY_TX_MAX_PUBDATA, "uk");



        // Ensuring that the transaction covers the minimal costs for its processing:

        // hashing its content, publishing the factory dependencies, etc.

        require(

            _getMinimalPriorityTransactionGasLimit(

                transactionEncoding.length,

                _factoryDeps.length,

                _priorityOpParams.l2GasPricePerPubdata

            ) <= _priorityOpParams.l2GasLimit,

            "um"

        );



        canonicalTxHash = keccak256(transactionEncoding);



        s.priorityQueue.pushBack(

            PriorityOperation({

                canonicalTxHash: canonicalTxHash,

                expirationTimestamp: _priorityOpParams.expirationTimestamp,

                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)

            })

        );



        // Data that is needed for the operator to simulate priority queue offchain

        emit NewPriorityRequest(

            _priorityOpParams.txId,

            canonicalTxHash,

            _priorityOpParams.expirationTimestamp,

            transaction,

            _factoryDeps

        );

    }



    /// @dev Calculates the approximate minimum gas limit required for executing a priority transaction.

    /// @param _encodingLength The length of the priority transaction encoding in bytes.

    /// @param _numberOfFactoryDependencies The number of new factory dependencies that will be added.

    /// @param _l2GasPricePerPubdata The L2 gas price for publishing the priority transaction on L2.

    /// @return The minimum gas limit required to execute the priority transaction.

    /// Note: The calculation includes the main cost of the priority transaction, however, in reality, the operator can spend a little more gas on overheads.

    function _getMinimalPriorityTransactionGasLimit(

        uint256 _encodingLength,

        uint256 _numberOfFactoryDependencies,

        uint256 _l2GasPricePerPubdata

    ) internal pure returns (uint256) {

        uint256 costForComputation;

        {

            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which can not be easily accounted for

            costForComputation = L1_TX_INTRINSIC_L2_GAS;



            // Taking into account the hashing costs that depend on the length of the transaction

            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of

            // the transaction's encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round

            // and the size of each new encoding word).

            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);



            // Taking into the account the additional costs of providing new factory dependenies

            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;



            // There is a minimal amount of computational L2 gas that the transaction should cover

            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);

        }



        uint256 costForPubdata = 0;

        {

            // Adding the intrinsic cost for the transaction, i.e. auxilary prices which can not be easily accounted for

            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;



            // Taking into the account the additional costs of providing new factory dependenies

            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;

        }



        return costForComputation + costForPubdata;

    }



    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader

    function _hashFactoryDeps(bytes[] calldata _factoryDeps)

        internal

        pure

        returns (uint256[] memory hashedFactoryDeps)

    {

        uint256 factoryDepsLen = _factoryDeps.length;

        hashedFactoryDeps = new uint256[](factoryDepsLen);

        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {

            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);



            // Store the resulting hash sequentially in bytes.

            assembly {

                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)

            }

        }

    }



    /// @notice Based on the total L2 gas limit and several other parameters of the transaction

    /// returns the part of the L2 gas that will be spent on the block's overhead.

    /// @dev The details of how this function works can be checked in the documentation

    /// of the fee model of zkSync. The appropriate comments are also present

    /// in the Rust implementation description of function `get_maximal_allowed_overhead`.

    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the block

    /// and the L2 gas needed to process the transaction itself (i.e. the actual gasLimit that will be used for the transaction).

    function _getOverheadForTransaction(

        uint256 _totalGasLimit,

        uint256 _gasPricePerPubdata,

        uint256 _encodingLength

    ) internal pure returns (uint256 blockOverheadForTransaction) {

        uint256 blockOverheadGas = BLOCK_OVERHEAD_L2_GAS + BLOCK_OVERHEAD_PUBDATA * _gasPricePerPubdata;



        // The overhead from taking up the transaction's slot

        uint256 txSlotOverhead = Math.ceilDiv(blockOverheadGas, MAX_TRANSACTIONS_IN_BLOCK);

        blockOverheadForTransaction = Math.max(blockOverheadForTransaction, txSlotOverhead);



        // The overhead for occupying the bootloader memory can be derived from encoded_len

        uint256 overheadForLength = Math.ceilDiv(_encodingLength * blockOverheadGas, BOOTLOADER_TX_ENCODING_SPACE);

        blockOverheadForTransaction = Math.max(blockOverheadForTransaction, overheadForLength);



        // The overhead for possible published public data

        // TODO: possibly charge a separate fee for possible pubdata spending

        // uint256 overheadForPublicData;

        // {

        //     uint256 numerator = (blockOverheadGas * _totalGasLimit + _gasPricePerPubdata * MAX_PUBDATA_PER_BLOCK);

        //     uint256 denominator = (_gasPricePerPubdata * MAX_PUBDATA_PER_BLOCK + blockOverheadGas);



        //     overheadForPublicData = (numerator - 1) / denominator;

        // }

        // blockOverheadForTransaction = Math.max(blockOverheadForTransaction, overheadForPublicData);



        // The overhead for ergs that could be used to use single-instance circuits

        uint256 overheadForGas;

        {

            uint256 numerator = blockOverheadGas * _totalGasLimit + L2_TX_MAX_GAS_LIMIT;

            uint256 denominator = L2_TX_MAX_GAS_LIMIT + blockOverheadGas;



            overheadForGas = (numerator - 1) / denominator;

        }

        blockOverheadForTransaction = Math.max(blockOverheadForTransaction, overheadForGas);

    }



    /// @notice Based on the full L2 gas limit (that includes the block overhead) and other

    /// properties of the transaction, returns the l2GasLimit for the body of the transaction (the actual execution).

    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the block

    /// and the L2 gas needed to process the transaction itself (i.e. the actual l2GasLimit that will be used for the transaction).

    /// @param _gasPricePerPubdata The L2 gas price for each byte of pubdata.

    /// @param _encodingLength The length of the ABI-encoding of the transaction.

    function _getTransactionBodyGasLimit(

        uint256 _totalGasLimit,

        uint256 _gasPricePerPubdata,

        uint256 _encodingLength

    ) internal pure returns (uint256 txBodyGasLimit) {

        uint256 overhead = _getOverheadForTransaction(_totalGasLimit, _gasPricePerPubdata, _encodingLength);



        require(_totalGasLimit >= overhead, "my"); // provided gas limit doesn't cover transaction overhead

        unchecked {

            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.

            txBodyGasLimit = _totalGasLimit - overhead;

        }

    }



    /// @dev Decode the withdraw message that came from L2

    function _parseL2WithdrawalMessage(bytes memory _message)

        internal

        pure

        returns (address l1Receiver, uint256 amount)

    {

        // We check that the message is long enough to read the data.

        // Please note that there are two versions of the message:

        // 1. The message that is sent by `withdraw(address _l1Receiver)`

        // It should be equal to the length of the bytes4 function signature + address l1Receiver + uint256 amount = 4 + 20 + 32 = 56 (bytes).

        // 2. The message that is sent by `withdraw(address _l1Receiver, bytes calldata _additionalData)`

        // It should be equal to the length of the following:

        // bytes4 function signature + address l1Receiver + uint256 amount + address l2Sender + bytes _additionalData =

        // = 4 + 20 + 32 + 32 + _additionalData.length >= 68 (bytes).



        // So the data is expected to be at least 56 bytes long.

        require(_message.length >= 56, "pm");



        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_message, 0);

        require(bytes4(functionSignature) == this.finalizeEthWithdrawal.selector, "is");



        (l1Receiver, offset) = UnsafeBytes.readAddress(_message, offset);

        (amount, offset) = UnsafeBytes.readUint256(_message, offset);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Math.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)



pragma solidity ^0.8.0;



/**

 * @dev Standard math utilities missing in the Solidity language.

 */

library Math {

    enum Rounding {

        Down, // Toward negative infinity

        Up, // Toward infinity

        Zero // Toward zero

    }



    /**

     * @dev Returns the largest of two numbers.

     */

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a > b ? a : b;

    }



    /**

     * @dev Returns the smallest of two numbers.

     */

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    /**

     * @dev Returns the average of two numbers. The result is rounded towards

     * zero.

     */

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b) / 2 can overflow.

        return (a & b) + (a ^ b) / 2;

    }



    /**

     * @dev Returns the ceiling of the division of two numbers.

     *

     * This differs from standard division with `/` in that it rounds up instead

     * of rounding down.

     */

    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b - 1) / b can overflow on addition, so we distribute.

        return a == 0 ? 0 : (a - 1) / b + 1;

    }



    /**

     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)

     * with further edits by Uniswap Labs also under MIT license.

     */

    function mulDiv(

        uint256 x,

        uint256 y,

        uint256 denominator

    ) internal pure returns (uint256 result) {

        unchecked {

            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use

            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256

            // variables such that product = prod1 * 2^256 + prod0.

            uint256 prod0; // Least significant 256 bits of the product

            uint256 prod1; // Most significant 256 bits of the product

            assembly {

                let mm := mulmod(x, y, not(0))

                prod0 := mul(x, y)

                prod1 := sub(sub(mm, prod0), lt(mm, prod0))

            }



            // Handle non-overflow cases, 256 by 256 division.

            if (prod1 == 0) {

                return prod0 / denominator;

            }



            // Make sure the result is less than 2^256. Also prevents denominator == 0.

            require(denominator > prod1);



            ///////////////////////////////////////////////

            // 512 by 256 division.

            ///////////////////////////////////////////////



            // Make division exact by subtracting the remainder from [prod1 prod0].

            uint256 remainder;

            assembly {

                // Compute remainder using mulmod.

                remainder := mulmod(x, y, denominator)



                // Subtract 256 bit number from 512 bit number.

                prod1 := sub(prod1, gt(remainder, prod0))

                prod0 := sub(prod0, remainder)

            }



            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.

            // See https://cs.stackexchange.com/q/138556/92363.



            // Does not overflow because the denominator cannot be zero at this stage in the function.

            uint256 twos = denominator & (~denominator + 1);

            assembly {

                // Divide denominator by twos.

                denominator := div(denominator, twos)



                // Divide [prod1 prod0] by twos.

                prod0 := div(prod0, twos)



                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.

                twos := add(div(sub(0, twos), twos), 1)

            }



            // Shift in bits from prod1 into prod0.

            prod0 |= prod1 * twos;



            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such

            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for

            // four bits. That is, denominator * inv = 1 mod 2^4.

            uint256 inverse = (3 * denominator) ^ 2;



            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works

            // in modular arithmetic, doubling the correct bits in each step.

            inverse *= 2 - denominator * inverse; // inverse mod 2^8

            inverse *= 2 - denominator * inverse; // inverse mod 2^16

            inverse *= 2 - denominator * inverse; // inverse mod 2^32

            inverse *= 2 - denominator * inverse; // inverse mod 2^64

            inverse *= 2 - denominator * inverse; // inverse mod 2^128

            inverse *= 2 - denominator * inverse; // inverse mod 2^256



            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.

            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is

            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1

            // is no longer required.

            result = prod0 * inverse;

            return result;

        }

    }



    /**

     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.

     */

    function mulDiv(

        uint256 x,

        uint256 y,

        uint256 denominator,

        Rounding rounding

    ) internal pure returns (uint256) {

        uint256 result = mulDiv(x, y, denominator);

        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {

            result += 1;

        }

        return result;

    }



    /**

     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.

     *

     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).

     */

    function sqrt(uint256 a) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        }



        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.

        //

        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have

        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.

        //

        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`

        // ?¨² `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`

        // ?¨² `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`

        //

        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.

        uint256 result = 1 << (log2(a) >> 1);



        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,

        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at

        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision

        // into the expected uint128 result.

        unchecked {

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            return min(result, a / result);

        }

    }



    /**

     * @notice Calculates sqrt(a), following the selected rounding direction.

     */

    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = sqrt(a);

            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);

        }

    }



    /**

     * @dev Return the log in base 2, rounded down, of a positive value.

     * Returns 0 if given 0.

     */

    function log2(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >> 128 > 0) {

                value >>= 128;

                result += 128;

            }

            if (value >> 64 > 0) {

                value >>= 64;

                result += 64;

            }

            if (value >> 32 > 0) {

                value >>= 32;

                result += 32;

            }

            if (value >> 16 > 0) {

                value >>= 16;

                result += 16;

            }

            if (value >> 8 > 0) {

                value >>= 8;

                result += 8;

            }

            if (value >> 4 > 0) {

                value >>= 4;

                result += 4;

            }

            if (value >> 2 > 0) {

                value >>= 2;

                result += 2;

            }

            if (value >> 1 > 0) {

                result += 1;

            }

        }

        return result;

    }



    /**

     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.

     * Returns 0 if given 0.

     */

    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log2(value);

            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);

        }

    }



    /**

     * @dev Return the log in base 10, rounded down, of a positive value.

     * Returns 0 if given 0.

     */

    function log10(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >= 10**64) {

                value /= 10**64;

                result += 64;

            }

            if (value >= 10**32) {

                value /= 10**32;

                result += 32;

            }

            if (value >= 10**16) {

                value /= 10**16;

                result += 16;

            }

            if (value >= 10**8) {

                value /= 10**8;

                result += 8;

            }

            if (value >= 10**4) {

                value /= 10**4;

                result += 4;

            }

            if (value >= 10**2) {

                value /= 10**2;

                result += 2;

            }

            if (value >= 10**1) {

                result += 1;

            }

        }

        return result;

    }



    /**

     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.

     * Returns 0 if given 0.

     */

    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log10(value);

            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);

        }

    }



    /**

     * @dev Return the log in base 256, rounded down, of a positive value.

     * Returns 0 if given 0.

     *

     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.

     */

    function log256(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >> 128 > 0) {

                value >>= 128;

                result += 16;

            }

            if (value >> 64 > 0) {

                value >>= 64;

                result += 8;

            }

            if (value >> 32 > 0) {

                value >>= 32;

                result += 4;

            }

            if (value >> 16 > 0) {

                value >>= 16;

                result += 2;

            }

            if (value >> 8 > 0) {

                result += 1;

            }

        }

        return result;

    }



    /**

     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.

     * Returns 0 if given 0.

     */

    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log256(value);

            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\MathUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)



pragma solidity ^0.8.0;



/**

 * @dev Standard math utilities missing in the Solidity language.

 */

library MathUpgradeable {

    enum Rounding {

        Down, // Toward negative infinity

        Up, // Toward infinity

        Zero // Toward zero

    }



    /**

     * @dev Returns the largest of two numbers.

     */

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a > b ? a : b;

    }



    /**

     * @dev Returns the smallest of two numbers.

     */

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    /**

     * @dev Returns the average of two numbers. The result is rounded towards

     * zero.

     */

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b) / 2 can overflow.

        return (a & b) + (a ^ b) / 2;

    }



    /**

     * @dev Returns the ceiling of the division of two numbers.

     *

     * This differs from standard division with `/` in that it rounds up instead

     * of rounding down.

     */

    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b - 1) / b can overflow on addition, so we distribute.

        return a == 0 ? 0 : (a - 1) / b + 1;

    }



    /**

     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)

     * with further edits by Uniswap Labs also under MIT license.

     */

    function mulDiv(

        uint256 x,

        uint256 y,

        uint256 denominator

    ) internal pure returns (uint256 result) {

        unchecked {

            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use

            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256

            // variables such that product = prod1 * 2^256 + prod0.

            uint256 prod0; // Least significant 256 bits of the product

            uint256 prod1; // Most significant 256 bits of the product

            assembly {

                let mm := mulmod(x, y, not(0))

                prod0 := mul(x, y)

                prod1 := sub(sub(mm, prod0), lt(mm, prod0))

            }



            // Handle non-overflow cases, 256 by 256 division.

            if (prod1 == 0) {

                return prod0 / denominator;

            }



            // Make sure the result is less than 2^256. Also prevents denominator == 0.

            require(denominator > prod1);



            ///////////////////////////////////////////////

            // 512 by 256 division.

            ///////////////////////////////////////////////



            // Make division exact by subtracting the remainder from [prod1 prod0].

            uint256 remainder;

            assembly {

                // Compute remainder using mulmod.

                remainder := mulmod(x, y, denominator)



                // Subtract 256 bit number from 512 bit number.

                prod1 := sub(prod1, gt(remainder, prod0))

                prod0 := sub(prod0, remainder)

            }



            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.

            // See https://cs.stackexchange.com/q/138556/92363.



            // Does not overflow because the denominator cannot be zero at this stage in the function.

            uint256 twos = denominator & (~denominator + 1);

            assembly {

                // Divide denominator by twos.

                denominator := div(denominator, twos)



                // Divide [prod1 prod0] by twos.

                prod0 := div(prod0, twos)



                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.

                twos := add(div(sub(0, twos), twos), 1)

            }



            // Shift in bits from prod1 into prod0.

            prod0 |= prod1 * twos;



            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such

            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for

            // four bits. That is, denominator * inv = 1 mod 2^4.

            uint256 inverse = (3 * denominator) ^ 2;



            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works

            // in modular arithmetic, doubling the correct bits in each step.

            inverse *= 2 - denominator * inverse; // inverse mod 2^8

            inverse *= 2 - denominator * inverse; // inverse mod 2^16

            inverse *= 2 - denominator * inverse; // inverse mod 2^32

            inverse *= 2 - denominator * inverse; // inverse mod 2^64

            inverse *= 2 - denominator * inverse; // inverse mod 2^128

            inverse *= 2 - denominator * inverse; // inverse mod 2^256



            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.

            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is

            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1

            // is no longer required.

            result = prod0 * inverse;

            return result;

        }

    }



    /**

     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.

     */

    function mulDiv(

        uint256 x,

        uint256 y,

        uint256 denominator,

        Rounding rounding

    ) internal pure returns (uint256) {

        uint256 result = mulDiv(x, y, denominator);

        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {

            result += 1;

        }

        return result;

    }



    /**

     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.

     *

     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).

     */

    function sqrt(uint256 a) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        }



        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.

        //

        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have

        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.

        //

        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`

        // ?¨² `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`

        // ?¨² `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`

        //

        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.

        uint256 result = 1 << (log2(a) >> 1);



        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,

        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at

        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision

        // into the expected uint128 result.

        unchecked {

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            return min(result, a / result);

        }

    }



    /**

     * @notice Calculates sqrt(a), following the selected rounding direction.

     */

    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = sqrt(a);

            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);

        }

    }



    /**

     * @dev Return the log in base 2, rounded down, of a positive value.

     * Returns 0 if given 0.

     */

    function log2(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >> 128 > 0) {

                value >>= 128;

                result += 128;

            }

            if (value >> 64 > 0) {

                value >>= 64;

                result += 64;

            }

            if (value >> 32 > 0) {

                value >>= 32;

                result += 32;

            }

            if (value >> 16 > 0) {

                value >>= 16;

                result += 16;

            }

            if (value >> 8 > 0) {

                value >>= 8;

                result += 8;

            }

            if (value >> 4 > 0) {

                value >>= 4;

                result += 4;

            }

            if (value >> 2 > 0) {

                value >>= 2;

                result += 2;

            }

            if (value >> 1 > 0) {

                result += 1;

            }

        }

        return result;

    }



    /**

     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.

     * Returns 0 if given 0.

     */

    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log2(value);

            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);

        }

    }



    /**

     * @dev Return the log in base 10, rounded down, of a positive value.

     * Returns 0 if given 0.

     */

    function log10(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >= 10**64) {

                value /= 10**64;

                result += 64;

            }

            if (value >= 10**32) {

                value /= 10**32;

                result += 32;

            }

            if (value >= 10**16) {

                value /= 10**16;

                result += 16;

            }

            if (value >= 10**8) {

                value /= 10**8;

                result += 8;

            }

            if (value >= 10**4) {

                value /= 10**4;

                result += 4;

            }

            if (value >= 10**2) {

                value /= 10**2;

                result += 2;

            }

            if (value >= 10**1) {

                result += 1;

            }

        }

        return result;

    }



    /**

     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.

     * Returns 0 if given 0.

     */

    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log10(value);

            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);

        }

    }



    /**

     * @dev Return the log in base 256, rounded down, of a positive value.

     * Returns 0 if given 0.

     *

     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.

     */

    function log256(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >> 128 > 0) {

                value >>= 128;

                result += 16;

            }

            if (value >> 64 > 0) {

                value >>= 64;

                result += 8;

            }

            if (value >> 32 > 0) {

                value >>= 32;

                result += 4;

            }

            if (value >> 16 > 0) {

                value >>= 16;

                result += 2;

            }

            if (value >> 8 > 0) {

                result += 1;

            }

        }

        return result;

    }



    /**

     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.

     * Returns 0 if given 0.

     */

    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log256(value);

            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Merkle.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "../../common/libraries/UncheckedMath.sol";



/// @author Matter Labs

library Merkle {

    using UncheckedMath for uint256;



    /// @dev Calculate Merkle root by the provided Merkle proof.

    /// NOTE: When using this function, check that the _path length is equal to the tree height to prevent shorter/longer paths attack

    /// @param _path Merkle path from the leaf to the root

    /// @param _index Leaf index in the tree

    /// @param _itemHash Hash of leaf content

    /// @return The Merkle root

    function calculateRoot(

        bytes32[] calldata _path,

        uint256 _index,

        bytes32 _itemHash

    ) internal pure returns (bytes32) {

        uint256 pathLength = _path.length;

        require(pathLength > 0, "xc");

        require(pathLength < 256, "bt");

        require(_index < (1 << pathLength), "pz");



        bytes32 currentHash = _itemHash;

        for (uint256 i; i < pathLength; i = i.uncheckedInc()) {

            currentHash = (_index % 2 == 0)

                ? _efficientHash(currentHash, _path[i])

                : _efficientHash(_path[i], currentHash);

            _index /= 2;

        }



        return currentHash;

    }



    /// @dev Keccak hash of the concatenation of two 32-byte words

    function _efficientHash(bytes32 _lhs, bytes32 _rhs) private pure returns (bytes32 result) {

        assembly {

            mstore(0x00, _lhs)

            mstore(0x20, _rhs)

            result := keccak256(0x00, 0x40)

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\NFTFactory.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: UNLICENSED





interface NFTFactory {

    function mintNFTFromZkSync(

        address creator,

        address recipient,

        uint32 creatorAccountId,

        uint32 serialId,

        bytes32 contentHash,

        // Even though the token id can fit into the uint32, we still use

        // the uint256 to preserve consistency with the ERC721 parent contract

        uint256 tokenId

    ) external;



    event MintNFTFromZkSync(

        address indexed creator,

        address indexed recipient,

        uint32 creatorAccountId,

        uint32 serialId,

        bytes32 contentHash,

        uint256 tokenId

    );

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Operations.sol
File type: .sol
pragma solidity ^0.7.0;

pragma experimental ABIEncoderV2;



// SPDX-License-Identifier: MIT OR Apache-2.0











import "./Bytes.sol";

import "./Utils.sol";



/// @title zkSync operations tools

library Operations {

    // Circuit ops and their pubdata (chunks * bytes)



    /// @notice zkSync circuit operation type

    enum OpType {

        Noop,

        Deposit,

        TransferToNew,

        PartialExit,

        _CloseAccount, // used for correct op id offset

        Transfer,

        FullExit,

        ChangePubKey,

        ForcedExit,

        MintNFT,

        WithdrawNFT,

        Swap

    }



    // Byte lengths



    uint8 internal constant OP_TYPE_BYTES = 1;

    uint8 internal constant TOKEN_BYTES = 4;

    uint8 internal constant PUBKEY_BYTES = 32;

    uint8 internal constant NONCE_BYTES = 4;

    uint8 internal constant PUBKEY_HASH_BYTES = 20;

    uint8 internal constant ADDRESS_BYTES = 20;

    uint8 internal constant CONTENT_HASH_BYTES = 32;

    /// @dev Packed fee bytes lengths

    uint8 internal constant FEE_BYTES = 2;

    /// @dev zkSync account id bytes lengths

    uint8 internal constant ACCOUNT_ID_BYTES = 4;

    /// @dev zkSync nft serial id bytes lengths

    uint8 internal constant NFT_SERIAL_ID_BYTES = 4;

    uint8 internal constant AMOUNT_BYTES = 16;

    /// @dev Signature (for example full exit signature) bytes length

    uint8 internal constant SIGNATURE_BYTES = 64;



    // Deposit pubdata

    struct Deposit {

        // uint8 opType

        uint32 accountId;

        uint32 tokenId;

        uint128 amount;

        address owner;

    }



    uint256 internal constant PACKED_DEPOSIT_PUBDATA_BYTES =

        OP_TYPE_BYTES + ACCOUNT_ID_BYTES + TOKEN_BYTES + AMOUNT_BYTES + ADDRESS_BYTES;



    /// Deserialize deposit pubdata

    function readDepositPubdata(bytes memory _data) internal pure returns (Deposit memory parsed) {

        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.

        uint256 offset = OP_TYPE_BYTES;

        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId

        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset); // tokenId

        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount

        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner



        require(offset == PACKED_DEPOSIT_PUBDATA_BYTES, "N"); // reading invalid deposit pubdata size

    }



    /// Serialize deposit pubdata

    function writeDepositPubdataForPriorityQueue(Deposit memory op) internal pure returns (bytes memory buf) {

        buf = abi.encodePacked(

            uint8(OpType.Deposit),

            bytes4(0), // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)

            op.tokenId, // tokenId

            op.amount, // amount

            op.owner // owner

        );

    }



    /// @notice Write deposit pubdata for priority queue check.

    function checkDepositInPriorityQueue(Deposit memory op, bytes20 hashedPubdata) internal pure returns (bool) {

        return Utils.hashBytesToBytes20(writeDepositPubdataForPriorityQueue(op)) == hashedPubdata;

    }



    // FullExit pubdata



    struct FullExit {

        // uint8 opType

        uint32 accountId;

        address owner;

        uint32 tokenId;

        uint128 amount;

        uint32 nftCreatorAccountId;

        address nftCreatorAddress;

        uint32 nftSerialId;

        bytes32 nftContentHash;

    }



    uint256 public constant PACKED_FULL_EXIT_PUBDATA_BYTES =

        OP_TYPE_BYTES +

            ACCOUNT_ID_BYTES +

            ADDRESS_BYTES +

            TOKEN_BYTES +

            AMOUNT_BYTES +

            ACCOUNT_ID_BYTES +

            ADDRESS_BYTES +

            NFT_SERIAL_ID_BYTES +

            CONTENT_HASH_BYTES;



    function readFullExitPubdata(bytes memory _data) internal pure returns (FullExit memory parsed) {

        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.

        uint256 offset = OP_TYPE_BYTES;

        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId

        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner

        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset); // tokenId

        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount

        (offset, parsed.nftCreatorAccountId) = Bytes.readUInt32(_data, offset); // nftCreatorAccountId

        (offset, parsed.nftCreatorAddress) = Bytes.readAddress(_data, offset); // nftCreatorAddress

        (offset, parsed.nftSerialId) = Bytes.readUInt32(_data, offset); // nftSerialId

        (offset, parsed.nftContentHash) = Bytes.readBytes32(_data, offset); // nftContentHash



        require(offset == PACKED_FULL_EXIT_PUBDATA_BYTES, "O"); // reading invalid full exit pubdata size

    }



    function writeFullExitPubdataForPriorityQueue(FullExit memory op) internal pure returns (bytes memory buf) {

        buf = abi.encodePacked(

            uint8(OpType.FullExit),

            op.accountId, // accountId

            op.owner, // owner

            op.tokenId, // tokenId

            uint128(0), // amount -- ignored

            uint32(0), // nftCreatorAccountId -- ignored

            address(0), // nftCreatorAddress -- ignored

            uint32(0), // nftSerialId -- ignored

            bytes32(0) // nftContentHash -- ignored

        );

    }



    function checkFullExitInPriorityQueue(FullExit memory op, bytes20 hashedPubdata) internal pure returns (bool) {

        return Utils.hashBytesToBytes20(writeFullExitPubdataForPriorityQueue(op)) == hashedPubdata;

    }



    // PartialExit pubdata



    struct PartialExit {

        //uint8 opType; -- present in pubdata, ignored at serialization

        //uint32 accountId; -- present in pubdata, ignored at serialization

        uint32 tokenId;

        uint128 amount;

        //uint16 fee; -- present in pubdata, ignored at serialization

        address owner;

    }



    function readPartialExitPubdata(bytes memory _data) internal pure returns (PartialExit memory parsed) {

        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.

        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES; // opType + accountId (ignored)

        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset); // tokenId

        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount

        offset += FEE_BYTES; // fee (ignored)

        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner

    }



    // ForcedExit pubdata



    struct ForcedExit {

        //uint8 opType; -- present in pubdata, ignored at serialization

        //uint32 initiatorAccountId; -- present in pubdata, ignored at serialization

        //uint32 targetAccountId; -- present in pubdata, ignored at serialization

        uint32 tokenId;

        uint128 amount;

        //uint16 fee; -- present in pubdata, ignored at serialization

        address target;

    }



    function readForcedExitPubdata(bytes memory _data) internal pure returns (ForcedExit memory parsed) {

        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.

        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES * 2; // opType + initiatorAccountId + targetAccountId (ignored)

        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset); // tokenId

        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount

        offset += FEE_BYTES; // fee (ignored)

        (offset, parsed.target) = Bytes.readAddress(_data, offset); // target

    }



    // ChangePubKey



    enum ChangePubkeyType {

        ECRECOVER,

        CREATE2,

        OldECRECOVER,

        ECRECOVERV2

    }



    struct ChangePubKey {

        // uint8 opType; -- present in pubdata, ignored at serialization

        uint32 accountId;

        bytes20 pubKeyHash;

        address owner;

        uint32 nonce;

        //uint32 tokenId; -- present in pubdata, ignored at serialization

        //uint16 fee; -- present in pubdata, ignored at serialization

    }



    function readChangePubKeyPubdata(bytes memory _data) internal pure returns (ChangePubKey memory parsed) {

        uint256 offset = OP_TYPE_BYTES;

        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId

        (offset, parsed.pubKeyHash) = Bytes.readBytes20(_data, offset); // pubKeyHash

        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner

        (offset, parsed.nonce) = Bytes.readUInt32(_data, offset); // nonce

    }



    struct WithdrawNFT {

        //uint8 opType; -- present in pubdata, ignored at serialization

        //uint32 accountId; -- present in pubdata, ignored at serialization

        uint32 creatorAccountId;

        address creatorAddress;

        uint32 serialId;

        bytes32 contentHash;

        address receiver;

        uint32 tokenId;

        //uint32 feeTokenId;

        //uint16 fee; -- present in pubdata, ignored at serialization

    }



    function readWithdrawNFTPubdata(bytes memory _data) internal pure returns (WithdrawNFT memory parsed) {

        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES; // opType + accountId (ignored)

        (offset, parsed.creatorAccountId) = Bytes.readUInt32(_data, offset);

        (offset, parsed.creatorAddress) = Bytes.readAddress(_data, offset);

        (offset, parsed.serialId) = Bytes.readUInt32(_data, offset);

        (offset, parsed.contentHash) = Bytes.readBytes32(_data, offset);

        (offset, parsed.receiver) = Bytes.readAddress(_data, offset);

        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\OperatorFiltererUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;



import {IOperatorFilterRegistry} from "../IOperatorFilterRegistry.sol";

import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";



/**

 * @title  OperatorFiltererUpgradeable

 * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another

 *         registrant's entries in the OperatorFilterRegistry when the init function is called.

 * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:

 *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.

 *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.

 */

abstract contract OperatorFiltererUpgradeable is Initializable {

    /// @notice Emitted when an operator is not allowed.

    error OperatorNotAllowed(address operator);



    IOperatorFilterRegistry constant OPERATOR_FILTER_REGISTRY =

        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);



    /// @dev The upgradeable initialize function that should be called when the contract is being upgraded.

    function __OperatorFilterer_init(address subscriptionOrRegistrantToCopy, bool subscribe)

        internal

        onlyInitializing

    {

        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier

        // will not revert, but the contract will need to be registered with the registry once it is deployed in

        // order for the modifier to filter addresses.

        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {

            if (!OPERATOR_FILTER_REGISTRY.isRegistered(address(this))) {

                if (subscribe) {

                    OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);

                } else {

                    if (subscriptionOrRegistrantToCopy != address(0)) {

                        OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);

                    } else {

                        OPERATOR_FILTER_REGISTRY.register(address(this));

                    }

                }

            }

        }

    }



    /**

     * @dev A helper modifier to check if the operator is allowed.

     */

    modifier onlyAllowedOperator(address from) virtual {

        // Allow spending tokens from addresses with balance

        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred

        // from an EOA.

        if (from != msg.sender) {

            _checkFilterOperator(msg.sender);

        }

        _;

    }



    /**

     * @dev A helper modifier to check if the operator approval is allowed.

     */

    modifier onlyAllowedOperatorApproval(address operator) virtual {

        _checkFilterOperator(operator);

        _;

    }



    /**

     * @dev A helper function to check if the operator is allowed.

     */

    function _checkFilterOperator(address operator) internal view virtual {

        // Check registry code length to facilitate testing in environments without a deployed registry.

        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {

            // under normal circumstances, this function will revert rather than return false, but inheriting or

            // upgraded contracts may specify their own OperatorFilterRegistry implementations, which may behave

            // differently

            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {

                revert OperatorNotAllowed(operator);

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)



pragma solidity ^0.8.0;



import "../utils/Context.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _transferOwnership(_msgSender());

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        _checkOwner();

        _;

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if the sender is not the owner.

     */

    function _checkOwner() internal view virtual {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _transferOwnership(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Internal function without access restriction.

     */

    function _transferOwnership(address newOwner) internal virtual {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Ownable2Step.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)



pragma solidity ^0.8.0;



import "./Ownable.sol";



/**

 * @dev Contract module which provides access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership} and {acceptOwnership}.

 *

 * This module is used through inheritance. It will make available all functions

 * from parent (Ownable).

 */

abstract contract Ownable2Step is Ownable {

    address private _pendingOwner;



    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Returns the address of the pending owner.

     */

    function pendingOwner() public view virtual returns (address) {

        return _pendingOwner;

    }



    /**

     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual override onlyOwner {

        _pendingOwner = newOwner;

        emit OwnershipTransferStarted(owner(), newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.

     * Internal function without access restriction.

     */

    function _transferOwnership(address newOwner) internal virtual override {

        delete _pendingOwner;

        super._transferOwnership(newOwner);

    }



    /**

     * @dev The new owner accepts the ownership transfer.

     */

    function acceptOwnership() external {

        address sender = _msgSender();

        require(pendingOwner() == sender, "Ownable2Step: caller is not the new owner");

        _transferOwnership(sender);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\OwnableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)



pragma solidity ^0.8.0;



import "../utils/ContextUpgradeable.sol";

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    function __Ownable_init() internal onlyInitializing {

        __Ownable_init_unchained();

    }



    function __Ownable_init_unchained() internal onlyInitializing {

        _transferOwnership(_msgSender());

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        _checkOwner();

        _;

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if the sender is not the owner.

     */

    function _checkOwner() internal view virtual {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _transferOwnership(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Internal function without access restriction.

     */

    function _transferOwnership(address newOwner) internal virtual {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\PairingsBn254.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







library PairingsBn254 {

    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

    uint256 constant bn254_b_coeff = 3;



    struct G1Point {

        uint256 X;

        uint256 Y;

    }



    struct Fr {

        uint256 value;

    }



    function new_fr(uint256 fr) internal pure returns (Fr memory) {

        require(fr < r_mod);

        return Fr({value: fr});

    }



    function copy(Fr memory self) internal pure returns (Fr memory n) {

        n.value = self.value;

    }



    function assign(Fr memory self, Fr memory other) internal pure {

        self.value = other.value;

    }



    function inverse(Fr memory fr) internal view returns (Fr memory) {

        require(fr.value != 0);

        return pow(fr, r_mod - 2);

    }



    function add_assign(Fr memory self, Fr memory other) internal pure {

        self.value = addmod(self.value, other.value, r_mod);

    }



    function sub_assign(Fr memory self, Fr memory other) internal pure {

        self.value = addmod(self.value, r_mod - other.value, r_mod);

    }



    function mul_assign(Fr memory self, Fr memory other) internal pure {

        self.value = mulmod(self.value, other.value, r_mod);

    }



    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {

        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];

        uint256[1] memory result;

        bool success;

        assembly {

            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)

        }

        require(success);

        return Fr({value: result[0]});

    }



    // Encoding of field elements is: X[0] * z + X[1]

    struct G2Point {

        uint256[2] X;

        uint256[2] Y;

    }



    function P1() internal pure returns (G1Point memory) {

        return G1Point(1, 2);

    }



    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {

        return G1Point(x, y);

    }



    // function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {

    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {

        if (x == 0 && y == 0) {

            // point of infinity is (0,0)

            return G1Point(x, y);

        }



        // check encoding

        require(x < q_mod, "x axis isn't valid");

        require(y < q_mod, "y axis isn't valid");

        // check on curve

        uint256 lhs = mulmod(y, y, q_mod); // y^2



        uint256 rhs = mulmod(x, x, q_mod); // x^2

        rhs = mulmod(rhs, x, q_mod); // x^3

        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b

        require(lhs == rhs, "is not on curve");



        return G1Point(x, y);

    }



    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {

        return G2Point(x, y);

    }



    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {

        result.X = self.X;

        result.Y = self.Y;

    }



    function P2() internal pure returns (G2Point memory) {

        // for some reason ethereum expects to have c1*v + c0 form



        return

            G2Point(

                [

                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,

                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed

                ],

                [

                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,

                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa

                ]

            );

    }



    function negate(G1Point memory self) internal pure {

        // The prime q in the base field F_q for G1

        if (self.Y == 0) {

            require(self.X == 0);

            return;

        }



        self.Y = q_mod - self.Y;

    }



    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {

        point_add_into_dest(p1, p2, r);

        return r;

    }



    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {

        point_add_into_dest(p1, p2, p1);

    }



    function point_add_into_dest(

        G1Point memory p1,

        G1Point memory p2,

        G1Point memory dest

    ) internal view {

        if (p2.X == 0 && p2.Y == 0) {

            // we add zero, nothing happens

            dest.X = p1.X;

            dest.Y = p1.Y;

            return;

        } else if (p1.X == 0 && p1.Y == 0) {

            // we add into zero, and we add non-zero point

            dest.X = p2.X;

            dest.Y = p2.Y;

            return;

        } else {

            uint256[4] memory input;



            input[0] = p1.X;

            input[1] = p1.Y;

            input[2] = p2.X;

            input[3] = p2.Y;



            bool success;

            assembly {

                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)

            }

            require(success);

        }

    }



    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {

        point_sub_into_dest(p1, p2, p1);

    }



    function point_sub_into_dest(

        G1Point memory p1,

        G1Point memory p2,

        G1Point memory dest

    ) internal view {

        if (p2.X == 0 && p2.Y == 0) {

            // we subtracted zero, nothing happens

            dest.X = p1.X;

            dest.Y = p1.Y;

            return;

        } else if (p1.X == 0 && p1.Y == 0) {

            // we subtract from zero, and we subtract non-zero point

            dest.X = p2.X;

            dest.Y = q_mod - p2.Y;

            return;

        } else {

            uint256[4] memory input;



            input[0] = p1.X;

            input[1] = p1.Y;

            input[2] = p2.X;

            input[3] = q_mod - p2.Y;



            bool success = false;

            assembly {

                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)

            }

            require(success);

        }

    }



    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {

        // https://eips.ethereum.org/EIPS/eip-197

        // Elliptic curve points are encoded as a Jacobian pair (X, Y) where the point at infinity is encoded as (0, 0)

        if (p.X == 0 && p.Y == 1) {

            p.Y = 0;

        }

        point_mul_into_dest(p, s, r);

        return r;

    }



    function point_mul_assign(G1Point memory p, Fr memory s) internal view {

        point_mul_into_dest(p, s, p);

    }



    function point_mul_into_dest(

        G1Point memory p,

        Fr memory s,

        G1Point memory dest

    ) internal view {

        uint256[3] memory input;

        input[0] = p.X;

        input[1] = p.Y;

        input[2] = s.value;

        bool success;

        assembly {

            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)

        }

        require(success);

    }



    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {

        require(p1.length == p2.length);

        uint256 elements = p1.length;

        uint256 inputSize = elements * 6;

        uint256[] memory input = new uint256[](inputSize);

        for (uint256 i = 0; i < elements; ) {

            input[i * 6 + 0] = p1[i].X;

            input[i * 6 + 1] = p1[i].Y;

            input[i * 6 + 2] = p2[i].X[0];

            input[i * 6 + 3] = p2[i].X[1];

            input[i * 6 + 4] = p2[i].Y[0];

            input[i * 6 + 5] = p2[i].Y[1];

            unchecked {

                ++i;

            }

        }

        uint256[1] memory out;

        bool success;

        assembly {

            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)

        }

        require(success);

        return out[0] != 0;

    }



    /// Convenience method for a pairing check for two pairs.

    function pairingProd2(

        G1Point memory a1,

        G2Point memory a2,

        G1Point memory b1,

        G2Point memory b2

    ) internal view returns (bool) {

        G1Point[] memory p1 = new G1Point[](2);

        G2Point[] memory p2 = new G2Point[](2);

        p1[0] = a1;

        p1[1] = b1;

        p2[0] = a2;

        p2[1] = b2;

        return pairing(p1, p2);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\PausableUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)



pragma solidity ^0.8.0;



import "../utils/ContextUpgradeable.sol";

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module which allows children to implement an emergency stop

 * mechanism that can be triggered by an authorized account.

 *

 * This module is used through inheritance. It will make available the

 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to

 * the functions of your contract. Note that they will not be pausable by

 * simply including this module, only once the modifiers are put in place.

 */

abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {

    /**

     * @dev Emitted when the pause is triggered by `account`.

     */

    event Paused(address account);



    /**

     * @dev Emitted when the pause is lifted by `account`.

     */

    event Unpaused(address account);



    bool private _paused;



    /**

     * @dev Initializes the contract in unpaused state.

     */

    function __Pausable_init() internal onlyInitializing {

        __Pausable_init_unchained();

    }



    function __Pausable_init_unchained() internal onlyInitializing {

        _paused = false;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is not paused.

     *

     * Requirements:

     *

     * - The contract must not be paused.

     */

    modifier whenNotPaused() {

        _requireNotPaused();

        _;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is paused.

     *

     * Requirements:

     *

     * - The contract must be paused.

     */

    modifier whenPaused() {

        _requirePaused();

        _;

    }



    /**

     * @dev Returns true if the contract is paused, and false otherwise.

     */

    function paused() public view virtual returns (bool) {

        return _paused;

    }



    /**

     * @dev Throws if the contract is paused.

     */

    function _requireNotPaused() internal view virtual {

        require(!paused(), "Pausable: paused");

    }



    /**

     * @dev Throws if the contract is not paused.

     */

    function _requirePaused() internal view virtual {

        require(paused(), "Pausable: not paused");

    }



    /**

     * @dev Triggers stopped state.

     *

     * Requirements:

     *

     * - The contract must not be paused.

     */

    function _pause() internal virtual whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    /**

     * @dev Returns to normal state.

     *

     * Requirements:

     *

     * - The contract must be paused.

     */

    function _unpause() internal virtual whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Plonk4VerifierWithAccessToDNext.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "./libraries/PairingsBn254.sol";

import "./libraries/TranscriptLib.sol";

import "../common/libraries/UncheckedMath.sol";



uint256 constant STATE_WIDTH = 4;

uint256 constant NUM_G2_ELS = 2;



struct VerificationKey {

    uint256 domain_size;

    uint256 num_inputs;

    PairingsBn254.Fr omega;

    PairingsBn254.G1Point[2] gate_selectors_commitments;

    PairingsBn254.G1Point[8] gate_setup_commitments;

    PairingsBn254.G1Point[STATE_WIDTH] permutation_commitments;

    PairingsBn254.G1Point lookup_selector_commitment;

    PairingsBn254.G1Point[4] lookup_tables_commitments;

    PairingsBn254.G1Point lookup_table_type_commitment;

    PairingsBn254.Fr[STATE_WIDTH - 1] non_residues;

    PairingsBn254.G2Point[NUM_G2_ELS] g2_elements;

}



contract Plonk4VerifierWithAccessToDNext {

    using PairingsBn254 for PairingsBn254.G1Point;

    using PairingsBn254 for PairingsBn254.G2Point;

    using PairingsBn254 for PairingsBn254.Fr;



    using TranscriptLib for TranscriptLib.Transcript;



    using UncheckedMath for uint256;



    struct Proof {

        uint256[] input_values;

        // commitments

        PairingsBn254.G1Point[STATE_WIDTH] state_polys_commitments;

        PairingsBn254.G1Point copy_permutation_grand_product_commitment;

        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_parts_commitments;

        // openings

        PairingsBn254.Fr[STATE_WIDTH] state_polys_openings_at_z;

        PairingsBn254.Fr[1] state_polys_openings_at_z_omega;

        PairingsBn254.Fr[1] gate_selectors_openings_at_z;

        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_polys_openings_at_z;

        PairingsBn254.Fr copy_permutation_grand_product_opening_at_z_omega;

        PairingsBn254.Fr quotient_poly_opening_at_z;

        PairingsBn254.Fr linearization_poly_opening_at_z;

        // lookup commitments

        PairingsBn254.G1Point lookup_s_poly_commitment;

        PairingsBn254.G1Point lookup_grand_product_commitment;

        // lookup openings

        PairingsBn254.Fr lookup_s_poly_opening_at_z_omega;

        PairingsBn254.Fr lookup_grand_product_opening_at_z_omega;

        PairingsBn254.Fr lookup_t_poly_opening_at_z;

        PairingsBn254.Fr lookup_t_poly_opening_at_z_omega;

        PairingsBn254.Fr lookup_selector_poly_opening_at_z;

        PairingsBn254.Fr lookup_table_type_poly_opening_at_z;

        PairingsBn254.G1Point opening_proof_at_z;

        PairingsBn254.G1Point opening_proof_at_z_omega;

    }



    struct PartialVerifierState {

        PairingsBn254.Fr zero;

        PairingsBn254.Fr alpha;

        PairingsBn254.Fr beta;

        PairingsBn254.Fr gamma;

        PairingsBn254.Fr[9] alpha_values;

        PairingsBn254.Fr eta;

        PairingsBn254.Fr beta_lookup;

        PairingsBn254.Fr gamma_lookup;

        PairingsBn254.Fr beta_plus_one;

        PairingsBn254.Fr beta_gamma;

        PairingsBn254.Fr v;

        PairingsBn254.Fr u;

        PairingsBn254.Fr z;

        PairingsBn254.Fr z_omega;

        PairingsBn254.Fr z_minus_last_omega;

        PairingsBn254.Fr l_0_at_z;

        PairingsBn254.Fr l_n_minus_one_at_z;

        PairingsBn254.Fr t;

        PairingsBn254.G1Point tp;

    }



    function evaluate_l0_at_point(uint256 domain_size, PairingsBn254.Fr memory at)

        internal

        view

        returns (PairingsBn254.Fr memory num)

    {

        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);



        PairingsBn254.Fr memory size_fe = PairingsBn254.new_fr(domain_size);

        PairingsBn254.Fr memory den = at.copy();

        den.sub_assign(one);

        den.mul_assign(size_fe);



        den = den.inverse();



        num = at.pow(domain_size);

        num.sub_assign(one);

        num.mul_assign(den);

    }



    function evaluate_lagrange_poly_out_of_domain(

        uint256 poly_num,

        uint256 domain_size,

        PairingsBn254.Fr memory omega,

        PairingsBn254.Fr memory at

    ) internal view returns (PairingsBn254.Fr memory res) {

        // (omega^i / N) / (X - omega^i) * (X^N - 1)

        require(poly_num < domain_size);

        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);

        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);

        res = at.pow(domain_size);

        res.sub_assign(one);

        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`

        res.mul_assign(omega_power);



        PairingsBn254.Fr memory den = PairingsBn254.copy(at);

        den.sub_assign(omega_power);

        den.mul_assign(PairingsBn254.new_fr(domain_size));



        den = den.inverse();



        res.mul_assign(den);

    }



    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)

        internal

        view

        returns (PairingsBn254.Fr memory res)

    {

        res = at.pow(domain_size);

        res.sub_assign(PairingsBn254.new_fr(1));

    }



    function initialize_transcript(Proof memory proof, VerificationKey memory vk)

        internal

        pure

        returns (PartialVerifierState memory state)

    {

        TranscriptLib.Transcript memory transcript = TranscriptLib.new_transcript();



        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {

            transcript.update_with_u256(proof.input_values[i]);

        }



        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {

            transcript.update_with_g1(proof.state_polys_commitments[i]);

        }



        state.eta = transcript.get_challenge();

        transcript.update_with_g1(proof.lookup_s_poly_commitment);



        state.beta = transcript.get_challenge();

        state.gamma = transcript.get_challenge();



        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);

        state.beta_lookup = transcript.get_challenge();

        state.gamma_lookup = transcript.get_challenge();

        transcript.update_with_g1(proof.lookup_grand_product_commitment);

        state.alpha = transcript.get_challenge();



        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {

            transcript.update_with_g1(proof.quotient_poly_parts_commitments[i]);

        }

        state.z = transcript.get_challenge();



        transcript.update_with_fr(proof.quotient_poly_opening_at_z);



        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {

            transcript.update_with_fr(proof.state_polys_openings_at_z[i]);

        }



        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {

            transcript.update_with_fr(proof.state_polys_openings_at_z_omega[i]);

        }

        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {

            transcript.update_with_fr(proof.gate_selectors_openings_at_z[i]);

        }

        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {

            transcript.update_with_fr(proof.copy_permutation_polys_openings_at_z[i]);

        }



        state.z_omega = state.z.copy();

        state.z_omega.mul_assign(vk.omega);



        transcript.update_with_fr(proof.copy_permutation_grand_product_opening_at_z_omega);



        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z);

        transcript.update_with_fr(proof.lookup_selector_poly_opening_at_z);

        transcript.update_with_fr(proof.lookup_table_type_poly_opening_at_z);

        transcript.update_with_fr(proof.lookup_s_poly_opening_at_z_omega);

        transcript.update_with_fr(proof.lookup_grand_product_opening_at_z_omega);

        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z_omega);

        transcript.update_with_fr(proof.linearization_poly_opening_at_z);



        state.v = transcript.get_challenge();



        transcript.update_with_g1(proof.opening_proof_at_z);

        transcript.update_with_g1(proof.opening_proof_at_z_omega);



        state.u = transcript.get_challenge();

    }



    // compute some powers of challenge alpha([alpha^1, .. alpha^8])

    function compute_powers_of_alpha(PartialVerifierState memory state) public pure {

        require(state.alpha.value != 0);

        state.alpha_values[0] = PairingsBn254.new_fr(1);

        state.alpha_values[1] = state.alpha.copy();

        PairingsBn254.Fr memory current_alpha = state.alpha.copy();

        for (uint256 i = 2; i < state.alpha_values.length; i = i.uncheckedInc()) {

            current_alpha.mul_assign(state.alpha);

            state.alpha_values[i] = current_alpha.copy();

        }

    }



    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {

        // we initialize all challenges beforehand, we can draw each challenge in its own place

        PartialVerifierState memory state = initialize_transcript(proof, vk);

        if (verify_quotient_evaluation(vk, proof, state) == false) {

            return false;

        }

        require(proof.state_polys_openings_at_z_omega.length == 1);



        PairingsBn254.G1Point memory quotient_result = proof.quotient_poly_parts_commitments[0].copy_g1();

        {

            // block scope

            PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);

            PairingsBn254.Fr memory current_z = z_in_domain_size.copy();

            PairingsBn254.G1Point memory tp;

            // start from i =1

            for (uint256 i = 1; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {

                tp = proof.quotient_poly_parts_commitments[i].copy_g1();

                tp.point_mul_assign(current_z);

                quotient_result.point_add_assign(tp);



                current_z.mul_assign(z_in_domain_size);

            }

        }



        Queries memory queries = prepare_queries(vk, proof, state);

        queries.commitments_at_z[0] = quotient_result;

        queries.values_at_z[0] = proof.quotient_poly_opening_at_z;

        queries.commitments_at_z[1] = aggregated_linearization_commitment(vk, proof, state);

        queries.values_at_z[1] = proof.linearization_poly_opening_at_z;



        require(queries.commitments_at_z.length == queries.values_at_z.length);



        PairingsBn254.G1Point memory aggregated_commitment_at_z = queries.commitments_at_z[0];



        PairingsBn254.Fr memory aggregated_opening_at_z = queries.values_at_z[0];

        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);

        PairingsBn254.G1Point memory scaled;

        for (uint256 i = 1; i < queries.commitments_at_z.length; i = i.uncheckedInc()) {

            aggregation_challenge.mul_assign(state.v);

            scaled = queries.commitments_at_z[i].point_mul(aggregation_challenge);

            aggregated_commitment_at_z.point_add_assign(scaled);



            state.t = queries.values_at_z[i];

            state.t.mul_assign(aggregation_challenge);

            aggregated_opening_at_z.add_assign(state.t);

        }



        aggregation_challenge.mul_assign(state.v);



        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega = queries.commitments_at_z_omega[0].point_mul(

            aggregation_challenge

        );

        PairingsBn254.Fr memory aggregated_opening_at_z_omega = queries.values_at_z_omega[0];

        aggregated_opening_at_z_omega.mul_assign(aggregation_challenge);

        for (uint256 i = 1; i < queries.commitments_at_z_omega.length; i = i.uncheckedInc()) {

            aggregation_challenge.mul_assign(state.v);



            scaled = queries.commitments_at_z_omega[i].point_mul(aggregation_challenge);

            aggregated_commitment_at_z_omega.point_add_assign(scaled);



            state.t = queries.values_at_z_omega[i];

            state.t.mul_assign(aggregation_challenge);

            aggregated_opening_at_z_omega.add_assign(state.t);

        }



        return

            final_pairing(

                vk.g2_elements,

                proof,

                state,

                aggregated_commitment_at_z,

                aggregated_commitment_at_z_omega,

                aggregated_opening_at_z,

                aggregated_opening_at_z_omega

            );

    }



    function verify_quotient_evaluation(

        VerificationKey memory vk,

        Proof memory proof,

        PartialVerifierState memory state

    ) internal view returns (bool) {

        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);

        for (uint256 i = 0; i < lagrange_poly_numbers.length; i = i.uncheckedInc()) {

            lagrange_poly_numbers[i] = i;

        }

        require(vk.num_inputs > 0);



        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);

        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {

            state.t = evaluate_lagrange_poly_out_of_domain(i, vk.domain_size, vk.omega, state.z);

            state.t.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));

            inputs_term.add_assign(state.t);

        }

        inputs_term.mul_assign(proof.gate_selectors_openings_at_z[0]);

        PairingsBn254.Fr memory result = proof.linearization_poly_opening_at_z.copy();

        result.add_assign(inputs_term);



        // compute powers of alpha

        compute_powers_of_alpha(state);

        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();

        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);



        // - alpha_0 * (a + perm(z) * beta + gamma)*()*(d + gamma) * z(z*omega)

        require(proof.copy_permutation_polys_openings_at_z.length == STATE_WIDTH - 1);

        PairingsBn254.Fr memory t; // TMP;

        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {

            t = proof.copy_permutation_polys_openings_at_z[i].copy();

            t.mul_assign(state.beta);

            t.add_assign(proof.state_polys_openings_at_z[i]);

            t.add_assign(state.gamma);



            factor.mul_assign(t);

        }



        t = proof.state_polys_openings_at_z[3].copy();

        t.add_assign(state.gamma);

        factor.mul_assign(t);

        result.sub_assign(factor);



        // - L_0(z) * alpha_1

        PairingsBn254.Fr memory l_0_at_z = evaluate_l0_at_point(vk.domain_size, state.z);

        l_0_at_z.mul_assign(state.alpha_values[4 + 1]);

        result.sub_assign(l_0_at_z);



        PairingsBn254.Fr memory lookup_quotient_contrib = lookup_quotient_contribution(vk, proof, state);

        result.add_assign(lookup_quotient_contrib);



        PairingsBn254.Fr memory lhs = proof.quotient_poly_opening_at_z.copy();

        lhs.mul_assign(evaluate_vanishing(vk.domain_size, state.z));

        return lhs.value == result.value;

    }



    function lookup_quotient_contribution(

        VerificationKey memory vk,

        Proof memory proof,

        PartialVerifierState memory state

    ) internal view returns (PairingsBn254.Fr memory result) {

        PairingsBn254.Fr memory t;



        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);

        state.beta_plus_one = state.beta_lookup.copy();

        state.beta_plus_one.add_assign(one);

        state.beta_gamma = state.beta_plus_one.copy();

        state.beta_gamma.mul_assign(state.gamma_lookup);



        // (s'*beta + gamma)*(zw')*alpha

        t = proof.lookup_s_poly_opening_at_z_omega.copy();

        t.mul_assign(state.beta_lookup);

        t.add_assign(state.beta_gamma);

        t.mul_assign(proof.lookup_grand_product_opening_at_z_omega);

        t.mul_assign(state.alpha_values[6]);



        // (z - omega^{n-1}) for this part

        PairingsBn254.Fr memory last_omega = vk.omega.pow(vk.domain_size - 1);

        state.z_minus_last_omega = state.z.copy();

        state.z_minus_last_omega.sub_assign(last_omega);

        t.mul_assign(state.z_minus_last_omega);

        result.add_assign(t);



        // - alpha_1 * L_{0}(z)

        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);

        t = state.l_0_at_z.copy();

        t.mul_assign(state.alpha_values[6 + 1]);

        result.sub_assign(t);



        // - alpha_2 * beta_gamma_powered L_{n-1}(z)

        PairingsBn254.Fr memory beta_gamma_powered = state.beta_gamma.pow(vk.domain_size - 1);

        state.l_n_minus_one_at_z = evaluate_lagrange_poly_out_of_domain(

            vk.domain_size - 1,

            vk.domain_size,

            vk.omega,

            state.z

        );

        t = state.l_n_minus_one_at_z.copy();

        t.mul_assign(beta_gamma_powered);

        t.mul_assign(state.alpha_values[6 + 2]);



        result.sub_assign(t);

    }



    function aggregated_linearization_commitment(

        VerificationKey memory vk,

        Proof memory proof,

        PartialVerifierState memory state

    ) internal view returns (PairingsBn254.G1Point memory result) {

        // qMain*(Q_a * A + Q_b * B + Q_c * C + Q_d * D + Q_m * A*B + Q_const + Q_dNext * D_next)

        result = PairingsBn254.new_g1(0, 0);

        // Q_a * A

        PairingsBn254.G1Point memory scaled = vk.gate_setup_commitments[0].point_mul(

            proof.state_polys_openings_at_z[0]

        );

        result.point_add_assign(scaled);

        // Q_b * B

        scaled = vk.gate_setup_commitments[1].point_mul(proof.state_polys_openings_at_z[1]);

        result.point_add_assign(scaled);

        // Q_c * C

        scaled = vk.gate_setup_commitments[2].point_mul(proof.state_polys_openings_at_z[2]);

        result.point_add_assign(scaled);

        // Q_d * D

        scaled = vk.gate_setup_commitments[3].point_mul(proof.state_polys_openings_at_z[3]);

        result.point_add_assign(scaled);

        // Q_m* A*B or Q_ab*A*B

        PairingsBn254.Fr memory t = proof.state_polys_openings_at_z[0].copy();

        t.mul_assign(proof.state_polys_openings_at_z[1]);

        scaled = vk.gate_setup_commitments[4].point_mul(t);

        result.point_add_assign(scaled);

        // Q_AC* A*C

        t = proof.state_polys_openings_at_z[0].copy();

        t.mul_assign(proof.state_polys_openings_at_z[2]);

        scaled = vk.gate_setup_commitments[5].point_mul(t);

        result.point_add_assign(scaled);

        // Q_const

        result.point_add_assign(vk.gate_setup_commitments[6]);

        // Q_dNext * D_next

        scaled = vk.gate_setup_commitments[7].point_mul(proof.state_polys_openings_at_z_omega[0]);

        result.point_add_assign(scaled);

        result.point_mul_assign(proof.gate_selectors_openings_at_z[0]);



        PairingsBn254.G1Point

            memory rescue_custom_gate_linearization_contrib = rescue_custom_gate_linearization_contribution(

                vk,

                proof,

                state

            );

        result.point_add_assign(rescue_custom_gate_linearization_contrib);

        require(vk.non_residues.length == STATE_WIDTH - 1);



        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);

        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();

        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; ) {

            t = state.z.copy();

            if (i == 0) {

                t.mul_assign(one);

            } else {

                t.mul_assign(vk.non_residues[i - 1]);

            }

            t.mul_assign(state.beta);

            t.add_assign(state.gamma);

            t.add_assign(proof.state_polys_openings_at_z[i]);



            factor.mul_assign(t);

            unchecked {

                ++i;

            }

        }



        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);

        result.point_add_assign(scaled);



        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)

        factor = state.alpha_values[4].copy();

        factor.mul_assign(state.beta);

        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);

        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {

            t = proof.copy_permutation_polys_openings_at_z[i].copy();

            t.mul_assign(state.beta);

            t.add_assign(state.gamma);

            t.add_assign(proof.state_polys_openings_at_z[i]);



            factor.mul_assign(t);

        }

        scaled = vk.permutation_commitments[3].point_mul(factor);

        result.point_sub_assign(scaled);



        // + L_0(z) * Z(x)

        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);

        require(state.l_0_at_z.value != 0);

        factor = state.l_0_at_z.copy();

        factor.mul_assign(state.alpha_values[4 + 1]);

        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);

        result.point_add_assign(scaled);



        PairingsBn254.G1Point memory lookup_linearization_contrib = lookup_linearization_contribution(proof, state);

        result.point_add_assign(lookup_linearization_contrib);

    }



    function rescue_custom_gate_linearization_contribution(

        VerificationKey memory vk,

        Proof memory proof,

        PartialVerifierState memory state

    ) public view returns (PairingsBn254.G1Point memory result) {

        PairingsBn254.Fr memory t;

        PairingsBn254.Fr memory intermediate_result;



        // a^2 - b = 0

        t = proof.state_polys_openings_at_z[0].copy();

        t.mul_assign(t);

        t.sub_assign(proof.state_polys_openings_at_z[1]);

        // t.mul_assign(challenge1);

        t.mul_assign(state.alpha_values[1]);

        intermediate_result.add_assign(t);



        // b^2 - c = 0

        t = proof.state_polys_openings_at_z[1].copy();

        t.mul_assign(t);

        t.sub_assign(proof.state_polys_openings_at_z[2]);

        t.mul_assign(state.alpha_values[1 + 1]);

        intermediate_result.add_assign(t);



        // c*a - d = 0;

        t = proof.state_polys_openings_at_z[2].copy();

        t.mul_assign(proof.state_polys_openings_at_z[0]);

        t.sub_assign(proof.state_polys_openings_at_z[3]);

        t.mul_assign(state.alpha_values[1 + 2]);

        intermediate_result.add_assign(t);



        result = vk.gate_selectors_commitments[1].point_mul(intermediate_result);

    }



    function lookup_linearization_contribution(Proof memory proof, PartialVerifierState memory state)

        internal

        view

        returns (PairingsBn254.G1Point memory result)

    {

        PairingsBn254.Fr memory zero = PairingsBn254.new_fr(0);



        PairingsBn254.Fr memory t;

        PairingsBn254.Fr memory factor;

        // s(x) from the Z(x*omega)*(\gamma*(1 + \beta) + s(x) + \beta * s(x*omega)))

        factor = proof.lookup_grand_product_opening_at_z_omega.copy();

        factor.mul_assign(state.alpha_values[6]);

        factor.mul_assign(state.z_minus_last_omega);



        PairingsBn254.G1Point memory scaled = proof.lookup_s_poly_commitment.point_mul(factor);

        result.point_add_assign(scaled);



        // Z(x) from - alpha_0 * Z(x) * (\beta + 1) * (\gamma + f(x)) * (\gamma(1 + \beta) + t(x) + \beta * t(x*omega))

        // + alpha_1 * Z(x) * L_{0}(z) + alpha_2 * Z(x) * L_{n-1}(z)



        // accumulate coefficient

        factor = proof.lookup_t_poly_opening_at_z_omega.copy();

        factor.mul_assign(state.beta_lookup);

        factor.add_assign(proof.lookup_t_poly_opening_at_z);

        factor.add_assign(state.beta_gamma);



        // (\gamma + f(x))

        PairingsBn254.Fr memory f_reconstructed;

        PairingsBn254.Fr memory current = PairingsBn254.new_fr(1);

        PairingsBn254.Fr memory tmp0;

        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {

            tmp0 = proof.state_polys_openings_at_z[i].copy();

            tmp0.mul_assign(current);

            f_reconstructed.add_assign(tmp0);



            current.mul_assign(state.eta);

        }



        // add type of table

        t = proof.lookup_table_type_poly_opening_at_z.copy();

        t.mul_assign(current);

        f_reconstructed.add_assign(t);



        f_reconstructed.mul_assign(proof.lookup_selector_poly_opening_at_z);

        f_reconstructed.add_assign(state.gamma_lookup);



        // end of (\gamma + f(x)) part

        factor.mul_assign(f_reconstructed);

        factor.mul_assign(state.beta_plus_one);

        t = zero.copy();

        t.sub_assign(factor);

        factor = t;

        factor.mul_assign(state.alpha_values[6]);



        // Multiply by (z - omega^{n-1})

        factor.mul_assign(state.z_minus_last_omega);



        // L_{0}(z) in front of Z(x)

        t = state.l_0_at_z.copy();

        t.mul_assign(state.alpha_values[6 + 1]);

        factor.add_assign(t);



        // L_{n-1}(z) in front of Z(x)

        t = state.l_n_minus_one_at_z.copy();

        t.mul_assign(state.alpha_values[6 + 2]);

        factor.add_assign(t);



        scaled = proof.lookup_grand_product_commitment.point_mul(factor);

        result.point_add_assign(scaled);

    }



    struct Queries {

        PairingsBn254.G1Point[13] commitments_at_z;

        PairingsBn254.Fr[13] values_at_z;

        PairingsBn254.G1Point[6] commitments_at_z_omega;

        PairingsBn254.Fr[6] values_at_z_omega;

    }



    function prepare_queries(

        VerificationKey memory vk,

        Proof memory proof,

        PartialVerifierState memory state

    ) public view returns (Queries memory queries) {

        // we set first two items in calee side so start idx from 2

        uint256 idx = 2;

        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {

            queries.commitments_at_z[idx] = proof.state_polys_commitments[i];

            queries.values_at_z[idx] = proof.state_polys_openings_at_z[i];

            idx = idx.uncheckedInc();

        }

        require(proof.gate_selectors_openings_at_z.length == 1);

        queries.commitments_at_z[idx] = vk.gate_selectors_commitments[0];

        queries.values_at_z[idx] = proof.gate_selectors_openings_at_z[0];

        idx = idx.uncheckedInc();

        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {

            queries.commitments_at_z[idx] = vk.permutation_commitments[i];

            queries.values_at_z[idx] = proof.copy_permutation_polys_openings_at_z[i];

            idx = idx.uncheckedInc();

        }



        queries.commitments_at_z_omega[0] = proof.copy_permutation_grand_product_commitment;

        queries.commitments_at_z_omega[1] = proof.state_polys_commitments[STATE_WIDTH - 1];



        queries.values_at_z_omega[0] = proof.copy_permutation_grand_product_opening_at_z_omega;

        queries.values_at_z_omega[1] = proof.state_polys_openings_at_z_omega[0];



        PairingsBn254.G1Point memory lookup_t_poly_commitment_aggregated = vk.lookup_tables_commitments[0];

        PairingsBn254.Fr memory current_eta = state.eta.copy();

        for (uint256 i = 1; i < vk.lookup_tables_commitments.length; i = i.uncheckedInc()) {

            state.tp = vk.lookup_tables_commitments[i].point_mul(current_eta);

            lookup_t_poly_commitment_aggregated.point_add_assign(state.tp);



            current_eta.mul_assign(state.eta);

        }

        queries.commitments_at_z[idx] = lookup_t_poly_commitment_aggregated;

        queries.values_at_z[idx] = proof.lookup_t_poly_opening_at_z;

        idx = idx.uncheckedInc();

        queries.commitments_at_z[idx] = vk.lookup_selector_commitment;

        queries.values_at_z[idx] = proof.lookup_selector_poly_opening_at_z;

        idx = idx.uncheckedInc();

        queries.commitments_at_z[idx] = vk.lookup_table_type_commitment;

        queries.values_at_z[idx] = proof.lookup_table_type_poly_opening_at_z;

        queries.commitments_at_z_omega[2] = proof.lookup_s_poly_commitment;

        queries.values_at_z_omega[2] = proof.lookup_s_poly_opening_at_z_omega;

        queries.commitments_at_z_omega[3] = proof.lookup_grand_product_commitment;

        queries.values_at_z_omega[3] = proof.lookup_grand_product_opening_at_z_omega;

        queries.commitments_at_z_omega[4] = lookup_t_poly_commitment_aggregated;

        queries.values_at_z_omega[4] = proof.lookup_t_poly_opening_at_z_omega;

    }



    function final_pairing(

        // VerificationKey memory vk,

        PairingsBn254.G2Point[NUM_G2_ELS] memory g2_elements,

        Proof memory proof,

        PartialVerifierState memory state,

        PairingsBn254.G1Point memory aggregated_commitment_at_z,

        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega,

        PairingsBn254.Fr memory aggregated_opening_at_z,

        PairingsBn254.Fr memory aggregated_opening_at_z_omega

    ) internal view returns (bool) {

        // q(x) = f(x) - f(z) / (x - z)

        // q(x) * (x-z)  = f(x) - f(z)



        // f(x)

        PairingsBn254.G1Point memory pair_with_generator = aggregated_commitment_at_z.copy_g1();

        aggregated_commitment_at_z_omega.point_mul_assign(state.u);

        pair_with_generator.point_add_assign(aggregated_commitment_at_z_omega);



        // - f(z)*g

        PairingsBn254.Fr memory aggregated_value = aggregated_opening_at_z_omega.copy();

        aggregated_value.mul_assign(state.u);

        aggregated_value.add_assign(aggregated_opening_at_z);

        PairingsBn254.G1Point memory tp = PairingsBn254.P1().point_mul(aggregated_value);

        pair_with_generator.point_sub_assign(tp);



        // +z * q(x)

        tp = proof.opening_proof_at_z.point_mul(state.z);

        PairingsBn254.Fr memory t = state.z_omega.copy();

        t.mul_assign(state.u);

        PairingsBn254.G1Point memory t1 = proof.opening_proof_at_z_omega.point_mul(t);

        tp.point_add_assign(t1);

        pair_with_generator.point_add_assign(tp);



        // rhs

        PairingsBn254.G1Point memory pair_with_x = proof.opening_proof_at_z_omega.point_mul(state.u);

        pair_with_x.point_add_assign(proof.opening_proof_at_z);

        pair_with_x.negate();

        // Pairing precompile expects points to be in a `i*x[1] + x[0]` form instead of `x[0] + i*x[1]`

        // so we handle it in code generation step

        PairingsBn254.G2Point memory first_g2 = g2_elements[0];

        PairingsBn254.G2Point memory second_g2 = g2_elements[1];



        return PairingsBn254.pairingProd2(pair_with_generator, first_g2, pair_with_x, second_g2);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\PlonkCore.sol
File type: .sol
pragma solidity >=0.5.0 <0.8.0;

pragma experimental ABIEncoderV2;



// SPDX-License-Identifier: MIT OR Apache-2.0

// solhint-disable









library PairingsBn254 {

    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

    uint256 constant bn254_b_coeff = 3;



    struct G1Point {

        uint256 X;

        uint256 Y;

    }



    struct Fr {

        uint256 value;

    }



    function new_fr(uint256 fr) internal pure returns (Fr memory) {

        require(fr < r_mod);

        return Fr({value: fr});

    }



    function copy(Fr memory self) internal pure returns (Fr memory n) {

        n.value = self.value;

    }



    function assign(Fr memory self, Fr memory other) internal pure {

        self.value = other.value;

    }



    function inverse(Fr memory fr) internal view returns (Fr memory) {

        require(fr.value != 0);

        return pow(fr, r_mod - 2);

    }



    function add_assign(Fr memory self, Fr memory other) internal pure {

        self.value = addmod(self.value, other.value, r_mod);

    }



    function sub_assign(Fr memory self, Fr memory other) internal pure {

        self.value = addmod(self.value, r_mod - other.value, r_mod);

    }



    function mul_assign(Fr memory self, Fr memory other) internal pure {

        self.value = mulmod(self.value, other.value, r_mod);

    }



    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {

        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];

        uint256[1] memory result;

        bool success;

        assembly {

            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)

        }

        require(success);

        return Fr({value: result[0]});

    }



    // Encoding of field elements is: X[0] * z + X[1]

    struct G2Point {

        uint256[2] X;

        uint256[2] Y;

    }



    function P1() internal pure returns (G1Point memory) {

        return G1Point(1, 2);

    }



    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {

        return G1Point(x, y);

    }



    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {

        if (x == 0 && y == 0) {

            // point of infinity is (0,0)

            return G1Point(x, y);

        }



        // check encoding

        require(x < q_mod);

        require(y < q_mod);

        // check on curve

        uint256 lhs = mulmod(y, y, q_mod); // y^2

        uint256 rhs = mulmod(x, x, q_mod); // x^2

        rhs = mulmod(rhs, x, q_mod); // x^3

        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b

        require(lhs == rhs);



        return G1Point(x, y);

    }



    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {

        return G2Point(x, y);

    }



    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {

        result.X = self.X;

        result.Y = self.Y;

    }



    function P2() internal pure returns (G2Point memory) {

        // for some reason ethereum expects to have c1*v + c0 form



        return

            G2Point(

                [

                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,

                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed

                ],

                [

                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,

                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa

                ]

            );

    }



    function negate(G1Point memory self) internal pure {

        // The prime q in the base field F_q for G1

        if (self.Y == 0) {

            require(self.X == 0);

            return;

        }



        self.Y = q_mod - self.Y;

    }



    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {

        point_add_into_dest(p1, p2, r);

        return r;

    }



    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {

        point_add_into_dest(p1, p2, p1);

    }



    function point_add_into_dest(

        G1Point memory p1,

        G1Point memory p2,

        G1Point memory dest

    ) internal view {

        if (p2.X == 0 && p2.Y == 0) {

            // we add zero, nothing happens

            dest.X = p1.X;

            dest.Y = p1.Y;

            return;

        } else if (p1.X == 0 && p1.Y == 0) {

            // we add into zero, and we add non-zero point

            dest.X = p2.X;

            dest.Y = p2.Y;

            return;

        } else {

            uint256[4] memory input;



            input[0] = p1.X;

            input[1] = p1.Y;

            input[2] = p2.X;

            input[3] = p2.Y;



            bool success = false;

            assembly {

                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)

            }

            require(success);

        }

    }



    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {

        point_sub_into_dest(p1, p2, p1);

    }



    function point_sub_into_dest(

        G1Point memory p1,

        G1Point memory p2,

        G1Point memory dest

    ) internal view {

        if (p2.X == 0 && p2.Y == 0) {

            // we subtracted zero, nothing happens

            dest.X = p1.X;

            dest.Y = p1.Y;

            return;

        } else if (p1.X == 0 && p1.Y == 0) {

            // we subtract from zero, and we subtract non-zero point

            dest.X = p2.X;

            dest.Y = q_mod - p2.Y;

            return;

        } else {

            uint256[4] memory input;



            input[0] = p1.X;

            input[1] = p1.Y;

            input[2] = p2.X;

            input[3] = q_mod - p2.Y;



            bool success = false;

            assembly {

                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)

            }

            require(success);

        }

    }



    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {

        point_mul_into_dest(p, s, r);

        return r;

    }



    function point_mul_assign(G1Point memory p, Fr memory s) internal view {

        point_mul_into_dest(p, s, p);

    }



    function point_mul_into_dest(

        G1Point memory p,

        Fr memory s,

        G1Point memory dest

    ) internal view {

        uint256[3] memory input;

        input[0] = p.X;

        input[1] = p.Y;

        input[2] = s.value;

        bool success;

        assembly {

            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)

        }

        require(success);

    }



    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {

        require(p1.length == p2.length);

        uint256 elements = p1.length;

        uint256 inputSize = elements * 6;

        uint256[] memory input = new uint256[](inputSize);

        for (uint256 i = 0; i < elements; i++) {

            input[i * 6 + 0] = p1[i].X;

            input[i * 6 + 1] = p1[i].Y;

            input[i * 6 + 2] = p2[i].X[0];

            input[i * 6 + 3] = p2[i].X[1];

            input[i * 6 + 4] = p2[i].Y[0];

            input[i * 6 + 5] = p2[i].Y[1];

        }

        uint256[1] memory out;

        bool success;

        assembly {

            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)

        }

        require(success);

        return out[0] != 0;

    }



    /// Convenience method for a pairing check for two pairs.

    function pairingProd2(

        G1Point memory a1,

        G2Point memory a2,

        G1Point memory b1,

        G2Point memory b2

    ) internal view returns (bool) {

        G1Point[] memory p1 = new G1Point[](2);

        G2Point[] memory p2 = new G2Point[](2);

        p1[0] = a1;

        p1[1] = b1;

        p2[0] = a2;

        p2[1] = b2;

        return pairing(p1, p2);

    }

}



library TranscriptLibrary {

    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;

    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;



    uint32 constant DST_0 = 0;

    uint32 constant DST_1 = 1;

    uint32 constant DST_CHALLENGE = 2;



    struct Transcript {

        bytes32 state_0;

        bytes32 state_1;

        uint32 challenge_counter;

    }



    function new_transcript() internal pure returns (Transcript memory t) {

        t.state_0 = bytes32(0);

        t.state_1 = bytes32(0);

        t.challenge_counter = 0;

    }



    function update_with_u256(Transcript memory self, uint256 value) internal pure {

        bytes32 old_state_0 = self.state_0;

        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));

        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));

    }



    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {

        update_with_u256(self, value.value);

    }



    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {

        update_with_u256(self, p.X);

        update_with_u256(self, p.Y);

    }



    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {

        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));

        self.challenge_counter += 1;

        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});

    }

}



contract Plonk4VerifierWithAccessToDNext {

    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;



    using PairingsBn254 for PairingsBn254.G1Point;

    using PairingsBn254 for PairingsBn254.G2Point;

    using PairingsBn254 for PairingsBn254.Fr;



    using TranscriptLibrary for TranscriptLibrary.Transcript;



    uint256 constant ZERO = 0;

    uint256 constant ONE = 1;

    uint256 constant TWO = 2;

    uint256 constant THREE = 3;

    uint256 constant FOUR = 4;



    uint256 constant STATE_WIDTH = 4;

    uint256 constant NUM_DIFFERENT_GATES = 2;

    uint256 constant NUM_SETUP_POLYS_FOR_MAIN_GATE = 7;

    uint256 constant NUM_SETUP_POLYS_RANGE_CHECK_GATE = 0;

    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP = 1;

    uint256 constant NUM_GATE_SELECTORS_OPENED_EXPLICITLY = 1;



    uint256 constant RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK =

        0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;

    uint256 constant LIMB_WIDTH = 68;



    struct VerificationKey {

        uint256 domain_size;

        uint256 num_inputs;

        PairingsBn254.Fr omega;

        PairingsBn254.G1Point[NUM_SETUP_POLYS_FOR_MAIN_GATE + NUM_SETUP_POLYS_RANGE_CHECK_GATE] gate_setup_commitments;

        PairingsBn254.G1Point[NUM_DIFFERENT_GATES] gate_selector_commitments;

        PairingsBn254.G1Point[STATE_WIDTH] copy_permutation_commitments;

        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_non_residues;

        PairingsBn254.G2Point g2_x;

    }



    struct Proof {

        uint256[] input_values;

        PairingsBn254.G1Point[STATE_WIDTH] wire_commitments;

        PairingsBn254.G1Point copy_permutation_grand_product_commitment;

        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_commitments;

        PairingsBn254.Fr[STATE_WIDTH] wire_values_at_z;

        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] wire_values_at_z_omega;

        PairingsBn254.Fr[NUM_GATE_SELECTORS_OPENED_EXPLICITLY] gate_selector_values_at_z;

        PairingsBn254.Fr copy_grand_product_at_z_omega;

        PairingsBn254.Fr quotient_polynomial_at_z;

        PairingsBn254.Fr linearization_polynomial_at_z;

        PairingsBn254.Fr[STATE_WIDTH - 1] permutation_polynomials_at_z;

        PairingsBn254.G1Point opening_at_z_proof;

        PairingsBn254.G1Point opening_at_z_omega_proof;

    }



    struct PartialVerifierState {

        PairingsBn254.Fr alpha;

        PairingsBn254.Fr beta;

        PairingsBn254.Fr gamma;

        PairingsBn254.Fr v;

        PairingsBn254.Fr u;

        PairingsBn254.Fr z;

        PairingsBn254.Fr[] cached_lagrange_evals;

    }



    function evaluate_lagrange_poly_out_of_domain(

        uint256 poly_num,

        uint256 domain_size,

        PairingsBn254.Fr memory omega,

        PairingsBn254.Fr memory at

    ) internal view returns (PairingsBn254.Fr memory res) {

        require(poly_num < domain_size);

        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);

        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);

        res = at.pow(domain_size);

        res.sub_assign(one);

        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`

        res.mul_assign(omega_power);



        PairingsBn254.Fr memory den = PairingsBn254.copy(at);

        den.sub_assign(omega_power);

        den.mul_assign(PairingsBn254.new_fr(domain_size));



        den = den.inverse();



        res.mul_assign(den);

    }



    function batch_evaluate_lagrange_poly_out_of_domain(

        uint256[] memory poly_nums,

        uint256 domain_size,

        PairingsBn254.Fr memory omega,

        PairingsBn254.Fr memory at

    ) internal view returns (PairingsBn254.Fr[] memory res) {

        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);

        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);

        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);

        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);

        vanishing_at_z.sub_assign(one);

        // we can not have random point z be in domain

        require(vanishing_at_z.value != 0);

        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);

        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);

        // numerators in a form omega^i * (z^n - 1)

        // denoms in a form (z - omega^i) * N

        for (uint256 i = 0; i < poly_nums.length; i++) {

            tmp_1 = omega.pow(poly_nums[i]); // power of omega

            nums[i].assign(vanishing_at_z);

            nums[i].mul_assign(tmp_1);



            dens[i].assign(at); // (X - omega^i) * N

            dens[i].sub_assign(tmp_1);

            dens[i].mul_assign(tmp_2); // mul by domain size

        }



        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);

        partial_products[0].assign(PairingsBn254.new_fr(1));

        for (uint256 i = 1; i < dens.length - 1; i++) {

            partial_products[i].assign(dens[i - 1]);

            partial_products[i].mul_assign(dens[i]);

        }



        tmp_2.assign(partial_products[partial_products.length - 1]);

        tmp_2.mul_assign(dens[dens.length - 1]);

        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)



        for (uint256 i = dens.length - 1; i < dens.length; i--) {

            dens[i].assign(tmp_2); // all inversed

            dens[i].mul_assign(partial_products[i]); // clear lowest terms

            tmp_2.mul_assign(dens[i]);

        }



        for (uint256 i = 0; i < nums.length; i++) {

            nums[i].mul_assign(dens[i]);

        }



        return nums;

    }



    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)

        internal

        view

        returns (PairingsBn254.Fr memory res)

    {

        res = at.pow(domain_size);

        res.sub_assign(PairingsBn254.new_fr(1));

    }



    function verify_at_z(

        PartialVerifierState memory state,

        Proof memory proof,

        VerificationKey memory vk

    ) internal view returns (bool) {

        PairingsBn254.Fr memory lhs = evaluate_vanishing(vk.domain_size, state.z);

        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain

        lhs.mul_assign(proof.quotient_polynomial_at_z);



        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);

        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);



        // public inputs

        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);

        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);

        for (uint256 i = 0; i < proof.input_values.length; i++) {

            tmp.assign(state.cached_lagrange_evals[i]);

            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));

            inputs_term.add_assign(tmp);

        }



        inputs_term.mul_assign(proof.gate_selector_values_at_z[0]);

        rhs.add_assign(inputs_term);



        // now we need 5th power

        quotient_challenge.mul_assign(state.alpha);

        quotient_challenge.mul_assign(state.alpha);

        quotient_challenge.mul_assign(state.alpha);

        quotient_challenge.mul_assign(state.alpha);

        quotient_challenge.mul_assign(state.alpha);



        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.copy_grand_product_at_z_omega);

        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            tmp.assign(proof.permutation_polynomials_at_z[i]);

            tmp.mul_assign(state.beta);

            tmp.add_assign(state.gamma);

            tmp.add_assign(proof.wire_values_at_z[i]);



            z_part.mul_assign(tmp);

        }



        tmp.assign(state.gamma);

        // we need a wire value of the last polynomial in enumeration

        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH - 1]);



        z_part.mul_assign(tmp);

        z_part.mul_assign(quotient_challenge);



        rhs.sub_assign(z_part);



        quotient_challenge.mul_assign(state.alpha);



        tmp.assign(state.cached_lagrange_evals[0]);

        tmp.mul_assign(quotient_challenge);



        rhs.sub_assign(tmp);



        return lhs.value == rhs.value;

    }



    function add_contribution_from_range_constraint_gates(

        PartialVerifierState memory state,

        Proof memory proof,

        PairingsBn254.Fr memory current_alpha

    ) internal pure returns (PairingsBn254.Fr memory res) {

        // now add contribution from range constraint gate

        // we multiply selector commitment by all the factors (alpha*(c - 4d)(c - 4d - 1)(..-2)(..-3) + alpha^2 * (4b - c)()()() + {} + {})



        PairingsBn254.Fr memory one_fr = PairingsBn254.new_fr(ONE);

        PairingsBn254.Fr memory two_fr = PairingsBn254.new_fr(TWO);

        PairingsBn254.Fr memory three_fr = PairingsBn254.new_fr(THREE);

        PairingsBn254.Fr memory four_fr = PairingsBn254.new_fr(FOUR);



        res = PairingsBn254.new_fr(0);

        PairingsBn254.Fr memory t0 = PairingsBn254.new_fr(0);

        PairingsBn254.Fr memory t1 = PairingsBn254.new_fr(0);

        PairingsBn254.Fr memory t2 = PairingsBn254.new_fr(0);



        for (uint256 i = 0; i < 3; i++) {

            current_alpha.mul_assign(state.alpha);



            // high - 4*low



            // this is 4*low

            t0 = PairingsBn254.copy(proof.wire_values_at_z[3 - i]);

            t0.mul_assign(four_fr);



            // high

            t1 = PairingsBn254.copy(proof.wire_values_at_z[2 - i]);

            t1.sub_assign(t0);



            // t0 is now t1 - {0,1,2,3}



            // first unroll manually for -0;

            t2 = PairingsBn254.copy(t1);



            // -1

            t0 = PairingsBn254.copy(t1);

            t0.sub_assign(one_fr);

            t2.mul_assign(t0);



            // -2

            t0 = PairingsBn254.copy(t1);

            t0.sub_assign(two_fr);

            t2.mul_assign(t0);



            // -3

            t0 = PairingsBn254.copy(t1);

            t0.sub_assign(three_fr);

            t2.mul_assign(t0);



            t2.mul_assign(current_alpha);



            res.add_assign(t2);

        }



        // now also d_next - 4a



        current_alpha.mul_assign(state.alpha);



        // high - 4*low



        // this is 4*low

        t0 = PairingsBn254.copy(proof.wire_values_at_z[0]);

        t0.mul_assign(four_fr);



        // high

        t1 = PairingsBn254.copy(proof.wire_values_at_z_omega[0]);

        t1.sub_assign(t0);



        // t0 is now t1 - {0,1,2,3}



        // first unroll manually for -0;

        t2 = PairingsBn254.copy(t1);



        // -1

        t0 = PairingsBn254.copy(t1);

        t0.sub_assign(one_fr);

        t2.mul_assign(t0);



        // -2

        t0 = PairingsBn254.copy(t1);

        t0.sub_assign(two_fr);

        t2.mul_assign(t0);



        // -3

        t0 = PairingsBn254.copy(t1);

        t0.sub_assign(three_fr);

        t2.mul_assign(t0);



        t2.mul_assign(current_alpha);



        res.add_assign(t2);



        return res;

    }



    function reconstruct_linearization_commitment(

        PartialVerifierState memory state,

        Proof memory proof,

        VerificationKey memory vk

    ) internal view returns (PairingsBn254.G1Point memory res) {

        // we compute what power of v is used as a delinearization factor in batch opening of

        // commitments. Let's label W(x) = 1 / (x - z) *

        // [

        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)

        // + v (r(x) - r(z))

        // + v^{2..5} * (witness(x) - witness(z))

        // + v^{6} * (selector(x) - selector(z))

        // + v^{7..9} * (permutation(x) - permutation(z))

        // ]

        // W'(x) = 1 / (x - z*omega) *

        // [

        // + v^10 (z(x) - z(z*omega)) <- we need this power

        // + v^11 * (d(x) - d(z*omega))

        // ]

        //



        // we reconstruct linearization polynomial virtual selector

        // for that purpose we first linearize over main gate (over all it's selectors)

        // and multiply them by value(!) of the corresponding main gate selector

        res = PairingsBn254.copy_g1(vk.gate_setup_commitments[STATE_WIDTH + 1]); // index of q_const(x)



        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();

        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);



        // addition gates

        for (uint256 i = 0; i < STATE_WIDTH; i++) {

            tmp_g1 = vk.gate_setup_commitments[i].point_mul(proof.wire_values_at_z[i]);

            res.point_add_assign(tmp_g1);

        }



        // multiplication gate

        tmp_fr.assign(proof.wire_values_at_z[0]);

        tmp_fr.mul_assign(proof.wire_values_at_z[1]);

        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH].point_mul(tmp_fr);

        res.point_add_assign(tmp_g1);



        // d_next

        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH + 2].point_mul(proof.wire_values_at_z_omega[0]); // index of q_d_next(x)

        res.point_add_assign(tmp_g1);



        // multiply by main gate selector(z)

        res.point_mul_assign(proof.gate_selector_values_at_z[0]); // these is only one explicitly opened selector



        PairingsBn254.Fr memory current_alpha = PairingsBn254.new_fr(ONE);



        // calculate scalar contribution from the range check gate

        tmp_fr = add_contribution_from_range_constraint_gates(state, proof, current_alpha);

        tmp_g1 = vk.gate_selector_commitments[1].point_mul(tmp_fr); // selector commitment for range constraint gate * scalar

        res.point_add_assign(tmp_g1);



        // proceed as normal to copy permutation

        current_alpha.mul_assign(state.alpha); // alpha^5



        PairingsBn254.Fr memory alpha_for_grand_product = PairingsBn254.copy(current_alpha);



        // z * non_res * beta + gamma + a

        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);

        grand_product_part_at_z.mul_assign(state.beta);

        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);

        grand_product_part_at_z.add_assign(state.gamma);

        for (uint256 i = 0; i < vk.copy_permutation_non_residues.length; i++) {

            tmp_fr.assign(state.z);

            tmp_fr.mul_assign(vk.copy_permutation_non_residues[i]);

            tmp_fr.mul_assign(state.beta);

            tmp_fr.add_assign(state.gamma);

            tmp_fr.add_assign(proof.wire_values_at_z[i + 1]);



            grand_product_part_at_z.mul_assign(tmp_fr);

        }



        grand_product_part_at_z.mul_assign(alpha_for_grand_product);



        // alpha^n & L_{0}(z), and we bump current_alpha

        current_alpha.mul_assign(state.alpha);



        tmp_fr.assign(state.cached_lagrange_evals[0]);

        tmp_fr.mul_assign(current_alpha);



        grand_product_part_at_z.add_assign(tmp_fr);



        // prefactor for grand_product(x) is complete



        // add to the linearization a part from the term

        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)

        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);

        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            tmp_fr.assign(state.beta);

            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);

            tmp_fr.add_assign(state.gamma);

            tmp_fr.add_assign(proof.wire_values_at_z[i]);



            last_permutation_part_at_z.mul_assign(tmp_fr);

        }



        last_permutation_part_at_z.mul_assign(state.beta);

        last_permutation_part_at_z.mul_assign(proof.copy_grand_product_at_z_omega);

        last_permutation_part_at_z.mul_assign(alpha_for_grand_product); // we multiply by the power of alpha from the argument



        // actually multiply prefactors by z(x) and perm_d(x) and combine them

        tmp_g1 = proof.copy_permutation_grand_product_commitment.point_mul(grand_product_part_at_z);

        tmp_g1.point_sub_assign(vk.copy_permutation_commitments[STATE_WIDTH - 1].point_mul(last_permutation_part_at_z));



        res.point_add_assign(tmp_g1);

        // multiply them by v immedately as linearization has a factor of v^1

        res.point_mul_assign(state.v);

        // res now contains contribution from the gates linearization and

        // copy permutation part



        // now we need to add a part that is the rest

        // for z(x*omega):

        // - (a(z) + beta*perm_a + gamma)*()*()*(d(z) + gamma) * z(x*omega)

    }



    function aggregate_commitments(

        PartialVerifierState memory state,

        Proof memory proof,

        VerificationKey memory vk

    ) internal view returns (PairingsBn254.G1Point[2] memory res) {

        PairingsBn254.G1Point memory d = reconstruct_linearization_commitment(state, proof, vk);



        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);



        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();



        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);



        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);

        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);

        for (uint256 i = 1; i < proof.quotient_poly_commitments.length; i++) {

            tmp_fr.mul_assign(z_in_domain_size);

            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);

            commitment_aggregation.point_add_assign(tmp_g1);

        }



        aggregation_challenge.mul_assign(state.v);

        commitment_aggregation.point_add_assign(d);



        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {

            aggregation_challenge.mul_assign(state.v);

            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);

            commitment_aggregation.point_add_assign(tmp_g1);

        }



        for (uint256 i = 0; i < NUM_GATE_SELECTORS_OPENED_EXPLICITLY; i++) {

            aggregation_challenge.mul_assign(state.v);

            tmp_g1 = vk.gate_selector_commitments[0].point_mul(aggregation_challenge);

            commitment_aggregation.point_add_assign(tmp_g1);

        }



        for (uint256 i = 0; i < vk.copy_permutation_commitments.length - 1; i++) {

            aggregation_challenge.mul_assign(state.v);

            tmp_g1 = vk.copy_permutation_commitments[i].point_mul(aggregation_challenge);

            commitment_aggregation.point_add_assign(tmp_g1);

        }



        aggregation_challenge.mul_assign(state.v);

        // now do prefactor for grand_product(x*omega)

        tmp_fr.assign(aggregation_challenge);

        tmp_fr.mul_assign(state.u);

        commitment_aggregation.point_add_assign(proof.copy_permutation_grand_product_commitment.point_mul(tmp_fr));



        aggregation_challenge.mul_assign(state.v);



        tmp_fr.assign(aggregation_challenge);

        tmp_fr.mul_assign(state.u);

        tmp_g1 = proof.wire_commitments[STATE_WIDTH - 1].point_mul(tmp_fr);

        commitment_aggregation.point_add_assign(tmp_g1);



        // collect opening values

        aggregation_challenge = PairingsBn254.new_fr(1);



        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);



        aggregation_challenge.mul_assign(state.v);



        tmp_fr.assign(proof.linearization_polynomial_at_z);

        tmp_fr.mul_assign(aggregation_challenge);

        aggregated_value.add_assign(tmp_fr);



        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {

            aggregation_challenge.mul_assign(state.v);



            tmp_fr.assign(proof.wire_values_at_z[i]);

            tmp_fr.mul_assign(aggregation_challenge);

            aggregated_value.add_assign(tmp_fr);

        }



        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {

            aggregation_challenge.mul_assign(state.v);

            tmp_fr.assign(proof.gate_selector_values_at_z[i]);

            tmp_fr.mul_assign(aggregation_challenge);

            aggregated_value.add_assign(tmp_fr);

        }



        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            aggregation_challenge.mul_assign(state.v);



            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);

            tmp_fr.mul_assign(aggregation_challenge);

            aggregated_value.add_assign(tmp_fr);

        }



        aggregation_challenge.mul_assign(state.v);



        tmp_fr.assign(proof.copy_grand_product_at_z_omega);

        tmp_fr.mul_assign(aggregation_challenge);

        tmp_fr.mul_assign(state.u);

        aggregated_value.add_assign(tmp_fr);



        aggregation_challenge.mul_assign(state.v);



        tmp_fr.assign(proof.wire_values_at_z_omega[0]);

        tmp_fr.mul_assign(aggregation_challenge);

        tmp_fr.mul_assign(state.u);

        aggregated_value.add_assign(tmp_fr);



        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));



        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;

        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));



        tmp_fr.assign(state.z);

        tmp_fr.mul_assign(vk.omega);

        tmp_fr.mul_assign(state.u);

        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));



        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);

        pair_with_x.point_add_assign(proof.opening_at_z_proof);

        pair_with_x.negate();



        res[0] = pair_with_generator;

        res[1] = pair_with_x;



        return res;

    }



    function verify_initial(

        PartialVerifierState memory state,

        Proof memory proof,

        VerificationKey memory vk

    ) internal view returns (bool) {

        require(proof.input_values.length == vk.num_inputs);

        require(vk.num_inputs >= 1);

        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();

        for (uint256 i = 0; i < vk.num_inputs; i++) {

            transcript.update_with_u256(proof.input_values[i]);

        }



        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {

            transcript.update_with_g1(proof.wire_commitments[i]);

        }



        state.beta = transcript.get_challenge();

        state.gamma = transcript.get_challenge();



        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);

        state.alpha = transcript.get_challenge();



        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {

            transcript.update_with_g1(proof.quotient_poly_commitments[i]);

        }



        state.z = transcript.get_challenge();



        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);

        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {

            lagrange_poly_numbers[i] = i;

        }



        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain(

            lagrange_poly_numbers,

            vk.domain_size,

            vk.omega,

            state.z

        );



        bool valid = verify_at_z(state, proof, vk);



        if (valid == false) {

            return false;

        }



        transcript.update_with_fr(proof.quotient_polynomial_at_z);



        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {

            transcript.update_with_fr(proof.wire_values_at_z[i]);

        }



        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {

            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);

        }



        transcript.update_with_fr(proof.gate_selector_values_at_z[0]);



        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);

        }



        transcript.update_with_fr(proof.copy_grand_product_at_z_omega);

        transcript.update_with_fr(proof.linearization_polynomial_at_z);



        state.v = transcript.get_challenge();

        transcript.update_with_g1(proof.opening_at_z_proof);

        transcript.update_with_g1(proof.opening_at_z_omega_proof);

        state.u = transcript.get_challenge();



        return true;

    }



    // This verifier is for a PLONK with a state width 4

    // and main gate equation

    // q_a(X) * a(X) +

    // q_b(X) * b(X) +

    // q_c(X) * c(X) +

    // q_d(X) * d(X) +

    // q_m(X) * a(X) * b(X) +

    // q_constants(X)+

    // q_d_next(X) * d(X*omega)

    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials

    // q_d_next(X) "peeks" into the next row of the trace, so it takes

    // the same d(X) polynomial, but shifted



    function aggregate_for_verification(Proof memory proof, VerificationKey memory vk)

        internal

        view

        returns (bool valid, PairingsBn254.G1Point[2] memory part)

    {

        PartialVerifierState memory state;



        valid = verify_initial(state, proof, vk);



        if (valid == false) {

            return (valid, part);

        }



        part = aggregate_commitments(state, proof, vk);



        (valid, part);

    }



    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {

        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);

        if (valid == false) {

            return false;

        }



        valid = PairingsBn254.pairingProd2(

            recursive_proof_part[0],

            PairingsBn254.P2(),

            recursive_proof_part[1],

            vk.g2_x

        );



        return valid;

    }



    function verify_recursive(

        Proof memory proof,

        VerificationKey memory vk,

        uint256 recursive_vks_root,

        uint8 max_valid_index,

        uint8[] memory recursive_vks_indexes,

        uint256[] memory individual_vks_inputs,

        uint256[16] memory subproofs_limbs

    ) internal view returns (bool) {

        (uint256 recursive_input, PairingsBn254.G1Point[2] memory aggregated_g1s) = reconstruct_recursive_public_input(

            recursive_vks_root,

            max_valid_index,

            recursive_vks_indexes,

            individual_vks_inputs,

            subproofs_limbs

        );



        assert(recursive_input == proof.input_values[0]);



        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);

        if (valid == false) {

            return false;

        }



        // aggregated_g1s = inner

        // recursive_proof_part = outer

        PairingsBn254.G1Point[2] memory combined = combine_inner_and_outer(aggregated_g1s, recursive_proof_part);



        valid = PairingsBn254.pairingProd2(combined[0], PairingsBn254.P2(), combined[1], vk.g2_x);



        return valid;

    }



    function combine_inner_and_outer(PairingsBn254.G1Point[2] memory inner, PairingsBn254.G1Point[2] memory outer)

        internal

        view

        returns (PairingsBn254.G1Point[2] memory result)

    {

        // reuse the transcript primitive

        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();

        transcript.update_with_g1(inner[0]);

        transcript.update_with_g1(inner[1]);

        transcript.update_with_g1(outer[0]);

        transcript.update_with_g1(outer[1]);

        PairingsBn254.Fr memory challenge = transcript.get_challenge();

        // 1 * inner + challenge * outer

        result[0] = PairingsBn254.copy_g1(inner[0]);

        result[1] = PairingsBn254.copy_g1(inner[1]);

        PairingsBn254.G1Point memory tmp = outer[0].point_mul(challenge);

        result[0].point_add_assign(tmp);

        tmp = outer[1].point_mul(challenge);

        result[1].point_add_assign(tmp);



        return result;

    }



    function reconstruct_recursive_public_input(

        uint256 recursive_vks_root,

        uint8 max_valid_index,

        uint8[] memory recursive_vks_indexes,

        uint256[] memory individual_vks_inputs,

        uint256[16] memory subproofs_aggregated

    ) internal pure returns (uint256 recursive_input, PairingsBn254.G1Point[2] memory reconstructed_g1s) {

        assert(recursive_vks_indexes.length == individual_vks_inputs.length);

        bytes memory concatenated = abi.encodePacked(recursive_vks_root);

        uint8 index;

        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {

            index = recursive_vks_indexes[i];

            assert(index <= max_valid_index);

            concatenated = abi.encodePacked(concatenated, index);

        }

        uint256 input;

        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {

            input = individual_vks_inputs[i];

            assert(input < r_mod);

            concatenated = abi.encodePacked(concatenated, input);

        }



        concatenated = abi.encodePacked(concatenated, subproofs_aggregated);



        bytes32 commitment = sha256(concatenated);

        recursive_input = uint256(commitment) & RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK;



        reconstructed_g1s[0] = PairingsBn254.new_g1_checked(

            subproofs_aggregated[0] +

                (subproofs_aggregated[1] << LIMB_WIDTH) +

                (subproofs_aggregated[2] << (2 * LIMB_WIDTH)) +

                (subproofs_aggregated[3] << (3 * LIMB_WIDTH)),

            subproofs_aggregated[4] +

                (subproofs_aggregated[5] << LIMB_WIDTH) +

                (subproofs_aggregated[6] << (2 * LIMB_WIDTH)) +

                (subproofs_aggregated[7] << (3 * LIMB_WIDTH))

        );



        reconstructed_g1s[1] = PairingsBn254.new_g1_checked(

            subproofs_aggregated[8] +

                (subproofs_aggregated[9] << LIMB_WIDTH) +

                (subproofs_aggregated[10] << (2 * LIMB_WIDTH)) +

                (subproofs_aggregated[11] << (3 * LIMB_WIDTH)),

            subproofs_aggregated[12] +

                (subproofs_aggregated[13] << LIMB_WIDTH) +

                (subproofs_aggregated[14] << (2 * LIMB_WIDTH)) +

                (subproofs_aggregated[15] << (3 * LIMB_WIDTH))

        );



        return (recursive_input, reconstructed_g1s);

    }

}



contract VerifierWithDeserialize is Plonk4VerifierWithAccessToDNext {

    uint256 constant SERIALIZED_PROOF_LENGTH = 34;



    function deserialize_proof(uint256[] memory public_inputs, uint256[] memory serialized_proof)

        internal

        pure

        returns (Proof memory proof)

    {

        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH);

        proof.input_values = new uint256[](public_inputs.length);

        for (uint256 i = 0; i < public_inputs.length; i++) {

            proof.input_values[i] = public_inputs[i];

        }



        uint256 j = 0;

        for (uint256 i = 0; i < STATE_WIDTH; i++) {

            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);



            j += 2;

        }



        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(

            serialized_proof[j],

            serialized_proof[j + 1]

        );

        j += 2;



        for (uint256 i = 0; i < STATE_WIDTH; i++) {

            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(

                serialized_proof[j],

                serialized_proof[j + 1]

            );



            j += 2;

        }



        for (uint256 i = 0; i < STATE_WIDTH; i++) {

            proof.wire_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j += 1;

        }



        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {

            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j += 1;

        }



        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {

            proof.gate_selector_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j += 1;

        }



        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j += 1;

        }



        proof.copy_grand_product_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);



        j += 1;



        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);



        j += 1;



        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);



        j += 1;



        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);

        j += 2;



        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);

    }



    function verify_serialized_proof(

        uint256[] memory public_inputs,

        uint256[] memory serialized_proof,

        VerificationKey memory vk

    ) public view returns (bool) {

        require(vk.num_inputs == public_inputs.length);



        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);



        bool valid = verify(proof, vk);



        return valid;

    }



    function verify_serialized_proof_with_recursion(

        uint256[] memory public_inputs,

        uint256[] memory serialized_proof,

        uint256 recursive_vks_root,

        uint8 max_valid_index,

        uint8[] memory recursive_vks_indexes,

        uint256[] memory individual_vks_inputs,

        uint256[16] memory subproofs_limbs,

        VerificationKey memory vk

    ) public view returns (bool) {

        require(vk.num_inputs == public_inputs.length);



        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);



        bool valid = verify_recursive(

            proof,

            vk,

            recursive_vks_root,

            max_valid_index,

            recursive_vks_indexes,

            individual_vks_inputs,

            subproofs_limbs

        );



        return valid;

    }

}



contract Plonk4VerifierWithAccessToDNextOld {

    using PairingsBn254 for PairingsBn254.G1Point;

    using PairingsBn254 for PairingsBn254.G2Point;

    using PairingsBn254 for PairingsBn254.Fr;



    using TranscriptLibrary for TranscriptLibrary.Transcript;



    uint256 constant STATE_WIDTH_OLD = 4;

    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD = 1;



    struct VerificationKeyOld {

        uint256 domain_size;

        uint256 num_inputs;

        PairingsBn254.Fr omega;

        PairingsBn254.G1Point[STATE_WIDTH_OLD + 2] selector_commitments; // STATE_WIDTH for witness + multiplication + constant

        PairingsBn254.G1Point[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD] next_step_selector_commitments;

        PairingsBn254.G1Point[STATE_WIDTH_OLD] permutation_commitments;

        PairingsBn254.Fr[STATE_WIDTH_OLD - 1] permutation_non_residues;

        PairingsBn254.G2Point g2_x;

    }



    struct ProofOld {

        uint256[] input_values;

        PairingsBn254.G1Point[STATE_WIDTH_OLD] wire_commitments;

        PairingsBn254.G1Point grand_product_commitment;

        PairingsBn254.G1Point[STATE_WIDTH_OLD] quotient_poly_commitments;

        PairingsBn254.Fr[STATE_WIDTH_OLD] wire_values_at_z;

        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD] wire_values_at_z_omega;

        PairingsBn254.Fr grand_product_at_z_omega;

        PairingsBn254.Fr quotient_polynomial_at_z;

        PairingsBn254.Fr linearization_polynomial_at_z;

        PairingsBn254.Fr[STATE_WIDTH_OLD - 1] permutation_polynomials_at_z;

        PairingsBn254.G1Point opening_at_z_proof;

        PairingsBn254.G1Point opening_at_z_omega_proof;

    }



    struct PartialVerifierStateOld {

        PairingsBn254.Fr alpha;

        PairingsBn254.Fr beta;

        PairingsBn254.Fr gamma;

        PairingsBn254.Fr v;

        PairingsBn254.Fr u;

        PairingsBn254.Fr z;

        PairingsBn254.Fr[] cached_lagrange_evals;

    }



    function evaluate_lagrange_poly_out_of_domain_old(

        uint256 poly_num,

        uint256 domain_size,

        PairingsBn254.Fr memory omega,

        PairingsBn254.Fr memory at

    ) internal view returns (PairingsBn254.Fr memory res) {

        require(poly_num < domain_size);

        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);

        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);

        res = at.pow(domain_size);

        res.sub_assign(one);

        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`

        res.mul_assign(omega_power);



        PairingsBn254.Fr memory den = PairingsBn254.copy(at);

        den.sub_assign(omega_power);

        den.mul_assign(PairingsBn254.new_fr(domain_size));



        den = den.inverse();



        res.mul_assign(den);

    }



    function batch_evaluate_lagrange_poly_out_of_domain_old(

        uint256[] memory poly_nums,

        uint256 domain_size,

        PairingsBn254.Fr memory omega,

        PairingsBn254.Fr memory at

    ) internal view returns (PairingsBn254.Fr[] memory res) {

        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);

        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);

        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);

        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);

        vanishing_at_z.sub_assign(one);

        // we can not have random point z be in domain

        require(vanishing_at_z.value != 0);

        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);

        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);

        // numerators in a form omega^i * (z^n - 1)

        // denoms in a form (z - omega^i) * N

        for (uint256 i = 0; i < poly_nums.length; i++) {

            tmp_1 = omega.pow(poly_nums[i]); // power of omega

            nums[i].assign(vanishing_at_z);

            nums[i].mul_assign(tmp_1);



            dens[i].assign(at); // (X - omega^i) * N

            dens[i].sub_assign(tmp_1);

            dens[i].mul_assign(tmp_2); // mul by domain size

        }



        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);

        partial_products[0].assign(PairingsBn254.new_fr(1));

        for (uint256 i = 1; i < dens.length - 1; i++) {

            partial_products[i].assign(dens[i - 1]);

            partial_products[i].mul_assign(dens[i]);

        }



        tmp_2.assign(partial_products[partial_products.length - 1]);

        tmp_2.mul_assign(dens[dens.length - 1]);

        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)



        for (uint256 i = dens.length - 1; i < dens.length; i--) {

            dens[i].assign(tmp_2); // all inversed

            dens[i].mul_assign(partial_products[i]); // clear lowest terms

            tmp_2.mul_assign(dens[i]);

        }



        for (uint256 i = 0; i < nums.length; i++) {

            nums[i].mul_assign(dens[i]);

        }



        return nums;

    }



    function evaluate_vanishing_old(uint256 domain_size, PairingsBn254.Fr memory at)

        internal

        view

        returns (PairingsBn254.Fr memory res)

    {

        res = at.pow(domain_size);

        res.sub_assign(PairingsBn254.new_fr(1));

    }



    function verify_at_z(

        PartialVerifierStateOld memory state,

        ProofOld memory proof,

        VerificationKeyOld memory vk

    ) internal view returns (bool) {

        PairingsBn254.Fr memory lhs = evaluate_vanishing_old(vk.domain_size, state.z);

        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain

        lhs.mul_assign(proof.quotient_polynomial_at_z);



        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);

        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);



        // public inputs

        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);

        for (uint256 i = 0; i < proof.input_values.length; i++) {

            tmp.assign(state.cached_lagrange_evals[i]);

            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));

            rhs.add_assign(tmp);

        }



        quotient_challenge.mul_assign(state.alpha);



        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.grand_product_at_z_omega);

        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            tmp.assign(proof.permutation_polynomials_at_z[i]);

            tmp.mul_assign(state.beta);

            tmp.add_assign(state.gamma);

            tmp.add_assign(proof.wire_values_at_z[i]);



            z_part.mul_assign(tmp);

        }



        tmp.assign(state.gamma);

        // we need a wire value of the last polynomial in enumeration

        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH_OLD - 1]);



        z_part.mul_assign(tmp);

        z_part.mul_assign(quotient_challenge);



        rhs.sub_assign(z_part);



        quotient_challenge.mul_assign(state.alpha);



        tmp.assign(state.cached_lagrange_evals[0]);

        tmp.mul_assign(quotient_challenge);



        rhs.sub_assign(tmp);



        return lhs.value == rhs.value;

    }



    function reconstruct_d(

        PartialVerifierStateOld memory state,

        ProofOld memory proof,

        VerificationKeyOld memory vk

    ) internal view returns (PairingsBn254.G1Point memory res) {

        // we compute what power of v is used as a delinearization factor in batch opening of

        // commitments. Let's label W(x) = 1 / (x - z) *

        // [

        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)

        // + v (r(x) - r(z))

        // + v^{2..5} * (witness(x) - witness(z))

        // + v^(6..8) * (permutation(x) - permutation(z))

        // ]

        // W'(x) = 1 / (x - z*omega) *

        // [

        // + v^9 (z(x) - z(z*omega)) <- we need this power

        // + v^10 * (d(x) - d(z*omega))

        // ]

        //

        // we pay a little for a few arithmetic operations to not introduce another constant

        uint256 power_for_z_omega_opening = 1 + 1 + STATE_WIDTH_OLD + STATE_WIDTH_OLD - 1;

        res = PairingsBn254.copy_g1(vk.selector_commitments[STATE_WIDTH_OLD + 1]);



        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();

        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);



        // addition gates

        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {

            tmp_g1 = vk.selector_commitments[i].point_mul(proof.wire_values_at_z[i]);

            res.point_add_assign(tmp_g1);

        }



        // multiplication gate

        tmp_fr.assign(proof.wire_values_at_z[0]);

        tmp_fr.mul_assign(proof.wire_values_at_z[1]);

        tmp_g1 = vk.selector_commitments[STATE_WIDTH_OLD].point_mul(tmp_fr);

        res.point_add_assign(tmp_g1);



        // d_next

        tmp_g1 = vk.next_step_selector_commitments[0].point_mul(proof.wire_values_at_z_omega[0]);

        res.point_add_assign(tmp_g1);



        // z * non_res * beta + gamma + a

        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);

        grand_product_part_at_z.mul_assign(state.beta);

        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);

        grand_product_part_at_z.add_assign(state.gamma);

        for (uint256 i = 0; i < vk.permutation_non_residues.length; i++) {

            tmp_fr.assign(state.z);

            tmp_fr.mul_assign(vk.permutation_non_residues[i]);

            tmp_fr.mul_assign(state.beta);

            tmp_fr.add_assign(state.gamma);

            tmp_fr.add_assign(proof.wire_values_at_z[i + 1]);



            grand_product_part_at_z.mul_assign(tmp_fr);

        }



        grand_product_part_at_z.mul_assign(state.alpha);



        tmp_fr.assign(state.cached_lagrange_evals[0]);

        tmp_fr.mul_assign(state.alpha);

        tmp_fr.mul_assign(state.alpha);



        grand_product_part_at_z.add_assign(tmp_fr);



        PairingsBn254.Fr memory grand_product_part_at_z_omega = state.v.pow(power_for_z_omega_opening);

        grand_product_part_at_z_omega.mul_assign(state.u);



        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);

        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            tmp_fr.assign(state.beta);

            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);

            tmp_fr.add_assign(state.gamma);

            tmp_fr.add_assign(proof.wire_values_at_z[i]);



            last_permutation_part_at_z.mul_assign(tmp_fr);

        }



        last_permutation_part_at_z.mul_assign(state.beta);

        last_permutation_part_at_z.mul_assign(proof.grand_product_at_z_omega);

        last_permutation_part_at_z.mul_assign(state.alpha);



        // add to the linearization

        tmp_g1 = proof.grand_product_commitment.point_mul(grand_product_part_at_z);

        tmp_g1.point_sub_assign(vk.permutation_commitments[STATE_WIDTH_OLD - 1].point_mul(last_permutation_part_at_z));



        res.point_add_assign(tmp_g1);

        res.point_mul_assign(state.v);



        res.point_add_assign(proof.grand_product_commitment.point_mul(grand_product_part_at_z_omega));

    }



    function verify_commitments(

        PartialVerifierStateOld memory state,

        ProofOld memory proof,

        VerificationKeyOld memory vk

    ) internal view returns (bool) {

        PairingsBn254.G1Point memory d = reconstruct_d(state, proof, vk);



        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);



        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();



        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);



        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);

        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);

        for (uint256 i = 1; i < proof.quotient_poly_commitments.length; i++) {

            tmp_fr.mul_assign(z_in_domain_size);

            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);

            commitment_aggregation.point_add_assign(tmp_g1);

        }



        aggregation_challenge.mul_assign(state.v);

        commitment_aggregation.point_add_assign(d);



        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {

            aggregation_challenge.mul_assign(state.v);

            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);

            commitment_aggregation.point_add_assign(tmp_g1);

        }



        for (uint256 i = 0; i < vk.permutation_commitments.length - 1; i++) {

            aggregation_challenge.mul_assign(state.v);

            tmp_g1 = vk.permutation_commitments[i].point_mul(aggregation_challenge);

            commitment_aggregation.point_add_assign(tmp_g1);

        }



        aggregation_challenge.mul_assign(state.v);



        aggregation_challenge.mul_assign(state.v);



        tmp_fr.assign(aggregation_challenge);

        tmp_fr.mul_assign(state.u);

        tmp_g1 = proof.wire_commitments[STATE_WIDTH_OLD - 1].point_mul(tmp_fr);

        commitment_aggregation.point_add_assign(tmp_g1);



        // collect opening values

        aggregation_challenge = PairingsBn254.new_fr(1);



        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);



        aggregation_challenge.mul_assign(state.v);



        tmp_fr.assign(proof.linearization_polynomial_at_z);

        tmp_fr.mul_assign(aggregation_challenge);

        aggregated_value.add_assign(tmp_fr);



        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {

            aggregation_challenge.mul_assign(state.v);



            tmp_fr.assign(proof.wire_values_at_z[i]);

            tmp_fr.mul_assign(aggregation_challenge);

            aggregated_value.add_assign(tmp_fr);

        }



        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            aggregation_challenge.mul_assign(state.v);



            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);

            tmp_fr.mul_assign(aggregation_challenge);

            aggregated_value.add_assign(tmp_fr);

        }



        aggregation_challenge.mul_assign(state.v);



        tmp_fr.assign(proof.grand_product_at_z_omega);

        tmp_fr.mul_assign(aggregation_challenge);

        tmp_fr.mul_assign(state.u);

        aggregated_value.add_assign(tmp_fr);



        aggregation_challenge.mul_assign(state.v);



        tmp_fr.assign(proof.wire_values_at_z_omega[0]);

        tmp_fr.mul_assign(aggregation_challenge);

        tmp_fr.mul_assign(state.u);

        aggregated_value.add_assign(tmp_fr);



        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));



        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;

        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));



        tmp_fr.assign(state.z);

        tmp_fr.mul_assign(vk.omega);

        tmp_fr.mul_assign(state.u);

        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));



        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);

        pair_with_x.point_add_assign(proof.opening_at_z_proof);

        pair_with_x.negate();



        return PairingsBn254.pairingProd2(pair_with_generator, PairingsBn254.P2(), pair_with_x, vk.g2_x);

    }



    function verify_initial(

        PartialVerifierStateOld memory state,

        ProofOld memory proof,

        VerificationKeyOld memory vk

    ) internal view returns (bool) {

        require(proof.input_values.length == vk.num_inputs);

        require(vk.num_inputs >= 1);

        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();

        for (uint256 i = 0; i < vk.num_inputs; i++) {

            transcript.update_with_u256(proof.input_values[i]);

        }



        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {

            transcript.update_with_g1(proof.wire_commitments[i]);

        }



        state.beta = transcript.get_challenge();

        state.gamma = transcript.get_challenge();



        transcript.update_with_g1(proof.grand_product_commitment);

        state.alpha = transcript.get_challenge();



        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {

            transcript.update_with_g1(proof.quotient_poly_commitments[i]);

        }



        state.z = transcript.get_challenge();



        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);

        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {

            lagrange_poly_numbers[i] = i;

        }



        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain_old(

            lagrange_poly_numbers,

            vk.domain_size,

            vk.omega,

            state.z

        );



        bool valid = verify_at_z(state, proof, vk);



        if (valid == false) {

            return false;

        }



        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {

            transcript.update_with_fr(proof.wire_values_at_z[i]);

        }



        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {

            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);

        }



        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);

        }



        transcript.update_with_fr(proof.quotient_polynomial_at_z);

        transcript.update_with_fr(proof.linearization_polynomial_at_z);

        transcript.update_with_fr(proof.grand_product_at_z_omega);



        state.v = transcript.get_challenge();

        transcript.update_with_g1(proof.opening_at_z_proof);

        transcript.update_with_g1(proof.opening_at_z_omega_proof);

        state.u = transcript.get_challenge();



        return true;

    }



    // This verifier is for a PLONK with a state width 4

    // and main gate equation

    // q_a(X) * a(X) +

    // q_b(X) * b(X) +

    // q_c(X) * c(X) +

    // q_d(X) * d(X) +

    // q_m(X) * a(X) * b(X) +

    // q_constants(X)+

    // q_d_next(X) * d(X*omega)

    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials

    // q_d_next(X) "peeks" into the next row of the trace, so it takes

    // the same d(X) polynomial, but shifted



    function verify_old(ProofOld memory proof, VerificationKeyOld memory vk) internal view returns (bool) {

        PartialVerifierStateOld memory state;



        bool valid = verify_initial(state, proof, vk);



        if (valid == false) {

            return false;

        }



        valid = verify_commitments(state, proof, vk);



        return valid;

    }

}



contract VerifierWithDeserializeOld is Plonk4VerifierWithAccessToDNextOld {

    uint256 constant SERIALIZED_PROOF_LENGTH_OLD = 33;



    function deserialize_proof_old(uint256[] memory public_inputs, uint256[] memory serialized_proof)

        internal

        pure

        returns (ProofOld memory proof)

    {

        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH_OLD);

        proof.input_values = new uint256[](public_inputs.length);

        for (uint256 i = 0; i < public_inputs.length; i++) {

            proof.input_values[i] = public_inputs[i];

        }



        uint256 j = 0;

        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {

            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);



            j += 2;

        }



        proof.grand_product_commitment = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);

        j += 2;



        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {

            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(

                serialized_proof[j],

                serialized_proof[j + 1]

            );



            j += 2;

        }



        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {

            proof.wire_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j += 1;

        }



        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {

            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j += 1;

        }



        proof.grand_product_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);



        j += 1;



        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);



        j += 1;



        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);



        j += 1;



        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {

            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j += 1;

        }



        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);

        j += 2;



        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\PriorityQueue.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







/// @notice The structure that contains meta information of the L2 transaction that was requested from L1

/// @dev The weird size of fields was selected specifically to minimize the structure storage size

/// @param canonicalTxHash Hashed L2 transaction data that is needed to process it

/// @param expirationTimestamp Expiration timestamp for this request (must be satisfied before)

/// @param layer2Tip Additional payment to the validator as an incentive to perform the operation

struct PriorityOperation {

    bytes32 canonicalTxHash;

    uint64 expirationTimestamp;

    uint192 layer2Tip;

}



/// @author Matter Labs

/// @dev The library provides the API to interact with the priority queue container

/// @dev Order of processing operations from queue - FIFO (Fist in - first out)

library PriorityQueue {

    using PriorityQueue for Queue;



    /// @notice Container that stores priority operations

    /// @param data The inner mapping that saves priority operation by its index

    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty

    /// @param tail The pointer to the free slot

    struct Queue {

        mapping(uint256 => PriorityOperation) data;

        uint256 tail;

        uint256 head;

    }



    /// @notice Returns zero if and only if no operations were processed from the queue

    /// @return Index of the oldest priority operation that wasn't processed yet

    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {

        return _queue.head;

    }



    /// @return The total number of priority operations that were added to the priority queue, including all processed ones

    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {

        return _queue.tail;

    }



    /// @return The total number of unprocessed priority operations in a priority queue

    function getSize(Queue storage _queue) internal view returns (uint256) {

        return uint256(_queue.tail - _queue.head);

    }



    /// @return Whether the priority queue contains no operations

    function isEmpty(Queue storage _queue) internal view returns (bool) {

        return _queue.tail == _queue.head;

    }



    /// @notice Add the priority operation to the end of the priority queue

    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {

        // Save value into the stack to avoid double reading from the storage

        uint256 tail = _queue.tail;



        _queue.data[tail] = _operation;

        _queue.tail = tail + 1;

    }



    /// @return The first unprocessed priority operation from the queue

    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {

        require(!_queue.isEmpty(), "D"); // priority queue is empty



        return _queue.data[_queue.head];

    }



    /// @notice Remove the first unprocessed priority operation from the queue

    /// @return priorityOperation that was popped from the priority queue

    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {

        require(!_queue.isEmpty(), "s"); // priority queue is empty



        // Save value into the stack to avoid double reading from the storage

        uint256 head = _queue.head;



        priorityOperation = _queue.data[head];

        delete _queue.data[head];

        _queue.head = head + 1;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Proxy.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)



pragma solidity ^0.8.0;



/**

 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM

 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to

 * be specified by overriding the virtual {_implementation} function.

 *

 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a

 * different contract through the {_delegate} function.

 *

 * The success and return data of the delegated call will be returned back to the caller of the proxy.

 */

abstract contract Proxy {

    /**

     * @dev Delegates the current call to `implementation`.

     *

     * This function does not return to its internal call site, it will return directly to the external caller.

     */

    function _delegate(address implementation) internal virtual {

        assembly {

            // Copy msg.data. We take full control of memory in this inline assembly

            // block because it will not return to Solidity code. We overwrite the

            // Solidity scratch pad at memory position 0.

            calldatacopy(0, 0, calldatasize())



            // Call the implementation.

            // out and outsize are 0 because we don't know the size yet.

            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)



            // Copy the returned data.

            returndatacopy(0, 0, returndatasize())



            switch result

            // delegatecall returns 0 on error.

            case 0 {

                revert(0, returndatasize())

            }

            default {

                return(0, returndatasize())

            }

        }

    }



    /**

     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function

     * and {_fallback} should delegate.

     */

    function _implementation() internal view virtual returns (address);



    /**

     * @dev Delegates the current call to the address returned by `_implementation()`.

     *

     * This function does not return to its internal call site, it will return directly to the external caller.

     */

    function _fallback() internal virtual {

        _beforeFallback();

        _delegate(_implementation());

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other

     * function in the contract matches the call data.

     */

    fallback() external payable virtual {

        _fallback();

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data

     * is empty.

     */

    receive() external payable virtual {

        _fallback();

    }



    /**

     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`

     * call, or as part of the Solidity `fallback` or `receive` functions.

     *

     * If overridden should call `super._beforeFallback()`.

     */

    function _beforeFallback() internal virtual {}

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ProxyAdmin.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)



pragma solidity ^0.8.0;



import "./TransparentUpgradeableProxy.sol";

import "../../access/Ownable.sol";



/**

 * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an

 * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.

 */

contract ProxyAdmin is Ownable {

    /**

     * @dev Returns the current implementation of `proxy`.

     *

     * Requirements:

     *

     * - This contract must be the admin of `proxy`.

     */

    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {

        // We need to manually run the static call since the getter cannot be flagged as view

        // bytes4(keccak256("implementation()")) == 0x5c60da1b

        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"5c60da1b");

        require(success);

        return abi.decode(returndata, (address));

    }



    /**

     * @dev Returns the current admin of `proxy`.

     *

     * Requirements:

     *

     * - This contract must be the admin of `proxy`.

     */

    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {

        // We need to manually run the static call since the getter cannot be flagged as view

        // bytes4(keccak256("admin()")) == 0xf851a440

        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"f851a440");

        require(success);

        return abi.decode(returndata, (address));

    }



    /**

     * @dev Changes the admin of `proxy` to `newAdmin`.

     *

     * Requirements:

     *

     * - This contract must be the current admin of `proxy`.

     */

    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {

        proxy.changeAdmin(newAdmin);

    }



    /**

     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.

     *

     * Requirements:

     *

     * - This contract must be the admin of `proxy`.

     */

    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {

        proxy.upgradeTo(implementation);

    }



    /**

     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See

     * {TransparentUpgradeableProxy-upgradeToAndCall}.

     *

     * Requirements:

     *

     * - This contract must be the admin of `proxy`.

     */

    function upgradeAndCall(

        TransparentUpgradeableProxy proxy,

        address implementation,

        bytes memory data

    ) public payable virtual onlyOwner {

        proxy.upgradeToAndCall{value: msg.value}(implementation, data);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ReentrancyGuard.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * TIP: If you would like to learn more about reentrancy and alternative ways

 * to protect against it, check out our blog post

 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].

 *

 * _Since v2.5.0:_ this module is now much more gas efficient, given net gas

 * metering changes introduced in the Istanbul hardfork.

 */

abstract contract ReentrancyGuard {

    /// @dev Address of lock flag variable.

    /// @dev Flag is placed at random memory location to not interfere with Storage contract.

    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4; // keccak256("ReentrancyGuard") - 1;



    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/security/ReentrancyGuard.sol

    // The values being non-zero value makes deployment a bit more expensive,

    // but in exchange the refund on every call to nonReentrant will be lower in

    // amount. Since refunds are capped to a percentage of the total

    // transaction's gas, it is best to keep them low in cases like this one, to

    // increase the likelihood of the full refund coming into effect.

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    modifier reentrancyGuardInitializer() {

        _initializeReentrancyGuard();

        _;

    }



    function _initializeReentrancyGuard() private {

        uint256 lockSlotOldValue;



        // Storing an initial non-zero value makes deployment a bit more

        // expensive but in exchange every call to nonReentrant

        // will be cheaper.

        assembly {

            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)

            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)

        }



        // Check that storage slot for reentrancy guard is empty to rule out possibility of slot conflict

        require(lockSlotOldValue == 0, "1B");

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        uint256 _status;

        assembly {

            _status := sload(LOCK_FLAG_ADDRESS)

        }



        // On the first call to nonReentrant, _notEntered will be true

        require(_status == _NOT_ENTERED, "r1");



        // Any calls to nonReentrant after this point will fail

        assembly {

            sstore(LOCK_FLAG_ADDRESS, _ENTERED)

        }



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        assembly {

            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ReentrancyGuardUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)



pragma solidity ^0.8.0;

import "../proxy/utils/Initializable.sol";



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * TIP: If you would like to learn more about reentrancy and alternative ways

 * to protect against it, check out our blog post

 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].

 */

abstract contract ReentrancyGuardUpgradeable is Initializable {

    // Booleans are more expensive than uint256 or any type that takes up a full

    // word because each write operation emits an extra SLOAD to first read the

    // slot's contents, replace the bits taken up by the boolean, and then write

    // back. This is the compiler's defense against contract upgrades and

    // pointer aliasing, and it cannot be disabled.



    // The values being non-zero value makes deployment a bit more expensive,

    // but in exchange the refund on every call to nonReentrant will be lower in

    // amount. Since refunds are capped to a percentage of the total

    // transaction's gas, it is best to keep them low in cases like this one, to

    // increase the likelihood of the full refund coming into effect.

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    uint256 private _status;



    function __ReentrancyGuard_init() internal onlyInitializing {

        __ReentrancyGuard_init_unchained();

    }



    function __ReentrancyGuard_init_unchained() internal onlyInitializing {

        _status = _NOT_ENTERED;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and making it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        _nonReentrantBefore();

        _;

        _nonReentrantAfter();

    }



    function _nonReentrantBefore() private {

        // On the first call to nonReentrant, _status will be _NOT_ENTERED

        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _status = _ENTERED;

    }



    function _nonReentrantAfter() private {

        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _status = _NOT_ENTERED;

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\SafeCast.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)

// This file was procedurally generated from scripts/generate/templates/SafeCast.js.



pragma solidity ^0.8.0;



/**

 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow

 * checks.

 *

 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can

 * easily result in undesired exploitation or bugs, since developers usually

 * assume that overflows raise errors. `SafeCast` restores this intuition by

 * reverting the transaction when such an operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 *

 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing

 * all math on `uint256` and `int256` and then downcasting.

 */

library SafeCast {

    /**

     * @dev Returns the downcasted uint248 from uint256, reverting on

     * overflow (when the input is greater than largest uint248).

     *

     * Counterpart to Solidity's `uint248` operator.

     *

     * Requirements:

     *

     * - input must fit into 248 bits

     *

     * _Available since v4.7._

     */

    function toUint248(uint256 value) internal pure returns (uint248) {

        require(value <= type(uint248).max, "SafeCast: value doesn't fit in 248 bits");

        return uint248(value);

    }



    /**

     * @dev Returns the downcasted uint240 from uint256, reverting on

     * overflow (when the input is greater than largest uint240).

     *

     * Counterpart to Solidity's `uint240` operator.

     *

     * Requirements:

     *

     * - input must fit into 240 bits

     *

     * _Available since v4.7._

     */

    function toUint240(uint256 value) internal pure returns (uint240) {

        require(value <= type(uint240).max, "SafeCast: value doesn't fit in 240 bits");

        return uint240(value);

    }



    /**

     * @dev Returns the downcasted uint232 from uint256, reverting on

     * overflow (when the input is greater than largest uint232).

     *

     * Counterpart to Solidity's `uint232` operator.

     *

     * Requirements:

     *

     * - input must fit into 232 bits

     *

     * _Available since v4.7._

     */

    function toUint232(uint256 value) internal pure returns (uint232) {

        require(value <= type(uint232).max, "SafeCast: value doesn't fit in 232 bits");

        return uint232(value);

    }



    /**

     * @dev Returns the downcasted uint224 from uint256, reverting on

     * overflow (when the input is greater than largest uint224).

     *

     * Counterpart to Solidity's `uint224` operator.

     *

     * Requirements:

     *

     * - input must fit into 224 bits

     *

     * _Available since v4.2._

     */

    function toUint224(uint256 value) internal pure returns (uint224) {

        require(value <= type(uint224).max, "SafeCast: value doesn't fit in 224 bits");

        return uint224(value);

    }



    /**

     * @dev Returns the downcasted uint216 from uint256, reverting on

     * overflow (when the input is greater than largest uint216).

     *

     * Counterpart to Solidity's `uint216` operator.

     *

     * Requirements:

     *

     * - input must fit into 216 bits

     *

     * _Available since v4.7._

     */

    function toUint216(uint256 value) internal pure returns (uint216) {

        require(value <= type(uint216).max, "SafeCast: value doesn't fit in 216 bits");

        return uint216(value);

    }



    /**

     * @dev Returns the downcasted uint208 from uint256, reverting on

     * overflow (when the input is greater than largest uint208).

     *

     * Counterpart to Solidity's `uint208` operator.

     *

     * Requirements:

     *

     * - input must fit into 208 bits

     *

     * _Available since v4.7._

     */

    function toUint208(uint256 value) internal pure returns (uint208) {

        require(value <= type(uint208).max, "SafeCast: value doesn't fit in 208 bits");

        return uint208(value);

    }



    /**

     * @dev Returns the downcasted uint200 from uint256, reverting on

     * overflow (when the input is greater than largest uint200).

     *

     * Counterpart to Solidity's `uint200` operator.

     *

     * Requirements:

     *

     * - input must fit into 200 bits

     *

     * _Available since v4.7._

     */

    function toUint200(uint256 value) internal pure returns (uint200) {

        require(value <= type(uint200).max, "SafeCast: value doesn't fit in 200 bits");

        return uint200(value);

    }



    /**

     * @dev Returns the downcasted uint192 from uint256, reverting on

     * overflow (when the input is greater than largest uint192).

     *

     * Counterpart to Solidity's `uint192` operator.

     *

     * Requirements:

     *

     * - input must fit into 192 bits

     *

     * _Available since v4.7._

     */

    function toUint192(uint256 value) internal pure returns (uint192) {

        require(value <= type(uint192).max, "SafeCast: value doesn't fit in 192 bits");

        return uint192(value);

    }



    /**

     * @dev Returns the downcasted uint184 from uint256, reverting on

     * overflow (when the input is greater than largest uint184).

     *

     * Counterpart to Solidity's `uint184` operator.

     *

     * Requirements:

     *

     * - input must fit into 184 bits

     *

     * _Available since v4.7._

     */

    function toUint184(uint256 value) internal pure returns (uint184) {

        require(value <= type(uint184).max, "SafeCast: value doesn't fit in 184 bits");

        return uint184(value);

    }



    /**

     * @dev Returns the downcasted uint176 from uint256, reverting on

     * overflow (when the input is greater than largest uint176).

     *

     * Counterpart to Solidity's `uint176` operator.

     *

     * Requirements:

     *

     * - input must fit into 176 bits

     *

     * _Available since v4.7._

     */

    function toUint176(uint256 value) internal pure returns (uint176) {

        require(value <= type(uint176).max, "SafeCast: value doesn't fit in 176 bits");

        return uint176(value);

    }



    /**

     * @dev Returns the downcasted uint168 from uint256, reverting on

     * overflow (when the input is greater than largest uint168).

     *

     * Counterpart to Solidity's `uint168` operator.

     *

     * Requirements:

     *

     * - input must fit into 168 bits

     *

     * _Available since v4.7._

     */

    function toUint168(uint256 value) internal pure returns (uint168) {

        require(value <= type(uint168).max, "SafeCast: value doesn't fit in 168 bits");

        return uint168(value);

    }



    /**

     * @dev Returns the downcasted uint160 from uint256, reverting on

     * overflow (when the input is greater than largest uint160).

     *

     * Counterpart to Solidity's `uint160` operator.

     *

     * Requirements:

     *

     * - input must fit into 160 bits

     *

     * _Available since v4.7._

     */

    function toUint160(uint256 value) internal pure returns (uint160) {

        require(value <= type(uint160).max, "SafeCast: value doesn't fit in 160 bits");

        return uint160(value);

    }



    /**

     * @dev Returns the downcasted uint152 from uint256, reverting on

     * overflow (when the input is greater than largest uint152).

     *

     * Counterpart to Solidity's `uint152` operator.

     *

     * Requirements:

     *

     * - input must fit into 152 bits

     *

     * _Available since v4.7._

     */

    function toUint152(uint256 value) internal pure returns (uint152) {

        require(value <= type(uint152).max, "SafeCast: value doesn't fit in 152 bits");

        return uint152(value);

    }



    /**

     * @dev Returns the downcasted uint144 from uint256, reverting on

     * overflow (when the input is greater than largest uint144).

     *

     * Counterpart to Solidity's `uint144` operator.

     *

     * Requirements:

     *

     * - input must fit into 144 bits

     *

     * _Available since v4.7._

     */

    function toUint144(uint256 value) internal pure returns (uint144) {

        require(value <= type(uint144).max, "SafeCast: value doesn't fit in 144 bits");

        return uint144(value);

    }



    /**

     * @dev Returns the downcasted uint136 from uint256, reverting on

     * overflow (when the input is greater than largest uint136).

     *

     * Counterpart to Solidity's `uint136` operator.

     *

     * Requirements:

     *

     * - input must fit into 136 bits

     *

     * _Available since v4.7._

     */

    function toUint136(uint256 value) internal pure returns (uint136) {

        require(value <= type(uint136).max, "SafeCast: value doesn't fit in 136 bits");

        return uint136(value);

    }



    /**

     * @dev Returns the downcasted uint128 from uint256, reverting on

     * overflow (when the input is greater than largest uint128).

     *

     * Counterpart to Solidity's `uint128` operator.

     *

     * Requirements:

     *

     * - input must fit into 128 bits

     *

     * _Available since v2.5._

     */

    function toUint128(uint256 value) internal pure returns (uint128) {

        require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");

        return uint128(value);

    }



    /**

     * @dev Returns the downcasted uint120 from uint256, reverting on

     * overflow (when the input is greater than largest uint120).

     *

     * Counterpart to Solidity's `uint120` operator.

     *

     * Requirements:

     *

     * - input must fit into 120 bits

     *

     * _Available since v4.7._

     */

    function toUint120(uint256 value) internal pure returns (uint120) {

        require(value <= type(uint120).max, "SafeCast: value doesn't fit in 120 bits");

        return uint120(value);

    }



    /**

     * @dev Returns the downcasted uint112 from uint256, reverting on

     * overflow (when the input is greater than largest uint112).

     *

     * Counterpart to Solidity's `uint112` operator.

     *

     * Requirements:

     *

     * - input must fit into 112 bits

     *

     * _Available since v4.7._

     */

    function toUint112(uint256 value) internal pure returns (uint112) {

        require(value <= type(uint112).max, "SafeCast: value doesn't fit in 112 bits");

        return uint112(value);

    }



    /**

     * @dev Returns the downcasted uint104 from uint256, reverting on

     * overflow (when the input is greater than largest uint104).

     *

     * Counterpart to Solidity's `uint104` operator.

     *

     * Requirements:

     *

     * - input must fit into 104 bits

     *

     * _Available since v4.7._

     */

    function toUint104(uint256 value) internal pure returns (uint104) {

        require(value <= type(uint104).max, "SafeCast: value doesn't fit in 104 bits");

        return uint104(value);

    }



    /**

     * @dev Returns the downcasted uint96 from uint256, reverting on

     * overflow (when the input is greater than largest uint96).

     *

     * Counterpart to Solidity's `uint96` operator.

     *

     * Requirements:

     *

     * - input must fit into 96 bits

     *

     * _Available since v4.2._

     */

    function toUint96(uint256 value) internal pure returns (uint96) {

        require(value <= type(uint96).max, "SafeCast: value doesn't fit in 96 bits");

        return uint96(value);

    }



    /**

     * @dev Returns the downcasted uint88 from uint256, reverting on

     * overflow (when the input is greater than largest uint88).

     *

     * Counterpart to Solidity's `uint88` operator.

     *

     * Requirements:

     *

     * - input must fit into 88 bits

     *

     * _Available since v4.7._

     */

    function toUint88(uint256 value) internal pure returns (uint88) {

        require(value <= type(uint88).max, "SafeCast: value doesn't fit in 88 bits");

        return uint88(value);

    }



    /**

     * @dev Returns the downcasted uint80 from uint256, reverting on

     * overflow (when the input is greater than largest uint80).

     *

     * Counterpart to Solidity's `uint80` operator.

     *

     * Requirements:

     *

     * - input must fit into 80 bits

     *

     * _Available since v4.7._

     */

    function toUint80(uint256 value) internal pure returns (uint80) {

        require(value <= type(uint80).max, "SafeCast: value doesn't fit in 80 bits");

        return uint80(value);

    }



    /**

     * @dev Returns the downcasted uint72 from uint256, reverting on

     * overflow (when the input is greater than largest uint72).

     *

     * Counterpart to Solidity's `uint72` operator.

     *

     * Requirements:

     *

     * - input must fit into 72 bits

     *

     * _Available since v4.7._

     */

    function toUint72(uint256 value) internal pure returns (uint72) {

        require(value <= type(uint72).max, "SafeCast: value doesn't fit in 72 bits");

        return uint72(value);

    }



    /**

     * @dev Returns the downcasted uint64 from uint256, reverting on

     * overflow (when the input is greater than largest uint64).

     *

     * Counterpart to Solidity's `uint64` operator.

     *

     * Requirements:

     *

     * - input must fit into 64 bits

     *

     * _Available since v2.5._

     */

    function toUint64(uint256 value) internal pure returns (uint64) {

        require(value <= type(uint64).max, "SafeCast: value doesn't fit in 64 bits");

        return uint64(value);

    }



    /**

     * @dev Returns the downcasted uint56 from uint256, reverting on

     * overflow (when the input is greater than largest uint56).

     *

     * Counterpart to Solidity's `uint56` operator.

     *

     * Requirements:

     *

     * - input must fit into 56 bits

     *

     * _Available since v4.7._

     */

    function toUint56(uint256 value) internal pure returns (uint56) {

        require(value <= type(uint56).max, "SafeCast: value doesn't fit in 56 bits");

        return uint56(value);

    }



    /**

     * @dev Returns the downcasted uint48 from uint256, reverting on

     * overflow (when the input is greater than largest uint48).

     *

     * Counterpart to Solidity's `uint48` operator.

     *

     * Requirements:

     *

     * - input must fit into 48 bits

     *

     * _Available since v4.7._

     */

    function toUint48(uint256 value) internal pure returns (uint48) {

        require(value <= type(uint48).max, "SafeCast: value doesn't fit in 48 bits");

        return uint48(value);

    }



    /**

     * @dev Returns the downcasted uint40 from uint256, reverting on

     * overflow (when the input is greater than largest uint40).

     *

     * Counterpart to Solidity's `uint40` operator.

     *

     * Requirements:

     *

     * - input must fit into 40 bits

     *

     * _Available since v4.7._

     */

    function toUint40(uint256 value) internal pure returns (uint40) {

        require(value <= type(uint40).max, "SafeCast: value doesn't fit in 40 bits");

        return uint40(value);

    }



    /**

     * @dev Returns the downcasted uint32 from uint256, reverting on

     * overflow (when the input is greater than largest uint32).

     *

     * Counterpart to Solidity's `uint32` operator.

     *

     * Requirements:

     *

     * - input must fit into 32 bits

     *

     * _Available since v2.5._

     */

    function toUint32(uint256 value) internal pure returns (uint32) {

        require(value <= type(uint32).max, "SafeCast: value doesn't fit in 32 bits");

        return uint32(value);

    }



    /**

     * @dev Returns the downcasted uint24 from uint256, reverting on

     * overflow (when the input is greater than largest uint24).

     *

     * Counterpart to Solidity's `uint24` operator.

     *

     * Requirements:

     *

     * - input must fit into 24 bits

     *

     * _Available since v4.7._

     */

    function toUint24(uint256 value) internal pure returns (uint24) {

        require(value <= type(uint24).max, "SafeCast: value doesn't fit in 24 bits");

        return uint24(value);

    }



    /**

     * @dev Returns the downcasted uint16 from uint256, reverting on

     * overflow (when the input is greater than largest uint16).

     *

     * Counterpart to Solidity's `uint16` operator.

     *

     * Requirements:

     *

     * - input must fit into 16 bits

     *

     * _Available since v2.5._

     */

    function toUint16(uint256 value) internal pure returns (uint16) {

        require(value <= type(uint16).max, "SafeCast: value doesn't fit in 16 bits");

        return uint16(value);

    }



    /**

     * @dev Returns the downcasted uint8 from uint256, reverting on

     * overflow (when the input is greater than largest uint8).

     *

     * Counterpart to Solidity's `uint8` operator.

     *

     * Requirements:

     *

     * - input must fit into 8 bits

     *

     * _Available since v2.5._

     */

    function toUint8(uint256 value) internal pure returns (uint8) {

        require(value <= type(uint8).max, "SafeCast: value doesn't fit in 8 bits");

        return uint8(value);

    }



    /**

     * @dev Converts a signed int256 into an unsigned uint256.

     *

     * Requirements:

     *

     * - input must be greater than or equal to 0.

     *

     * _Available since v3.0._

     */

    function toUint256(int256 value) internal pure returns (uint256) {

        require(value >= 0, "SafeCast: value must be positive");

        return uint256(value);

    }



    /**

     * @dev Returns the downcasted int248 from int256, reverting on

     * overflow (when the input is less than smallest int248 or

     * greater than largest int248).

     *

     * Counterpart to Solidity's `int248` operator.

     *

     * Requirements:

     *

     * - input must fit into 248 bits

     *

     * _Available since v4.7._

     */

    function toInt248(int256 value) internal pure returns (int248 downcasted) {

        downcasted = int248(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 248 bits");

    }



    /**

     * @dev Returns the downcasted int240 from int256, reverting on

     * overflow (when the input is less than smallest int240 or

     * greater than largest int240).

     *

     * Counterpart to Solidity's `int240` operator.

     *

     * Requirements:

     *

     * - input must fit into 240 bits

     *

     * _Available since v4.7._

     */

    function toInt240(int256 value) internal pure returns (int240 downcasted) {

        downcasted = int240(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 240 bits");

    }



    /**

     * @dev Returns the downcasted int232 from int256, reverting on

     * overflow (when the input is less than smallest int232 or

     * greater than largest int232).

     *

     * Counterpart to Solidity's `int232` operator.

     *

     * Requirements:

     *

     * - input must fit into 232 bits

     *

     * _Available since v4.7._

     */

    function toInt232(int256 value) internal pure returns (int232 downcasted) {

        downcasted = int232(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 232 bits");

    }



    /**

     * @dev Returns the downcasted int224 from int256, reverting on

     * overflow (when the input is less than smallest int224 or

     * greater than largest int224).

     *

     * Counterpart to Solidity's `int224` operator.

     *

     * Requirements:

     *

     * - input must fit into 224 bits

     *

     * _Available since v4.7._

     */

    function toInt224(int256 value) internal pure returns (int224 downcasted) {

        downcasted = int224(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 224 bits");

    }



    /**

     * @dev Returns the downcasted int216 from int256, reverting on

     * overflow (when the input is less than smallest int216 or

     * greater than largest int216).

     *

     * Counterpart to Solidity's `int216` operator.

     *

     * Requirements:

     *

     * - input must fit into 216 bits

     *

     * _Available since v4.7._

     */

    function toInt216(int256 value) internal pure returns (int216 downcasted) {

        downcasted = int216(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 216 bits");

    }



    /**

     * @dev Returns the downcasted int208 from int256, reverting on

     * overflow (when the input is less than smallest int208 or

     * greater than largest int208).

     *

     * Counterpart to Solidity's `int208` operator.

     *

     * Requirements:

     *

     * - input must fit into 208 bits

     *

     * _Available since v4.7._

     */

    function toInt208(int256 value) internal pure returns (int208 downcasted) {

        downcasted = int208(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 208 bits");

    }



    /**

     * @dev Returns the downcasted int200 from int256, reverting on

     * overflow (when the input is less than smallest int200 or

     * greater than largest int200).

     *

     * Counterpart to Solidity's `int200` operator.

     *

     * Requirements:

     *

     * - input must fit into 200 bits

     *

     * _Available since v4.7._

     */

    function toInt200(int256 value) internal pure returns (int200 downcasted) {

        downcasted = int200(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 200 bits");

    }



    /**

     * @dev Returns the downcasted int192 from int256, reverting on

     * overflow (when the input is less than smallest int192 or

     * greater than largest int192).

     *

     * Counterpart to Solidity's `int192` operator.

     *

     * Requirements:

     *

     * - input must fit into 192 bits

     *

     * _Available since v4.7._

     */

    function toInt192(int256 value) internal pure returns (int192 downcasted) {

        downcasted = int192(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 192 bits");

    }



    /**

     * @dev Returns the downcasted int184 from int256, reverting on

     * overflow (when the input is less than smallest int184 or

     * greater than largest int184).

     *

     * Counterpart to Solidity's `int184` operator.

     *

     * Requirements:

     *

     * - input must fit into 184 bits

     *

     * _Available since v4.7._

     */

    function toInt184(int256 value) internal pure returns (int184 downcasted) {

        downcasted = int184(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 184 bits");

    }



    /**

     * @dev Returns the downcasted int176 from int256, reverting on

     * overflow (when the input is less than smallest int176 or

     * greater than largest int176).

     *

     * Counterpart to Solidity's `int176` operator.

     *

     * Requirements:

     *

     * - input must fit into 176 bits

     *

     * _Available since v4.7._

     */

    function toInt176(int256 value) internal pure returns (int176 downcasted) {

        downcasted = int176(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 176 bits");

    }



    /**

     * @dev Returns the downcasted int168 from int256, reverting on

     * overflow (when the input is less than smallest int168 or

     * greater than largest int168).

     *

     * Counterpart to Solidity's `int168` operator.

     *

     * Requirements:

     *

     * - input must fit into 168 bits

     *

     * _Available since v4.7._

     */

    function toInt168(int256 value) internal pure returns (int168 downcasted) {

        downcasted = int168(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 168 bits");

    }



    /**

     * @dev Returns the downcasted int160 from int256, reverting on

     * overflow (when the input is less than smallest int160 or

     * greater than largest int160).

     *

     * Counterpart to Solidity's `int160` operator.

     *

     * Requirements:

     *

     * - input must fit into 160 bits

     *

     * _Available since v4.7._

     */

    function toInt160(int256 value) internal pure returns (int160 downcasted) {

        downcasted = int160(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 160 bits");

    }



    /**

     * @dev Returns the downcasted int152 from int256, reverting on

     * overflow (when the input is less than smallest int152 or

     * greater than largest int152).

     *

     * Counterpart to Solidity's `int152` operator.

     *

     * Requirements:

     *

     * - input must fit into 152 bits

     *

     * _Available since v4.7._

     */

    function toInt152(int256 value) internal pure returns (int152 downcasted) {

        downcasted = int152(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 152 bits");

    }



    /**

     * @dev Returns the downcasted int144 from int256, reverting on

     * overflow (when the input is less than smallest int144 or

     * greater than largest int144).

     *

     * Counterpart to Solidity's `int144` operator.

     *

     * Requirements:

     *

     * - input must fit into 144 bits

     *

     * _Available since v4.7._

     */

    function toInt144(int256 value) internal pure returns (int144 downcasted) {

        downcasted = int144(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 144 bits");

    }



    /**

     * @dev Returns the downcasted int136 from int256, reverting on

     * overflow (when the input is less than smallest int136 or

     * greater than largest int136).

     *

     * Counterpart to Solidity's `int136` operator.

     *

     * Requirements:

     *

     * - input must fit into 136 bits

     *

     * _Available since v4.7._

     */

    function toInt136(int256 value) internal pure returns (int136 downcasted) {

        downcasted = int136(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 136 bits");

    }



    /**

     * @dev Returns the downcasted int128 from int256, reverting on

     * overflow (when the input is less than smallest int128 or

     * greater than largest int128).

     *

     * Counterpart to Solidity's `int128` operator.

     *

     * Requirements:

     *

     * - input must fit into 128 bits

     *

     * _Available since v3.1._

     */

    function toInt128(int256 value) internal pure returns (int128 downcasted) {

        downcasted = int128(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 128 bits");

    }



    /**

     * @dev Returns the downcasted int120 from int256, reverting on

     * overflow (when the input is less than smallest int120 or

     * greater than largest int120).

     *

     * Counterpart to Solidity's `int120` operator.

     *

     * Requirements:

     *

     * - input must fit into 120 bits

     *

     * _Available since v4.7._

     */

    function toInt120(int256 value) internal pure returns (int120 downcasted) {

        downcasted = int120(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 120 bits");

    }



    /**

     * @dev Returns the downcasted int112 from int256, reverting on

     * overflow (when the input is less than smallest int112 or

     * greater than largest int112).

     *

     * Counterpart to Solidity's `int112` operator.

     *

     * Requirements:

     *

     * - input must fit into 112 bits

     *

     * _Available since v4.7._

     */

    function toInt112(int256 value) internal pure returns (int112 downcasted) {

        downcasted = int112(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 112 bits");

    }



    /**

     * @dev Returns the downcasted int104 from int256, reverting on

     * overflow (when the input is less than smallest int104 or

     * greater than largest int104).

     *

     * Counterpart to Solidity's `int104` operator.

     *

     * Requirements:

     *

     * - input must fit into 104 bits

     *

     * _Available since v4.7._

     */

    function toInt104(int256 value) internal pure returns (int104 downcasted) {

        downcasted = int104(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 104 bits");

    }



    /**

     * @dev Returns the downcasted int96 from int256, reverting on

     * overflow (when the input is less than smallest int96 or

     * greater than largest int96).

     *

     * Counterpart to Solidity's `int96` operator.

     *

     * Requirements:

     *

     * - input must fit into 96 bits

     *

     * _Available since v4.7._

     */

    function toInt96(int256 value) internal pure returns (int96 downcasted) {

        downcasted = int96(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 96 bits");

    }



    /**

     * @dev Returns the downcasted int88 from int256, reverting on

     * overflow (when the input is less than smallest int88 or

     * greater than largest int88).

     *

     * Counterpart to Solidity's `int88` operator.

     *

     * Requirements:

     *

     * - input must fit into 88 bits

     *

     * _Available since v4.7._

     */

    function toInt88(int256 value) internal pure returns (int88 downcasted) {

        downcasted = int88(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 88 bits");

    }



    /**

     * @dev Returns the downcasted int80 from int256, reverting on

     * overflow (when the input is less than smallest int80 or

     * greater than largest int80).

     *

     * Counterpart to Solidity's `int80` operator.

     *

     * Requirements:

     *

     * - input must fit into 80 bits

     *

     * _Available since v4.7._

     */

    function toInt80(int256 value) internal pure returns (int80 downcasted) {

        downcasted = int80(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 80 bits");

    }



    /**

     * @dev Returns the downcasted int72 from int256, reverting on

     * overflow (when the input is less than smallest int72 or

     * greater than largest int72).

     *

     * Counterpart to Solidity's `int72` operator.

     *

     * Requirements:

     *

     * - input must fit into 72 bits

     *

     * _Available since v4.7._

     */

    function toInt72(int256 value) internal pure returns (int72 downcasted) {

        downcasted = int72(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 72 bits");

    }



    /**

     * @dev Returns the downcasted int64 from int256, reverting on

     * overflow (when the input is less than smallest int64 or

     * greater than largest int64).

     *

     * Counterpart to Solidity's `int64` operator.

     *

     * Requirements:

     *

     * - input must fit into 64 bits

     *

     * _Available since v3.1._

     */

    function toInt64(int256 value) internal pure returns (int64 downcasted) {

        downcasted = int64(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 64 bits");

    }



    /**

     * @dev Returns the downcasted int56 from int256, reverting on

     * overflow (when the input is less than smallest int56 or

     * greater than largest int56).

     *

     * Counterpart to Solidity's `int56` operator.

     *

     * Requirements:

     *

     * - input must fit into 56 bits

     *

     * _Available since v4.7._

     */

    function toInt56(int256 value) internal pure returns (int56 downcasted) {

        downcasted = int56(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 56 bits");

    }



    /**

     * @dev Returns the downcasted int48 from int256, reverting on

     * overflow (when the input is less than smallest int48 or

     * greater than largest int48).

     *

     * Counterpart to Solidity's `int48` operator.

     *

     * Requirements:

     *

     * - input must fit into 48 bits

     *

     * _Available since v4.7._

     */

    function toInt48(int256 value) internal pure returns (int48 downcasted) {

        downcasted = int48(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 48 bits");

    }



    /**

     * @dev Returns the downcasted int40 from int256, reverting on

     * overflow (when the input is less than smallest int40 or

     * greater than largest int40).

     *

     * Counterpart to Solidity's `int40` operator.

     *

     * Requirements:

     *

     * - input must fit into 40 bits

     *

     * _Available since v4.7._

     */

    function toInt40(int256 value) internal pure returns (int40 downcasted) {

        downcasted = int40(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 40 bits");

    }



    /**

     * @dev Returns the downcasted int32 from int256, reverting on

     * overflow (when the input is less than smallest int32 or

     * greater than largest int32).

     *

     * Counterpart to Solidity's `int32` operator.

     *

     * Requirements:

     *

     * - input must fit into 32 bits

     *

     * _Available since v3.1._

     */

    function toInt32(int256 value) internal pure returns (int32 downcasted) {

        downcasted = int32(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 32 bits");

    }



    /**

     * @dev Returns the downcasted int24 from int256, reverting on

     * overflow (when the input is less than smallest int24 or

     * greater than largest int24).

     *

     * Counterpart to Solidity's `int24` operator.

     *

     * Requirements:

     *

     * - input must fit into 24 bits

     *

     * _Available since v4.7._

     */

    function toInt24(int256 value) internal pure returns (int24 downcasted) {

        downcasted = int24(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 24 bits");

    }



    /**

     * @dev Returns the downcasted int16 from int256, reverting on

     * overflow (when the input is less than smallest int16 or

     * greater than largest int16).

     *

     * Counterpart to Solidity's `int16` operator.

     *

     * Requirements:

     *

     * - input must fit into 16 bits

     *

     * _Available since v3.1._

     */

    function toInt16(int256 value) internal pure returns (int16 downcasted) {

        downcasted = int16(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 16 bits");

    }



    /**

     * @dev Returns the downcasted int8 from int256, reverting on

     * overflow (when the input is less than smallest int8 or

     * greater than largest int8).

     *

     * Counterpart to Solidity's `int8` operator.

     *

     * Requirements:

     *

     * - input must fit into 8 bits

     *

     * _Available since v3.1._

     */

    function toInt8(int256 value) internal pure returns (int8 downcasted) {

        downcasted = int8(value);

        require(downcasted == value, "SafeCast: value doesn't fit in 8 bits");

    }



    /**

     * @dev Converts an unsigned uint256 into a signed int256.

     *

     * Requirements:

     *

     * - input must be less than or equal to maxInt256.

     *

     * _Available since v3.0._

     */

    function toInt256(uint256 value) internal pure returns (int256) {

        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive

        require(value <= uint256(type(int256).max), "SafeCast: value doesn't fit in an int256");

        return int256(value);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)



pragma solidity ^0.8.0;



import "../IERC20.sol";

import "../extensions/draft-IERC20Permit.sol";

import "../../../utils/Address.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender) + value;

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        unchecked {

            uint256 oldAllowance = token.allowance(address(this), spender);

            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");

            uint256 newAllowance = oldAllowance - value;

            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

        }

    }



    function safePermit(

        IERC20Permit token,

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal {

        uint256 nonceBefore = token.nonces(owner);

        token.permit(owner, spender, value, deadline, v, r, s);

        uint256 nonceAfter = token.nonces(owner);

        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {

            // Return data is optional

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\SafeMath.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: MIT OR Apache-2.0







/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "14");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "v");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "15");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "x");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "y");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\SafeMathUInt128.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: MIT OR Apache-2.0







/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMathUInt128 {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint128 a, uint128 b) internal pure returns (uint128) {

        uint128 c = a + b;

        require(c >= a, "12");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint128 a, uint128 b) internal pure returns (uint128) {

        return sub(a, b, "aa");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(

        uint128 a,

        uint128 b,

        string memory errorMessage

    ) internal pure returns (uint128) {

        require(b <= a, errorMessage);

        uint128 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint128 a, uint128 b) internal pure returns (uint128) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint128 c = a * b;

        require(c / a == b, "13");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint128 a, uint128 b) internal pure returns (uint128) {

        return div(a, b, "ac");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(

        uint128 a,

        uint128 b,

        string memory errorMessage

    ) internal pure returns (uint128) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, errorMessage);

        uint128 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint128 a, uint128 b) internal pure returns (uint128) {

        return mod(a, b, "ad");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(

        uint128 a,

        uint128 b,

        string memory errorMessage

    ) internal pure returns (uint128) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Storage.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "./Verifier.sol";

import "../common/interfaces/IAllowList.sol";

import "./libraries/PriorityQueue.sol";



/// @notice Indicates whether an upgrade is initiated and if yes what type

/// @param None Upgrade is NOT initiated

/// @param Transparent Fully transparent upgrade is initiated, upgrade data is publicly known

/// @param Shadow Shadow upgrade is initiated, upgrade data is hidden

enum UpgradeState {

    None,

    Transparent,

    Shadow

}



/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy upgrades and diamond cuts

/// @param proposedUpgradeHash The hash of the current upgrade proposal, zero if there is no active proposal

/// @param state Indicates whether an upgrade is initiated and if yes what type

/// @param securityCouncil Address which has the permission to approve instant upgrades (expected to be a Gnosis multisig)

/// @param approvedBySecurityCouncil Indicates whether the security council has approved the upgrade

/// @param proposedUpgradeTimestamp The timestamp when the upgrade was proposed, zero if there are no active proposals

/// @param currentProposalId The serial number of proposed upgrades, increments when proposing a new one

struct UpgradeStorage {

    bytes32 proposedUpgradeHash;

    UpgradeState state;

    address securityCouncil;

    bool approvedBySecurityCouncil;

    uint40 proposedUpgradeTimestamp;

    uint40 currentProposalId;

}



/// @dev The log passed from L2

/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter. All other values are not used but are reserved for the future

/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.

/// This field is required formally but does not have any special meaning.

/// @param txNumberInBlock The L2 transaction number in a block, in which the log was sent

/// @param sender The L2 address which sent the log

/// @param key The 32 bytes of information that was sent in the log

/// @param value The 32 bytes of information that was sent in the log

// Both `key` and `value` are arbitrary 32-bytes selected by the log sender

struct L2Log {

    uint8 l2ShardId;

    bool isService;

    uint16 txNumberInBlock;

    address sender;

    bytes32 key;

    bytes32 value;

}



/// @dev An arbitrary length message passed from L2

/// @notice Under the hood it is `L2Log` sent from the special system L2 contract

/// @param txNumberInBlock The L2 transaction number in a block, in which the message was sent

/// @param sender The address of the L2 account from which the message was passed

/// @param data An arbitrary length message

struct L2Message {

    uint16 txNumberInBlock;

    address sender;

    bytes data;

}



/// @notice Part of the configuration parameters of ZKP circuits

struct VerifierParams {

    bytes32 recursionNodeLevelVkHash;

    bytes32 recursionLeafLevelVkHash;

    bytes32 recursionCircuitsSetVksHash;

}



/// @dev storing all storage variables for zkSync facets

/// NOTE: It is used in a proxy, so it is possible to add new variables to the end

/// NOTE: but NOT to modify already existing variables or change their order

/// NOTE: DiamondCutStorage is unused, but it must remain a member of AppStorage to not have storage collision

/// NOTE: instead UpgradeStorage is used that is appended to the end of the AppStorage struct

struct AppStorage {

    /// @dev Storage of variables needed for deprecated diamond cut facet

    uint256[7] __DEPRECATED_diamondCutStorage;

    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades

    address governor;

    /// @notice Address that the governor proposed as one that will replace it

    address pendingGovernor;

    /// @notice List of permitted validators

    mapping(address => bool) validators;

    /// @dev Verifier contract. Used to verify aggregated proof for blocks

    Verifier verifier;

    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)

    uint256 totalBlocksExecuted;

    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block

    uint256 totalBlocksVerified;

    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block

    uint256 totalBlocksCommitted;

    /// @dev Stored hashed StoredBlock for block number

    mapping(uint256 => bytes32) storedBlockHashes;

    /// @dev Stored root hashes of L2 -> L1 logs

    mapping(uint256 => bytes32) l2LogsRootHashes;

    /// @dev Container that stores transactions requested from L1

    PriorityQueue.Queue priorityQueue;

    /// @dev The smart contract that manages the list with permission to call contract functions

    IAllowList allowList;

    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract

    VerifierParams verifierParams;

    /// @notice Bytecode hash of bootloader program.

    /// @dev Used as an input to zkp-circuit.

    bytes32 l2BootloaderBytecodeHash;

    /// @notice Bytecode hash of default account (bytecode for EOA).

    /// @dev Used as an input to zkp-circuit.

    bytes32 l2DefaultAccountBytecodeHash;

    /// @dev Indicates that the porter may be touched on L2 transactions.

    /// @dev Used as an input to zkp-circuit.

    bool zkPorterIsAvailable;

    /// @dev The maximum number of the L2 gas that a user can request for L1 -> L2 transactions

    /// @dev This is the maximum number of L2 gas that is available for the "body" of the transaction, i.e.

    /// without overhead for proving the block.

    uint256 priorityTxMaxGasLimit;

    /// @dev Storage of variables needed for upgrade facet

    UpgradeStorage upgrades;

    /// @dev A mapping L2 block number => message number => flag.

    /// @dev The L2 -> L1 log is sent for every withdrawal, so this mapping is serving as

    /// a flag to indicate that the message was already processed.

    /// @dev Used to indicate that eth withdrawal was already processed

    mapping(uint256 => mapping(uint256 => bool)) isEthWithdrawalFinalized;

    /// @dev The most recent withdrawal time and amount reset

    uint256 __DEPRECATED_lastWithdrawalLimitReset;

    /// @dev The accumulated withdrawn amount during the withdrawal limit window

    uint256 __DEPRECATED_withdrawnAmountInWindow;

    /// @dev A mapping user address => the total deposited amount by the user

    mapping(address => uint256) totalDepositedAmountPerUser;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\StorageSlot.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)



pragma solidity ^0.8.0;



/**

 * @dev Library for reading and writing primitive types to specific storage slots.

 *

 * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.

 * This library helps with reading and writing to such slots without the need for inline assembly.

 *

 * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.

 *

 * Example usage to set ERC1967 implementation slot:

 * ```

 * contract ERC1967 {

 *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

 *

 *     function _getImplementation() internal view returns (address) {

 *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

 *     }

 *

 *     function _setImplementation(address newImplementation) internal {

 *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

 *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

 *     }

 * }

 * ```

 *

 * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._

 */

library StorageSlot {

    struct AddressSlot {

        address value;

    }



    struct BooleanSlot {

        bool value;

    }



    struct Bytes32Slot {

        bytes32 value;

    }



    struct Uint256Slot {

        uint256 value;

    }



    /**

     * @dev Returns an `AddressSlot` with member `value` located at `slot`.

     */

    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {

        /// @solidity memory-safe-assembly

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.

     */

    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {

        /// @solidity memory-safe-assembly

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.

     */

    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {

        /// @solidity memory-safe-assembly

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.

     */

    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {

        /// @solidity memory-safe-assembly

        assembly {

            r.slot := slot

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\StringsUpgradeable.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)



pragma solidity ^0.8.0;



import "./math/MathUpgradeable.sol";



/**

 * @dev String operations.

 */

library StringsUpgradeable {

    bytes16 private constant _SYMBOLS = "0123456789abcdef";

    uint8 private constant _ADDRESS_LENGTH = 20;



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        unchecked {

            uint256 length = MathUpgradeable.log10(value) + 1;

            string memory buffer = new string(length);

            uint256 ptr;

            /// @solidity memory-safe-assembly

            assembly {

                ptr := add(buffer, add(32, length))

            }

            while (true) {

                ptr--;

                /// @solidity memory-safe-assembly

                assembly {

                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))

                }

                value /= 10;

                if (value == 0) break;

            }

            return buffer;

        }

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        unchecked {

            return toHexString(value, MathUpgradeable.log256(value) + 1);

        }

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }



    /**

     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.

     */

    function toHexString(address addr) internal pure returns (string memory) {

        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\TokenGovernance.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: MIT OR Apache-2.0







import "./ReentrancyGuard.sol";

import "./Governance.sol";

import "./ITrustedTransfarableERC20.sol";

import "./Utils.sol";



/// @title Token Governance Contract

/// @author Matter Labs

/// @notice Contract is used to allow anyone to add new ERC20 tokens to zkSync given sufficient payment

contract TokenGovernance is ReentrancyGuard {

    /// @notice Token lister added or removed (see `tokenLister`)

    event TokenListerUpdate(address indexed tokenLister, bool isActive);



    /// @notice Listing fee token set

    event ListingFeeTokenUpdate(ITrustedTransfarableERC20 indexed newListingFeeToken, uint256 newListingFee);



    /// @notice Listing fee set

    event ListingFeeUpdate(uint256 newListingFee);



    /// @notice Maximum number of listed tokens updated

    event ListingCapUpdate(uint16 newListingCap);



    /// @notice The treasury (the account which will receive the fee) was updated

    event TreasuryUpdate(address newTreasury);



    /// @notice zkSync governance contract

    Governance public governance;



    /// @notice Token used to collect listing fee for addition of new token to zkSync network

    ITrustedTransfarableERC20 public listingFeeToken;



    /// @notice Token listing fee

    uint256 public listingFee;



    /// @notice Max number of tokens that can be listed using this contract

    uint16 public listingCap;



    /// @notice Addresses that can list tokens without fee

    mapping(address => bool) public tokenLister;



    /// @notice Address that collects listing payments

    address public treasury;



    constructor(

        Governance _governance,

        ITrustedTransfarableERC20 _listingFeeToken,

        uint256 _listingFee,

        uint16 _listingCap,

        address _treasury

    ) {

        initializeReentrancyGuard();



        governance = _governance;

        listingFeeToken = _listingFeeToken;

        listingFee = _listingFee;

        listingCap = _listingCap;

        treasury = _treasury;



        address governor = governance.networkGovernor();

        // We add zkSync governor as a first token lister.

        tokenLister[governor] = true;

        emit TokenListerUpdate(governor, true);

    }



    /// @notice Adds new ERC20 token to zkSync network.

    /// @notice If caller is not present in the `tokenLister` map payment of `listingFee` in `listingFeeToken` should be made.

    /// @notice NOTE: before calling this function make sure to approve `listingFeeToken` transfer for this contract.

    function addToken(address _token) external nonReentrant {

        require(_token != address(0), "z1"); // Token should have a non-zero address

        require(_token != 0xaBEA9132b05A70803a4E85094fD0e1800777fBEF, "z2"); // Address of the token cannot be the same as the address of the main zksync contract

        require(governance.totalTokens() < listingCap, "can't add more tokens"); // Impossible to add more tokens using this contract

        if (!tokenLister[msg.sender] && listingFee > 0) {

            // Collect fees

            bool feeTransferOk = listingFeeToken.transferFrom(msg.sender, treasury, listingFee);

            require(feeTransferOk, "fee transfer failed"); // Failed to receive payment for token addition.

        }

        governance.addToken(_token);

    }



    /// Governance functions (this contract is governed by zkSync governor)



    /// @notice Set new listing token and fee

    /// @notice Can be called only by zkSync governor

    function setListingFeeToken(ITrustedTransfarableERC20 _newListingFeeToken, uint256 _newListingFee) external {

        governance.requireGovernor(msg.sender);

        listingFeeToken = _newListingFeeToken;

        listingFee = _newListingFee;



        emit ListingFeeTokenUpdate(_newListingFeeToken, _newListingFee);

    }



    /// @notice Set new listing fee

    /// @notice Can be called only by zkSync governor

    function setListingFee(uint256 _newListingFee) external {

        governance.requireGovernor(msg.sender);

        listingFee = _newListingFee;



        emit ListingFeeUpdate(_newListingFee);

    }



    /// @notice Enable or disable token lister. If enabled new tokens can be added by that address without payment

    /// @notice Can be called only by zkSync governor

    function setLister(address _listerAddress, bool _active) external {

        governance.requireGovernor(msg.sender);

        if (tokenLister[_listerAddress] != _active) {

            tokenLister[_listerAddress] = _active;

            emit TokenListerUpdate(_listerAddress, _active);

        }

    }



    /// @notice Change maximum amount of tokens that can be listed using this method

    /// @notice Can be called only by zkSync governor

    function setListingCap(uint16 _newListingCap) external {

        governance.requireGovernor(msg.sender);

        listingCap = _newListingCap;



        emit ListingCapUpdate(_newListingCap);

    }



    /// @notice Change address that collects payments for listing tokens.

    /// @notice Can be called only by zkSync governor

    function setTreasury(address _newTreasury) external {

        governance.requireGovernor(msg.sender);

        treasury = _newTreasury;



        emit TreasuryUpdate(_newTreasury);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\TranscriptLib.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "./PairingsBn254.sol";



library TranscriptLib {

    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;

    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;



    uint32 constant DST_0 = 0;

    uint32 constant DST_1 = 1;

    uint32 constant DST_CHALLENGE = 2;



    struct Transcript {

        bytes32 state_0;

        bytes32 state_1;

        uint32 challenge_counter;

    }



    function new_transcript() internal pure returns (Transcript memory t) {

        t.state_0 = bytes32(0);

        t.state_1 = bytes32(0);

        t.challenge_counter = 0;

    }



    function update_with_u256(Transcript memory self, uint256 value) internal pure {

        bytes32 old_state_0 = self.state_0;

        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));

        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));

    }



    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {

        update_with_u256(self, value.value);

    }



    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {

        update_with_u256(self, p.X);

        update_with_u256(self, p.Y);

    }



    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {

        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));

        self.challenge_counter += 1;

        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\TransparentUpgradeableProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)



pragma solidity ^0.8.0;



import "../ERC1967/ERC1967Proxy.sol";



/**

 * @dev This contract implements a proxy that is upgradeable by an admin.

 *

 * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector

 * clashing], which can potentially be used in an attack, this contract uses the

 * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two

 * things that go hand in hand:

 *

 * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if

 * that call matches one of the admin functions exposed by the proxy itself.

 * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the

 * implementation. If the admin tries to call a function on the implementation it will fail with an error that says

 * "admin cannot fallback to proxy target".

 *

 * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing

 * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due

 * to sudden errors when trying to call a function from the proxy implementation.

 *

 * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,

 * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.

 */

contract TransparentUpgradeableProxy is ERC1967Proxy {

    /**

     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and

     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.

     */

    constructor(

        address _logic,

        address admin_,

        bytes memory _data

    ) payable ERC1967Proxy(_logic, _data) {

        _changeAdmin(admin_);

    }



    /**

     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.

     */

    modifier ifAdmin() {

        if (msg.sender == _getAdmin()) {

            _;

        } else {

            _fallback();

        }

    }



    /**

     * @dev Returns the current admin.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.

     *

     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the

     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.

     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`

     */

    function admin() external ifAdmin returns (address admin_) {

        admin_ = _getAdmin();

    }



    /**

     * @dev Returns the current implementation.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.

     *

     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the

     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.

     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`

     */

    function implementation() external ifAdmin returns (address implementation_) {

        implementation_ = _implementation();

    }



    /**

     * @dev Changes the admin of the proxy.

     *

     * Emits an {AdminChanged} event.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.

     */

    function changeAdmin(address newAdmin) external virtual ifAdmin {

        _changeAdmin(newAdmin);

    }



    /**

     * @dev Upgrade the implementation of the proxy.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.

     */

    function upgradeTo(address newImplementation) external ifAdmin {

        _upgradeToAndCall(newImplementation, bytes(""), false);

    }



    /**

     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified

     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the

     * proxied contract.

     *

     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.

     */

    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {

        _upgradeToAndCall(newImplementation, data, true);

    }



    /**

     * @dev Returns the current admin.

     */

    function _admin() internal view virtual returns (address) {

        return _getAdmin();

    }



    /**

     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.

     */

    function _beforeFallback() internal virtual override {

        require(msg.sender != _getAdmin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target");

        super._beforeFallback();

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\UncheckedMath.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







library UncheckedMath {

    function uncheckedInc(uint256 _number) internal pure returns (uint256) {

        unchecked {

            return _number + 1;

        }

    }



    function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {

        unchecked {

            return _lhs + _rhs;

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\UnsafeBytes.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







/**

 * @author Matter Labs

 * @dev The library provides a set of functions that help read data from an "abi.encodePacked" byte array.

 * @dev Each of the functions accepts the `bytes memory` and the offset where data should be read and returns a value of a certain type.

 *

 * @dev WARNING!

 * 1) Functions don't check the length of the bytes array, so it can go out of bounds.

 * The user of the library must check for bytes length before using any functions from the library!

 *

 * 2) Read variables are not cleaned up - https://docs.soliditylang.org/en/v0.8.16/internals/variable_cleanup.html.

 * Using data in inline assembly can lead to unexpected behavior!

 */

library UnsafeBytes {

    function readUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 result, uint256 offset) {

        assembly {

            offset := add(_start, 4)

            result := mload(add(_bytes, offset))

        }

    }



    function readAddress(bytes memory _bytes, uint256 _start) internal pure returns (address result, uint256 offset) {

        assembly {

            offset := add(_start, 20)

            result := mload(add(_bytes, offset))

        }

    }



    function readUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256 result, uint256 offset) {

        assembly {

            offset := add(_start, 32)

            result := mload(add(_bytes, offset))

        }

    }



    function readBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 result, uint256 offset) {

        assembly {

            offset := add(_start, 32)

            result := mload(add(_bytes, offset))

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Upgradeable.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: MIT OR Apache-2.0







/// @title Interface of the upgradeable contract

/// @author Matter Labs

interface Upgradeable {

    /// @notice Upgrades target of upgradeable contract

    /// @param newTarget New target

    /// @param newTargetInitializationParameters New target initialization parameters

    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\UpgradeableMaster.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: MIT OR Apache-2.0







/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)

/// @author Matter Labs

interface UpgradeableMaster {

    /// @notice Notice period before activation preparation status of upgrade mode

    function getNoticePeriod() external returns (uint256);



    /// @notice Notifies contract that notice period started

    function upgradeNoticePeriodStarted() external;



    /// @notice Notifies contract that upgrade preparation status is activated

    function upgradePreparationStarted() external;



    /// @notice Notifies contract that upgrade canceled

    function upgradeCanceled() external;



    /// @notice Notifies contract that upgrade finishes

    function upgradeFinishes() external;



    /// @notice Checks that contract is ready for upgrade

    /// @return bool flag indicating that contract is ready for upgrade

    function isReadyForUpgrade() external returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Utils.sol
File type: .sol
pragma solidity ^0.7.0;



// SPDX-License-Identifier: MIT OR Apache-2.0







import "./IERC20.sol";

import "./Bytes.sol";



library Utils {

    /// @notice Returns lesser of two values

    function minU32(uint32 a, uint32 b) internal pure returns (uint32) {

        return a < b ? a : b;

    }



    /// @notice Returns lesser of two values

    function minU64(uint64 a, uint64 b) internal pure returns (uint64) {

        return a < b ? a : b;

    }



    /// @notice Returns lesser of two values

    function minU128(uint128 a, uint128 b) internal pure returns (uint128) {

        return a < b ? a : b;

    }



    /// @notice Recovers signer's address from ethereum signature for given message

    /// @param _signature 65 bytes concatenated. R (32) + S (32) + V (1)

    /// @param _messageHash signed message hash.

    /// @return address of the signer

    /// NOTE: will revert if signature is invalid

    function recoverAddressFromEthSignature(bytes memory _signature, bytes32 _messageHash)

        internal

        pure

        returns (address)

    {

        require(_signature.length == 65, "P"); // incorrect signature length



        bytes32 signR;

        bytes32 signS;

        uint8 signV;

        assembly {

            signR := mload(add(_signature, 32))

            signS := mload(add(_signature, 64))

            signV := byte(0, mload(add(_signature, 96)))

        }



        address recoveredAddress = ecrecover(_messageHash, signV, signR, signS);

        require(recoveredAddress != address(0), "p4"); // invalid signature



        return recoveredAddress;

    }



    /// @notice Returns new_hash = hash(old_hash + bytes)

    function concatHash(bytes32 _hash, bytes memory _bytes) internal pure returns (bytes32) {

        bytes32 result;

        assembly {

            let bytesLen := add(mload(_bytes), 32)

            mstore(_bytes, _hash)

            result := keccak256(_bytes, bytesLen)

        }

        return result;

    }



    function hashBytesToBytes20(bytes memory _bytes) internal pure returns (bytes20) {

        return bytes20(uint160(uint256(keccak256(_bytes))));

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\Verifier.sol
File type: .sol
pragma solidity ^0.8.13;



// SPDX-License-Identifier: MIT







import "./Plonk4VerifierWithAccessToDNext.sol";

import "../common/libraries/UncheckedMath.sol";



contract Verifier is Plonk4VerifierWithAccessToDNext {

    using UncheckedMath for uint256;



    function get_verification_key() public pure returns (VerificationKey memory vk) {

        vk.num_inputs = 1;

        vk.domain_size = 67108864;

        vk.omega = PairingsBn254.new_fr(0x1dba8b5bdd64ef6ce29a9039aca3c0e524395c43b9227b96c75090cc6cc7ec97);

        // coefficients

        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(

            0x14c289d746e37aa82ec428491881c4732766492a8bc2e8e3cca2000a40c0ea27,

            0x2f617a7eb9808ad9843d1e080b7cfbf99d61bb1b02076c905f31adb12731bc41

        );

        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(

            0x210b5cc8e6a85d63b65b701b8fb5ad24ff9c41f923432de17fe4ebae04526a8c,

            0x05c10ab17ea731b2b87fb890fa5b10bd3d6832917a616b807a9b640888ebc731

        );

        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(

            0x29d4d14adcfe67a2ac690d6369db6b75e82d8ab3124bc4fa1dd145f41ca6949c,

            0x004f6cd229373f1c1f735ccf49aef6a5c32025bc36c3328596dd0db7d87bef67

        );

        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(

            0x06d15382e8cabae9f98374a9fbdadd424f48e24da7e4c65bf710fd7d7d59a05a,

            0x22e438ad5c51673879ce17073a3d2d29327a97dc3ce61c4f88540e00087695f6

        );

        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(

            0x274a668dfc485cf192d0086f214146d9e02b3040a5a586df344c53c16a87882b,

            0x15f5bb7ad01f162b70fc77c8ea456d67d15a6ce98acbbfd521222810f8ec0a66

        );

        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(

            0x0ba53bf4fb0446927857e33978d02abf45948fc68f4091394ae0827a22cf1e47,

            0x0720d818751ce5b3f11c716e925f60df4679ea90bed516499bdec066f5ff108f

        );

        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(

            0x2e986ba2ea495e5ec6af532980b1dc567f1430bfa82f8de07c12fc097c0e0483,

            0x1555d189f6164e82d78de1b8313c2e923e616b3c8ed0e350c3b61c94516d0b58

        );

        vk.gate_setup_commitments[7] = PairingsBn254.new_g1(

            0x0925959592604ca73c917f9b2e029aa2563c318ddcc5ca29c11badb7b880127b,

            0x2b4a430fcb2fa7d6d67d6c358e01cf0524c7df7e1e56442f65b39bc1a1052367

        );

        // gate selectors

        vk.gate_selectors_commitments[0] = PairingsBn254.new_g1(

            0x28f2a0a95af79ba67e9dd1986bd3190199f661b710a693fc82fb395c126edcbd,

            0x0db75db5de5192d1ba1c24710fc00da16fa8029ac7fe82d855674dcd6d090e05

        );

        vk.gate_selectors_commitments[1] = PairingsBn254.new_g1(

            0x143471a174dfcb2d9cb5ae621e519387bcc93c9dcfc011160b2f5c5f88e32cbe,

            0x2a0194c0224c3d964223a96c4c99e015719bc879125aa0df3f0715d154e71a31

        );

        // permutation

        vk.permutation_commitments[0] = PairingsBn254.new_g1(

            0x1423fa82e00ba22c280181afb12c56eea541933eeb5ec39119b0365b6beab4b9,

            0x0efdcd3423a38f5e2ecf8c7e4fd46f13189f8fed392ad9d8d393e8ba568b06e4

        );

        vk.permutation_commitments[1] = PairingsBn254.new_g1(

            0x0e9b5b12c1090d62224e64aa1696c009aa59a9c3eec458e781fae773e1f4eca5,

            0x1fe3df508c7e9750eb37d9cae5e7437ad11a21fa36530ff821b407b165a79a55

        );

        vk.permutation_commitments[2] = PairingsBn254.new_g1(

            0x25d1a714bd1e258f196e38d6b2826153382c2d04b870d0b7ec250296005129ae,

            0x0883a121b41ca7beaa9de97ecf4417e62aa2eeb9434f24ddacbfed57cbf016a8

        );

        vk.permutation_commitments[3] = PairingsBn254.new_g1(

            0x2f3ede68e854a6b3b14589851cf077a606e2aeb3205c43cc579b7abae39d8f58,

            0x178ccd4b1f78fd79ee248e376b6fc8297d5450900d1e15e8c03e3ed2c171ac8c

        );

        // lookup table commitments

        vk.lookup_selector_commitment = PairingsBn254.new_g1(

            0x1f814e2d87c332e964eeef94ec695eef9d2caaac58b682a43da5107693b06f30,

            0x196d56fb01907e66af9303886fd95328d398e5b2b72906882a9d12c1718e2ee2

        );

        vk.lookup_tables_commitments[0] = PairingsBn254.new_g1(

            0x0ebe0de4a2f39df3b903da484c1641ffdffb77ff87ce4f9508c548659eb22d3c,

            0x12a3209440242d5662729558f1017ed9dcc08fe49a99554dd45f5f15da5e4e0b

        );

        vk.lookup_tables_commitments[1] = PairingsBn254.new_g1(

            0x1b7d54f8065ca63bed0bfbb9280a1011b886d07e0c0a26a66ecc96af68c53bf9,

            0x2c51121fff5b8f58c302f03c74e0cb176ae5a1d1730dec4696eb9cce3fe284ca

        );

        vk.lookup_tables_commitments[2] = PairingsBn254.new_g1(

            0x0138733c5faa9db6d4b8df9748081e38405999e511fb22d40f77cf3aef293c44,

            0x269bee1c1ac28053238f7fe789f1ea2e481742d6d16ae78ed81e87c254af0765

        );

        vk.lookup_tables_commitments[3] = PairingsBn254.new_g1(

            0x1b1be7279d59445065a95f01f16686adfa798ec4f1e6845ffcec9b837e88372e,

            0x057c90cb96d8259238ed86b05f629efd55f472a721efeeb56926e979433e6c0e

        );

        vk.lookup_table_type_commitment = PairingsBn254.new_g1(

            0x2f85df2d6249ccbcc11b91727333cc800459de6ee274f29c657c8d56f6f01563,

            0x088e1df178c47116a69c3c8f6d0c5feb530e2a72493694a623b1cceb7d44a76c

        );

        // non residues

        vk.non_residues[0] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000005);

        vk.non_residues[1] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000007);

        vk.non_residues[2] = PairingsBn254.new_fr(0x000000000000000000000000000000000000000000000000000000000000000a);



        // g2 elements

        vk.g2_elements[0] = PairingsBn254.new_g2(

            [

                0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,

                0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed

            ],

            [

                0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,

                0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa

            ]

        );

        vk.g2_elements[1] = PairingsBn254.new_g2(

            [

                0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,

                0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0

            ],

            [

                0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,

                0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55

            ]

        );

    }



    function deserialize_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)

        internal

        pure

        returns (Proof memory proof)

    {

        require(serialized_proof.length == 44);

        proof.input_values = new uint256[](public_inputs.length);

        for (uint256 i = 0; i < public_inputs.length; i = i.uncheckedInc()) {

            proof.input_values[i] = public_inputs[i];

        }



        uint256 j;

        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {

            proof.state_polys_commitments[i] = PairingsBn254.new_g1_checked(

                serialized_proof[j],

                serialized_proof[j.uncheckedInc()]

            );



            j = j.uncheckedAdd(2);

        }

        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(

            serialized_proof[j],

            serialized_proof[j.uncheckedInc()]

        );

        j = j.uncheckedAdd(2);



        proof.lookup_s_poly_commitment = PairingsBn254.new_g1_checked(

            serialized_proof[j],

            serialized_proof[j.uncheckedInc()]

        );

        j = j.uncheckedAdd(2);



        proof.lookup_grand_product_commitment = PairingsBn254.new_g1_checked(

            serialized_proof[j],

            serialized_proof[j.uncheckedInc()]

        );

        j = j.uncheckedAdd(2);

        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {

            proof.quotient_poly_parts_commitments[i] = PairingsBn254.new_g1_checked(

                serialized_proof[j],

                serialized_proof[j.uncheckedInc()]

            );

            j = j.uncheckedAdd(2);

        }



        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {

            proof.state_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j = j.uncheckedInc();

        }



        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {

            proof.state_polys_openings_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j = j.uncheckedInc();

        }

        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {

            proof.gate_selectors_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j = j.uncheckedInc();

        }

        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {

            proof.copy_permutation_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);



            j = j.uncheckedInc();

        }

        proof.copy_permutation_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);



        j = j.uncheckedInc();

        proof.lookup_s_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);

        j = j.uncheckedInc();

        proof.lookup_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);



        j = j.uncheckedInc();

        proof.lookup_t_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);



        j = j.uncheckedInc();

        proof.lookup_t_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);

        j = j.uncheckedInc();

        proof.lookup_selector_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);

        j = j.uncheckedInc();

        proof.lookup_table_type_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);

        j = j.uncheckedInc();

        proof.quotient_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);

        j = j.uncheckedInc();

        proof.linearization_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);

        j = j.uncheckedInc();

        proof.opening_proof_at_z = PairingsBn254.new_g1_checked(

            serialized_proof[j],

            serialized_proof[j.uncheckedInc()]

        );

        j = j.uncheckedAdd(2);

        proof.opening_proof_at_z_omega = PairingsBn254.new_g1_checked(

            serialized_proof[j],

            serialized_proof[j.uncheckedInc()]

        );

    }



    function verify_serialized_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)

        public

        view

        returns (bool)

    {

        VerificationKey memory vk = get_verification_key();

        require(vk.num_inputs == public_inputs.length);



        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);



        return verify(proof, vk);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\WagmiTraitsUpgradable.sol
File type: .sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;



import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";

import "@openzeppelin/contracts-upgradeable/token/common/ERC2981Upgradeable.sol";

import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";

import "@openzeppelin/contracts-upgradeable//utils/cryptography/ECDSAUpgradeable.sol";

import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol";

import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol";

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "operator-filter-registry/src/upgradeable/DefaultOperatorFiltererUpgradeable.sol";

import "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

import "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";



contract WagmiTraits is Initializable, ERC1155Upgradeable, ERC2981Upgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable, ERC1155BurnableUpgradeable, ERC1155SupplyUpgradeable, DefaultOperatorFiltererUpgradeable {

    string public name = "WAGMI Traits";

    string public symbol = "WAT";

    address private signer;

    address private sales;



    /// @custom:oz-upgrades-unsafe-allow constructor

    constructor() {

        signer = msg.sender;

        _disableInitializers();

    }



    function initialize() initializer public {

        __ERC1155_init("https://wagmiarmy.io/api/metadata/traits?id={id}");

        __ERC2981_init();

        __DefaultOperatorFilterer_init();

        __Ownable_init();

        __Pausable_init();

        __ReentrancyGuard_init();

        __ERC1155Burnable_init();

        __ERC1155Supply_init();

    }



    struct Transfer {

        address holder;

        uint256 traitId;

        uint256 amount;

    }



    struct Trait {

        uint256 traitId;

        uint256 amount;

    }



    event BuyTrait (

        address indexed buyer,

        Transfer[] transfers

    );



    event ClaimTrait (

        address indexed receiver,

        Trait[] traits

    );



    function setSigner(address _signer) external onlyOwner {

        signer = _signer;

    }



    function setSales(address _sales) external onlyOwner {

        sales = _sales;

    }



    function setURI(string memory newuri) public onlyOwner {

        _setURI(newuri);

    }



    function pause() public onlyOwner {

        _pause();

    }



    function unpause() public onlyOwner {

        _unpause();

    }



    function teamMint(uint256 _traitId, address receiver, uint256 amount)

    external

    onlyOwner

    {

        _mint(receiver, _traitId, amount, "");

    }



    function claim(bytes calldata signature, Trait[] memory _traits)

    external

    nonReentrant

    {

        require(_isVerifiedSignature(signature), "Invalid Signature");



        uint256[] memory ids;

        uint256[] memory amounts;

        

        for (uint256 i = 0; i < _traits.length; ++i) { 

            ids[i] = _traits[i].traitId;

            amounts[i] = _traits[i].amount;

        }



        _mintBatch(msg.sender, ids, amounts, "");

        emit ClaimTrait(msg.sender, _traits);

    }



    function buyTraits(Transfer[] memory _transfers)

    external

    onlySales

    {

        uint256[] memory ids;

        uint256[] memory amounts;

        for (uint256 i = 0; i < _transfers.length; ++i) { 

            ids[i] = _transfers[i].traitId;

            amounts[i] = _transfers[i].amount;

        }



        _mintBatch(msg.sender, ids, amounts, "");

        emit BuyTrait(msg.sender, _transfers);

    }



    function sendAirdrop(Transfer[] memory _transfers)

    external

    onlyOwner

    {

        for (uint256 i = 0; i < _transfers.length; ++i) { 

            _mint(_transfers[i].holder, _transfers[i].traitId, _transfers[i].amount, "");

        }

    }



    function _isVerifiedSignature(bytes calldata signature)

    internal

    view

    returns (bool)

    {

        bytes32 digest = keccak256(

            abi.encodePacked(

                "\x19Ethereum Signed Message:\n32",

                bytes32(uint256(uint160(msg.sender)))

            )

        );

        return ECDSAUpgradeable.recover(digest, signature) == signer;

    }



    /**

     * @dev See {IERC1155-setApprovalForAll}.

     *      In this example the added modifier ensures that the operator is allowed by the OperatorFilterRegistry.

     */

    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {

        super.setApprovalForAll(operator, approved);

    }



    /**

     * @dev See {IERC1155-safeTransferFrom}.

     *      In this example the added modifier ensures that the operator is allowed by the OperatorFilterRegistry.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId, uint256 amount, bytes memory data)

        public

        override

        onlyAllowedOperator(from)

    {

        super.safeTransferFrom(from, to, tokenId, amount, data);

    }



    /**

     * @dev See {IERC1155-safeBatchTransferFrom}.

     *      In this example the added modifier ensures that the operator is allowed by the OperatorFilterRegistry.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) public virtual override onlyAllowedOperator(from) {

        super.safeBatchTransferFrom(from, to, ids, amounts, data);

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155Upgradeable, ERC2981Upgradeable) returns (bool) {

        return super.supportsInterface(interfaceId);

    }



    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)

        internal

        whenNotPaused

        override(ERC1155Upgradeable, ERC1155SupplyUpgradeable)

    {

        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);

    }



    function withdraw() external onlyOwner {

        uint256 balance = address(this).balance;

        payable(msg.sender).transfer(balance);

    }



    modifier onlySales() {

        require(msg.sender == sales, "Invalid Access");

        _;

    }



    /**

     * @dev This empty reserved space is put in place to allow future versions to add new

     * variables without shifting down storage in the inheritance chain.

     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps

     */

    uint256[49] private __gap;

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_last\zkSync Portal Bridge\contracts\ZkSync.sol
File type: .sol
pragma solidity ^0.7.0;

pragma experimental ABIEncoderV2;



// SPDX-License-Identifier: MIT OR Apache-2.0











import "./ReentrancyGuard.sol";

import "./SafeMath.sol";

import "./SafeMathUInt128.sol";

import "./SafeCast.sol";

import "./Utils.sol";



import "./Storage.sol";

import "./Config.sol";

import "./Events.sol";



import "./Bytes.sol";

import "./Operations.sol";



import "./UpgradeableMaster.sol";

import "./AdditionalZkSync.sol";



/// @title zkSync main contract

/// @author Matter Labs

contract ZkSync is UpgradeableMaster, Storage, Config, Events, ReentrancyGuard {

    using SafeMath for uint256;

    using SafeMathUInt128 for uint128;



    bytes32 private constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;



    /// @notice Data needed to process onchain operation from block public data.

    /// @notice Onchain operations is operations that need some processing on L1: Deposits, Withdrawals, ChangePubKey.

    /// @param ethWitness Some external data that can be needed for operation processing

    /// @param publicDataOffset Byte offset in public data for onchain operation

    struct OnchainOperationData {

        bytes ethWitness;

        uint32 publicDataOffset;

    }



    /// @notice Data needed to commit new block

    struct CommitBlockInfo {

        bytes32 newStateHash;

        bytes publicData;

        uint256 timestamp;

        OnchainOperationData[] onchainOperations;

        uint32 blockNumber;

        uint32 feeAccount;

    }



    /// @notice Data needed to execute committed and verified block

    /// @param commitmentsInSlot verified commitments in one slot

    /// @param commitmentIdx index such that commitmentsInSlot[commitmentIdx] is current block commitment

    struct ExecuteBlockInfo {

        StoredBlockInfo storedBlock;

        bytes[] pendingOnchainOpsPubdata;

    }



    /// @notice Recursive proof input data (individual commitments are constructed onchain)

    struct ProofInput {

        uint256[] recursiveInput;

        uint256[] proof;

        uint256[] commitments;

        uint8[] vkIndexes;

        uint256[16] subproofsLimbs;

    }



    // Upgrade functional



    /// @notice Notice period before activation preparation status of upgrade mode

    function getNoticePeriod() external pure override returns (uint256) {

        return 0;

    }



    /// @notice Notification that upgrade notice period started

    /// @dev Can be external because Proxy contract intercepts illegal calls of this function

    function upgradeNoticePeriodStarted() external override {

        upgradeStartTimestamp = block.timestamp;

    }



    /// @notice Notification that upgrade preparation status is activated

    /// @dev Can be external because Proxy contract intercepts illegal calls of this function

    function upgradePreparationStarted() external override {

        require(block.timestamp >= upgradeStartTimestamp.add(approvedUpgradeNoticePeriod));



        upgradePreparationActive = true;

        upgradePreparationActivationTime = block.timestamp;

    }



    /// @dev When upgrade is finished or canceled we must clean upgrade-related state.

    function clearUpgradeStatus() internal {

        upgradePreparationActive = false;

        upgradePreparationActivationTime = 0;

        approvedUpgradeNoticePeriod = UPGRADE_NOTICE_PERIOD;

        emit NoticePeriodChange(approvedUpgradeNoticePeriod);

        upgradeStartTimestamp = 0;

        for (uint256 i = 0; i < SECURITY_COUNCIL_MEMBERS_NUMBER; ++i) {

            securityCouncilApproves[i] = false;

        }

        numberOfApprovalsFromSecurityCouncil = 0;

    }



    /// @notice Notification that upgrade canceled

    /// @dev Can be external because Proxy contract intercepts illegal calls of this function

    function upgradeCanceled() external override {

        clearUpgradeStatus();

    }



    /// @notice Notification that upgrade finishes

    /// @dev Can be external because Proxy contract intercepts illegal calls of this function

    function upgradeFinishes() external override {

        clearUpgradeStatus();

    }



    /// @notice Checks that contract is ready for upgrade

    /// @return bool flag indicating that contract is ready for upgrade

    function isReadyForUpgrade() external view override returns (bool) {

        return true;

    }



    constructor() {

        initializeReentrancyGuard();

    }



    /// @notice zkSync contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.

    /// @param initializationParameters Encoded representation of initialization parameters:

    /// @dev _governanceAddress The address of Governance contract

    /// @dev _verifierAddress The address of Verifier contract

    /// @dev _genesisStateHash Genesis blocks (first block) state tree root hash

    function initialize(bytes calldata initializationParameters) external {

        initializeReentrancyGuard();



        (

            address _governanceAddress,

            address _verifierAddress,

            address _additionalZkSync,

            bytes32 _genesisStateHash

        ) = abi.decode(initializationParameters, (address, address, address, bytes32));



        verifier = Verifier(_verifierAddress);

        governance = Governance(_governanceAddress);

        additionalZkSync = AdditionalZkSync(_additionalZkSync);



        StoredBlockInfo memory storedBlockZero = StoredBlockInfo(

            0,

            0,

            EMPTY_STRING_KECCAK,

            0,

            _genesisStateHash,

            bytes32(0)

        );

        storedBlockHashes[0] = hashStoredBlockInfo(storedBlockZero);

        approvedUpgradeNoticePeriod = UPGRADE_NOTICE_PERIOD;

        emit NoticePeriodChange(approvedUpgradeNoticePeriod);

    }



    /// @notice zkSync contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.

    /// @param upgradeParameters Encoded representation of upgrade parameters

    // solhint-disable-next-line no-empty-blocks

    function upgrade(bytes calldata upgradeParameters) external nonReentrant {

        approvedUpgradeNoticePeriod = UPGRADE_NOTICE_PERIOD;

        additionalZkSync = AdditionalZkSync(0x080812701c94087F1DEE425EbD7CBF9EFAF878e2);

    }



    function cutUpgradeNoticePeriod(bytes32 targetsHash) external {

        // All functions delegated to additional contract should NOT be nonReentrant

        delegateAdditional();

    }



    function cutUpgradeNoticePeriodBySignature(bytes[] calldata signatures) external {

        // All functions delegated to additional contract should NOT be nonReentrant

        delegateAdditional();

    }



    /// @notice Sends tokens

    /// @dev NOTE: will revert if transfer call fails or rollup balance difference (before and after transfer) is bigger than _maxAmount

    /// @dev This function is used to allow tokens to spend zkSync contract balance up to amount that is requested

    /// @param _token Token address

    /// @param _to Address of recipient

    /// @param _amount Amount of tokens to transfer

    /// @param _maxAmount Maximum possible amount of tokens to transfer to this account

    function transferERC20(

        IERC20 _token,

        address _to,

        uint128 _amount,

        uint128 _maxAmount

    ) external returns (uint128 withdrawnAmount) {

        require(msg.sender == address(this), "5"); // can be called only from this contract as one "external" call (to revert all this function state changes if it is needed)



        uint256 balanceBefore = _token.balanceOf(address(this));

        _token.transfer(_to, _amount);

        uint256 balanceAfter = _token.balanceOf(address(this));

        uint256 balanceDiff = balanceBefore.sub(balanceAfter);

        require(balanceDiff > 0, "c1"); // transfer is considered successful only if the balance of the contract decreased after transfer

        require(balanceDiff <= _maxAmount, "7"); // rollup balance difference (before and after transfer) is bigger than `_maxAmount`



        // It is safe to convert `balanceDiff` to `uint128` without additional checks, because `balanceDiff <= _maxAmount`

        return uint128(balanceDiff);

    }



    /// @notice Accrues users balances from deposit priority requests in Exodus mode

    /// @dev WARNING: Only for Exodus mode

    /// @dev Canceling may take several separate transactions to be completed

    /// @param _n number of requests to process

    function cancelOutstandingDepositsForExodusMode(uint64 _n, bytes[] calldata _depositsPubdata) external {

        // All functions delegated to additional contract should NOT be nonReentrant

        delegateAdditional();

    }



    /// @notice Deposit ETH to Layer 2 - transfer ether from user into contract, validate it, register deposit

    /// @param _zkSyncAddress The receiver Layer 2 address

    function depositETH(address _zkSyncAddress) external payable {

        require(_zkSyncAddress != SPECIAL_ACCOUNT_ADDRESS, "P");

        require(msg.value > 0, "M"); // Zero-value deposits are forbidden by zkSync rollup logic

        requireActive();

        registerDeposit(0, SafeCast.toUint128(msg.value), _zkSyncAddress);

    }



    /// @notice Deposit ERC20 token to Layer 2 - transfer ERC20 tokens from user into contract, validate it, register deposit

    /// @param _token Token address

    /// @param _amount Token amount

    /// @param _zkSyncAddress Receiver Layer 2 address

    function depositERC20(

        IERC20 _token,

        uint104 _amount,

        address _zkSyncAddress

    ) external nonReentrant {

        require(_zkSyncAddress != SPECIAL_ACCOUNT_ADDRESS, "P");

        requireActive();



        // Get token id by its address

        uint16 tokenId = governance.validateTokenAddress(address(_token));

        require(!governance.pausedTokens(tokenId), "b"); // token deposits are paused



        uint256 balanceBefore = _token.balanceOf(address(this));

        _token.transferFrom(msg.sender, address(this), _amount);

        uint256 balanceAfter = _token.balanceOf(address(this));

        uint128 depositAmount = SafeCast.toUint128(balanceAfter.sub(balanceBefore));

        require(depositAmount > 0 && depositAmount <= MAX_DEPOSIT_AMOUNT, "C");



        registerDeposit(tokenId, depositAmount, _zkSyncAddress);

    }



    /// @notice Returns amount of tokens that can be withdrawn by `address` from zkSync contract

    /// @param _address Address of the tokens owner

    /// @param _token Address of token, zero address is used for ETH

    function getPendingBalance(address _address, address _token) public view returns (uint128) {

        uint16 tokenId = 0;

        if (_token != address(0)) {

            tokenId = governance.validateTokenAddress(_token);

        }

        return pendingBalances[packAddressAndTokenId(_address, tokenId)].balanceToWithdraw;

    }



    /// @notice  Withdraws tokens from zkSync contract to the owner

    /// @param _owner Address of the tokens owner

    /// @param _token Address of tokens, zero address is used for ETH

    /// @param _amount Amount to withdraw to request.

    ///         NOTE: We will call ERC20.transfer(.., _amount), but if according to internal logic of ERC20 token zkSync contract

    ///         balance will be decreased by value more then _amount we will try to subtract this value from user pending balance

    function withdrawPendingBalance(

        address payable _owner,

        address _token,

        uint128 _amount

    ) external nonReentrant {

        uint16 tokenId = 0;

        if (_token != address(0)) {

            tokenId = governance.validateTokenAddress(_token);

        }



        bytes22 packedBalanceKey = packAddressAndTokenId(_owner, tokenId);

        uint128 balance = pendingBalances[packedBalanceKey].balanceToWithdraw;

        uint128 amount = Utils.minU128(balance, _amount);

        require(amount > 0, "f1"); // Nothing to withdraw



        if (tokenId == 0) {

            (bool success, ) = _owner.call{value: amount}("");

            require(success, "d"); // ETH withdraw failed

        } else {

            // We will allow withdrawals of `value` such that:

            // `value` <= user pending balance

            // `value` can be bigger then `amount` requested if token takes fee from sender in addition to `amount` requested

            amount = this.transferERC20(IERC20(_token), _owner, amount, balance);

        }



        pendingBalances[packedBalanceKey].balanceToWithdraw = balance - amount;

        emit Withdrawal(tokenId, amount);

    }



    /// @notice  Withdraws NFT from zkSync contract to the owner

    /// @param _tokenId Id of NFT token

    function withdrawPendingNFTBalance(uint32 _tokenId) external nonReentrant {

        Operations.WithdrawNFT memory op = pendingWithdrawnNFTs[_tokenId];

        require(op.creatorAddress != address(0), "op"); // No NFT to withdraw

        NFTFactory _factory = governance.getNFTFactory(op.creatorAccountId, op.creatorAddress);

        // Save withdrawn nfts for future deposits

        withdrawnNFTs[_tokenId] = address(_factory);

        delete pendingWithdrawnNFTs[_tokenId];

        _factory.mintNFTFromZkSync(

            op.creatorAddress,

            op.receiver,

            op.creatorAccountId,

            op.serialId,

            op.contentHash,

            op.tokenId

        );



        emit WithdrawalNFT(op.tokenId);

    }



    /// @notice Register full exit request - pack pubdata, add priority request

    /// @param _accountId Numerical id of the account

    /// @param _token Token address, 0 address for ether

    function requestFullExit(uint32 _accountId, address _token) public nonReentrant {

        requireActive();

        require(_accountId <= MAX_ACCOUNT_ID, "e");

        require(_accountId != SPECIAL_ACCOUNT_ID, "v"); // request full exit for nft storage account



        uint16 tokenId;

        if (_token == address(0)) {

            tokenId = 0;

        } else {

            tokenId = governance.validateTokenAddress(_token);

        }



        // Priority Queue request

        Operations.FullExit memory op = Operations.FullExit({

            accountId: _accountId,

            owner: msg.sender,

            tokenId: tokenId,

            amount: 0, // unknown at this point

            nftCreatorAccountId: uint32(0), // unknown at this point

            nftCreatorAddress: address(0), // unknown at this point

            nftSerialId: uint32(0), // unknown at this point

            nftContentHash: bytes32(0) // unknown at this point

        });

        bytes memory pubData = Operations.writeFullExitPubdataForPriorityQueue(op);

        addPriorityRequest(Operations.OpType.FullExit, pubData);



        // User must fill storage slot of balancesToWithdraw(msg.sender, tokenId) with nonzero value

        // In this case operator should just overwrite this slot during confirming withdrawal

        bytes22 packedBalanceKey = packAddressAndTokenId(msg.sender, tokenId);

        pendingBalances[packedBalanceKey].gasReserveValue = FILLED_GAS_RESERVE_VALUE;

    }



    /// @notice Register full exit nft request - pack pubdata, add priority request

    /// @param _accountId Numerical id of the account

    /// @param _tokenId NFT token id in zkSync network

    function requestFullExitNFT(uint32 _accountId, uint32 _tokenId) public nonReentrant {

        requireActive();

        require(_accountId <= MAX_ACCOUNT_ID, "e");

        require(_accountId != SPECIAL_ACCOUNT_ID, "v"); // request full exit nft for nft storage account

        require(MAX_FUNGIBLE_TOKEN_ID < _tokenId && _tokenId < SPECIAL_NFT_TOKEN_ID, "T"); // request full exit nft for invalid token id



        // Priority Queue request

        Operations.FullExit memory op = Operations.FullExit({

            accountId: _accountId,

            owner: msg.sender,

            tokenId: _tokenId,

            amount: 0, // unknown at this point

            nftCreatorAccountId: uint32(0), // unknown at this point

            nftCreatorAddress: address(0), // unknown at this point

            nftSerialId: uint32(0), // unknown at this point

            nftContentHash: bytes32(0) // unknown at this point

        });

        bytes memory pubData = Operations.writeFullExitPubdataForPriorityQueue(op);

        addPriorityRequest(Operations.OpType.FullExit, pubData);

    }



    /// @dev Process one block commit using previous block StoredBlockInfo,

    /// @dev returns new block StoredBlockInfo

    function commitOneBlock(StoredBlockInfo memory _previousBlock, CommitBlockInfo memory _newBlock)

        internal

        view

        returns (StoredBlockInfo memory storedNewBlock)

    {

        require(_newBlock.blockNumber == _previousBlock.blockNumber + 1, "f"); // only commit next block



        // Check timestamp of the new block

        {

            require(_newBlock.timestamp >= _previousBlock.timestamp, "g"); // Block should be after previous block

            bool timestampNotTooSmall = block.timestamp.sub(COMMIT_TIMESTAMP_NOT_OLDER) <= _newBlock.timestamp;

            bool timestampNotTooBig = _newBlock.timestamp <= block.timestamp.add(COMMIT_TIMESTAMP_APPROXIMATION_DELTA);

            require(timestampNotTooSmall && timestampNotTooBig, "h"); // New block timestamp is not valid

        }



        // Check onchain operations

        (

            bytes32 pendingOnchainOpsHash,

            uint64 priorityReqCommitted,

            bytes memory onchainOpsOffsetCommitment

        ) = collectOnchainOps(_newBlock);



        // Create block commitment for verification proof

        bytes32 commitment = createBlockCommitment(_previousBlock, _newBlock, onchainOpsOffsetCommitment);



        return

            StoredBlockInfo(

                _newBlock.blockNumber,

                priorityReqCommitted,

                pendingOnchainOpsHash,

                _newBlock.timestamp,

                _newBlock.newStateHash,

                commitment

            );

    }



    /// @notice Commit block

    /// @notice 1. Checks onchain operations, timestamp.

    /// @notice 2. Store block commitments

    function commitBlocks(StoredBlockInfo memory _lastCommittedBlockData, CommitBlockInfo[] memory _newBlocksData)

        external

        nonReentrant

    {

        requireActive();

        governance.requireActiveValidator(msg.sender);

        // Check that we commit blocks after last committed block

        require(storedBlockHashes[totalBlocksCommitted] == hashStoredBlockInfo(_lastCommittedBlockData), "i"); // incorrect previous block data



        for (uint32 i = 0; i < _newBlocksData.length; ++i) {

            _lastCommittedBlockData = commitOneBlock(_lastCommittedBlockData, _newBlocksData[i]);



            totalCommittedPriorityRequests += _lastCommittedBlockData.priorityOperations;

            storedBlockHashes[_lastCommittedBlockData.blockNumber] = hashStoredBlockInfo(_lastCommittedBlockData);



            emit BlockCommit(_lastCommittedBlockData.blockNumber);

        }



        totalBlocksCommitted += uint32(_newBlocksData.length);



        require(totalCommittedPriorityRequests <= totalOpenPriorityRequests, "j");

    }



    /// @dev 1. Try to send token to _recipients

    /// @dev 2. On failure: Increment _recipients balance to withdraw.

    function withdrawOrStoreNFT(Operations.WithdrawNFT memory op) internal {

        NFTFactory _factory = governance.getNFTFactory(op.creatorAccountId, op.creatorAddress);

        try

            _factory.mintNFTFromZkSync{gas: WITHDRAWAL_NFT_GAS_LIMIT}(

                op.creatorAddress,

                op.receiver,

                op.creatorAccountId,

                op.serialId,

                op.contentHash,

                op.tokenId

            )

        {

            // Save withdrawn nfts for future deposits

            withdrawnNFTs[op.tokenId] = address(_factory);

            emit WithdrawalNFT(op.tokenId);

        } catch {

            storePendingNFT(op);

        }

    }



    /// @dev 1. Try to send token to _recipients

    /// @dev 2. On failure: Increment _recipients balance to withdraw.

    function withdrawOrStore(

        uint16 _tokenId,

        address _recipient,

        uint128 _amount

    ) internal {

        bool sent = false;

        if (_tokenId == 0) {

            address payable toPayable = address(uint160(_recipient));

            sent = sendETHNoRevert(toPayable, _amount);

        } else {

            address tokenAddr = governance.tokenAddresses(_tokenId);

            // We use `transferERC20` here to check that `ERC20` token indeed transferred `_amount`

            // and fail if token subtracted from zkSync balance more then `_amount` that was requested.

            // This can happen if token subtracts fee from sender while transferring `_amount` that was requested to transfer.

            try this.transferERC20{gas: WITHDRAWAL_GAS_LIMIT}(IERC20(tokenAddr), _recipient, _amount, _amount) {

                sent = true;

            } catch {

                sent = false;

            }

        }

        if (sent) {

            emit Withdrawal(_tokenId, _amount);

        } else {

            increasePendingBalance(_tokenId, _recipient, _amount);

        }

    }



    /// @dev Save NFT as pending to withdraw

    function storePendingNFT(Operations.WithdrawNFT memory op) internal {

        pendingWithdrawnNFTs[op.tokenId] = op;

        emit WithdrawalNFTPending(op.tokenId);

    }



    /// @dev Increase `_recipient` balance to withdraw

    function increasePendingBalance(

        uint16 _tokenId,

        address _recipient,

        uint128 _amount

    ) internal {

        bytes22 packedBalanceKey = packAddressAndTokenId(_recipient, _tokenId);

        increaseBalanceToWithdraw(packedBalanceKey, _amount);

        emit WithdrawalPending(_tokenId, _recipient, _amount);

    }



    /// @dev helper function to process ETH/ERC20 withdrawal

    function handleWithdrawFT(

        bool _completeWithdrawals,

        uint16 _tokenId,

        address _addr,

        uint128 _amount

    ) internal {

        if (_completeWithdrawals) {

            withdrawOrStore(_tokenId, _addr, _amount);

        } else {

            increasePendingBalance(_tokenId, _addr, _amount);

        }

    }



    /// @dev helper function to process NFT withdrawal

    function handleWithdrawNFT(bool _completeWithdrawals, Operations.WithdrawNFT memory _op) internal {

        if (_completeWithdrawals) {

            withdrawOrStoreNFT(_op);

        } else {

            storePendingNFT(_op);

        }

    }



    /// @dev Executes one block

    /// @dev 1. Processes all priority operations or save them as pending

    /// @dev 2. Finalizes block on Ethereum

    /// @dev _executedBlockIdx is index in the array of the blocks that we want to execute together

    function executeOneBlock(

        ExecuteBlockInfo memory _blockExecuteData,

        uint32 _executedBlockIdx,

        bool _completeWithdrawals

    ) internal {

        // Ensure block was committed

        require(

            hashStoredBlockInfo(_blockExecuteData.storedBlock) ==

                storedBlockHashes[_blockExecuteData.storedBlock.blockNumber],

            "exe10" // executing block should be committed

        );

        require(_blockExecuteData.storedBlock.blockNumber == totalBlocksExecuted + _executedBlockIdx + 1, "k"); // Execute blocks in order



        bytes32 pendingOnchainOpsHash = EMPTY_STRING_KECCAK;

        for (uint32 i = 0; i < _blockExecuteData.pendingOnchainOpsPubdata.length; ++i) {

            bytes memory pubData = _blockExecuteData.pendingOnchainOpsPubdata[i];



            Operations.OpType opType = Operations.OpType(uint8(pubData[0]));



            if (opType == Operations.OpType.PartialExit) {

                Operations.PartialExit memory op = Operations.readPartialExitPubdata(pubData);

                // Circuit guarantees that partial exits are available only for fungible tokens

                require(op.tokenId <= MAX_FUNGIBLE_TOKEN_ID, "mf1");

                handleWithdrawFT(_completeWithdrawals, uint16(op.tokenId), op.owner, op.amount);

            } else if (opType == Operations.OpType.ForcedExit) {

                Operations.ForcedExit memory op = Operations.readForcedExitPubdata(pubData);

                // Circuit guarantees that forced exits are available only for fungible tokens

                require(op.tokenId <= MAX_FUNGIBLE_TOKEN_ID, "mf2");

                handleWithdrawFT(_completeWithdrawals, uint16(op.tokenId), op.target, op.amount);

            } else if (opType == Operations.OpType.FullExit) {

                Operations.FullExit memory op = Operations.readFullExitPubdata(pubData);

                if (op.tokenId <= MAX_FUNGIBLE_TOKEN_ID) {

                    handleWithdrawFT(_completeWithdrawals, uint16(op.tokenId), op.owner, op.amount);

                } else {

                    if (op.amount == 1) {

                        Operations.WithdrawNFT memory withdrawNftOp = Operations.WithdrawNFT(

                            op.nftCreatorAccountId,

                            op.nftCreatorAddress,

                            op.nftSerialId,

                            op.nftContentHash,

                            op.owner,

                            op.tokenId

                        );

                        handleWithdrawNFT(_completeWithdrawals, withdrawNftOp);

                    }

                }

            } else if (opType == Operations.OpType.WithdrawNFT) {

                Operations.WithdrawNFT memory op = Operations.readWithdrawNFTPubdata(pubData);

                handleWithdrawNFT(_completeWithdrawals, op);

            } else {

                revert("l"); // unsupported op in block execution

            }



            pendingOnchainOpsHash = Utils.concatHash(pendingOnchainOpsHash, pubData);

        }

        require(pendingOnchainOpsHash == _blockExecuteData.storedBlock.pendingOnchainOperationsHash, "m"); // incorrect onchain ops executed

    }



    /// @notice Execute blocks, completing priority operations and processing withdrawals.

    /// @notice 1. Processes all pending operations (Send Exits, Complete priority requests)

    /// @notice 2. Finalizes block on Ethereum

    function executeBlocks(ExecuteBlockInfo[] memory _blocksData, bool _completeWithdrawals) external nonReentrant {

        requireActive();

        governance.requireActiveValidator(msg.sender);



        uint64 priorityRequestsExecuted = 0;

        uint32 nBlocks = uint32(_blocksData.length);

        for (uint32 i = 0; i < nBlocks; ++i) {

            executeOneBlock(_blocksData[i], i, _completeWithdrawals);

            priorityRequestsExecuted += _blocksData[i].storedBlock.priorityOperations;

            emit BlockVerification(_blocksData[i].storedBlock.blockNumber);

        }



        firstPriorityRequestId += priorityRequestsExecuted;

        totalCommittedPriorityRequests -= priorityRequestsExecuted;

        totalOpenPriorityRequests -= priorityRequestsExecuted;



        totalBlocksExecuted += nBlocks;

        require(totalBlocksExecuted <= totalBlocksProven, "n"); // Can't execute blocks more then committed and proven currently.

    }



    /// @notice Blocks commitment verification.

    /// @notice Only verifies block commitments without any other processing

    function proveBlocks(StoredBlockInfo[] memory _committedBlocks, ProofInput memory _proof) external nonReentrant {

        requireActive();



        uint32 currentTotalBlocksProven = totalBlocksProven;

        for (uint256 i = 0; i < _committedBlocks.length; ++i) {

            require(hashStoredBlockInfo(_committedBlocks[i]) == storedBlockHashes[currentTotalBlocksProven + 1], "o1");

            ++currentTotalBlocksProven;



            require(_proof.commitments[i] & INPUT_MASK == uint256(_committedBlocks[i].commitment) & INPUT_MASK, "o"); // incorrect block commitment in proof

        }



        bool success = verifier.verifyAggregatedBlockProof(

            _proof.recursiveInput,

            _proof.proof,

            _proof.vkIndexes,

            _proof.commitments,

            _proof.subproofsLimbs

        );

        require(success, "p"); // Aggregated proof verification fail



        require(currentTotalBlocksProven <= totalBlocksCommitted, "q");

        totalBlocksProven = currentTotalBlocksProven;

    }



    /// @notice Reverts unverified blocks

    function revertBlocks(StoredBlockInfo[] calldata _blocksToRevert) external {

        // All functions delegated to additional contract should NOT be nonReentrant

        delegateAdditional();

    }



    /// @notice Checks if Exodus mode must be entered. If true - enters exodus mode and emits ExodusMode event.

    /// @dev Exodus mode must be entered in case of current ethereum block number is higher than the oldest

    /// @dev of existed priority requests expiration block number.

    /// @return bool flag that is true if the Exodus mode must be entered.

    function activateExodusMode() external returns (bool) {

        if (exodusMode) {

            return false;

        }



        bool trigger = block.number >= priorityRequests[firstPriorityRequestId].expirationBlock &&

            priorityRequests[firstPriorityRequestId].expirationBlock != 0;



        if (trigger) {

            exodusMode = true;

            emit ExodusMode();

        }

        return trigger;

    }



    /// @notice Withdraws token from ZkSync to root chain in case of exodus mode. User must provide proof that he owns funds

    /// @param _storedBlockInfo Last verified block

    /// @param _owner Owner of the account

    /// @param _accountId Id of the account in the tree

    /// @param _proof Proof

    /// @param _tokenId Verified token id

    /// @param _amount Amount for owner (must be total amount, not part of it)

    function performExodus(

        StoredBlockInfo memory _storedBlockInfo,

        address _owner,

        uint32 _accountId,

        uint32 _tokenId,

        uint128 _amount,

        uint32 _nftCreatorAccountId,

        address _nftCreatorAddress,

        uint32 _nftSerialId,

        bytes32 _nftContentHash,

        uint256[] calldata _proof

    ) external {

        // All functions delegated to additional should NOT be nonReentrant

        delegateAdditional();

    }



    /// @notice Set data for changing pubkey hash using onchain authorization.

    ///         Transaction author (msg.sender) should be L2 account address

    /// @notice New pubkey hash can be reset, to do that user should send two transactions:

    ///         1) First `setAuthPubkeyHash` transaction for already used `_nonce` will set timer.

    ///         2) After `AUTH_FACT_RESET_TIMELOCK` time is passed second `setAuthPubkeyHash` transaction will reset pubkey hash for `_nonce`.

    /// @param _pubkeyHash New pubkey hash

    /// @param _nonce Nonce of the change pubkey L2 transaction

    function setAuthPubkeyHash(bytes calldata _pubkeyHash, uint32 _nonce) external {

        // All functions delegated to additional contract should NOT be nonReentrant

        delegateAdditional();

    }



    /// @notice Register deposit request - pack pubdata, add priority request and emit OnchainDeposit event

    /// @param _tokenId Token by id

    /// @param _amount Token amount

    /// @param _owner Receiver

    function registerDeposit(

        uint16 _tokenId,

        uint128 _amount,

        address _owner

    ) internal {

        // Priority Queue request

        Operations.Deposit memory op = Operations.Deposit({

            accountId: 0, // unknown at this point

            owner: _owner,

            tokenId: _tokenId,

            amount: _amount

        });

        bytes memory pubData = Operations.writeDepositPubdataForPriorityQueue(op);

        addPriorityRequest(Operations.OpType.Deposit, pubData);

        emit Deposit(_tokenId, _amount);

    }



    /// @dev Gets operations packed in bytes array. Unpacks it and stores onchain operations.

    /// @dev Priority operations must be committed in the same order as they are in the priority queue.

    /// @dev NOTE: does not change storage! (only emits events)

    /// @dev processableOperationsHash - hash of the all operations that needs to be executed  (Deposit, Exits, ChangPubKey)

    /// @dev priorityOperationsProcessed - number of priority operations processed in this block (Deposits, FullExits)

    /// @dev offsetsCommitment - array where 1 is stored in chunk where onchainOperation begins and other are 0 (used in commitments)

    function collectOnchainOps(CommitBlockInfo memory _newBlockData)

        internal

        view

        returns (

            bytes32 processableOperationsHash,

            uint64 priorityOperationsProcessed,

            bytes memory offsetsCommitment

        )

    {

        bytes memory pubData = _newBlockData.publicData;



        uint64 uncommittedPriorityRequestsOffset = firstPriorityRequestId + totalCommittedPriorityRequests;

        priorityOperationsProcessed = 0;

        processableOperationsHash = EMPTY_STRING_KECCAK;



        require(pubData.length % CHUNK_BYTES == 0, "A"); // pubdata length must be a multiple of CHUNK_BYTES

        offsetsCommitment = new bytes(pubData.length / CHUNK_BYTES);

        for (uint256 i = 0; i < _newBlockData.onchainOperations.length; ++i) {

            OnchainOperationData memory onchainOpData = _newBlockData.onchainOperations[i];



            uint256 pubdataOffset = onchainOpData.publicDataOffset;

            require(pubdataOffset < pubData.length, "A1");

            require(pubdataOffset % CHUNK_BYTES == 0, "B"); // offsets should be on chunks boundaries

            uint256 chunkId = pubdataOffset / CHUNK_BYTES;

            require(offsetsCommitment[chunkId] == 0x00, "C"); // offset commitment should be empty

            offsetsCommitment[chunkId] = bytes1(0x01);



            Operations.OpType opType = Operations.OpType(uint8(pubData[pubdataOffset]));



            if (opType == Operations.OpType.Deposit) {

                bytes memory opPubData = Bytes.slice(pubData, pubdataOffset, DEPOSIT_BYTES);



                Operations.Deposit memory depositData = Operations.readDepositPubdata(opPubData);



                checkPriorityOperation(depositData, uncommittedPriorityRequestsOffset + priorityOperationsProcessed);

                priorityOperationsProcessed++;

            } else if (opType == Operations.OpType.ChangePubKey) {

                bytes memory opPubData = Bytes.slice(pubData, pubdataOffset, CHANGE_PUBKEY_BYTES);



                Operations.ChangePubKey memory op = Operations.readChangePubKeyPubdata(opPubData);



                if (onchainOpData.ethWitness.length != 0) {

                    bool valid = verifyChangePubkey(onchainOpData.ethWitness, op);

                    require(valid, "D"); // failed to verify change pubkey hash signature

                } else {

                    bool valid = authFacts[op.owner][op.nonce] == keccak256(abi.encodePacked(op.pubKeyHash));

                    require(valid, "E"); // new pub key hash is not authenticated properly

                }

            } else {

                bytes memory opPubData;



                if (opType == Operations.OpType.PartialExit) {

                    opPubData = Bytes.slice(pubData, pubdataOffset, PARTIAL_EXIT_BYTES);

                } else if (opType == Operations.OpType.ForcedExit) {

                    opPubData = Bytes.slice(pubData, pubdataOffset, FORCED_EXIT_BYTES);

                } else if (opType == Operations.OpType.WithdrawNFT) {

                    opPubData = Bytes.slice(pubData, pubdataOffset, WITHDRAW_NFT_BYTES);

                } else if (opType == Operations.OpType.FullExit) {

                    opPubData = Bytes.slice(pubData, pubdataOffset, FULL_EXIT_BYTES);



                    Operations.FullExit memory fullExitData = Operations.readFullExitPubdata(opPubData);



                    checkPriorityOperation(

                        fullExitData,

                        uncommittedPriorityRequestsOffset + priorityOperationsProcessed

                    );

                    priorityOperationsProcessed++;

                } else {

                    revert("F"); // unsupported op

                }



                processableOperationsHash = Utils.concatHash(processableOperationsHash, opPubData);

            }

        }

    }



    /// @notice Checks that change operation is correct

    function verifyChangePubkey(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)

        internal

        pure

        returns (bool)

    {

        Operations.ChangePubkeyType changePkType = Operations.ChangePubkeyType(uint8(_ethWitness[0]));

        if (changePkType == Operations.ChangePubkeyType.ECRECOVER) {

            return verifyChangePubkeyECRECOVER(_ethWitness, _changePk);

        } else if (changePkType == Operations.ChangePubkeyType.CREATE2) {

            return verifyChangePubkeyCREATE2(_ethWitness, _changePk);

        } else if (changePkType == Operations.ChangePubkeyType.OldECRECOVER) {

            return verifyChangePubkeyOldECRECOVER(_ethWitness, _changePk);

        } else if (changePkType == Operations.ChangePubkeyType.ECRECOVERV2) {

            return verifyChangePubkeyECRECOVERV2(_ethWitness, _changePk);

        } else {

            revert("G"); // Incorrect ChangePubKey type

        }

    }



    /// @notice Checks that signature is valid for pubkey change message

    /// @param _ethWitness Signature (65 bytes)

    /// @param _changePk Parsed change pubkey operation

    function verifyChangePubkeyECRECOVER(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)

        internal

        pure

        returns (bool)

    {

        (, bytes memory signature) = Bytes.read(_ethWitness, 1, 65); // offset is 1 because we skip type of ChangePubkey

        bytes32 messageHash = keccak256(

            abi.encodePacked(

                "\x19Ethereum Signed Message:\n60",

                _changePk.pubKeyHash,

                _changePk.nonce,

                _changePk.accountId,

                bytes32(0)

            )

        );

        address recoveredAddress = Utils.recoverAddressFromEthSignature(signature, messageHash);

        return recoveredAddress == _changePk.owner;

    }



    /// @notice Checks that signature is valid for pubkey change message

    /// @param _ethWitness Signature (65 bytes) + 32 bytes of the arbitrary signed data

    /// @notice additional 32 bytes can be used to sign batches and ChangePubKey with one signature

    /// @param _changePk Parsed change pubkey operation

    function verifyChangePubkeyECRECOVERV2(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)

        internal

        pure

        returns (bool)

    {

        (uint256 offset, bytes memory signature) = Bytes.read(_ethWitness, 1, 65); // offset is 1 because we skip type of ChangePubkey

        (, bytes32 additionalData) = Bytes.readBytes32(_ethWitness, offset);

        bytes32 messageHash = keccak256(

            abi.encodePacked(

                "\x19Ethereum Signed Message:\n60",

                _changePk.pubKeyHash,

                _changePk.nonce,

                _changePk.accountId,

                additionalData

            )

        );

        address recoveredAddress = Utils.recoverAddressFromEthSignature(signature, messageHash);

        return recoveredAddress == _changePk.owner;

    }



    /// @notice Checks that signature is valid for pubkey change message, old version differs by form of the signed message.

    /// @param _ethWitness Signature (65 bytes)

    /// @param _changePk Parsed change pubkey operation

    function verifyChangePubkeyOldECRECOVER(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)

        internal

        pure

        returns (bool)

    {

        (, bytes memory signature) = Bytes.read(_ethWitness, 1, 65); // offset is 1 because we skip type of ChangePubkey

        bytes32 messageHash = keccak256(

            abi.encodePacked(

                "\x19Ethereum Signed Message:\n152",

                "Register zkSync pubkey:\n\n",

                Bytes.bytesToHexASCIIBytes(abi.encodePacked(_changePk.pubKeyHash)),

                "\n",

                "nonce: 0x",

                Bytes.bytesToHexASCIIBytes(Bytes.toBytesFromUInt32(_changePk.nonce)),

                "\n",

                "account id: 0x",

                Bytes.bytesToHexASCIIBytes(Bytes.toBytesFromUInt32(_changePk.accountId)),

                "\n\n",

                "Only sign this message for a trusted client!"

            )

        );

        address recoveredAddress = Utils.recoverAddressFromEthSignature(signature, messageHash);

        return recoveredAddress == _changePk.owner;

    }



    /// @notice Checks that signature is valid for pubkey change message

    /// @param _ethWitness Create2 deployer address, saltArg, codeHash

    /// @param _changePk Parsed change pubkey operation

    function verifyChangePubkeyCREATE2(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)

        internal

        pure

        returns (bool)

    {

        address creatorAddress;

        bytes32 saltArg; // salt arg is additional bytes that are encoded in the CREATE2 salt

        bytes32 codeHash;

        uint256 offset = 1; // offset is 1 because we skip type of ChangePubkey

        (offset, creatorAddress) = Bytes.readAddress(_ethWitness, offset);

        (offset, saltArg) = Bytes.readBytes32(_ethWitness, offset);

        (offset, codeHash) = Bytes.readBytes32(_ethWitness, offset);

        // salt from CREATE2 specification

        bytes32 salt = keccak256(abi.encodePacked(saltArg, _changePk.pubKeyHash));

        // Address computation according to CREATE2 definition: https://eips.ethereum.org/EIPS/eip-1014

        address recoveredAddress = address(

            uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), creatorAddress, salt, codeHash))))

        );

        // This type of change pubkey can be done only once

        return recoveredAddress == _changePk.owner && _changePk.nonce == 0;

    }



    /// @dev Creates block commitment from its data

    /// @dev _offsetCommitment - hash of the array where 1 is stored in chunk where onchainOperation begins and 0 for other chunks

    function createBlockCommitment(

        StoredBlockInfo memory _previousBlock,

        CommitBlockInfo memory _newBlockData,

        bytes memory _offsetCommitment

    ) internal view returns (bytes32 commitment) {

        bytes32 hash = sha256(abi.encodePacked(uint256(_newBlockData.blockNumber), uint256(_newBlockData.feeAccount)));

        hash = sha256(abi.encodePacked(hash, _previousBlock.stateHash));

        hash = sha256(abi.encodePacked(hash, _newBlockData.newStateHash));

        hash = sha256(abi.encodePacked(hash, uint256(_newBlockData.timestamp)));



        bytes memory pubdata = abi.encodePacked(_newBlockData.publicData, _offsetCommitment);



        /// The code below is equivalent to `commitment = sha256(abi.encodePacked(hash, _publicData))`



        /// We use inline assembly instead of this concise and readable code in order to avoid copying of `_publicData` (which saves ~90 gas per transfer operation).



        /// Specifically, we perform the following trick:

        /// First, replace the first 32 bytes of `_publicData` (where normally its length is stored) with the value of `hash`.

        /// Then, we call `sha256` precompile passing the `_publicData` pointer and the length of the concatenated byte buffer.

        /// Finally, we put the `_publicData.length` back to its original location (to the first word of `_publicData`).

        assembly {

            let hashResult := mload(0x40)

            let pubDataLen := mload(pubdata)

            mstore(pubdata, hash)

            // staticcall to the sha256 precompile at address 0x2

            let success := staticcall(gas(), 0x2, pubdata, add(pubDataLen, 0x20), hashResult, 0x20)

            mstore(pubdata, pubDataLen)



            // Use "invalid" to make gas estimation work

            switch success

            case 0 {

                invalid()

            }



            commitment := mload(hashResult)

        }

    }



    /// @notice Checks that deposit is same as operation in priority queue

    /// @param _deposit Deposit data

    /// @param _priorityRequestId Operation's id in priority queue

    function checkPriorityOperation(Operations.Deposit memory _deposit, uint64 _priorityRequestId) internal view {

        Operations.OpType priorReqType = priorityRequests[_priorityRequestId].opType;

        require(priorReqType == Operations.OpType.Deposit, "H"); // incorrect priority op type



        bytes20 hashedPubdata = priorityRequests[_priorityRequestId].hashedPubData;

        require(Operations.checkDepositInPriorityQueue(_deposit, hashedPubdata), "I");

    }



    /// @notice Checks that FullExit is same as operation in priority queue

    /// @param _fullExit FullExit data

    /// @param _priorityRequestId Operation's id in priority queue

    function checkPriorityOperation(Operations.FullExit memory _fullExit, uint64 _priorityRequestId) internal view {

        Operations.OpType priorReqType = priorityRequests[_priorityRequestId].opType;

        require(priorReqType == Operations.OpType.FullExit, "J"); // incorrect priority op type



        bytes20 hashedPubdata = priorityRequests[_priorityRequestId].hashedPubData;

        require(Operations.checkFullExitInPriorityQueue(_fullExit, hashedPubdata), "K");

    }



    // Priority queue



    /// @notice Saves priority request in storage

    /// @dev Calculates expiration block for request, store this request and emit NewPriorityRequest event

    /// @param _opType Rollup operation type

    /// @param _pubData Operation pubdata

    function addPriorityRequest(Operations.OpType _opType, bytes memory _pubData) internal {

        // Expiration block is: current block number + priority expiration delta

        uint64 expirationBlock = uint64(block.number + PRIORITY_EXPIRATION);



        uint64 nextPriorityRequestId = firstPriorityRequestId + totalOpenPriorityRequests;



        bytes20 hashedPubData = Utils.hashBytesToBytes20(_pubData);



        priorityRequests[nextPriorityRequestId] = PriorityOperation({

            hashedPubData: hashedPubData,

            expirationBlock: expirationBlock,

            opType: _opType

        });



        emit NewPriorityRequest(msg.sender, nextPriorityRequestId, _opType, _pubData, uint256(expirationBlock));



        totalOpenPriorityRequests++;

    }



    function increaseBalanceToWithdraw(bytes22 _packedBalanceKey, uint128 _amount) internal {

        uint128 balance = pendingBalances[_packedBalanceKey].balanceToWithdraw;

        pendingBalances[_packedBalanceKey] = PendingBalance(balance.add(_amount), FILLED_GAS_RESERVE_VALUE);

    }



    /// @notice Sends ETH

    /// @param _to Address of recipient

    /// @param _amount Amount of tokens to transfer

    /// @return bool flag indicating that transfer is successful

    function sendETHNoRevert(address payable _to, uint256 _amount) internal returns (bool) {

        (bool callSuccess, ) = _to.call{gas: WITHDRAWAL_GAS_LIMIT, value: _amount}("");

        return callSuccess;

    }



    /// @notice Delegates the call to the additional part of the main contract.

    /// @notice Should be only use to delegate the external calls as it passes the calldata

    /// @notice All functions delegated to additional contract should NOT be nonReentrant

    function delegateAdditional() internal {

        address _target = address(additionalZkSync);

        assembly {

            // The pointer to the free memory slot

            let ptr := mload(0x40)

            // Copy function signature and arguments from calldata at zero position into memory at pointer position

            calldatacopy(ptr, 0x0, calldatasize())

            // Delegatecall method of the implementation contract, returns 0 on error

            let result := delegatecall(gas(), _target, ptr, calldatasize(), 0x0, 0)

            // Get the size of the last return data

            let size := returndatasize()

            // Copy the size length of bytes from return data at zero position to pointer position

            returndatacopy(ptr, 0x0, size)



            // Depending on result value

            switch result

            case 0 {

                // End execution and revert state changes

                revert(ptr, size)

            }

            default {

                // Return data with length of size at pointers position

                return(ptr, size)

            }

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------

{
    "src_chain": {
        "AddLiquidity1": [
            {
                "addLiquidity": "function addLiquidity(bool direction, uint256 index) external override lock {\n require(IOSWAP_RestrictedFactory(factory).isLive(), 'GLOBALLY PAUSED');\n require(isLive, \"PAUSED\");\n Offer storage offer = offers[direction][index];\n require(msg.sender == restrictedLiquidityProvider || msg.sender == offer.provider, \"Not from router or owner\");\n (uint256 newGovBalance, uint256 newToken0Balance, uint256 newToken1Balance) = getBalances();\n uint256 amountIn;\n if (direction) {\n amountIn = newToken1Balance.sub(lastToken1Balance);\n } else {\n amountIn = newToken0Balance.sub(lastToken0Balance);\n }\n require(amountIn > 0, \"No amount in\");\n offer.amount = offer.amount.add(amountIn);\n lastGovBalance = newGovBalance;\n lastToken0Balance = newToken0Balance;\n lastToken1Balance = newToken1Balance;\n emit AddLiquidity(offer.provider, direction, index, amountIn, offer.amount);\n }"
            }
        ],
        "RemoveLiquidity2": [
            {
                "removeLiquidity": "function removeLiquidity(address provider, bool direction, uint256 index, uint256 amountOut, uint256 receivingOut) external override lock {\n require(msg.sender == restrictedLiquidityProvider || msg.sender == provider, \"Not from router or owner\");\n _removeLiquidity(provider, direction, index, amountOut, receivingOut);\n (address tokenA, address tokenB) = direction ? (token1,token0) : (token0,token1);\n _safeTransfer(tokenA, msg.sender, amountOut); \n _safeTransfer(tokenB, msg.sender, receivingOut); \n _sync();\n }"
            },
            {
                "_removeLiquidity": "function _removeLiquidity(address provider, bool direction, uint256 index, uint256 amountOut, uint256 receivingOut) internal {\n require(index > 0, \"Provider liquidity not found\");\n Offer storage offer = offers[direction][index]; \n require(offer.provider == provider, \"Not from provider\");\n if (offer.locked && amountOut > 0) {\n require(offer.expire < block.timestamp, \"Not expired\");\n }\n offer.amount = offer.amount.sub(amountOut);\n offer.receiving = offer.receiving.sub(receivingOut);\n emit RemoveLiquidity(provider, direction, index, amountOut, receivingOut, offer.amount, offer.receiving);\n }"
            }
        ]
    },
    "rel_chain": {
        "Swap": [
            {
                "swap": "function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock onlyEndUser {\n require(isLive, \"PAUSED\");\n uint256 amount0In;\n uint256 amount1In;\n amount0In = IERC20(token0).balanceOf(address(this)).sub(lastToken0Balance);\n amount1In = IERC20(token1).balanceOf(address(this)).sub(lastToken1Balance);\n uint256 protocolFeeCollected;\n if (amount0Out == 0 && amount1Out != 0){\n (amount1Out, protocolFeeCollected) = _swap(to, true, amount0In, amount1Out, data);\n _safeTransfer(token1, to, amount1Out); \n protocolFeeBalance0 = protocolFeeBalance0.add(protocolFeeCollected);\n } else if (amount0Out != 0 && amount1Out == 0){\n (amount0Out, protocolFeeCollected) = _swap(to, false, amount1In, amount0Out, data);\n _safeTransfer(token0, to, amount0Out); \n protocolFeeBalance1 = protocolFeeBalance1.add(protocolFeeCollected);\n } else {\n revert(\"Not supported\");\n }\n _sync();\n }"
            },
            {
                "_swap": "function _swap(address to, bool direction, uint256 amountIn, uint256 _amountOut, bytes calldata data) internal returns (uint256 amountOut, uint256 protocolFeeCollected) {\n uint256 amountInMinusProtocolFee;\n {\n uint256 price;\n uint256 tradeFeeCollected;\n uint256 tradeFee;\n uint256 protocolFee;\n (amountOut, price, tradeFeeCollected, tradeFee, protocolFee) = _getSwappedAmount(direction, amountIn, data);\n require(amountOut >= _amountOut, \"INSUFFICIENT_AMOUNT\");\n if (protocolFee == 0) {\n amountInMinusProtocolFee = amountIn;\n } else {\n protocolFeeCollected = amountIn.mul(tradeFee.mul(protocolFee)).div(FEE_BASE_SQ);\n amountInMinusProtocolFee = amountIn.sub(protocolFeeCollected);\n }\n emit Swap(to, direction, price, amountIn, amountOut, tradeFeeCollected, protocolFeeCollected);\n }\n uint256 remainOut = amountOut;\n uint256 index = first[direction];\n Offer storage offer;\n Offer storage counteroffer;\n while (remainOut > 0 && index != 0) {\n offer = offers[direction][index];\n if (offer.expire < block.timestamp) {\n index = _dequeue(direction, index);\n } else {\n counteroffer = offers[!direction][index];\n uint256 amount = offer.amount;\n if (remainOut >= amount) {\n \n remainOut = remainOut.sub(amount);\n uint256 providerShare = amountInMinusProtocolFee.mul(amount).div(amountOut);\n counteroffer.reserve = counteroffer.reserve.add(providerShare);\n offer.amount = 0;\n emit SwappedOneProvider(offer.provider, direction, amount, providerShare, 0, counteroffer.reserve);\n \n index = _dequeue(direction, index);\n } else {\n \n uint256 providerShare = amountInMinusProtocolFee.mul(remainOut).div(amountOut);\n counteroffer.reserve = counteroffer.reserve.add(providerShare);\n offer.amount = offer.amount.sub(remainOut);\n emit SwappedOneProvider(offer.provider, direction, remainOut, providerShare, offer.amount, counteroffer.reserve);\n remainOut = 0;\n }\n }\n }\n require(remainOut == 0, \"Amount exceeds available fund\");\n }"
            }
        ],
        "SwappedOneProvider": [
            {
                "removeLiquidity": "function removeLiquidity(address provider, bool direction, uint256 unstake, uint256 afterIndex, uint256 amountOut, uint256 reserveOut, uint256 expire, bool enable) external override lock {\n require(msg.sender == oracleLiquidityProvider || msg.sender == provider, \"Not from router or owner\");\n require(expire > block.timestamp, \"Already expired\");\n uint256 index = providerOfferIndex[provider];\n require(index > 0, \"Provider liquidity not found\");\n Offer storage offer = offers[direction][index];\n uint256 newAmount = offer.amount.sub(amountOut);\n function minLotSize(...) {...}\nrequire(newAmount == 0 || newAmount >= minLotSize(direction), \"Minium lot size not met\");\n uint256 staked = offer.staked.sub(unstake);\n offer.enabled = enable;\n if (amountOut > 0)\n offer.amount = newAmount;\n if (unstake > 0)\n offer.staked = staked;\n offer.reserve = offer.reserve.sub(reserveOut);\n offer.expire = expire;\n if (enable) {\n if (offer.isActive) {\n if (unstake > 0 && (index != afterIndex || offers[direction][offer.next].staked >= staked)) {\n _halfDequeue(direction, index);\n _enqueue(direction, index, staked, afterIndex, newAmount, expire);\n }\n } else {\n _enqueue(direction, index, staked, afterIndex, newAmount, expire);\n }\n } else {\n if (offer.isActive)\n _dequeue(direction, index);\n }\n if (unstake > 0) {\n stakeBalance = stakeBalance.sub(unstake);\n _safeTransfer(govToken, msg.sender, unstake); \n }\n if (amountOut > 0 || reserveOut > 0)\n _safeTransfer(direction ? token1 : token0, msg.sender, amountOut.add(reserveOut)); \n emit RemoveLiquidity(provider, direction, unstake, amountOut, reserveOut, offer.staked, offer.amount, offer.reserve, expire, enable);\n _sync();\n }"
            }
        ]
    },
    "det_chain": {
        "AddLiquidity1": [
            {
                "addLiquidity": "function addLiquidity(bool direction, uint256 index) external override lock {\n require(IOSWAP_RestrictedFactory(factory).isLive(), 'GLOBALLY PAUSED');\n require(isLive, \"PAUSED\");\n Offer storage offer = offers[direction][index];\n require(msg.sender == restrictedLiquidityProvider || msg.sender == offer.provider, \"Not from router or owner\");\n (uint256 newGovBalance, uint256 newToken0Balance, uint256 newToken1Balance) = getBalances();\n uint256 amountIn;\n if (direction) {\n amountIn = newToken1Balance.sub(lastToken1Balance);\n } else {\n amountIn = newToken0Balance.sub(lastToken0Balance);\n }\n require(amountIn > 0, \"No amount in\");\n offer.amount = offer.amount.add(amountIn);\n lastGovBalance = newGovBalance;\n lastToken0Balance = newToken0Balance;\n lastToken1Balance = newToken1Balance;\n emit AddLiquidity(offer.provider, direction, index, amountIn, offer.amount);\n }"
            }
        ],
        "RemoveLiquidity2": [
            {
                "removeLiquidity": "function removeLiquidity(address provider, bool direction, uint256 index, uint256 amountOut, uint256 receivingOut) external override lock {\n require(msg.sender == restrictedLiquidityProvider || msg.sender == provider, \"Not from router or owner\");\n _removeLiquidity(provider, direction, index, amountOut, receivingOut);\n (address tokenA, address tokenB) = direction ? (token1,token0) : (token0,token1);\n _safeTransfer(tokenA, msg.sender, amountOut); \n _safeTransfer(tokenB, msg.sender, receivingOut); \n _sync();\n }"
            }
        ],
        "Swap3": [
            {
                "swap": "function swap(uint256 amount0Out, uint256 amount1Out, address to, address trader, bytes calldata ) external override lock {\n if (!IOSWAP_OracleFactory(whitelistFactory).isWhitelisted(msg.sender)) {\n require(tx.origin == msg.sender && !Address.isContract(msg.sender) && trader == msg.sender, \"Invalid trader\");\n }\n require(isLive, \"PAUSED\");\n uint256 amount0In = IERC20(token0).balanceOf(address(this)).sub(lastToken0Balance);\n uint256 amount1In = IERC20(token1).balanceOf(address(this)).sub(lastToken1Balance);\n uint256 amountOut;\n uint256 protocolFeeCollected;\n if (amount0Out == 0 && amount1Out != 0){\n (amountOut, protocolFeeCollected) = _swap(true, amount0In, trader);\n require(amountOut >= amount1Out, \"INSUFFICIENT_AMOUNT\");\n _safeTransfer(token1, to, amountOut); \n protocolFeeBalance0 = protocolFeeBalance0.add(protocolFeeCollected);\n } else if (amount0Out != 0 && amount1Out == 0){\n (amountOut, protocolFeeCollected) = _swap(false, amount1In, trader);\n require(amountOut >= amount0Out, \"INSUFFICIENT_AMOUNT\");\n _safeTransfer(token0, to, amountOut); \n protocolFeeBalance1 = protocolFeeBalance1.add(protocolFeeCollected);\n } else {\n revert(\"Not supported\");\n }\n _sync();\n }"
            },
            {
                "_swap": "function _swap(bool direction, uint256 amountIn, address trader) internal returns (uint256 totalOut, uint256 totalProtocolFeeCollected) {\n (uint256[] memory idxList, uint256[] memory amountList) = _decodeData(0xa4);\n address oracle;\n uint256[2] memory fee;\n (oracle, fee[0], fee[1]) = IOSWAP_RestrictedFactory(factory).checkAndGetOracleSwapParams(token0, token1);\n uint256 totalIn;\n uint256 totalTradeFeeCollected;\n for (uint256 index = 0 ; index < idxList.length ; index++) {\n totalIn = totalIn.add(amountList[index]);\n uint256[3] memory amount;\n uint256 thisIn = amountList[index].mul(amountIn).div(1e18);\n (amount[0], amount[1], amount[2]) = _swap2(direction, trader, idxList[index], thisIn, oracle, fee);\n totalOut = totalOut.add(amount[0]);\n totalTradeFeeCollected = totalTradeFeeCollected.add(amount[1]);\n totalProtocolFeeCollected = totalProtocolFeeCollected.add(amount[2]);\n }\n require(totalIn == 1e18, \"Invalid input\");\n emit Swap(trader, direction, amountIn, totalOut, totalTradeFeeCollected, totalProtocolFeeCollected);\n }"
            }
        ]
    }
}
{
    "src_chain": {
        "Deposit1": [
            {
                "depositTokens": "function depositTokens(\n address receiver, \n address token, \n uint256 value, \n uint256 toChainId \n ) \n external\n payable\n notFrozen\n {\n require(functionMapping & 1 == 0, \"locked\"); \n require(receiver != address(0), \"Incorrect receiver address\");\n address pair_token = _deposit(token, value, toChainId);\n emit Deposit(token, receiver, value, toChainId, pair_token);\n }"
            },
            {
                "_deposit": "function _deposit(\n address token, \n uint256 value, \n uint256 toChainId \n ) \n internal \n returns (address pair_token) \n {\n Token memory pair = tokenPair[toChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n pair_token = pair.token;\n uint256 fee = msg.value;\n if (token <= MAX_NATIVE_COINS) {\n require(value <= msg.value, \"Wrong value\");\n fee -= value;\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).burnFrom(msg.sender, value);\n } else {\n tokenDeposits[token] += value;\n token.safeTransferFrom(msg.sender, address(this), value);\n }\n }\n if (fee != 0) {\n feeTo.safeTransferETH(fee);\n emit Fee(msg.sender, fee);\n }\n }"
            }
        ],
        "BridgeToContract2": [
            {
                "bridgeToContract": "function bridgeToContract(\n address receiver, \n address token, \n uint256 value, \n uint256 toChainId, \n address toContract, \n bytes memory data \n )\n external\n payable\n notFrozen\n {\n require(functionMapping & 2 == 0, \"locked\"); \n require(receiver != address(0), \"Incorrect receiver address\");\n address pair_token = _deposit(token, value, toChainId);\n emit BridgeToContract(token, receiver, value, toChainId, pair_token, toContract, data);\n }"
            },
            {
                "_deposit": "function _deposit(\n address token, \n uint256 value, \n uint256 toChainId \n ) \n internal \n returns (address pair_token) \n {\n Token memory pair = tokenPair[toChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n pair_token = pair.token;\n uint256 fee = msg.value;\n if (token <= MAX_NATIVE_COINS) {\n require(value <= msg.value, \"Wrong value\");\n fee -= value;\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).burnFrom(msg.sender, value);\n } else {\n tokenDeposits[token] += value;\n token.safeTransferFrom(msg.sender, address(this), value);\n }\n }\n if (fee != 0) {\n feeTo.safeTransferETH(fee);\n emit Fee(msg.sender, fee);\n }\n }"
            }
        ]
    },
    "rel_chain": {
        "Claim": [
            {
                "claim": "function claim(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n isTxProcessed[fromChainId][txId] = true;\n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n function safeTransfer(...) {...}\ntoken.safeTransfer(to, value);\n }\n }\n emit Claim(token, to, value, txId, fromChainId, pair.token);\n }"
            }
        ],
        "claimToContract": [
            {
                "claimToContract": "function claimToContract(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n address toContract, \n bytes memory data, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(functionMapping & 4 == 0, \"locked\"); \n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n {\n isTxProcessed[fromChainId][txId] = true;\n \n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid, toContract, data));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n }\n \n if(isContract(toContract) && toContract != address(this)) {\n if (token <= MAX_NATIVE_COINS) {\n IContractCaller(contractCaller).callContract{value: value}(to, token, value, toContract, data);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(contractCaller, value);\n } else {\n tokenDeposits[token] -= value;\n token.safeTransfer(contractCaller, value);\n }\n IContractCaller(contractCaller).callContract(to, token, value, toContract, data); \n }\n } else { \n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n token.safeTransfer(to, value);\n }\n }\n }\n emit ClaimToContract(token, to, value, txId, fromChainId, pair.token, toContract);\n }"
            },
            {
                "callContract": "function callContract(address user, address token, uint256 value, address toContract, bytes memory data) external payable onlyBridge {\n if (token <= MAX_NATIVE_COINS) {\n value = msg.value;\n uint balanceBefore = address(this).balance - value; \n (bool success,) = toContract.call{value: value}(data);\n if (success) value = address(this).balance - balanceBefore; \n if (value != 0) user.safeTransferETH(value); \n } else {\n function safeApprove(...) {...}\nfunction safeTransfer(...) {...}\ntoken.safeApprove(toContract, value);\n (bool success,) = toContract.call{value: 0}(data);\n if (success) value = IERC223TokenCloned(token).allowance(address(this), toContract); \n if (value != 0) { \n token.safeApprove(toContract, 0);\n token.safeTransfer(user, value); \n } \n }\n }"
            }
        ]
    },
    "det_chain": {
        "Claim1": [
            {
                "claim": "function claim(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n isTxProcessed[fromChainId][txId] = true;\n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n function safeTransfer(...) {...}\ntoken.safeTransfer(to, value);\n }\n }\n emit Claim(token, to, value, txId, fromChainId, pair.token);\n }"
            }
        ],
        "ClaimToContract2": [
            {
                "claimToContract": "function claimToContract(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n address toContract, \n bytes memory data, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(functionMapping & 4 == 0, \"locked\"); \n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n {\n isTxProcessed[fromChainId][txId] = true;\n \n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid, toContract, data));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n }\n \n if(isContract(toContract) && toContract != address(this)) {\n if (token <= MAX_NATIVE_COINS) {\n IContractCaller(contractCaller).callContract{value: value}(to, token, value, toContract, data);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(contractCaller, value);\n } else {\n tokenDeposits[token] -= value;\n token.safeTransfer(contractCaller, value);\n }\n IContractCaller(contractCaller).callContract(to, token, value, toContract, data); \n }\n } else { \n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n token.safeTransfer(to, value);\n }\n }\n }\n emit ClaimToContract(token, to, value, txId, fromChainId, pair.token, toContract);\n }"
            },
            {
                "callContract": "function callContract(address user, address token, uint256 value, address toContract, bytes memory data) external payable onlyBridge {\n if (token <= MAX_NATIVE_COINS) {\n value = msg.value;\n uint balanceBefore = address(this).balance - value; \n (bool success,) = toContract.call{value: value}(data);\n if (success) value = address(this).balance - balanceBefore; \n if (value != 0) user.safeTransferETH(value); \n } else {\n function safeApprove(...) {...}\nfunction safeTransfer(...) {...}\ntoken.safeApprove(toContract, value);\n (bool success,) = toContract.call{value: 0}(data);\n if (success) value = IERC223TokenCloned(token).allowance(address(this), toContract); \n if (value != 0) { \n token.safeApprove(toContract, 0);\n token.safeTransfer(user, value); \n } \n }\n }"
            }
        ]
    }
}
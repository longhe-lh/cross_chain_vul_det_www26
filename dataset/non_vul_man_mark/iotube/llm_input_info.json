{
    "src_chain": {
        "Receipt1": [
            {
                "depositTo": "function depositTo(address _token, address _to, uint256 _amount) public whenNotPaused payable {\n require(_to != address(0), \"invalid destination\");\n bool isCoin = false;\n uint256 fee = msg.value;\n if (_token == address(0)) {\n require(msg.value >= _amount, \"insufficient msg.value\");\n fee = msg.value - _amount;\n wrappedCoin.deposit.value(_amount)();\n _token = address(wrappedCoin);\n isCoin = true;\n }\n require(fee >= depositFee, \"insufficient fee\");\n for (uint256 i = 0; i < tokenLists.length; i++) {\n if (tokenLists[i].isAllowed(_token)) {\n require(_amount >= tokenLists[i].minAmount(_token), \"amount too low\");\n require(_amount <= tokenLists[i].maxAmount(_token), \"amount too high\");\n if (tokenSafes[i] == address(0)) {\n require(!isCoin && safeTransferFrom(_token, msg.sender, address(this), _amount), \"fail to transfer token to cashier\");\n \n (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x42966c68, _amount));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"fail to burn token\");\n } else {\n if (isCoin) {\n require(safeTransfer(_token, tokenSafes[i], _amount), \"failed to put into safe\");\n } else {\n require(safeTransferFrom(_token, msg.sender, tokenSafes[i], _amount), \"failed to put into safe\");\n }\n }\n counts[_token] += 1;\n emit Receipt(_token, counts[_token], msg.sender, _to, _amount, fee);\n return;\n }\n }\n revert(\"not a whitelisted token\");\n }"
            },
            {
                "safeTransferFrom": "function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n \n (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x23b872dd, _from, _to, _amount));\n return success && (data.length == 0 || abi.decode(data, (bool)));\n }"
            },
            {
                "safeTransfer": "function safeTransfer(address _token, address _to, uint256 _amount) internal returns (bool) {\n \n (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0xa9059cbb, _to, _amount));\n return success && (data.length == 0 || abi.decode(data, (bool)));\n }"
            }
        ]
    },
    "rel_chain": {},
    "det_chain": {
        "TokenAdded1": [
            {
                "addToken": "function addToken(address _token, uint256 _min, uint256 _max) public onlyOwner returns (bool success_) {\n if (activateItem(_token)) {\n require(_min > 0 && _max > _min, \"invalid parameters\");\n settings[_token] = Setting(_min, _max);\n emit TokenAdded(_token, _min, _max);\n success_ = true;\n }\n }"
            },
            {
                "activateItem": "function activateItem(address _item) internal returns (bool) {\n if (existAndActives[_item].active) {\n return false;\n }\n if (!existAndActives[_item].exist) {\n items.push(_item);\n }\n num++;\n existAndActives[_item] = ExistAndActive(true, true);\n return true;\n }"
            }
        ],
        "TokenRemoved2": [
            {
                "deactivateItem": "function deactivateItem(address _item) internal returns (bool) {\n if (existAndActives[_item].exist && existAndActives[_item].active) {\n num--;\n existAndActives[_item].active = false;\n return true;\n }\n return false;\n }"
            }
        ]
    }
}
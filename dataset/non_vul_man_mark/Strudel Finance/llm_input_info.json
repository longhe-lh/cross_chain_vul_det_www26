{
    "src_chain": {
        "TokenDeposit1": [
            {
                "deposit": "function deposit(\n address _owner,\n uint256 _amountOrTokenId,\n uint16 _color\n ) public {\n require(_owner == msg.sender, \"owner different from msg.sender\");\n\n _deposit(_amountOrTokenId, _color);\n }"
            },
            {
                "_deposit": "function _deposit(uint256 _amountOrTokenId, uint16 _color) internal {\n TransferrableToken token = tokens[_color].addr;\n\n require(address(token) != address(0), \"Token color already registered\");\n\n require(\n _amountOrTokenId > 0 || _color > 32769,\n \"no 0 deposits for fungible tokens\"\n );\n\n bytes32 _tokenData;\n\n if (_color >= NST_FIRST_COLOR) {\n IERC1948 nst = IERC1948(address(token));\n\n \n\n _tokenData = nst.readData(_amountOrTokenId);\n }\n\n token.transferFrom(msg.sender, address(this), _amountOrTokenId);\n\n bytes32 tipHash = bridge.tipHash();\n\n uint256 timestamp;\n\n (, timestamp, , ) = bridge.periods(tipHash);\n\n depositCount++;\n\n deposits[depositCount] = Deposit({\n time: uint32(timestamp),\n owner: msg.sender,\n color: _color,\n amount: _amountOrTokenId\n });\n\n if (_color >= NST_FIRST_COLOR) {\n tokenData[depositCount] = _tokenData;\n\n emit NewDepositV2(\n depositCount,\n msg.sender,\n _color,\n _amountOrTokenId,\n _tokenData\n );\n } else {\n emit NewDeposit(depositCount, msg.sender, _color, _amountOrTokenId);\n }\n }"
            }
        ]
    },
    "rel_chain": {
        "mint": [
            {
                "proofOpReturnAndMint": "function proofOpReturnAndMint(\n bytes calldata _header,\n bytes calldata _proof,\n bytes4 _version,\n bytes4 _locktime,\n uint256 _index,\n uint32 _crossingOutputIndex,\n bytes calldata _vin,\n bytes calldata _vout\n ) external returns (bool) {\n return\n _provideProof(\n _header,\n _proof,\n _version,\n _locktime,\n _index,\n _crossingOutputIndex,\n _vin,\n _vout\n );\n }"
            },
            {
                "_provideProof": "function _provideProof(\n bytes memory _header,\n bytes memory _proof,\n bytes4 _version,\n bytes4 _locktime,\n uint256 _index,\n uint32 _crossingOutputIndex,\n bytes memory _vin,\n bytes memory _vout\n ) internal returns (bool) {\n bytes32 txId = abi\n .encodePacked(_version, _vin, _vout, _locktime)\n .ref(0)\n .hash256();\n\n bytes32 outpoint = makeCompressedOutpoint(txId, _crossingOutputIndex);\n\n require(!knownOutpoints[outpoint], \"already processed outputs\");\n\n _checkInclusion(\n _header.ref(0).tryAsHeader().assertValid(),\n _proof.ref(0).tryAsMerkleArray().assertValid(),\n _index,\n txId\n );\n\n \n\n knownOutpoints[outpoint] = true;\n\n \n\n address account;\n\n uint256 amount;\n\n (account, amount) = doPayouts(\n _vout.ref(0).tryAsVout(),\n _crossingOutputIndex\n );\n\n emit Crossing(txId, account, amount, _crossingOutputIndex);\n\n return true;\n }"
            },
            {
                "doPayouts": "function doPayouts(\n bytes29 _vout,\n uint32 _crossingOutputIndex\n ) internal returns (address account, uint256 amount) {\n bytes29 output = _vout.indexVout(_crossingOutputIndex);\n\n \n\n amount = output.value() * 10 ** 10; \n\n require(amount > 0, \"output has 0 value\");\n\n bytes29 opReturnPayload = output.scriptPubkey().opReturnPayload();\n\n require(\n opReturnPayload.len() == ADDR_LEN + 3,\n \"invalid op-return payload length\"\n );\n\n require(\n bytes3(opReturnPayload.index(0, 3)) == PROTOCOL_ID,\n \"invalid protocol id\"\n );\n\n account = address(bytes20(opReturnPayload.index(3, ADDR_LEN)));\n\n uint256 sqrtVbtcBefore = Babylonian.sqrt(totalSupply());\n\n _mint(account, amount);\n\n uint256 sqrtVbtcAfter = Babylonian.sqrt(totalSupply());\n\n \n\n \n\n \n\n uint256 rewardAmount = BTC_CAP\n .mul(3)\n .mul(sqrtVbtcAfter)\n .add(sqrtVbtcBefore ** 3)\n .sub(BTC_CAP.mul(3).mul(sqrtVbtcBefore))\n .sub(sqrtVbtcAfter ** 3)\n .div(3)\n .div(BTC_CAP_SQRT);\n\n strudel.mint(account, rewardAmount);\n\n strudel.mint(owner(), rewardAmount.div(devFundDivRate));\n }"
            }
        ],
        "withdraw": [
            {
                "challengeYoungestInput": "function challengeYoungestInput(\n bytes32[] memory _youngerInputProof,\n bytes32[] memory _exitingTxProof,\n uint8 _outputIndex,\n uint8 _inputIndex\n ) public {\n \n\n bytes32 txHash;\n\n bytes memory txData;\n\n (, txHash, txData) = TxLib.validateProof(\n 32 * (_youngerInputProof.length + 2) + 64,\n _exitingTxProof\n );\n\n bytes32 utxoId = bytes32(\n (uint256(_outputIndex) << 120) | uint120(uint256(txHash))\n );\n\n \n\n require(exits[utxoId].amount > 0, \"There is no exit for this UTXO\");\n\n TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n\n \n\n (, txHash, ) = TxLib.validateProof(96, _youngerInputProof);\n\n \n\n require(\n txHash == exitingTx.ins[_inputIndex].outpoint.hash,\n \"Given output is not referenced in exiting tx\"\n );\n\n uint32 youngerInputTimestamp;\n\n (, youngerInputTimestamp) = bridge.periods(_youngerInputProof[0]);\n\n require(\n youngerInputTimestamp > 0,\n \"The referenced period was not submitted to bridge\"\n );\n\n require(\n exits[utxoId].priorityTimestamp < youngerInputTimestamp,\n \"Challenged input should be older\"\n );\n\n \n\n msg.sender.transfer(exits[utxoId].stake);\n\n \n\n delete exits[utxoId];\n }"
            }
        ]
    },
    "det_chain": {
        "TokenWithdraw1": [
            {
                "startExit": "function startExit(\n bytes32[] memory _youngestInputProof,\n bytes32[] memory _proof,\n uint8 _outputIndex,\n uint8 _inputIndex\n ) public payable {\n require(\n msg.value >= exitStake,\n \"Not enough ether sent to pay for exit stake\"\n );\n\n uint32 timestamp;\n\n (, timestamp) = bridge.periods(_proof[0]);\n\n require(\n timestamp > 0,\n \"The referenced period was not submitted to bridge\"\n );\n\n if (_youngestInputProof.length > 0) {\n (, timestamp) = bridge.periods(_youngestInputProof[0]);\n\n require(\n timestamp > 0,\n \"The referenced period was not submitted to bridge\"\n );\n }\n\n \n\n bytes32 txHash;\n\n bytes memory txData;\n\n uint64 txPos;\n\n (txPos, txHash, txData) = TxLib.validateProof(\n 32 * (_youngestInputProof.length + 2) + 64,\n _proof\n );\n\n \n\n TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n\n TxLib.Output memory out = exitingTx.outs[_outputIndex];\n\n bytes32 utxoId = bytes32(\n (uint256(_outputIndex) << 120) | uint120(uint256(txHash))\n );\n\n require(out.owner == msg.sender, \"Only UTXO owner can start exit\");\n\n require(out.value > 0, \"UTXO has no value\");\n\n require(\n exits[utxoId].amount == 0,\n \"The exit for UTXO has already been started\"\n );\n\n require(\n !exits[utxoId].finalized,\n \"The exit for UTXO has already been finalized\"\n );\n\n uint256 priority;\n\n if (_youngestInputProof.length > 0) {\n \n\n bytes32 inputTxHash;\n\n (txPos, inputTxHash, ) = TxLib.validateProof(\n 96,\n _youngestInputProof\n );\n\n require(\n inputTxHash == exitingTx.ins[_inputIndex].outpoint.hash,\n \"Input from the proof is not referenced in exiting tx\"\n );\n\n if (isNft(out.color)) {\n priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n\n nftExitCounter++;\n } else {\n priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n }\n } else {\n require(\n exitingTx.txType == TxLib.TxType.Deposit,\n \"Expected deposit tx\"\n );\n\n if (isNft(out.color)) {\n priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n\n nftExitCounter++;\n } else {\n priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n }\n }\n\n function insert(...) {...}\ntokens[out.color].insert(priority);\n\n exits[utxoId] = Exit({\n owner: out.owner,\n color: out.color,\n amount: out.value,\n finalized: false,\n stake: exitStake,\n priorityTimestamp: timestamp\n });\n\n emit ExitStarted(txHash, _outputIndex, out.color, out.owner, out.value);\n }"
            },
            {
                "insert": "function insert(Token storage self, uint256 k) public {\n self.heapList.push(k);\n\n function add(...) {...}\nfunction percUp(...) {...}\nself.currentSize = self.currentSize.add(1);\n\n percUp(self, self.currentSize);\n }"
            }
        ],
        "TokenMint2": [
            {
                "finalizeExits": "function finalizeExits(uint16 _color) public {\n bytes32 utxoId;\n\n uint256 exitableAt;\n\n Exit memory currentExit;\n\n (utxoId, exitableAt) = getNextExit(_color);\n\n require(tokens[_color].currentSize > 0, \"Queue empty for color.\");\n\n for (uint i = 0; i < 20; i++) {\n \n\n if (exitableAt > block.timestamp) {\n return;\n }\n\n currentExit = exits[utxoId];\n\n if (currentExit.owner != address(0) || currentExit.amount != 0) {\n \n\n \n\n if (isNft(currentExit.color)) {\n tokens[currentExit.color].addr.transferFrom(\n address(this),\n currentExit.owner,\n currentExit.amount\n );\n } else {\n tokens[currentExit.color].addr.approve(\n address(this),\n currentExit.amount\n );\n\n tokens[currentExit.color].addr.transferFrom(\n address(this),\n currentExit.owner,\n currentExit.amount\n );\n }\n\n \n\n address(uint160(currentExit.owner)).send(currentExit.stake);\n }\n\n tokens[currentExit.color].delMin();\n\n exits[utxoId].finalized = true;\n\n if (tokens[currentExit.color].currentSize > 0) {\n (utxoId, exitableAt) = getNextExit(_color);\n } else {\n return;\n }\n }\n }"
            }
        ]
    }
}
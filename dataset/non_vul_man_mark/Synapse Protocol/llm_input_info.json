{
    "src_chain": {
        "TokenDeposit1": [
            {
                "deposit": "function deposit(\n address to,\n uint256 chainId,\n IERC20 token,\n uint256 amount\n ) external nonReentrant whenNotPaused {\n emit TokenDeposit(to, chainId, token, amount);\n\n token.safeTransferFrom(msg.sender, address(this), amount);\n }"
            }
        ],
        "TokenDepositAndSwap2": [
            {
                "depositAndSwap": "function depositAndSwap(\n address to,\n uint256 chainId,\n IERC20 token,\n uint256 amount,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline\n ) external nonReentrant whenNotPaused {\n emit TokenDepositAndSwap(\n to,\n chainId,\n token,\n amount,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline\n );\n\n token.safeTransferFrom(msg.sender, address(this), amount);\n }"
            }
        ],
        "TokenRedeem3": [
            {
                "redeem": "function redeem(\n address to,\n uint256 chainId,\n ERC20Burnable token,\n uint256 amount\n ) external nonReentrant whenNotPaused {\n emit TokenRedeem(to, chainId, token, amount);\n\n token.burnFrom(msg.sender, amount);\n }"
            }
        ],
        "TokenRedeemAndSwap4": [
            {
                "redeemAndSwap": "function redeemAndSwap(\n address to,\n uint256 chainId,\n ERC20Burnable token,\n uint256 amount,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline\n ) external nonReentrant whenNotPaused {\n emit TokenRedeemAndSwap(\n to,\n chainId,\n token,\n amount,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline\n );\n\n token.burnFrom(msg.sender, amount);\n }"
            }
        ],
        "TokenRedeemAndRemove5": [
            {
                "redeemAndRemove": "function redeemAndRemove(\n address to,\n uint256 chainId,\n ERC20Burnable token,\n uint256 amount,\n uint8 swapTokenIndex,\n uint256 swapMinAmount,\n uint256 swapDeadline\n ) external nonReentrant whenNotPaused {\n emit TokenRedeemAndRemove(\n to,\n chainId,\n token,\n amount,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline\n );\n\n token.burnFrom(msg.sender, amount);\n }"
            }
        ]
    },
    "rel_chain": {
        "mint": [
            {
                "mint": "function mint(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n emit TokenMint(to, token, amount.sub(fee), fee, kappa);\n\n function mint(...) {...}\ntoken.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n }"
            }
        ],
        "withdraw": [
            {
                "withdraw": "function withdraw(\n address to,\n IERC20 token,\n uint256 amount,\n uint256 fee,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\n IWETH9(WETH_ADDRESS).withdraw(amount.sub(fee));\n\n (bool success, ) = to.call{value: amount.sub(fee)}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenWithdraw(to, token, amount, fee, kappa);\n } else {\n emit TokenWithdraw(to, token, amount, fee, kappa);\n\n token.safeTransfer(to, amount.sub(fee));\n }\n }"
            }
        ],
        "mintAndSwap": [
            {
                "mintAndSwap": "function mintAndSwap(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateSwap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee)\n );\n\n if (expectedOutput >= minDy) {\n \n\n function mint(...) {...}\ntoken.mint(address(this), amount);\n\n token.safeIncreaseAllowance(address(pool), amount);\n\n try\n ISwap(pool).swap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee),\n minDy,\n deadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(tokenIndexTo);\n\n if (\n address(swappedTokenTo) == WETH_ADDRESS &&\n WETH_ADDRESS != address(0)\n ) {\n IWETH9(WETH_ADDRESS).withdraw(finalSwappedAmount);\n\n (bool success, ) = to.call{value: finalSwappedAmount}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n } else {\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n }\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n } else {\n function mint(...) {...}\ntoken.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n }"
            }
        ],
        "withdrawAndRemove": [
            {
                "withdrawAndRemove": "function withdrawAndRemove(\n address to,\n IERC20 token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 swapTokenIndex,\n uint256 swapMinAmount,\n uint256 swapDeadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateRemoveLiquidityOneToken(\n amount.sub(fee),\n swapTokenIndex\n );\n\n if (expectedOutput >= swapMinAmount) {\n token.safeIncreaseAllowance(address(pool), amount.sub(fee));\n\n try\n ISwap(pool).removeLiquidityOneToken(\n amount.sub(fee),\n swapTokenIndex,\n swapMinAmount,\n swapDeadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(swapTokenIndex);\n\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n finalSwappedAmount,\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n true,\n kappa\n );\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n amount.sub(fee),\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n false,\n kappa\n );\n }\n } else {\n token.safeTransfer(to, amount.sub(fee));\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n amount.sub(fee),\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n false,\n kappa\n );\n }\n }"
            }
        ]
    },
    "det_chain": {
        "TokenWithdraw1": [
            {
                "withdraw": "function withdraw(\n address to,\n IERC20 token,\n uint256 amount,\n uint256 fee,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\n IWETH9(WETH_ADDRESS).withdraw(amount.sub(fee));\n\n (bool success, ) = to.call{value: amount.sub(fee)}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenWithdraw(to, token, amount, fee, kappa);\n } else {\n emit TokenWithdraw(to, token, amount, fee, kappa);\n\n token.safeTransfer(to, amount.sub(fee));\n }\n }"
            }
        ],
        "TokenMintAndSwap2": [
            {
                "mintAndSwap": "function mintAndSwap(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateSwap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee)\n );\n\n if (expectedOutput >= minDy) {\n \n\n token.mint(address(this), amount);\n\n token.safeIncreaseAllowance(address(pool), amount);\n\n try\n ISwap(pool).swap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee),\n minDy,\n deadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(tokenIndexTo);\n\n if (\n address(swappedTokenTo) == WETH_ADDRESS &&\n WETH_ADDRESS != address(0)\n ) {\n IWETH9(WETH_ADDRESS).withdraw(finalSwappedAmount);\n\n (bool success, ) = to.call{value: finalSwappedAmount}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n } else {\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n }\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n } else {\n token.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n }"
            }
        ],
        "TokenMint3": [
            {
                "mint": "function mint(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n emit TokenMint(to, token, amount.sub(fee), fee, kappa);\n\n token.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n }"
            }
        ],
        "TokenMintAndSwap4": [
            {
                "mintAndSwap": "function mintAndSwap(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateSwap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee)\n );\n\n if (expectedOutput >= minDy) {\n \n\n token.mint(address(this), amount);\n\n token.safeIncreaseAllowance(address(pool), amount);\n\n try\n ISwap(pool).swap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee),\n minDy,\n deadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(tokenIndexTo);\n\n if (\n address(swappedTokenTo) == WETH_ADDRESS &&\n WETH_ADDRESS != address(0)\n ) {\n IWETH9(WETH_ADDRESS).withdraw(finalSwappedAmount);\n\n (bool success, ) = to.call{value: finalSwappedAmount}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n } else {\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n }\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n } else {\n token.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n }"
            }
        ],
        "TokenWithdrawAndRemove5": [
            {
                "withdrawAndRemove": "function withdrawAndRemove(\n address to,\n IERC20 token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 swapTokenIndex,\n uint256 swapMinAmount,\n uint256 swapDeadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateRemoveLiquidityOneToken(\n amount.sub(fee),\n swapTokenIndex\n );\n\n if (expectedOutput >= swapMinAmount) {\n token.safeIncreaseAllowance(address(pool), amount.sub(fee));\n\n try\n ISwap(pool).removeLiquidityOneToken(\n amount.sub(fee),\n swapTokenIndex,\n swapMinAmount,\n swapDeadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(swapTokenIndex);\n\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n finalSwappedAmount,\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n true,\n kappa\n );\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n amount.sub(fee),\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n false,\n kappa\n );\n }\n } else {\n token.safeTransfer(to, amount.sub(fee));\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n amount.sub(fee),\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n false,\n kappa\n );\n }\n }"
            }
        ]
    }
}
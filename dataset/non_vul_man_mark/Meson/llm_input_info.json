{
    "src_chain": {
        "SwapPosted1": [
            {
                "postSwap": "function postSwap(uint256 encodedSwap, bytes32 r, bytes32 s, uint8 v, uint200 postingValue)\n external matchProtocolVersion(encodedSwap) forInitialChain(encodedSwap)\n {\n require(_postedSwaps[encodedSwap] == 0, \"Swap already exists\");\n uint256 amount = _amountFrom(encodedSwap);\n require(amount <= MAX_SWAP_AMOUNT, \"For security reason, amount cannot be greater than 100k\");\n uint256 delta = _expireTsFrom(encodedSwap) - block.timestamp;\n \n require(delta > MIN_BOND_TIME_PERIOD, \"Expire ts too early\");\n require(delta < MAX_BOND_TIME_PERIOD, \"Expire ts too late\");\n uint40 poolIndex = _poolIndexFromPosted(postingValue);\n if (poolIndex > 0) {\n \n require(poolOfAuthorizedAddr[_msgSender()] == poolIndex, \"Signer should be an authorized address of the given pool\");\n } \n address initiator = _initiatorFromPosted(postingValue);\n _checkRequestSignature(encodedSwap, r, s, v, initiator);\n _postedSwaps[encodedSwap] = postingValue;\n uint8 tokenIndex = _inTokenIndexFrom(encodedSwap);\n _unsafeDepositToken(tokenForIndex[tokenIndex], initiator, amount, tokenIndex);\n emit SwapPosted(encodedSwap);\n }"
            },
            {
                "_checkRequestSignature": "function _checkRequestSignature(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_33 : TRON_SIGN_HEADER, encodedSwap));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER, encodedSwap));\n } else {\n bytes32 typehash = REQUEST_TYPE_HASH;\n assembly {\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 32))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }"
            },
            {
                "_unsafeDepositToken": "function _unsafeDepositToken(\n address token,\n address sender,\n uint256 amount,\n uint8 tokenIndex\n ) internal {\n require(token != address(0), \"Token not supported\");\n require(amount > 0, \"Amount must be greater than zero\");\n require(Address.isContract(token), \"The given token address is not a contract\");\n if (_needAdjustAmount(tokenIndex)) {\n amount *= 1e12;\n }\n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(\n ERC20_TRANSFER_FROM_SELECTOR,\n sender,\n address(this),\n amount\n ));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"transferFrom failed\");\n }"
            }
        ],
        "SwapBonded2": [
            {
                "bondSwap": "function bondSwap(uint256 encodedSwap, uint40 poolIndex) external {\n uint200 postedSwap = _postedSwaps[encodedSwap];\n require(postedSwap > 1, \"Swap does not exist\");\n require(_poolIndexFromPosted(postedSwap) == 0, \"Swap bonded to another pool\");\n require(poolOfAuthorizedAddr[_msgSender()] == poolIndex, \"Signer should be an authorized address of the given pool\");\n _postedSwaps[encodedSwap] = postedSwap | poolIndex;\n emit SwapBonded(encodedSwap);\n }"
            }
        ]
    },
    "rel_chain": {
        "RequestSignatureVerified": [
            {
                "_checkRequestSignature": "function _checkRequestSignature(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_33 : TRON_SIGN_HEADER, encodedSwap));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER, encodedSwap));\n } else {\n bytes32 typehash = REQUEST_TYPE_HASH;\n assembly {\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 32))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }"
            }
        ],
        "ReleaseSignatureVerified": [
            {
                "_checkReleaseSignature": "function _checkReleaseSignature(\n uint256 encodedSwap,\n address recipient,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_53 : TRON_SIGN_HEADER, encodedSwap, recipient));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER_52, encodedSwap, recipient));\n } else {\n bytes32 typehash = _outChainFrom(encodedSwap) == 0x00c3 ? RELEASE_TO_TRON_TYPE_HASH : RELEASE_TYPE_HASH;\n assembly {\n mstore(20, recipient)\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 52))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }"
            }
        ]
    },
    "det_chain": {
        "SwapLocked1": [
            {
                "lock": "function lock(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address initiator\n ) external matchProtocolVersion(encodedSwap) forTargetChain(encodedSwap) {\n bytes32 swapId = _getSwapId(encodedSwap, initiator);\n require(_lockedSwaps[swapId] == 0, \"Swap already exists\");\n _checkRequestSignature(encodedSwap, r, s, v, initiator);\n uint40 poolIndex = poolOfAuthorizedAddr[_msgSender()];\n require(poolIndex != 0, \"Caller not registered. Call depositAndRegister.\");\n uint256 until = block.timestamp + LOCK_TIME_PERIOD;\n require(until < _expireTsFrom(encodedSwap) - 5 minutes, \"Cannot lock because expireTs is soon.\");\n uint48 poolTokenIndex = _poolTokenIndexForOutToken(encodedSwap, poolIndex);\n \n _balanceOfPoolToken[poolTokenIndex] -= (_amountFrom(encodedSwap) - _feeForLp(encodedSwap));\n _lockedSwaps[swapId] = _lockedSwapFrom(until, poolIndex);\n emit SwapLocked(encodedSwap);\n }"
            },
            {
                "_checkRequestSignature": "function _checkRequestSignature(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_33 : TRON_SIGN_HEADER, encodedSwap));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER, encodedSwap));\n } else {\n bytes32 typehash = REQUEST_TYPE_HASH;\n assembly {\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 32))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }"
            }
        ],
        "SwapReleased2": [
            {
                "release": "function release(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address initiator,\n address recipient\n ) external {\n bool feeWaived = _feeWaived(encodedSwap);\n if (feeWaived) {\n \n _onlyPremiumManager();\n }\n \n bytes32 swapId = _getSwapId(encodedSwap, initiator);\n uint80 lockedSwap = _lockedSwaps[swapId];\n require(lockedSwap != 0, \"Swap does not exist\");\n require(recipient != address(0), \"Recipient cannot be zero address\");\n function release(...) {...}\nrequire(_expireTsFrom(encodedSwap) > block.timestamp, \"Cannot release because expired\");\n _checkReleaseSignature(encodedSwap, recipient, r, s, v, initiator);\n _lockedSwaps[swapId] = 0;\n uint8 tokenIndex = _outTokenIndexFrom(encodedSwap);\n \n uint256 releaseAmount = _amountFrom(encodedSwap) - _feeForLp(encodedSwap);\n if (!feeWaived) { \n uint256 serviceFee = _serviceFee(encodedSwap);\n \n releaseAmount -= serviceFee;\n \n \n \n \n _balanceOfPoolToken[_poolTokenIndexForOutToken(encodedSwap, 0)] += serviceFee;\n }\n _release(encodedSwap, tokenIndex, initiator, recipient, releaseAmount);\n emit SwapReleased(encodedSwap);\n }"
            },
            {
                "_checkReleaseSignature": "function _checkReleaseSignature(\n uint256 encodedSwap,\n address recipient,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_53 : TRON_SIGN_HEADER, encodedSwap, recipient));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER_52, encodedSwap, recipient));\n } else {\n bytes32 typehash = _outChainFrom(encodedSwap) == 0x00c3 ? RELEASE_TO_TRON_TYPE_HASH : RELEASE_TYPE_HASH;\n assembly {\n mstore(20, recipient)\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 52))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }"
            },
            {
                "_transferToContract": "function _transferToContract(\n address token,\n address contractAddr,\n address beneficiary,\n uint256 amount,\n uint8 tokenIndex,\n uint64 data\n ) internal {\n require(Address.isContract(token), \"The given token address is not a contract\");\n require(Address.isContract(contractAddr), \"The given recipient address is not a contract\");\n if (_needAdjustAmount(tokenIndex)) {\n amount *= 1e12;\n }\n IERC20Minimal(token).approve(contractAddr, amount);\n ITransferWithBeneficiary(contractAddr).transferWithBeneficiary(token, amount, beneficiary, data);\n }"
            },
            {
                "_safeTransfer": "function _safeTransfer(\n address token,\n address recipient,\n uint256 amount,\n uint8 tokenIndex\n ) internal {\n require(Address.isContract(token), \"The given token address is not a contract\");\n if (_needAdjustAmount(tokenIndex)) {\n amount *= 1e12;\n }\n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(\n ERC20_TRANSFER_SELECTOR,\n recipient,\n amount\n ));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"transfer failed\");\n \n \n }"
            }
        ]
    }
}
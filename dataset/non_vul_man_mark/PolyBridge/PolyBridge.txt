Folder Structure
--------------------------------------------------
contracts/
    Address.sol
    Context.sol
    copy.sol
    ERC20Template.sol
    EthCrossChainData.sol
    EthCrossChainManager.sol
    EthCrossChainManagerProxy.sol
    FiatTokenProxy.sol
    FiatTokenV2_1.sol
    IERC165.sol
    IERC20.sol
    IERC721.sol
    IERC721Enumerable.sol
    IERC721Metadata.sol
    IERC721Receiver.sol
    IEthCrossChainManager.sol
    IEthCrossChainManagerProxy.sol
    IPolyNFTLockProxy.sol
    LockProxy.sol
    Ownable.sol
    Pausable.sol
    PolyNFTLockProxy.sol
    PolyNFTQuery.sol
    PolyNFTWrapper.sol
    pONT.sol
    ReentrancyGuard.sol
    SafeERC20.sol
    SafeMath.sol
    TetherToken.sol
    Utils.sol
    ZeroCopySink.sol
    ZeroCopySource.sol


File Contents
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\Address.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies in extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\Context.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\copy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



import "IERC165.sol";



/**

 * @dev Required interface of an ERC721 compliant contract.

 */

interface IERC721 is IERC165 {

    /**

     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.

     */

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.

     */

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.

     */

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of tokens in ``owner``'s account.

     */

    function balanceOf(address owner) external view returns (uint256 balance);



    /**

     * @dev Returns the owner of the `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function ownerOf(uint256 tokenId) external view returns (address owner);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Transfers `tokenId` token from `from` to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Gives permission to `to` to transfer `tokenId` token to another account.

     * The approval is cleared when the token is transferred.

     *

     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.

     *

     * Requirements:

     *

     * - The caller must own the token or be an approved operator.

     * - `tokenId` must exist.

     *

     * Emits an {Approval} event.

     */

    function approve(address to, uint256 tokenId) external;



    /**

     * @dev Returns the account approved for `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function getApproved(uint256 tokenId) external view returns (address operator);



    /**

     * @dev Approve or remove `operator` as an operator for the caller.

     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.

     *

     * Requirements:

     *

     * - The `operator` cannot be the caller.

     *

     * Emits an {ApprovalForAll} event.

     */

    function setApprovalForAll(address operator, bool _approved) external;



    /**

     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.

     *

     * See {setApprovalForAll}

     */

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    /**

      * @dev Safely transfers `tokenId` token from `from` to `to`.

      *

      * Requirements:

      *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

      * - `tokenId` token must exist and be owned by `from`.

      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

      *

      * Emits a {Transfer} event.

      */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\ERC20Template.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2022-11-16

*/



// File: polynetwork/eth-contracts/contracts/libs/math/SafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b != 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: polynetwork/eth-contracts/contracts/libs/token/ERC20/IERC20.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: polynetwork/eth-contracts/contracts/libs/token/ERC20/ERC20Detailed.sol



pragma solidity ^0.5.0;





/**

 * @dev Optional functions from the ERC20 standard.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20Detailed.sol

 */

contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    /**

     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of

     * these values are immutable: they can only be set once during

     * construction.

     */

    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    /**

     * @dev Returns the name of the token.

     */

    function name() public view returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5,05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei.

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}



// File: polynetwork/eth-contracts/contracts/libs/GSN/Context.sol



pragma solidity ^0.5.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: polynetwork/eth-contracts/contracts/libs/token/ERC20/ERC20.sol



pragma solidity ^0.5.0;









/**

 * @dev Implementation of the {IERC20} interface.

 *

 * This implementation is agnostic to the way tokens are created. This means

 * that a supply mechanism has to be added in a derived contract using {_mint}.

 * For a generic mechanism see {ERC20Mintable}.

 *

 * TIP: For a detailed writeup see our guide

 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How

 * to implement supply mechanisms].

 *

 * We have followed general OpenZeppelin guidelines: functions revert instead

 * of returning `false` on failure. This behavior is nonetheless conventional

 * and does not conflict with the expectations of ERC20 applications.

 *

 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.

 * This allows applications to reconstruct the allowance for all accounts just

 * by listening to said events. Other implementations of the EIP may not emit

 * these events, as it isn't required by the specification.

 *

 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}

 * functions have been added to mitigate the well-known issues around setting

 * allowances. See {IERC20-approve}.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol

 */

contract ERC20 is Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `recipient` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20};

     *

     * Requirements:

     * - `sender` and `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     * - the caller must have allowance for `sender`'s tokens of at least

     * `amount`.

     */

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    /**

     * @dev Moves tokens `amount` from `sender` to `recipient`.

     *

     * This is internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `sender` cannot be the zero address.

     * - `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     */

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements

     *

     * - `to` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.

     *

     * This is internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted

     * from the caller's allowance.

     *

     * See {_burn} and {_approve}.

     */

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }

}



// File: polynetwork/eth-contracts/contracts/core/assets/erc20_template/ERC20Template.sol



pragma solidity ^0.5.0;









contract ERC20Template is Context, ERC20, ERC20Detailed {

    

    constructor (address lockProxy) public ERC20Detailed("Poly Ontology Wing Token", "pWING", 9) {

        _mint(lockProxy, 10000000000000000);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\EthCrossChainData.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2023-02-06

*/



// File: eth-contracts/contracts/core/cross_chain_manager/interface/IEthCrossChainData.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the EthCrossChainData contract, the implementation is in EthCrossChainData.sol

 */

interface IEthCrossChainData {

    function putCurEpochStartHeight(uint32 curEpochStartHeight) external returns (bool);

    function getCurEpochStartHeight() external view returns (uint32);

    function putCurEpochConPubKeyBytes(bytes calldata curEpochPkBytes) external returns (bool);

    function getCurEpochConPubKeyBytes() external view returns (bytes memory);

    function markFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) external returns (bool);

    function checkIfFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) external view returns (bool);

    function getEthTxHashIndex() external view returns (uint256);

    function putEthTxHash(bytes32 ethTxHash) external returns (bool);

    function putExtraData(bytes32 key1, bytes32 key2, bytes calldata value) external returns (bool);

    function getExtraData(bytes32 key1, bytes32 key2) external view returns (bytes memory);

    function transferOwnership(address newOwner) external;

    function pause() external returns (bool);

    function unpause() external returns (bool);

    function paused() external view returns (bool);

    // Not used currently by ECCM

    function getEthTxHash(uint256 ethTxHashIndex) external view returns (bytes32);

}

// File: eth-contracts/contracts/libs/GSN/Context.sol



pragma solidity ^0.5.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: eth-contracts/contracts/libs/lifecycle/Pausable.sol



pragma solidity ^0.5.0;





/**

 * @dev Contract module which allows children to implement an emergency stop

 * mechanism that can be triggered by an authorized account.

 *

 * This module is used through inheritance. It will make available the

 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to

 * the functions of your contract. Note that they will not be pausable by

 * simply including this module, only once the modifiers are put in place.

 */

contract Pausable is Context {

    /**

     * @dev Emitted when the pause is triggered by a pauser (`account`).

     */

    event Paused(address account);



    /**

     * @dev Emitted when the pause is lifted by a pauser (`account`).

     */

    event Unpaused(address account);



    bool private _paused;



    /**

     * @dev Initializes the contract in unpaused state.

     */

    constructor () internal {

        _paused = false;

    }



    /**

     * @dev Returns true if the contract is paused, and false otherwise.

     */

    function paused() public view returns (bool) {

        return _paused;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is not paused.

     */

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is paused.

     */

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    /**

     * @dev Called to pause, triggers stopped state.

     */

    function _pause() internal whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    /**

     * @dev Called to unpause, returns to normal state.

     */

    function _unpause() internal whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }

}



// File: eth-contracts/contracts/libs/ownership/Ownable.sol



pragma solidity ^0.5.0;



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public  onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: eth-contracts/contracts/core/cross_chain_manager/data/EthCrossChainData.sol



pragma solidity ^0.5.0;









contract EthCrossChainData is IEthCrossChainData, Ownable, Pausable{

    /*

     Ethereum cross chain tx hash indexed by the automatically increased index.

     This map exists for the reason that Poly chain can verify the existence of 

     cross chain request tx coming from Ethereum

    */

    mapping(uint256 => bytes32) public EthToPolyTxHashMap;

    // This index records the current Map length

    uint256 public EthToPolyTxHashIndex;



    /* 

     When Poly chain switches the consensus epoch book keepers, the consensus peers public keys of Poly chain should be 

     changed into no-compressed version so that solidity smart contract can convert it to address type and 

     verify the signature derived from Poly chain account signature.

     ConKeepersPkBytes means Consensus book Keepers Public Key Bytes

    */

    bytes public ConKeepersPkBytes;

    

    // CurEpochStartHeight means Current Epoch Start Height of Poly chain block

    uint32 public CurEpochStartHeight;

    

    // Record the from chain txs that have been processed

    mapping(uint64 => mapping(bytes32 => bool)) FromChainTxExist;

    

    // Extra map for the usage of future potentially

    mapping(bytes32 => mapping(bytes32 => bytes)) public ExtraData;

    

    // Store Current Epoch Start Height of Poly chain block

    function putCurEpochStartHeight(uint32 curEpochStartHeight) public whenNotPaused onlyOwner returns (bool) {

        CurEpochStartHeight = curEpochStartHeight;

        return true;

    }



    // Get Current Epoch Start Height of Poly chain block

    function getCurEpochStartHeight() public view returns (uint32) {

        return CurEpochStartHeight;

    }



    // Store Consensus book Keepers Public Key Bytes

    function putCurEpochConPubKeyBytes(bytes memory curEpochPkBytes) public whenNotPaused onlyOwner returns (bool) {

        ConKeepersPkBytes = curEpochPkBytes;

        return true;

    }



    // Get Consensus book Keepers Public Key Bytes

    function getCurEpochConPubKeyBytes() public view returns (bytes memory) {

        return ConKeepersPkBytes;

    }



    // Mark from chain tx fromChainTx as exist or processed

    function markFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) public whenNotPaused onlyOwner returns (bool) {

        FromChainTxExist[fromChainId][fromChainTx] = true;

        return true;

    }



    // Check if from chain tx fromChainTx has been processed before

    function checkIfFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) public view returns (bool) {

        return FromChainTxExist[fromChainId][fromChainTx];

    }



    // Get current recorded index of cross chain txs requesting from Ethereum to other public chains

    // in order to help cross chain manager contract differenciate two cross chain tx requests

    function getEthTxHashIndex() public view returns (uint256) {

        return EthToPolyTxHashIndex;

    }



    // Store Ethereum cross chain tx hash, increase the index record by 1

    function putEthTxHash(bytes32 ethTxHash) public whenNotPaused onlyOwner returns (bool) {

        EthToPolyTxHashMap[EthToPolyTxHashIndex] = ethTxHash;

        EthToPolyTxHashIndex = EthToPolyTxHashIndex + 1;

        return true;

    }



    // Get Ethereum cross chain tx hash indexed by ethTxHashIndex

    function getEthTxHash(uint256 ethTxHashIndex) public view returns (bytes32) {

        return EthToPolyTxHashMap[ethTxHashIndex];

    }



    // Store extra data, which may be used in the future

    function putExtraData(bytes32 key1, bytes32 key2, bytes memory value) public whenNotPaused onlyOwner returns (bool) {

        ExtraData[key1][key2] = value;

        return true;

    }

    // Get extra data, which may be used in the future

    function getExtraData(bytes32 key1, bytes32 key2) public view returns (bytes memory) {

        return ExtraData[key1][key2];

    }

    

    function pause() onlyOwner whenNotPaused public returns (bool) {

        _pause();

        return true;

    }

    

    function unpause() onlyOwner whenPaused public returns (bool) {

        _unpause();

        return true;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\EthCrossChainManager.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-10-19

*/



pragma solidity ^0.5.0;

pragma experimental ABIEncoderV2;



contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public  onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



contract Pausable is Context {

    /**

     * @dev Emitted when the pause is triggered by a pauser (`account`).

     */

    event Paused(address account);



    /**

     * @dev Emitted when the pause is lifted by a pauser (`account`).

     */

    event Unpaused(address account);



    bool private _paused;



    /**

     * @dev Initializes the contract in unpaused state.

     */

    constructor () internal {

        _paused = false;

    }



    /**

     * @dev Returns true if the contract is paused, and false otherwise.

     */

    function paused() public view returns (bool) {

        return _paused;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is not paused.

     */

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is paused.

     */

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    /**

     * @dev Called to pause, triggers stopped state.

     */

    function _pause() internal whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    /**

     * @dev Called to unpause, returns to normal state.

     */

    function _unpause() internal whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }

}



library ZeroCopySink {

    /* @notice          Convert boolean value into bytes

    *  @param b         The boolean value

    *  @return          Converted bytes array

    */

    function WriteBool(bool b) internal pure returns (bytes memory) {

        bytes memory buff;

        assembly{

            buff := mload(0x40)

            mstore(buff, 1)

            switch iszero(b)

            case 1 {

                mstore(add(buff, 0x20), shl(248, 0x00))

                // mstore8(add(buff, 0x20), 0x00)

            }

            default {

                mstore(add(buff, 0x20), shl(248, 0x01))

                // mstore8(add(buff, 0x20), 0x01)

            }

            mstore(0x40, add(buff, 0x21))

        }

        return buff;

    }



    /* @notice          Convert byte value into bytes

    *  @param b         The byte value

    *  @return          Converted bytes array

    */

    function WriteByte(byte b) internal pure returns (bytes memory) {

        return WriteUint8(uint8(b));

    }



    /* @notice          Convert uint8 value into bytes

    *  @param v         The uint8 value

    *  @return          Converted bytes array

    */

    function WriteUint8(uint8 v) internal pure returns (bytes memory) {

        bytes memory buff;

        assembly{

            buff := mload(0x40)

            mstore(buff, 1)

            mstore(add(buff, 0x20), shl(248, v))

            // mstore(add(buff, 0x20), byte(0x1f, v))

            mstore(0x40, add(buff, 0x21))

        }

        return buff;

    }



    /* @notice          Convert uint16 value into bytes

    *  @param v         The uint16 value

    *  @return          Converted bytes array

    */

    function WriteUint16(uint16 v) internal pure returns (bytes memory) {

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x02

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x22))

        }

        return buff;

    }

    

    /* @notice          Convert uint32 value into bytes

    *  @param v         The uint32 value

    *  @return          Converted bytes array

    */

    function WriteUint32(uint32 v) internal pure returns(bytes memory) {

        bytes memory buff;

        assembly{

            buff := mload(0x40)

            let byteLen := 0x04

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x24))

        }

        return buff;

    }



    /* @notice          Convert uint64 value into bytes

    *  @param v         The uint64 value

    *  @return          Converted bytes array

    */

    function WriteUint64(uint64 v) internal pure returns(bytes memory) {

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x08

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x28))

        }

        return buff;

    }



    /* @notice          Convert limited uint256 value into bytes

    *  @param v         The uint256 value

    *  @return          Converted bytes array

    */

    function WriteUint255(uint256 v) internal pure returns (bytes memory) {

        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds uint255 range");

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x20

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x40))

        }

        return buff;

    }



    /* @notice          Encode bytes format data into bytes

    *  @param data      The bytes array data

    *  @return          Encoded bytes array

    */

    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {

        uint64 l = uint64(data.length);

        return abi.encodePacked(WriteVarUint(l), data);

    }



    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {

        if (v < 0xFD){

    		return WriteUint8(uint8(v));

    	} else if (v <= 0xFFFF) {

    		return abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));

    	} else if (v <= 0xFFFFFFFF) {

            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));

    	} else {

    		return abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));

    	}

    }

}



library ZeroCopySource {

    /* @notice              Read next byte as boolean type starting at offset from buff

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the boolean value

    *  @return              The the read boolean value and new offset

    */

    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {

        require(offset + 1 <= buff.length && offset < offset + 1, "Offset exceeds limit");

        // byte === bytes1

        byte v;

        assembly{

            v := mload(add(add(buff, 0x20), offset))

        }

        bool value;

        if (v == 0x01) {

		    value = true;

    	} else if (v == 0x00) {

            value = false;

        } else {

            revert("NextBool value error");

        }

        return (value, offset + 1);

    }



    /* @notice              Read next byte starting at offset from buff

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the byte value

    *  @return              The read byte value and new offset

    */

    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {

        require(offset + 1 <= buff.length && offset < offset + 1, "NextByte, Offset exceeds maximum");

        byte v;

        assembly{

            v := mload(add(add(buff, 0x20), offset))

        }

        return (v, offset + 1);

    }



    /* @notice              Read next byte as uint8 starting at offset from buff

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the byte value

    *  @return              The read uint8 value and new offset

    */

    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {

        require(offset + 1 <= buff.length && offset < offset + 1, "NextUint8, Offset exceeds maximum");

        uint8 v;

        assembly{

            let tmpbytes := mload(0x40)

            let bvalue := mload(add(add(buff, 0x20), offset))

            mstore8(tmpbytes, byte(0, bvalue))

            mstore(0x40, add(tmpbytes, 0x01))

            v := mload(sub(tmpbytes, 0x1f))

        }

        return (v, offset + 1);

    }



    /* @notice              Read next two bytes as uint16 type starting from offset

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint16 value

    *  @return              The read uint16 value and updated offset

    */

    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {

        require(offset + 2 <= buff.length && offset < offset + 2, "NextUint16, offset exceeds maximum");

        

        uint16 v;

        assembly {

            let tmpbytes := mload(0x40)

            let bvalue := mload(add(add(buff, 0x20), offset))

            mstore8(tmpbytes, byte(0x01, bvalue))

            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))

            mstore(0x40, add(tmpbytes, 0x02))

            v := mload(sub(tmpbytes, 0x1e))

        }

        return (v, offset + 2);

    }





    /* @notice              Read next four bytes as uint32 type starting from offset

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint32 value

    *  @return              The read uint32 value and updated offset

    */

    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {

        require(offset + 4 <= buff.length && offset < offset + 4, "NextUint32, offset exceeds maximum");

        uint32 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x04

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(sub(tmpbytes, sub(0x20, byteLen)))

        }

        return (v, offset + 4);

    }



    /* @notice              Read next eight bytes as uint64 type starting from offset

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint64 value

    *  @return              The read uint64 value and updated offset

    */

    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {

        require(offset + 8 <= buff.length && offset < offset + 8, "NextUint64, offset exceeds maximum");

        uint64 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x08

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(sub(tmpbytes, sub(0x20, byteLen)))

        }

        return (v, offset + 8);

    }



    /* @notice              Read next 32 bytes as uint256 type starting from offset,

                            there are limits considering the numerical limits in multi-chain

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint256 value

    *  @return              The read uint256 value and updated offset

    */

    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {

        require(offset + 32 <= buff.length && offset < offset + 32, "NextUint255, offset exceeds maximum");

        uint256 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x20

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(tmpbytes)

        }

        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds the range");

        return (v, offset + 32);

    }

    /* @notice              Read next variable bytes starting from offset,

                            the decoding rule coming from multi-chain

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the bytes value

    *  @return              The read variable bytes array value and updated offset

    */

    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {

        uint len;

        (len, offset) = NextVarUint(buff, offset);

        require(offset + len <= buff.length && offset < offset + len, "NextVarBytes, offset exceeds maximum");

        bytes memory tempBytes;

        assembly{

            switch iszero(len)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                let lengthmod := and(len, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, len)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, len)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return (tempBytes, offset + len);

    }

    /* @notice              Read next 32 bytes starting from offset,

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the bytes value

    *  @return              The read bytes32 value and updated offset

    */

    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {

        require(offset + 32 <= buff.length && offset < offset + 32, "NextHash, offset exceeds maximum");

        bytes32 v;

        assembly {

            v := mload(add(buff, add(offset, 0x20)))

        }

        return (v, offset + 32);

    }



    /* @notice              Read next 20 bytes starting from offset,

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the bytes value

    *  @return              The read bytes20 value and updated offset

    */

    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {

        require(offset + 20 <= buff.length && offset < offset + 20, "NextBytes20, offset exceeds maximum");

        bytes20 v;

        assembly {

            v := mload(add(buff, add(offset, 0x20)))

        }

        return (v, offset + 20);

    }

    

    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {

        byte v;

        (v, offset) = NextByte(buff, offset);



        uint value;

        if (v == 0xFD) {

            // return NextUint16(buff, offset);

            (value, offset) = NextUint16(buff, offset);

            require(value >= 0xFD && value <= 0xFFFF, "NextUint16, value outside range");

            return (value, offset);

        } else if (v == 0xFE) {

            // return NextUint32(buff, offset);

            (value, offset) = NextUint32(buff, offset);

            require(value > 0xFFFF && value <= 0xFFFFFFFF, "NextVarUint, value outside range");

            return (value, offset);

        } else if (v == 0xFF) {

            // return NextUint64(buff, offset);

            (value, offset) = NextUint64(buff, offset);

            require(value > 0xFFFFFFFF, "NextVarUint, value outside range");

            return (value, offset);

        } else{

            // return (uint8(v), offset);

            value = uint8(v);

            require(value < 0xFD, "NextVarUint, value outside range");

            return (value, offset);

        }

    }

}



library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b != 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}





library Utils {



    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32

    *  @param _bs   Source bytes array

    *  @return      bytes32

    */

    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {

        require(_bs.length == 32, "bytes length is not 32.");

        assembly {

            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length

            value := mload(add(_bs, 0x20))

        }

    }



    /* @notice      Convert bytes to uint256

    *  @param _b    Source bytes should have length of 32

    *  @return      uint256

    */

    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {

        require(_bs.length == 32, "bytes length is not 32.");

        assembly {

            // load 32 bytes from memory starting from position _bs + 32

            value := mload(add(_bs, 0x20))

        }

        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds the range");

    }



    /* @notice      Convert uint256 to bytes

    *  @param _b    uint256 that needs to be converted

    *  @return      bytes

    */

    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {

        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds the range");

        assembly {

            // Get a location of some free memory and store it in result as

            // Solidity does for memory variables.

            bs := mload(0x40)

            // Put 0x20 at the first word, the length of bytes for uint256 value

            mstore(bs, 0x20)

            //In the next word, put value in bytes format to the next 32 bytes

            mstore(add(bs, 0x20), _value)

            // Update the free-memory pointer by padding our last write location to 32 bytes

            mstore(0x40, add(bs, 0x40))

        }

    }



    /* @notice      Convert bytes to address

    *  @param _bs   Source bytes: bytes length must be 20

    *  @return      Converted address from source bytes

    */

    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)

    {

        require(_bs.length == 20, "bytes length does not match address");

        assembly {

            // for _bs, first word store _bs.length, second word store _bs.value

            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).

            addr := mload(add(_bs, 0x14))

        }



    }

    

    /* @notice      Convert address to bytes

    *  @param _addr Address need to be converted

    *  @return      Converted bytes from address

    */

    function addressToBytes(address _addr) internal pure returns (bytes memory bs){

        assembly {

            // Get a location of some free memory and store it in result as

            // Solidity does for memory variables.

            bs := mload(0x40)

            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value

            mstore(bs, 0x14)

            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned

            mstore(add(bs, 0x20), shl(96, _addr))

            // Update the free-memory pointer by padding our last write location to 32 bytes

            mstore(0x40, add(bs, 0x40))

       }

    }



    /* @notice          Do hash leaf as the multi-chain does

    *  @param _data     Data in bytes format

    *  @return          Hashed value in bytes32 format

    */

    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {

        result = sha256(abi.encodePacked(byte(0x0), _data));

    }



    /* @notice          Do hash children as the multi-chain does

    *  @param _l        Left node

    *  @param _r        Right node

    *  @return          Hashed value in bytes32 format

    */

    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {

        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));

    }



    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately

                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368

    *  @param _preBytes     The bytes stored in storage

    *  @param _postBytes    The bytes stored in memory

    *  @return              Bool type indicating if they are equal

    */

    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {

        bool success = true;



        assembly {

            // we know _preBytes_offset is 0

            let fslot := sload(_preBytes_slot)

            // Arrays of 31 bytes or less have an even value in their slot,

            // while longer arrays have an odd value. The actual length is

            // the slot divided by two for odd values, and the lowest order

            // byte divided by two for even values.

            // If the slot is even, bitwise and the slot with 255 and divide by

            // two to get the length. If the slot is odd, bitwise and the slot

            // with -1 and divide by two.

            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)

            let mlength := mload(_postBytes)



            // if lengths don't match the arrays are not equal

            switch eq(slength, mlength)

            case 1 {

                // fslot can contain both the length and contents of the array

                // if slength < 32 bytes so let's prepare for that

                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage

                // slength != 0

                if iszero(iszero(slength)) {

                    switch lt(slength, 32)

                    case 1 {

                        // blank the last byte which is the length

                        fslot := mul(div(fslot, 0x100), 0x100)



                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {

                            // unsuccess:

                            success := 0

                        }

                    }

                    default {

                        // cb is a circuit breaker in the for loop since there's

                        //  no said feature for inline assembly loops

                        // cb = 1 - don't breaker

                        // cb = 0 - break

                        let cb := 1



                        // get the keccak hash to get the contents of the array

                        mstore(0x0, _preBytes_slot)

                        let sc := keccak256(0x0, 0x20)



                        let mc := add(_postBytes, 0x20)

                        let end := add(mc, mlength)



                        // the next line is the loop condition:

                        // while(uint(mc < end) + cb == 2)

                        for {} eq(add(lt(mc, end), cb), 2) {

                            sc := add(sc, 1)

                            mc := add(mc, 0x20)

                        } {

                            if iszero(eq(sload(sc), mload(mc))) {

                                // unsuccess:

                                success := 0

                                cb := 0

                            }

                        }

                    }

                }

            }

            default {

                // unsuccess:

                success := 0

            }

        }



        return success;

    }



    /* @notice              Slice the _bytes from _start index till the result has length of _length

                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246

    *  @param _bytes        The original bytes needs to be sliced

    *  @param _start        The index of _bytes for the start of sliced bytes

    *  @param _length       The index of _bytes for the end of sliced bytes

    *  @return              The sliced bytes

    */

    function slice(

        bytes memory _bytes,

        uint _start,

        uint _length

    )

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));



        bytes memory tempBytes;



        assembly {

            switch iszero(_length)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                // lengthmod <= _length % 32

                let lengthmod := and(_length, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, _length)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, _length)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return tempBytes;

    }

    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m

    *  @param _keepers      The array consists of serveral address

    *  @param _signers      Some specific addresses to be looked into

    *  @param _m            The number requirement paramter

    *  @return              True means containment, false meansdo do not contain.

    */

    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){

        uint m = 0;

        for(uint i = 0; i < _signers.length; i++){

            for (uint j = 0; j < _keepers.length; j++) {

                if (_signers[i] == _keepers[j]) {

                    m++;

                    delete _keepers[j];

                }

            }

        }

        return m >= _m;

    }



    /* @notice              TODO

    *  @param key

    *  @return

    */

    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {

         require(key.length >= 67, "key lenggh is too short");

         newkey = slice(key, 0, 35);

         if (uint8(key[66]) % 2 == 0){

             newkey[2] = byte(0x02);

         } else {

             newkey[2] = byte(0x03);

         }

         return newkey;

    }

    

    /**

     * @dev Returns true if `account` is a contract.

     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18

     *

     * This test is non-exhaustive, and there may be false-negatives: during the

     * execution of a contract's constructor, its address will be reported as

     * not containing a contract.

     *

     * IMPORTANT: It is unsafe to assume that an address for which this

     * function returns false is an externally-owned account (EOA) and not a

     * contract.

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies in extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }

}



library ECCUtils {

    using SafeMath for uint256;

    

    struct Header {

        uint32 version;

        uint64 chainId;

        uint32 timestamp;

        uint32 height;

        uint64 consensusData;

        bytes32 prevBlockHash;

        bytes32 transactionsRoot;

        bytes32 crossStatesRoot;

        bytes32 blockRoot;

        bytes consensusPayload;

        bytes20 nextBookkeeper;

    }



    struct ToMerkleValue {

        bytes  txHash;  // cross chain txhash

        uint64 fromChainID;

        TxParam makeTxParam;

    }



    struct TxParam {

        bytes txHash; //  source chain txhash

        bytes crossChainId;

        bytes fromContract;

        uint64 toChainId;

        bytes toContract;

        bytes method;

        bytes args;

    }



    uint constant POLYCHAIN_PUBKEY_LEN = 67;

    uint constant POLYCHAIN_SIGNATURE_LEN = 65;



    /* @notice                  Verify Poly chain transaction whether exist or not

    *  @param _auditPath        Poly chain merkle proof

    *  @param _root             Poly chain root

    *  @return                  The verified value included in _auditPath

    */

    function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {

        uint256 off = 0;

        bytes memory value;

        (value, off)  = ZeroCopySource.NextVarBytes(_auditPath, off);



        bytes32 hash = Utils.hashLeaf(value);

        uint size = _auditPath.length.sub(off).div(33);

        bytes32 nodeHash;

        byte pos;

        for (uint i = 0; i < size; i++) {

            (pos, off) = ZeroCopySource.NextByte(_auditPath, off);

            (nodeHash, off) = ZeroCopySource.NextHash(_auditPath, off);

            if (pos == 0x00) {

                hash = Utils.hashChildren(nodeHash, hash);

            } else if (pos == 0x01) {

                hash = Utils.hashChildren(hash, nodeHash);

            } else {

                revert("merkleProve, NextByte for position info failed");

            }

        }

        require(hash == _root, "merkleProve, expect root is not equal actual root");

        return value;

    }



    /* @notice              calculate next book keeper according to public key list

    *  @param _keyLen       consensus node number

    *  @param _m            minimum signature number

    *  @param _pubKeyList   consensus node public key list

    *  @return              two element: next book keeper, consensus node signer addresses

    */

    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){

         bytes memory buff;

         buff = ZeroCopySink.WriteUint16(uint16(_keyLen));

         address[] memory keepers = new address[](_keyLen);

         bytes32 hash;

         bytes memory publicKey;

         for(uint i = 0; i < _keyLen; i++){

             publicKey = Utils.slice(_pubKeyList, i*POLYCHAIN_PUBKEY_LEN, POLYCHAIN_PUBKEY_LEN);

             buff =  abi.encodePacked(buff, ZeroCopySink.WriteVarBytes(Utils.compressMCPubKey(publicKey)));

             hash = keccak256(Utils.slice(publicKey, 3, 64));

             keepers[i] = address(uint160(uint256(hash)));

         }



         buff = abi.encodePacked(buff, ZeroCopySink.WriteUint16(uint16(_m)));

         bytes20  nextBookKeeper = ripemd160(abi.encodePacked(sha256(buff)));

         return (nextBookKeeper, keepers);

    }



    /* @notice              Verify public key derived from Poly chain

    *  @param _pubKeyList   serialized consensus node public key list

    *  @param _sigList      consensus node signature list

    *  @return              return two element: next book keeper, consensus node signer addresses

    */

    function verifyPubkey(bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory) {

        require(_pubKeyList.length % POLYCHAIN_PUBKEY_LEN == 0, "_pubKeyList length illegal!");

        uint n = _pubKeyList.length / POLYCHAIN_PUBKEY_LEN;

        require(n >= 1, "too short _pubKeyList!");

        return _getBookKeeper(n, n - (n - 1) / 3, _pubKeyList);

    }



    /* @notice              Verify Poly chain consensus node signature

    *  @param _rawHeader    Poly chain block header raw bytes

    *  @param _sigList      consensus node signature list

    *  @param _keepers      addresses corresponding with Poly chain book keepers' public keys

    *  @param _m            minimum signature number

    *  @return              true or false

    */

    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){

        bytes32 hash = getHeaderHash(_rawHeader);



        uint sigCount = _sigList.length.div(POLYCHAIN_SIGNATURE_LEN);

        address[] memory signers = new address[](sigCount);

        bytes32 r;

        bytes32 s;

        uint8 v;

        for(uint j = 0; j  < sigCount; j++){

            r = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN, 32));

            s =  Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN + 32, 32));

            v =  uint8(_sigList[j*POLYCHAIN_SIGNATURE_LEN + 64]) + 27;

            signers[j] =  ecrecover(sha256(abi.encodePacked(hash)), v, r, s);

            if (signers[j] == address(0)) return false;

        }

        return Utils.containMAddresses(_keepers, signers, _m);

    }

    



    /* @notice               Serialize Poly chain book keepers' info in Ethereum addresses format into raw bytes

    *  @param keepersBytes   The serialized addresses

    *  @return               serialized bytes result

    */

    function serializeKeepers(address[] memory keepers) internal pure returns (bytes memory) {

        uint256 keeperLen = keepers.length;

        bytes memory keepersBytes = ZeroCopySink.WriteUint64(uint64(keeperLen));

        for(uint i = 0; i < keeperLen; i++) {

            keepersBytes = abi.encodePacked(keepersBytes, ZeroCopySink.WriteVarBytes(Utils.addressToBytes(keepers[i])));

        }

        return keepersBytes;

    }



    /* @notice               Deserialize bytes into Ethereum addresses

    *  @param keepersBytes   The serialized addresses derived from Poly chain book keepers in bytes format

    *  @return               addresses

    */

    function deserializeKeepers(bytes memory keepersBytes) internal pure returns (address[] memory) {

        uint256 off = 0;

        uint64 keeperLen;

        (keeperLen, off) = ZeroCopySource.NextUint64(keepersBytes, off);

        address[] memory keepers = new address[](keeperLen);

        bytes memory keeperBytes;

        for(uint i = 0; i < keeperLen; i++) {

            (keeperBytes, off) = ZeroCopySource.NextVarBytes(keepersBytes, off);

            keepers[i] = Utils.bytesToAddress(keeperBytes);

        }

        return keepers;

    }



    /* @notice               Deserialize Poly chain transaction raw value

    *  @param _valueBs       Poly chain transaction raw bytes

    *  @return               ToMerkleValue struct

    */

    function deserializeMerkleValue(bytes memory _valueBs) internal pure returns (ToMerkleValue memory) {

        ToMerkleValue memory toMerkleValue;

        uint256 off = 0;



        (toMerkleValue.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);



        (toMerkleValue.fromChainID, off) = ZeroCopySource.NextUint64(_valueBs, off);



        TxParam memory txParam;



        (txParam.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);

        

        (txParam.crossChainId, off) = ZeroCopySource.NextVarBytes(_valueBs, off);



        (txParam.fromContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);



        (txParam.toChainId, off) = ZeroCopySource.NextUint64(_valueBs, off);



        (txParam.toContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);



        (txParam.method, off) = ZeroCopySource.NextVarBytes(_valueBs, off);



        (txParam.args, off) = ZeroCopySource.NextVarBytes(_valueBs, off);

        toMerkleValue.makeTxParam = txParam;



        return toMerkleValue;

    }



    /* @notice            Deserialize Poly chain block header raw bytes

    *  @param _valueBs    Poly chain block header raw bytes

    *  @return            Header struct

    */

    function deserializeHeader(bytes memory _headerBs) internal pure returns (Header memory) {

        Header memory header;

        uint256 off = 0;

        (header.version, off)  = ZeroCopySource.NextUint32(_headerBs, off);



        (header.chainId, off) = ZeroCopySource.NextUint64(_headerBs, off);



        (header.prevBlockHash, off) = ZeroCopySource.NextHash(_headerBs, off);



        (header.transactionsRoot, off) = ZeroCopySource.NextHash(_headerBs, off);



        (header.crossStatesRoot, off) = ZeroCopySource.NextHash(_headerBs, off);



        (header.blockRoot, off) = ZeroCopySource.NextHash(_headerBs, off);



        (header.timestamp, off) = ZeroCopySource.NextUint32(_headerBs, off);



        (header.height, off) = ZeroCopySource.NextUint32(_headerBs, off);



        (header.consensusData, off) = ZeroCopySource.NextUint64(_headerBs, off);



        (header.consensusPayload, off) = ZeroCopySource.NextVarBytes(_headerBs, off);



        (header.nextBookkeeper, off) = ZeroCopySource.NextBytes20(_headerBs, off);



        return header;

    }



    /* @notice            Deserialize Poly chain block header raw bytes

    *  @param rawHeader   Poly chain block header raw bytes

    *  @return            header hash same as Poly chain

    */

    function getHeaderHash(bytes memory rawHeader) internal pure returns (bytes32) {

        return sha256(abi.encodePacked(sha256(rawHeader)));

    }

}



interface IEthCrossChainData {

    function putCurEpochStartHeight(uint32 curEpochStartHeight) external returns (bool);

    function getCurEpochStartHeight() external view returns (uint32);

    function putCurEpochConPubKeyBytes(bytes calldata curEpochPkBytes) external returns (bool);

    function getCurEpochConPubKeyBytes() external view returns (bytes memory);

    function markFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) external returns (bool);

    function checkIfFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) external view returns (bool);

    function getEthTxHashIndex() external view returns (uint256);

    function putEthTxHash(bytes32 ethTxHash) external returns (bool);

    function putExtraData(bytes32 key1, bytes32 key2, bytes calldata value) external returns (bool);

    function getExtraData(bytes32 key1, bytes32 key2) external view returns (bytes memory);

    function transferOwnership(address newOwner) external;

    function pause() external returns (bool);

    function unpause() external returns (bool);

    function paused() external view returns (bool);

    // Not used currently by ECCM

    function getEthTxHash(uint256 ethTxHashIndex) external view returns (bytes32);

}



interface IUpgradableECCM {

    function pause() external returns (bool);

    function unpause() external returns (bool);

    function paused() external view returns (bool);

    function upgradeToNew(address) external returns (bool);

    function isOwner() external view returns (bool);

    function setChainId(uint64 _newChainId) external returns (bool);

}





interface IEthCrossChainManager {

    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);

}



contract UpgradableECCM is IUpgradableECCM, Ownable, Pausable {

    address public EthCrossChainDataAddress;

    uint64 public chainId;  

    

    constructor (address ethCrossChainDataAddr, uint64 _chainId) Pausable() Ownable()  public {

        EthCrossChainDataAddress = ethCrossChainDataAddr;

        chainId = _chainId;

    }

    function pause() onlyOwner public returns (bool) {

        if (!paused()) {

            _pause();

        }

        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);

        if (!eccd.paused()) {

            require(eccd.pause(), "pause EthCrossChainData contract failed");

        }

        return true;

    }

    

    function unpause() onlyOwner public returns (bool) {

        if (paused()) {

            _unpause();

        }

        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);

        if (eccd.paused()) {

            require(eccd.unpause(), "unpause EthCrossChainData contract failed");

        }

        return true;

    }



    // if we want to upgrade this contract, we need to invoke this method 

    function upgradeToNew(address newEthCrossChainManagerAddress) whenPaused onlyOwner public returns (bool) {

        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);

        eccd.transferOwnership(newEthCrossChainManagerAddress);

        return true;

    }

    

    function setChainId(uint64 _newChainId) whenPaused onlyOwner public returns (bool) {

        chainId = _newChainId;

        return true;

    }

}



contract EthCrossChainManager is IEthCrossChainManager, UpgradableECCM {

    using SafeMath for uint256;

    

    address public whiteLister;

    mapping(address => bool) public whiteListFromContract;

    mapping(address => mapping(bytes => bool)) public whiteListContractMethodMap;



    event InitGenesisBlockEvent(uint256 height, bytes rawHeader);

    event ChangeBookKeeperEvent(uint256 height, bytes rawHeader);

    event CrossChainEvent(address indexed sender, bytes txId, address proxyOrAssetContract, uint64 toChainId, bytes toContract, bytes rawdata);

    event VerifyHeaderAndExecuteTxEvent(uint64 fromChainID, bytes toContract, bytes crossChainTxHash, bytes fromChainTxHash);

    constructor(

        address _eccd, 

        uint64 _chainId, 

        address[] memory fromContractWhiteList, 

        bytes[] memory contractMethodWhiteList

    ) UpgradableECCM(_eccd,_chainId) public {

        whiteLister = msg.sender;

        for (uint i=0;i<fromContractWhiteList.length;i++) {

            whiteListFromContract[fromContractWhiteList[i]] = true;

        }

        for (uint i=0;i<contractMethodWhiteList.length;i++) {

            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));

            for (uint j=0;j<methods.length;j++) {

                whiteListContractMethodMap[toContract][methods[j]] = true;

            }

        }

    }

    

    modifier onlyWhiteLister() {

        require(msg.sender == whiteLister, "Not whiteLister");

        _;

    }



    function setWhiteLister(address newWL) public onlyWhiteLister {

        require(newWL!=address(0), "Can not transfer to address(0)");

        whiteLister = newWL;

    }

    

    function setFromContractWhiteList(address[] memory fromContractWhiteList) public onlyWhiteLister {

        for (uint i=0;i<fromContractWhiteList.length;i++) {

            whiteListFromContract[fromContractWhiteList[i]] = true;

        }

    }

    

    function removeFromContractWhiteList(address[] memory fromContractWhiteList) public onlyWhiteLister {

        for (uint i=0;i<fromContractWhiteList.length;i++) {

            whiteListFromContract[fromContractWhiteList[i]] = false;

        }

    }

    

    function setContractMethodWhiteList(bytes[] memory contractMethodWhiteList) public onlyWhiteLister {

        for (uint i=0;i<contractMethodWhiteList.length;i++) {

            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));

            for (uint j=0;j<methods.length;j++) {

                whiteListContractMethodMap[toContract][methods[j]] = true;

            }

        }

    }

    

    function removeContractMethodWhiteList(bytes[] memory contractMethodWhiteList) public onlyWhiteLister {

        for (uint i=0;i<contractMethodWhiteList.length;i++) {

            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));

            for (uint j=0;j<methods.length;j++) {

                whiteListContractMethodMap[toContract][methods[j]] = false;

            }

        }

    }



    /* @notice              sync Poly chain genesis block header to smart contrat

    *  @dev                 this function can only be called once, nextbookkeeper of rawHeader can't be empty

    *  @param rawHeader     Poly chain genesis block raw header or raw Header including switching consensus peers info

    *  @return              true or false

    */

    function initGenesisBlock(bytes memory rawHeader, bytes memory pubKeyList) whenNotPaused public returns(bool) {

        // Load Ethereum cross chain data contract

        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);

        

        // Make sure the contract has not been initialized before

        require(eccd.getCurEpochConPubKeyBytes().length == 0, "EthCrossChainData contract has already been initialized!");

        

        // Parse header and convit the public keys into nextBookKeeper and compare it with header.nextBookKeeper to verify the validity of signature

        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);

        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);

        require(header.nextBookkeeper == nextBookKeeper, "NextBookers illegal");

        

        // Record current epoch start height and public keys (by storing them in address format)

        require(eccd.putCurEpochStartHeight(header.height), "Save Poly chain current epoch start height to Data contract failed!");

        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), "Save Poly chain current epoch book keepers to Data contract failed!");

        

        // Fire the event

        emit InitGenesisBlockEvent(header.height, rawHeader);

        return true;

    }

    

    /* @notice              change Poly chain consensus book keeper

    *  @param rawHeader     Poly chain change book keeper block raw header

    *  @param pubKeyList    Poly chain consensus nodes public key list

    *  @param sigList       Poly chain consensus nodes signature list

    *  @return              true or false

    */

    function changeBookKeeper(bytes memory rawHeader, bytes memory pubKeyList, bytes memory sigList) whenNotPaused public returns(bool) {

        // Load Ethereum cross chain data contract

        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);

        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);

        

        // Make sure rawHeader.height is higher than recorded current epoch start height

        uint64 curEpochStartHeight = eccd.getCurEpochStartHeight();

        require(header.height > curEpochStartHeight, "The height of header is lower than current epoch start height!");

        

        // Ensure the rawHeader is the key header including info of switching consensus peers by containing non-empty nextBookKeeper field

        require(header.nextBookkeeper != bytes20(0), "The nextBookKeeper of header is empty");

        

        // Verify signature of rawHeader comes from pubKeyList

        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());

        uint n = polyChainBKs.length;

        require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), "Verify signature failed!");

        

        // Convert pubKeyList into ethereum address format and make sure the compound address from the converted ethereum addresses

        // equals passed in header.nextBooker

        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);

        require(header.nextBookkeeper == nextBookKeeper, "NextBookers illegal");

        

        // update current epoch start height of Poly chain and current epoch consensus peers book keepers addresses

        require(eccd.putCurEpochStartHeight(header.height), "Save MC LatestHeight to Data contract failed!");

        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), "Save Poly chain book keepers bytes to Data contract failed!");

        

        // Fire the change book keeper event

        emit ChangeBookKeeperEvent(header.height, rawHeader);

        return true;

    }





    /* @notice              ERC20 token cross chain to other blockchain.

    *                       this function push tx event to blockchain

    *  @param toChainId     Target chain id

    *  @param toContract    Target smart contract address in target block chain

    *  @param txData        Transaction data for target chain, include to_address, amount

    *  @return              true or false

    */

    function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) {

        // Only allow whitelist contract to call

        require(whiteListFromContract[msg.sender],"Invalid from contract");

        

        // Load Ethereum cross chain data contract

        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);

        

        // To help differentiate two txs, the ethTxHashIndex is increasing automatically

        uint256 txHashIndex = eccd.getEthTxHashIndex();

        

        // Convert the uint256 into bytes

        bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex);

        

        // Construct the makeTxParam, and put the hash info storage, to help provide proof of tx existence

        bytes memory rawParam = abi.encodePacked(ZeroCopySink.WriteVarBytes(paramTxHash),

            ZeroCopySink.WriteVarBytes(abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)))),

            ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)),

            ZeroCopySink.WriteUint64(toChainId),

            ZeroCopySink.WriteVarBytes(toContract),

            ZeroCopySink.WriteVarBytes(method),

            ZeroCopySink.WriteVarBytes(txData)

        );

        

        // Must save it in the storage to be included in the proof to be verified.

        require(eccd.putEthTxHash(keccak256(rawParam)), "Save ethTxHash by index to Data contract failed!");

        

        // Fire the cross chain event denoting there is a cross chain request from Ethereum network to other public chains through Poly chain network

        emit CrossChainEvent(tx.origin, paramTxHash, msg.sender, toChainId, toContract, rawParam);

        return true;

    }

    /* @notice              Verify Poly chain header and proof, execute the cross chain tx from Poly chain to Ethereum

    *  @param proof         Poly chain tx merkle proof

    *  @param rawHeader     The header containing crossStateRoot to verify the above tx merkle proof

    *  @param headerProof   The header merkle proof used to verify rawHeader

    *  @param curRawHeader  Any header in current epoch consensus of Poly chain

    *  @param headerSig     The coverted signature veriable for solidity derived from Poly chain consensus nodes' signature

    *                       used to verify the validity of curRawHeader

    *  @return              true or false

    */

    function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){

        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);

        // Load ehereum cross chain data contract

        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);

        

        // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[]

        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());



        uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();



        uint n = polyChainBKs.length;

        if (header.height >= curEpochStartHeight) {

            // It's enough to verify rawHeader signature

            require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), "Verify poly chain header signature failed!");

        } else {

            // We need to verify the signature of curHeader 

            require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), "Verify poly chain current epoch header signature failed!");



            // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot

            ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);

            bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);

            require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), "verify header proof failed!");

        }

        

        // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof

        bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);

        

        // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed

        ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);

        require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), "the transaction has been executed!");

        require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), "Save crosschain tx exist failed!");

        

        // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network

        require(toMerkleValue.makeTxParam.toChainId == chainId, "This Tx is not aiming at this network!");

        

        // Obtain the targeting contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side

        address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);

        

        // only invoke PreWhiteListed Contract and method For Now

        require(whiteListContractMethodMap[toContract][toMerkleValue.makeTxParam.method],"Invalid to contract or method");



        //TODO: check this part to make sure we commit the next line when doing local net UT test

        require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), "Execute CrossChain Tx failed!");



        // Fire the cross chain event denoting the executation of cross chain tx is successful,

        // and this tx is coming from other public chains to current Ethereum network

        emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);



        return true;

    }

    

    /* @notice                  Dynamically invoke the targeting contract, and trigger executation of cross chain tx on Ethereum side

    *  @param _toContract       The targeting contract that will be invoked by the Ethereum Cross Chain Manager contract

    *  @param _method           At which method will be invoked within the targeting contract

    *  @param _args             The parameter that will be passed into the targeting contract

    *  @param _fromContractAddr From chain smart contract address

    *  @param _fromChainId      Indicate from which chain current cross chain tx comes 

    *  @return                  true or false

    */

    function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){

        // Ensure the targeting contract gonna be invoked is indeed a contract rather than a normal account address

        require(Utils.isContract(_toContract), "The passed in address is not a contract!");

        bytes memory returnData;

        bool success;

        

        // The returnData will be bytes32, the last byte must be 01;

        (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, "(bytes,bytes,uint64)"))), abi.encode(_args, _fromContractAddr, _fromChainId)));

        

        // Ensure the executation is successful

        require(success == true, "EthCrossChain call business contract failed");

        

        // Ensure the returned value is true

        require(returnData.length != 0, "No return value from business contract!");

        (bool res,) = ZeroCopySource.NextBool(returnData, 31);

        require(res == true, "EthCrossChain call business contract return is not true");

        

        return true;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\EthCrossChainManagerProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2023-02-06

*/



// File: eth-contracts/contracts/core/cross_chain_manager/interface/IEthCrossChainManagerProxy.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the EthCrossChainManagerProxy for business contract like LockProxy to obtain the reliable EthCrossChainManager contract hash.

 */

interface IEthCrossChainManagerProxy {

    function getEthCrossChainManager() external view returns (address);

}



// File: eth-contracts/contracts/core/cross_chain_manager/interface/IUpgradableECCM.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of upgradableECCM to make ECCM be upgradable, the implementation is in UpgradableECCM.sol

 */

interface IUpgradableECCM {

    function pause() external returns (bool);

    function unpause() external returns (bool);

    function paused() external view returns (bool);

    function upgradeToNew(address) external returns (bool);

    function isOwner() external view returns (bool);

    function setChainId(uint64 _newChainId) external returns (bool);

}



// File: eth-contracts/contracts/libs/GSN/Context.sol



pragma solidity ^0.5.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: eth-contracts/contracts/libs/lifecycle/Pausable.sol



pragma solidity ^0.5.0;





/**

 * @dev Contract module which allows children to implement an emergency stop

 * mechanism that can be triggered by an authorized account.

 *

 * This module is used through inheritance. It will make available the

 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to

 * the functions of your contract. Note that they will not be pausable by

 * simply including this module, only once the modifiers are put in place.

 */

contract Pausable is Context {

    /**

     * @dev Emitted when the pause is triggered by a pauser (`account`).

     */

    event Paused(address account);



    /**

     * @dev Emitted when the pause is lifted by a pauser (`account`).

     */

    event Unpaused(address account);



    bool private _paused;



    /**

     * @dev Initializes the contract in unpaused state.

     */

    constructor () internal {

        _paused = false;

    }



    /**

     * @dev Returns true if the contract is paused, and false otherwise.

     */

    function paused() public view returns (bool) {

        return _paused;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is not paused.

     */

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is paused.

     */

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    /**

     * @dev Called to pause, triggers stopped state.

     */

    function _pause() internal whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    /**

     * @dev Called to unpause, returns to normal state.

     */

    function _unpause() internal whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }

}



// File: eth-contracts/contracts/libs/ownership/Ownable.sol



pragma solidity ^0.5.0;



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public  onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: eth-contracts/contracts/core/cross_chain_manager/upgrade/EthCrossChainManagerProxy.sol



pragma solidity ^0.5.0;











contract EthCrossChainManagerProxy is IEthCrossChainManagerProxy, Ownable, Pausable {

    address private EthCrossChainManagerAddr_;

    

    constructor(address _ethCrossChainManagerAddr) public {

        EthCrossChainManagerAddr_ = _ethCrossChainManagerAddr;

    }

    

    function pause() onlyOwner public returns (bool) {

        if (paused()) {

            return true;

        }

        _pause();

        return true;

    }

    function unpause() onlyOwner public returns (bool) {

        if (!paused()) {

            return true;

        }

        _unpause();

        return true;

    }

    function pauseEthCrossChainManager() onlyOwner whenNotPaused public returns (bool) {

        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);

        require(pause(), "pause EthCrossChainManagerProxy contract failed!");

        require(eccm.pause(), "pause EthCrossChainManager contract failed!");

    }

    function upgradeEthCrossChainManager(address _newEthCrossChainManagerAddr) onlyOwner whenPaused public returns (bool) {

        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);

        if (!eccm.paused()) {

            require(eccm.pause(), "Pause old EthCrossChainManager contract failed!");

        }

        require(eccm.upgradeToNew(_newEthCrossChainManagerAddr), "EthCrossChainManager upgradeToNew failed!");

        IUpgradableECCM neweccm = IUpgradableECCM(_newEthCrossChainManagerAddr);

        require(neweccm.isOwner(), "EthCrossChainManagerProxy is not owner of new EthCrossChainManager contract");

        EthCrossChainManagerAddr_ = _newEthCrossChainManagerAddr;

    }

    function unpauseEthCrossChainManager() onlyOwner whenPaused public returns (bool) {

        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);

        require(eccm.unpause(), "unpause EthCrossChainManager contract failed!");

        require(unpause(), "unpause EthCrossChainManagerProxy contract failed!");

    }

    function getEthCrossChainManager() whenNotPaused public view returns (address) {

        return EthCrossChainManagerAddr_;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\FiatTokenProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2018-08-03

*/



pragma solidity ^0.4.24;



// File: zos-lib/contracts/upgradeability/Proxy.sol



/**

 * @title Proxy

 * @dev Implements delegation of calls to other contracts, with proper

 * forwarding of return values and bubbling of failures.

 * It defines a fallback function that delegates all calls to the address

 * returned by the abstract _implementation() internal function.

 */

contract Proxy {

  /**

   * @dev Fallback function.

   * Implemented entirely in `_fallback`.

   */

  function () payable external {

    _fallback();

  }



  /**

   * @return The Address of the implementation.

   */

  function _implementation() internal view returns (address);



  /**

   * @dev Delegates execution to an implementation contract.

   * This is a low level function that doesn't return to its internal call site.

   * It will return to the external caller whatever the implementation returns.

   * @param implementation Address to delegate.

   */

  function _delegate(address implementation) internal {

    assembly {

      // Copy msg.data. We take full control of memory in this inline assembly

      // block because it will not return to Solidity code. We overwrite the

      // Solidity scratch pad at memory position 0.

      calldatacopy(0, 0, calldatasize)



      // Call the implementation.

      // out and outsize are 0 because we don't know the size yet.

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      // Copy the returned data.

      returndatacopy(0, 0, returndatasize)



      switch result

      // delegatecall returns 0 on error.

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  /**

   * @dev Function that is run as the first thing in the fallback function.

   * Can be redefined in derived contracts to add functionality.

   * Redefinitions must call super._willFallback().

   */

  function _willFallback() internal {

  }



  /**

   * @dev fallback implementation.

   * Extracted to enable manual triggering.

   */

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



// File: openzeppelin-solidity/contracts/AddressUtils.sol



/**

 * Utility library of inline functions on addresses

 */

library AddressUtils {



  /**

   * Returns whether the target address is a contract

   * @dev This function will return false if invoked during the constructor of a contract,

   * as the code is not actually created until after the constructor finishes.

   * @param addr address to check

   * @return whether the target address is a contract

   */

  function isContract(address addr) internal view returns (bool) {

    uint256 size;

    // XXX Currently there is no better way to check if there is a contract in an address

    // than to check the size of the code at that address.

    // See https://ethereum.stackexchange.com/a/14016/36603

    // for more details about how this works.

    // TODO Check this again before the Serenity release, because all addresses will be

    // contracts then.

    // solium-disable-next-line security/no-inline-assembly

    assembly { size := extcodesize(addr) }

    return size > 0;

  }



}



// File: zos-lib/contracts/upgradeability/UpgradeabilityProxy.sol



/**

 * @title UpgradeabilityProxy

 * @dev This contract implements a proxy that allows to change the

 * implementation address to which it will delegate.

 * Such a change is called an implementation upgrade.

 */

contract UpgradeabilityProxy is Proxy {

  /**

   * @dev Emitted when the implementation is upgraded.

   * @param implementation Address of the new implementation.

   */

  event Upgraded(address implementation);



  /**

   * @dev Storage slot with the address of the current implementation.

   * This is the keccak-256 hash of "org.zeppelinos.proxy.implementation", and is

   * validated in the constructor.

   */

  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;



  /**

   * @dev Contract constructor.

   * @param _implementation Address of the initial implementation.

   */

  constructor(address _implementation) public {

    assert(IMPLEMENTATION_SLOT == keccak256("org.zeppelinos.proxy.implementation"));



    _setImplementation(_implementation);

  }



  /**

   * @dev Returns the current implementation.

   * @return Address of the current implementation

   */

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  /**

   * @dev Upgrades the proxy to a new implementation.

   * @param newImplementation Address of the new implementation.

   */

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  /**

   * @dev Sets the implementation address of the proxy.

   * @param newImplementation Address of the new implementation.

   */

  function _setImplementation(address newImplementation) private {

    require(AddressUtils.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



// File: zos-lib/contracts/upgradeability/AdminUpgradeabilityProxy.sol



/**

 * @title AdminUpgradeabilityProxy

 * @dev This contract combines an upgradeability proxy with an authorization

 * mechanism for administrative tasks.

 * All external functions in this contract must be guarded by the

 * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity

 * feature proposal that would enable this to be done automatically.

 */

contract AdminUpgradeabilityProxy is UpgradeabilityProxy {

  /**

   * @dev Emitted when the administration has been transferred.

   * @param previousAdmin Address of the previous admin.

   * @param newAdmin Address of the new admin.

   */

  event AdminChanged(address previousAdmin, address newAdmin);



  /**

   * @dev Storage slot with the admin of the contract.

   * This is the keccak-256 hash of "org.zeppelinos.proxy.admin", and is

   * validated in the constructor.

   */

  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;



  /**

   * @dev Modifier to check whether the `msg.sender` is the admin.

   * If it is, it will run the function. Otherwise, it will delegate the call

   * to the implementation.

   */

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  /**

   * Contract constructor.

   * It sets the `msg.sender` as the proxy administrator.

   * @param _implementation address of the initial implementation.

   */

  constructor(address _implementation) UpgradeabilityProxy(_implementation) public {

    assert(ADMIN_SLOT == keccak256("org.zeppelinos.proxy.admin"));



    _setAdmin(msg.sender);

  }



  /**

   * @return The address of the proxy admin.

   */

  function admin() external view ifAdmin returns (address) {

    return _admin();

  }



  /**

   * @return The address of the implementation.

   */

  function implementation() external view ifAdmin returns (address) {

    return _implementation();

  }



  /**

   * @dev Changes the admin of the proxy.

   * Only the current admin can call this function.

   * @param newAdmin Address to transfer proxy administration to.

   */

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  /**

   * @dev Upgrade the backing implementation of the proxy.

   * Only the admin can call this function.

   * @param newImplementation Address of the new implementation.

   */

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  /**

   * @dev Upgrade the backing implementation of the proxy and call a function

   * on the new implementation.

   * This is useful to initialize the proxied contract.

   * @param newImplementation Address of the new implementation.

   * @param data Data to send as msg.data in the low level call.

   * It should include the signature and the parameters of the function to be

   * called, as described in

   * https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding.

   */

  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {

    _upgradeTo(newImplementation);

    require(address(this).call.value(msg.value)(data));

  }



  /**

   * @return The admin slot.

   */

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  /**

   * @dev Sets the address of the proxy admin.

   * @param newAdmin Address of the new proxy admin.

   */

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  /**

   * @dev Only fall back when the sender is not the admin.

   */

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



// File: contracts/FiatTokenProxy.sol



/**

* Copyright CENTRE SECZ 2018

*

* Permission is hereby granted, free of charge, to any person obtaining a copy 

* of this software and associated documentation files (the "Software"), to deal 

* in the Software without restriction, including without limitation the rights 

* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 

* copies of the Software, and to permit persons to whom the Software is furnished to 

* do so, subject to the following conditions:

*

* The above copyright notice and this permission notice shall be included in all 

* copies or substantial portions of the Software.

*

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 

* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 

* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 

* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,

* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 

* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/



pragma solidity ^0.4.24;





/**

 * @title FiatTokenProxy

 * @dev This contract proxies FiatToken calls and enables FiatToken upgrades

*/ 

contract FiatTokenProxy is AdminUpgradeabilityProxy {

    constructor(address _implementation) public AdminUpgradeabilityProxy(_implementation) {

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\FiatTokenV2_1.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-04-17

*/



// File: @openzeppelin/contracts/math/SafeMath.sol



// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: @openzeppelin/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.6.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount)

        external

        returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender)

        external

        view

        returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );

}



// File: contracts/v1/AbstractFiatTokenV1.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



abstract contract AbstractFiatTokenV1 is IERC20 {

    function _approve(

        address owner,

        address spender,

        uint256 value

    ) internal virtual;



    function _transfer(

        address from,

        address to,

        uint256 value

    ) internal virtual;

}



// File: contracts/v1/Ownable.sol



/**

 * Copyright (c) 2018 zOS Global Limited.

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */

pragma solidity 0.6.12;



/**

 * @notice The Ownable contract has an owner address, and provides basic

 * authorization control functions

 * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-labs/blob/3887ab77b8adafba4a26ace002f3a684c1a3388b/upgradeability_ownership/contracts/ownership/Ownable.sol

 * Modifications:

 * 1. Consolidate OwnableStorage into this contract (7/13/18)

 * 2. Reformat, conform to Solidity 0.6 syntax, and add error messages (5/13/20)

 * 3. Make public functions external (5/27/20)

 */

contract Ownable {

    // Owner of the contract

    address private _owner;



    /**

     * @dev Event to show ownership has been transferred

     * @param previousOwner representing the address of the previous owner

     * @param newOwner representing the address of the new owner

     */

    event OwnershipTransferred(address previousOwner, address newOwner);



    /**

     * @dev The constructor sets the original owner of the contract to the sender account.

     */

    constructor() public {

        setOwner(msg.sender);

    }



    /**

     * @dev Tells the address of the owner

     * @return the address of the owner

     */

    function owner() external view returns (address) {

        return _owner;

    }



    /**

     * @dev Sets a new owner address

     */

    function setOwner(address newOwner) internal {

        _owner = newOwner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(msg.sender == _owner, "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) external onlyOwner {

        require(

            newOwner != address(0),

            "Ownable: new owner is the zero address"

        );

        emit OwnershipTransferred(_owner, newOwner);

        setOwner(newOwner);

    }

}



// File: contracts/v1/Pausable.sol



/**

 * Copyright (c) 2016 Smart Contract Solutions, Inc.

 * Copyright (c) 2018-2020 CENTRE SECZ0

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @notice Base contract which allows children to implement an emergency stop

 * mechanism

 * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/feb665136c0dae9912e08397c1a21c4af3651ef3/contracts/lifecycle/Pausable.sol

 * Modifications:

 * 1. Added pauser role, switched pause/unpause to be onlyPauser (6/14/2018)

 * 2. Removed whenNotPause/whenPaused from pause/unpause (6/14/2018)

 * 3. Removed whenPaused (6/14/2018)

 * 4. Switches ownable library to use ZeppelinOS (7/12/18)

 * 5. Remove constructor (7/13/18)

 * 6. Reformat, conform to Solidity 0.6 syntax and add error messages (5/13/20)

 * 7. Make public functions external (5/27/20)

 */

contract Pausable is Ownable {

    event Pause();

    event Unpause();

    event PauserChanged(address indexed newAddress);



    address public pauser;

    bool public paused = false;



    /**

     * @dev Modifier to make a function callable only when the contract is not paused.

     */

    modifier whenNotPaused() {

        require(!paused, "Pausable: paused");

        _;

    }



    /**

     * @dev throws if called by any account other than the pauser

     */

    modifier onlyPauser() {

        require(msg.sender == pauser, "Pausable: caller is not the pauser");

        _;

    }



    /**

     * @dev called by the owner to pause, triggers stopped state

     */

    function pause() external onlyPauser {

        paused = true;

        emit Pause();

    }



    /**

     * @dev called by the owner to unpause, returns to normal state

     */

    function unpause() external onlyPauser {

        paused = false;

        emit Unpause();

    }



    /**

     * @dev update the pauser role

     */

    function updatePauser(address _newPauser) external onlyOwner {

        require(

            _newPauser != address(0),

            "Pausable: new pauser is the zero address"

        );

        pauser = _newPauser;

        emit PauserChanged(pauser);

    }

}



// File: contracts/v1/Blacklistable.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @title Blacklistable Token

 * @dev Allows accounts to be blacklisted by a "blacklister" role

 */

contract Blacklistable is Ownable {

    address public blacklister;

    mapping(address => bool) internal blacklisted;



    event Blacklisted(address indexed _account);

    event UnBlacklisted(address indexed _account);

    event BlacklisterChanged(address indexed newBlacklister);



    /**

     * @dev Throws if called by any account other than the blacklister

     */

    modifier onlyBlacklister() {

        require(

            msg.sender == blacklister,

            "Blacklistable: caller is not the blacklister"

        );

        _;

    }



    /**

     * @dev Throws if argument account is blacklisted

     * @param _account The address to check

     */

    modifier notBlacklisted(address _account) {

        require(

            !blacklisted[_account],

            "Blacklistable: account is blacklisted"

        );

        _;

    }



    /**

     * @dev Checks if account is blacklisted

     * @param _account The address to check

     */

    function isBlacklisted(address _account) external view returns (bool) {

        return blacklisted[_account];

    }



    /**

     * @dev Adds account to blacklist

     * @param _account The address to blacklist

     */

    function blacklist(address _account) external onlyBlacklister {

        blacklisted[_account] = true;

        emit Blacklisted(_account);

    }



    /**

     * @dev Removes account from blacklist

     * @param _account The address to remove from the blacklist

     */

    function unBlacklist(address _account) external onlyBlacklister {

        blacklisted[_account] = false;

        emit UnBlacklisted(_account);

    }



    function updateBlacklister(address _newBlacklister) external onlyOwner {

        require(

            _newBlacklister != address(0),

            "Blacklistable: new blacklister is the zero address"

        );

        blacklister = _newBlacklister;

        emit BlacklisterChanged(blacklister);

    }

}



// File: contracts/v1/FiatTokenV1.sol



/**

 *

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @title FiatToken

 * @dev ERC20 Token backed by fiat reserves

 */

contract FiatTokenV1 is AbstractFiatTokenV1, Ownable, Pausable, Blacklistable {

    using SafeMath for uint256;



    string public name;

    string public symbol;

    uint8 public decimals;

    string public currency;

    address public masterMinter;

    bool internal initialized;



    mapping(address => uint256) internal balances;

    mapping(address => mapping(address => uint256)) internal allowed;

    uint256 internal totalSupply_ = 0;

    mapping(address => bool) internal minters;

    mapping(address => uint256) internal minterAllowed;



    event Mint(address indexed minter, address indexed to, uint256 amount);

    event Burn(address indexed burner, uint256 amount);

    event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);

    event MinterRemoved(address indexed oldMinter);

    event MasterMinterChanged(address indexed newMasterMinter);



    function initialize(

        string memory tokenName,

        string memory tokenSymbol,

        string memory tokenCurrency,

        uint8 tokenDecimals,

        address newMasterMinter,

        address newPauser,

        address newBlacklister,

        address newOwner

    ) public {

        require(!initialized, "FiatToken: contract is already initialized");

        require(

            newMasterMinter != address(0),

            "FiatToken: new masterMinter is the zero address"

        );

        require(

            newPauser != address(0),

            "FiatToken: new pauser is the zero address"

        );

        require(

            newBlacklister != address(0),

            "FiatToken: new blacklister is the zero address"

        );

        require(

            newOwner != address(0),

            "FiatToken: new owner is the zero address"

        );



        name = tokenName;

        symbol = tokenSymbol;

        currency = tokenCurrency;

        decimals = tokenDecimals;

        masterMinter = newMasterMinter;

        pauser = newPauser;

        blacklister = newBlacklister;

        setOwner(newOwner);

        initialized = true;

    }



    /**

     * @dev Throws if called by any account other than a minter

     */

    modifier onlyMinters() {

        require(minters[msg.sender], "FiatToken: caller is not a minter");

        _;

    }



    /**

     * @dev Function to mint tokens

     * @param _to The address that will receive the minted tokens.

     * @param _amount The amount of tokens to mint. Must be less than or equal

     * to the minterAllowance of the caller.

     * @return A boolean that indicates if the operation was successful.

     */

    function mint(address _to, uint256 _amount)

        external

        whenNotPaused

        onlyMinters

        notBlacklisted(msg.sender)

        notBlacklisted(_to)

        returns (bool)

    {

        require(_to != address(0), "FiatToken: mint to the zero address");

        require(_amount > 0, "FiatToken: mint amount not greater than 0");



        uint256 mintingAllowedAmount = minterAllowed[msg.sender];

        require(

            _amount <= mintingAllowedAmount,

            "FiatToken: mint amount exceeds minterAllowance"

        );



        totalSupply_ = totalSupply_.add(_amount);

        balances[_to] = balances[_to].add(_amount);

        minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount);

        emit Mint(msg.sender, _to, _amount);

        emit Transfer(address(0), _to, _amount);

        return true;

    }



    /**

     * @dev Throws if called by any account other than the masterMinter

     */

    modifier onlyMasterMinter() {

        require(

            msg.sender == masterMinter,

            "FiatToken: caller is not the masterMinter"

        );

        _;

    }



    /**

     * @dev Get minter allowance for an account

     * @param minter The address of the minter

     */

    function minterAllowance(address minter) external view returns (uint256) {

        return minterAllowed[minter];

    }



    /**

     * @dev Checks if account is a minter

     * @param account The address to check

     */

    function isMinter(address account) external view returns (bool) {

        return minters[account];

    }



    /**

     * @notice Amount of remaining tokens spender is allowed to transfer on

     * behalf of the token owner

     * @param owner     Token owner's address

     * @param spender   Spender's address

     * @return Allowance amount

     */

    function allowance(address owner, address spender)

        external

        override

        view

        returns (uint256)

    {

        return allowed[owner][spender];

    }



    /**

     * @dev Get totalSupply of token

     */

    function totalSupply() external override view returns (uint256) {

        return totalSupply_;

    }



    /**

     * @dev Get token balance of an account

     * @param account address The account

     */

    function balanceOf(address account)

        external

        override

        view

        returns (uint256)

    {

        return balances[account];

    }



    /**

     * @notice Set spender's allowance over the caller's tokens to be a given

     * value.

     * @param spender   Spender's address

     * @param value     Allowance amount

     * @return True if successful

     */

    function approve(address spender, uint256 value)

        external

        override

        whenNotPaused

        notBlacklisted(msg.sender)

        notBlacklisted(spender)

        returns (bool)

    {

        _approve(msg.sender, spender, value);

        return true;

    }



    /**

     * @dev Internal function to set allowance

     * @param owner     Token owner's address

     * @param spender   Spender's address

     * @param value     Allowance amount

     */

    function _approve(

        address owner,

        address spender,

        uint256 value

    ) internal override {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");

        allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    /**

     * @notice Transfer tokens by spending allowance

     * @param from  Payer's address

     * @param to    Payee's address

     * @param value Transfer amount

     * @return True if successful

     */

    function transferFrom(

        address from,

        address to,

        uint256 value

    )

        external

        override

        whenNotPaused

        notBlacklisted(msg.sender)

        notBlacklisted(from)

        notBlacklisted(to)

        returns (bool)

    {

        require(

            value <= allowed[from][msg.sender],

            "ERC20: transfer amount exceeds allowance"

        );

        _transfer(from, to, value);

        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);

        return true;

    }



    /**

     * @notice Transfer tokens from the caller

     * @param to    Payee's address

     * @param value Transfer amount

     * @return True if successful

     */

    function transfer(address to, uint256 value)

        external

        override

        whenNotPaused

        notBlacklisted(msg.sender)

        notBlacklisted(to)

        returns (bool)

    {

        _transfer(msg.sender, to, value);

        return true;

    }



    /**

     * @notice Internal function to process transfers

     * @param from  Payer's address

     * @param to    Payee's address

     * @param value Transfer amount

     */

    function _transfer(

        address from,

        address to,

        uint256 value

    ) internal override {

        require(from != address(0), "ERC20: transfer from the zero address");

        require(to != address(0), "ERC20: transfer to the zero address");

        require(

            value <= balances[from],

            "ERC20: transfer amount exceeds balance"

        );



        balances[from] = balances[from].sub(value);

        balances[to] = balances[to].add(value);

        emit Transfer(from, to, value);

    }



    /**

     * @dev Function to add/update a new minter

     * @param minter The address of the minter

     * @param minterAllowedAmount The minting amount allowed for the minter

     * @return True if the operation was successful.

     */

    function configureMinter(address minter, uint256 minterAllowedAmount)

        external

        whenNotPaused

        onlyMasterMinter

        returns (bool)

    {

        minters[minter] = true;

        minterAllowed[minter] = minterAllowedAmount;

        emit MinterConfigured(minter, minterAllowedAmount);

        return true;

    }



    /**

     * @dev Function to remove a minter

     * @param minter The address of the minter to remove

     * @return True if the operation was successful.

     */

    function removeMinter(address minter)

        external

        onlyMasterMinter

        returns (bool)

    {

        minters[minter] = false;

        minterAllowed[minter] = 0;

        emit MinterRemoved(minter);

        return true;

    }



    /**

     * @dev allows a minter to burn some of its own tokens

     * Validates that caller is a minter and that sender is not blacklisted

     * amount is less than or equal to the minter's account balance

     * @param _amount uint256 the amount of tokens to be burned

     */

    function burn(uint256 _amount)

        external

        whenNotPaused

        onlyMinters

        notBlacklisted(msg.sender)

    {

        uint256 balance = balances[msg.sender];

        require(_amount > 0, "FiatToken: burn amount not greater than 0");

        require(balance >= _amount, "FiatToken: burn amount exceeds balance");



        totalSupply_ = totalSupply_.sub(_amount);

        balances[msg.sender] = balance.sub(_amount);

        emit Burn(msg.sender, _amount);

        emit Transfer(msg.sender, address(0), _amount);

    }



    function updateMasterMinter(address _newMasterMinter) external onlyOwner {

        require(

            _newMasterMinter != address(0),

            "FiatToken: new masterMinter is the zero address"

        );

        masterMinter = _newMasterMinter;

        emit MasterMinterChanged(masterMinter);

    }

}



// File: @openzeppelin/contracts/utils/Address.sol



pragma solidity ^0.6.2;



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;



            bytes32 accountHash

         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly {

            codehash := extcodehash(account)

        }

        return (codehash != accountHash && codehash != 0x0);

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(

            address(this).balance >= amount,

            "Address: insufficient balance"

        );



        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value

        (bool success, ) = recipient.call{ value: amount }("");

        require(

            success,

            "Address: unable to send value, recipient may have reverted"

        );

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain`call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data)

        internal

        returns (bytes memory)

    {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return

            functionCallWithValue(

                target,

                data,

                value,

                "Address: low-level call with value failed"

            );

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(

            address(this).balance >= value,

            "Address: insufficient balance for call"

        );

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(

        address target,

        bytes memory data,

        uint256 weiValue,

        string memory errorMessage

    ) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = target.call{

            value: weiValue

        }(data);

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                // solhint-disable-next-line no-inline-assembly

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol



pragma solidity ^0.6.0;



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(token.transfer.selector, to, value)

        );

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)

        );

    }



    /**

     * @dev Deprecated. This function has issues similar to the ones found in

     * {IERC20-approve}, and its usage is discouraged.

     *

     * Whenever possible, use {safeIncreaseAllowance} and

     * {safeDecreaseAllowance} instead.

     */

    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(token.approve.selector, spender, value)

        );

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(

            value

        );

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(

                token.approve.selector,

                spender,

                newAllowance

            )

        );

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(

            value,

            "SafeERC20: decreased allowance below zero"

        );

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(

                token.approve.selector,

                spender,

                newAllowance

            )

        );

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that

        // the target address contains contract code and also asserts for success in the low-level call.



        bytes memory returndata = address(token).functionCall(

            data,

            "SafeERC20: low-level call failed"

        );

        if (returndata.length > 0) {

            // Return data is optional

            // solhint-disable-next-line max-line-length

            require(

                abi.decode(returndata, (bool)),

                "SafeERC20: ERC20 operation did not succeed"

            );

        }

    }

}



// File: contracts/v1.1/Rescuable.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



contract Rescuable is Ownable {

    using SafeERC20 for IERC20;



    address private _rescuer;



    event RescuerChanged(address indexed newRescuer);



    /**

     * @notice Returns current rescuer

     * @return Rescuer's address

     */

    function rescuer() external view returns (address) {

        return _rescuer;

    }



    /**

     * @notice Revert if called by any account other than the rescuer.

     */

    modifier onlyRescuer() {

        require(msg.sender == _rescuer, "Rescuable: caller is not the rescuer");

        _;

    }



    /**

     * @notice Rescue ERC20 tokens locked up in this contract.

     * @param tokenContract ERC20 token contract address

     * @param to        Recipient address

     * @param amount    Amount to withdraw

     */

    function rescueERC20(

        IERC20 tokenContract,

        address to,

        uint256 amount

    ) external onlyRescuer {

        tokenContract.safeTransfer(to, amount);

    }



    /**

     * @notice Assign the rescuer role to a given address.

     * @param newRescuer New rescuer's address

     */

    function updateRescuer(address newRescuer) external onlyOwner {

        require(

            newRescuer != address(0),

            "Rescuable: new rescuer is the zero address"

        );

        _rescuer = newRescuer;

        emit RescuerChanged(newRescuer);

    }

}



// File: contracts/v1.1/FiatTokenV1_1.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @title FiatTokenV1_1

 * @dev ERC20 Token backed by fiat reserves

 */

contract FiatTokenV1_1 is FiatTokenV1, Rescuable {



}



// File: contracts/v2/AbstractFiatTokenV2.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



abstract contract AbstractFiatTokenV2 is AbstractFiatTokenV1 {

    function _increaseAllowance(

        address owner,

        address spender,

        uint256 increment

    ) internal virtual;



    function _decreaseAllowance(

        address owner,

        address spender,

        uint256 decrement

    ) internal virtual;

}



// File: contracts/util/ECRecover.sol



/**

 * Copyright (c) 2016-2019 zOS Global Limited

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @title ECRecover

 * @notice A library that provides a safe ECDSA recovery function

 */

library ECRecover {

    /**

     * @notice Recover signer's address from a signed message

     * @dev Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65e4ffde586ec89af3b7e9140bdc9235d1254853/contracts/cryptography/ECDSA.sol

     * Modifications: Accept v, r, and s as separate arguments

     * @param digest    Keccak-256 hash digest of the signed message

     * @param v         v of the signature

     * @param r         r of the signature

     * @param s         s of the signature

     * @return Signer address

     */

    function recover(

        bytes32 digest,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address) {

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature

        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines

        // the valid range for s in (281): 0 < s < secp256k1n ?? 2 + 1, and for v in (282): v ?? {27, 28}. Most

        // signatures from current libraries generate a unique signature with an s-value in the lower half order.

        //

        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value

        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or

        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept

        // these malleable signatures as well.

        if (

            uint256(s) >

            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0

        ) {

            revert("ECRecover: invalid signature 's' value");

        }



        if (v != 27 && v != 28) {

            revert("ECRecover: invalid signature 'v' value");

        }



        // If the signature is valid (and not malleable), return the signer address

        address signer = ecrecover(digest, v, r, s);

        require(signer != address(0), "ECRecover: invalid signature");



        return signer;

    }

}



// File: contracts/util/EIP712.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @title EIP712

 * @notice A library that provides EIP712 helper functions

 */

library EIP712 {

    /**

     * @notice Make EIP712 domain separator

     * @param name      Contract name

     * @param version   Contract version

     * @return Domain separator

     */

    function makeDomainSeparator(string memory name, string memory version)

        internal

        view

        returns (bytes32)

    {

        uint256 chainId;

        assembly {

            chainId := chainid()

        }

        return

            keccak256(

                abi.encode(

                    // keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")

                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,

                    keccak256(bytes(name)),

                    keccak256(bytes(version)),

                    chainId,

                    address(this)

                )

            );

    }



    /**

     * @notice Recover signer's address from a EIP712 signature

     * @param domainSeparator   Domain separator

     * @param v                 v of the signature

     * @param r                 r of the signature

     * @param s                 s of the signature

     * @param typeHashAndData   Type hash concatenated with data

     * @return Signer's address

     */

    function recover(

        bytes32 domainSeparator,

        uint8 v,

        bytes32 r,

        bytes32 s,

        bytes memory typeHashAndData

    ) internal pure returns (address) {

        bytes32 digest = keccak256(

            abi.encodePacked(

                "\x19\x01",

                domainSeparator,

                keccak256(typeHashAndData)

            )

        );

        return ECRecover.recover(digest, v, r, s);

    }

}



// File: contracts/v2/EIP712Domain.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @title EIP712 Domain

 */

contract EIP712Domain {

    /**

     * @dev EIP712 Domain Separator

     */

    bytes32 public DOMAIN_SEPARATOR;

}



// File: contracts/v2/EIP3009.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @title EIP-3009

 * @notice Provide internal implementation for gas-abstracted transfers

 * @dev Contracts that inherit from this must wrap these with publicly

 * accessible functions, optionally adding modifiers where necessary

 */

abstract contract EIP3009 is AbstractFiatTokenV2, EIP712Domain {

    // keccak256("TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)")

    bytes32

        public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;



    // keccak256("ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)")

    bytes32

        public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;



    // keccak256("CancelAuthorization(address authorizer,bytes32 nonce)")

    bytes32

        public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;



    /**

     * @dev authorizer address => nonce => bool (true if nonce is used)

     */

    mapping(address => mapping(bytes32 => bool)) private _authorizationStates;



    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);

    event AuthorizationCanceled(

        address indexed authorizer,

        bytes32 indexed nonce

    );



    /**

     * @notice Returns the state of an authorization

     * @dev Nonces are randomly generated 32-byte data unique to the

     * authorizer's address

     * @param authorizer    Authorizer's address

     * @param nonce         Nonce of the authorization

     * @return True if the nonce is used

     */

    function authorizationState(address authorizer, bytes32 nonce)

        external

        view

        returns (bool)

    {

        return _authorizationStates[authorizer][nonce];

    }



    /**

     * @notice Execute a transfer with a signed authorization

     * @param from          Payer's address (Authorizer)

     * @param to            Payee's address

     * @param value         Amount to be transferred

     * @param validAfter    The time after which this is valid (unix time)

     * @param validBefore   The time before which this is valid (unix time)

     * @param nonce         Unique nonce

     * @param v             v of the signature

     * @param r             r of the signature

     * @param s             s of the signature

     */

    function _transferWithAuthorization(

        address from,

        address to,

        uint256 value,

        uint256 validAfter,

        uint256 validBefore,

        bytes32 nonce,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal {

        _requireValidAuthorization(from, nonce, validAfter, validBefore);



        bytes memory data = abi.encode(

            TRANSFER_WITH_AUTHORIZATION_TYPEHASH,

            from,

            to,

            value,

            validAfter,

            validBefore,

            nonce

        );

        require(

            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == from,

            "FiatTokenV2: invalid signature"

        );



        _markAuthorizationAsUsed(from, nonce);

        _transfer(from, to, value);

    }



    /**

     * @notice Receive a transfer with a signed authorization from the payer

     * @dev This has an additional check to ensure that the payee's address

     * matches the caller of this function to prevent front-running attacks.

     * @param from          Payer's address (Authorizer)

     * @param to            Payee's address

     * @param value         Amount to be transferred

     * @param validAfter    The time after which this is valid (unix time)

     * @param validBefore   The time before which this is valid (unix time)

     * @param nonce         Unique nonce

     * @param v             v of the signature

     * @param r             r of the signature

     * @param s             s of the signature

     */

    function _receiveWithAuthorization(

        address from,

        address to,

        uint256 value,

        uint256 validAfter,

        uint256 validBefore,

        bytes32 nonce,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal {

        require(to == msg.sender, "FiatTokenV2: caller must be the payee");

        _requireValidAuthorization(from, nonce, validAfter, validBefore);



        bytes memory data = abi.encode(

            RECEIVE_WITH_AUTHORIZATION_TYPEHASH,

            from,

            to,

            value,

            validAfter,

            validBefore,

            nonce

        );

        require(

            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == from,

            "FiatTokenV2: invalid signature"

        );



        _markAuthorizationAsUsed(from, nonce);

        _transfer(from, to, value);

    }



    /**

     * @notice Attempt to cancel an authorization

     * @param authorizer    Authorizer's address

     * @param nonce         Nonce of the authorization

     * @param v             v of the signature

     * @param r             r of the signature

     * @param s             s of the signature

     */

    function _cancelAuthorization(

        address authorizer,

        bytes32 nonce,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal {

        _requireUnusedAuthorization(authorizer, nonce);



        bytes memory data = abi.encode(

            CANCEL_AUTHORIZATION_TYPEHASH,

            authorizer,

            nonce

        );

        require(

            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == authorizer,

            "FiatTokenV2: invalid signature"

        );



        _authorizationStates[authorizer][nonce] = true;

        emit AuthorizationCanceled(authorizer, nonce);

    }



    /**

     * @notice Check that an authorization is unused

     * @param authorizer    Authorizer's address

     * @param nonce         Nonce of the authorization

     */

    function _requireUnusedAuthorization(address authorizer, bytes32 nonce)

        private

        view

    {

        require(

            !_authorizationStates[authorizer][nonce],

            "FiatTokenV2: authorization is used or canceled"

        );

    }



    /**

     * @notice Check that authorization is valid

     * @param authorizer    Authorizer's address

     * @param nonce         Nonce of the authorization

     * @param validAfter    The time after which this is valid (unix time)

     * @param validBefore   The time before which this is valid (unix time)

     */

    function _requireValidAuthorization(

        address authorizer,

        bytes32 nonce,

        uint256 validAfter,

        uint256 validBefore

    ) private view {

        require(

            now > validAfter,

            "FiatTokenV2: authorization is not yet valid"

        );

        require(now < validBefore, "FiatTokenV2: authorization is expired");

        _requireUnusedAuthorization(authorizer, nonce);

    }



    /**

     * @notice Mark an authorization as used

     * @param authorizer    Authorizer's address

     * @param nonce         Nonce of the authorization

     */

    function _markAuthorizationAsUsed(address authorizer, bytes32 nonce)

        private

    {

        _authorizationStates[authorizer][nonce] = true;

        emit AuthorizationUsed(authorizer, nonce);

    }

}



// File: contracts/v2/EIP2612.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @title EIP-2612

 * @notice Provide internal implementation for gas-abstracted approvals

 */

abstract contract EIP2612 is AbstractFiatTokenV2, EIP712Domain {

    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")

    bytes32

        public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;



    mapping(address => uint256) private _permitNonces;



    /**

     * @notice Nonces for permit

     * @param owner Token owner's address (Authorizer)

     * @return Next nonce

     */

    function nonces(address owner) external view returns (uint256) {

        return _permitNonces[owner];

    }



    /**

     * @notice Verify a signed approval permit and execute if valid

     * @param owner     Token owner's address (Authorizer)

     * @param spender   Spender's address

     * @param value     Amount of allowance

     * @param deadline  The time at which this expires (unix time)

     * @param v         v of the signature

     * @param r         r of the signature

     * @param s         s of the signature

     */

    function _permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal {

        require(deadline >= now, "FiatTokenV2: permit is expired");



        bytes memory data = abi.encode(

            PERMIT_TYPEHASH,

            owner,

            spender,

            value,

            _permitNonces[owner]++,

            deadline

        );

        require(

            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,

            "EIP2612: invalid signature"

        );



        _approve(owner, spender, value);

    }

}



// File: contracts/v2/FiatTokenV2.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



/**

 * @title FiatToken V2

 * @notice ERC20 Token backed by fiat reserves, version 2

 */

contract FiatTokenV2 is FiatTokenV1_1, EIP3009, EIP2612 {

    uint8 internal _initializedVersion;



    /**

     * @notice Initialize v2

     * @param newName   New token name

     */

    function initializeV2(string calldata newName) external {

        // solhint-disable-next-line reason-string

        require(initialized && _initializedVersion == 0);

        name = newName;

        DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(newName, "2");

        _initializedVersion = 1;

    }



    /**

     * @notice Increase the allowance by a given increment

     * @param spender   Spender's address

     * @param increment Amount of increase in allowance

     * @return True if successful

     */

    function increaseAllowance(address spender, uint256 increment)

        external

        whenNotPaused

        notBlacklisted(msg.sender)

        notBlacklisted(spender)

        returns (bool)

    {

        _increaseAllowance(msg.sender, spender, increment);

        return true;

    }



    /**

     * @notice Decrease the allowance by a given decrement

     * @param spender   Spender's address

     * @param decrement Amount of decrease in allowance

     * @return True if successful

     */

    function decreaseAllowance(address spender, uint256 decrement)

        external

        whenNotPaused

        notBlacklisted(msg.sender)

        notBlacklisted(spender)

        returns (bool)

    {

        _decreaseAllowance(msg.sender, spender, decrement);

        return true;

    }



    /**

     * @notice Execute a transfer with a signed authorization

     * @param from          Payer's address (Authorizer)

     * @param to            Payee's address

     * @param value         Amount to be transferred

     * @param validAfter    The time after which this is valid (unix time)

     * @param validBefore   The time before which this is valid (unix time)

     * @param nonce         Unique nonce

     * @param v             v of the signature

     * @param r             r of the signature

     * @param s             s of the signature

     */

    function transferWithAuthorization(

        address from,

        address to,

        uint256 value,

        uint256 validAfter,

        uint256 validBefore,

        bytes32 nonce,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external whenNotPaused notBlacklisted(from) notBlacklisted(to) {

        _transferWithAuthorization(

            from,

            to,

            value,

            validAfter,

            validBefore,

            nonce,

            v,

            r,

            s

        );

    }



    /**

     * @notice Receive a transfer with a signed authorization from the payer

     * @dev This has an additional check to ensure that the payee's address

     * matches the caller of this function to prevent front-running attacks.

     * @param from          Payer's address (Authorizer)

     * @param to            Payee's address

     * @param value         Amount to be transferred

     * @param validAfter    The time after which this is valid (unix time)

     * @param validBefore   The time before which this is valid (unix time)

     * @param nonce         Unique nonce

     * @param v             v of the signature

     * @param r             r of the signature

     * @param s             s of the signature

     */

    function receiveWithAuthorization(

        address from,

        address to,

        uint256 value,

        uint256 validAfter,

        uint256 validBefore,

        bytes32 nonce,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external whenNotPaused notBlacklisted(from) notBlacklisted(to) {

        _receiveWithAuthorization(

            from,

            to,

            value,

            validAfter,

            validBefore,

            nonce,

            v,

            r,

            s

        );

    }



    /**

     * @notice Attempt to cancel an authorization

     * @dev Works only if the authorization is not yet used.

     * @param authorizer    Authorizer's address

     * @param nonce         Nonce of the authorization

     * @param v             v of the signature

     * @param r             r of the signature

     * @param s             s of the signature

     */

    function cancelAuthorization(

        address authorizer,

        bytes32 nonce,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external whenNotPaused {

        _cancelAuthorization(authorizer, nonce, v, r, s);

    }



    /**

     * @notice Update allowance with a signed permit

     * @param owner       Token owner's address (Authorizer)

     * @param spender     Spender's address

     * @param value       Amount of allowance

     * @param deadline    Expiration time, seconds since the epoch

     * @param v           v of the signature

     * @param r           r of the signature

     * @param s           s of the signature

     */

    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) {

        _permit(owner, spender, value, deadline, v, r, s);

    }



    /**

     * @notice Internal function to increase the allowance by a given increment

     * @param owner     Token owner's address

     * @param spender   Spender's address

     * @param increment Amount of increase

     */

    function _increaseAllowance(

        address owner,

        address spender,

        uint256 increment

    ) internal override {

        _approve(owner, spender, allowed[owner][spender].add(increment));

    }



    /**

     * @notice Internal function to decrease the allowance by a given decrement

     * @param owner     Token owner's address

     * @param spender   Spender's address

     * @param decrement Amount of decrease

     */

    function _decreaseAllowance(

        address owner,

        address spender,

        uint256 decrement

    ) internal override {

        _approve(

            owner,

            spender,

            allowed[owner][spender].sub(

                decrement,

                "ERC20: decreased allowance below zero"

            )

        );

    }

}



// File: contracts/v2/FiatTokenV2_1.sol



/**

 * Copyright (c) 2018-2020 CENTRE SECZ

 *

 * Permission is hereby granted, free of charge, to any person obtaining a copy

 * of this software and associated documentation files (the "Software"), to deal

 * in the Software without restriction, including without limitation the rights

 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the Software is

 * furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice shall be included in

 * copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 */



pragma solidity 0.6.12;



// solhint-disable func-name-mixedcase



/**

 * @title FiatToken V2.1

 * @notice ERC20 Token backed by fiat reserves, version 2.1

 */

contract FiatTokenV2_1 is FiatTokenV2 {

    /**

     * @notice Initialize v2.1

     * @param lostAndFound  The address to which the locked funds are sent

     */

    function initializeV2_1(address lostAndFound) external {

        // solhint-disable-next-line reason-string

        require(_initializedVersion == 1);



        uint256 lockedAmount = balances[address(this)];

        if (lockedAmount > 0) {

            _transfer(address(this), lostAndFound, lockedAmount);

        }

        blacklisted[address(this)] = true;



        _initializedVersion = 2;

    }



    /**

     * @notice Version string for the EIP712 domain separator

     * @return Version string

     */

    function version() external view returns (string memory) {

        return "2";

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\IERC165.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\IERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\IERC721.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



import "IERC165.sol";



/**

 * @dev Required interface of an ERC721 compliant contract.

 */

interface IERC721 is IERC165 {

    /**

     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.

     */

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.

     */

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.

     */

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of tokens in ``owner``'s account.

     */

    function balanceOf(address owner) external view returns (uint256 balance);



    /**

     * @dev Returns the owner of the `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function ownerOf(uint256 tokenId) external view returns (address owner);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Transfers `tokenId` token from `from` to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Gives permission to `to` to transfer `tokenId` token to another account.

     * The approval is cleared when the token is transferred.

     *

     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.

     *

     * Requirements:

     *

     * - The caller must own the token or be an approved operator.

     * - `tokenId` must exist.

     *

     * Emits an {Approval} event.

     */

    function approve(address to, uint256 tokenId) external;



    /**

     * @dev Returns the account approved for `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function getApproved(uint256 tokenId) external view returns (address operator);



    /**

     * @dev Approve or remove `operator` as an operator for the caller.

     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.

     *

     * Requirements:

     *

     * - The `operator` cannot be the caller.

     *

     * Emits an {ApprovalForAll} event.

     */

    function setApprovalForAll(address operator, bool _approved) external;



    /**

     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.

     *

     * See {setApprovalForAll}

     */

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    /**

      * @dev Safely transfers `tokenId` token from `from` to `to`.

      *

      * Requirements:

      *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

      * - `tokenId` token must exist and be owned by `from`.

      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

      *

      * Emits a {Transfer} event.

      */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\IERC721Enumerable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



import "IERC721.sol";



/**

 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

interface IERC721Enumerable is IERC721 {



    /**

     * @dev Returns the total amount of tokens stored by the contract.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.

     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.

     */

    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);



    /**

     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.

     * Use along with {totalSupply} to enumerate all tokens.

     */

    function tokenByIndex(uint256 index) external view returns (uint256);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\IERC721Metadata.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.2;



import "IERC721.sol";



/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

interface IERC721Metadata is IERC721 {



    /**

     * @dev Returns the token collection name.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the token collection symbol.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.

     */

    function tokenURI(uint256 tokenId) external view returns (string memory);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\IERC721Receiver.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

interface IERC721Receiver {

    /**

     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}

     * by `operator` from `from`, this function is called.

     *

     * It must return its Solidity selector to confirm the token transfer.

     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.

     *

     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.

     */

    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\IEthCrossChainManager.sol
File type: .sol
pragma solidity >=0.5.0;



/**

 * @dev Interface of the EthCrossChainManager contract for business contract like LockProxy to request cross chain transaction

 */

interface IEthCrossChainManager {

    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\IEthCrossChainManagerProxy.sol
File type: .sol
pragma solidity >=0.5.0;



/**

 * @dev Interface of the EthCrossChainManagerProxy for business contract like LockProxy to obtain the reliable EthCrossChainManager contract hash.

 */

interface IEthCrossChainManagerProxy {

    function getEthCrossChainManager() external view returns (address);

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\IPolyNFTLockProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



interface IPolyNFTLockProxy {

    function managerProxyContract() external view returns (address);

    function proxyHashMap(uint64) external view returns (bytes memory);

    function assetHashMap(address, uint64) external view returns (bytes memory);

    function setManagerProxy(

        address eccmpAddr

    ) external;

    

    function bindProxyHash(

        uint64 toChainId, 

        bytes calldata targetProxyHash

    ) external returns (bool);



    function bindAssetHash(

        address fromAssetHash, 

        uint64 toChainId, 

        bytes calldata toAssetHash

    ) external returns (bool);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\LockProxy.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2021-09-01

*/



pragma solidity ^0.5.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



pragma solidity ^0.5.0;



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public  onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b != 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

pragma solidity ^0.5.0;





library Utils {



    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32

    *  @param _bs   Source bytes array

    *  @return      bytes32

    */

    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {

        require(_bs.length == 32, "bytes length is not 32.");

        assembly {

            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length

            value := mload(add(_bs, 0x20))

        }

    }



    /* @notice      Convert bytes to uint256

    *  @param _b    Source bytes should have length of 32

    *  @return      uint256

    */

    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {

        require(_bs.length == 32, "bytes length is not 32.");

        assembly {

            // load 32 bytes from memory starting from position _bs + 32

            value := mload(add(_bs, 0x20))

        }

        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds the range");

    }



    /* @notice      Convert uint256 to bytes

    *  @param _b    uint256 that needs to be converted

    *  @return      bytes

    */

    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {

        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds the range");

        assembly {

            // Get a location of some free memory and store it in result as

            // Solidity does for memory variables.

            bs := mload(0x40)

            // Put 0x20 at the first word, the length of bytes for uint256 value

            mstore(bs, 0x20)

            //In the next word, put value in bytes format to the next 32 bytes

            mstore(add(bs, 0x20), _value)

            // Update the free-memory pointer by padding our last write location to 32 bytes

            mstore(0x40, add(bs, 0x40))

        }

    }



    /* @notice      Convert bytes to address

    *  @param _bs   Source bytes: bytes length must be 20

    *  @return      Converted address from source bytes

    */

    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)

    {

        require(_bs.length == 20, "bytes length does not match address");

        assembly {

            // for _bs, first word store _bs.length, second word store _bs.value

            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).

            addr := mload(add(_bs, 0x14))

        }



    }

    

    /* @notice      Convert address to bytes

    *  @param _addr Address need to be converted

    *  @return      Converted bytes from address

    */

    function addressToBytes(address _addr) internal pure returns (bytes memory bs){

        assembly {

            // Get a location of some free memory and store it in result as

            // Solidity does for memory variables.

            bs := mload(0x40)

            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value

            mstore(bs, 0x14)

            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned

            mstore(add(bs, 0x20), shl(96, _addr))

            // Update the free-memory pointer by padding our last write location to 32 bytes

            mstore(0x40, add(bs, 0x40))

       }

    }



    /* @notice          Do hash leaf as the multi-chain does

    *  @param _data     Data in bytes format

    *  @return          Hashed value in bytes32 format

    */

    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {

        result = sha256(abi.encodePacked(byte(0x0), _data));

    }



    /* @notice          Do hash children as the multi-chain does

    *  @param _l        Left node

    *  @param _r        Right node

    *  @return          Hashed value in bytes32 format

    */

    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {

        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));

    }



    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately

                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368

    *  @param _preBytes     The bytes stored in storage

    *  @param _postBytes    The bytes stored in memory

    *  @return              Bool type indicating if they are equal

    */

    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {

        bool success = true;



        assembly {

            // we know _preBytes_offset is 0

            let fslot := sload(_preBytes_slot)

            // Arrays of 31 bytes or less have an even value in their slot,

            // while longer arrays have an odd value. The actual length is

            // the slot divided by two for odd values, and the lowest order

            // byte divided by two for even values.

            // If the slot is even, bitwise and the slot with 255 and divide by

            // two to get the length. If the slot is odd, bitwise and the slot

            // with -1 and divide by two.

            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)

            let mlength := mload(_postBytes)



            // if lengths don't match the arrays are not equal

            switch eq(slength, mlength)

            case 1 {

                // fslot can contain both the length and contents of the array

                // if slength < 32 bytes so let's prepare for that

                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage

                // slength != 0

                if iszero(iszero(slength)) {

                    switch lt(slength, 32)

                    case 1 {

                        // blank the last byte which is the length

                        fslot := mul(div(fslot, 0x100), 0x100)



                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {

                            // unsuccess:

                            success := 0

                        }

                    }

                    default {

                        // cb is a circuit breaker in the for loop since there's

                        //  no said feature for inline assembly loops

                        // cb = 1 - don't breaker

                        // cb = 0 - break

                        let cb := 1



                        // get the keccak hash to get the contents of the array

                        mstore(0x0, _preBytes_slot)

                        let sc := keccak256(0x0, 0x20)



                        let mc := add(_postBytes, 0x20)

                        let end := add(mc, mlength)



                        // the next line is the loop condition:

                        // while(uint(mc < end) + cb == 2)

                        for {} eq(add(lt(mc, end), cb), 2) {

                            sc := add(sc, 1)

                            mc := add(mc, 0x20)

                        } {

                            if iszero(eq(sload(sc), mload(mc))) {

                                // unsuccess:

                                success := 0

                                cb := 0

                            }

                        }

                    }

                }

            }

            default {

                // unsuccess:

                success := 0

            }

        }



        return success;

    }



    /* @notice              Slice the _bytes from _start index till the result has length of _length

                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246

    *  @param _bytes        The original bytes needs to be sliced

    *  @param _start        The index of _bytes for the start of sliced bytes

    *  @param _length       The index of _bytes for the end of sliced bytes

    *  @return              The sliced bytes

    */

    function slice(

        bytes memory _bytes,

        uint _start,

        uint _length

    )

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));



        bytes memory tempBytes;



        assembly {

            switch iszero(_length)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                // lengthmod <= _length % 32

                let lengthmod := and(_length, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, _length)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, _length)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return tempBytes;

    }

    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m

    *  @param _keepers      The array consists of serveral address

    *  @param _signers      Some specific addresses to be looked into

    *  @param _m            The number requirement paramter

    *  @return              True means containment, false meansdo do not contain.

    */

    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){

        uint m = 0;

        for(uint i = 0; i < _signers.length; i++){

            for (uint j = 0; j < _keepers.length; j++) {

                if (_signers[i] == _keepers[j]) {

                    m++;

                    delete _keepers[j];

                }

            }

        }

        return m >= _m;

    }



    /* @notice              TODO

    *  @param key

    *  @return

    */

    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {

         require(key.length >= 67, "key lenggh is too short");

         newkey = slice(key, 0, 35);

         if (uint8(key[66]) % 2 == 0){

             newkey[2] = byte(0x02);

         } else {

             newkey[2] = byte(0x03);

         }

         return newkey;

    }

    

    /**

     * @dev Returns true if `account` is a contract.

     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18

     *

     * This test is non-exhaustive, and there may be false-negatives: during the

     * execution of a contract's constructor, its address will be reported as

     * not containing a contract.

     *

     * IMPORTANT: It is unsafe to assume that an address for which this

     * function returns false is an externally-owned account (EOA) and not a

     * contract.

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies in extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }

}

pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves.



        // A Solidity high level call has three parts:

        //  1. The target address is checked to verify it contains contract code

        //  2. The call itself is made, and success asserted

        //  3. The return value is decoded, which in turn checks the size of the returned data.

        // solhint-disable-next-line max-line-length

        require(Utils.isContract(address(token)), "SafeERC20: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

pragma solidity ^0.5.0;



/**

 * @dev Interface of the EthCrossChainManager contract for business contract like LockProxy to request cross chain transaction

 */

interface IEthCrossChainManager {

    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);

}

pragma solidity ^0.5.0;



/**

 * @dev Interface of the EthCrossChainManagerProxy for business contract like LockProxy to obtain the reliable EthCrossChainManager contract hash.

 */

interface IEthCrossChainManagerProxy {

    function getEthCrossChainManager() external view returns (address);

}

pragma solidity ^0.5.0;



/**

 * @dev Wrappers over decoding and deserialization operation from bytes into bassic types in Solidity for PolyNetwork cross chain utility.

 *

 * Decode into basic types in Solidity from bytes easily. It's designed to be used 

 * for PolyNetwork cross chain application, and the decoding rules on Ethereum chain 

 * and the encoding rule on other chains should be consistent, and . Here we

 * follow the underlying deserialization rule with implementation found here: 

 * https://github.com/polynetwork/poly/blob/master/common/zero_copy_source.go

 *

 * Using this library instead of the unchecked serialization method can help reduce

 * the risk of serious bugs and handfule, so it's recommended to use it.

 *

 * Please note that risk can be minimized, yet not eliminated.

 */

library ZeroCopySource {

    /* @notice              Read next byte as boolean type starting at offset from buff

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the boolean value

    *  @return              The the read boolean value and new offset

    */

    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {

        require(offset + 1 <= buff.length && offset < offset + 1, "Offset exceeds limit");

        // byte === bytes1

        byte v;

        assembly{

            v := mload(add(add(buff, 0x20), offset))

        }

        bool value;

        if (v == 0x01) {

		    value = true;

    	} else if (v == 0x00) {

            value = false;

        } else {

            revert("NextBool value error");

        }

        return (value, offset + 1);

    }



    /* @notice              Read next byte starting at offset from buff

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the byte value

    *  @return              The read byte value and new offset

    */

    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {

        require(offset + 1 <= buff.length && offset < offset + 1, "NextByte, Offset exceeds maximum");

        byte v;

        assembly{

            v := mload(add(add(buff, 0x20), offset))

        }

        return (v, offset + 1);

    }



    /* @notice              Read next byte as uint8 starting at offset from buff

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the byte value

    *  @return              The read uint8 value and new offset

    */

    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {

        require(offset + 1 <= buff.length && offset < offset + 1, "NextUint8, Offset exceeds maximum");

        uint8 v;

        assembly{

            let tmpbytes := mload(0x40)

            let bvalue := mload(add(add(buff, 0x20), offset))

            mstore8(tmpbytes, byte(0, bvalue))

            mstore(0x40, add(tmpbytes, 0x01))

            v := mload(sub(tmpbytes, 0x1f))

        }

        return (v, offset + 1);

    }



    /* @notice              Read next two bytes as uint16 type starting from offset

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint16 value

    *  @return              The read uint16 value and updated offset

    */

    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {

        require(offset + 2 <= buff.length && offset < offset + 2, "NextUint16, offset exceeds maximum");

        

        uint16 v;

        assembly {

            let tmpbytes := mload(0x40)

            let bvalue := mload(add(add(buff, 0x20), offset))

            mstore8(tmpbytes, byte(0x01, bvalue))

            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))

            mstore(0x40, add(tmpbytes, 0x02))

            v := mload(sub(tmpbytes, 0x1e))

        }

        return (v, offset + 2);

    }





    /* @notice              Read next four bytes as uint32 type starting from offset

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint32 value

    *  @return              The read uint32 value and updated offset

    */

    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {

        require(offset + 4 <= buff.length && offset < offset + 4, "NextUint32, offset exceeds maximum");

        uint32 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x04

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(sub(tmpbytes, sub(0x20, byteLen)))

        }

        return (v, offset + 4);

    }



    /* @notice              Read next eight bytes as uint64 type starting from offset

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint64 value

    *  @return              The read uint64 value and updated offset

    */

    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {

        require(offset + 8 <= buff.length && offset < offset + 8, "NextUint64, offset exceeds maximum");

        uint64 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x08

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(sub(tmpbytes, sub(0x20, byteLen)))

        }

        return (v, offset + 8);

    }



    /* @notice              Read next 32 bytes as uint256 type starting from offset,

                            there are limits considering the numerical limits in multi-chain

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint256 value

    *  @return              The read uint256 value and updated offset

    */

    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {

        require(offset + 32 <= buff.length && offset < offset + 32, "NextUint255, offset exceeds maximum");

        uint256 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x20

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(tmpbytes)

        }

        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds the range");

        return (v, offset + 32);

    }

    /* @notice              Read next variable bytes starting from offset,

                            the decoding rule coming from multi-chain

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the bytes value

    *  @return              The read variable bytes array value and updated offset

    */

    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {

        uint len;

        (len, offset) = NextVarUint(buff, offset);

        require(offset + len <= buff.length && offset < offset + len, "NextVarBytes, offset exceeds maximum");

        bytes memory tempBytes;

        assembly{

            switch iszero(len)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                let lengthmod := and(len, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, len)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, len)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return (tempBytes, offset + len);

    }

    /* @notice              Read next 32 bytes starting from offset,

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the bytes value

    *  @return              The read bytes32 value and updated offset

    */

    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {

        require(offset + 32 <= buff.length && offset < offset + 32, "NextHash, offset exceeds maximum");

        bytes32 v;

        assembly {

            v := mload(add(buff, add(offset, 0x20)))

        }

        return (v, offset + 32);

    }



    /* @notice              Read next 20 bytes starting from offset,

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the bytes value

    *  @return              The read bytes20 value and updated offset

    */

    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {

        require(offset + 20 <= buff.length && offset < offset + 20, "NextBytes20, offset exceeds maximum");

        bytes20 v;

        assembly {

            v := mload(add(buff, add(offset, 0x20)))

        }

        return (v, offset + 20);

    }

    

    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {

        byte v;

        (v, offset) = NextByte(buff, offset);



        uint value;

        if (v == 0xFD) {

            // return NextUint16(buff, offset);

            (value, offset) = NextUint16(buff, offset);

            require(value >= 0xFD && value <= 0xFFFF, "NextUint16, value outside range");

            return (value, offset);

        } else if (v == 0xFE) {

            // return NextUint32(buff, offset);

            (value, offset) = NextUint32(buff, offset);

            require(value > 0xFFFF && value <= 0xFFFFFFFF, "NextVarUint, value outside range");

            return (value, offset);

        } else if (v == 0xFF) {

            // return NextUint64(buff, offset);

            (value, offset) = NextUint64(buff, offset);

            require(value > 0xFFFFFFFF, "NextVarUint, value outside range");

            return (value, offset);

        } else{

            // return (uint8(v), offset);

            value = uint8(v);

            require(value < 0xFD, "NextVarUint, value outside range");

            return (value, offset);

        }

    }

}

pragma solidity ^0.5.0;



/**

 * @dev Wrappers over encoding and serialization operation into bytes from bassic types in Solidity for PolyNetwork cross chain utility.

 *

 * Encode basic types in Solidity into bytes easily. It's designed to be used 

 * for PolyNetwork cross chain application, and the encoding rules on Ethereum chain 

 * and the decoding rules on other chains should be consistent. Here we  

 * follow the underlying serialization rule with implementation found here: 

 * https://github.com/polynetwork/poly/blob/master/common/zero_copy_sink.go

 *

 * Using this library instead of the unchecked serialization method can help reduce

 * the risk of serious bugs and handfule, so it's recommended to use it.

 *

 * Please note that risk can be minimized, yet not eliminated.

 */

library ZeroCopySink {

    /* @notice          Convert boolean value into bytes

    *  @param b         The boolean value

    *  @return          Converted bytes array

    */

    function WriteBool(bool b) internal pure returns (bytes memory) {

        bytes memory buff;

        assembly{

            buff := mload(0x40)

            mstore(buff, 1)

            switch iszero(b)

            case 1 {

                mstore(add(buff, 0x20), shl(248, 0x00))

                // mstore8(add(buff, 0x20), 0x00)

            }

            default {

                mstore(add(buff, 0x20), shl(248, 0x01))

                // mstore8(add(buff, 0x20), 0x01)

            }

            mstore(0x40, add(buff, 0x21))

        }

        return buff;

    }



    /* @notice          Convert byte value into bytes

    *  @param b         The byte value

    *  @return          Converted bytes array

    */

    function WriteByte(byte b) internal pure returns (bytes memory) {

        return WriteUint8(uint8(b));

    }



    /* @notice          Convert uint8 value into bytes

    *  @param v         The uint8 value

    *  @return          Converted bytes array

    */

    function WriteUint8(uint8 v) internal pure returns (bytes memory) {

        bytes memory buff;

        assembly{

            buff := mload(0x40)

            mstore(buff, 1)

            mstore(add(buff, 0x20), shl(248, v))

            // mstore(add(buff, 0x20), byte(0x1f, v))

            mstore(0x40, add(buff, 0x21))

        }

        return buff;

    }



    /* @notice          Convert uint16 value into bytes

    *  @param v         The uint16 value

    *  @return          Converted bytes array

    */

    function WriteUint16(uint16 v) internal pure returns (bytes memory) {

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x02

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x22))

        }

        return buff;

    }

    

    /* @notice          Convert uint32 value into bytes

    *  @param v         The uint32 value

    *  @return          Converted bytes array

    */

    function WriteUint32(uint32 v) internal pure returns(bytes memory) {

        bytes memory buff;

        assembly{

            buff := mload(0x40)

            let byteLen := 0x04

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x24))

        }

        return buff;

    }



    /* @notice          Convert uint64 value into bytes

    *  @param v         The uint64 value

    *  @return          Converted bytes array

    */

    function WriteUint64(uint64 v) internal pure returns(bytes memory) {

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x08

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x28))

        }

        return buff;

    }



    /* @notice          Convert limited uint256 value into bytes

    *  @param v         The uint256 value

    *  @return          Converted bytes array

    */

    function WriteUint255(uint256 v) internal pure returns (bytes memory) {

        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds uint255 range");

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x20

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x40))

        }

        return buff;

    }



    /* @notice          Encode bytes format data into bytes

    *  @param data      The bytes array data

    *  @return          Encoded bytes array

    */

    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {

        uint64 l = uint64(data.length);

        return abi.encodePacked(WriteVarUint(l), data);

    }



    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {

        if (v < 0xFD){

    		return WriteUint8(uint8(v));

    	} else if (v <= 0xFFFF) {

    		return abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));

    	} else if (v <= 0xFFFFFFFF) {

            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));

    	} else {

    		return abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));

    	}

    }

}

contract LockProxy is Ownable {

    using SafeMath for uint;

    using SafeERC20 for IERC20;



    struct TxArgs {

        bytes toAssetHash;

        bytes toAddress;

        uint256 amount;

    }

    address public managerProxyContract;

    mapping(uint64 => bytes) public proxyHashMap;

    mapping(address => mapping(uint64 => bytes)) public assetHashMap;

    mapping(address => bool) safeTransfer;



    event SetManagerProxyEvent(address manager);

    event BindProxyEvent(uint64 toChainId, bytes targetProxyHash);

    event BindAssetEvent(address fromAssetHash, uint64 toChainId, bytes targetProxyHash, uint initialAmount);

    event UnlockEvent(address toAssetHash, address toAddress, uint256 amount);

    event LockEvent(address fromAssetHash, address fromAddress, uint64 toChainId, bytes toAssetHash, bytes toAddress, uint256 amount);

    

    modifier onlyManagerContract() {

        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);

        require(_msgSender() == ieccmp.getEthCrossChainManager(), "msgSender is not EthCrossChainManagerContract");

        _;

    }

    

    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {

        managerProxyContract = ethCCMProxyAddr;

        emit SetManagerProxyEvent(managerProxyContract);

    }

    

    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) {

        proxyHashMap[toChainId] = targetProxyHash;

        emit BindProxyEvent(toChainId, targetProxyHash);

        return true;

    }

    

    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) {

        assetHashMap[fromAssetHash][toChainId] = toAssetHash;

        emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash, getBalanceFor(fromAssetHash));

        return true;

    }

    

    /* @notice                  This function is meant to be invoked by the user,

    *                           a certin amount teokens will be locked in the proxy contract the invoker/msg.sender immediately.

    *                           Then the same amount of tokens will be unloked from target chain proxy contract at the target chain with chainId later.

    *  @param fromAssetHash     The asset address in current chain, uniformly named as `fromAssetHash`

    *  @param toChainId         The target chain id

    *                           

    *  @param toAddress         The address in bytes format to receive same amount of tokens in target chain 

    *  @param amount            The amount of tokens to be crossed from ethereum to the chain with chainId

    */

    function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) {

        require(amount != 0, "amount cannot be zero!");

        

        

        require(_transferToContract(fromAssetHash, amount), "transfer asset from fromAddress to lock_proxy contract  failed!");

        

        bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId];

        require(toAssetHash.length != 0, "empty illegal toAssetHash");



        TxArgs memory txArgs = TxArgs({

            toAssetHash: toAssetHash,

            toAddress: toAddress,

            amount: amount

        });

        bytes memory txData = _serializeTxArgs(txArgs);

        

        IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);

        address eccmAddr = eccmp.getEthCrossChainManager();

        IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);

        

        bytes memory toProxyHash = proxyHashMap[toChainId];

        require(toProxyHash.length != 0, "empty illegal toProxyHash");

        require(eccm.crossChain(toChainId, toProxyHash, "unlock", txData), "EthCrossChainManager crossChain executed error!");



        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount);

        

        return true;



    }

    

    // /* @notice                  This function is meant to be invoked by the ETH crosschain management contract,

    // *                           then mint a certin amount of tokens to the designated address since a certain amount 

    // *                           was burnt from the source chain invoker.

    // *  @param argsBs            The argument bytes recevied by the ethereum lock proxy contract, need to be deserialized.

    // *                           based on the way of serialization in the source chain proxy contract.

    // *  @param fromContractAddr  The source chain contract address

    // *  @param fromChainId       The source chain id

    // */

    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {

        TxArgs memory args = _deserializeTxArgs(argsBs);



        require(fromContractAddr.length != 0, "from proxy contract address cannot be empty");

        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), "From Proxy contract address error!");

        

        require(args.toAssetHash.length != 0, "toAssetHash cannot be empty");

        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);



        require(args.toAddress.length != 0, "toAddress cannot be empty");

        address toAddress = Utils.bytesToAddress(args.toAddress);

        

        

        require(_transferFromContract(toAssetHash, toAddress, args.amount), "transfer asset from lock_proxy contract to toAddress failed!");

        

        emit UnlockEvent(toAssetHash, toAddress, args.amount);

        return true;

    }

    

    function getBalanceFor(address fromAssetHash) public view returns (uint256) {

        if (fromAssetHash == address(0)) {

            // return address(this).balance; // this expression would result in error: Failed to decode output: Error: insufficient data for uint256 type

            address selfAddr = address(this);

            return selfAddr.balance;

        } else {

            IERC20 erc20Token = IERC20(fromAssetHash);

            return erc20Token.balanceOf(address(this));

        }

    }

    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) {

        if (fromAssetHash == address(0)) {

            // fromAssetHash === address(0) denotes user choose to lock ether

            // passively check if the received msg.value equals amount

            require(msg.value != 0, "transferred ether cannot be zero!");

            require(msg.value == amount, "transferred ether is not equal to amount!");

        } else {

            // make sure lockproxy contract will decline any received ether

            require(msg.value == 0, "there should be no ether transfer!");

            // actively transfer amount of asset from msg.sender to lock_proxy contract

            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), "transfer erc20 asset to lock_proxy contract failed!");

        }

        return true;

    }

    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {

        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {

            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress

            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether

            address(uint160(toAddress)).transfer(amount);

        } else {

            // actively transfer amount of asset from msg.sender to lock_proxy contract 

            require(_transferERC20FromContract(toAssetHash, toAddress, amount), "transfer erc20 asset to lock_proxy contract failed!");

        }

        return true;

    }

    

    

    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) {

         IERC20 erc20Token = IERC20(fromAssetHash);

        //  require(erc20Token.transferFrom(fromAddress, toAddress, amount), "trasnfer ERC20 Token failed!");

         erc20Token.safeTransferFrom(fromAddress, toAddress, amount);

         return true;

    }

    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {

         IERC20 erc20Token = IERC20(toAssetHash);

        //  require(erc20Token.transfer(toAddress, amount), "trasnfer ERC20 Token failed!");

         erc20Token.safeTransfer(toAddress, amount);

         return true;

    }

    

    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {

        bytes memory buff;

        buff = abi.encodePacked(

            ZeroCopySink.WriteVarBytes(args.toAssetHash),

            ZeroCopySink.WriteVarBytes(args.toAddress),

            ZeroCopySink.WriteUint255(args.amount)

            );

        return buff;

    }



    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {

        TxArgs memory args;

        uint256 off = 0;

        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);

        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);

        (args.amount, off) = ZeroCopySource.NextUint255(valueBs, off);

        return args;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\Ownable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



import "Context.sol";

/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Returns true if the caller is the current owner.

     */

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public  onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\Pausable.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



import "Context.sol";



/**

 * @dev Contract module which allows children to implement an emergency stop

 * mechanism that can be triggered by an authorized account.

 *

 * This module is used through inheritance. It will make available the

 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to

 * the functions of your contract. Note that they will not be pausable by

 * simply including this module, only once the modifiers are put in place.

 */

contract Pausable is Context {

    /**

     * @dev Emitted when the pause is triggered by a pauser (`account`).

     */

    event Paused(address account);



    /**

     * @dev Emitted when the pause is lifted by a pauser (`account`).

     */

    event Unpaused(address account);



    bool private _paused;



    /**

     * @dev Initializes the contract in unpaused state.

     */

    constructor () internal {

        _paused = false;

    }



    /**

     * @dev Returns true if the contract is paused, and false otherwise.

     */

    function paused() public view returns (bool) {

        return _paused;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is not paused.

     */

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    /**

     * @dev Modifier to make a function callable only when the contract is paused.

     */

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    /**

     * @dev Called to pause, triggers stopped state.

     */

    function _pause() internal whenNotPaused {

        _paused = true;

        emit Paused(_msgSender());

    }



    /**

     * @dev Called to unpause, returns to normal state.

     */

    function _unpause() internal whenPaused {

        _paused = false;

        emit Unpaused(_msgSender());

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\PolyNFTLockProxy.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



import "Ownable.sol";

import "ZeroCopySink.sol";

import "ZeroCopySource.sol";

import "Utils.sol";

import "Address.sol";

import "IERC721Metadata.sol";

import "IERC721Receiver.sol";

import "SafeMath.sol";

import "IEthCrossChainManager.sol";

import "IEthCrossChainManagerProxy.sol";



contract PolyNFTLockProxy is IERC721Receiver, Ownable {

    using SafeMath for uint;

    using Address for address;



    struct TxArgs {

        bytes toAssetHash;

        bytes toAddress;

        uint256 tokenId;

        bytes tokenURI;

    }



    address public managerProxyContract;

    mapping(uint64 => bytes) public proxyHashMap;

    mapping(address => mapping(uint64 => bytes)) public assetHashMap;

    mapping(address => bool) safeTransfer;



    event SetManagerProxyEvent(address manager);

    event BindProxyEvent(uint64 toChainId, bytes targetProxyHash);

    event BindAssetEvent(address fromAssetHash, uint64 toChainId, bytes targetProxyHash);

    event UnlockEvent(address toAssetHash, address toAddress, uint256 tokenId);

    event LockEvent(address fromAssetHash, address fromAddress, bytes toAssetHash, bytes toAddress, uint64 toChainId, uint256 tokenId);

    

    modifier onlyManagerContract() {

        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);

        require(_msgSender() == ieccmp.getEthCrossChainManager(), "msgSender is not EthCrossChainManagerContract");

        _;

    }

    

    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {

        managerProxyContract = ethCCMProxyAddr;

        emit SetManagerProxyEvent(managerProxyContract);

    }

    

    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) {

        proxyHashMap[toChainId] = targetProxyHash;

        emit BindProxyEvent(toChainId, targetProxyHash);

        return true;

    }

    

    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) {

        assetHashMap[fromAssetHash][toChainId] = toAssetHash;

        emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash);

        return true;

    }

    

    // /* @notice                  This function is meant to be invoked by the ETH crosschain management contract,

    // *                           then mint a certin amount of tokens to the designated address since a certain amount 

    // *                           was burnt from the source chain invoker.

    // *  @param argsBs            The argument bytes recevied by the ethereum lock proxy contract, need to be deserialized.

    // *                           based on the way of serialization in the source chain proxy contract.

    // *  @param fromContractAddr  The source chain contract address

    // *  @param fromChainId       The source chain id

    // */

    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) public onlyManagerContract returns (bool) {

        TxArgs memory args = _deserializeTxArgs(argsBs);



        require(fromContractAddr.length != 0, "from proxy contract address cannot be empty");

        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), "From Proxy contract address error!");

        

        require(args.toAssetHash.length != 0, "toAssetHash cannot be empty");

        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);



        require(args.toAddress.length != 0, "toAddress cannot be empty");

        address toAddress = Utils.bytesToAddress(args.toAddress);

        

        bool success;

        bytes memory res;

        address owner;

        bytes memory raw = abi.encodeWithSignature("ownerOf(uint256)", args.tokenId);

        (success, res) = toAssetHash.call(raw);

        if (success) {

            owner = abi.decode(res, (address));

            require(owner == address(this) || owner == address(0), "your token ID is not hold by lockproxy.");

            if (owner == address(this)) {

                raw = abi.encodeWithSignature("safeTransferFrom(address,address,uint256)", address(this), toAddress, args.tokenId);

                (success, ) = toAssetHash.call(raw);

                require(success, "failed to call safeTransferFrom");

            }

        }

        if (!success || owner == address(0)) {

            raw = abi.encodeWithSignature("mintWithURI(address,uint256,string)", toAddress, args.tokenId, string(args.tokenURI));

            (success, ) = toAssetHash.call(raw);

            require(success, "failed to call mintWithURI to mint a new mapping NFT");

        }

        

        emit UnlockEvent(toAssetHash, toAddress, args.tokenId);

        return true;

    }



    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) public override returns (bytes4) {

        address fromAssetHash = _msgSender();

        require(data.length > 0, "length of toAddress can't be zero. ");

        require(fromAssetHash.isContract(), "caller must be a contract. ");

            

        bytes memory toAddress;

        uint64 toChainId;

        bytes memory toAssetHash;

        {

            (toAddress, toChainId) = _deserializeCallData(data);

            toAssetHash = assetHashMap[fromAssetHash][toChainId];

            require(toAssetHash.length != 0, "empty illegal toAssetHash");

    

            IERC721Metadata nft = IERC721Metadata(fromAssetHash);

            require(nft.ownerOf(tokenId) == address(this), "wrong owner for this token ID");

    

            string memory uri = nft.tokenURI(tokenId);

            TxArgs memory txArgs = TxArgs({

                toAssetHash: toAssetHash,

                toAddress: toAddress,

                tokenId: tokenId,

                tokenURI: bytes(uri)

            });

            bytes memory txData = _serializeTxArgs(txArgs);

            IEthCrossChainManager eccm = IEthCrossChainManager(IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager());

            

            bytes memory toProxyHash = proxyHashMap[toChainId];

            require(toProxyHash.length != 0, "empty illegal toProxyHash");

            require(eccm.crossChain(toChainId, toProxyHash, "unlock", txData), "EthCrossChainManager crossChain executed error!");

        }

        {

            emit LockEvent(fromAssetHash, from, toAssetHash, toAddress, toChainId, tokenId);

        }



        return this.onERC721Received.selector;

    }

    

    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {

        bytes memory buff;

        buff = abi.encodePacked(

            ZeroCopySink.WriteVarBytes(args.toAssetHash),

            ZeroCopySink.WriteVarBytes(args.toAddress),

            ZeroCopySink.WriteUint256(args.tokenId),

            ZeroCopySink.WriteVarBytes(args.tokenURI)

            );

        return buff;

    }



    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {

        TxArgs memory args;

        uint256 off = 0;

        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);

        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);

        (args.tokenId, off) = ZeroCopySource.NextUint256(valueBs, off);

        (args.tokenURI, off) = ZeroCopySource.NextVarBytes(valueBs, off);

        return args;

    }

    

    function _deserializeCallData(bytes memory valueBs) internal pure returns (bytes memory, uint64) {

        bytes memory toAddress;

        uint64 chainId;

        uint256 off = 0;

        (toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);

        (chainId, off) = ZeroCopySource.NextUint64(valueBs, off);

        return (toAddress, chainId);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\PolyNFTQuery.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity >=0.5.0;



import "SafeMath.sol";

import "ZeroCopySink.sol";

import "ZeroCopySource.sol";

import "IERC721.sol";

import "IERC721Enumerable.sol";

import "IERC721Metadata.sol";

import "IPolyNFTLockProxy.sol";



contract PolyNFTQuery {

    using SafeMath for uint;



    function getAndCheckTokenUrl(address asset, address user, uint tokenId) public view returns (bool, string memory) {

        string memory url = "";

        address owner = IERC721(asset).ownerOf(tokenId);

        if (user != owner || user == address(0)) {

            return (false, url);

        }



        url = IERC721Metadata(asset).tokenURI(tokenId);

        return (true, url);

    }



    // getTokensByIndex index start from 0

    function getOwnerTokensByIndex(address asset, address owner, uint start, uint length) public view returns (bool, bytes memory) {

        bytes memory buff;

        if (length == 0 || length > 10) {

            return (false, buff);

        }



        uint total = IERC721(asset).balanceOf(owner);

        if (total == 0 || start >= total) {

            return (false, buff);

        }        

        uint end = _calcEndIndex(start, length, total);



        IERC721Metadata meta = IERC721Metadata(asset);

        IERC721Enumerable enu = IERC721Enumerable(asset);

        for (uint index = start; index <= end; index++) {

            uint tokenId = enu.tokenOfOwnerByIndex(owner, index);

            string memory url = meta.tokenURI(tokenId);

            buff = _serializeProfile(buff, tokenId, url);

        }

        return (true, buff);

    }



    // getTokensByIndex index start from 0

    function getTokensByIds(address asset, bytes calldata args) public view returns (bool, bytes memory) {

        uint off = 0;

        uint tokenId = 0;

        uint length = 0;

        bytes memory buff;



        (length, off) = ZeroCopySource.NextUint256(args, off);

        if (length == 0 || length > 10) {

            return (false, buff);

        }



        IERC721Metadata meta = IERC721Metadata(asset);

        for (uint index = 0; index < length; index++) {

            (tokenId, off) = ZeroCopySource.NextUint256(args, off);

            string memory url = meta.tokenURI(tokenId);

            buff = _serializeProfile(buff, tokenId, url);

        }

        return (true, buff);

    }



    function getFilterTokensByIndex(address asset, address ignore, uint start, uint length) public view returns (bool, bytes memory) {

        bytes memory buff;

        if (length == 0 || length > 10) {

            return (false, buff);

        }



        IERC721Metadata meta = IERC721Metadata(asset);

        IERC721Enumerable enu = IERC721Enumerable(asset);

        IERC721 erc = IERC721(asset);

        

        uint256 total = enu.totalSupply();

        if (total == 0 || start >= total) {

            return (false, buff);

        }



        uint end = _calcEndIndex(start, length, total);

        while(start <= end && end < total) {

            uint tokenId = enu.tokenByIndex(start);

            start = start + 1;

            address owner = erc.ownerOf(tokenId);

            if (owner == ignore) {

                end = end + 1;

                continue;

            }

            string memory url = meta.tokenURI(tokenId);

            buff = _serializeProfile(buff, tokenId, url);

        }

        return (true, buff);

    }



    function _serializeProfile(bytes memory buff, uint tokenId, string memory url) internal pure returns (bytes memory) {

        buff = abi.encodePacked(

            buff,

            ZeroCopySink.WriteUint256(tokenId),

            ZeroCopySink.WriteVarBytes(bytes(url))

        );

        return buff;

    }



    function _calcEndIndex(uint start, uint length, uint total) internal pure returns (uint) {

        uint end = start + length - 1;

        if (end >= total) {

            end = total - 1;

        }

        return end;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\PolyNFTWrapper.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity >=0.5.0;



import "Ownable.sol";

import "SafeERC20.sol";

import "SafeMath.sol";

import "Pausable.sol";

import "ZeroCopySink.sol";

import "ZeroCopySource.sol";

import "IERC721.sol";

import "IERC721Enumerable.sol";

import "IERC721Metadata.sol";

import "ReentrancyGuard.sol";

import "IPolyNFTLockProxy.sol";



contract PolyNFTWrapper is Ownable, Pausable, ReentrancyGuard {

    using SafeMath for uint;

    using SafeERC20 for IERC20;



    uint public chainId;

    address public feeCollector;

    address public lockProxy;

    

    struct CallArgs {

        bytes toAddress;

        uint64 toChainId;

    }



    event PolyWrapperLock(address indexed fromAsset, address indexed sender, uint64 toChainId, address toAddress, uint256 tokenId, address feeToken, uint256 fee, uint id);

    event PolyWrapperSpeedUp(address indexed feeToken, bytes indexed txHash, address indexed sender, uint256 efee);



    constructor(address _owner, uint _chainId) public {

        require(_chainId != 0, "!legal");

        transferOwnership(_owner);

        chainId = _chainId;

    }

    

    function setFeeCollector(address collector) external onlyOwner {

        require(collector != address(0), "emtpy address");

        feeCollector = collector;

    }



    function setLockProxy(address _lockProxy) external onlyOwner {

        require(_lockProxy != address(0));

        lockProxy = _lockProxy;

        require(IPolyNFTLockProxy(lockProxy).managerProxyContract() != address(0), "not lock proxy");

    }



    function pause() external onlyOwner {

        _pause();

    }



    function unpause() external onlyOwner {

        _unpause();

    }



    function extractFee(address token) external {

        require(msg.sender == feeCollector, "!feeCollector");

        if (token == address(0)) {

            payable(msg.sender).transfer(address(this).balance);

        } else {

            IERC20(token).safeTransfer(feeCollector, IERC20(token).balanceOf(address(this)));

        }

    }



    function lock(address fromAsset, uint64 toChainId, address toAddress, uint256 tokenId, address feeToken, uint256 fee, uint id) external payable nonReentrant whenNotPaused {    

        require(toChainId != chainId && toChainId != 0, "!toChainId");



        _pull(feeToken, fee);

        _push(fromAsset, toChainId, toAddress, tokenId);

        emit PolyWrapperLock(fromAsset, msg.sender, toChainId, toAddress, tokenId, feeToken, fee, id);

    }



    function speedUp(address feeToken, bytes memory txHash, uint256 fee) external payable nonReentrant whenNotPaused {

        _pull(feeToken, fee);

        emit PolyWrapperSpeedUp(feeToken, txHash, msg.sender, fee);

    }



    function _pull(address feeToken, uint256 fee) internal {

        if (feeToken == address(0)) {

            require(msg.value == fee, "insufficient ether");

        } else {

            IERC20(feeToken).safeTransferFrom(msg.sender, address(this), fee);

        }

    }



    function _push(address fromAsset, uint64 toChainId, address toAddress, uint256 tokenId) internal {

        CallArgs memory callArgs = CallArgs({

            toAddress: abi.encodePacked(toAddress),

            toChainId: toChainId

        });

        bytes memory callData = _serializeCallArgs(callArgs);

        IERC721(fromAsset).safeTransferFrom(msg.sender, lockProxy, tokenId, callData);

    }



    function _serializeCallArgs(CallArgs memory args) internal pure returns (bytes memory) {

        bytes memory buff;

        buff = abi.encodePacked(

            ZeroCopySink.WriteVarBytes(args.toAddress),

            ZeroCopySink.WriteUint64(args.toChainId)

            );

        return buff;

    }



    function _serializeProfile(bytes memory buff, uint tokenId, string memory url) internal pure returns (bytes memory) {

        buff = abi.encodePacked(

            buff,

            ZeroCopySink.WriteUint256(tokenId),

            ZeroCopySink.WriteVarBytes(bytes(url))

        );

        return buff;

    }



    function _calcEndIndex(uint start, uint length, uint total) internal pure returns (uint) {

        uint end = start + length - 1;

        if (end >= total) {

            end = total - 1;

        }

        return end;

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\pONT.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2023-01-06

*/



/**

 *Submitted for verification at Etherscan.io on 2022-11-16

*/



// File: polynetwork/eth-contracts/contracts/libs/math/SafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b != 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



// File: polynetwork/eth-contracts/contracts/libs/token/ERC20/IERC20.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: polynetwork/eth-contracts/contracts/libs/token/ERC20/ERC20Detailed.sol



pragma solidity ^0.5.0;





/**

 * @dev Optional functions from the ERC20 standard.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20Detailed.sol

 */

contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    /**

     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of

     * these values are immutable: they can only be set once during

     * construction.

     */

    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    /**

     * @dev Returns the name of the token.

     */

    function name() public view returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5,05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei.

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}



// File: polynetwork/eth-contracts/contracts/libs/GSN/Context.sol



pragma solidity ^0.5.0;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with GSN meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol

 */

contract Context {

    // Empty internal constructor, to prevent people from mistakenly deploying

    // an instance of this contract, which should be used via inheritance.

    constructor () internal { }

    // solhint-disable-previous-line no-empty-blocks



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}



// File: polynetwork/eth-contracts/contracts/libs/token/ERC20/ERC20.sol



pragma solidity ^0.5.0;









/**

 * @dev Implementation of the {IERC20} interface.

 *

 * This implementation is agnostic to the way tokens are created. This means

 * that a supply mechanism has to be added in a derived contract using {_mint}.

 * For a generic mechanism see {ERC20Mintable}.

 *

 * TIP: For a detailed writeup see our guide

 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How

 * to implement supply mechanisms].

 *

 * We have followed general OpenZeppelin guidelines: functions revert instead

 * of returning `false` on failure. This behavior is nonetheless conventional

 * and does not conflict with the expectations of ERC20 applications.

 *

 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.

 * This allows applications to reconstruct the allowance for all accounts just

 * by listening to said events. Other implementations of the EIP may not emit

 * these events, as it isn't required by the specification.

 *

 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}

 * functions have been added to mitigate the well-known issues around setting

 * allowances. See {IERC20-approve}.

 * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol

 */

contract ERC20 is Context, IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `recipient` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20};

     *

     * Requirements:

     * - `sender` and `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     * - the caller must have allowance for `sender`'s tokens of at least

     * `amount`.

     */

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    /**

     * @dev Atomically increases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Atomically decreases the allowance granted to `spender` by the caller.

     *

     * This is an alternative to {approve} that can be used as a mitigation for

     * problems described in {IERC20-approve}.

     *

     * Emits an {Approval} event indicating the updated allowance.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `spender` must have allowance for the caller of at least

     * `subtractedValue`.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    /**

     * @dev Moves tokens `amount` from `sender` to `recipient`.

     *

     * This is internal function is equivalent to {transfer}, and can be used to

     * e.g. implement automatic token fees, slashing mechanisms, etc.

     *

     * Emits a {Transfer} event.

     *

     * Requirements:

     *

     * - `sender` cannot be the zero address.

     * - `recipient` cannot be the zero address.

     * - `sender` must have a balance of at least `amount`.

     */

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    /** @dev Creates `amount` tokens and assigns them to `account`, increasing

     * the total supply.

     *

     * Emits a {Transfer} event with `from` set to the zero address.

     *

     * Requirements

     *

     * - `to` cannot be the zero address.

     */

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`, reducing the

     * total supply.

     *

     * Emits a {Transfer} event with `to` set to the zero address.

     *

     * Requirements

     *

     * - `account` cannot be the zero address.

     * - `account` must have at least `amount` tokens.

     */

    function _burn(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    /**

     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.

     *

     * This is internal function is equivalent to `approve`, and can be used to

     * e.g. set automatic allowances for certain subsystems, etc.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `owner` cannot be the zero address.

     * - `spender` cannot be the zero address.

     */

    function _approve(address owner, address spender, uint256 amount) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    /**

     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted

     * from the caller's allowance.

     *

     * See {_burn} and {_approve}.

     */

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));

    }

}



// File: polynetwork/eth-contracts/contracts/core/assets/erc20_template/ERC20Template.sol



pragma solidity ^0.5.0;









contract pONT is Context, ERC20, ERC20Detailed {

    

    constructor (address lockProxy) public ERC20Detailed("Poly Ontology Token", "pONT", 9) {

        _mint(lockProxy, 1000000000000000000);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\ReentrancyGuard.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 */

contract ReentrancyGuard {

    // counter to allow mutex lock with only one SSTORE operation

    uint256 private _guardCounter;



    constructor () internal {

        // The counter starts at one to prevent changing it from zero to a non-zero

        // value, which is a more expensive operation.

        _guardCounter = 1;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        _guardCounter += 1;

        uint256 localCounter = _guardCounter;

        _;

        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\SafeERC20.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



import "IERC20.sol";

import "SafeMath.sol";

import "Utils.sol";



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

    using SafeMath for uint256;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        // safeApprove should only be called when setting an initial allowance,

        // or when resetting it to zero. To increase and decrease it, use

        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'

        // solhint-disable-next-line max-line-length

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    /**

     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement

     * on the return value: the return value is optional (but if data is returned, it must not be false).

     * @param token The token targeted by the call.

     * @param data The call data (encoded using abi.encode or one of its variants).

     */

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since

        // we're implementing it ourselves.



        // A Solidity high level call has three parts:

        //  1. The target address is checked to verify it contains contract code

        //  2. The call itself is made, and success asserted

        //  3. The return value is decoded, which in turn checks the size of the returned data.

        // solhint-disable-next-line max-line-length

        require(Utils.isContract(address(token)), "SafeERC20: call to non-contract");



        // solhint-disable-next-line avoid-low-level-calls

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { // Return data is optional

            // solhint-disable-next-line max-line-length

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\SafeMath.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     *

     * _Available since v2.4.0._

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b != 0, errorMessage);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts with custom message when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     *

     * _Available since v2.4.0._

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}



--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\TetherToken.sol
File type: .sol
/**

 *Submitted for verification at Etherscan.io on 2017-11-28

*/



pragma solidity ^0.4.17;



/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        }

        uint256 c = a * b;

        assert(c / a == b);

        return c;

    }



    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // assert(b > 0); // Solidity automatically throws when dividing by 0

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;

    }



    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        assert(b <= a);

        return a - b;

    }



    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        assert(c >= a);

        return c;

    }

}



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address public owner;



    /**

      * @dev The Ownable constructor sets the original `owner` of the contract to the sender

      * account.

      */

    function Ownable() public {

        owner = msg.sender;

    }



    /**

      * @dev Throws if called by any account other than the owner.

      */

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner The address to transfer ownership to.

    */

    function transferOwnership(address newOwner) public onlyOwner {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }



}



/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20Basic {

    uint public _totalSupply;

    function totalSupply() public constant returns (uint);

    function balanceOf(address who) public constant returns (uint);

    function transfer(address to, uint value) public;

    event Transfer(address indexed from, address indexed to, uint value);

}



/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public constant returns (uint);

    function transferFrom(address from, address to, uint value) public;

    function approve(address spender, uint value) public;

    event Approval(address indexed owner, address indexed spender, uint value);

}



/**

 * @title Basic token

 * @dev Basic version of StandardToken, with no allowances.

 */

contract BasicToken is Ownable, ERC20Basic {

    using SafeMath for uint;



    mapping(address => uint) public balances;



    // additional variables for use if transaction fees ever became necessary

    uint public basisPointsRate = 0;

    uint public maximumFee = 0;



    /**

    * @dev Fix for the ERC20 short address attack.

    */

    modifier onlyPayloadSize(uint size) {

        require(!(msg.data.length < size + 4));

        _;

    }



    /**

    * @dev transfer token for a specified address

    * @param _to The address to transfer to.

    * @param _value The amount to be transferred.

    */

    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {

        uint fee = (_value.mul(basisPointsRate)).div(10000);

        if (fee > maximumFee) {

            fee = maximumFee;

        }

        uint sendAmount = _value.sub(fee);

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(sendAmount);

        if (fee > 0) {

            balances[owner] = balances[owner].add(fee);

            Transfer(msg.sender, owner, fee);

        }

        Transfer(msg.sender, _to, sendAmount);

    }



    /**

    * @dev Gets the balance of the specified address.

    * @param _owner The address to query the the balance of.

    * @return An uint representing the amount owned by the passed address.

    */

    function balanceOf(address _owner) public constant returns (uint balance) {

        return balances[_owner];

    }



}



/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * @dev https://github.com/ethereum/EIPs/issues/20

 * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 */

contract StandardToken is BasicToken, ERC20 {



    mapping (address => mapping (address => uint)) public allowed;



    uint public constant MAX_UINT = 2**256 - 1;



    /**

    * @dev Transfer tokens from one address to another

    * @param _from address The address which you want to send tokens from

    * @param _to address The address which you want to transfer to

    * @param _value uint the amount of tokens to be transferred

    */

    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {

        var _allowance = allowed[_from][msg.sender];



        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met

        // if (_value > _allowance) throw;



        uint fee = (_value.mul(basisPointsRate)).div(10000);

        if (fee > maximumFee) {

            fee = maximumFee;

        }

        if (_allowance < MAX_UINT) {

            allowed[_from][msg.sender] = _allowance.sub(_value);

        }

        uint sendAmount = _value.sub(fee);

        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(sendAmount);

        if (fee > 0) {

            balances[owner] = balances[owner].add(fee);

            Transfer(_from, owner, fee);

        }

        Transfer(_from, _to, sendAmount);

    }



    /**

    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

    * @param _spender The address which will spend the funds.

    * @param _value The amount of tokens to be spent.

    */

    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {



        // To change the approve amount you first have to reduce the addresses`

        //  allowance to zero by calling `approve(_spender, 0)` if it is not

        //  already 0 to mitigate the race condition described here:

        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));



        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

    }



    /**

    * @dev Function to check the amount of tokens than an owner allowed to a spender.

    * @param _owner address The address which owns the funds.

    * @param _spender address The address which will spend the funds.

    * @return A uint specifying the amount of tokens still available for the spender.

    */

    function allowance(address _owner, address _spender) public constant returns (uint remaining) {

        return allowed[_owner][_spender];

    }



}





/**

 * @title Pausable

 * @dev Base contract which allows children to implement an emergency stop mechanism.

 */

contract Pausable is Ownable {

  event Pause();

  event Unpause();



  bool public paused = false;





  /**

   * @dev Modifier to make a function callable only when the contract is not paused.

   */

  modifier whenNotPaused() {

    require(!paused);

    _;

  }



  /**

   * @dev Modifier to make a function callable only when the contract is paused.

   */

  modifier whenPaused() {

    require(paused);

    _;

  }



  /**

   * @dev called by the owner to pause, triggers stopped state

   */

  function pause() onlyOwner whenNotPaused public {

    paused = true;

    Pause();

  }



  /**

   * @dev called by the owner to unpause, returns to normal state

   */

  function unpause() onlyOwner whenPaused public {

    paused = false;

    Unpause();

  }

}



contract BlackList is Ownable, BasicToken {



    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////

    function getBlackListStatus(address _maker) external constant returns (bool) {

        return isBlackListed[_maker];

    }



    function getOwner() external constant returns (address) {

        return owner;

    }



    mapping (address => bool) public isBlackListed;

    

    function addBlackList (address _evilUser) public onlyOwner {

        isBlackListed[_evilUser] = true;

        AddedBlackList(_evilUser);

    }



    function removeBlackList (address _clearedUser) public onlyOwner {

        isBlackListed[_clearedUser] = false;

        RemovedBlackList(_clearedUser);

    }



    function destroyBlackFunds (address _blackListedUser) public onlyOwner {

        require(isBlackListed[_blackListedUser]);

        uint dirtyFunds = balanceOf(_blackListedUser);

        balances[_blackListedUser] = 0;

        _totalSupply -= dirtyFunds;

        DestroyedBlackFunds(_blackListedUser, dirtyFunds);

    }



    event DestroyedBlackFunds(address _blackListedUser, uint _balance);



    event AddedBlackList(address _user);



    event RemovedBlackList(address _user);



}



contract UpgradedStandardToken is StandardToken{

    // those methods are called by the legacy contract

    // and they must ensure msg.sender to be the contract address

    function transferByLegacy(address from, address to, uint value) public;

    function transferFromByLegacy(address sender, address from, address spender, uint value) public;

    function approveByLegacy(address from, address spender, uint value) public;

}



contract TetherToken is Pausable, StandardToken, BlackList {



    string public name;

    string public symbol;

    uint public decimals;

    address public upgradedAddress;

    bool public deprecated;



    //  The contract can be initialized with a number of tokens

    //  All the tokens are deposited to the owner address

    //

    // @param _balance Initial supply of the contract

    // @param _name Token Name

    // @param _symbol Token symbol

    // @param _decimals Token decimals

    function TetherToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public {

        _totalSupply = _initialSupply;

        name = _name;

        symbol = _symbol;

        decimals = _decimals;

        balances[owner] = _initialSupply;

        deprecated = false;

    }



    // Forward ERC20 methods to upgraded contract if this one is deprecated

    function transfer(address _to, uint _value) public whenNotPaused {

        require(!isBlackListed[msg.sender]);

        if (deprecated) {

            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);

        } else {

            return super.transfer(_to, _value);

        }

    }



    // Forward ERC20 methods to upgraded contract if this one is deprecated

    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {

        require(!isBlackListed[_from]);

        if (deprecated) {

            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);

        } else {

            return super.transferFrom(_from, _to, _value);

        }

    }



    // Forward ERC20 methods to upgraded contract if this one is deprecated

    function balanceOf(address who) public constant returns (uint) {

        if (deprecated) {

            return UpgradedStandardToken(upgradedAddress).balanceOf(who);

        } else {

            return super.balanceOf(who);

        }

    }



    // Forward ERC20 methods to upgraded contract if this one is deprecated

    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {

        if (deprecated) {

            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);

        } else {

            return super.approve(_spender, _value);

        }

    }



    // Forward ERC20 methods to upgraded contract if this one is deprecated

    function allowance(address _owner, address _spender) public constant returns (uint remaining) {

        if (deprecated) {

            return StandardToken(upgradedAddress).allowance(_owner, _spender);

        } else {

            return super.allowance(_owner, _spender);

        }

    }



    // deprecate current contract in favour of a new one

    function deprecate(address _upgradedAddress) public onlyOwner {

        deprecated = true;

        upgradedAddress = _upgradedAddress;

        Deprecate(_upgradedAddress);

    }



    // deprecate current contract if favour of a new one

    function totalSupply() public constant returns (uint) {

        if (deprecated) {

            return StandardToken(upgradedAddress).totalSupply();

        } else {

            return _totalSupply;

        }

    }



    // Issue a new amount of tokens

    // these tokens are deposited into the owner address

    //

    // @param _amount Number of tokens to be issued

    function issue(uint amount) public onlyOwner {

        require(_totalSupply + amount > _totalSupply);

        require(balances[owner] + amount > balances[owner]);



        balances[owner] += amount;

        _totalSupply += amount;

        Issue(amount);

    }



    // Redeem tokens.

    // These tokens are withdrawn from the owner address

    // if the balance must be enough to cover the redeem

    // or the call will fail.

    // @param _amount Number of tokens to be issued

    function redeem(uint amount) public onlyOwner {

        require(_totalSupply >= amount);

        require(balances[owner] >= amount);



        _totalSupply -= amount;

        balances[owner] -= amount;

        Redeem(amount);

    }



    function setParams(uint newBasisPoints, uint newMaxFee) public onlyOwner {

        // Ensure transparency by hardcoding limit beyond which fees can never be added

        require(newBasisPoints < 20);

        require(newMaxFee < 50);



        basisPointsRate = newBasisPoints;

        maximumFee = newMaxFee.mul(10**decimals);



        Params(basisPointsRate, maximumFee);

    }



    // Called when new token are issued

    event Issue(uint amount);



    // Called when tokens are redeemed

    event Redeem(uint amount);



    // Called when contract is deprecated

    event Deprecate(address newAddress);



    // Called if contract ever adds fees

    event Params(uint feeBasisPoints, uint maxFee);

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\Utils.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;





library Utils {



    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32

    *  @param _bs   Source bytes array

    *  @return      bytes32

    */

    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {

        require(_bs.length == 32, "bytes length is not 32.");

        assembly {

            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length

            value := mload(add(_bs, 0x20))

        }

    }



    /* @notice      Convert bytes to uint256

    *  @param _b    Source bytes should have length of 32

    *  @return      uint256

    */

    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {

        require(_bs.length == 32, "bytes length is not 32.");

        assembly {

            // load 32 bytes from memory starting from position _bs + 32

            value := mload(add(_bs, 0x20))

        }

        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds the range");

    }



    /* @notice      Convert uint256 to bytes

    *  @param _b    uint256 that needs to be converted

    *  @return      bytes

    */

    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {

        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds the range");

        assembly {

            // Get a location of some free memory and store it in result as

            // Solidity does for memory variables.

            bs := mload(0x40)

            // Put 0x20 at the first word, the length of bytes for uint256 value

            mstore(bs, 0x20)

            //In the next word, put value in bytes format to the next 32 bytes

            mstore(add(bs, 0x20), _value)

            // Update the free-memory pointer by padding our last write location to 32 bytes

            mstore(0x40, add(bs, 0x40))

        }

    }



    /* @notice      Convert bytes to address

    *  @param _bs   Source bytes: bytes length must be 20

    *  @return      Converted address from source bytes

    */

    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)

    {

        require(_bs.length == 20, "bytes length does not match address");

        assembly {

            // for _bs, first word store _bs.length, second word store _bs.value

            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).

            addr := mload(add(_bs, 0x14))

        }



    }

    

    /* @notice      Convert address to bytes

    *  @param _addr Address need to be converted

    *  @return      Converted bytes from address

    */

    function addressToBytes(address _addr) internal pure returns (bytes memory bs){

        assembly {

            // Get a location of some free memory and store it in result as

            // Solidity does for memory variables.

            bs := mload(0x40)

            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value

            mstore(bs, 0x14)

            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned

            mstore(add(bs, 0x20), shl(96, _addr))

            // Update the free-memory pointer by padding our last write location to 32 bytes

            mstore(0x40, add(bs, 0x40))

       }

    }



    /* @notice          Do hash leaf as the multi-chain does

    *  @param _data     Data in bytes format

    *  @return          Hashed value in bytes32 format

    */

    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {

        result = sha256(abi.encodePacked(byte(0x0), _data));

    }



    /* @notice          Do hash children as the multi-chain does

    *  @param _l        Left node

    *  @param _r        Right node

    *  @return          Hashed value in bytes32 format

    */

    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {

        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));

    }



    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately

                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368

    *  @param _preBytes     The bytes stored in storage

    *  @param _postBytes    The bytes stored in memory

    *  @return              Bool type indicating if they are equal

    */

    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {

        bool success = true;



        assembly {

            // we know _preBytes_offset is 0

            let fslot := sload(_preBytes_slot)

            // Arrays of 31 bytes or less have an even value in their slot,

            // while longer arrays have an odd value. The actual length is

            // the slot divided by two for odd values, and the lowest order

            // byte divided by two for even values.

            // If the slot is even, bitwise and the slot with 255 and divide by

            // two to get the length. If the slot is odd, bitwise and the slot

            // with -1 and divide by two.

            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)

            let mlength := mload(_postBytes)



            // if lengths don't match the arrays are not equal

            switch eq(slength, mlength)

            case 1 {

                // fslot can contain both the length and contents of the array

                // if slength < 32 bytes so let's prepare for that

                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage

                // slength != 0

                if iszero(iszero(slength)) {

                    switch lt(slength, 32)

                    case 1 {

                        // blank the last byte which is the length

                        fslot := mul(div(fslot, 0x100), 0x100)



                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {

                            // unsuccess:

                            success := 0

                        }

                    }

                    default {

                        // cb is a circuit breaker in the for loop since there's

                        //  no said feature for inline assembly loops

                        // cb = 1 - don't breaker

                        // cb = 0 - break

                        let cb := 1



                        // get the keccak hash to get the contents of the array

                        mstore(0x0, _preBytes_slot)

                        let sc := keccak256(0x0, 0x20)



                        let mc := add(_postBytes, 0x20)

                        let end := add(mc, mlength)



                        // the next line is the loop condition:

                        // while(uint(mc < end) + cb == 2)

                        for {} eq(add(lt(mc, end), cb), 2) {

                            sc := add(sc, 1)

                            mc := add(mc, 0x20)

                        } {

                            if iszero(eq(sload(sc), mload(mc))) {

                                // unsuccess:

                                success := 0

                                cb := 0

                            }

                        }

                    }

                }

            }

            default {

                // unsuccess:

                success := 0

            }

        }



        return success;

    }



    /* @notice              Slice the _bytes from _start index till the result has length of _length

                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246

    *  @param _bytes        The original bytes needs to be sliced

    *  @param _start        The index of _bytes for the start of sliced bytes

    *  @param _length       The index of _bytes for the end of sliced bytes

    *  @return              The sliced bytes

    */

    function slice(

        bytes memory _bytes,

        uint _start,

        uint _length

    )

        internal

        pure

        returns (bytes memory)

    {

        require(_bytes.length >= (_start + _length));



        bytes memory tempBytes;



        assembly {

            switch iszero(_length)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                // lengthmod <= _length % 32

                let lengthmod := and(_length, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, _length)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, _length)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return tempBytes;

    }

    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m

    *  @param _keepers      The array consists of serveral address

    *  @param _signers      Some specific addresses to be looked into

    *  @param _m            The number requirement paramter

    *  @return              True means containment, false meansdo do not contain.

    */

    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){

        uint m = 0;

        for(uint i = 0; i < _signers.length; i++){

            for (uint j = 0; j < _keepers.length; j++) {

                if (_signers[i] == _keepers[j]) {

                    m++;

                    delete _keepers[j];

                }

            }

        }

        return m >= _m;

    }



    /* @notice              TODO

    *  @param key

    *  @return

    */

    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {

         require(key.length >= 67, "key lenggh is too short");

         newkey = slice(key, 0, 35);

         if (uint8(key[66]) % 2 == 0){

             newkey[2] = byte(0x02);

         } else {

             newkey[2] = byte(0x03);

         }

         return newkey;

    }

    

    /**

     * @dev Returns true if `account` is a contract.

     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18

     *

     * This test is non-exhaustive, and there may be false-negatives: during the

     * execution of a contract's constructor, its address will be reported as

     * not containing a contract.

     *

     * IMPORTANT: It is unsafe to assume that an address for which this

     * function returns false is an externally-owned account (EOA) and not a

     * contract.

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies in extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts

        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned

        // for accounts without code, i.e. `keccak256('')`

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        // solhint-disable-next-line no-inline-assembly

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\ZeroCopySink.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Wrappers over encoding and serialization operation into bytes from bassic types in Solidity for PolyNetwork cross chain utility.

 *

 * Encode basic types in Solidity into bytes easily. It's designed to be used 

 * for PolyNetwork cross chain application, and the encoding rules on Ethereum chain 

 * and the decoding rules on other chains should be consistent. Here we  

 * follow the underlying serialization rule with implementation found here: 

 * https://github.com/polynetwork/poly/blob/master/common/zero_copy_sink.go

 *

 * Using this library instead of the unchecked serialization method can help reduce

 * the risk of serious bugs and handfule, so it's recommended to use it.

 *

 * Please note that risk can be minimized, yet not eliminated.

 */

library ZeroCopySink {

    /* @notice          Convert boolean value into bytes

    *  @param b         The boolean value

    *  @return          Converted bytes array

    */

    function WriteBool(bool b) internal pure returns (bytes memory) {

        bytes memory buff;

        assembly{

            buff := mload(0x40)

            mstore(buff, 1)

            switch iszero(b)

            case 1 {

                mstore(add(buff, 0x20), shl(248, 0x00))

                // mstore8(add(buff, 0x20), 0x00)

            }

            default {

                mstore(add(buff, 0x20), shl(248, 0x01))

                // mstore8(add(buff, 0x20), 0x01)

            }

            mstore(0x40, add(buff, 0x21))

        }

        return buff;

    }



    /* @notice          Convert byte value into bytes

    *  @param b         The byte value

    *  @return          Converted bytes array

    */

    function WriteByte(byte b) internal pure returns (bytes memory) {

        return WriteUint8(uint8(b));

    }



    /* @notice          Convert uint8 value into bytes

    *  @param v         The uint8 value

    *  @return          Converted bytes array

    */

    function WriteUint8(uint8 v) internal pure returns (bytes memory) {

        bytes memory buff;

        assembly{

            buff := mload(0x40)

            mstore(buff, 1)

            mstore(add(buff, 0x20), shl(248, v))

            // mstore(add(buff, 0x20), byte(0x1f, v))

            mstore(0x40, add(buff, 0x21))

        }

        return buff;

    }



    /* @notice          Convert uint16 value into bytes

    *  @param v         The uint16 value

    *  @return          Converted bytes array

    */

    function WriteUint16(uint16 v) internal pure returns (bytes memory) {

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x02

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x22))

        }

        return buff;

    }

    

    /* @notice          Convert uint32 value into bytes

    *  @param v         The uint32 value

    *  @return          Converted bytes array

    */

    function WriteUint32(uint32 v) internal pure returns(bytes memory) {

        bytes memory buff;

        assembly{

            buff := mload(0x40)

            let byteLen := 0x04

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x24))

        }

        return buff;

    }



    /* @notice          Convert uint64 value into bytes

    *  @param v         The uint64 value

    *  @return          Converted bytes array

    */

    function WriteUint64(uint64 v) internal pure returns(bytes memory) {

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x08

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x28))

        }

        return buff;

    }



    /* @notice          Convert limited uint256 value into bytes

    *  @param v         The uint256 value

    *  @return          Converted bytes array

    */

    function WriteUint255(uint256 v) internal pure returns (bytes memory) {

        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds uint255 range");

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x20

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x40))

        }

        return buff;

    }



    /* @notice          Convert limited uint256 value into bytes

    *  @param v         The uint256 value

    *  @return          Converted bytes array

    */

    function WriteUint256(uint256 v) internal pure returns (bytes memory) {

        require(v <= uint256(-1), "Value exceeds uint256 range");

        bytes memory buff;



        assembly{

            buff := mload(0x40)

            let byteLen := 0x20

            mstore(buff, byteLen)

            for {

                let mindex := 0x00

                let vindex := 0x1f

            } lt(mindex, byteLen) {

                mindex := add(mindex, 0x01)

                vindex := sub(vindex, 0x01)

            }{

                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))

            }

            mstore(0x40, add(buff, 0x40))

        }

        return buff;

    }



    /* @notice          Encode bytes format data into bytes

    *  @param data      The bytes array data

    *  @return          Encoded bytes array

    */

    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {

        uint64 l = uint64(data.length);

        return abi.encodePacked(WriteVarUint(l), data);

    }



    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {

        if (v < 0xFD){

    		return WriteUint8(uint8(v));

    	} else if (v <= 0xFFFF) {

    		return abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));

    	} else if (v <= 0xFFFFFFFF) {

            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));

    	} else {

    		return abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));

    	}

    }

}

--------------------------------------------------
File End
--------------------------------------------------


F:\cross_chain_vul_det_based_llm\dedup_non_vul_bridges_output_aliyun_723\PolyBridge\contracts\ZeroCopySource.sol
File type: .sol
// SPDX-License-Identifier: MIT



pragma solidity ^0.6.0;



/**

 * @dev Wrappers over decoding and deserialization operation from bytes into bassic types in Solidity for PolyNetwork cross chain utility.

 *

 * Decode into basic types in Solidity from bytes easily. It's designed to be used 

 * for PolyNetwork cross chain application, and the decoding rules on Ethereum chain 

 * and the encoding rule on other chains should be consistent, and . Here we

 * follow the underlying deserialization rule with implementation found here: 

 * https://github.com/polynetwork/poly/blob/master/common/zero_copy_source.go

 *

 * Using this library instead of the unchecked serialization method can help reduce

 * the risk of serious bugs and handfule, so it's recommended to use it.

 *

 * Please note that risk can be minimized, yet not eliminated.

 */

library ZeroCopySource {

    /* @notice              Read next byte as boolean type starting at offset from buff

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the boolean value

    *  @return              The the read boolean value and new offset

    */

    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {

        require(offset + 1 <= buff.length && offset < offset + 1, "Offset exceeds limit");

        // byte === bytes1

        byte v;

        assembly{

            v := mload(add(add(buff, 0x20), offset))

        }

        bool value;

        if (v == 0x01) {

		    value = true;

    	} else if (v == 0x00) {

            value = false;

        } else {

            revert("NextBool value error");

        }

        return (value, offset + 1);

    }



    /* @notice              Read next byte starting at offset from buff

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the byte value

    *  @return              The read byte value and new offset

    */

    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {

        require(offset + 1 <= buff.length && offset < offset + 1, "NextByte, Offset exceeds maximum");

        byte v;

        assembly{

            v := mload(add(add(buff, 0x20), offset))

        }

        return (v, offset + 1);

    }



    /* @notice              Read next byte as uint8 starting at offset from buff

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the byte value

    *  @return              The read uint8 value and new offset

    */

    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {

        require(offset + 1 <= buff.length && offset < offset + 1, "NextUint8, Offset exceeds maximum");

        uint8 v;

        assembly{

            let tmpbytes := mload(0x40)

            let bvalue := mload(add(add(buff, 0x20), offset))

            mstore8(tmpbytes, byte(0, bvalue))

            mstore(0x40, add(tmpbytes, 0x01))

            v := mload(sub(tmpbytes, 0x1f))

        }

        return (v, offset + 1);

    }



    /* @notice              Read next two bytes as uint16 type starting from offset

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint16 value

    *  @return              The read uint16 value and updated offset

    */

    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {

        require(offset + 2 <= buff.length && offset < offset + 2, "NextUint16, offset exceeds maximum");

        

        uint16 v;

        assembly {

            let tmpbytes := mload(0x40)

            let bvalue := mload(add(add(buff, 0x20), offset))

            mstore8(tmpbytes, byte(0x01, bvalue))

            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))

            mstore(0x40, add(tmpbytes, 0x02))

            v := mload(sub(tmpbytes, 0x1e))

        }

        return (v, offset + 2);

    }





    /* @notice              Read next four bytes as uint32 type starting from offset

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint32 value

    *  @return              The read uint32 value and updated offset

    */

    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {

        require(offset + 4 <= buff.length && offset < offset + 4, "NextUint32, offset exceeds maximum");

        uint32 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x04

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(sub(tmpbytes, sub(0x20, byteLen)))

        }

        return (v, offset + 4);

    }



    /* @notice              Read next eight bytes as uint64 type starting from offset

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint64 value

    *  @return              The read uint64 value and updated offset

    */

    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {

        require(offset + 8 <= buff.length && offset < offset + 8, "NextUint64, offset exceeds maximum");

        uint64 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x08

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(sub(tmpbytes, sub(0x20, byteLen)))

        }

        return (v, offset + 8);

    }



    /* @notice              Read next 32 bytes as uint256 type starting from offset,

                            there are limits considering the numerical limits in multi-chain

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the uint256 value

    *  @return              The read uint256 value and updated offset

    */

    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {

        require(offset + 32 <= buff.length && offset < offset + 32, "NextUint255, offset exceeds maximum");

        uint256 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x20

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(tmpbytes)

        }

        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, "Value exceeds the range");

        return (v, offset + 32);

    }



    function NextUint256(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {

        require(offset + 32 <= buff.length && offset < offset + 32, "NextUint256, offset exceeds maximum");

        uint256 v;

        assembly {

            let tmpbytes := mload(0x40)

            let byteLen := 0x20

            for {

                let tindex := 0x00

                let bindex := sub(byteLen, 0x01)

                let bvalue := mload(add(add(buff, 0x20), offset))

            } lt(tindex, byteLen) {

                tindex := add(tindex, 0x01)

                bindex := sub(bindex, 0x01)

            }{

                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))

            }

            mstore(0x40, add(tmpbytes, byteLen))

            v := mload(tmpbytes)

        }

        require(v <= uint256(-1), "Value exceeds the range");

        return (v, offset + 32);

    }



    /* @notice              Read next variable bytes starting from offset,

                            the decoding rule coming from multi-chain

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the bytes value

    *  @return              The read variable bytes array value and updated offset

    */

    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {

        uint len;

        (len, offset) = NextVarUint(buff, offset);

        require(offset + len <= buff.length && offset < offset + len, "NextVarBytes, offset exceeds maximum");

        bytes memory tempBytes;

        assembly{

            switch iszero(len)

            case 0 {

                // Get a location of some free memory and store it in tempBytes as

                // Solidity does for memory variables.

                tempBytes := mload(0x40)



                // The first word of the slice result is potentially a partial

                // word read from the original array. To read it, we calculate

                // the length of that partial word and start copying that many

                // bytes into the array. The first word we copy will start with

                // data we don't care about, but the last `lengthmod` bytes will

                // land at the beginning of the contents of the new array. When

                // we're done copying, we overwrite the full first word with

                // the actual length of the slice.

                let lengthmod := and(len, 31)



                // The multiplication in the next line is necessary

                // because when slicing multiples of 32 bytes (lengthmod == 0)

                // the following copy loop was copying the origin's length

                // and then ending prematurely not copying everything it should.

                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))

                let end := add(mc, len)



                for {

                    // The multiplication in the next line has the same exact purpose

                    // as the one above.

                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)

                } lt(mc, end) {

                    mc := add(mc, 0x20)

                    cc := add(cc, 0x20)

                } {

                    mstore(mc, mload(cc))

                }



                mstore(tempBytes, len)



                //update free-memory pointer

                //allocating the array padded to 32 bytes like the compiler does now

                mstore(0x40, and(add(mc, 31), not(31)))

            }

            //if we want a zero-length slice let's just return a zero-length array

            default {

                tempBytes := mload(0x40)



                mstore(0x40, add(tempBytes, 0x20))

            }

        }



        return (tempBytes, offset + len);

    }

    /* @notice              Read next 32 bytes starting from offset,

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the bytes value

    *  @return              The read bytes32 value and updated offset

    */

    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {

        require(offset + 32 <= buff.length && offset < offset + 32, "NextHash, offset exceeds maximum");

        bytes32 v;

        assembly {

            v := mload(add(buff, add(offset, 0x20)))

        }

        return (v, offset + 32);

    }



    /* @notice              Read next 20 bytes starting from offset,

    *  @param buff          Source bytes array

    *  @param offset        The position from where we read the bytes value

    *  @return              The read bytes20 value and updated offset

    */

    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {

        require(offset + 20 <= buff.length && offset < offset + 20, "NextBytes20, offset exceeds maximum");

        bytes20 v;

        assembly {

            v := mload(add(buff, add(offset, 0x20)))

        }

        return (v, offset + 20);

    }

    

    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {

        byte v;

        (v, offset) = NextByte(buff, offset);



        uint value;

        if (v == 0xFD) {

            // return NextUint16(buff, offset);

            (value, offset) = NextUint16(buff, offset);

            require(value >= 0xFD && value <= 0xFFFF, "NextUint16, value outside range");

            return (value, offset);

        } else if (v == 0xFE) {

            // return NextUint32(buff, offset);

            (value, offset) = NextUint32(buff, offset);

            require(value > 0xFFFF && value <= 0xFFFFFFFF, "NextVarUint, value outside range");

            return (value, offset);

        } else if (v == 0xFF) {

            // return NextUint64(buff, offset);

            (value, offset) = NextUint64(buff, offset);

            require(value > 0xFFFFFFFF, "NextVarUint, value outside range");

            return (value, offset);

        } else{

            // return (uint8(v), offset);

            value = uint8(v);

            require(value < 0xFD, "NextVarUint, value outside range");

            return (value, offset);

        }

    }

}

--------------------------------------------------
File End
--------------------------------------------------

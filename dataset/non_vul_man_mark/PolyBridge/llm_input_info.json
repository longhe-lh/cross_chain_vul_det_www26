{
    "src_chain": {
        "LockEvent1": [
            {
                "lock": "function lock(\n address fromAssetHash,\n uint64 toChainId,\n bytes memory toAddress,\n uint256 amount\n ) public payable returns (bool) {\n require(amount != 0, \"amount cannot be zero!\");\n\n require(\n _transferToContract(fromAssetHash, amount),\n \"transfer asset from fromAddress to lock_proxy contract failed!\"\n );\n\n bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId];\n\n require(toAssetHash.length != 0, \"empty illegal toAssetHash\");\n\n TxArgs memory txArgs = TxArgs({\n toAssetHash: toAssetHash,\n toAddress: toAddress,\n amount: amount\n });\n\n bytes memory txData = _serializeTxArgs(txArgs);\n\n IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(\n managerProxyContract\n );\n\n address eccmAddr = eccmp.getEthCrossChainManager();\n\n IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n\n bytes memory toProxyHash = proxyHashMap[toChainId];\n\n require(toProxyHash.length != 0, \"empty illegal toProxyHash\");\n\n require(\n eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData),\n \"EthCrossChainManager crossChain executed error!\"\n );\n\n emit LockEvent(\n fromAssetHash,\n _msgSender(),\n toChainId,\n toAssetHash,\n toAddress,\n amount\n );\n\n return true;\n }"
            },
            {
                "_transferToContract": "function _transferToContract(\n address fromAssetHash,\n uint256 amount\n ) internal returns (bool) {\n if (fromAssetHash == address(0)) {\n \n\n \n\n require(msg.value != 0, \"transferred ether cannot be zero!\");\n\n require(\n msg.value == amount,\n \"transferred ether is not equal to amount!\"\n );\n } else {\n \n\n require(msg.value == 0, \"there should be no ether transfer!\");\n\n \n\n require(\n _transferERC20ToContract(\n fromAssetHash,\n _msgSender(),\n address(this),\n amount\n ),\n \"transfer erc20 asset to lock_proxy contract failed!\"\n );\n }\n\n return true;\n }"
            },
            {
                "_transferERC20ToContract": "function _transferERC20ToContract(\n address fromAssetHash,\n address fromAddress,\n address toAddress,\n uint256 amount\n ) internal returns (bool) {\n IERC20 erc20Token = IERC20(fromAssetHash);\n\n \n\n function safeTransferFrom(...) {...}\nerc20Token.safeTransferFrom(fromAddress, toAddress, amount);\n\n return true;\n }"
            }
        ]
    },
    "rel_chain": {
        "CrossChainEvent": [
            {
                "crossChain": "function crossChain(\n uint64 toChainId,\n bytes calldata toContract,\n bytes calldata method,\n bytes calldata txData\n ) external whenNotPaused returns (bool) {\n \n\n require(whiteListFromContract[msg.sender], \"Invalid from contract\");\n\n \n\n IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n\n \n\n uint256 txHashIndex = eccd.getEthTxHashIndex();\n\n \n\n bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex);\n\n \n\n bytes memory rawParam = abi.encodePacked(\n ZeroCopySink.WriteVarBytes(paramTxHash),\n ZeroCopySink.WriteVarBytes(\n abi.encodePacked(\n sha256(abi.encodePacked(address(this), paramTxHash))\n )\n ),\n ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)),\n ZeroCopySink.WriteUint64(toChainId),\n ZeroCopySink.WriteVarBytes(toContract),\n ZeroCopySink.WriteVarBytes(method),\n ZeroCopySink.WriteVarBytes(txData)\n );\n\n \n\n require(\n eccd.putEthTxHash(keccak256(rawParam)),\n \"Save ethTxHash by index to Data contract failed!\"\n );\n\n \n\n emit CrossChainEvent(\n tx.origin,\n paramTxHash,\n msg.sender,\n toChainId,\n toContract,\n rawParam\n );\n\n return true;\n }"
            }
        ],
        "VerifyHeaderAndExecuteTxEvent": [
            {
                "verifyHeaderAndExecuteTx": "function verifyHeaderAndExecuteTx(\n bytes memory proof,\n bytes memory rawHeader,\n bytes memory headerProof,\n bytes memory curRawHeader,\n bytes memory headerSig\n ) public whenNotPaused returns (bool) {\n ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n\n \n\n IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n\n \n\n address[] memory polyChainBKs = ECCUtils.deserializeKeepers(\n eccd.getCurEpochConPubKeyBytes()\n );\n\n uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\n\n uint n = polyChainBKs.length;\n\n if (header.height >= curEpochStartHeight) {\n \n\n require(\n ECCUtils.verifySig(\n rawHeader,\n headerSig,\n polyChainBKs,\n n - (n - 1) / 3\n ),\n \"Verify poly chain header signature failed!\"\n );\n } else {\n \n\n require(\n ECCUtils.verifySig(\n curRawHeader,\n headerSig,\n polyChainBKs,\n n - (n - 1) / 3\n ),\n \"Verify poly chain current epoch header signature failed!\"\n );\n\n \n\n ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(\n curRawHeader\n );\n\n bytes memory proveValue = ECCUtils.merkleProve(\n headerProof,\n curHeader.blockRoot\n );\n\n require(\n ECCUtils.getHeaderHash(rawHeader) ==\n Utils.bytesToBytes32(proveValue),\n \"verify header proof failed!\"\n );\n }\n\n \n\n bytes memory toMerkleValueBs = ECCUtils.merkleProve(\n proof,\n header.crossStatesRoot\n );\n\n \n\n ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils\n .deserializeMerkleValue(toMerkleValueBs);\n\n require(\n !eccd.checkIfFromChainTxExist(\n toMerkleValue.fromChainID,\n Utils.bytesToBytes32(toMerkleValue.txHash)\n ),\n \"the transaction has been executed!\"\n );\n\n require(\n eccd.markFromChainTxExist(\n toMerkleValue.fromChainID,\n Utils.bytesToBytes32(toMerkleValue.txHash)\n ),\n \"Save crosschain tx exist failed!\"\n );\n\n \n\n require(\n toMerkleValue.makeTxParam.toChainId == chainId,\n \"This Tx is not aiming at this network!\"\n );\n\n \n\n address toContract = Utils.bytesToAddress(\n toMerkleValue.makeTxParam.toContract\n );\n\n \n\n require(\n whiteListContractMethodMap[toContract][\n toMerkleValue.makeTxParam.method\n ],\n \"Invalid to contract or method\"\n );\n\n \n\n require(\n _executeCrossChainTx(\n toContract,\n toMerkleValue.makeTxParam.method,\n toMerkleValue.makeTxParam.args,\n toMerkleValue.makeTxParam.fromContract,\n toMerkleValue.fromChainID\n ),\n \"Execute CrossChain Tx failed!\"\n );\n\n \n\n \n\n emit VerifyHeaderAndExecuteTxEvent(\n toMerkleValue.fromChainID,\n toMerkleValue.makeTxParam.toContract,\n toMerkleValue.txHash,\n toMerkleValue.makeTxParam.txHash\n );\n\n return true;\n }"
            },
            {
                "_executeCrossChainTx": "function _executeCrossChainTx(\n address _toContract,\n bytes memory _method,\n bytes memory _args,\n bytes memory _fromContractAddr,\n uint64 _fromChainId\n ) internal returns (bool) {\n \n\n require(\n Utils.isContract(_toContract),\n \"The passed in address is not a contract!\"\n );\n\n bytes memory returnData;\n\n bool success;\n\n \n\n (success, returnData) = _toContract.call(\n abi.encodePacked(\n bytes4(\n keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))\n ),\n abi.encode(_args, _fromContractAddr, _fromChainId)\n )\n );\n\n \n\n require(success == true, \"EthCrossChain call business contract failed\");\n\n \n\n require(\n returnData.length != 0,\n \"No return value from business contract!\"\n );\n\n (bool res, ) = ZeroCopySource.NextBool(returnData, 31);\n\n require(\n res == true,\n \"EthCrossChain call business contract return is not true\"\n );\n\n return true;\n }"
            }
        ]
    },
    "det_chain": {
        "UnlockEvent1": [
            {
                "unlock": "function unlock(\n bytes memory argsBs,\n bytes memory fromContractAddr,\n uint64 fromChainId\n ) public onlyManagerContract returns (bool) {\n TxArgs memory args = _deserializeTxArgs(argsBs);\n\n require(\n fromContractAddr.length != 0,\n \"from proxy contract address cannot be empty\"\n );\n\n require(\n Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr),\n \"From Proxy contract address error!\"\n );\n\n require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\");\n\n address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\n\n require(args.toAddress.length != 0, \"toAddress cannot be empty\");\n\n address toAddress = Utils.bytesToAddress(args.toAddress);\n\n require(\n _transferFromContract(toAssetHash, toAddress, args.amount),\n \"transfer asset from lock_proxy contract to toAddress failed!\"\n );\n\n emit UnlockEvent(toAssetHash, toAddress, args.amount);\n\n return true;\n }"
            },
            {
                "_transferFromContract": "function _transferFromContract(\n address toAssetHash,\n address toAddress,\n uint256 amount\n ) internal returns (bool) {\n if (\n toAssetHash == address(0x0000000000000000000000000000000000000000)\n ) {\n \n\n \n\n address(uint160(toAddress)).transfer(amount);\n } else {\n \n\n require(\n _transferERC20FromContract(toAssetHash, toAddress, amount),\n \"transfer erc20 asset to lock_proxy contract failed!\"\n );\n }\n\n return true;\n }"
            },
            {
                "_transferERC20FromContract": "function _transferERC20FromContract(\n address toAssetHash,\n address toAddress,\n uint256 amount\n ) internal returns (bool) {\n IERC20 erc20Token = IERC20(toAssetHash);\n\n \n\n function safeTransfer(...) {...}\nerc20Token.safeTransfer(toAddress, amount);\n\n return true;\n }"
            }
        ]
    }
}
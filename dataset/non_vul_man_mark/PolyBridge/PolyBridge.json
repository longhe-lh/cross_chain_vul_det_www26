{
  "contract": "PolyBridge",
  "source_code_path": "../contracts/",
  "type": "",
  "vulnerable_entry_function": {
    "file": "",
    "name": "",
    "signature": "",
    "lines": "",
    "attack_type": "",
    "vul_reason": "",
    "code_snippet": ""
  },
  "detail": "",
  "blg": {
    "PolyBridge": {
      "interoperability": "heterogeneous",
      "roles": {
        "src_chain": [
          "LockEvent1"
        ],
        "rel_chain": [
          "CrossChainEvent",
          "VerifyHeaderAndExecuteTxEvent"
        ],
        "det_chain": [
          "UnlockEvent1"
        ]
      },
      "src_chain": {
        "chain_name": "Ethereum",
        "events": {
          "LockEvent1": {
            "0": {
              "func_name": "lock",
              "file_name": "LockProxy.sol",
              "key_ops": [
                "require(amount != 0, \"amount cannot be zero!\")",
                "require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\")",
                "require(toAssetHash.length != 0, \"empty illegal toAssetHash\")",
                "require(toProxyHash.length != 0, \"empty illegal toProxyHash\")",
                "require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\")"
              ],
              "child": {
                "0": {
                  "func_name": "_transferToContract",
                  "file_name": "LockProxy.sol",
                  "key_ops": [
                    "require(msg.value != 0, \"transferred ether cannot be zero!\")",
                    "require(msg.value == amount, \"transferred ether is not equal to amount!\")",
                    "require(msg.value == 0, \"there should be no ether transfer!\")",
                    "require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\")"
                  ],
                  "child": {
                    "0": {
                      "func_name": "_transferERC20ToContract",
                      "file_name": "LockProxy.sol",
                      "key_ops": [
                        "erc20Token.safeTransferFrom(fromAddress, toAddress, amount)"
                      ],
                      "child": {}
                    }
                  }
                },
                "1": {
                  "func_name": "_serializeTxArgs",
                  "file_name": "LockProxy.sol",
                  "key_ops": [],
                  "child": {}
                }
              }
            }
          }
        }
      },
      "rel_chain": {
        "chain_name": "PolyChain",
        "events": {
          "CrossChainEvent": {
            "0": {
              "func_name": "crossChain",
              "file_name": "EthCrossChainManager.sol",
              "key_ops": [
                "require(whiteListFromContract[msg.sender],\"Invalid from contract\")",
                "require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\")"
              ],
              "child": {
                "0": {
                  "func_name": "putEthTxHash",
                  "file_name": "EthCrossChainData.sol",
                  "key_ops": [],
                  "child": {}
                }
              }
            }
          },
          "VerifyHeaderAndExecuteTxEvent": {
            "0": {
              "func_name": "verifyHeaderAndExecuteTx",
              "file_name": "EthCrossChainManager.sol",
              "key_ops": [
                "require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\")",
                "require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\")",
                "require(ECCUtils.merkleProve(headerProof, curHeader.blockRoot), \"verify header proof failed!\")",
                "require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\")",
                "require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\")",
                "require(toMerkleValue.makeTxParam.toChainId == chainId, \"This Tx is not aiming at this network!\")",
                "require(whiteListContractMethodMap[toContract][toMerkleValue.makeTxParam.method],\"Invalid to contract or method\")",
                "require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\")"
              ],
              "child": {
                "0": {
                  "func_name": "_executeCrossChainTx",
                  "file_name": "EthCrossChainManager.sol",
                  "key_ops": [
                    "require(Utils.isContract(_toContract), \"The passed in address is not a contract!\")",
                    "require(success == true, \"EthCrossChain call business contract failed\")",
                    "require(returnData.length != 0, \"No return value from business contract!\")",
                    "(bool res,) = ZeroCopySource.NextBool(returnData, 31)",
                    "require(res == true, \"EthCrossChain call business contract return is not true\")"
                  ],
                  "child": {}
                }
              }
            }
          }
        }
      },
      "det_chain": {
        "chain_name": "DestinationChain",
        "events": {
          "UnlockEvent1": {
            "0": {
              "func_name": "unlock",
              "file_name": "LockProxy.sol",
              "key_ops": [
                "require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\")",
                "require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\")",
                "require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\")",
                "require(args.toAddress.length != 0, \"toAddress cannot be empty\")",
                "require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\")"
              ],
              "child": {
                "0": {
                  "func_name": "_transferFromContract",
                  "file_name": "LockProxy.sol",
                  "key_ops": [
                    "address(uint160(toAddress)).transfer(amount)",
                    "require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\")"
                  ],
                  "child": {
                    "0": {
                      "func_name": "_transferERC20FromContract",
                      "file_name": "LockProxy.sol",
                      "key_ops": [
                        "erc20Token.safeTransfer(toAddress, amount)"
                      ],
                      "child": {}
                    }
                  }
                },
                "1": {
                  "func_name": "_deserializeTxArgs",
                  "file_name": "LockProxy.sol",
                  "key_ops": [],
                  "child": {}
                }
              }
            }
          }
        }
      }
    }
  },
  "cag": []
}
{
    "src_chain": {
        "verifysignature0": [
            {
                "verify_signatures": "fn verify_signatures(\n ctx: &ExecutionContext,\n accs: &mut VerifySignatures,\n data: VerifySignaturesData,\n) -> Result<()> {\n accs.guardian_set\n .verify_derivation(ctx.program_id, &(&*accs).into())?;\n let sig_infos: Vec<SigInfo> = data\n .signers\n .iter()\n .enumerate()\n .filter_map(|(i, p)| {\n if *p == -1 {\n return None;\n }\n return Some(SigInfo {\n sig_index: *p as u8,\n signer_index: i as u8,\n });\n })\n .collect();\n let current_instruction = solana_program::sysvar::instructions::load_current_index(\n &accs.instruction_acc.try_borrow_mut_data()?,\n );\n if current_instruction == 0 {\n return Err(InstructionAtWrongIndex.into());\n }\n \n let secp_ix_index = (current_instruction - 1) as u8;\n let secp_ix = solana_program::sysvar::instructions::load_instruction_at(\n secp_ix_index as usize,\n &accs.instruction_acc.try_borrow_mut_data()?,\n )\n .map_err(|_| ProgramError::InvalidAccountData)?;\n \n if secp_ix.program_id != solana_program::secp256k1_program::id() {\n return Err(InvalidSecpInstruction.into());\n }\n let secp_data_len = secp_ix.data.len();\n if secp_data_len < 2 {\n return Err(InvalidSecpInstruction.into());\n }\n let sig_len = secp_ix.data[0];\n let mut index = 1;\n let mut secp_ixs: Vec<SecpInstructionPart> = Vec::with_capacity(sig_len as usize);\n for i in 0..sig_len {\n let _sig_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]) as usize;\n index += 2;\n let sig_ix = secp_ix.data[index];\n index += 1;\n let address_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]) as usize;\n index += 2;\n let address_ix = secp_ix.data[index];\n index += 1;\n let msg_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]);\n index += 2;\n let msg_size = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]);\n index += 2;\n let msg_ix = secp_ix.data[index];\n index += 1;\n if address_ix != secp_ix_index || msg_ix != secp_ix_index || sig_ix != secp_ix_index {\n return Err(InvalidSecpInstruction.into());\n }\n let address: &[u8] = &secp_ix.data[address_offset..address_offset + 20];\n \n if i > 0 {\n if msg_offset != secp_ixs[0].msg_offset || msg_size != secp_ixs[0].msg_size {\n return Err(InvalidSecpInstruction.into());\n }\n }\n secp_ixs.push(SecpInstructionPart {\n address,\n msg_offset,\n msg_size,\n });\n }\n if sig_infos.len() != secp_ixs.len() {\n return Err(ProgramError::InvalidArgument.into());\n }\n \n if secp_ixs[0].msg_size != 32 {\n return Err(ProgramError::InvalidArgument.into());\n }\n \n let message = &secp_ix.data\n [secp_ixs[0].msg_offset as usize..(secp_ixs[0].msg_offset + secp_ixs[0].msg_size) as usize];\n \n let mut msg_hash: [u8; 32] = [0u8; 32];\n msg_hash.copy_from_slice(message);\n if !accs.signature_set.is_initialized() {\n accs.signature_set.signatures = vec![false; accs.guardian_set.keys.len()];\n accs.signature_set.guardian_set_index = accs.guardian_set.index;\n accs.signature_set.hash = msg_hash;\n let size = accs.signature_set.size();\n let ix = solana_program::system_instruction::create_account(\n accs.payer.key,\n accs.signature_set.info().key,\n Exempt.amount(size),\n size as u64,\n ctx.program_id,\n );\n solana_program::program::invoke(&ix, ctx.accounts)?;\n } else {\n \n if accs.signature_set.guardian_set_index != accs.guardian_set.index {\n return Err(GuardianSetMismatch.into());\n }\n if accs.signature_set.hash != msg_hash {\n return Err(InvalidHash.into());\n }\n }\n \n for s in sig_infos {\n if s.signer_index > accs.guardian_set.num_guardians() {\n return Err(ProgramError::InvalidArgument.into());\n }\n if s.sig_index + 1 > sig_len {\n return Err(ProgramError::InvalidArgument.into());\n }\n let key = accs.guardian_set.keys[s.signer_index as usize];\n \n if key != secp_ixs[s.sig_index as usize].address {\n return Err(ProgramError::InvalidArgument.into());\n }\n \n accs.signature_set.signatures[s.signer_index as usize] = true;\n }\n Ok(())\n}"
            }
        ],
        "MintWETH1": [
            {
                "post_vaa": "fn post_vaa(ctx: &ExecutionContext, accs: &mut PostVAA, vaa: PostVAAData) -> Result<()> {\n let msg_derivation = PostedVAADerivationData {\n payload_hash: hash_vaa(&vaa).to_vec(),\n };\n accs.message\n .verify_derivation(ctx.program_id, &msg_derivation)?;\n \n if !accs.message.is_initialized() {\n accs.message.nonce = vaa.nonce;\n accs.message.emitter_chain = vaa.emitter_chain;\n accs.message.emitter_address = vaa.emitter_address;\n accs.message.sequence = vaa.sequence;\n accs.message.payload = vaa.payload;\n accs.message.consistency_level = vaa.consistency_level;\n accs.message\n .create(&msg_derivation, ctx, accs.payer.key, Exempt)?;\n }\n \n accs.message.vaa_version = vaa.version;\n accs.message.vaa_time = vaa.timestamp;\n accs.message.vaa_signature_account = *accs.signature_set.info().key;\n Ok(())\n}"
            },
            {
                "complete_wrapped": "fn complete_wrapped(\n ctx: &ExecutionContext,\n accs: &mut CompleteWrapped,\n _data: CompleteWrappedData,\n) -> Result<()> {\n \n let derivation_data: EndpointDerivationData = (&*accs).into();\n accs.chain_registration\n .verify_derivation(ctx.program_id, &derivation_data)?;\n \n accs.wrapped_meta.verify_derivation(\n ctx.program_id,\n &WrappedMetaDerivationData {\n mint_key: *accs.mint.info().key,\n },\n )?;\n if accs.wrapped_meta.token_address != accs.vaa.token_address\n || accs.wrapped_meta.chain != accs.vaa.token_chain\n {\n return Err(InvalidMint.into());\n }\n \n if *accs.mint.info().key != accs.to.mint {\n return Err(InvalidMint.into());\n }\n if *accs.mint.info().key != accs.to_fees.mint {\n return Err(InvalidMint.into());\n }\n \n if accs.vaa.to_chain != CHAIN_ID_SOLANA {\n return Err(InvalidChain.into());\n }\n if accs.vaa.to != accs.to.info().key.to_bytes() {\n return Err(InvalidRecipient.into());\n }\n if INVALID_VAAS.contains(&&*accs.vaa.info().key.to_string()) {\n return Err(InvalidVAA.into());\n }\n claim::consume(ctx, accs.payer.key, &mut accs.claim, &accs.vaa)?;\n let token_amount: u64 = accs\n .vaa\n .amount\n .as_u64()\n .checked_sub(accs.vaa.fee.as_u64())\n .ok_or(SolitaireError::InsufficientFunds)?;\n \n let mint_ix = spl_token::instruction::mint_to(\n &spl_token::id(),\n accs.mint.info().key,\n accs.to.info().key,\n accs.mint_authority.key,\n &[],\n token_amount,\n )?;\n invoke_seeded(&mint_ix, ctx, &accs.mint_authority, None)?;\n \n let mint_ix = spl_token::instruction::mint_to(\n &spl_token::id(),\n accs.mint.info().key,\n accs.to_fees.info().key,\n accs.mint_authority.key,\n &[],\n accs.vaa.fee.as_u64(),\n )?;\n invoke_seeded(&mint_ix, ctx, &accs.mint_authority, None)?;\n Ok(())\n}"
            }
        ],
        "transferWETH2": [
            {
                "transfer_wrapped": "fn transfer_wrapped(\n ctx: &ExecutionContext,\n accs: &mut TransferWrapped,\n data: TransferWrappedData,\n) -> Result<()> {\n \n if data.target_chain == CHAIN_ID_SOLANA {\n return Err(InvalidChain.into());\n }\n let derivation_data: WrappedMetaDerivationData = (&*accs).into();\n verify_and_execute_wrapped_transfers(\n ctx,\n &derivation_data,\n &accs.payer,\n &accs.from,\n &accs.from_owner,\n &accs.mint,\n &accs.wrapped_meta,\n &accs.authority_signer,\n &accs.bridge,\n &accs.fee_collector,\n data.amount,\n data.fee,\n )?;\n \n let payload = PayloadTransfer {\n amount: U256::from(data.amount),\n token_address: accs.wrapped_meta.token_address,\n token_chain: accs.wrapped_meta.chain,\n to: data.target_address,\n to_chain: data.target_chain,\n fee: U256::from(data.fee),\n };\n let params = (\n bridge::instruction::Instruction::PostMessage,\n PostMessageData {\n nonce: data.nonce,\n payload: payload.try_to_vec()?,\n consistency_level: ConsistencyLevel::Finalized,\n },\n );\n let ix = Instruction::new_with_bytes(\n accs.config.wormhole_bridge,\n params.try_to_vec()?.as_slice(),\n vec![\n AccountMeta::new(*accs.bridge.info().key, false),\n AccountMeta::new(*accs.message.key, true),\n AccountMeta::new_readonly(*accs.emitter.key, true),\n AccountMeta::new(*accs.sequence.key, false),\n AccountMeta::new(*accs.payer.key, true),\n AccountMeta::new(*accs.fee_collector.key, false),\n AccountMeta::new_readonly(*accs.clock.info().key, false),\n AccountMeta::new_readonly(solana_program::system_program::id(), false),\n AccountMeta::new_readonly(solana_program::sysvar::rent::ID, false),\n ],\n );\n invoke_seeded(&ix, ctx, &accs.emitter, None)?;\n Ok(())\n}"
            },
            {
                "verify_and_execute_wrapped_transfers": "fn verify_and_execute_wrapped_transfers(\n ctx: &ExecutionContext,\n derivation_data: &WrappedMetaDerivationData,\n payer: &Mut<Signer<AccountInfo>>,\n from: &Mut<Data<SplAccount, { AccountState::Initialized }>>,\n from_owner: &MaybeMut<Signer<Info>>,\n mint: &Mut<WrappedMint<{ AccountState::Initialized }>>,\n wrapped_meta: &WrappedTokenMeta<{ AccountState::Initialized }>,\n authority_signer: &AuthoritySigner,\n bridge: &Mut<CoreBridge<{ AccountState::Initialized }>>,\n fee_collector: &Mut<Info>,\n amount: u64,\n fee: u64,\n) -> Result<()> {\n \n if &from.owner != from_owner.key {\n return Err(WrongAccountOwner.into());\n }\n \n if mint.info().key != &from.mint {\n return Err(TokenBridgeError::InvalidMint.into());\n }\n \n if fee > amount {\n return Err(InvalidFee.into());\n }\n \n wrapped_meta.verify_derivation(ctx.program_id, derivation_data)?;\n \n let burn_ix = spl_token::instruction::burn(\n &spl_token::id(),\n from.info().key,\n mint.info().key,\n authority_signer.key,\n &[],\n amount,\n )?;\n invoke_seeded(&burn_ix, ctx, authority_signer, None)?;\n \n let transfer_ix = solana_program::system_instruction::transfer(\n payer.key,\n fee_collector.key,\n bridge.config.fee,\n );\n invoke(&transfer_ix, ctx.accounts)?;\n Ok(())\n}"
            }
        ]
    },
    "rel_chain": {
        "signvaa": [
            {
                "AddSignature": "func (v *VAA) AddSignature(key *ecdsa.PrivateKey, index uint8) {\n\tfunc Bytes(...) {...}\nfunc SigningDigest(...) {...}\nsig, err := crypto.Sign(v.SigningDigest().Bytes(), key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tsigData := [65]byte{}\n\tcopy(sigData[:], sig)\n\tv.Signatures = append(v.Signatures, &Signature{\n\t\tIndex: index,\n\t\tSignature: sigData,\n\t})\n}"
            }
        ]
    },
    "det_chain": {
        "completeTransfer2": [
            {
                "_completeTransfer": "function _completeTransfer(bytes memory encodedVm, bool unwrapWETH) internal returns (bytes memory) {\n (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n require(valid, reason);\n function verifyBridgeVM(...) {...}\nrequire(verifyBridgeVM(vm), \"invalid emitter\");\n BridgeStructs.Transfer memory transfer = _parseTransferCommon(vm.payload);\n \n address transferRecipient = _truncateAddress(transfer.to);\n if (transfer.payloadID == 3) {\n require(msg.sender == transferRecipient, \"invalid sender\");\n }\n require(!isTransferCompleted(vm.hash), \"transfer already completed\");\n setTransferCompleted(vm.hash);\n \n emit TransferRedeemed(vm.emitterChainId, vm.emitterAddress, vm.sequence);\n require(transfer.toChain == chainId(), \"invalid target chain\");\n IERC20 transferToken;\n if (transfer.tokenChain == chainId()) {\n transferToken = IERC20(_truncateAddress(transfer.tokenAddress));\n \n bridgedIn(address(transferToken), transfer.amount);\n } else {\n address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\n require(wrapped != address(0), \"no wrapper for this token created yet\");\n transferToken = IERC20(wrapped);\n }\n require(unwrapWETH == false || address(transferToken) == address(WETH()), \"invalid token, can only unwrap WETH\");\n \n (,bytes memory queriedDecimals) = address(transferToken).staticcall(abi.encodeWithSignature(\"decimals()\"));\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n \n uint256 nativeAmount = deNormalizeAmount(transfer.amount, decimals);\n uint256 nativeFee = deNormalizeAmount(transfer.fee, decimals);\n \n if (nativeFee > 0 && transferRecipient != msg.sender) {\n require(nativeFee <= nativeAmount, \"fee higher than transferred amount\");\n if (unwrapWETH) {\n WETH().withdraw(nativeFee);\n payable(msg.sender).transfer(nativeFee);\n } else {\n if (transfer.tokenChain != chainId()) {\n \n TokenImplementation(address(transferToken)).mint(msg.sender, nativeFee);\n } else {\n SafeERC20.safeTransfer(transferToken, msg.sender, nativeFee);\n }\n }\n } else {\n \n nativeFee = 0;\n }\n \n uint transferAmount = nativeAmount - nativeFee;\n if (unwrapWETH) {\n WETH().withdraw(transferAmount);\n payable(transferRecipient).transfer(transferAmount);\n } else {\n if (transfer.tokenChain != chainId()) {\n \n TokenImplementation(address(transferToken)).mint(transferRecipient, transferAmount);\n } else {\n SafeERC20.safeTransfer(transferToken, transferRecipient, transferAmount);\n }\n }\n return vm.payload;\n }"
            }
        ]
    }
}
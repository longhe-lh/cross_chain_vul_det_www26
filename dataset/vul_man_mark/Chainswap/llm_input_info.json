{
    "src_chain": {
        "Send1": [
            {
                "_sendFrom": "function _sendFrom(address from, uint volume) virtual override internal {\n function safeTransferFrom(...) {...}\nIERC20(token).safeTransferFrom(from, address(this), volume);\n }"
            }
        ]
    },
    "rel_chain": {},
    "det_chain": {
        "Receive1": [
            {
                "receive": "function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n _chargeFee();\n require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n uint N = signatures.length;\n function getConfig(...) {...}\nrequire(N >= MappingTokenFactory(factory).getConfig(_minSignatures_), 'too few signatures');\n for(uint i=0; i<N; i++) {\n for(uint j=0; j<i; j++)\n require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _DOMAIN_SEPARATOR, structHash));\n address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n require(signatory != address(0), \"invalid signature\");\n require(signatory == signatures[i].signatory, \"unauthorized\");\n _decreaseAuthQuota(signatures[i].signatory, volume);\n emit Authorize(fromChainId, to, nonce, volume, signatory);\n }\n received[fromChainId][to][nonce] = volume;\n _receive(to, volume);\n emit Receive(fromChainId, to, nonce, volume);\n }"
            }
        ]
    }
}
{
    "src_chain": {
        "swap2": [
            {
                "swap": "function swap(\n Swap storage self,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 dx,\n uint256 minDy\n ) external returns (uint256) {\n {\n \n IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n require(\n dx <= tokenFrom.balanceOf(msg.sender),\n \"Cannot swap more than you own\"\n );\n \n uint256 beforeBalance = tokenFrom.balanceOf(address(this)); \n tokenFrom.safeTransferFrom(msg.sender, address(this), dx); \n \n dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance); \n }\n uint256 dy; \n uint256 dyFee; \n uint256[] memory balances = self.balances;\n \n (dy, dyFee) = _calculateSwap(\n self,\n tokenIndexFrom,\n tokenIndexTo,\n dx,\n balances\n );\n require(dy >= minDy, \"Swap didn't result in min tokens\"); \n uint256 dyAdminFee =\n dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n self.tokenPrecisionMultipliers[tokenIndexTo]\n ); \n \n self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n \n self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(\n dyAdminFee\n );\n \n self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n \n emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n return dy;\n }"
            },
            {
                "_calculateSwap": "function _calculateSwap(\n Swap storage self,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 dx,\n uint256[] memory balances\n ) internal view returns (uint256 dy, uint256 dyFee) {\n uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n uint256[] memory xp = _xp(balances, multipliers);\n require(\n tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\n \"Token index out of range\"\n );\n uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\n uint256 y =\n getY(getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\n dy = xp[tokenIndexTo].sub(y).sub(1);\n dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\n }"
            },
            {
                "_xp": "function _xp(\n uint256[] memory balances,\n uint256[] memory precisionMultipliers\n ) internal pure returns (uint256[] memory) {\n uint256 numTokens = balances.length;\n require(\n numTokens == precisionMultipliers.length,\n \"Balances must match multipliers\"\n );\n uint256[] memory xp = new uint256[](numTokens);\n for (uint256 i = 0; i < numTokens; i++) {\n xp[i] = balances[i].mul(precisionMultipliers[i]);\n }\n return xp;\n }"
            }
        ],
        "swap3": [
            {
                "removeLiquidityOneToken": "function removeLiquidityOneToken(\n Swap storage self,\n uint256 tokenAmount,\n uint8 tokenIndex,\n uint256 minAmount\n ) external returns (uint256) {\n LPToken lpToken = self.lpToken;\n IERC20[] memory pooledTokens = self.pooledTokens;\n require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n require(tokenIndex < pooledTokens.length, \"Token not found\");\n uint256 totalSupply = lpToken.totalSupply();\n (uint256 dy, uint256 dyFee) =\n _calculateWithdrawOneToken(\n self,\n msg.sender,\n tokenAmount,\n tokenIndex,\n totalSupply\n );\n require(dy >= minAmount, \"dy < minAmount\");\n self.balances[tokenIndex] = self.balances[tokenIndex].sub(\n dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\n );\n lpToken.burnFrom(msg.sender, tokenAmount);\n pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n emit RemoveLiquidityOne(\n msg.sender,\n tokenAmount,\n totalSupply,\n tokenIndex,\n dy\n );\n return dy;\n }"
            }
        ],
        "swap4": [
            {
                "swapUnderlying": "function swapUnderlying(\n SwapUtils.Swap storage self,\n MetaSwap storage metaSwapStorage,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 dx,\n uint256 minDy\n ) external returns (uint256) {\n SwapUnderlyingInfo memory v =\n SwapUnderlyingInfo(\n 0,\n 0,\n 0,\n 0,\n 0,\n self.balances,\n metaSwapStorage.baseTokens,\n IERC20(address(0)),\n IERC20(address(0)),\n _updateBaseVirtualPrice(metaSwapStorage)\n );\n uint8 baseLPTokenIndex = uint8(v.oldBalances.length) - 1;\n {\n uint8 maxRange = baseLPTokenIndex + uint8(v.baseTokens.length);\n require(\n tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\n \"Token index out of range\"\n );\n }\n ISwap baseSwap = metaSwapStorage.baseSwap;\n \n if (tokenIndexFrom < baseLPTokenIndex) {\n v.tokenFrom = self.pooledTokens[tokenIndexFrom];\n v.metaIndexFrom = tokenIndexFrom;\n } else {\n v.tokenFrom = v.baseTokens[tokenIndexFrom - baseLPTokenIndex];\n v.metaIndexFrom = baseLPTokenIndex;\n }\n \n if (tokenIndexTo < baseLPTokenIndex) {\n v.tokenTo = self.pooledTokens[tokenIndexTo];\n v.metaIndexTo = tokenIndexTo;\n } else {\n v.tokenTo = v.baseTokens[tokenIndexTo - baseLPTokenIndex];\n v.metaIndexTo = baseLPTokenIndex;\n }\n v.dx = v.tokenFrom.balanceOf(address(this));\n v.tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n v.dx = v.tokenFrom.balanceOf(address(this)).sub(v.dx); \n if (\n tokenIndexFrom < baseLPTokenIndex || tokenIndexTo < baseLPTokenIndex\n ) {\n uint256[] memory xp = _xp(self, v.oldBalances, v.baseVirtualPrice);\n if (tokenIndexFrom < baseLPTokenIndex) {\n v.x =\n xp[tokenIndexFrom] +\n dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]);\n } else {\n \n uint256[] memory baseAmounts =\n new uint256[](v.baseTokens.length);\n baseAmounts[tokenIndexFrom - baseLPTokenIndex] = v.dx;\n IERC20 baseLPToken = self.pooledTokens[baseLPTokenIndex];\n v.x = baseLPToken.balanceOf(address(this));\n \n baseSwap.addLiquidity(baseAmounts, 0, block.timestamp);\n \n v.dx = baseLPToken.balanceOf(address(this)).sub(v.x);\n v.x = v\n .dx\n .mul(v.baseVirtualPrice)\n .div(BASE_VIRTUAL_PRICE_PRECISION)\n .add(xp[baseLPTokenIndex]);\n }\n uint256 dyFee;\n {\n uint256 y =\n getY(\n getAPrecise(self),\n v.metaIndexFrom,\n v.metaIndexTo,\n v.x,\n xp\n );\n v.dy = xp[v.metaIndexTo].sub(y).sub(1);\n dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n v.dy = v.dy.sub(dyFee).div(\n self.tokenPrecisionMultipliers[v.metaIndexTo]\n );\n }\n if (tokenIndexTo >= baseLPTokenIndex) {\n v.dy = v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(\n v.baseVirtualPrice\n );\n }\n {\n uint256 dyAdminFee =\n dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);\n dyAdminFee = dyAdminFee.div(\n self.tokenPrecisionMultipliers[v.metaIndexTo]\n );\n self.balances[v.metaIndexFrom] = v.oldBalances[v.metaIndexFrom]\n .add(v.dx);\n self.balances[v.metaIndexTo] = v.oldBalances[v.metaIndexTo]\n .sub(v.dy)\n .sub(dyAdminFee);\n }\n if (tokenIndexTo >= baseLPTokenIndex) {\n \n \n uint256 oldBalance = v.tokenTo.balanceOf(address(this));\n baseSwap.removeLiquidityOneToken(\n v.dy,\n tokenIndexTo - baseLPTokenIndex,\n 0,\n block.timestamp\n );\n v.dy = v.tokenTo.balanceOf(address(this)) - oldBalance;\n }\n require(v.dy >= minDy, \"Swap didn't result in min tokens\");\n } else {\n \n v.dy = v.tokenTo.balanceOf(address(this));\n baseSwap.swap(\n tokenIndexFrom - baseLPTokenIndex,\n tokenIndexTo - baseLPTokenIndex,\n v.dx,\n minDy,\n block.timestamp\n );\n v.dy = v.tokenTo.balanceOf(address(this)).sub(v.dy);\n }\n v.tokenTo.safeTransfer(msg.sender, v.dy);\n emit TokenSwapUnderlying(\n msg.sender,\n dx,\n v.dy,\n tokenIndexFrom,\n tokenIndexTo\n );\n return v.dy;\n }"
            },
            {
                "_xp": "function _xp(\n uint256[] memory balances,\n uint256[] memory precisionMultipliers,\n uint256 baseVirtualPrice\n ) internal pure returns (uint256[] memory) {\n uint256 numTokens = balances.length;\n require(\n numTokens == precisionMultipliers.length,\n \"Balances must match multipliers\"\n );\n uint256[] memory xp = new uint256[](numTokens);\n for (uint256 i = 0; i < numTokens; i++) {\n xp[i] = balances[i].mul(precisionMultipliers[i]);\n }\n uint256 baseLPTokenIndex = numTokens - 1;\n xp[baseLPTokenIndex] = xp[baseLPTokenIndex].mul(baseVirtualPrice).div(\n BASE_VIRTUAL_PRICE_PRECISION\n );\n return xp;\n }"
            }
        ],
        "CrossOutFunds1": [
            {
                "crossOut": "function crossOut(string memory to, uint256 amount, address ERC20) public payable returns (bool) {\n address from = msg.sender;\n require(amount > 0, \"ERROR: Zero amount\");\n if (ERC20 != address(0)) {\n require(msg.value == 0, \"ERC20: Does not accept Ethereum Coin\");\n function isContract(...) {...}\nfunction safeTransferFrom(...) {...}\nrequire(ERC20.isContract(), \"The address is not a contract address\");\n IERC20 token = IERC20(ERC20);\n uint256 allowance = token.allowance(from, address(this));\n require(allowance >= amount, \"No enough amount for authorization\");\n uint256 fromBalance = token.balanceOf(from);\n require(fromBalance >= amount, \"No enough balance of the token\");\n token.safeTransferFrom(from, address(this), amount);\n if (isMinterERC20(ERC20)) {\n \n IERC20Minter minterToken = IERC20Minter(ERC20);\n minterToken.burn(amount);\n }\n } else {\n require(msg.value == amount, \"Inconsistency Ethereum amount\");\n }\n emit CrossOutFunds(from, to, amount, ERC20);\n return true;\n }"
            }
        ]
    },
    "rel_chain": {
        "relay": [
            {
                "heightNotice": "\n \n public static void heightNotice(int chainId, long height, String blockHeader) {\n \n if (!ModuleHelper.isSupportCrossChain()) {\n return;\n }\n NulsLogger logger = ContextManager.getContext(chainId).getLogger(); \n try {\n Map<String, Object> params = new HashMap<>(4);\n\n params.put(Constants.CHAIN_ID, chainId);\n params.put(\"height\", height);\n params.put(\"blockHeader\", blockHeader);\n NerveCoreResponseMessageProcessor.requestAndResponse(ModuleE.CC.abbr, \"newBlockHeight\", params);\n } catch (Exception e) {\n logger.error(\"\", e);\n }\n }"
            },
            {
                "sendMainAssetWithdraw": "\n protected String sendMainAssetWithdraw(String txKey, String toAddress, String value, int signCount) throws Exception {\n BigInteger bValue = new BigDecimal(value).multiply(BigDecimal.TEN.pow(18)).toBigInteger();\n String vHash = HtgUtil.encoderWithdraw(htgContext, txKey, toAddress, bValue, false, HtgConstant.ZERO_ADDRESS, VERSION);\n String signData = this.ethSign(vHash, signCount);\n \n function Function(...) {...}\nFunction function = HtgUtil.getCreateOrSignWithdrawFunction(txKey, toAddress, bValue, false, HtgConstant.ZERO_ADDRESS, signData);\nString signData = this.ethSign(vHash, signCount);\nString vHash = HtgUtil.encoderWithdraw(htgContext, txKey, toAddress, bValue, false, HtgConstant.ZERO_ADDRESS, VERSION);\nfunction ethSign(...) {...}\nfunction sendTx(...) {...}\nFunction function = HtgUtil.getCreateOrSignWithdrawFunction(txKey, toAddress, bValue, false, HtgConstant.ZERO_ADDRESS, signData);\n return this.sendTx(address, priKey, function, HeterogeneousChainTxType.WITHDRAW);\n }"
            }
        ]
    },
    "det_chain": {
        "Transfer1": [
            {
                "_mint": "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n function add(...) {...}\n_totalSupply = _totalSupply.add(amount);\n _balances[account] = _balances[account].add(amount);\n emit Transfer(address(0), account, amount);\n }"
            }
        ]
    }
}
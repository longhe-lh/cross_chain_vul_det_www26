{
    "src_chain": {
        "transferOutSuccess1": [
            {
                "transferOut": "function transferOut(address contractAddr, address recipient, uint256 amount, uint64 expireTime) external override onlyInit payable returns (bool) {\n require(expireTime>=block.timestamp + 120, \"expireTime must be two minutes later\");\n require(msg.value%TEN_DECIMALS==0, \"invalid received BNB amount: precision loss in amount conversion\");\n bytes32 bep2TokenSymbol;\n uint256 convertedAmount;\n uint256 rewardForRelayer;\n if (contractAddr==address(0x0)) {\n require(msg.value>=amount.add(relayFee), \"received BNB amount should be no less than the sum of transferOut BNB amount and minimum relayFee\");\n require(amount%TEN_DECIMALS==0, \"invalid transfer amount: precision loss in amount conversion\");\n rewardForRelayer=msg.value.sub(amount);\n convertedAmount = amount.div(TEN_DECIMALS); \n bep2TokenSymbol=BEP2_TOKEN_SYMBOL_FOR_BNB;\n } else {\n bep2TokenSymbol = contractAddrToBEP2Symbol[contractAddr];\n require(bep2TokenSymbol!=bytes32(0x00), \"the contract has not been bound to any bep2 token\");\n require(msg.value>=relayFee, \"received BNB amount should be no less than the minimum relayFee\");\n rewardForRelayer=msg.value;\n uint256 bep20TokenDecimals=bep20ContractDecimals[contractAddr];\n require(bep20TokenDecimals<=BEP2_TOKEN_DECIMALS || (bep20TokenDecimals>BEP2_TOKEN_DECIMALS && amount.mod(10**(bep20TokenDecimals-BEP2_TOKEN_DECIMALS))==0), \"invalid transfer amount: precision loss in amount conversion\");\n convertedAmount = convertToBep2Amount(amount, bep20TokenDecimals);\n if (isMiniBEP2Token(bep2TokenSymbol)) {\n require(convertedAmount >= 1e8 , \"For miniToken, the transfer amount must not be less than 1\");\n }\n require(bep20TokenDecimals>=BEP2_TOKEN_DECIMALS || (bep20TokenDecimals<BEP2_TOKEN_DECIMALS && convertedAmount>amount), \"amount is too large, uint256 overflow\");\n require(convertedAmount<=MAX_BEP2_TOTAL_SUPPLY, \"amount is too large, exceed maximum bep2 token amount\");\n require(IBEP20(contractAddr).transferFrom(msg.sender, address(this), amount));\n }\n TransferOutSynPackage memory transOutSynPkg = TransferOutSynPackage({\n bep2TokenSymbol: bep2TokenSymbol,\n contractAddr: contractAddr,\n amounts: new uint256[](1),\n recipients: new address[](1),\n refundAddrs: new address[](1),\n expireTime: expireTime\n });\n transOutSynPkg.amounts[0]=convertedAmount;\n transOutSynPkg.recipients[0]=recipient;\n transOutSynPkg.refundAddrs[0]=msg.sender;\n function encodeTransferOutSynPackage(...) {...}\nICrossChain(CROSS_CHAIN_CONTRACT_ADDR).sendSynPackage(TRANSFER_OUT_CHANNELID, encodeTransferOutSynPackage(transOutSynPkg), rewardForRelayer.div(TEN_DECIMALS));\n emit transferOutSuccess(contractAddr, msg.sender, amount, rewardForRelayer);\n return true;\n }"
            }
        ]
    },
    "rel_chain": {
        "receivedPackage": [
            {
                "handlePackage": "function handlePackage(\n bytes calldata payload,\n bytes calldata proof,\n uint64 height,\n uint64 packageSequence,\n uint8 channelId\n )\n external\n onlyInit\n onlyRelayer\n sequenceInOrder(packageSequence, channelId)\n blockSynced(height)\n channelSupported(channelId)\n headerInOrder(height, channelId)\n whenNotSuspended\n {\n bytes memory payloadLocal = payload; \n bytes memory proofLocal = proof; \n require(\n MerkleProof.validateMerkleProof(\n ILightClient(LIGHT_CLIENT_ADDR).getAppHash(height),\n STORE_NAME,\n generateKey(packageSequence, channelId),\n payloadLocal,\n proofLocal\n ),\n \"invalid merkle proof\"\n );\n address payable headerRelayer = ILightClient(LIGHT_CLIENT_ADDR).getSubmitter(height);\n uint64 sequenceLocal = packageSequence; \n uint8 channelIdLocal = channelId; \n (bool success, uint8 packageType, uint256 relayFee, bytes memory msgBytes) = decodePayloadHeader(payloadLocal);\n if (!success) {\n emit unsupportedPackage(sequenceLocal, channelIdLocal, payloadLocal);\n return;\n }\n emit receivedPackage(packageType, sequenceLocal, channelIdLocal);\n if (packageType == SYN_PACKAGE) {\n address handlerContract = channelHandlerContractMap[channelIdLocal];\n try IApplication(handlerContract).handleSynPackage(channelIdLocal, msgBytes) returns (\n bytes memory responsePayload\n ) {\n if (responsePayload.length != 0) {\n sendPackage(\n channelSendSequenceMap[channelIdLocal],\n channelIdLocal,\n encodePayload(ACK_PACKAGE, 0, responsePayload)\n );\n channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n }\n } catch Error(string memory reason) {\n sendPackage(\n channelSendSequenceMap[channelIdLocal], channelIdLocal, encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n );\n channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n emit unexpectedRevertInPackageHandler(handlerContract, reason);\n } catch (bytes memory lowLevelData) {\n sendPackage(\n channelSendSequenceMap[channelIdLocal], channelIdLocal, encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n );\n channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n emit unexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n }\n } else if (packageType == ACK_PACKAGE) {\n address handlerContract = channelHandlerContractMap[channelIdLocal];\n try IApplication(handlerContract).handleAckPackage(channelIdLocal, msgBytes) { }\n catch Error(string memory reason) {\n emit unexpectedRevertInPackageHandler(handlerContract, reason);\n } catch (bytes memory lowLevelData) {\n emit unexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n }\n } else if (packageType == FAIL_ACK_PACKAGE) {\n address handlerContract = channelHandlerContractMap[channelIdLocal];\n try IApplication(handlerContract).handleFailAckPackage(channelIdLocal, msgBytes) { }\n catch Error(string memory reason) {\n emit unexpectedRevertInPackageHandler(handlerContract, reason);\n } catch (bytes memory lowLevelData) {\n emit unexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n }\n }\n IRelayerIncentivize(INCENTIVIZE_ADDR).addReward(\n headerRelayer,\n msg.sender,\n relayFee,\n isRelayRewardFromSystemReward[channelIdLocal] || packageType != SYN_PACKAGE\n );\n }"
            },
            {
                "validateMerkleProof": "function validateMerkleProof(bytes32 appHash, string memory storeName, bytes memory key, bytes memory value, bytes memory proof)\n internal view returns (bool) {\n if (appHash == bytes32(0)) {\n return false;\n }\n \n \n bytes memory input = new bytes(128+key.length+value.length+proof.length);\n uint256 ptr = Memory.dataPtr(input);\n bytes memory storeNameBytes = bytes(storeName);\n \n assembly {\n mstore(ptr, mload(add(storeNameBytes, 32)))\n }\n uint256 src;\n uint256 length;\n \n ptr += 32;\n (src, length) = Memory.fromBytes(key);\n \n assembly {\n mstore(ptr, length)\n }\n ptr += 32;\n Memory.copy(src, ptr, length);\n \n ptr += length;\n (src, length) = Memory.fromBytes(value);\n \n assembly {\n mstore(ptr, length)\n }\n ptr += 32;\n Memory.copy(src, ptr, length);\n \n ptr += length;\n \n assembly {\n mstore(ptr, appHash)\n }\n \n ptr += 32;\n (src,length) = Memory.fromBytes(proof);\n Memory.copy(src, ptr, length);\n length = input.length+32;\n uint256[1] memory result;\n \n assembly {\n \n \n if iszero(staticcall(not(0), 0x65, input, length, result, 0x20)) {}\n }\n return result[0] == 0x01;\n }"
            },
            {
                "Validate": "func (h *Header) Validate(chainID string) error {\n\tif err := h.SignedHeader.ValidateBasic(chainID); err != nil {\n\t\treturn err\n\t}\n\tif h.ValidatorSet == nil {\n\t\treturn fmt.Errorf(\"invalid header: validator set is nil\")\n\t}\n\tif h.NextValidatorSet == nil {\n\t\treturn fmt.Errorf(\"invalid header: next validator set is nil\")\n\t}\n\tif !bytes.Equal(h.ValidatorsHash, h.ValidatorSet.Hash()) {\n\t\treturn fmt.Errorf(\"invalid header: validator set does not match hash\")\n\t}\n\tif !bytes.Equal(h.NextValidatorsHash, h.NextValidatorSet.Hash()) {\n\t\treturn fmt.Errorf(\"invalid header: next validator set does not match hash\")\n\t}\n\treturn nil\n}"
            },
            {
                "DefaultProofRuntime": "func DefaultProofRuntime() (prt *merkle.ProofRuntime) {\n\tprt = merkle.NewProofRuntime()\n\tprt.RegisterOpDecoder(merkle.ProofOpSimpleValue, merkle.SimpleValueOpDecoder)\n\tprt.RegisterOpDecoder(iavl.ProofOpIAVLValue, iavl.IAVLValueOpDecoder)\n\tprt.RegisterOpDecoder(iavl.ProofOpIAVLAbsence, iavl.IAVLAbsenceOpDecoder)\n\tprt.RegisterOpDecoder(ProofOpMultiStore, MultiStoreProofOpDecoder)\n\treturn\n}"
            },
            {
                "Hash": "func (pin ProofInnerNode) Hash(childHash []byte) ([]byte, error) {\n\thasher := sha256.New()\n\tbuf := bufPool.Get().(*bytes.Buffer)\n\tbuf.Reset()\n\tdefer bufPool.Put(buf)\n\terr := encoding.EncodeVarint(buf, int64(pin.Height))\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Size)\n\t}\n\tif err == nil {\n\t\terr = encoding.EncodeVarint(buf, pin.Version)\n\t}\n\tif len(pin.Left) == 0 {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Right)\n\t\t}\n\t} else {\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, pin.Left)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = encoding.EncodeBytes(buf, childHash)\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to hash ProofInnerNode: %v\", err)\n\t}\n\t_, err = hasher.Write(buf.Bytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn hasher.Sum(nil), nil\n}"
            }
        ]
    },
    "det_chain": {
        "transferInSuccess1": [
            {
                "doTransferIn": "function doTransferIn(TransferInSynPackage memory transInSynPkg) internal returns (uint32) {\n if (transInSynPkg.contractAddr==address(0x0)) {\n if (block.timestamp > transInSynPkg.expireTime) {\n return TRANSFER_IN_FAILURE_TIMEOUT;\n }\n if (address(this).balance < transInSynPkg.amount) {\n return TRANSFER_IN_FAILURE_INSUFFICIENT_BALANCE;\n }\n (bool success, ) = transInSynPkg.recipient.call{gas: MAX_GAS_FOR_TRANSFER_BNB, value: transInSynPkg.amount}(\"\");\n if (!success) {\n return TRANSFER_IN_FAILURE_NON_PAYABLE_RECIPIENT;\n }\n emit transferInSuccess(transInSynPkg.contractAddr, transInSynPkg.recipient, transInSynPkg.amount);\n return TRANSFER_IN_SUCCESS;\n } else {\n if (block.timestamp > transInSynPkg.expireTime) {\n return TRANSFER_IN_FAILURE_TIMEOUT;\n }\n if (contractAddrToBEP2Symbol[transInSynPkg.contractAddr]!= transInSynPkg.bep2TokenSymbol) {\n return TRANSFER_IN_FAILURE_UNBOUND_TOKEN;\n }\n uint256 actualBalance = IBEP20(transInSynPkg.contractAddr).balanceOf{gas: MAX_GAS_FOR_CALLING_BEP20}(address(this));\n if (actualBalance < transInSynPkg.amount) {\n return TRANSFER_IN_FAILURE_INSUFFICIENT_BALANCE;\n }\n bool success = IBEP20(transInSynPkg.contractAddr).transfer{gas: MAX_GAS_FOR_CALLING_BEP20}(transInSynPkg.recipient, transInSynPkg.amount);\n if (success) {\n emit transferInSuccess(transInSynPkg.contractAddr, transInSynPkg.recipient, transInSynPkg.amount);\n return TRANSFER_IN_SUCCESS;\n } else {\n return TRANSFER_IN_FAILURE_UNKNOWN;\n }\n }\n }"
            }
        ]
    }
}
{
    "src_chain": {
        "Lock1": [
            {
                "lock": "def lock(toChainId, fromAddress, toAddress, amount):\n\n \"\"\"\n decrease the btcx balance of 'fromAddress' in this contract, decrease the total supply.\n request cross chain transaction from Ontology network to the 'toChainId' blockchain by sending serialized parameter to\n Ontology Native contract method of 'createCrossChainTx'.\n :param toChainId: indicates which blockchain 'fromAddress' wants to do cross chain transaction, in integer format.\n :param fromAddress: indicates the requester of this crosschain transaction invocation, in Ontology address format\n :param toAddress: indicates the address that will receive btcx asset in the 'toChainId' blockchain, in hex format,\n if 'toAddress' belongs to Ethereum, we take the ethereum address and remove the '0x' then pass it as bytearray to contract\n if 'toAddress' belongs to BitCoin, we take the btc address and force formating it to bytes and take the hex of bytes then pass it as bytearray to contract\n :param amount: indicates how many btcx 'fromAddress' want to do cross chain transaction from Ontology to another chain, in integer format, should be >= minimum limit\n :return:\n \"\"\"\n btcRedeemScriptBytes = getBtcRedeemScript()\n assert(len(btcRedeemScriptBytes) != 0)\n \n if toChainId == BTC_ChainId:\n assert (amount >= getMinBackBTCLimit())\n argsList = [toAddress, amount, btcRedeemScriptBytes]\n else:\n assert (amount >=0 and toChainId != ONT_ChainId)\n argsList = [toAddress, amount]\n \n assert (CheckWitness(fromAddress))\n \n \n assert (len(toAddress) != 0)\n \n Put(ctx, concat(BALANCE_KEY, fromAddress), Sub(balanceOf(fromAddress), amount))\n \n Put(ctx, TOTAL_SUPPLY_KEY, Sub(totalSupply(), amount))\n \n inputArgs = _serialzieArgs(argsList)\n \n toAssetHash = getContractAddrWithChainId(toChainId)\n assert(len(toAssetHash) != 0)\n param = state(toChainId, toAssetHash, \"unlock\", inputArgs)\n assert (Invoke(0, CROSS_CHAIN_CONTRACT_ADDRESS, \"createCrossChainTx\", param))\n \n LockEvent(CONTRACT_ADDRESS, fromAddress, toChainId, toAssetHash, toAddress, amount)\n return True"
            }
        ]
    },
    "rel_chain": {
        "verify": [
            {
                "SideToAlliance": "func (this *SyncService) SideToAlliance() {\n\tcurrentAliaChainSyncHeight, err := this.GetCurrentAliaChainSyncHeight(this.GetSideChainID())\n\tif err != nil {\n\t\tlog.Errorf(\"[SideToAlliance] this.GetCurrentAliaChainSyncHeight error:\", err)\n\t\tos.Exit(1)\n\t}\n\tthis.aliaSyncHeight = currentAliaChainSyncHeight\n\tif config.DefConfig.SideToAlliForceSyncHeight > 0 {\n\t\tthis.aliaSyncHeight = uint32(config.DefConfig.SideToAlliForceSyncHeight)\n\t}\n\tfor {\n\t\tcurrentSideChainHeight, err := this.sideSdk.GetCurrentBlockHeight()\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"[SideToAlliance] this.sideSdk.GetCurrentBlockHeight error:\", err)\n\t\t}\n\t\tfunc sideToAlliance(...) {...}\nerr = this.sideToAlliance(this.aliaSyncHeight, currentSideChainHeight)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"[SideToAlliance] this.sideToAlliance error:\", err)\n\t\t}\n\t\ttime.Sleep(time.Duration(this.config.ScanInterval) * time.Second)\n\t}\n}"
            },
            {
                "sendTxToEth": "func (this *EthSender) sendTxToEth(info *EthTxInfo) error {\n\tnonce := this.nonceManager.GetAddressNonce(this.acc.Address)\n\ttx := types.NewTransaction(nonce, info.contractAddr, big.NewInt(0), info.gasLimit, info.gasPrice, info.txData)\n\tsignedtx, err := this.keyStore.SignTransaction(tx, this.acc)\n\tif err != nil {\n\t\tthis.nonceManager.ReturnNonce(this.acc.Address, nonce)\n\t\treturn fmt.Errorf(\"commitDepositEventsWithHeader - sign raw tx error and return nonce %d: %v\", nonce, err)\n\t}\n\terr = this.ethClient.SendTransaction(context.Background(), signedtx)\n\tif err != nil {\n\t\tthis.nonceManager.ReturnNonce(this.acc.Address, nonce)\n\t\treturn fmt.Errorf(\"commitDepositEventsWithHeader - send transaction error and return nonce %d: %v\", nonce, err)\n\t}\n\thash := signedtx.Hash()\n\tisSuccess := this.waitTransactionConfirm(info.polyTxHash, hash)\n\tif isSuccess {\n\t\tlog.Infof(\"successful to relay tx to ethereum: (eth_hash: %s, nonce: %d, poly_hash: %s, eth_explorer: %s)\",\n\t\t\thash.String(), nonce, info.polyTxHash, tools.GetExplorerUrl(this.keyStore.GetChainId())+hash.String())\n\t} else {\n\t\tlog.Errorf(\"failed to relay tx to ethereum: (eth_hash: %s, nonce: %d, poly_hash: %s, eth_explorer: %s)\",\n\t\t\thash.String(), nonce, info.polyTxHash, tools.GetExplorerUrl(this.keyStore.GetChainId())+hash.String())\n\t}\n\treturn nil\n}"
            }
        ]
    },
    "det_chain": {
        "execute1": [
            {
                "verifyHeaderAndExecuteTx": "function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){\n ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n \n IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n \n address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\n uint n = polyChainBKs.length;\n if (header.height >= curEpochStartHeight) {\n \n require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n } else {\n \n require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n \n ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\n bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);\n require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n }\n \n bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\n \n ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\n require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n \n require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");\n \n address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\n \n function _executeCrossChainTx(...) {...}\nrequire(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n \n \n emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\n return true;\n }"
            },
            {
                "verifySig": "function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n bytes32 hash = getHeaderHash(_rawHeader);\n uint sigCount = _sigList.length.div(POLYCHAIN_SIGNATURE_LEN);\n address[] memory signers = new address[](sigCount);\n bytes32 r;\n bytes32 s;\n uint8 v;\n for(uint j = 0; j < sigCount; j++){\n r = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN, 32));\n s = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN + 32, 32));\n v = uint8(_sigList[j*POLYCHAIN_SIGNATURE_LEN + 64]) + 27;\n signers[j] = ecrecover(sha256(abi.encodePacked(hash)), v, r, s);\n if (signers[j] == address(0)) return false;\n }\n return Utils.containMAddresses(_keepers, signers, _m);\n }"
            },
            {
                "merkleProve": "function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {\n uint256 off = 0;\n bytes memory value;\n (value, off) = ZeroCopySource.NextVarBytes(_auditPath, off);\n bytes32 hash = Utils.hashLeaf(value);\n uint size = _auditPath.length.sub(off).div(33);\n bytes32 nodeHash;\n byte pos;\n for (uint i = 0; i < size; i++) {\n (pos, off) = ZeroCopySource.NextByte(_auditPath, off);\n (nodeHash, off) = ZeroCopySource.NextHash(_auditPath, off);\n if (pos == 0x00) {\n hash = Utils.hashChildren(nodeHash, hash);\n } else if (pos == 0x01) {\n hash = Utils.hashChildren(hash, nodeHash);\n } else {\n revert(\"merkleProve, NextByte for position info failed\");\n }\n }\n require(hash == _root, \"merkleProve, expect root is not equal actual root\");\n return value;\n }"
            },
            {
                "_executeCrossChainTx": "function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){\n \n require(Utils.isContract(_toContract), \"The passed in address is not a contract!\");\n bytes memory returnData;\n bool success;\n \n (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))), abi.encode(_args, _fromContractAddr, _fromChainId)));\n \n require(success == true, \"EthCrossChain call business contract failed\");\n \n require(returnData.length != 0, \"No return value from business contract!\");\n (bool res,) = ZeroCopySource.NextBool(returnData, 31);\n require(res == true, \"EthCrossChain call business contract return is not true\");\n return true;\n }"
            }
        ]
    }
}
{
    "contract": "PolyNetwork",
    "source_code_path": "../vul_src_code/Poly_network/",
    "type": "AccessControlBypass",
    "vulnerable_entry_function": {
        "file": "EthCrossChainManager.sol",
        "name": "verifyHeaderAndExecuteTx",
        "signature": "function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool)",
        "lines": "127-149",
        "attack_type": "ArbitraryFunctionExecution via Malicious CrossChainInput",
        "vul_reason": "The contract fails to validate the `method` field passed in cross-chain calls. The attacker exploited the lack of method whitelist and invoked an internal function `putCurEpochConPubKeyBytes`, replacing the keeper public keys stored in EthCrossChainData. This allowed forged signatures to pass verification, enabling unauthorized asset withdrawals.",
        "code_snippet": "require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");"
    },
    "detail": "The PolyNetwork attack exploited a critical flaw in the EthCrossChainManager contract, which failed to properly validate the `method` string in incoming cross-chain requests. By crafting a transaction from Ontology that appeared legitimate and passed through PolyChain, the attacker called `putCurEpochConPubKeyBytes` on the Ethereum-side EthCrossChainData contract. This replaced the authorized keeper public keys with attacker-controlled keys. Subsequent fake transactions using forged signatures were accepted, leading to unauthorized asset minting and withdrawal across multiple blockchains. The exploit occurred because there was no method whitelist or contract-level access control on cross-chain delegated calls.",
    "blg": {
        "ploynetwork": {
            "interoperability": "heterogeneous",
            "roles": {
                "src_chain": [
                    "Lock1"
                ],
                "rel_chain": [
                    "verify"
                ],
                "det_name": [
                    "execute1"
                ]
            },
            "src_chain": {
                "chain_name": "Ontology_chain",
                "events": {
                    "Lock1": {
                        "0": {
                            "func_name": "lock",
                            "file_name": "btcx.py",
                            "key_ops": [
                                "assert(len(btcRedeemScriptBytes) != 0)",
                                "assert (amount >= getMinBackBTCLimit())",
                                "assert (amount >=0 and toChainId != ONT_ChainId)",
                                "assert (CheckWitness(fromAddress))",
                                "assert (len(toAddress) != 0)",
                                "Put(ctx, concat(BALANCE_KEY, fromAddress), Sub(balanceOf(fromAddress), amount))",
                                "Put(ctx, TOTAL_SUPPLY_KEY, Sub(totalSupply(), amount))",
                                "assert(len(toAssetHash) != 0)",
                                "assert (Invoke(0, CROSS_CHAIN_CONTRACT_ADDRESS, \"createCrossChainTx\", param))"
                            ],
                            "child": {
                                "0": {
                                    "func_name": "getBtcRedeemScript",
                                    "file_name": "btcx.py",
                                    "key_ops": [],
                                    "child": {}
                                },
                                "1": {
                                    "func_name": "_serialzieArgs",
                                    "file_name": "btcx.py",
                                    "key_ops": [],
                                    "child": {}
                                },
                                "2": {
                                    "func_name": "getContractAddrWithChainId",
                                    "file_name": "btcx.py",
                                    "key_ops": [],
                                    "child": {}
                                },
                                "3": {
                                    "func_name": "LockEvent",
                                    "file_name": "btcx.py",
                                    "key_ops": [],
                                    "child": {}
                                }
                            }
                        }
                    }
                }
            },
            "rel_chain": {
                "chain_name": "ploynetwork",
                "events": {
                    "verify": {
                        "0": {
                            "func_name": "SideToAlliance",
                            "file_name": "service.go",
                            "key_ops": [
                                "err = this.sideToAlliance(this.aliaSyncHeight, currentSideChainHeight"
                            ],
                            "child": {}
                        },
                        "1": {
                            "func_name": "sendTxToEth",
                            "file_name": "polymanager.go",
                            "key_ops": [
                                "signedtx, err := this.keyStore.SignTransaction(tx, this.acc)",
                                "err = this.ethClient.SendTransaction(context.Background(), signedtx)"
                            ],
                            "child": {}
                        }
                    }
                }
            },
            "det_chain": {
                "chain_name": "ethereum",
                "events": {
                    "execute1": {
                        "0": {
                            "func_name": "verifyHeaderAndExecuteTx",
                            "file_name": "EthCrossChainManager.sol",
                            "key_ops": [
                                "require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");",
                                "require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");",
                                "require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");",
                                "require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");",
                                "require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");",
                                "require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");",
                                "require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");"
                            ],
                            "child": {
                                "0": {
                                    "func_name": "deserializeKeepers",
                                    "file_name": "EthCrossChainUtils.sol",
                                    "key_ops": [],
                                    "child": {}
                                },
                                "1": {
                                    "func_name": "verifySig",
                                    "file_name": "EthCrossChainUtils.sol",
                                    "key_ops": [
                                        "ecrecover(sha256(abi.encodePacked(hash)), v, r, s)",
                                        "return Utils.containMAddresses(_keepers, signers, _m);"
                                    ],
                                    "child": {}
                                },
                                "2": {
                                    "func_name": "merkleProve",
                                    "file_name": "EthCrossChainUtils.sol",
                                    "key_ops": [
                                        "require(hash == _root, \"merkleProve, expect root is not equal actual root\");"
                                    ],
                                    "child": {}
                                },
                                "3": {
                                    "func_name": "_executeCrossChainTx",
                                    "file_name": "EthCrossChainManager.sol",
                                    "key_ops": [
                                        "require(Utils.isContract(_toContract), \"The passed in address is not a contract!\");",
                                        "require(success == true, \"EthCrossChain call business contract failed\");",
                                        "require(returnData.length != 0, \"No return value from business contract!\");",
                                        "require(res == true, \"EthCrossChain call business contract return is not true\");"
                                    ],
                                    "child": {}
                                },
                                "4": {
                                    "event_name": "VerifyHeaderAndExecuteTxEvent",
                                    "file_name": "EthCrossChainManager.sol",
                                    "key_ops": [],
                                    "child": {}
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    "cag": []
}
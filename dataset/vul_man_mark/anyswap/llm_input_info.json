{
    "src_chain": {
        "Transfer0": [
            {
                "depositWithPermit": "function depositWithPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns (uint) {\n function permit(...) {...}\nfunction safeTransferFrom(...) {...}\nIERC20(underlying).permit(target, address(this), value, deadline, v, r, s);\n IERC20(underlying).safeTransferFrom(target, address(this), value);\n return _deposit(value, to);\n }"
            },
            {
                "permit": "function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\n require(block.timestamp <= deadline, \"AnyswapV3ERC20: Expired permit\");\n bytes32 hashStruct = keccak256(\n abi.encode(\n PERMIT_TYPEHASH,\n target,\n spender,\n value,\n nonces[target]++,\n deadline));\n function verifyEIP712(...) {...}\nfunction verifyPersonalSign(...) {...}\nrequire(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));\n \n allowance[target][spender] = value;\n emit Approval(target, spender, value);\n }"
            },
            {
                "_deposit": "function _deposit(uint amount, address to) internal returns (uint) {\n require(underlying != address(0x0) && underlying != address(this));\n function _mint(...) {...}\n_mint(to, amount);\n return amount;\n }"
            },
            {
                "_mint": "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _totalSupply += amount;\n balanceOf[account] += amount;\n emit Transfer(address(0), account, amount);\n }"
            }
        ],
        "LogAnySwapOut1": [
            {
                "anySwapOutUnderlyingWithPermit": "function anySwapOutUnderlyingWithPermit(\n address from,\n address token,\n address to,\n uint amount,\n uint deadline,\n uint8 v,\n bytes32 r,\n bytes32 s,\n uint toChainID\n ) external {\n address _underlying = AnyswapV1ERC20(token).underlying();\n IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n IERC20(_underlying).safeTransferFrom(from, token, amount);\n AnyswapV1ERC20(token).depositVault(amount, from);\n _anySwapOut(from, token, to, amount, toChainID);\n }"
            },
            {
                "_anySwapOut": "function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n AnyswapV1ERC20(token).burn(from, amount);\n emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n }"
            }
        ]
    },
    "rel_chain": {
        "relayer": [
            {
                "processRouterSwap": "func processRouterSwap(swap *mongodb.MgoSwap) (err error) {\n\tif router.IsChainIDPaused(swap.FromChainID) || router.IsChainIDPaused(swap.ToChainID) {\n\t\treturn errChainIsPaused\n\t}\n\tfromChainID := swap.FromChainID\n\ttoChainID := swap.ToChainID\n\ttxid := swap.TxID\n\tlogIndex := swap.LogIndex\n\tbind := swap.Bind\n\t\n\tif cachedSwapTasks.Contains(swap.Key) {\n\t\treturn errAlreadySwapped\n\t}\n\tif isBlacked(swap) {\n\t\tlogWorkerWarn(\"swap\", \"swap is in black list\", \"txid\", txid, \"logIndex\", logIndex, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"token\", swap.GetToken(), \"tokenID\", swap.GetTokenID())\n\t\terr = tokens.ErrSwapInBlacklist\n\t\t_ = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.SwapInBlacklist, now(), err.Error())\n\t\t_ = mongodb.UpdateRouterSwapResultStatus(fromChainID, txid, logIndex, mongodb.SwapInBlacklist, now(), err.Error())\n\t\treturn nil\n\t}\n\tres, err := mongodb.FindRouterSwapResult(fromChainID, txid, logIndex)\n\tif err != nil {\n\t\tif errors.Is(err, mongodb.ErrItemNotFound) {\n\t\t\t_ = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.TxNotStable, now(), \"\")\n\t\t}\n\t\treturn err\n\t}\n\tif strings.HasPrefix(res.Memo, tokens.ErrBuildTxErrorAndDelay.Error()) && res.Timestamp+300 > now() {\n\t\treturn nil\n\t}\n\tvar disagreeCount uint64\n\tcacheKey := mongodb.GetRouterSwapKey(fromChainID, txid, logIndex)\n\toldValue, exist := disagreeRecords.Load(cacheKey)\n\tif exist {\n\t\tdisagreeCount = oldValue.(uint64)\n\t}\n\tif disagreeCount > maxDisagreeCount {\n\t\tif res.Timestamp+disagreeWaitInterval > now() {\n\t\t\tlogWorkerTrace(\"swap\", \"disagree too many times\", \"txid\", txid, \"logIndex\", logIndex, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"token\", swap.GetToken(), \"tokenID\", swap.GetTokenID())\n\t\t\treturn nil\n\t\t}\n\t\tdisagreeRecords.Store(cacheKey, 0) \n\t}\n\tlogWorker(\"swap\", \"start process router swap\", \"fromChainID\", fromChainID, \"txid\", txid, \"logIndex\", logIndex, \"status\", swap.Status, \"value\", res.Value)\n\tdstBridge := router.GetBridgeByChainID(toChainID)\n\tif dstBridge == nil {\n\t\treturn tokens.ErrNoBridgeForChainID\n\t}\n\terr = preventReswap(res)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbiFromChainID, biToChainID, biValue, err := getFromToChainIDAndValue(fromChainID, toChainID, res.Value)\n\tif err != nil {\n\t\treturn err\n\t}\n\trouterMPC, err := router.GetRouterMPC(swap.GetTokenID(), toChainID)\n\tif err != nil {\n\t\treturn err\n\t}\n\targs := &tokens.BuildTxArgs{\n\t\tSwapArgs: tokens.SwapArgs{\n\t\t\tIdentifier: params.GetIdentifier(),\n\t\t\tSwapID: txid,\n\t\t\tSwapType: tokens.SwapType(swap.SwapType),\n\t\t\tBind: bind,\n\t\t\tLogIndex: swap.LogIndex,\n\t\t\tFromChainID: biFromChainID,\n\t\t\tToChainID: biToChainID,\n\t\t\tReswapping: res.Status == mongodb.Reswapping,\n\t\t},\n\t\tFrom: routerMPC,\n\t\tOriginFrom: swap.From,\n\t\tOriginTxTo: swap.TxTo,\n\t\tOriginValue: biValue,\n\t\tExtra: &tokens.AllExtras{},\n\t}\n\targs.SwapInfo, err = mongodb.ConvertFromSwapInfo(&res.SwapInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn dispatchSwapTask(args)\n}"
            },
            {
                "dispatchSwapTask": "func dispatchSwapTask(args *tokens.BuildTxArgs) error {\n\tif !args.SwapType.IsValidType() {\n\t\treturn fmt.Errorf(\"unknown router swap type %d\", args.SwapType)\n\t}\n\tchainID := args.ToChainID.String()\n\ttaskQueue, exist := swapTaskQueues[chainID]\n\tif !exist {\n\t\tbridge := router.GetBridgeByChainID(chainID)\n\t\tif bridge == nil {\n\t\t\treturn tokens.ErrNoBridgeForChainID\n\t\t}\n\t\t\n\t\ttaskQueue = fifo.NewQueue()\n\t\tswapTaskQueues[chainID] = taskQueue\n\t\tmongodb.MgoWaitGroup.Add(1)\n\t\tgo startSwapConsumer(chainID)\n\t}\n\tlogWorker(\"doSwap\", \"dispatch router swap task\", \"fromChainID\", args.FromChainID, \"toChainID\", args.ToChainID, \"txid\", args.SwapID, \"logIndex\", args.LogIndex, \"value\", args.OriginValue, \"swapNonce\", args.GetTxNonce(), \"queue\", taskQueue.Len())\n\ttaskQueue.Add(args)\n\tcacheKey := mongodb.GetRouterSwapKey(args.FromChainID.String(), args.SwapID, args.LogIndex)\n\tswapTasksInQueue.Add(cacheKey)\n\treturn nil\n}"
            },
            {
                "doSwap": "func doSwap(args *tokens.BuildTxArgs) (err error) {\n\tif params.IsParallelSwapEnabled() {\n\t\treturn doSwapParallel(args)\n\t}\n\tfromChainID := args.FromChainID.String()\n\ttoChainID := args.ToChainID.String()\n\ttxid := args.SwapID\n\tlogIndex := args.LogIndex\n\toriginValue := args.OriginValue\n\tcacheKey := mongodb.GetRouterSwapKey(fromChainID, txid, logIndex)\n\terr = checkAndUpdateProcessSwapTaskCache(cacheKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogWorker(\"doSwap\", \"add swap cache\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\tisCachedSwapProcessed := false\n\tdefer func() {\n\t\tif !isCachedSwapProcessed {\n\t\t\tlogWorkerError(\"doSwap\", \"delete swap cache\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\t\t\tcachedSwapTasks.Remove(cacheKey)\n\t\t}\n\t}()\n\tlogWorker(\"doSwap\", \"start to process\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\tresBridge := router.GetBridgeByChainID(toChainID)\n\tif resBridge == nil {\n\t\treturn tokens.ErrNoBridgeForChainID\n\t}\n\tstart := time.Now()\n\trawTx, err := resBridge.BuildRawTransaction(args)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"build tx failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"timespent\", time.Since(start).String())\n\t\tif errors.Is(err, tokens.ErrBuildTxErrorAndDelay) {\n\t\t\t_ = updateSwapMemo(fromChainID, txid, logIndex, err.Error())\n\t\t}\n\t\treturn err\n\t}\n\tif args.SwapValue == nil {\n\t\treturn tokens.ErrNilSwapValue\n\t}\n\tswapTxNonce := args.GetTxNonce() \n\tlogWorker(\"doSwap\", \"build tx success\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\tstart = time.Now()\n\tsignedTx, txHash, err := resBridge.MPCSignTransaction(rawTx, args)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"sign tx failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"timespent\", time.Since(start).String())\n\t\tif errors.Is(err, mpc.ErrGetSignStatusHasDisagree) {\n\t\t\treverifySwap(args)\n\t\t}\n\t\treturn err\n\t}\n\tlogWorker(\"doSwap\", \"sign tx success\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"txHash\", txHash, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\tdisagreeRecords.Delete(cacheKey)\n\t\n\tres, err := mongodb.FindRouterSwapResult(fromChainID, txid, logIndex)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = preventReswap(res)\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n\taddSwapHistory(fromChainID, txid, logIndex, txHash)\n\tmatchTx := &MatchTx{\n\t\tSwapTx: txHash,\n\t\tSwapNonce: swapTxNonce,\n\t\tSwapValue: args.SwapValue.String(),\n\t\tMPC: args.From,\n\t}\n\tif args.Extra.TTL != nil {\n\t\tmatchTx.TTL = *args.Extra.TTL\n\t}\n\terr = updateRouterSwapResult(fromChainID, txid, logIndex, matchTx)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"update router swap result failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"swapNonce\", swapTxNonce)\n\t\treturn err\n\t}\n\tisCachedSwapProcessed = true\n\terr = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.TxProcessed, now(), \"\")\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"update router swap status failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex)\n\t\treturn err\n\t}\n\tstart = time.Now()\n\tsentTxHash, err := sendSignedTransaction(resBridge, signedTx, args)\n\tif err == nil && txHash != sentTxHash {\n\t\tlogWorkerError(\"doSwap\", \"send tx success but with different hash\", errSendTxWithDiffHash,\n\t\t\t\"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex,\n\t\t\t\"txHash\", txHash, \"sentTxHash\", sentTxHash, \"swapNonce\", swapTxNonce,\n\t\t\t\"timespent\", time.Since(start).String())\n\t\t_ = mongodb.UpdateRouterOldSwapTxs(fromChainID, txid, logIndex, sentTxHash)\n\t} else if err == nil {\n\t\tlogWorker(\"doSwap\", \"send tx success\",\n\t\t\t\"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex,\n\t\t\t\"txHash\", txHash, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\t}\n\tlogWorker(\"doSwap\", \"finish to process\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\treturn err\n}"
            }
        ]
    },
    "det_chain": {
        "Transfer1": [
            {
                "_mint": "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _totalSupply += amount;\n balanceOf[account] += amount;\n emit Transfer(address(0), account, amount);\n }"
            }
        ]
    }
}
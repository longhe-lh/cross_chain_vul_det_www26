{
    "src_chain": {
        "Deposit1": [
            {
                "deposit": "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n uint safeAmount;\n if(asset == address(0)){\n safeAmount = msg.value;\n (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n require(success && (data.length == 0 || abi.decode(data, (bool))));\n } else if(asset == RUNE) {\n safeAmount = amount;\n iRUNE(RUNE).transferTo(address(this), amount);\n iERC20(RUNE).burn(amount);\n } else {\n safeAmount = safeTransferFrom(asset, amount); \n vaultAllowance[vault][asset] += safeAmount; \n }\n emit Deposit(vault, asset, safeAmount, memo);\n }"
            },
            {
                "safeTransferFrom": "function safeTransferFrom(address _asset, uint _amount) internal returns(uint amount) {\n uint _startBal = iERC20(_asset).balanceOf(address(this));\n (bool success, bytes memory data) = _asset.call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), _amount));\n require(success && (data.length == 0 || abi.decode(data, (bool))));\n return (iERC20(_asset).balanceOf(address(this)) - _startBal);\n }"
            }
        ]
    },
    "rel_chain": {
        "Verify": [
            {
                "FetchTxs": "func (e *ETHScanner) FetchTxs(height int64) (stypes.TxIn, error) {\n\tblock, err := e.getRPCBlock(height)\n\tif err != nil {\n\t\treturn stypes.TxIn{}, err\n\t}\n\tfunc processBlock(...) {...}\ntxIn, err := e.processBlock(block)\n\tif err != nil {\n\t\te.logger.Error().Err(err).Int64(\"height\", height).Msg(\"fail to search tx in block\")\n\t\treturn stypes.TxIn{}, fmt.Errorf(\"fail to process block: %d, err:%w\", height, err)\n\t}\n\t\n\t\n\tblockMeta := types.NewBlockMeta(block.Header(), txIn)\n\tif err := e.blockMetaAccessor.SaveBlockMeta(blockMeta.Height, blockMeta); err != nil {\n\t\te.logger.Err(err).Msgf(\"fail to save block meta of height: %d \", blockMeta.Height)\n\t}\n\te.currentBlockHeight = height\n\tpruneHeight := height - BlockCacheSize\n\tif pruneHeight > 0 {\n\t\tdefer func() {\n\t\t\tif err := e.blockMetaAccessor.PruneBlockMeta(pruneHeight); err != nil {\n\t\t\t\te.logger.Err(err).Msgf(\"fail to prune block meta, height(%d)\", pruneHeight)\n\t\t\t}\n\t\t}()\n\t}\n\tif e.gasPriceChanged {\n\t\t\n\t\tgasPrice := e.GetGasPrice() \n\t\t\n\t\tgasPriceForThorchain := big.NewInt(0).Div(gasPrice, big.NewInt(common.One*100))\n\t\tgasValue := gasPriceForThorchain.Uint64()\n\t\tif gasValue == 0 {\n\t\t\tgasValue = 1\n\t\t}\n\t\t\n\t\tif big.NewInt(1).Mul(big.NewInt(int64(gasValue)), big.NewInt(common.One*100)).Cmp(gasPrice) < 0 {\n\t\t\tgasValue++\n\t\t}\n\t\t\n\t\tif gasValue != e.lastReportedGasPrice {\n\t\t\te.lastReportedGasPrice = gasValue\n\t\t\tif _, err := e.bridge.PostNetworkFee(height, common.ETHChain, MaxContractGas, gasValue); err != nil {\n\t\t\t\te.logger.Err(err).Msg(\"fail to post ETH chain single transfer fee to THORNode\")\n\t\t\t}\n\t\t}\n\t}\n\treturn txIn, nil\n}"
            },
            {
                "processBlock": "func (e *ETHScanner) processBlock(block *etypes.Block) (stypes.TxIn, error) {\n\theight := int64(block.NumberU64())\n\ttxIn := stypes.TxIn{\n\t\tChain: common.ETHChain,\n\t\tTxArray: nil,\n\t\tFiltered: false,\n\t\tMemPool: false,\n\t\tSentUnFinalised: false,\n\t\tFinalised: false,\n\t}\n\t\n\te.updateGasPrice()\n\tfunc processReorg(...) {...}\nfunc extractTxs(...) {...}\nreorgedTxIns, err := e.processReorg(block.Header())\n\tif err != nil {\n\t\te.logger.Error().Err(err).Msgf(\"fail to process reorg for block %d\", height)\n\t\treturn txIn, err\n\t}\n\tif len(reorgedTxIns) > 0 {\n\t\tfor _, item := range reorgedTxIns {\n\t\t\tif len(item.TxArray) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttxIn.TxArray = append(txIn.TxArray, item.TxArray...)\n\t\t}\n\t}\n\tif block.Transactions().Len() == 0 {\n\t\treturn txIn, nil\n\t}\n\ttxInBlock, err := e.extractTxs(block)\n\tif err != nil {\n\t\treturn txIn, err\n\t}\n\tif len(txInBlock.TxArray) > 0 {\n\t\ttxIn.TxArray = append(txIn.TxArray, txInBlock.TxArray...)\n\t}\n\treturn txIn, nil\n}"
            },
            {
                "extractTxs": "func (e *ETHScanner) extractTxs(block *etypes.Block) (stypes.TxIn, error) {\n\ttxInbound := stypes.TxIn{\n\t\tChain: common.ETHChain,\n\t\tFiltered: false,\n\t\tMemPool: false,\n\t}\n\tfor _, tx := range block.Transactions() {\n\t\tif tx.To() == nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif err := e.blockMetaAccessor.RemoveSignedTxItem(tx.Hash().String()); err != nil {\n\t\t\te.logger.Err(err).Msgf(\"fail to remove signed tx item, hash:%s\", tx.Hash().String())\n\t\t}\n\t\tfunc fromTxToTxIn(...) {...}\ntxInItem, err := e.fromTxToTxIn(tx)\n\t\tif err != nil {\n\t\t\te.logger.Error().Err(err).Str(\"hash\", tx.Hash().Hex()).Msg(\"fail to get one tx from server\")\n\t\t\t\n\t\t\t\n\t\t\tif errors.Is(err, etypes.ErrInvalidChainId) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\te.errCounter.WithLabelValues(\"fail_get_tx\", \"\").Inc()\n\t\t\t\n\t\t\t\n\t\t\treturn stypes.TxIn{}, fmt.Errorf(\"fail to get one tx from server: %w\", err)\n\t\t}\n\t\tif txInItem == nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif len(txInItem.To) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif len([]byte(txInItem.Memo)) > constants.MaxMemoSize {\n\t\t\tcontinue\n\t\t}\n\t\ttxInItem.BlockHeight = block.Number().Int64()\n\t\ttxInbound.TxArray = append(txInbound.TxArray, *txInItem)\n\t\te.logger.Debug().Str(\"hash\", tx.Hash().Hex()).Msgf(\"%s got %d tx\", e.cfg.ChainID, 1)\n\t}\n\tif len(txInbound.TxArray) == 0 {\n\t\te.logger.Info().Int64(\"block\", int64(block.NumberU64())).Msg(\"no tx need to be processed in this block\")\n\t\treturn stypes.TxIn{}, nil\n\t}\n\ttxInbound.Count = strconv.Itoa(len(txInbound.TxArray))\n\te.logger.Debug().Int64(\"block\", int64(block.NumberU64())).Msgf(\"there are %s tx in this block need to process\", txInbound.Count)\n\treturn txInbound, nil\n}"
            },
            {
                "fromTxToTxIn": "func (e *ETHScanner) fromTxToTxIn(tx *etypes.Transaction) (*stypes.TxInItem, error) {\n\tif tx == nil || tx.To() == nil {\n\t\treturn nil, nil\n\t}\n\treceipt, err := e.getReceipt(tx.Hash().Hex())\n\tif err != nil {\n\t\tif errors.Is(err, ethereum.NotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"fail to get transaction receipt: %w\", err)\n\t}\n\tif receipt.Status != 1 {\n\t\te.logger.Debug().Msgf(\"tx(%s) state: %d means failed , ignore\", tx.Hash().String(), receipt.Status)\n\t\treturn nil, nil\n\t}\n\tfunc isToSmartContract(...) {...}\nfunc getTxInFromSmartContract(...) {...}\nfunc getTxInFromTransaction(...) {...}\nsmartContract := e.isToSmartContract(receipt)\n\tif smartContract {\n\t\treturn e.getTxInFromSmartContract(tx, receipt)\n\t}\n\treturn e.getTxInFromTransaction(tx)\n}"
            },
            {
                "getTxInFromSmartContract": "func (e *ETHScanner) getTxInFromSmartContract(tx *etypes.Transaction, receipt *etypes.Receipt) (*stypes.TxInItem, error) {\n\te.logger.Debug().Msg(\"parse tx from smart contract\")\n\ttxInItem := &stypes.TxInItem{\n\t\tTx: tx.Hash().Hex()[2:],\n\t}\n\tsender, err := e.eipSigner.Sender(tx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fail to get sender: %w\", err)\n\t}\n\ttxInItem.Sender = strings.ToLower(sender.String())\n\t\n\tif receipt.Status != 1 {\n\t\te.logger.Info().Msgf(\"tx(%s) state: %d means failed , ignore\", tx.Hash().String(), receipt.Status)\n\t\treturn nil, nil\n\t}\n\tfor _, item := range receipt.Logs {\n\t\tswitch item.Topics[0].String() {\n\t\tcase depositEvent:\n\t\t\tdepositEvt, err := e.parseDeposit(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse deposit event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"deposit:%+v\", depositEvt)\n\t\t\ttxInItem.To = depositEvt.To.String()\n\t\t\ttxInItem.Memo = depositEvt.Memo\n\t\t\tfunc getAssetFromTokenAddress(...) {...}\nasset, err := e.getAssetFromTokenAddress(depositEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(depositEvt.Asset.String())\n\t\t\te.logger.Info().Msgf(\"token:%s,decimals:%d\", depositEvt.Asset, decimals)\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(depositEvt.Asset.String(), depositEvt.Amount)).WithDecimals(decimals))\n\t\tcase transferOutEvent:\n\t\t\ttransferOutEvt, err := e.parseTransferOut(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse transfer out event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"transfer out: %+v\", transferOutEvt)\n\t\t\ttxInItem.Sender = transferOutEvt.Vault.String()\n\t\t\ttxInItem.To = transferOutEvt.To.String()\n\t\t\ttxInItem.Memo = transferOutEvt.Memo\n\t\t\tasset, err := e.getAssetFromTokenAddress(transferOutEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(transferOutEvt.Asset.String())\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(transferOutEvt.Asset.String(), transferOutEvt.Amount)).WithDecimals(decimals))\n\t\tcase transferAllowanceEvent:\n\t\t\ttransferAllowanceEvt, err := e.parseTransferAllowanceEvent(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse transfer allowance event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"transfer allowance: %+v\", transferAllowanceEvt)\n\t\t\ttxInItem.Sender = transferAllowanceEvt.OldVault.String()\n\t\t\ttxInItem.To = transferAllowanceEvt.NewVault.String()\n\t\t\ttxInItem.Memo = transferAllowanceEvt.Memo\n\t\t\tasset, err := e.getAssetFromTokenAddress(transferAllowanceEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(transferAllowanceEvt.Asset.String())\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(transferAllowanceEvt.Asset.String(), transferAllowanceEvt.Amount)).WithDecimals(decimals))\n\t\tcase vaultTransferEvent:\n\t\t\ttransferEvent, err := e.parseVaultTransfer(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse vault transfer event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"vault transfer: %+v\", transferEvent)\n\t\t\ttxInItem.Sender = transferEvent.OldVault.String()\n\t\t\ttxInItem.To = transferEvent.NewVault.String()\n\t\t\ttxInItem.Memo = transferEvent.Memo\n\t\t\tfor _, item := range transferEvent.Coins {\n\t\t\t\tasset, err := e.getAssetFromTokenAddress(item.Asset.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t\t}\n\t\t\t\tdecimals := e.getTokenDecimalsForTHORChain(item.Asset.String())\n\t\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(item.Asset.String(), item.Amount)).WithDecimals(decimals))\n\t\t\t}\n\t\t}\n\t}\n\t\n\tethValue := cosmos.NewUintFromBigInt(tx.Value())\n\tif !ethValue.IsZero() {\n\t\tethValue = e.convertAmount(ethToken, tx.Value())\n\t\tif txInItem.Coins.GetCoin(common.ETHAsset).IsEmpty() && !ethValue.IsZero() {\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(common.ETHAsset, ethValue))\n\t\t}\n\t}\n\te.logger.Info().Msgf(\"tx: %s, gas price: %s, gas used: %d,receipt status:%d\", txInItem.Tx, tx.GasPrice().String(), receipt.GasUsed, receipt.Status)\n\t\n\ttxGasPrice := tx.GasPrice()\n\tif txGasPrice.Cmp(big.NewInt(tenGwei)) < 0 {\n\t\ttxGasPrice = big.NewInt(tenGwei)\n\t}\n\ttxInItem.Gas = common.MakeETHGas(txGasPrice, receipt.GasUsed)\n\tif txInItem.Coins.IsEmpty() {\n\t\te.logger.Debug().Msgf(\"there is no coin in this tx, ignore, %+v\", txInItem)\n\t\treturn nil, nil\n\t}\n\te.logger.Debug().Msgf(\"tx in item: %+v\", txInItem)\n\treturn txInItem, nil\n}"
            },
            {
                "getAssetFromTokenAddress": "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\tfunc getTokenMeta(...) {...}\ntokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}"
            },
            {
                "getTokenMeta": "func (e *ETHScanner) getTokenMeta(token string) (types.TokenMeta, error) {\n\ttokenMeta, err := e.tokens.GetTokenMeta(token)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tif tokenMeta.IsEmpty() {\n\t\tfunc getSymbol(...) {...}\nsymbol, err := e.getSymbol(token)\n\t\tif err != nil {\n\t\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get symbol: %w\", err)\n\t\t}\n\t\tdecimals, err := e.getDecimals(token)\n\t\tif err != nil {\n\t\t\te.logger.Err(err).Msgf(\"fail to get decimals from smart contract, default to: %d\", defaultDecimals)\n\t\t}\n\t\te.logger.Info().Msgf(\"token:%s, decimals: %d\", token, decimals)\n\t\ttokenMeta = types.NewTokenMeta(symbol, token, decimals)\n\t\tif err = e.tokens.SaveTokenMeta(symbol, token, decimals); err != nil {\n\t\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to save token meta: %w\", err)\n\t\t}\n\t}\n\treturn tokenMeta, nil\n}"
            },
            {
                "GetTokenMeta": "func (t *LevelDBTokenMeta) GetTokenMeta(address string) (types.TokenMeta, error) {\n\tfunc getTokenMetaKey(...) {...}\nkey := t.getTokenMetaKey(address)\n\texist, err := t.db.Has([]byte(key), nil)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to check whether token meta(%s) exist: %w\", key, err)\n\t}\n\tif !exist {\n\t\treturn types.TokenMeta{}, nil\n\t}\n\tv, err := t.db.Get([]byte(key), nil)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get token meta(%s) from storage: %w\", key, err)\n\t}\n\tvar tm types.TokenMeta\n\tif err := json.Unmarshal(v, &tm); err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to unmarshal token meta from json: %w\", err)\n\t}\n\treturn tm, nil\n}"
            },
            {
                "getSymbol": "func (e *ETHScanner) getSymbol(token string) (string, error) {\n\tif IsETH(token) {\n\t\treturn \"ETH\", nil\n\t}\n\tto := ecommon.HexToAddress(token)\n\tinput, err := e.erc20ABI.Pack(symbolMethod)\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\tctx, cancel := e.getContext()\n\tdefer cancel()\n\tres, err := e.client.CallContract(ctx, ethereum.CallMsg{\n\t\tTo: &to,\n\t\tData: input,\n\t}, nil)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"fail to call to smart contract and get symbol: %w\", err)\n\t}\n\toutput, err := e.erc20ABI.Unpack(symbolMethod, res)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"fail to unpack symbol method call: %w\", err)\n\t}\n\tsymbol := *abi.ConvertType(output[0], new(string)).(*string)\n\treturn sanitiseSymbol(symbol), nil\n}"
            },
            {
                "SaveTokenMeta": "func (t *LevelDBTokenMeta) SaveTokenMeta(symbol, address string, decimals uint64) error {\n\tfunc getTokenMetaKey(...) {...}\nkey := t.getTokenMetaKey(address)\n\ttokenMeta := types.NewTokenMeta(symbol, address, decimals)\n\tbuf, err := json.Marshal(tokenMeta)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"fail to marshal token meta to json: %w\", err)\n\t}\n\treturn t.db.Put([]byte(key), buf, nil)\n}"
            },
            {
                "getTxInFromTransaction": "func (e *ETHScanner) getTxInFromTransaction(tx *etypes.Transaction) (*stypes.TxInItem, error) {\n\ttxInItem := &stypes.TxInItem{\n\t\tTx: tx.Hash().Hex()[2:],\n\t}\n\tasset := common.ETHAsset\n\tsender, err := e.eipSigner.Sender(tx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fail to get sender: %w\", err)\n\t}\n\ttxInItem.Sender = strings.ToLower(sender.String())\n\ttxInItem.To = strings.ToLower(tx.To().String())\n\t\n\tdata := tx.Data()\n\tif len(data) > 0 {\n\t\tmemo, err := hex.DecodeString(string(data))\n\t\tif err != nil {\n\t\t\ttxInItem.Memo = string(data)\n\t\t} else {\n\t\t\ttxInItem.Memo = string(memo)\n\t\t}\n\t}\n\tethValue := e.convertAmount(ethToken, tx.Value())\n\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, ethValue))\n\ttxGasPrice := tx.GasPrice()\n\tif txGasPrice.Cmp(big.NewInt(tenGwei)) < 0 {\n\t\ttxGasPrice = big.NewInt(tenGwei)\n\t}\n\ttxInItem.Gas = common.MakeETHGas(txGasPrice, tx.Gas())\n\tif txInItem.Coins.IsEmpty() {\n\t\te.logger.Debug().Msgf(\"there is no coin in this tx, ignore, %+v\", txInItem)\n\t\treturn nil, nil\n\t}\n\treturn txInItem, nil\n}"
            }
        ]
    },
    "det_chain": {
        "returnVaultAssets1": [
            {
                "returnVaultAssets": "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n if (router == address(this)){\n for(uint i = 0; i < coins.length; i++){\n _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n }\n emit VaultTransfer(msg.sender, asgard, coins, memo); \n } else {\n for(uint i = 0; i < coins.length; i++){\n _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n }\n }\n (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n require(success && (data.length == 0 || abi.decode(data, (bool))));\n }"
            },
            {
                "_routerDeposit": "function _routerDeposit(address _router, address _vault, address _asset, uint _amount, string memory _memo) internal {\n vaultAllowance[msg.sender][_asset] -= _amount;\n require(iERC20(_asset).approve(_router, _amount)); \n function deposit(...) {...}\niROUTER(_router).deposit(_vault, _asset, _amount, _memo); \n }"
            }
        ]
    }
}
{"project": "AllBridge", "functions": ["function sendTokens(\n uint256 amount,\n bytes32 recipient,\n uint8 destinationChainId,\n bytes32 receiveToken,\n uint256 nonce,\n MessengerProtocol messenger\n ) internal override {\n uint8 sourceChainId = chainId; \n require(\n destinationChainId != sourceChainId,\n \"Bridge: wrong destination chain\"\n );\n require(\n otherBridgeTokens[destinationChainId][receiveToken],\n \"Bridge: unknown chain or token\"\n );\n bytes32 message = this.hashMessage(\n amount,\n recipient,\n sourceChainId,\n destinationChainId,\n receiveToken,\n nonce,\n messenger\n );\n bool wasMessageSent;\n assembly {\n mstore(0x00, message)\n mstore(0x20, sentMessages.slot)\n let key := keccak256(0, 0x40)\n wasMessageSent := sload(key)\n sstore(key, true)\n }\n require(!wasMessageSent, \"Bridge: tokens already sent\");\n uint256 bridgeTransactionCost = this.getTransactionCost(\n destinationChainId\n );\n uint256 messageTransactionCost = sendMessage(message, messenger);\n unchecked {\n require(\n msg.value >= bridgeTransactionCost + messageTransactionCost,\n \"Bridge: not enough fee\"\n );\n }\n emit TokensSent(\n amount,\n recipient,\n destinationChainId,\n receiveToken,\n nonce,\n messenger\n );\n }", "function sendMessage(bytes32 message) external payable {\n require(\n uint8(message[0]) == chainId,\n \"WormholeMessenger: wrong chainId\"\n );\n require(\n otherChainIds[uint8(message[1])] != 0,\n \"Messenger: wrong destination\"\n );\n bytes32 messageWithSender = message.hashWithSenderAddress(msg.sender);\n uint32 nonce_ = nonce;\n uint64 sequence = wormhole.publishMessage(\n nonce_,\n abi.encodePacked(messageWithSender),\n commitmentLevel\n );\n unchecked {\n nonce = nonce_ + 1;\n }\n require(\n !sentMessages[messageWithSender],\n \"WormholeMessenger: has message\"\n );\n sentMessages[messageWithSender] = true;\n emit MessageSent(messageWithSender, sequence);\n }", "function receiveTokens(\n uint256 amount,\n bytes32 recipient,\n uint8 sourceChainId,\n bytes32 receiveToken,\n uint256 nonce,\n MessengerProtocol messenger\n ) external override {\n require(\n otherBridges[sourceChainId] != bytes32(0),\n \"Bridge: source not registered\"\n );\n bytes32 messageWithSender = this\n .hashMessage(\n amount,\n recipient,\n sourceChainId,\n chainId,\n receiveToken,\n nonce,\n messenger\n )\n .hashWithSender(otherBridges[sourceChainId]);\n bool wasMessageProcessed;\n assembly {\n mstore(0x00, messageWithSender)\n mstore(0x20, processedMessages.slot)\n let key := keccak256(0, 0x40)\n wasMessageProcessed := sload(key)\n sstore(key, true)\n }\n require(!wasMessageProcessed, \"Bridge: message processed\");\n require(\n this.hasReceivedMessage(messageWithSender, messenger),\n \"Bridge: no message\"\n );\n receiveAndSwap(\n amount,\n receiveToken,\n address(uint160(uint256(recipient)))\n );\n }", "function receiveAndSwap(\n uint256 vUsdAmount,\n bytes32 token,\n address recipient\n ) internal {\n Pool tokenPool = pools[token];\n require(address(tokenPool) != address(0), \"Router: no pool\");\n function swapFromVUsd(...) {...}\ntokenPool.swapFromVUsd(recipient, vUsdAmount);\n }", "function swapFromVUsd(\n address user,\n uint256 amount\n ) external onlyRouter returns (uint256) {\n uint256 result; \n uint256 fee;\n if (amount > 0) {\n vUsdBalance += amount;\n uint256 newAmount = this.getY(vUsdBalance);\n if (tokenBalance > newAmount) {\n result = fromSystemPrecision(tokenBalance - newAmount);\n } \n fee = (result * feeShareBP) / BP;\n \n unchecked {\n result -= fee;\n }\n tokenBalance = newAmount;\n function safeTransfer(...) {...}\nfunction _addRewards(...) {...}\ntoken.safeTransfer(user, result);\n _addRewards(fee);\n }\n emit SwappedFromVUsd(user, address(token), amount, result, fee);\n return result;\n }", "function _addRewards(uint256 rewardAmount_) internal {\n if (totalLpAmount > 0) {\n uint256 adminFeeRewards = (rewardAmount_ * adminFeeShareBP) / BP;\n unchecked {\n rewardAmount_ -= adminFeeRewards;\n }\n accRewardPerShareP += (rewardAmount_ << P) / totalLpAmount;\n adminFeeAmount += adminFeeRewards;\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "AllBridge", "functions": ["function sendMessage(bytes32 message) external payable {\n require(\n uint8(message[0]) == chainId,\n \"WormholeMessenger: wrong chainId\"\n );\n require(\n otherChainIds[uint8(message[1])] != 0,\n \"Messenger: wrong destination\"\n );\n bytes32 messageWithSender = message.hashWithSenderAddress(msg.sender);\n uint32 nonce_ = nonce;\n uint64 sequence = wormhole.publishMessage(\n nonce_,\n abi.encodePacked(messageWithSender),\n commitmentLevel\n );\n unchecked {\n nonce = nonce_ + 1;\n }\n require(\n !sentMessages[messageWithSender],\n \"WormholeMessenger: has message\"\n );\n sentMessages[messageWithSender] = true;\n emit MessageSent(messageWithSender, sequence);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "AllBridge", "functions": ["function receiveMessage(bytes memory encodedMsg) external {\n (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole\n .parseAndVerifyVM(encodedMsg);\n require(valid, reason);\n require(vm.payload.length == 32, \"WormholeMessenger: wrong length\");\n bytes32 messageWithSender = bytes32(vm.payload);\n require(\n uint8(messageWithSender[1]) == chainId,\n \"WormholeMessenger: wrong chainId\"\n );\n require(\n otherWormholeMessengers[vm.emitterChainId] == vm.emitterAddress,\n \"WormholeMessenger: wrong emitter\"\n );\n receivedMessages[messageWithSender] = true;\n emit MessageReceived(messageWithSender, vm.sequence);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arbitrum Bridge", "functions": ["function enqueueDelayedMessage(\n uint8 kind,\n address sender,\n bytes32 messageDataHash\n ) external payable returns (uint256) {\n if (!allowedDelayedInboxesMap[msg.sender].allowed)\n revert NotDelayedInbox(msg.sender);\n return\n addMessageToDelayedAccumulator(\n kind,\n sender,\n uint64(block.number),\n uint64(block.timestamp), \n block.basefee,\n messageDataHash\n );\n }", "function addMessageToDelayedAccumulator(\n uint8 kind,\n address sender,\n uint64 blockNumber,\n uint64 blockTimestamp,\n uint256 baseFeeL1,\n bytes32 messageDataHash\n ) internal returns (uint256) {\n uint256 count = delayedInboxAccs.length;\n bytes32 messageHash = Messages.messageHash(\n kind,\n sender,\n blockNumber,\n blockTimestamp,\n count,\n baseFeeL1,\n messageDataHash\n );\n bytes32 prevAcc = 0;\n if (count > 0) {\n prevAcc = delayedInboxAccs[count - 1];\n }\n delayedInboxAccs.push(\n Messages.accumulateInboxMessage(prevAcc, messageHash)\n );\n emit MessageDelivered(\n count,\n prevAcc,\n msg.sender,\n kind,\n sender,\n messageDataHash,\n baseFeeL1,\n blockTimestamp\n );\n return count;\n }", "function executeTransaction(\n bytes32[] calldata proof,\n uint256 index,\n address l2Sender,\n address to,\n uint256 l2Block,\n uint256 l1Block,\n uint256 l2Timestamp,\n uint256 value,\n bytes calldata data\n ) external {\n bytes32 userTx = calculateItemHash(\n l2Sender,\n to,\n l2Block,\n l1Block,\n l2Timestamp,\n value,\n data\n );\n function recordOutputAsSpent(...) {...}\nfunction executeTransactionImpl(...) {...}\nrecordOutputAsSpent(proof, index, userTx);\n executeTransactionImpl(\n index,\n l2Sender,\n to,\n l2Block,\n l1Block,\n l2Timestamp,\n value,\n data\n );\n }", "function executeTransactionImpl(\n uint256 outputId,\n address l2Sender,\n address to,\n uint256 l2Block,\n uint256 l1Block,\n uint256 l2Timestamp,\n uint256 value,\n bytes calldata data\n ) internal {\n emit OutBoxTransactionExecuted(to, l2Sender, 0, outputId);\n \n \n L2ToL1Context memory prevContext = context;\n context = L2ToL1Context({\n sender: l2Sender,\n l2Block: uint128(l2Block),\n l1Block: uint128(l1Block),\n timestamp: uint128(l2Timestamp),\n outputId: bytes32(outputId)\n });\n \n function executeBridgeCall(...) {...}\nexecuteBridgeCall(to, value, data);\n context = prevContext;\n }", "function executeBridgeCall(\n address to,\n uint256 value,\n bytes memory data\n ) internal {\n (bool success, bytes memory returndata) = bridge.executeCall(\n to,\n value,\n data\n );\n if (!success) {\n if (returndata.length > 0) {\n \n assembly {\n let returndata_size := mload(returndata)\n revert(add(32, returndata), returndata_size)\n }\n } else {\n revert BridgeCallFailed();\n }\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arbitrum Bridge", "functions": ["function executeCall(\n address to,\n uint256 value,\n bytes calldata data\n ) external returns (bool success, bytes memory returnData) {\n if (!allowedOutboxesMap[msg.sender].allowed)\n revert NotOutbox(msg.sender);\n if (data.length > 0 && !to.isContract()) revert NotContract(to);\n address prevOutbox = _activeOutbox;\n _activeOutbox = msg.sender;\n \n \n \n \n (success, returnData) = to.call{value: value}(data);\n _activeOutbox = prevOutbox;\n emit BridgeCallTriggered(msg.sender, to, value, data);\n }", "function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external {\n if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);\n roots[root] = l2BlockHash;\n emit SendRootUpdated(root, l2BlockHash);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arbitrum Bridge", "functions": ["function addSequencerL2BatchFromOrigin(\n uint256 sequenceNumber,\n bytes calldata data,\n uint256 afterDelayedMessagesRead,\n IGasRefunder gasRefunder\n ) external refundsGas(gasRefunder) {\n \n if (msg.sender != tx.origin) revert NotOrigin();\n if (!isBatchPoster[msg.sender]) revert NotBatchPoster();\n (bytes32 dataHash, TimeBounds memory timeBounds) = formDataHash(\n data,\n afterDelayedMessagesRead\n );\n (\n uint256 seqMessageIndex,\n bytes32 beforeAcc,\n bytes32 delayedAcc,\n bytes32 afterAcc\n ) = addSequencerL2BatchImpl(\n dataHash,\n afterDelayedMessagesRead,\n data.length\n );\n if (seqMessageIndex != sequenceNumber)\n revert BadSequencerNumber(seqMessageIndex, sequenceNumber);\n emit SequencerBatchDelivered(\n sequenceNumber,\n beforeAcc,\n afterAcc,\n delayedAcc,\n totalDelayedMessagesRead,\n timeBounds,\n BatchDataLocation.TxInput\n );\n }", "function addSequencerL2BatchImpl(\n bytes32 dataHash,\n uint256 afterDelayedMessagesRead,\n uint256 calldataLengthPosted\n )\n internal\n returns (\n uint256 seqMessageIndex,\n bytes32 beforeAcc,\n bytes32 delayedAcc,\n bytes32 acc\n )\n {\n if (afterDelayedMessagesRead < totalDelayedMessagesRead)\n revert DelayedBackwards();\n if (afterDelayedMessagesRead > bridge.delayedMessageCount())\n revert DelayedTooFar();\n (seqMessageIndex, beforeAcc, delayedAcc, acc) = bridge\n .enqueueSequencerMessage(dataHash, afterDelayedMessagesRead);\n totalDelayedMessagesRead = afterDelayedMessagesRead;\n if (calldataLengthPosted > 0) {\n \n \n address batchPoster = msg.sender;\n bytes memory spendingReportMsg = abi.encodePacked(\n block.timestamp,\n batchPoster,\n dataHash,\n seqMessageIndex,\n block.basefee\n );\n uint256 msgNum = bridge.submitBatchSpendingReport(\n batchPoster,\n keccak256(spendingReportMsg)\n );\n \n emit InboxMessageDelivered(msgNum, spendingReportMsg);\n }\n }", "function enqueueSequencerMessage(\n bytes32 dataHash,\n uint256 afterDelayedMessagesRead\n )\n external\n onlySequencerInbox\n returns (\n uint256 seqMessageIndex,\n bytes32 beforeAcc,\n bytes32 delayedAcc,\n bytes32 acc\n )\n {\n seqMessageIndex = sequencerInboxAccs.length;\n if (sequencerInboxAccs.length > 0) {\n beforeAcc = sequencerInboxAccs[sequencerInboxAccs.length - 1];\n }\n if (afterDelayedMessagesRead > 0) {\n delayedAcc = delayedInboxAccs[afterDelayedMessagesRead - 1];\n }\n acc = keccak256(abi.encodePacked(beforeAcc, dataHash, delayedAcc));\n sequencerInboxAccs.push(acc);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arbitrum Bridge", "functions": ["function createNewNode(\n RollupLib.Assertion calldata assertion,\n uint64 prevNodeNum,\n uint256 prevNodeInboxMaxCount,\n bytes32 expectedNodeHash\n ) internal returns (bytes32 newNodeHash) {\n require(\n assertion.afterState.machineStatus == MachineStatus.FINISHED ||\n assertion.afterState.machineStatus == MachineStatus.ERRORED,\n \"BAD_AFTER_STATUS\"\n );\n StakeOnNewNodeFrame memory memoryFrame;\n {\n \n memoryFrame.prevNode = getNode(prevNodeNum);\n memoryFrame.currentInboxSize = bridge.sequencerMessageCount();\n \n require(\n RollupLib.stateHash(\n assertion.beforeState,\n prevNodeInboxMaxCount\n ) == memoryFrame.prevNode.stateHash,\n \"PREV_STATE_HASH\"\n );\n \n uint64 afterInboxCount = assertion\n .afterState\n .globalState\n .getInboxPosition();\n uint64 prevInboxPosition = assertion\n .beforeState\n .globalState\n .getInboxPosition();\n require(afterInboxCount >= prevInboxPosition, \"INBOX_BACKWARDS\");\n if (afterInboxCount == prevInboxPosition) {\n require(\n assertion.afterState.globalState.getPositionInMessage() >=\n assertion\n .beforeState\n .globalState\n .getPositionInMessage(),\n \"INBOX_POS_IN_MSG_BACKWARDS\"\n );\n }\n \n if (\n assertion.afterState.machineStatus == MachineStatus.ERRORED ||\n assertion.afterState.globalState.getPositionInMessage() > 0\n ) {\n \n afterInboxCount++;\n }\n require(\n afterInboxCount <= memoryFrame.currentInboxSize,\n \"INBOX_PAST_END\"\n );\n \n if (afterInboxCount > 0) {\n memoryFrame.sequencerBatchAcc = bridge.sequencerInboxAccs(\n afterInboxCount - 1\n );\n }\n }\n {\n memoryFrame.executionHash = RollupLib.executionHash(assertion);\n memoryFrame.deadlineBlock =\n uint64(block.number) +\n confirmPeriodBlocks;\n memoryFrame.hasSibling = memoryFrame.prevNode.latestChildNumber > 0;\n \n if (memoryFrame.hasSibling) {\n memoryFrame.lastHash = getNodeStorage(\n memoryFrame.prevNode.latestChildNumber\n ).nodeHash;\n } else {\n memoryFrame.lastHash = memoryFrame.prevNode.nodeHash;\n }\n newNodeHash = RollupLib.nodeHash(\n memoryFrame.hasSibling,\n memoryFrame.lastHash,\n memoryFrame.executionHash,\n memoryFrame.sequencerBatchAcc,\n wasmModuleRoot\n );\n require(\n newNodeHash == expectedNodeHash ||\n expectedNodeHash == bytes32(0),\n \"UNEXPECTED_NODE_HASH\"\n );\n memoryFrame.node = NodeLib.createNode(\n RollupLib.stateHash(\n assertion.afterState,\n memoryFrame.currentInboxSize\n ),\n RollupLib.challengeRootHash(\n memoryFrame.executionHash,\n block.number,\n wasmModuleRoot\n ),\n RollupLib.confirmHash(assertion),\n prevNodeNum,\n memoryFrame.deadlineBlock,\n newNodeHash\n );\n }\n {\n uint64 nodeNum = latestNodeCreated() + 1;\n \n \n Node storage prevNode = getNodeStorage(prevNodeNum);\n prevNode.childCreated(nodeNum);\n nodeCreated(memoryFrame.node);\n }\n emit NodeCreated(\n latestNodeCreated(),\n memoryFrame.prevNode.nodeHash,\n newNodeHash,\n memoryFrame.executionHash,\n assertion,\n memoryFrame.sequencerBatchAcc,\n wasmModuleRoot,\n memoryFrame.currentInboxSize\n );\n return newNodeHash;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arbitrum Bridge", "functions": ["function createChallenge(\n bytes32 wasmModuleRoot_,\n MachineStatus[2] calldata startAndEndMachineStatuses_,\n GlobalState[2] calldata startAndEndGlobalStates_,\n uint64 numBlocks,\n address asserter_,\n address challenger_,\n uint256 asserterTimeLeft_,\n uint256 challengerTimeLeft_\n ) external override returns (uint64) {\n require(msg.sender == address(resultReceiver), \"ONLY_ROLLUP_CHAL\");\n bytes32[] memory segments = new bytes32[](2);\n segments[0] = ChallengeLib.blockStateHash(\n startAndEndMachineStatuses_[0],\n startAndEndGlobalStates_[0].hash()\n );\n segments[1] = ChallengeLib.blockStateHash(\n startAndEndMachineStatuses_[1],\n startAndEndGlobalStates_[1].hash()\n );\n uint64 challengeIndex = ++totalChallengesCreated;\n \n assert(challengeIndex != NO_CHAL_INDEX);\n ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\n challenge.wasmModuleRoot = wasmModuleRoot_;\n \n uint64 maxInboxMessagesRead = startAndEndGlobalStates_[1]\n .getInboxPosition();\n if (\n startAndEndMachineStatuses_[1] == MachineStatus.ERRORED ||\n startAndEndGlobalStates_[1].getPositionInMessage() > 0\n ) {\n maxInboxMessagesRead++;\n }\n challenge.maxInboxMessages = maxInboxMessagesRead;\n challenge.next = ChallengeLib.Participant({\n addr: asserter_,\n timeLeft: asserterTimeLeft_\n });\n challenge.current = ChallengeLib.Participant({\n addr: challenger_,\n timeLeft: challengerTimeLeft_\n });\n challenge.lastMoveTimestamp = block.timestamp;\n challenge.mode = ChallengeLib.ChallengeMode.BLOCK;\n emit InitiatedChallenge(\n challengeIndex,\n startAndEndGlobalStates_[0],\n startAndEndGlobalStates_[1]\n );\n function completeBisection(...) {...}\ncompleteBisection(challengeIndex, 0, numBlocks, segments);\n return challengeIndex;\n }", "function completeBisection(\n uint64 challengeIndex,\n uint256 challengeStart,\n uint256 challengeLength,\n bytes32[] memory newSegments\n ) private {\n assert(challengeLength >= 1);\n assert(newSegments.length >= 2);\n bytes32 challengeStateHash = ChallengeLib.hashChallengeState(\n challengeStart,\n challengeLength,\n newSegments\n );\n challenges[challengeIndex].challengeStateHash = challengeStateHash;\n emit Bisected(\n challengeIndex,\n challengeStateHash,\n challengeStart,\n challengeLength,\n newSegments\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arken.Finance Bridge", "functions": ["function initializeCallableAddress(address _callableAddress) external {\n require(\n _CALLABLE_ADDRESS_ == address(0),\n \"ArkenApprove: callable address initialized\"\n );\n _CALLABLE_ADDRESS_ = _callableAddress;\n emit SetCallableAddress(address(0), _callableAddress);\n }", "function trade(TradeDescription memory desc) external payable {\n require(desc.amountIn > 0, \"Amount-in needs to be more than zero\");\n require(\n desc.amountOutMin > 0,\n \"Amount-out minimum needs to be more than zero\"\n );\n if (_ETH_ == desc.srcToken) {\n require(\n desc.amountIn == msg.value,\n \"Ether value not match amount-in\"\n );\n require(\n desc.isRouterSource,\n \"Source token Ether requires isRouterSource=true\"\n );\n }\n uint256 beforeDstAmt = _getBalance(desc.dstToken, desc.to);\n uint256 returnAmount = _trade(desc);\n if (returnAmount > 0) {\n if (_ETH_ == desc.dstToken) {\n (bool sent, ) = desc.to.call{value: returnAmount}(\"\");\n require(sent, \"Failed to send Ether\");\n } else {\n IERC20(desc.dstToken).safeTransfer(desc.to, returnAmount);\n }\n }\n uint256 receivedAmt = _getBalance(desc.dstToken, desc.to) -\n beforeDstAmt;\n require(\n receivedAmt >= desc.amountOutMin,\n \"Received token is not enough\"\n );\n emit Swapped(desc.srcToken, desc.dstToken, desc.amountIn, receivedAmt);\n }", "function _trade(\n TradeDescription memory desc\n ) internal returns (uint256 returnAmount) {\n TradeData memory data = TradeData({amountIn: desc.amountIn});\n if (desc.isSourceFee) {\n if (_ETH_ == desc.srcToken) {\n data.amountIn = _collectFee(desc.amountIn, desc.srcToken);\n } else {\n uint256 fee = _calculateFee(desc.amountIn);\n require(fee < desc.amountIn, \"Fee exceeds amount\");\n _transferFromSender(\n desc.srcToken,\n _FEE_WALLET_ADDR_,\n fee,\n desc.srcToken,\n data\n );\n }\n }\n if (desc.isRouterSource && _ETH_ != desc.srcToken) {\n _transferFromSender(\n desc.srcToken,\n address(this),\n data.amountIn,\n desc.srcToken,\n data\n );\n }\n if (_ETH_ == desc.srcToken) {\n _wrapEther(_WETH_, address(this).balance);\n }\n for (uint256 i = 0; i < desc.routes.length; i++) {\n _tradeRoute(desc.routes[i], desc, data);\n }\n if (_ETH_ == desc.dstToken) {\n returnAmount = IERC20(_WETH_).balanceOf(address(this));\n _unwrapEther(_WETH_, returnAmount);\n } else {\n returnAmount = IERC20(desc.dstToken).balanceOf(address(this));\n }\n if (!desc.isSourceFee) {\n require(\n returnAmount >= desc.amountOutMin && returnAmount > 0,\n \"Return amount is not enough\"\n );\n function _collectFee(...) {...}\nreturnAmount = _collectFee(returnAmount, desc.dstToken);\n }\n }", "function _collectFee(\n uint256 amount,\n address token\n ) internal returns (uint256 remainingAmount) {\n function _calculateFee(...) {...}\nfunction safeTransfer(...) {...}\nuint256 fee = _calculateFee(amount);\n require(fee < amount, \"Fee exceeds amount\");\n remainingAmount = amount - fee;\n if (_ETH_ == token) {\n (bool sent, ) = _FEE_WALLET_ADDR_.call{value: fee}(\"\");\n require(sent, \"Failed to send Ether too fee\");\n } else {\n IERC20(token).safeTransfer(_FEE_WALLET_ADDR_, fee);\n }\n }", "function safeTransfer(IERC20 token, address to, uint256 value) internal {\n _callOptionalReturn(\n token,\n abi.encodeWithSelector(token.transfer.selector, to, value)\n );\n }", "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n \n \n \n bytes memory returndata = address(token).functionCall(\n data,\n \"SafeERC20: low-level call failed\"\n );\n if (returndata.length > 0) {\n \n require(\n abi.decode(returndata, (bool)),\n \"SafeERC20: ERC20 operation did not succeed\"\n );\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arken.Finance Bridge", "functions": ["function transferToken(\n IERC20 token,\n address from,\n address to,\n uint256 amount\n ) external onlyCallable {\n if (amount > 0) {\n function safeTransferFrom(...) {...}\ntoken.safeTransferFrom(from, to, amount);\n }\n }", "function safeTransferFrom(\n IERC20 token,\n address from,\n address to,\n uint256 value\n ) internal {\n _callOptionalReturn(\n token,\n abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n );\n }", "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n \n \n \n bytes memory returndata = address(token).functionCall(\n data,\n \"SafeERC20: low-level call failed\"\n );\n if (returndata.length > 0) {\n \n require(\n abi.decode(returndata, (bool)),\n \"SafeERC20: ERC20 operation did not succeed\"\n );\n }\n }", "function updateFeeWallet(address payable _feeWallet) external onlyOwner {\n require(_feeWallet != address(0), \"fee wallet zero address\");\n _FEE_WALLET_ADDR_ = _feeWallet;\n emit FeeWalletUpdated(_FEE_WALLET_ADDR_);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arken.Finance Bridge", "functions": ["function updateWETH(address _weth) external onlyOwner {\n require(_weth != address(0), \"WETH zero address\");\n _WETH_ = _weth;\n emit WETHUpdated(_WETH_);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arken.Finance Bridge", "functions": ["function updateWETHDfyn(address _weth_dfyn) external onlyOwner {\n require(_weth_dfyn != address(0), \"WETH dfyn zero address\");\n _WETH_DFYN_ = _weth_dfyn;\n emit WETHDfynUpdated(_WETH_DFYN_);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arken.Finance Bridge", "functions": ["function updateDODOApproveAddress(\n address _dodoApproveAddress\n ) external onlyOwner {\n require(_dodoApproveAddress != address(0), \"dodo approve zero address\");\n _DODO_APPROVE_ADDR_ = _dodoApproveAddress;\n emit DODOApproveUpdated(_DODO_APPROVE_ADDR_);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Arken.Finance Bridge", "functions": ["function updateArkenApprove(address _arkenApprove) external onlyOwner {\n require(_arkenApprove != address(0), \"arken approve zero address\");\n _ARKEN_APPROVE_ = _arkenApprove;\n emit ArkenApproveUpdated(_ARKEN_APPROVE_);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Boba Gateway bridge", "functions": ["function enqueue(\n address _target,\n uint256 _gasLimit,\n bytes memory _data\n ) external {\n require(\n _data.length <= MAX_ROLLUP_TX_SIZE,\n \"Transaction data size exceeds maximum for rollup transaction.\"\n );\n require(\n _gasLimit <= maxTransactionGasLimit,\n \"Transaction gas limit exceeds maximum for rollup transaction.\"\n );\n require(\n _gasLimit >= MIN_ROLLUP_TX_GAS,\n \"Transaction gas limit too low to enqueue.\"\n );\n \n \n \n \n \n \n \n \n \n \n \n \n if (_gasLimit > enqueueL2GasPrepaid) {\n uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) /\n l2GasDiscountDivisor;\n uint256 startingGas = gasleft();\n \n \n require(\n startingGas > gasToConsume,\n \"Insufficient gas for L2 rate limiting burn.\"\n );\n uint256 i;\n while (startingGas - gasleft() < gasToConsume) {\n i++;\n }\n }\n \n \n \n \n \n address sender;\n if (msg.sender == tx.origin) {\n sender = msg.sender;\n } else {\n sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n }\n bytes32 transactionHash = keccak256(\n abi.encode(sender, _target, _gasLimit, _data)\n );\n queueElements.push(\n Lib_OVMCodec.QueueElement({\n transactionHash: transactionHash,\n timestamp: uint40(block.timestamp),\n blockNumber: uint40(block.number)\n })\n );\n uint256 queueIndex = queueElements.length - 1;\n emit TransactionEnqueued(\n sender,\n _target,\n _gasLimit,\n _data,\n queueIndex,\n block.timestamp\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Boba Gateway bridge", "functions": ["function appendSequencerBatch() external {\n uint40 shouldStartAtElement;\n uint24 totalElementsToAppend;\n uint24 numContexts;\n assembly {\n shouldStartAtElement := shr(216, calldataload(4))\n totalElementsToAppend := shr(232, calldataload(9))\n numContexts := shr(232, calldataload(12))\n }\n require(\n shouldStartAtElement == getTotalElements(),\n \"Actual batch start index does not match expected start index.\"\n );\n require(\n msg.sender == resolve(\"OVM_Sequencer\"),\n \"Function can only be called by the Sequencer.\"\n );\n uint40 nextTransactionPtr = uint40(\n BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts\n );\n require(\n msg.data.length >= nextTransactionPtr,\n \"Not enough BatchContexts provided.\"\n );\n \n uint32 numSequencerTransactions = 0;\n \n \n \n uint40 nextQueueIndex = _nextQueueIndex;\n BatchContext memory curContext;\n for (uint32 i = 0; i < numContexts; i++) {\n BatchContext memory nextContext = _getBatchContext(i);\n \n curContext = nextContext;\n \n numSequencerTransactions += uint32(\n curContext.numSequencedTransactions\n );\n \n nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);\n }\n require(\n nextQueueIndex <= queueElements.length,\n \"Attempted to append more elements than are available in the queue.\"\n );\n \n uint40 numQueuedTransactions = totalElementsToAppend -\n numSequencerTransactions;\n uint40 blockTimestamp;\n uint40 blockNumber;\n if (curContext.numSubsequentQueueTransactions == 0) {\n \n \n blockTimestamp = uint40(curContext.timestamp);\n blockNumber = uint40(curContext.blockNumber);\n } else {\n \n \n \n \n \n Lib_OVMCodec.QueueElement memory lastElement = queueElements[\n nextQueueIndex - 1\n ];\n blockTimestamp = lastElement.timestamp;\n blockNumber = lastElement.blockNumber;\n }\n \n _appendBatch(\n blockhash(block.number - 1),\n totalElementsToAppend,\n numQueuedTransactions,\n blockTimestamp,\n blockNumber\n );\n emit SequencerBatchAppended(\n nextQueueIndex - numQueuedTransactions,\n numQueuedTransactions,\n getTotalElements()\n );\n \n _nextQueueIndex = nextQueueIndex;\n }", "function _appendBatch(\n bytes32 _transactionRoot,\n uint256 _batchSize,\n uint256 _numQueuedTransactions,\n uint40 _timestamp,\n uint40 _blockNumber\n ) internal {\n IChainStorageContainer batchesRef = batches();\n (\n uint40 totalElements,\n uint40 nextQueueIndex,\n ,\n ) = _getBatchExtraData();\n Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec\n .ChainBatchHeader({\n batchIndex: batchesRef.length(),\n batchRoot: _transactionRoot,\n batchSize: _batchSize,\n prevTotalElements: totalElements,\n extraData: hex\"\"\n });\n emit TransactionBatchAppended(\n header.batchIndex,\n header.batchRoot,\n header.batchSize,\n header.prevTotalElements,\n header.extraData\n );\n bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\n bytes27 latestBatchContext = _makeBatchExtraData(\n totalElements + uint40(header.batchSize),\n nextQueueIndex + uint40(_numQueuedTransactions),\n _timestamp,\n _blockNumber\n );\n batchesRef.push(batchHeaderHash, latestBatchContext);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_1", "functions": ["function lockTokens(uint256 _bridgedAmount) public onlyGateway {\n IERC20(ethToken).burn(msg.sender, _bridgedAmount);\n emit TokensLocked(msg.sender, _bridgedAmount, block.timestamp);\n }", "function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _beforeTokenTransfer(account, address(0), amount);\n uint256 accountBalance = _balances[account];\n require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n unchecked {\n _balances[account] = accountBalance - amount;\n }\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n _afterTokenTransfer(account, address(0), amount);\n }", "function bridgeTokens(\n address _requester,\n uint aaamount\n ) external onlyGateway verifyInitialization {\n IERC20(bnbToken).mint(_requester, aaamount);\n emit TokensBridged(_requester, aaamount, block.timestamp);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n _totalSupply += amount;\n _balances[account] += amount;\n emit Transfer(address(0), account, amount);\n _afterTokenTransfer(address(0), account, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_10", "functions": ["function swap(\n address recepient,\n uint256 amount,\n address erc20from,\n uint256 chainIdto,\n address erc20to\n ) external isBridgeValid(erc20from, chainIdto, erc20to) {\n IExampleToken(erc20from).burn(msg.sender, amount);\n nonce += 1;\n emit SwapInitialized(\n msg.sender,\n recepient,\n amount,\n getChainID(),\n erc20from,\n chainIdto,\n erc20to,\n nonce\n );\n }", "function burn(\n address account,\n uint256 amount\n ) public onlyRole(BURNER_ROLE) enoughTokens(account, amount) {\n balances[account] -= amount;\n totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }", "modifier isBridgeValid(\n address erc20from,\n uint256 chainIdto,\n address erc20to\n ) {\n require(\n isERC20valid[getChainID()][erc20from],\n \"ERC20 address from is not valid\"\n );\n require(\n isERC20valid[chainIdto][erc20to],\n \"Chain id or ERC20 address to is not valid\"\n );\n _;\n }", "function getChainID() public view returns (uint256) {\n uint256 id;\n assembly {\n id := chainid()\n }\n return id;\n }", "function redeem(\n address recepient,\n uint256 amount,\n uint256 chainIdfrom,\n address erc20from,\n address erc20to,\n uint256 nonce,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external {\n require(\n isERC20valid[chainIdfrom][erc20from],\n \"Chain id or ERC20 address from is not valid\"\n );\n require(\n isERC20valid[getChainID()][erc20to],\n \"ERC20 on this chain is not valid\"\n );\n require(\n checkSign(\n recepient,\n amount,\n chainIdfrom,\n erc20from,\n nonce,\n v,\n r,\n s\n ),\n \"Input is not valid\"\n );\n bytes32 redeemHash = keccak256(\n abi.encodePacked(\n recepient,\n amount,\n chainIdfrom,\n erc20from,\n nonce,\n v,\n r,\n s\n )\n );\n redeemStatus[redeemHash] = Status.Undone;\n require(redeemStatus[redeemHash] == Status.Undone, \"Hash is not valid\");\n redeemStatus[redeemHash] = Status.Done;\n IExampleToken(erc20to).mint(recepient, amount);\n emit RedeemInitialized(\n recepient,\n amount,\n erc20to,\n chainIdfrom,\n erc20from,\n nonce\n );\n }", "function checkSign(\n address recepient,\n uint256 amount,\n uint256 chainIdfrom,\n address erc20from,\n uint256 nonce,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public view returns (bool) {\n bytes32 message = keccak256(\n abi.encodePacked(recepient, amount, chainIdfrom, erc20from, nonce)\n );\n address function hashMessage(...) {...}\naddr = ecrecover(hashMessage(message), v, r, s);\n if (addr == validator) {\n return true;\n } else {\n return false;\n }\n }", "function hashMessage(bytes32 message) private pure returns (bytes32) {\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n return keccak256(abi.encodePacked(prefix, message));\n }", "function mint(\n address account,\n uint256 amount\n ) public onlyRole(MINTER_ROLE) {\n balances[account] += amount;\n totalSupply += amount;\n emit Transfer(address(0), account, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_12", "functions": ["function burn(address owner, uint amount) external {\n require(msg.sender == admin, \"only admin\");\n _burn(owner, amount);\n }", "function mint(address to, uint amount) external {\n require(msg.sender == admin, \"only admin\");\n _mint(to, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_15", "functions": ["function proposeTransaction(\n address sender,\n address receiver,\n uint amount,\n address[] memory potentialSigners,\n address proposer,\n bytes calldata signature\n ) public {\n \n bytes32 message = prefixed(\n keccak256(abi.encodePacked(sender, receiver, amount))\n );\n require(\n recoverSigner(message, signature) == proposer,\n \"Signature Error: Not Signed by the Proposer\"\n );\n \n require(\n potentialSigners.length == 3,\n \"Three potential signers are required\"\n );\n \n transactions[message] = Transaction(\n potentialSigners,\n new address[](0),\n sender,\n receiver,\n amount\n );\n \n transactions[message].signers.push(msg.sender);\n \n emit Proposed(sender, receiver, amount, proposer, signature);\n }", "function prefixed(bytes32 hash) internal pure returns (bytes32) {\n return\n keccak256(\n abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n );\n }", "function recoverSigner(\n bytes32 message,\n bytes memory sig\n ) internal pure returns (address) {\n uint8 v;\n bytes32 r;\n bytes32 s;\n function splitSignature(...) {...}\n(v, r, s) = splitSignature(sig);\n return ecrecover(message, v, r, s);\n }", "function splitSignature(\n bytes memory sig\n ) internal pure returns (uint8, bytes32, bytes32) {\n require(sig.length == 65);\n bytes32 r;\n bytes32 s;\n uint8 v;\n assembly {\n \n r := mload(add(sig, 32))\n \n s := mload(add(sig, 64))\n \n v := byte(0, mload(add(sig, 96)))\n }\n return (v, r, s);\n }", "function confirmTransaction(\n address sender,\n address receiver,\n uint amount,\n address signer,\n bytes memory signature\n ) public {\n \n \n bytes32 message = prefixed(\n keccak256(abi.encodePacked(sender, receiver, amount))\n );\n require(\n recoverSigner(message, signature) == signer,\n \"Signature Error: Not Signed by the Sender\"\n );\n \n \n require(\n addressExists(transactions[message].potentialSigners, signer),\n \"Provided Address is not a potential signer for this transaction\"\n );\n \n require(\n !addressExists(transactions[message].signers, signer),\n \"Sender has already signed this transaction\"\n );\n \n transactions[message].signers.push(signer);\n \n emit Confirmed(sender, receiver, amount, signer, signature);\n if (transactions[message].signers.length >= 2) {\n Transaction memory trx = transactions[message];\n burn(trx.sender, trx.receiver, trx.amount);\n }\n }", "function addressExists(\n address[] memory _arr,\n address _address\n ) internal view returns (bool) {\n for (uint256 i = 0; i < _arr.length; i++) {\n if (_arr[i] == _address) {\n return true;\n }\n }\n return false;\n }", "function prefixed(bytes32 hash) internal pure returns (bytes32) {\n return\n keccak256(\n abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n );\n }", "function recoverSigner(\n bytes32 message,\n bytes memory sig\n ) internal pure returns (address) {\n uint8 v;\n bytes32 r;\n bytes32 s;\n function splitSignature(...) {...}\n(v, r, s) = splitSignature(sig);\n return ecrecover(message, v, r, s);\n }", "function splitSignature(\n bytes memory sig\n ) internal pure returns (uint8, bytes32, bytes32) {\n require(sig.length == 65);\n bytes32 r;\n bytes32 s;\n uint8 v;\n assembly {\n \n r := mload(add(sig, 32))\n \n s := mload(add(sig, 64))\n \n v := byte(0, mload(add(sig, 96)))\n }\n return (v, r, s);\n }", "function burn(address from, address to, uint256 amount) internal {\n function burn(...) {...}\ntoken.burn(from, amount);\n emit Transfer(from, to, amount, Step.Burn);\n }", "function mint(address from, address to, uint256 amount) external {\n function mint(...) {...}\ntoken.mint(to, amount);\n \n emit Transfer(from, to, amount, Step.Mint);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_15", "functions": ["function burn(address from, address to, uint256 amount) internal {\n function burn(...) {...}\ntoken.burn(from, amount);\n emit Transfer(from, to, amount, Step.Burn);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_16", "functions": ["function burn(address to, uint amount) external {\n function burn(...) {...}\ntoken.burn(msg.sender, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n nonce,\n Step.Burn\n );\n nonce++;\n }", "function mint(address to, uint amount, uint otherChainNonce) external {\n require(msg.sender == admin, \"only admin\");\n require(\n processedNonces[otherChainNonce] == false,\n \"transfer already processed\"\n );\n processedNonces[otherChainNonce] = true;\n function mint(...) {...}\ntoken.mint(to, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n otherChainNonce,\n Step.Mint\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_16", "functions": ["function mint(address to, uint amount, uint otherChainNonce) external {\n require(msg.sender == admin, \"only admin\");\n require(\n processedNonces[otherChainNonce] == false,\n \"transfer already processed\"\n );\n processedNonces[otherChainNonce] = true;\n function mint(...) {...}\ntoken.mint(to, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n otherChainNonce,\n Step.Mint\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_16", "functions": ["function burn(address to, uint amount) external {\n function burn(...) {...}\ntoken.burn(msg.sender, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n nonce,\n Step.Burn\n );\n nonce++;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_2", "functions": ["function swap(\n address _tokenFrom,\n address _tokenTo,\n uint256 _amount,\n uint256 _chainId\n ) external {\n if (_tokenFrom == address(0x0) || _tokenTo == address(0x0))\n revert ZeroAddress();\n if (!chains[block.chainid].tokens[_tokenFrom])\n revert IncorrectAction(_tokenFrom, false);\n if (!chains[_chainId].tokens[_tokenTo])\n revert IncorrectAction(_tokenTo, false);\n _nonce++;\n ITokenForBridge(_tokenFrom).burn(msg.sender, _amount);\n emit Swap(_tokenTo, msg.sender, _amount, _nonce);\n }", "function burn(uint256 _tokenId) public {\n require(msg.sender == ownerOf(_tokenId), \"not owner of the token\");\n uint256 amount = auraAmounts[_tokenId];\n auraAmounts[_tokenId] = 0;\n IERC20(auraAddress).transfer(msg.sender, amount);\n _burn(_tokenId);\n }", "function reedem(\n address _tokenTo,\n address _to,\n uint256 _amount,\n uint256 _nonce_,\n bytes memory _signature\n ) external {\n bytes32 signedHash = keccak256(\n abi.encodePacked(_tokenTo, _to, _amount, _nonce_)\n );\n bytes32 messageHash = signedHash.toEthSignedMessageHash();\n address messageSender = messageHash.recover(_signature);\n if (messageSender != validator) revert IncorrectSignature();\n ITokenForBridge(_tokenTo).mint(_to, _amount);\n }", "function mint(uint256 _amount) public {\n require(_amount > 0, \"invalid amount\");\n uint256 tokenId = _tokenIdCounter.current();\n IERC20(auraAddress).transferFrom(msg.sender, address(this), _amount);\n _safeMint(msg.sender, tokenId);\n auraAmounts[tokenId] = _amount;\n _tokenIdCounter.increment();\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_3", "functions": ["function Burn(\n address to,\n uint256 amount,\n uint256 nonce,\n bytes calldata signature\n ) external {\n transfers[msg.sender] = transfers[msg.sender] + 1;\n token.burn(msg.sender, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n nonce,\n signature,\n Type.BURN\n );\n }", "function burn(address _owner, uint256 _amount) external {\n require(msg.sender == bridge, \"Only admin\");\n _burn(_owner, _amount);\n }", "function Mint(\n address from,\n address to,\n uint256 amount,\n uint256 nonce,\n bytes calldata signature\n ) external {\n bytes32 messageHash = keccak256(abi.encodePacked(to, amount, nonce));\n bytes32 message = ECDSA.toEthSignedMessageHash(messageHash);\n address signer = ECDSA.recover(message, signature);\n require(signer == from, \"incorret Signature\");\n uint256 id = transfers[to];\n hasProcessed[to][id] = true;\n token.mint(to, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n nonce,\n signature,\n Type.MINT\n );\n }", "function mint(address _to, uint256 _amount) external {\n require(msg.sender == bridge, \"Only admin\");\n _mint(_to, _amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_3", "functions": ["function Mint(\n address from,\n address to,\n uint256 amount,\n uint256 nonce,\n bytes calldata signature\n ) external {\n bytes32 messageHash = keccak256(abi.encodePacked(to, amount, nonce));\n bytes32 message = ECDSA.toEthSignedMessageHash(messageHash);\n address signer = ECDSA.recover(message, signature);\n require(signer == from, \"incorret Signature\");\n uint256 id = transfers[to];\n hasProcessed[to][id] = true;\n token.mint(to, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n nonce,\n signature,\n Type.MINT\n );\n }", "function mint(address _to, uint256 _amount) external {\n require(msg.sender == bridge, \"Only admin\");\n _mint(_to, _amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_3", "functions": ["function Burn(\n address to,\n uint256 amount,\n uint256 nonce,\n bytes calldata signature\n ) external {\n transfers[msg.sender] = transfers[msg.sender] + 1;\n token.burn(msg.sender, amount);\n emit Transfer(\n msg.sender,\n to,\n amount,\n block.timestamp,\n nonce,\n signature,\n Type.BURN\n );\n }", "function burn(address _owner, uint256 _amount) external {\n require(msg.sender == bridge, \"Only admin\");\n _burn(_owner, _amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_4", "functions": ["function swap(\n address receiver,\n uint256 amount,\n uint256 chainTo,\n uint256 nonce,\n string memory symbol\n ) external nonReentrant checkNonce(nonce) TokenSupported(symbol) {\n require(\n supportedChains[thisChainId] == true &&\n supportedChains[chainTo] == true,\n \"Bridge: One of the blockchains isn't supported\"\n );\n IERC20(supportedTokens[symbol]).burnFrom(msg.sender, amount);\n usersNonces[msg.sender][nonce] = true;\n emit SwapInitilaized(\n receiver,\n supportedTokens[symbol],\n amount,\n nonce,\n block.timestamp,\n thisChainId,\n chainTo\n );\n }", "function redeem(\n address receiver,\n string memory symbol,\n uint256 amount,\n uint256 nonce,\n uint256 chainTo,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external nonReentrant checkNonce(nonce) TokenSupported(symbol) {\n require(\n receiver == msg.sender,\n \"Only the receiver can collect the tokens\"\n );\n require(\n chainTo == thisChainId,\n \"This transaction is for another chain\"\n );\n bytes32 signedDataHash = keccak256(\n abi.encode(\n receiver,\n supportedTokens[symbol],\n amount,\n nonce,\n chainTo\n )\n );\n bytes32 message = signedDataHash.toEthSignedMessageHash();\n address signer = message.recover(v, r, s);\n require(hasRole(VALIDATOR_ROLE, signer), \"Bridge: invalid sig\");\n IERC20(supportedTokens[symbol]).mint(receiver, amount);\n usersNonces[msg.sender][nonce] = true;\n emit RedeemInitilaized(\n receiver,\n supportedTokens[symbol],\n amount,\n nonce\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_4", "functions": ["function swap(\n address receiver,\n uint256 amount,\n uint256 chainTo,\n uint256 nonce,\n string memory symbol\n ) external nonReentrant checkNonce(nonce) TokenSupported(symbol) {\n require(\n supportedChains[thisChainId] == true &&\n supportedChains[chainTo] == true,\n \"Bridge: One of the blockchains isn't supported\"\n );\n IERC20(supportedTokens[symbol]).burnFrom(msg.sender, amount);\n usersNonces[msg.sender][nonce] = true;\n emit SwapInitilaized(\n receiver,\n supportedTokens[symbol],\n amount,\n nonce,\n thisChainId,\n chainTo\n );\n }", "function redeem(\n address receiver,\n address token,\n uint256 amount,\n uint256 nonce,\n uint256 chainTo,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external nonReentrant checkNonce(nonce) {\n require(\n receiver == msg.sender,\n \"Only the receiver can collect the tokens\"\n );\n require(\n chainTo == thisChainId,\n \"This transaction is for another chain\"\n );\n bytes32 signedDataHash = keccak256(\n abi.encode(receiver, token, chainTo, amount, nonce)\n );\n address signer = signedDataHash.toEthSignedMessageHash().recover(\n v,\n r,\n s\n );\n require(hasRole(VALIDATOR_ROLE, signer), \"Bridge: invalid sig\");\n IERC20(token).mint(receiver, amount);\n usersNonces[receiver][nonce] = true;\n emit RedeemInitilaized(receiver, token, amount, nonce);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_4", "functions": ["function redeem(\n address receiver,\n string memory symbol,\n uint256 amount,\n uint256 nonce,\n uint256 time,\n uint256 chainTo,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external nonReentrant checkNonce(nonce) TokenSupported(symbol) {\n require(receiver == msg.sender, \"Only receiver can call this function\");\n require(\n chainTo == thisChainId,\n \"This transaction is for another chain\"\n );\n bytes32 signedDataHash = keccak256(\n abi.encodePacked(\n receiver,\n supportedTokens[symbol],\n amount,\n nonce,\n time,\n chainTo\n )\n );\n bytes32 message = signedDataHash.toEthSignedMessageHash();\n address signer = message.recover(v, r, s);\n require(hasRole(VALIDATOR_ROLE, signer), \"Bridge: invalid sig\");\n IERC20(supportedTokens[symbol]).mint(receiver, amount);\n usersNonces[msg.sender][nonce] == true;\n emit RedeemInitilaized(\n receiver,\n supportedTokens[symbol],\n amount,\n nonce\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_5", "functions": ["function burn(address to, uint amount, uint nonce, bytes calldata signature) external {\n require(processedNonces[msg.sender][nonce] == false, \"transfer already processed\");\n token._burn(msg.sender, amount);\n emit Transfer(msg.sender, to, amount, block.timestamp, nonce, signature, Step.Burn);\n }", "function mint(address from, address to, uint amount, uint nonce, bytes calldata signature) external {\n function prefixed(...) {...}\nfunction recoverSigner(...) {...}\nbytes32 message = prefixed(keccak256(abi.encodePacked(from, to, amount, nonce)));\n require(recoverSigner(message, signature) == from, \"wrong signature\");\n require(processedNonces[from][nonce] == false, 'transfer already processed');\n processedNonces[from][nonce] = true;\n token._mint(to, amount);\n emit Transfer(msg.sender, to, amount, block.timestamp, nonce, signature, Step.Mint);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_5", "functions": ["function mint(address from, address to, uint amount, uint nonce, bytes calldata signature) external {\n function prefixed(...) {...}\nfunction recoverSigner(...) {...}\nbytes32 message = prefixed(keccak256(abi.encodePacked(from, to, amount, nonce)));\n require(recoverSigner(message, signature) == from, \"wrong signature\");\n require(processedNonces[from][nonce] == false, 'transfer already processed');\n processedNonces[from][nonce] = true;\n token._mint(to, amount);\n emit Transfer(msg.sender, to, amount, block.timestamp, nonce, signature, Step.Mint);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_7", "functions": ["function burn(\n address _to,\n uint256 _amount,\n uint256 _nonce,\n bytes calldata _signature\n ) external validateProcessedNonce(_nonce) {\n \n configToken.burnToken(msg.sender, _amount);\n emit Transfer(\n msg.sender,\n _to,\n _amount,\n _nonce,\n block.timestamp,\n _signature,\n BridgeSteps.BURN\n );\n }", "function burnToken(address _owner, uint256 _amount) external onlyAdmin {\n _burn(_owner, _amount);\n }", "function mint(\n address _from,\n address _to,\n uint256 _amount,\n uint256 _nonce,\n bytes calldata _signature\n ) external {\n \n bytes32 message = prefixed(\n keccak256(abi.encodePacked(_from, _to, _amount, _nonce))\n );\n \n require(recoverSigner(message, _signature) == _from, \"wrong signature\");\n \n require(\n processedTxNonce[_from][_nonce] == false,\n \"transfer has already been processed\"\n );\n processedTxNonce[_from][_nonce] = true;\n configToken.mintToken(_to, _amount);\n emit Transfer(\n _from,\n _to,\n _amount,\n block.timestamp,\n _nonce,\n _signature,\n BridgeSteps.MINT\n );\n }", "function prefixed(bytes32 _hash) internal pure returns (bytes32) {\n return\n keccak256(\n abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)\n );\n }", "function splitSignature(\n bytes memory _signature\n ) internal pure returns (uint8, bytes32, bytes32) {\n \n require(_signature.length == 65, \"invalid signature\");\n uint8 v;\n bytes32 r;\n bytes32 s;\n \n assembly {\n \n r := mload(add(_signature, 32))\n \n s := mload(add(_signature, 64))\n \n v := byte(0, mload(add(_signature, 96)))\n }\n return (v, r, s);\n }", "function mintToken(address _to, uint256 _amount) external onlyAdmin {\n _mint(_to, _amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_8", "functions": ["function _sendCrossChainMessage(\n address destination,\n bytes memory data,\n bytes memory crossChainTxParams\n ) internal virtual override {\n uint256 ticketId = LibArbitrumL1.sendCrossChainMessage(\n _bridge,\n destination,\n data,\n crossChainTxParams\n );\n emit RetryableTicketCreated(ticketId);\n }", "function sendCrossChainMessage(\n address bridge,\n address destination,\n bytes memory data,\n bytes memory crossChainTxParams\n ) internal returns (uint256 ticketId) {\n \n address delayedInbox = ArbitrumL1_Bridge(bridge).allowedInboxList(0);\n CrossChainTxParams memory params = abi.decode(\n crossChainTxParams,\n (CrossChainTxParams)\n );\n if (BRIDGE_ID != params.bridgeId)\n revert InvalidTargetBridge(params.bridgeId, BRIDGE_ID);\n ticketId = ArbitrumL1_Inbox(delayedInbox).createRetryableTicket{\n value: params.depositValue\n }(\n destination,\n params.l2CallValue,\n params.maxSubmissionCost,\n params.excessFeeRefundAddress,\n params.callValueRefundAddress,\n params.maxGas,\n params.gasPriceBid,\n data\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Bridge_9", "functions": ["function burn(address to, uint tokenId) external {\n \n \n _burn(tokenId);\n \n }", "function mint(address to) external {\n \n uint256 tokenId = _tokenIdCounter.current();\n _tokenIdCounter.increment();\n _safeMint(to, tokenId);\n \n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "cBridge", "functions": ["function send(\n address _receiver,\n address _token,\n uint256 _amount,\n uint64 _dstChainId,\n uint64 _nonce,\n uint32 _maxSlippage \n ) external nonReentrant whenNotPaused {\n bytes32 transferId = _send(\n _receiver,\n _token,\n _amount,\n _dstChainId,\n _nonce,\n _maxSlippage\n );\n IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n emit Send(\n transferId,\n msg.sender,\n _receiver,\n _token,\n _amount,\n _dstChainId,\n _nonce,\n _maxSlippage\n );\n }", "function _send(\n address _receiver,\n address _token,\n uint256 _amount,\n uint64 _dstChainId,\n uint64 _nonce,\n uint32 _maxSlippage\n ) private returns (bytes32) {\n require(_amount > minSend[_token], \"amount too small\");\n require(\n maxSend[_token] == 0 || _amount <= maxSend[_token],\n \"amount too large\"\n );\n require(_maxSlippage > minimalMaxSlippage, \"max slippage too small\");\n bytes32 transferId = keccak256(\n \n abi.encodePacked(\n msg.sender,\n _receiver,\n _token,\n _amount,\n _dstChainId,\n _nonce,\n uint64(block.chainid)\n )\n );\n require(transfers[transferId] == false, \"transfer exists\");\n transfers[transferId] = true;\n return transferId;\n }", "function relay(\n bytes calldata _relayRequest,\n bytes[] calldata _sigs,\n address[] calldata _signers,\n uint256[] calldata _powers\n ) external whenNotPaused {\n bytes32 domain = keccak256(\n abi.encodePacked(block.chainid, address(this), \"Relay\")\n );\n verifySigs(\n abi.encodePacked(domain, _relayRequest),\n _sigs,\n _signers,\n _powers\n );\n PbBridge.Relay memory request = PbBridge.decRelay(_relayRequest);\n bytes32 transferId = keccak256(\n abi.encodePacked(\n request.sender,\n request.receiver,\n request.token,\n request.amount,\n request.srcChainId,\n request.dstChainId,\n request.srcTransferId\n )\n );\n require(transfers[transferId] == false, \"transfer exists\");\n transfers[transferId] = true;\n _updateVolume(request.token, request.amount);\n uint256 delayThreshold = delayThresholds[request.token];\n if (delayThreshold > 0 && request.amount > delayThreshold) {\n _addDelayedTransfer(\n transferId,\n request.receiver,\n request.token,\n request.amount\n );\n } else {\n _sendToken(request.receiver, request.token, request.amount);\n }\n emit Relay(\n transferId,\n request.sender,\n request.receiver,\n request.token,\n request.amount,\n request.srcChainId,\n request.srcTransferId\n );\n }", "function withdraw(\n bytes calldata _wdmsg,\n bytes[] calldata _sigs,\n address[] calldata _signers,\n uint256[] calldata _powers\n ) external whenNotPaused {\n bytes32 domain = keccak256(\n abi.encodePacked(block.chainid, address(this), \"WithdrawMsg\")\n );\n verifySigs(abi.encodePacked(domain, _wdmsg), _sigs, _signers, _powers);\n \n PbPool.WithdrawMsg memory wdmsg = PbPool.decWithdrawMsg(_wdmsg);\n bytes32 wdId = keccak256(\n abi.encodePacked(\n wdmsg.chainid,\n wdmsg.seqnum,\n wdmsg.receiver,\n wdmsg.token,\n wdmsg.amount\n )\n );\n require(withdraws[wdId] == false, \"withdraw already succeeded\");\n withdraws[wdId] = true;\n _updateVolume(wdmsg.token, wdmsg.amount);\n uint256 delayThreshold = delayThresholds[wdmsg.token];\n if (delayThreshold > 0 && wdmsg.amount > delayThreshold) {\n _addDelayedTransfer(\n wdId,\n wdmsg.receiver,\n wdmsg.token,\n wdmsg.amount\n );\n } else {\n function _sendToken(...) {...}\n_sendToken(wdmsg.receiver, wdmsg.token, wdmsg.amount);\n }\n emit WithdrawDone(\n wdId,\n wdmsg.seqnum,\n wdmsg.receiver,\n wdmsg.token,\n wdmsg.amount,\n wdmsg.refid\n );\n }", "function _sendToken(\n address _receiver,\n address _token,\n uint256 _amount\n ) internal {\n if (_token == nativeWrap) {\n \n function withdraw(...) {...}\nIWETH(nativeWrap).withdraw(_amount);\n (bool sent, ) = _receiver.call{value: _amount, gas: 50000}(\"\");\n require(sent, \"failed to send native token\");\n } else {\n IERC20(_token).safeTransfer(_receiver, _amount);\n }\n }", "function mint(\n bytes calldata _request,\n bytes[] calldata _sigs,\n address[] calldata _signers,\n uint256[] calldata _powers\n ) external whenNotPaused {\n bytes32 domain = keccak256(\n abi.encodePacked(block.chainid, address(this), \"Mint\")\n );\n sigsVerifier.verifySigs(\n abi.encodePacked(domain, _request),\n _sigs,\n _signers,\n _powers\n );\n PbPegged.Mint memory request = PbPegged.decMint(_request);\n bytes32 mintId = keccak256(\n \n abi.encodePacked(\n request.account,\n request.token,\n request.amount,\n request.depositor,\n request.refChainId,\n request.refId\n )\n );\n require(records[mintId] == false, \"record exists\");\n records[mintId] = true;\n _updateVolume(request.token, request.amount);\n uint256 delayThreshold = delayThresholds[request.token];\n if (delayThreshold > 0 && request.amount > delayThreshold) {\n _addDelayedTransfer(\n mintId,\n request.account,\n request.token,\n request.amount\n );\n } else {\n function mint(...) {...}\nIPeggedToken(request.token).mint(request.account, request.amount);\n }\n emit Mint(\n mintId,\n request.token,\n request.account,\n request.amount,\n request.refChainId,\n request.refId,\n request.depositor\n );\n }", "function _updateVolume(address _token, uint256 _amount) internal {\n if (epochLength == 0) {\n return;\n }\n uint256 cap = epochVolumeCaps[_token];\n if (cap == 0) {\n return;\n }\n uint256 volume = epochVolumes[_token];\n uint256 timestamp = block.timestamp;\n uint256 epochStartTime = (timestamp / epochLength) * epochLength;\n if (lastOpTimestamps[_token] < epochStartTime) {\n volume = _amount;\n } else {\n volume += _amount;\n }\n require(volume <= cap, \"volume exceeds cap\");\n epochVolumes[_token] = volume;\n lastOpTimestamps[_token] = timestamp;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Connext Bridge", "functions": ["function handleIncomingAsset(address _asset, uint256 _amount) internal {\n \n if (_amount == 0) {\n return;\n }\n \n if (_asset == address(0)) {\n revert AssetLogic__handleIncomingAsset_nativeAssetNotSupported();\n }\n IERC20Metadata asset = IERC20Metadata(_asset);\n \n uint256 starting = asset.balanceOf(address(this));\n \n asset.safeTransferFrom(msg.sender, address(this), _amount);\n \n if (asset.balanceOf(address(this)) - starting != _amount) {\n revert AssetLogic__handleIncomingAsset_feeOnTransferNotSupported();\n }\n }", "function safeTransferFrom(\n IERC20 token,\n address from,\n address to,\n uint256 value\n ) internal {\n _callOptionalReturn(\n token,\n abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n );\n }", "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n \n \n \n bytes memory returndata = address(token).functionCall(\n data,\n \"SafeERC20: low-level call failed\"\n );\n if (returndata.length > 0) {\n \n require(\n abi.decode(returndata, (bool)),\n \"SafeERC20: ERC20 operation did not succeed\"\n );\n }\n }", "function handleOutgoingAsset(\n address _asset,\n address _to,\n uint256 _amount\n ) internal {\n \n if (_amount == 0) {\n return;\n }\n \n if (_asset == address(0))\n revert AssetLogic__handleOutgoingAsset_notNative();\n \n SafeERC20.safeTransfer(IERC20Metadata(_asset), _to, _amount);\n }", "function safeTransfer(IERC20 token, address to, uint256 value) internal {\n _callOptionalReturn(\n token,\n abi.encodeWithSelector(token.transfer.selector, to, value)\n );\n }", "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n \n \n \n bytes memory returndata = address(token).functionCall(\n data,\n \"SafeERC20: low-level call failed\"\n );\n if (returndata.length > 0) {\n \n require(\n abi.decode(returndata, (bool)),\n \"SafeERC20: ERC20 operation did not succeed\"\n );\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Connext Bridge", "functions": ["function swapToLocalAssetIfNeeded(\n bytes32 _key,\n address _asset,\n address _local,\n uint256 _amount,\n uint256 _slippage\n ) internal returns (uint256) {\n \n if (_amount == 0) {\n return 0;\n }\n \n if (_local == _asset) {\n return _amount;\n }\n \n TokenConfig storage config = getConfig(_key);\n \n (uint256 out, ) = _swapAsset(\n _key,\n _asset,\n _local,\n _amount,\n calculateSlippageBoundary(\n config.adoptedDecimals,\n config.representationDecimals,\n _amount,\n _slippage\n )\n );\n return out;\n }", "function calculateSlippageBoundary(\n uint8 _in,\n uint8 _out,\n uint256 _amountIn,\n uint256 _slippage\n ) internal pure returns (uint256) {\n if (_amountIn == 0) {\n return 0;\n }\n \n uint256 min = (_amountIn *\n (Constants.BPS_FEE_DENOMINATOR - _slippage)) /\n Constants.BPS_FEE_DENOMINATOR;\n return normalizeDecimals(_in, _out, min);\n }", "function normalizeDecimals(\n uint8 _in,\n uint8 _out,\n uint256 _amount\n ) internal pure returns (uint256) {\n if (_in == _out) {\n return _amount;\n }\n \n uint256 normalized;\n if (_in < _out) {\n normalized = _amount * (10 ** (_out - _in));\n } else {\n normalized = _amount / (10 ** (_in - _out));\n }\n return normalized;\n }", "function swapFromLocalAssetIfNeeded(\n bytes32 _key,\n address _asset,\n uint256 _amount,\n uint256 _slippage,\n uint256 _normalizedIn\n ) internal returns (uint256, address) {\n \n TokenConfig storage config = getConfig(_key);\n address adopted = config.adopted;\n \n if (adopted == _asset) {\n return (_amount, adopted);\n }\n \n if (_amount == 0) {\n return (_amount, adopted);\n }\n \n return\n _swapAsset(\n _key,\n _asset,\n adopted,\n _amount,\n \n \n \n calculateSlippageBoundary(\n Constants.DEFAULT_NORMALIZED_DECIMALS,\n config.adoptedDecimals,\n _normalizedIn,\n _slippage\n )\n );\n }", "function calculateSlippageBoundary(\n uint8 _in,\n uint8 _out,\n uint256 _amountIn,\n uint256 _slippage\n ) internal pure returns (uint256) {\n if (_amountIn == 0) {\n return 0;\n }\n \n uint256 min = (_amountIn *\n (Constants.BPS_FEE_DENOMINATOR - _slippage)) /\n Constants.BPS_FEE_DENOMINATOR;\n return normalizeDecimals(_in, _out, min);\n }", "function normalizeDecimals(\n uint8 _in,\n uint8 _out,\n uint256 _amount\n ) internal pure returns (uint256) {\n if (_in == _out) {\n return _amount;\n }\n \n uint256 normalized;\n if (_in < _out) {\n normalized = _amount * (10 ** (_out - _in));\n } else {\n normalized = _amount / (10 ** (_in - _out));\n }\n return normalized;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Counterstake Bridge", "functions": ["function transferToForeignChain(\n string memory foreign_address,\n string memory data,\n uint amount,\n int reward\n ) external payable nonReentrant {\n function receiveStakeAsset(...) {...}\nreceiveStakeAsset(amount);\n if (reward >= 0) require(uint(reward) < amount, \"reward too big\");\n emit NewExpatriation(msg.sender, amount, reward, foreign_address, data);\n }", "function receiveStakeAsset(uint stake_asset_amount) internal {\n if (settings.tokenAddress == address(0))\n require(msg.value == stake_asset_amount, \"wrong amount received\");\n else {\n require(msg.value == 0, \"don't send ETH\");\n IERC20(settings.tokenAddress).safeTransferFrom(\n msg.sender,\n address(this),\n stake_asset_amount\n );\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Counterstake Bridge", "functions": ["function claim(\n Settings storage settings,\n mapping(string => uint) storage claim_nums,\n mapping(uint => Claim) storage claims,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n ClaimRequest memory req\n ) external {\n require(req.amount > 0, \"0 claim\");\n require(req.stake >= req.required_stake, \"the stake is too small\");\n require(block.timestamp >= req.txts + settings.min_tx_age, \"too early\");\n if (req.recipient_address == address(0))\n req.recipient_address = payable(msg.sender);\n if (req.reward < 0)\n require(\n req.recipient_address == payable(msg.sender),\n \"the sender disallowed third-party claiming by setting a negative reward\"\n );\n string memory claim_id = getClaimId(\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.data\n );\n require(\n claim_nums[claim_id] == 0,\n \"this transfer has already been claimed\"\n );\n bool is_large = (settings.large_threshold > 0 &&\n req.stake >= settings.large_threshold);\n uint32 expiry_ts = uint32(\n block.timestamp + getChallengingPeriod(settings, 0, is_large)\n ); \n claim_nums[claim_id] = claim_num;\n \n claims[claim_num] = Claim({\n amount: req.amount,\n \n recipient_address: req.recipient_address,\n claimant_address: payable(msg.sender),\n sender_address: req.sender_address,\n \n data: req.data,\n yes_stake: req.stake,\n no_stake: 0,\n current_outcome: Side.yes,\n is_large: is_large,\n period_number: 0,\n txts: req.txts,\n ts: uint32(block.timestamp),\n expiry_ts: expiry_ts,\n \n withdrawn: false,\n finished: false\n });\n stakes[claim_num][Side.yes][msg.sender] = req.stake;\n emit NewClaim(\n claim_num,\n msg.sender,\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.stake,\n req.data,\n expiry_ts\n );\n \n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Counterstake Bridge", "functions": ["function claim(\n Settings storage settings,\n mapping(string => uint) storage claim_nums,\n mapping(uint => Claim) storage claims,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n ClaimRequest memory req\n ) external {\n require(req.amount > 0, \"0 claim\");\n require(req.stake >= req.required_stake, \"the stake is too small\");\n require(block.timestamp >= req.txts + settings.min_tx_age, \"too early\");\n if (req.recipient_address == address(0))\n req.recipient_address = payable(msg.sender);\n if (req.reward < 0)\n require(\n req.recipient_address == payable(msg.sender),\n \"the sender disallowed third-party claiming by setting a negative reward\"\n );\n string memory claim_id = getClaimId(\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.data\n );\n require(\n claim_nums[claim_id] == 0,\n \"this transfer has already been claimed\"\n );\n bool is_large = (settings.large_threshold > 0 &&\n req.stake >= settings.large_threshold);\n uint32 expiry_ts = uint32(\n block.timestamp + getChallengingPeriod(settings, 0, is_large)\n ); \n claim_nums[claim_id] = claim_num;\n \n claims[claim_num] = Claim({\n amount: req.amount,\n \n recipient_address: req.recipient_address,\n claimant_address: payable(msg.sender),\n sender_address: req.sender_address,\n \n data: req.data,\n yes_stake: req.stake,\n no_stake: 0,\n current_outcome: Side.yes,\n is_large: is_large,\n period_number: 0,\n txts: req.txts,\n ts: uint32(block.timestamp),\n expiry_ts: expiry_ts,\n \n withdrawn: false,\n finished: false\n });\n stakes[claim_num][Side.yes][msg.sender] = req.stake;\n emit NewClaim(\n claim_num,\n msg.sender,\n req.sender_address,\n req.recipient_address,\n req.txid,\n req.txts,\n req.amount,\n req.reward,\n req.stake,\n req.data,\n expiry_ts\n );\n \n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Counterstake Bridge", "functions": ["function challenge(\n Settings storage settings,\n Claim storage c,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n Side stake_on,\n uint stake\n ) external {\n require(\n block.timestamp < c.expiry_ts,\n \"the challenging period has expired\"\n );\n require(\n stake_on != c.current_outcome,\n \"this outcome is already current\"\n );\n uint excess;\n uint challenging_target = ((\n c.current_outcome == Side.yes ? c.yes_stake : c.no_stake\n ) * settings.counterstake_coef100) / 100;\n {\n \n uint stake_on_proposed_outcome = (\n stake_on == Side.yes ? c.yes_stake : c.no_stake\n ) + stake;\n bool would_override_current_outcome = stake_on_proposed_outcome >=\n challenging_target;\n excess = would_override_current_outcome\n ? stake_on_proposed_outcome - challenging_target\n : 0;\n uint accepted_stake = stake - excess;\n if (stake_on == Side.yes) c.yes_stake += accepted_stake;\n else c.no_stake += accepted_stake;\n if (would_override_current_outcome) {\n c.period_number++;\n c.current_outcome = stake_on;\n c.expiry_ts = uint32(\n block.timestamp +\n getChallengingPeriod(\n settings,\n c.period_number,\n c.is_large\n )\n );\n challenging_target =\n (challenging_target * settings.counterstake_coef100) /\n 100;\n }\n stakes[claim_num][stake_on][msg.sender] += accepted_stake;\n }\n emit NewChallenge(\n claim_num,\n msg.sender,\n stake,\n stake_on,\n c.current_outcome,\n c.yes_stake,\n c.no_stake,\n c.expiry_ts,\n challenging_target\n );\n if (excess > 0) {\n if (settings.tokenAddress == address(0))\n payable(msg.sender).transfer(excess);\n else IERC20(settings.tokenAddress).safeTransfer(msg.sender, excess);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Counterstake Bridge", "functions": ["function finish(\n Claim storage c,\n mapping(uint => mapping(Side => mapping(address => uint)))\n storage stakes,\n uint claim_num,\n address payable to_address\n ) external returns (bool, bool, uint) {\n require(\n block.timestamp > c.expiry_ts,\n \"challenging period is still ongoing\"\n );\n if (to_address == address(0)) to_address = payable(msg.sender);\n bool is_winning_claimant = (to_address == c.claimant_address &&\n c.current_outcome == Side.yes);\n require(!(is_winning_claimant && c.withdrawn), \"already withdrawn\");\n uint won_stake;\n {\n \n uint my_stake = stakes[claim_num][c.current_outcome][to_address];\n require(\n my_stake > 0 || is_winning_claimant,\n \"you are not the recipient and you didn't stake on the winning outcome or you have already withdrawn\"\n );\n uint winning_stake = c.current_outcome == Side.yes\n ? c.yes_stake\n : c.no_stake;\n if (my_stake > 0)\n won_stake =\n ((c.yes_stake + c.no_stake) * my_stake) /\n winning_stake;\n }\n if (is_winning_claimant) c.withdrawn = true;\n bool finished;\n if (!c.finished) {\n finished = true;\n c.finished = true;\n \n \n emit FinishedClaim(claim_num, c.current_outcome);\n }\n delete stakes[claim_num][c.current_outcome][to_address];\n return (finished, is_winning_claimant, won_stake);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Cross-Chain Bridge", "functions": ["function depositERC20(\n IERC20 token,\n uint256 amount,\n address receiverAddress,\n uint256 targetChainId\n ) public nonReentrant {\n \n uint256 balanceBefore = token.balanceOf(address(this));\n \n token.safeTransferFrom(_msgSender(), address(this), amount);\n \n require(\n token.balanceOf(address(this)) == balanceBefore + amount,\n \"CrossChainBridgeERC20: deposited token amount incorrect\"\n );\n \n _depositERC20(token, amount, receiverAddress, targetChainId);\n }", "function _depositERC20(\n IERC20 token,\n uint256 amount,\n address receiverAddress,\n uint256 targetChainId\n ) private whenNotPaused {\n \n require(amount > 0, \"CrossChainBridgeERC20: amount cannot be 0\");\n require(\n receiverAddress != address(0),\n \"CrossChainBridgeERC20: invalid receiverAddress provided\"\n );\n require(\n address(token) != address(0),\n \"CrossChainBridgeERC20: invalid token address provided\"\n );\n (bool exists, ) = liquidityManager.lpTokens(address(token));\n if (!exists) {\n \n liquidityManager.createPool(address(token));\n }\n \n \n depositCount = depositCount + 1;\n \n emit TokensDeposited(\n address(token),\n amount,\n receiverAddress,\n _getChainID(),\n targetChainId,\n depositCount\n );\n }", "function createPool(address tokenAddress) external override returns (bool) {\n require(\n _msgSender() == address(bridgeERC20),\n \"LiquidityManager: this function can only be called by the ERC20 bridge\"\n );\n return _createPool(tokenAddress);\n }", "function _createPool(\n address tokenAddress\n ) private whenNotPaused returns (bool) {\n require(\n !lpTokens[tokenAddress].exists,\n \"LiquidityManager: a pool already exists for this token\"\n );\n \n lpTokens[tokenAddress] = LPToken({\n exists: true,\n token: new MintableERC20(\"Cross-Chain Bridge LPs\", \"Bridge-LP\")\n });\n \n require(\n bridgeERC20.registerTokenTransferApprovals(tokenAddress),\n \"LiquidityManager: error while registering approvals\"\n );\n emit LiquidityPoolCreated(\n tokenAddress,\n address(lpTokens[tokenAddress].token)\n );\n return true;\n }", "function _releaseERC20(\n uint8[] memory sigV,\n bytes32[] memory sigR,\n bytes32[] memory sigS,\n address receiverAddress,\n address sourceNetworkTokenAddress,\n uint256 amount,\n uint256 depositChainId,\n uint256 depositNumber,\n bool keepTokensInBridge\n ) private whenNotPaused returns (uint256 releaseAmountAfterFees) {\n \n require(\n !releasedDeposits[depositChainId][depositNumber],\n \"CrossChainBridgeERC20: Deposit was already processed and released\"\n );\n require(\n receiverAddress != address(0),\n \"CrossChainBridgeERC20: invalid receiverAddress provided\"\n );\n require(\n sourceNetworkTokenAddress != address(0),\n \"CrossChainBridgeERC20: invalid sourceNetworkTokenAddress provided\"\n );\n require(amount > 0, \"CrossChainBridgeERC20: amount cannot be 0\");\n \n require(\n multiSignatureOracle.signaturesCheckERC20(\n sigV,\n sigR,\n sigS,\n receiverAddress,\n sourceNetworkTokenAddress,\n amount,\n depositChainId,\n depositNumber\n ),\n \"CrossChainBridgeERC20: Release not permitted. Not enough signatures from permitted oracles\"\n );\n \n \n address releaseChainTokenAddress = sourceNetworkTokenAddress;\n \n if (outsidePeggedTokens[sourceNetworkTokenAddress] != address(0)) {\n releaseChainTokenAddress = outsidePeggedTokens[\n sourceNetworkTokenAddress\n ];\n }\n IERC20 token = ERC20(releaseChainTokenAddress);\n \n require(\n token.balanceOf(address(this)) >= amount,\n \"CrossChainBridgeERC20: Not enough liquidity in bridge\"\n );\n \n \n uint256 relativeFee = bridgeFees[releaseChainTokenAddress] > 0\n ? bridgeFees[releaseChainTokenAddress]\n : defaultBridgeFee;\n \n \n uint256 bridgingFee = (amount * relativeFee) / 1000000;\n \n uint256 bridgingFeeToCollectAddress = (bridgingFee *\n collectBridgeFeePercentage) / 1000000;\n \n uint256 bridgingFeeToLiquidityMining = (bridgingFee *\n liquidityMiningFeePercentage) / 1000000;\n \n uint256 bridgingFeeToRewardPool = bridgingFee -\n bridgingFeeToCollectAddress -\n bridgingFeeToLiquidityMining;\n \n releasedDeposits[depositChainId][depositNumber] = true;\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(buyBackAndBurn)\n ] += bridgingFeeToCollectAddress;\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] += bridgingFeeToLiquidityMining;\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] += bridgingFeeToRewardPool;\n \n if (\n lastTransferBlock[releaseChainTokenAddress][address(rewardPools)] +\n blocksBetweenFeeTransfersToRewardPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] >\n 0\n ) {\n \n rewardPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(rewardPools)\n ] = block.number;\n } else if (\n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] +\n blocksBetweenFeeTransfersToLiquidityMiningPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] >\n 0\n ) {\n \n \n liquidityMiningPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = block.number;\n }\n releaseAmountAfterFees = amount - bridgingFee;\n \n \n if (!keepTokensInBridge) {\n \n token.safeTransfer(receiverAddress, releaseAmountAfterFees);\n }\n emit TokensReleased(\n sourceNetworkTokenAddress,\n releaseAmountAfterFees,\n receiverAddress,\n depositChainId,\n depositNumber\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Cross-Chain Bridge", "functions": ["function _releaseERC20(\n uint8[] memory sigV,\n bytes32[] memory sigR,\n bytes32[] memory sigS,\n address receiverAddress,\n address sourceNetworkTokenAddress,\n uint256 amount,\n uint256 depositChainId,\n uint256 depositNumber,\n bool keepTokensInBridge\n ) private whenNotPaused returns (uint256 releaseAmountAfterFees) {\n \n require(\n !releasedDeposits[depositChainId][depositNumber],\n \"CrossChainBridgeERC20: Deposit was already processed and released\"\n );\n require(\n receiverAddress != address(0),\n \"CrossChainBridgeERC20: invalid receiverAddress provided\"\n );\n require(\n sourceNetworkTokenAddress != address(0),\n \"CrossChainBridgeERC20: invalid sourceNetworkTokenAddress provided\"\n );\n require(amount > 0, \"CrossChainBridgeERC20: amount cannot be 0\");\n \n require(\n multiSignatureOracle.signaturesCheckERC20(\n sigV,\n sigR,\n sigS,\n receiverAddress,\n sourceNetworkTokenAddress,\n amount,\n depositChainId,\n depositNumber\n ),\n \"CrossChainBridgeERC20: Release not permitted. Not enough signatures from permitted oracles\"\n );\n \n \n address releaseChainTokenAddress = sourceNetworkTokenAddress;\n \n if (outsidePeggedTokens[sourceNetworkTokenAddress] != address(0)) {\n releaseChainTokenAddress = outsidePeggedTokens[\n sourceNetworkTokenAddress\n ];\n }\n IERC20 token = ERC20(releaseChainTokenAddress);\n \n require(\n token.balanceOf(address(this)) >= amount,\n \"CrossChainBridgeERC20: Not enough liquidity in bridge\"\n );\n \n \n uint256 relativeFee = bridgeFees[releaseChainTokenAddress] > 0\n ? bridgeFees[releaseChainTokenAddress]\n : defaultBridgeFee;\n \n \n uint256 bridgingFee = (amount * relativeFee) / 1000000;\n \n uint256 bridgingFeeToCollectAddress = (bridgingFee *\n collectBridgeFeePercentage) / 1000000;\n \n uint256 bridgingFeeToLiquidityMining = (bridgingFee *\n liquidityMiningFeePercentage) / 1000000;\n \n uint256 bridgingFeeToRewardPool = bridgingFee -\n bridgingFeeToCollectAddress -\n bridgingFeeToLiquidityMining;\n \n releasedDeposits[depositChainId][depositNumber] = true;\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(buyBackAndBurn)\n ] += bridgingFeeToCollectAddress;\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] += bridgingFeeToLiquidityMining;\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] += bridgingFeeToRewardPool;\n \n if (\n lastTransferBlock[releaseChainTokenAddress][address(rewardPools)] +\n blocksBetweenFeeTransfersToRewardPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] >\n 0\n ) {\n \n rewardPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(rewardPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(rewardPools)\n ] = block.number;\n } else if (\n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] +\n blocksBetweenFeeTransfersToLiquidityMiningPools <=\n block.number &&\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] >\n 0\n ) {\n \n \n liquidityMiningPools.addRewards(\n IERC20(releaseChainTokenAddress),\n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ]\n );\n \n collectedUnsentFees[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = 0;\n \n lastTransferBlock[releaseChainTokenAddress][\n address(liquidityMiningPools)\n ] = block.number;\n }\n releaseAmountAfterFees = amount - bridgingFee;\n \n \n if (!keepTokensInBridge) {\n \n token.safeTransfer(receiverAddress, releaseAmountAfterFees);\n }\n emit TokensReleased(\n sourceNetworkTokenAddress,\n releaseAmountAfterFees,\n receiverAddress,\n depositChainId,\n depositNumber\n );\n }", "function addRewards(\n IERC20 token,\n uint256 amount\n ) external whenNotPaused nonReentrant {\n \n require(\n address(token) != address(0),\n \"RewardPoolsV1: invalid address provided\"\n );\n \n if (!rewardPools[address(token)].exists) {\n \n rewardPools[address(token)] = RewardPool({\n rewardToken: token,\n interestBearingToken: new PoolsInterestBearingToken(\n \"Cross-Chain Bridge RP LPs\",\n \"BRIDGE-RP\",\n address(token)\n ),\n minStakeAmount: 1,\n maxStakeAmount: 0,\n maxPoolSize: 0,\n totalStakedAmount: 0,\n totalRewardAmount: 0,\n accRewardPerShare: 0,\n lastRewardAmount: 0,\n exists: true\n });\n \n PoolsInterestBearingToken(\n address(rewardPools[address(token)].interestBearingToken)\n ).setPoolsContract(address(this));\n }\n \n token.safeTransferFrom(_msgSender(), address(this), amount);\n \n \n \n if (rewardPools[address(token)].totalStakedAmount == 0) {\n \n require(\n token.approve(address(buyBackAndBurnContract), amount),\n \"RewardPoolsV1: approval failed\"\n );\n buyBackAndBurnContract.depositERC20(token, amount);\n } else {\n \n rewardPools[address(token)].totalRewardAmount =\n rewardPools[address(token)].totalRewardAmount +\n amount;\n }\n \n emit RewardsAdded(address(token), amount);\n }", "function buyBackAndBurnERC20(\n address collectedToken\n ) external whenNotPaused nonReentrant {\n \n require(\n collectedToken != address(0),\n \"BuyBackAndBurnV1: invalid token address\"\n );\n \n \n bridgeERC20.sendCollectedTokensToBuyBackAndBurn(IERC20(collectedToken));\n \n uint256 amount = collectedERC20ToBurn[collectedToken];\n require(amount > 0, \"BuyBackAndBurnV1: no tokens to burn\");\n \n if (\n IERC20(collectedToken).allowance(address(this), address(router)) <\n amount\n ) {\n IERC20(collectedToken).approve(address(router), type(uint256).max);\n }\n \n uint256 burnAmount = router.tradeERC20(\n IERC20(collectedToken),\n burnToken,\n amount\n );\n \n uint256 balanceBurnToken = burnToken.balanceOf(address(this));\n ERC20Burnable(address(burnToken)).burn(balanceBurnToken);\n \n collectedERC20ToBurn[collectedToken] = 0;\n \n emit BoughtBackAndBurned(\n collectedToken,\n amount,\n address(burnToken),\n balanceBurnToken\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Cross-Chain Bridge", "functions": ["function grantRole(\n bytes32 role,\n address account\n ) public virtual override onlyRole(getRoleAdmin(role)) {\n function _grantRole(...) {...}\n_grantRole(role, account);\n }", "function _grantRole(bytes32 role, address account) private {\n if (!hasRole(role, account)) {\n _roles[role].members[account] = true;\n emit RoleGranted(role, account, _msgSender());\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Cross-Chain Bridge", "functions": ["function revokeRole(\n bytes32 role,\n address account\n ) public virtual override onlyRole(getRoleAdmin(role)) {\n function _revokeRole(...) {...}\n_revokeRole(role, account);\n }", "function _revokeRole(bytes32 role, address account) private {\n if (hasRole(role, account)) {\n _roles[role].members[account] = false;\n emit RoleRevoked(role, account, _msgSender());\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Cross-Chain Bridge", "functions": ["function _upgradeTo(address newImplementation) internal {\n _setImplementation(newImplementation);\n emit Upgraded(newImplementation);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Cross-Chain Bridge", "functions": ["function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(\n senderBalance >= amount,\n \"ERC20: transfer amount exceeds balance\"\n );\n unchecked {\n _balances[sender] = senderBalance - amount;\n }\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);\n _afterTokenTransfer(sender, recipient, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Cross-Chain Bridge", "functions": ["function _approve(\n address owner,\n address spender,\n uint256 amount\n ) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "deBridge", "functions": ["function send(\n address _tokenAddress,\n uint256 _amount,\n uint256 _chainIdTo,\n bytes memory _receiver,\n bytes memory _permit,\n bool _useAssetFee,\n uint32 _referralCode,\n bytes calldata _autoParams\n ) external payable override nonReentrant whenNotPaused {\n bytes32 debridgeId;\n FeeParams memory feeParams;\n uint256 amountAfterFee;\n \n (amountAfterFee, debridgeId, feeParams) = _send(\n _permit,\n _tokenAddress,\n _amount,\n _chainIdTo,\n _useAssetFee\n );\n SubmissionAutoParamsTo memory autoParams;\n \n if (_autoParams.length > 0) {\n autoParams = abi.decode(_autoParams, (SubmissionAutoParamsTo));\n autoParams.executionFee = _normalizeTokenAmount(\n _tokenAddress,\n autoParams.executionFee\n );\n if (autoParams.executionFee > _amount) revert ProposedFeeTooHigh();\n if (\n autoParams.data.length > 0 &&\n autoParams.fallbackAddress.length == 0\n ) revert WrongAutoArgument();\n }\n amountAfterFee -= autoParams.executionFee;\n \n amountAfterFee = _normalizeTokenAmount(_tokenAddress, amountAfterFee);\n _publishSubmission(\n debridgeId,\n _chainIdTo,\n amountAfterFee,\n _receiver,\n feeParams,\n _referralCode,\n autoParams,\n _autoParams.length > 0\n );\n }", "function _send(\n bytes memory _permit,\n address _tokenAddress,\n uint256 _amount,\n uint256 _chainIdTo,\n bool _useAssetFee\n )\n internal\n returns (\n uint256 amountAfterFee,\n bytes32 debridgeId,\n FeeParams memory feeParams\n )\n {\n function _validateToken(...) {...}\n_validateToken(_tokenAddress);\n \n if (_permit.length > 0) {\n \n uint256 deadline = _permit.toUint256(0);\n (bytes32 r, bytes32 s, uint8 v) = _permit.parseSignature(32);\n IERC20Permit(_tokenAddress).permit(\n msg.sender,\n address(this),\n _amount,\n deadline,\n v,\n r,\n s\n );\n }\n TokenInfo memory nativeTokenInfo = getNativeInfo[_tokenAddress];\n bool isNativeToken = nativeTokenInfo.nativeChainId == 0\n ? true \n : nativeTokenInfo.nativeChainId == getChainId(); \n if (isNativeToken) {\n \n debridgeId = getDebridgeId(\n getChainId(),\n _tokenAddress == address(0) ? address(weth) : _tokenAddress\n );\n } else {\n debridgeId = getbDebridgeId(\n nativeTokenInfo.nativeChainId,\n nativeTokenInfo.nativeAddress\n );\n }\n DebridgeInfo storage debridge = getDebridge[debridgeId];\n if (!debridge.exist) {\n if (isNativeToken) {\n \n address assetAddress = _tokenAddress == address(0)\n ? address(weth)\n : _tokenAddress;\n _addAsset(\n debridgeId,\n assetAddress,\n abi.encodePacked(assetAddress),\n getChainId()\n );\n } else revert DebridgeNotFound();\n }\n ChainSupportInfo memory chainFees = getChainToConfig[_chainIdTo];\n if (!chainFees.isSupported) revert WrongChainTo();\n if (_tokenAddress == address(0)) {\n \n _amount = msg.value;\n weth.deposit{value: _amount}();\n _useAssetFee = true;\n } else {\n IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n uint256 balanceBefore = token.balanceOf(address(this));\n token.safeTransferFrom(msg.sender, address(this), _amount);\n \n _amount = token.balanceOf(address(this)) - balanceBefore;\n }\n if (_amount > debridge.maxAmount) revert TransferAmountTooHigh();\n \n {\n DiscountInfo memory discountInfo = feeDiscount[msg.sender];\n DebridgeFeeInfo storage debridgeFee = getDebridgeFeeInfo[\n debridgeId\n ];\n \n uint256 assetsFixedFee;\n if (_useAssetFee) {\n if (_tokenAddress == address(0)) {\n \n assetsFixedFee = chainFees.fixedNativeFee == 0\n ? globalFixedNativeFee\n : chainFees.fixedNativeFee;\n } else {\n \n assetsFixedFee = debridgeFee.getChainFee[_chainIdTo];\n if (assetsFixedFee == 0) revert NotSupportedFixedFee();\n }\n \n assetsFixedFee = _applyDiscount(\n assetsFixedFee,\n discountInfo.discountFixBps\n );\n if (_amount < assetsFixedFee)\n revert TransferAmountNotCoverFees();\n feeParams.fixFee = assetsFixedFee;\n } else {\n \n \n uint256 nativeFee = chainFees.fixedNativeFee == 0\n ? globalFixedNativeFee\n : chainFees.fixedNativeFee;\n \n nativeFee = _applyDiscount(\n nativeFee,\n discountInfo.discountFixBps\n );\n if (msg.value < nativeFee) revert TransferAmountNotCoverFees();\n else if (msg.value > nativeFee) {\n \n _safeTransferETH(msg.sender, msg.value - nativeFee);\n }\n bytes32 nativeDebridgeId = getDebridgeId(\n getChainId(),\n address(0)\n );\n getDebridgeFeeInfo[nativeDebridgeId].collectedFees += nativeFee;\n feeParams.fixFee = nativeFee;\n }\n \n \n uint256 transferFee = ((\n chainFees.transferFeeBps == 0\n ? globalTransferFeeBps\n : chainFees.transferFeeBps\n ) * (_amount - assetsFixedFee)) / BPS_DENOMINATOR;\n \n transferFee = _applyDiscount(\n transferFee,\n discountInfo.discountTransferBps\n );\n uint256 totalFee = transferFee + assetsFixedFee;\n if (_amount < totalFee) revert TransferAmountNotCoverFees();\n debridgeFee.collectedFees += totalFee;\n amountAfterFee = _amount - totalFee;\n \n feeParams.transferFee = transferFee;\n feeParams.useAssetFee = _useAssetFee;\n feeParams.receivedAmount = _amount;\n feeParams.isNativeToken = isNativeToken;\n }\n if (isNativeToken) {\n debridge.balance += amountAfterFee;\n } else {\n debridge.balance -= amountAfterFee;\n IDeBridgeToken(debridge.tokenAddress).burn(amountAfterFee);\n }\n return (amountAfterFee, debridgeId, feeParams);\n }", "function claim(\n bytes32 _debridgeId,\n uint256 _amount,\n uint256 _chainIdFrom,\n address _receiver,\n uint256 _nonce,\n bytes calldata _signatures,\n bytes calldata _autoParams\n ) external override whenNotPaused {\n if (!getChainFromConfig[_chainIdFrom].isSupported)\n revert WrongChainFrom();\n SubmissionAutoParamsFrom memory autoParams;\n if (_autoParams.length > 0) {\n autoParams = abi.decode(_autoParams, (SubmissionAutoParamsFrom));\n }\n bytes32 submissionId = getSubmissionIdFrom(\n _debridgeId,\n _chainIdFrom,\n _amount,\n _receiver,\n _nonce,\n autoParams,\n _autoParams.length > 0,\n msg.sender\n );\n \n if (isSubmissionUsed[submissionId]) revert SubmissionUsed();\n isSubmissionUsed[submissionId] = true;\n function _checkConfirmations(...) {...}\n_checkConfirmations(submissionId, _debridgeId, _amount, _signatures);\n bool isNativeToken = _claim(\n submissionId,\n _debridgeId,\n _receiver,\n _amount,\n _chainIdFrom,\n autoParams\n );\n emit Claimed(\n submissionId,\n _debridgeId,\n _amount,\n _receiver,\n _nonce,\n _chainIdFrom,\n _autoParams,\n isNativeToken\n );\n }", "function _checkConfirmations(\n bytes32 _submissionId,\n bytes32 _debridgeId,\n uint256 _amount,\n bytes calldata _signatures\n ) internal {\n if (isBlockedSubmission[_submissionId]) revert SubmissionBlocked();\n \n ISignatureVerifier(signatureVerifier).submit(\n _submissionId,\n _signatures,\n _amount >= getAmountThreshold[_debridgeId] ? excessConfirmations : 0\n );\n }", "function claim(\n bytes32 _debridgeId,\n uint256 _amount,\n uint256 _chainIdFrom,\n address _receiver,\n uint256 _nonce,\n bytes calldata _signatures,\n bytes calldata _autoParams\n ) external override whenNotPaused {\n if (!getChainFromConfig[_chainIdFrom].isSupported)\n revert WrongChainFrom();\n SubmissionAutoParamsFrom memory autoParams;\n if (_autoParams.length > 0) {\n autoParams = abi.decode(_autoParams, (SubmissionAutoParamsFrom));\n }\n bytes32 submissionId = getSubmissionIdFrom(\n _debridgeId,\n _chainIdFrom,\n _amount,\n _receiver,\n _nonce,\n autoParams,\n _autoParams.length > 0,\n msg.sender\n );\n \n if (isSubmissionUsed[submissionId]) revert SubmissionUsed();\n isSubmissionUsed[submissionId] = true;\n _checkConfirmations(submissionId, _debridgeId, _amount, _signatures);\n bool isNativeToken = _claim(\n submissionId,\n _debridgeId,\n _receiver,\n _amount,\n _chainIdFrom,\n autoParams\n );\n emit Claimed(\n submissionId,\n _debridgeId,\n _amount,\n _receiver,\n _nonce,\n _chainIdFrom,\n _autoParams,\n isNativeToken\n );\n }", "function _claim(\n bytes32 _submissionId,\n bytes32 _debridgeId,\n address _receiver,\n uint256 _amount,\n uint256 _chainIdFrom,\n SubmissionAutoParamsFrom memory _autoParams\n ) internal returns (bool isNativeToken) {\n DebridgeInfo storage debridge = getDebridge[_debridgeId];\n if (!debridge.exist) revert DebridgeNotFound();\n isNativeToken = debridge.chainId == getChainId();\n if (isNativeToken) {\n debridge.balance -= _amount + _autoParams.executionFee;\n } else {\n debridge.balance += _amount + _autoParams.executionFee;\n }\n address _token = debridge.tokenAddress;\n bool unwrapETH = isNativeToken &&\n _autoParams.flags.getFlag(Flags.UNWRAP_ETH) &&\n _token == address(weth);\n if (_autoParams.executionFee > 0) {\n _mintOrTransfer(\n _token,\n msg.sender,\n _autoParams.executionFee,\n isNativeToken\n );\n }\n if (_autoParams.data.length > 0) {\n \n address _callProxy = callProxy;\n bool status;\n if (unwrapETH) {\n \n _withdrawWeth(_callProxy, _amount);\n status = ICallProxy(_callProxy).call(\n _autoParams.fallbackAddress,\n _receiver,\n _autoParams.data,\n _autoParams.flags,\n _autoParams.nativeSender,\n _chainIdFrom\n );\n } else {\n _mintOrTransfer(_token, _callProxy, _amount, isNativeToken);\n status = ICallProxy(_callProxy).callERC20(\n _token,\n _autoParams.fallbackAddress,\n _receiver,\n _autoParams.data,\n _autoParams.flags,\n _autoParams.nativeSender,\n _chainIdFrom\n );\n }\n emit AutoRequestExecuted(_submissionId, status, _callProxy);\n } else if (unwrapETH) {\n \n _withdrawWeth(_receiver, _amount);\n } else {\n function _mintOrTransfer(...) {...}\n_mintOrTransfer(_token, _receiver, _amount, isNativeToken);\n }\n emit MonitoringClaimEvent(\n _submissionId,\n debridge.balance,\n IERC20Upgradeable(debridge.tokenAddress).totalSupply()\n );\n }", "function _mintOrTransfer(\n address _token,\n address _receiver,\n uint256 _amount,\n bool isNativeToken\n ) internal {\n if (_amount > 0) {\n if (isNativeToken) {\n IERC20Upgradeable(_token).safeTransfer(_receiver, _amount);\n } else {\n IDeBridgeToken(_token).mint(_receiver, _amount);\n }\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "deBridge", "functions": ["function submit(\n bytes32 _submissionId,\n bytes memory _signatures,\n uint8 _excessConfirmations\n ) external override onlyDeBridgeGate {\n \n uint8 needConfirmations = _excessConfirmations > minConfirmations\n ? _excessConfirmations\n : minConfirmations;\n \n uint256 currentRequiredOraclesCount;\n \n uint8 confirmations;\n uint256 signaturesCount = _countSignatures(_signatures);\n address[] memory validators = new address[](signaturesCount);\n for (uint256 i = 0; i < signaturesCount; i++) {\n (bytes32 r, bytes32 s, uint8 v) = _signatures.parseSignature(\n i * 65\n );\n address oracle = ecrecover(_submissionId.getUnsignedMsg(), v, r, s);\n if (getOracleInfo[oracle].isValid) {\n for (uint256 k = 0; k < i; k++) {\n if (validators[k] == oracle) revert DuplicateSignatures();\n }\n validators[i] = oracle;\n confirmations += 1;\n emit Confirmed(_submissionId, oracle);\n if (getOracleInfo[oracle].required) {\n currentRequiredOraclesCount += 1;\n }\n if (\n confirmations >= needConfirmations &&\n currentRequiredOraclesCount >= requiredOraclesCount\n ) {\n break;\n }\n }\n }\n if (currentRequiredOraclesCount != requiredOraclesCount)\n revert NotConfirmedByRequiredOracles();\n if (confirmations >= minConfirmations) {\n if (currentBlock == uint40(block.number)) {\n submissionsInBlock += 1;\n } else {\n currentBlock = uint40(block.number);\n submissionsInBlock = 1;\n }\n emit SubmissionApproved(_submissionId);\n }\n if (submissionsInBlock > confirmationThreshold) {\n if (confirmations < excessConfirmations)\n revert NotConfirmedThreshold();\n }\n if (confirmations < needConfirmations) revert SubmissionNotConfirmed();\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "DeGate Bridge", "functions": ["function withdrawFromMerkleTree(\n ExchangeData.State storage S,\n ExchangeData.MerkleProof calldata merkleProof\n ) public {\n require(S.isInWithdrawalMode(), \"NOT_IN_WITHDRAW_MODE\");\n address owner = merkleProof.accountLeaf.owner;\n uint32 accountID = merkleProof.accountLeaf.accountID;\n uint32 tokenID = merkleProof.balanceLeaf.tokenID;\n uint248 balance = merkleProof.balanceLeaf.balance;\n \n require(\n S.withdrawnInWithdrawMode[accountID][tokenID] == false,\n \"WITHDRAWN_ALREADY\"\n );\n \n ExchangeBalances.verifyAccountBalance(\n uint(S.merkleAssetRoot),\n merkleProof\n );\n \n S.withdrawnInWithdrawMode[accountID][tokenID] = true;\n \n transferTokens(\n S,\n uint8(WithdrawalCategory.FROM_MERKLE_TREE),\n owner,\n owner,\n tokenID,\n balance,\n gasleft(),\n false\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "DeGate Bridge", "functions": ["function withdrawFromDepositRequest(\n ExchangeData.State storage S,\n address owner,\n address token\n ) public {\n uint32 tokenID = S.getTokenID(token);\n ExchangeData.Deposit storage deposit = S.pendingDeposits[owner][\n tokenID\n ];\n require(deposit.timestamp != 0, \"DEPOSIT_NOT_WITHDRAWABLE_YET\");\n \n require(\n block.timestamp >=\n deposit.timestamp + S.maxAgeDepositUntilWithdrawable ||\n S.isInWithdrawalMode(),\n \"DEPOSIT_NOT_WITHDRAWABLE_YET\"\n );\n uint248 amount = deposit.amount;\n \n delete S.pendingDeposits[owner][tokenID];\n \n transferTokens(\n S,\n uint8(WithdrawalCategory.FROM_DEPOSIT_REQUEST),\n owner,\n owner,\n tokenID,\n amount,\n gasleft(),\n false\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "EYWA Bridge", "functions": ["function sendV2(\n SendParams calldata params,\n address from,\n uint256 nonce\n ) external override onlyRole(GATEKEEPER_ROLE) returns (bool) {\n require(state == State.Active, \"Bridge: state inactive\");\n require(\n previousEpoch.isSet() || currentEpoch.isSet(),\n \"Bridge: epoch not set\"\n );\n function verifyAndUpdateNonce(...) {...}\nverifyAndUpdateNonce(from, nonce);\n emit RequestSent(\n params.requestId,\n params.data,\n params.to,\n uint64(params.chainIdTo)\n );\n return true;\n }", "function verifyAndUpdateNonce(address from, uint256 nonce) internal {\n require(nonces[from]++ == nonce, \"Bridge: nonce mismatch\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "EYWA Bridge", "functions": ["function receiveV2(\n ReceiveParams[] calldata params\n ) external override onlyRole(VALIDATOR_ROLE) nonReentrant returns (bool) {\n require(state != State.Inactive, \"Bridge: state inactive\");\n for (uint256 i = 0; i < params.length; ++i) {\n bytes32 epochHash = Block.epochHash(params[i].blockHeader);\n \n if (epochHash == currentEpoch.epochHash) {\n require(currentEpoch.isSet(), \"Bridge: epoch not set\");\n verifyEpoch(currentEpoch, params[i]);\n } else if (epochHash == previousEpoch.epochHash) {\n require(previousEpoch.isSet(), \"Bridge: epoch not set\");\n verifyEpoch(previousEpoch, params[i]);\n } else {\n revert(\"Bridge: wrong epoch\");\n }\n \n bytes memory payload = Merkle.prove(\n params[i].merkleProof,\n Block.txRootHash(params[i].blockHeader)\n );\n \n (\n bytes32 requestId,\n bytes memory receivedData,\n address to,\n uint64 chainIdTo\n ) = Block.decodeRequest(payload);\n require(chainIdTo == block.chainid, \"Bridge: wrong chain id\");\n require(to.isContract(), \"Bridge: receiver is not a contract\");\n bool isRequestIdUniq;\n if (epochHash == currentEpoch.epochHash) {\n isRequestIdUniq = currentRequestIdChecker.check(requestId);\n } else {\n isRequestIdUniq = previousRequestIdChecker.check(requestId);\n }\n string memory err;\n if (isRequestIdUniq) {\n (bytes memory data, bytes memory check) = abi.decode(\n receivedData,\n (bytes, bytes)\n );\n bytes memory result = to.functionCall(check);\n require(abi.decode(result, (bool)), \"Bridge: check failed\");\n to.functionCall(data, \"Bridge: receive failed\");\n } else {\n revert(\"Bridge: request id already seen\");\n }\n emit RequestReceived(requestId, err);\n }\n return true;\n }", "function verifyEpoch(\n Bls.Epoch storage epoch,\n ReceiveParams calldata params\n ) internal view {\n Block.verify(\n epoch,\n params.blockHeader,\n params.votersPubKey,\n params.votersSignature,\n params.votersMask\n );\n }", "function check(bytes32 id) public onlyOwner returns (bool) {\n if (checks[id] == false) {\n checks[id] = true;\n return true;\n }\n return false;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Gravity Bridge", "functions": ["function sendToCosmos(\n address _tokenContract,\n string calldata _destination,\n uint256 _amount\n ) external nonReentrant {\n \n uint256 ourStartingBalance = IERC20(_tokenContract).balanceOf(\n address(this)\n );\n \n IERC20(_tokenContract).safeTransferFrom(\n msg.sender,\n address(this),\n _amount\n );\n \n \n uint256 ourEndingBalance = IERC20(_tokenContract).balanceOf(\n address(this)\n );\n \n \n if (ourEndingBalance <= ourStartingBalance) {\n revert InvalidSendToCosmos();\n }\n state_lastEventNonce = state_lastEventNonce + 1;\n \n \n \n emit SendToCosmosEvent(\n _tokenContract,\n msg.sender,\n _destination,\n ourEndingBalance - ourStartingBalance,\n state_lastEventNonce\n );\n }", "function submitBatch(\n \n ValsetArgs calldata _currentValset,\n \n Signature[] calldata _sigs,\n \n uint256[] calldata _amounts,\n address[] calldata _destinations,\n uint256[] calldata _fees,\n uint256 _batchNonce,\n address _tokenContract,\n \n \n uint256 _batchTimeout\n ) external nonReentrant {\n \n {\n \n if (_batchNonce <= state_lastBatchNonces[_tokenContract]) {\n revert InvalidBatchNonce({\n newNonce: _batchNonce,\n currentNonce: state_lastBatchNonces[_tokenContract]\n });\n }\n \n \n \n if (_batchNonce > state_lastBatchNonces[_tokenContract] + 1000000) {\n revert InvalidBatchNonce({\n newNonce: _batchNonce,\n currentNonce: state_lastBatchNonces[_tokenContract]\n });\n }\n \n if (block.number >= _batchTimeout) {\n revert BatchTimedOut();\n }\n \n validateValset(_currentValset, _sigs);\n \n if (\n makeCheckpoint(_currentValset, state_gravityId) !=\n state_lastValsetCheckpoint\n ) {\n revert IncorrectCheckpoint();\n }\n \n if (\n _amounts.length != _destinations.length ||\n _amounts.length != _fees.length\n ) {\n revert MalformedBatch();\n }\n \n checkValidatorSignatures(\n _currentValset,\n _sigs,\n \n keccak256(\n abi.encode(\n state_gravityId,\n \n 0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n _amounts,\n _destinations,\n _fees,\n _batchNonce,\n _tokenContract,\n _batchTimeout\n )\n ),\n constant_powerThreshold\n );\n \n \n state_lastBatchNonces[_tokenContract] = _batchNonce;\n {\n \n uint256 totalFee;\n for (uint256 i = 0; i < _amounts.length; i++) {\n IERC20(_tokenContract).safeTransfer(\n _destinations[i],\n _amounts[i]\n );\n totalFee = totalFee + _fees[i];\n }\n \n IERC20(_tokenContract).safeTransfer(msg.sender, totalFee);\n }\n }\n \n {\n state_lastEventNonce = state_lastEventNonce + 1;\n emit TransactionBatchExecutedEvent(\n _batchNonce,\n _tokenContract,\n state_lastEventNonce\n );\n }\n }", "function submitLogicCall(\n \n ValsetArgs calldata _currentValset,\n \n Signature[] calldata _sigs,\n LogicCallArgs memory _args\n ) external nonReentrant {\n \n {\n \n if (block.number >= _args.timeOut) {\n revert LogicCallTimedOut();\n }\n \n if (\n state_invalidationMapping[_args.invalidationId] >=\n _args.invalidationNonce\n ) {\n revert InvalidLogicCallNonce({\n newNonce: _args.invalidationNonce,\n currentNonce: state_invalidationMapping[\n _args.invalidationId\n ]\n });\n }\n \n \n \n \n validateValset(_currentValset, _sigs);\n \n if (\n makeCheckpoint(_currentValset, state_gravityId) !=\n state_lastValsetCheckpoint\n ) {\n revert IncorrectCheckpoint();\n }\n if (\n _args.transferAmounts.length !=\n _args.transferTokenContracts.length\n ) {\n revert InvalidLogicCallTransfers();\n }\n if (_args.feeAmounts.length != _args.feeTokenContracts.length) {\n revert InvalidLogicCallFees();\n }\n }\n {\n bytes32 argsHash = keccak256(\n abi.encode(\n state_gravityId,\n \n 0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n _args.transferAmounts,\n _args.transferTokenContracts,\n _args.feeAmounts,\n _args.feeTokenContracts,\n _args.logicContractAddress,\n _args.payload,\n _args.timeOut,\n _args.invalidationId,\n _args.invalidationNonce\n )\n );\n \n checkValidatorSignatures(\n _currentValset,\n _sigs,\n \n argsHash,\n constant_powerThreshold\n );\n }\n \n \n state_invalidationMapping[_args.invalidationId] = _args\n .invalidationNonce;\n \n for (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n IERC20(_args.transferTokenContracts[i]).safeTransfer(\n _args.logicContractAddress,\n _args.transferAmounts[i]\n );\n }\n \n bytes memory returnData = Address.functionCall(\n _args.logicContractAddress,\n _args.payload\n );\n \n for (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n IERC20(_args.feeTokenContracts[i]).safeTransfer(\n msg.sender,\n _args.feeAmounts[i]\n );\n }\n \n {\n state_lastEventNonce = state_lastEventNonce + 1;\n emit LogicCallEvent(\n _args.invalidationId,\n _args.invalidationNonce,\n returnData,\n state_lastEventNonce\n );\n }\n }", "function sendToCosmos(\n address _tokenContract,\n string calldata _destination,\n uint256 _amount\n ) external nonReentrant {\n \n uint256 ourStartingBalance = IERC20(_tokenContract).balanceOf(\n address(this)\n );\n \n IERC20(_tokenContract).safeTransferFrom(\n msg.sender,\n address(this),\n _amount\n );\n \n \n uint256 ourEndingBalance = IERC20(_tokenContract).balanceOf(\n address(this)\n );\n \n \n if (ourEndingBalance <= ourStartingBalance) {\n revert InvalidSendToCosmos();\n }\n state_lastEventNonce = state_lastEventNonce + 1;\n \n \n \n emit SendToCosmosEvent(\n _tokenContract,\n msg.sender,\n _destination,\n ourEndingBalance - ourStartingBalance,\n state_lastEventNonce\n );\n }", "function submitBatch(\n \n ValsetArgs calldata _currentValset,\n \n Signature[] calldata _sigs,\n \n uint256[] calldata _amounts,\n address[] calldata _destinations,\n uint256[] calldata _fees,\n uint256 _batchNonce,\n address _tokenContract,\n \n \n uint256 _batchTimeout\n ) external nonReentrant {\n \n {\n \n if (_batchNonce <= state_lastBatchNonces[_tokenContract]) {\n revert InvalidBatchNonce({\n newNonce: _batchNonce,\n currentNonce: state_lastBatchNonces[_tokenContract]\n });\n }\n \n \n \n if (_batchNonce > state_lastBatchNonces[_tokenContract] + 1000000) {\n revert InvalidBatchNonce({\n newNonce: _batchNonce,\n currentNonce: state_lastBatchNonces[_tokenContract]\n });\n }\n \n if (block.number >= _batchTimeout) {\n revert BatchTimedOut();\n }\n \n validateValset(_currentValset, _sigs);\n \n if (\n makeCheckpoint(_currentValset, state_gravityId) !=\n state_lastValsetCheckpoint\n ) {\n revert IncorrectCheckpoint();\n }\n \n if (\n _amounts.length != _destinations.length ||\n _amounts.length != _fees.length\n ) {\n revert MalformedBatch();\n }\n \n checkValidatorSignatures(\n _currentValset,\n _sigs,\n \n keccak256(\n abi.encode(\n state_gravityId,\n \n 0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n _amounts,\n _destinations,\n _fees,\n _batchNonce,\n _tokenContract,\n _batchTimeout\n )\n ),\n constant_powerThreshold\n );\n \n \n state_lastBatchNonces[_tokenContract] = _batchNonce;\n {\n \n uint256 totalFee;\n for (uint256 i = 0; i < _amounts.length; i++) {\n IERC20(_tokenContract).safeTransfer(\n _destinations[i],\n _amounts[i]\n );\n totalFee = totalFee + _fees[i];\n }\n \n IERC20(_tokenContract).safeTransfer(msg.sender, totalFee);\n }\n }\n \n {\n state_lastEventNonce = state_lastEventNonce + 1;\n emit TransactionBatchExecutedEvent(\n _batchNonce,\n _tokenContract,\n state_lastEventNonce\n );\n }\n }", "function submitLogicCall(\n \n ValsetArgs calldata _currentValset,\n \n Signature[] calldata _sigs,\n LogicCallArgs memory _args\n ) external nonReentrant {\n \n {\n \n if (block.number >= _args.timeOut) {\n revert LogicCallTimedOut();\n }\n \n if (\n state_invalidationMapping[_args.invalidationId] >=\n _args.invalidationNonce\n ) {\n revert InvalidLogicCallNonce({\n newNonce: _args.invalidationNonce,\n currentNonce: state_invalidationMapping[\n _args.invalidationId\n ]\n });\n }\n \n \n \n \n validateValset(_currentValset, _sigs);\n \n if (\n makeCheckpoint(_currentValset, state_gravityId) !=\n state_lastValsetCheckpoint\n ) {\n revert IncorrectCheckpoint();\n }\n if (\n _args.transferAmounts.length !=\n _args.transferTokenContracts.length\n ) {\n revert InvalidLogicCallTransfers();\n }\n if (_args.feeAmounts.length != _args.feeTokenContracts.length) {\n revert InvalidLogicCallFees();\n }\n }\n {\n bytes32 argsHash = keccak256(\n abi.encode(\n state_gravityId,\n \n 0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n _args.transferAmounts,\n _args.transferTokenContracts,\n _args.feeAmounts,\n _args.feeTokenContracts,\n _args.logicContractAddress,\n _args.payload,\n _args.timeOut,\n _args.invalidationId,\n _args.invalidationNonce\n )\n );\n \n checkValidatorSignatures(\n _currentValset,\n _sigs,\n \n argsHash,\n constant_powerThreshold\n );\n }\n \n \n state_invalidationMapping[_args.invalidationId] = _args\n .invalidationNonce;\n \n for (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n IERC20(_args.transferTokenContracts[i]).safeTransfer(\n _args.logicContractAddress,\n _args.transferAmounts[i]\n );\n }\n \n bytes memory returnData = Address.functionCall(\n _args.logicContractAddress,\n _args.payload\n );\n \n for (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n IERC20(_args.feeTokenContracts[i]).safeTransfer(\n msg.sender,\n _args.feeAmounts[i]\n );\n }\n \n {\n state_lastEventNonce = state_lastEventNonce + 1;\n emit LogicCallEvent(\n _args.invalidationId,\n _args.invalidationNonce,\n returnData,\n state_lastEventNonce\n );\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hashbon Rocket Bridge", "functions": ["function addOffer(\n address _token,\n uint _amount,\n address _payToken,\n uint _rate,\n address _payAddress,\n uint _minPurchase\n ) public {\n require(_amount > 0, \"Amount must be greater than 0\");\n require(\n _amount >= _minPurchase,\n \"Amount must not be less than the minimum purchase\"\n );\n require(_rate > 0, \"Rate must be greater than 0\");\n TransferHelper.safeTransferFrom(\n _token,\n msg.sender,\n address(this),\n _amount\n );\n uint offerId = offers.length;\n offers.push(\n Offer(\n _token,\n _amount,\n _payToken,\n _rate,\n msg.sender,\n _payAddress,\n _minPurchase,\n true\n )\n );\n emit OfferAdd(\n offerId,\n _token,\n _payToken,\n msg.sender,\n _payAddress,\n _amount,\n _rate,\n _minPurchase,\n true\n );\n }", "function safeTransferFrom(\n address token,\n address from,\n address to,\n uint256 value\n ) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0x23b872dd, from, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::transferFrom: transferFrom failed\"\n );\n }", "function withdrawTokens(uint _orderId, bytes calldata _sign) public {\n require(_orderId < orders.length, \"Incorrect orderId\");\n require(orders[_orderId].complete == false, \"Tokens already withdrawn\");\n uint offerId = orders[_orderId].offerId;\n uint amount = orders[_orderId].amount;\n uint payAmount = orders[_orderId].payAmount;\n address payToken = offers[offerId].payToken;\n address payAddress = orders[_orderId].payAddress;\n require(\n orders[_orderId].reservedUntil >= block.timestamp ||\n offers[offerId].amount - _getBlockedAmount(offerId) >= amount,\n \"Not enough tokens in the offer\"\n );\n bytes32 data = keccak256(\n abi.encodePacked(_orderId, payAmount, payToken, payAddress)\n );\n require(_verifySign(data, _sign), \"Incorrect signature\");\n TransferHelper.safeTransfer(\n offers[offerId].token,\n orders[_orderId].withdrawAddress,\n amount\n );\n orders[_orderId].complete = true;\n offers[offerId].amount -= amount;\n emit OrderComplete(_orderId, offers[offerId].amount);\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::safeTransfer: transfer failed\"\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hashbon Rocket Bridge", "functions": ["function updateOffer(\n uint _offerId,\n uint _amount,\n uint _rate,\n address _payAddress,\n uint _minPurchase\n ) public {\n _checkOfferAccess(_offerId);\n require(_rate > 0, \"Rate must be greater than 0\");\n uint blockedAmount = _getBlockedAmount(_offerId);\n require(\n _amount >= blockedAmount,\n \"You can not withdraw tokens ordered by customers\"\n );\n if (_amount > offers[_offerId].amount) {\n TransferHelper.safeTransferFrom(\n offers[_offerId].token,\n msg.sender,\n address(this),\n _amount - offers[_offerId].amount\n );\n } else {\n TransferHelper.safeTransfer(\n offers[_offerId].token,\n msg.sender,\n offers[_offerId].amount - _amount\n );\n }\n offers[_offerId].amount = _amount;\n offers[_offerId].rate = _rate;\n offers[_offerId].payAddress = _payAddress;\n offers[_offerId].minPurchase = _minPurchase;\n emit OfferUpdate(\n _offerId,\n _payAddress,\n _amount,\n _rate,\n _minPurchase,\n offers[_offerId].active\n );\n }", "function safeTransferFrom(\n address token,\n address from,\n address to,\n uint256 value\n ) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0x23b872dd, from, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::transferFrom: transferFrom failed\"\n );\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::safeTransfer: transfer failed\"\n );\n }", "function withdrawTokens(uint _orderId, bytes calldata _sign) public {\n require(_orderId < orders.length, \"Incorrect orderId\");\n require(orders[_orderId].complete == false, \"Tokens already withdrawn\");\n uint offerId = orders[_orderId].offerId;\n uint amount = orders[_orderId].amount;\n uint payAmount = orders[_orderId].payAmount;\n address payToken = offers[offerId].payToken;\n address payAddress = orders[_orderId].payAddress;\n require(\n orders[_orderId].reservedUntil >= block.timestamp ||\n offers[offerId].amount - _getBlockedAmount(offerId) >= amount,\n \"Not enough tokens in the offer\"\n );\n bytes32 data = keccak256(\n abi.encodePacked(_orderId, payAmount, payToken, payAddress)\n );\n require(_verifySign(data, _sign), \"Incorrect signature\");\n TransferHelper.safeTransfer(\n offers[offerId].token,\n orders[_orderId].withdrawAddress,\n amount\n );\n orders[_orderId].complete = true;\n offers[offerId].amount -= amount;\n emit OrderComplete(_orderId, offers[offerId].amount);\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::safeTransfer: transfer failed\"\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hashbon Rocket Bridge", "functions": ["function addOrder(\n uint _offerId,\n address _withdrawAddress,\n uint _amount,\n uint _payAmount\n ) public {\n require(_offerId < offers.length, \"Incorrect offerId\");\n require(offers[_offerId].active == true, \"Offer is inactive\");\n require(_amount > 0 || _payAmount > 0, \"Amount must be greater than 0\");\n uint rate = offers[_offerId].rate;\n if (_amount > 0) {\n _payAmount = (_amount * rate) / (10 ** RATE_DECIMALS);\n } else {\n _amount = (_payAmount * (10 ** RATE_DECIMALS)) / rate;\n }\n require(\n _amount >= offers[_offerId].minPurchase,\n \"Amount is less than the minimum purchase\"\n );\n uint blockedAmount = _getBlockedAmount(_offerId);\n require(\n _amount <= offers[_offerId].amount - blockedAmount,\n \"Not enough tokens in the offer\"\n );\n address _payAddress = offers[_offerId].payAddress;\n uint reservedUntil = block.timestamp + reservationTime;\n uint orderId = orders.length;\n orders.push(\n Order(\n _offerId,\n rate,\n msg.sender,\n _withdrawAddress,\n _amount,\n _payAmount,\n _payAddress,\n reservedUntil,\n false\n )\n );\n emit OrderAdd(\n orderId,\n _offerId,\n msg.sender,\n rate,\n _withdrawAddress,\n _amount,\n _payAmount,\n _payAddress,\n reservedUntil\n );\n }", "function withdrawTokens(uint _orderId, bytes calldata _sign) public {\n require(_orderId < orders.length, \"Incorrect orderId\");\n require(orders[_orderId].complete == false, \"Tokens already withdrawn\");\n uint offerId = orders[_orderId].offerId;\n uint amount = orders[_orderId].amount;\n uint payAmount = orders[_orderId].payAmount;\n address payToken = offers[offerId].payToken;\n address payAddress = orders[_orderId].payAddress;\n require(\n orders[_orderId].reservedUntil >= block.timestamp ||\n offers[offerId].amount - _getBlockedAmount(offerId) >= amount,\n \"Not enough tokens in the offer\"\n );\n bytes32 data = keccak256(\n abi.encodePacked(_orderId, payAmount, payToken, payAddress)\n );\n require(_verifySign(data, _sign), \"Incorrect signature\");\n TransferHelper.safeTransfer(\n offers[offerId].token,\n orders[_orderId].withdrawAddress,\n amount\n );\n orders[_orderId].complete = true;\n offers[offerId].amount -= amount;\n emit OrderComplete(_orderId, offers[offerId].amount);\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::safeTransfer: transfer failed\"\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hashbon Rocket Bridge", "functions": ["function payOrder(\n uint _orderId,\n uint _payAmount,\n address _payToken,\n address _payAddress\n ) public {\n require(_payAmount > 0, \"Amount must be greater than 0\");\n TransferHelper.safeTransferFrom(\n _payToken,\n msg.sender,\n _payAddress,\n _payAmount\n );\n uint paymentId = payments.length;\n payments.push(Payment(_orderId, _payAmount, _payToken, _payAddress));\n emit OrderPay(paymentId, _orderId, _payAmount, _payToken, _payAddress);\n }", "function safeTransferFrom(\n address token,\n address from,\n address to,\n uint256 value\n ) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0x23b872dd, from, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::transferFrom: transferFrom failed\"\n );\n }", "function withdrawTokens(uint _orderId, bytes calldata _sign) public {\n require(_orderId < orders.length, \"Incorrect orderId\");\n require(orders[_orderId].complete == false, \"Tokens already withdrawn\");\n uint offerId = orders[_orderId].offerId;\n uint amount = orders[_orderId].amount;\n uint payAmount = orders[_orderId].payAmount;\n address payToken = offers[offerId].payToken;\n address payAddress = orders[_orderId].payAddress;\n require(\n orders[_orderId].reservedUntil >= block.timestamp ||\n offers[offerId].amount - _getBlockedAmount(offerId) >= amount,\n \"Not enough tokens in the offer\"\n );\n bytes32 data = keccak256(\n abi.encodePacked(_orderId, payAmount, payToken, payAddress)\n );\n require(_verifySign(data, _sign), \"Incorrect signature\");\n TransferHelper.safeTransfer(\n offers[offerId].token,\n orders[_orderId].withdrawAddress,\n amount\n );\n orders[_orderId].complete = true;\n offers[offerId].amount -= amount;\n emit OrderComplete(_orderId, offers[offerId].amount);\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper::safeTransfer: transfer failed\"\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hashbon Rocket Bridge", "functions": ["function _recoverAddresses(\n bytes32 _hash,\n bytes memory _signatures\n ) private pure returns (address[] memory addresses) {\n uint8 v;\n bytes32 r;\n bytes32 s;\n uint count = _countSignatures(_signatures);\n addresses = new address[](count);\n for (uint i = 0; i < count; i++) {\n (v, r, s) = _parseSignature(_signatures, i);\n addresses[i] = ecrecover(_hash, v, r, s);\n }\n }", "function _parseSignature(\n bytes memory _signatures,\n uint _pos\n ) private pure returns (uint8 v, bytes32 r, bytes32 s) {\n uint offset = _pos * 65;\n assembly {\n r := mload(add(_signatures, add(32, offset)))\n s := mload(add(_signatures, add(64, offset)))\n v := and(mload(add(_signatures, add(65, offset))), 0xff)\n }\n if (v < 27) v += 27;\n require(v == 27 || v == 28);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Helix BETA Bridge", "functions": ["function lockAndRemoteIssuing(\n address token,\n address recipient,\n uint256 amount\n ) external payable whenNotPaused {\n uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n require(\n IERC20(token).transferFrom(msg.sender, address(this), amount),\n \"Backing:transfer tokens failed\"\n );\n uint256 balanceAfter = IERC20(token).balanceOf(address(this));\n require(\n balanceBefore + amount == balanceAfter,\n \"Backing:Transfer amount is invalid\"\n );\n _lockAndRemoteIssuing(token, recipient, amount, msg.value, false);\n }", "function _lockAndRemoteIssuing(\n address token,\n address recipient,\n uint256 amount,\n uint256 prepaid,\n bool isNative\n ) internal {\n bytes memory issueMappingToken = abi.encodeWithSelector(\n IErc20MappingTokenFactory.issueMappingToken.selector,\n token,\n recipient,\n amount\n );\n (uint256 transferId, uint256 fee) = _sendMessage(\n issueMappingToken,\n prepaid\n );\n bytes32 lockMessageHash = hash(\n abi.encodePacked(transferId, token, msg.sender, amount)\n );\n lockedMessages[transferId] = LockedInfo(lockMessageHash, false);\n emit TokenLocked(\n transferId,\n isNative,\n token,\n msg.sender,\n recipient,\n amount,\n fee\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Helix BETA Bridge", "functions": ["function lockAndRemoteIssuing(\n uint32 remoteSpecVersion,\n uint256 remoteReceiveGasLimit,\n address token,\n address recipient,\n uint256 amount\n ) external payable whenNotPaused {\n require(\n IERC20(token).transferFrom(msg.sender, address(this), amount),\n \"Backing:transfer tokens failed\"\n );\n _lockAndRemoteIssuing(\n remoteSpecVersion,\n remoteReceiveGasLimit,\n token,\n recipient,\n amount,\n msg.value,\n false\n );\n }", "function _lockAndRemoteIssuing(\n uint32 remoteSpecVersion,\n uint256 remoteReceiveGasLimit,\n address token,\n address recipient,\n uint256 amount,\n uint256 prepaid,\n bool isNative\n ) internal {\n bytes memory issueMappingToken = abi.encodeWithSelector(\n IErc20MappingTokenFactory.issueMappingToken.selector,\n token,\n recipient,\n amount\n );\n (uint256 transferId, uint256 totalFee) = _sendMessage(\n remoteSpecVersion,\n remoteReceiveGasLimit,\n issueMappingToken,\n prepaid\n );\n require(\n lockedMessages[transferId].hash == bytes32(0),\n \"backing: message exist\"\n );\n bytes32 lockMessageHash = hash(\n abi.encodePacked(transferId, token, msg.sender, amount)\n );\n lockedMessages[transferId] = LockedInfo(lockMessageHash, false);\n emit TokenLocked(\n transferId,\n isNative,\n token,\n msg.sender,\n recipient,\n amount,\n totalFee\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Helix BETA Bridge", "functions": ["function lockAndRemoteIssuing(\n address token,\n address recipient,\n uint256[] calldata ids,\n uint256[] calldata amounts\n ) external payable whenNotPaused {\n require(\n registeredTokens[token],\n \"Erc1155Backing:the token is not registered\"\n );\n IERC1155(token).safeBatchTransferFrom(\n msg.sender,\n address(this),\n ids,\n amounts,\n \"\"\n );\n bytes memory issueMappingToken = abi.encodeWithSelector(\n IErc1155MappingTokenFactory.issueMappingToken.selector,\n token,\n recipient,\n ids,\n amounts\n );\n uint256 messageId = IHelixMessageEndpoint(messageEndpoint).sendMessage{\n value: msg.value\n }(remoteMappingTokenFactory, issueMappingToken);\n lockMessages[messageId] = LockedInfo(token, msg.sender, ids, amounts);\n emit TokenLocked(messageId, token, recipient, ids, amounts);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Helix BETA Bridge", "functions": ["function lockAndRemoteIssuing(\n address token,\n address recipient,\n uint256[] calldata ids\n ) external payable whenNotPaused {\n TokenInfo memory info = registeredTokens[token];\n require(\n info.token != address(0),\n \"Erc721Backing:the token is not registed\"\n );\n bytes[] memory attrs = new bytes[](ids.length);\n for (uint idx = 0; idx < ids.length; idx++) {\n IERC721(token).transferFrom(msg.sender, address(this), ids[idx]);\n if (info.serializer != address(0)) {\n attrs[idx] = IErc721AttrSerializer(info.serializer).serialize(\n ids[idx]\n );\n }\n }\n bytes memory issueMappingToken = abi.encodeWithSelector(\n IErc721MappingTokenFactory.issueMappingToken.selector,\n token,\n recipient,\n ids,\n attrs\n );\n uint256 messageId = IHelixMessageEndpoint(messageEndpoint).sendMessage{\n value: msg.value\n }(remoteMappingTokenFactory, issueMappingToken);\n lockMessages[messageId] = LockedInfo(token, msg.sender, ids);\n emit TokenLocked(messageId, token, recipient, ids);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Helix BETA Bridge", "functions": ["function execute(\n bytes32 _commandId,\n string calldata _sourceChain,\n string calldata _sourceAddress,\n bytes calldata _payload\n ) external {\n \n require(\n gateway.validateContractCall(\n _commandId,\n _sourceChain,\n _sourceAddress,\n keccak256(_payload)\n ),\n \"invalid contract call\"\n );\n require(\n _sourceAddress.toAddress() == trustedRemotes[_sourceChain],\n \"invalid remote messager\"\n );\n \n (\n address remoteAppAddress,\n address localAppAddress,\n bytes memory message\n ) = abi.decode(_payload, (address, address, bytes));\n bytes32 key = keccak256(\n abi.encodePacked(_sourceChain, localAppAddress)\n );\n require(\n remoteAppAddress == remoteAppSenders[key],\n \"invalid remote address\"\n );\n \n (bool success, ) = localAppAddress.call(message);\n emit CallResult(_sourceChain, _sourceAddress, success);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Helix BETA Bridge", "functions": ["function receiveMessage(\n uint256 _srcAppChainId,\n address _remoteAppAddress,\n address _localAppAddress,\n bytes memory _message\n ) external onlyMsgline {\n uint256 srcChainId = _fromChainId();\n RemoteMessager memory remoteMessager = remoteMessagers[_srcAppChainId];\n require(\n srcChainId == remoteMessager.msglineRemoteChainId,\n \"invalid remote chainid\"\n );\n require(\n remoteMessager.messager == _xmsgSender(),\n \"invalid remote messager\"\n );\n bytes32 key = keccak256(abi.encodePacked(srcChainId, _localAppAddress));\n \n if (_remoteAppAddress != remoteAppSenders[key]) {\n emit CallerUnMatched(_srcAppChainId, _remoteAppAddress);\n return;\n }\n (bool success, ) = _localAppAddress.call(_message);\n \n emit CallResult(_srcAppChainId, success);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hermez bridge", "functions": ["function withdrawMerkleProof(\n uint32 tokenID,\n uint192 amount,\n uint256 babyPubKey,\n uint32 numExitRoot,\n uint256[] memory siblings,\n uint48 idx,\n bool instantWithdraw\n ) external {\n \n \n \n if (instantWithdraw) {\n require(\n _processInstantWithdrawal(tokenList[tokenID], amount),\n \"Hermez::withdrawMerkleProof: INSTANT_WITHDRAW_WASTED_FOR_THIS_USD_RANGE\"\n );\n }\n \n uint256[4] memory arrayState = _buildTreeState(\n tokenID,\n 0,\n amount,\n babyPubKey,\n msg.sender\n );\n uint256 stateHash = _hash4Elements(arrayState);\n \n uint256 exitRoot = exitRootsMap[numExitRoot];\n \n require(\n exitNullifierMap[numExitRoot][idx] == false,\n \"Hermez::withdrawMerkleProof: WITHDRAW_ALREADY_DONE\"\n );\n \n require(\n _smtVerifier(exitRoot, siblings, idx, stateHash) == true,\n \"Hermez::withdrawMerkleProof: SMT_PROOF_INVALID\"\n );\n \n exitNullifierMap[numExitRoot][idx] = true;\n function _withdrawFunds(...) {...}\n_withdrawFunds(amount, tokenID, instantWithdraw);\n emit WithdrawEvent(idx, numExitRoot, instantWithdraw);\n }", "function _withdrawFunds(\n uint192 amount,\n uint32 tokenID,\n bool instantWithdraw\n ) internal {\n if (instantWithdraw) {\n function _safeTransfer(...) {...}\nfunction _safeApprove(...) {...}\n_safeTransfer(tokenList[tokenID], msg.sender, amount);\n } else {\n if (tokenID == 0) {\n withdrawDelayerContract.deposit{value: amount}(\n msg.sender,\n address(0),\n amount\n );\n } else {\n address tokenAddress = tokenList[tokenID];\n _safeApprove(\n tokenAddress,\n address(withdrawDelayerContract),\n amount\n );\n withdrawDelayerContract.deposit(\n msg.sender,\n tokenAddress,\n amount\n );\n }\n }\n }", "function _safeTransfer(address token, address to, uint256 value) internal {\n \n if (token == address(0)) {\n \n (bool success, ) = msg.sender.call{value: value}(new bytes(0));\n require(success, \"Hermez::_safeTransfer: ETH_TRANSFER_FAILED\");\n } else {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_TRANSFER_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeTransfer: ERC20_TRANSFER_FAILED\"\n );\n }\n }", "function _safeApprove(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_APPROVE_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeApprove: ERC20_APPROVE_FAILED\"\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hermez bridge", "functions": ["function withdrawCircuit(\n uint256[2] calldata proofA,\n uint256[2][2] calldata proofB,\n uint256[2] calldata proofC,\n uint32 tokenID,\n uint192 amount,\n uint32 numExitRoot,\n uint48 idx,\n bool instantWithdraw\n ) external {\n \n if (instantWithdraw) {\n require(\n _processInstantWithdrawal(tokenList[tokenID], amount),\n \"Hermez::withdrawCircuit: INSTANT_WITHDRAW_WASTED_FOR_THIS_USD_RANGE\"\n );\n }\n require(\n exitNullifierMap[numExitRoot][idx] == false,\n \"Hermez::withdrawCircuit: WITHDRAW_ALREADY_DONE\"\n );\n \n uint256 exitRoot = exitRootsMap[numExitRoot];\n uint256 input = uint256(\n sha256(abi.encodePacked(exitRoot, msg.sender, tokenID, amount, idx))\n ) % _RFIELD;\n \n require(\n withdrawVerifier.verifyProof(proofA, proofB, proofC, [input]) ==\n true,\n \"Hermez::withdrawCircuit: INVALID_ZK_PROOF\"\n );\n \n exitNullifierMap[numExitRoot][idx] = true;\n function _withdrawFunds(...) {...}\n_withdrawFunds(amount, tokenID, instantWithdraw);\n emit WithdrawEvent(idx, numExitRoot, instantWithdraw);\n }", "function _withdrawFunds(\n uint192 amount,\n uint32 tokenID,\n bool instantWithdraw\n ) internal {\n if (instantWithdraw) {\n function _safeTransfer(...) {...}\nfunction _safeApprove(...) {...}\n_safeTransfer(tokenList[tokenID], msg.sender, amount);\n } else {\n if (tokenID == 0) {\n withdrawDelayerContract.deposit{value: amount}(\n msg.sender,\n address(0),\n amount\n );\n } else {\n address tokenAddress = tokenList[tokenID];\n _safeApprove(\n tokenAddress,\n address(withdrawDelayerContract),\n amount\n );\n withdrawDelayerContract.deposit(\n msg.sender,\n tokenAddress,\n amount\n );\n }\n }\n }", "function _safeTransfer(address token, address to, uint256 value) internal {\n \n if (token == address(0)) {\n \n (bool success, ) = msg.sender.call{value: value}(new bytes(0));\n require(success, \"Hermez::_safeTransfer: ETH_TRANSFER_FAILED\");\n } else {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_TRANSFER_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeTransfer: ERC20_TRANSFER_FAILED\"\n );\n }\n }", "function _safeApprove(address token, address to, uint256 value) internal {\n \n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(_APPROVE_SIGNATURE, to, value)\n );\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Hermez::_safeApprove: ERC20_APPROVE_FAILED\"\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hermez bridge", "functions": ["function forgeBatch(\n uint48 newLastIdx,\n uint256 newStRoot,\n uint256 newExitRoot,\n bytes calldata encodedL1CoordinatorTx,\n bytes calldata l1L2TxsData,\n bytes calldata feeIdxCoordinator,\n uint8 verifierIdx,\n bool l1Batch,\n uint256[2] calldata proofA,\n uint256[2][2] calldata proofB,\n uint256[2] calldata proofC\n ) external virtual {\n \n \n \n \n require(\n msg.sender == tx.origin,\n \"Hermez::forgeBatch: INTENAL_TX_NOT_ALLOWED\"\n );\n \n require(\n hermezAuctionContract.canForge(msg.sender, block.number) == true,\n \"Hermez::forgeBatch: AUCTION_DENIED\"\n );\n if (!l1Batch) {\n require(\n block.number < (lastL1L2Batch + forgeL1L2BatchTimeout), \n \"Hermez::forgeBatch: L1L2BATCH_REQUIRED\"\n );\n }\n \n uint256 input = _constructCircuitInput(\n newLastIdx,\n newStRoot,\n newExitRoot,\n l1Batch,\n verifierIdx\n );\n \n require(\n rollupVerifiers[verifierIdx].verifierInterface.verifyProof(\n proofA,\n proofB,\n proofC,\n [input]\n ),\n \"Hermez::forgeBatch: INVALID_PROOF\"\n );\n \n lastForgedBatch++;\n lastIdx = newLastIdx;\n stateRootMap[lastForgedBatch] = newStRoot;\n exitRootsMap[lastForgedBatch] = newExitRoot;\n l1L2TxsDataHashMap[lastForgedBatch] = sha256(l1L2TxsData);\n uint16 l1UserTxsLen;\n if (l1Batch) {\n \n lastL1L2Batch = uint64(block.number);\n \n function _clearQueue(...) {...}\nl1UserTxsLen = _clearQueue();\n }\n \n hermezAuctionContract.forge(msg.sender);\n emit ForgeBatch(lastForgedBatch, l1UserTxsLen);\n }", "function _clearQueue() internal returns (uint16) {\n uint16 l1UserTxsLen = uint16(\n mapL1TxQueue[nextL1ToForgeQueue].length / _L1_USER_TOTALBYTES\n );\n delete mapL1TxQueue[nextL1ToForgeQueue];\n nextL1ToForgeQueue++;\n if (nextL1ToForgeQueue == nextL1FillingQueue) {\n nextL1FillingQueue++;\n }\n return l1UserTxsLen;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hop.Exchange", "functions": ["function sendToL2(\n uint256 chainId,\n address recipient,\n uint256 amount,\n uint256 amountOutMin,\n uint256 deadline,\n address relayer,\n uint256 relayerFee\n )\n external\n payable\n {\n IMessengerWrapper messengerWrapper = crossDomainMessengerWrappers[chainId];\n require(messengerWrapper != IMessengerWrapper(0), \"L1_BRG: chainId not supported\");\n require(isChainIdPaused[chainId] == false, \"L1_BRG: Sends to this chainId are paused\");\n require(amount > 0, \"L1_BRG: Must transfer a non-zero amount\");\n require(amount >= relayerFee, \"L1_BRG: Relayer fee cannot exceed amount\");\n _transferToBridge(msg.sender, amount);\n bytes memory message = abi.encodeWithSignature(\n \"distribute(address,uint256,uint256,uint256,address,uint256)\",\n recipient,\n amount,\n amountOutMin,\n deadline,\n relayer,\n relayerFee\n );\n chainBalance[chainId] = chainBalance[chainId].add(amount);\n messengerWrapper.sendCrossDomainMessage(message);\n emit TransferSentToL2(\n chainId,\n recipient,\n amount,\n amountOutMin,\n deadline,\n relayer,\n relayerFee\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hop.Exchange", "functions": ["function bondTransferRoot(\n bytes32 rootHash,\n uint256 destinationChainId,\n uint256 totalAmount\n )\n external\n onlyBonder\n requirePositiveBalance\n {\n bytes32 transferRootId = getTransferRootId(rootHash, totalAmount);\n require(transferRootCommittedAt[destinationChainId][transferRootId] == 0, \"L1_BRG: TransferRoot has already been confirmed\");\n require(transferBonds[transferRootId].createdAt == 0, \"L1_BRG: TransferRoot has already been bonded\");\n uint256 currentTimeSlot = getTimeSlot(block.timestamp);\n uint256 bondAmount = getBondForTransferAmount(totalAmount);\n timeSlotToAmountBonded[currentTimeSlot][msg.sender] = timeSlotToAmountBonded[currentTimeSlot][msg.sender].add(bondAmount);\n transferBonds[transferRootId] = TransferBond(\n msg.sender,\n block.timestamp,\n totalAmount,\n uint256(0),\n address(0),\n false\n );\n function _distributeTransferRoot(...) {...}\n_distributeTransferRoot(rootHash, destinationChainId, totalAmount);\n emit TransferRootBonded(rootHash, totalAmount);\n }", "function _setTransferRoot(bytes32 rootHash, uint256 totalAmount) internal {\n bytes32 transferRootId = getTransferRootId(rootHash, totalAmount);\n require(_transferRoots[transferRootId].total == 0, \"BRG: Transfer root already set\");\n require(totalAmount > 0, \"BRG: Cannot set TransferRoot totalAmount of 0\");\n _transferRoots[transferRootId] = TransferRoot(totalAmount, 0, block.timestamp);\n emit TransferRootSet(rootHash, totalAmount);\n }", "function bondWithdrawal(\n address recipient,\n uint256 amount,\n bytes32 transferNonce,\n uint256 bonderFee\n )\n external\n onlyBonder\n requirePositiveBalance\n nonReentrant\n {\n bytes32 transferId = getTransferId(\n getChainId(),\n recipient,\n amount,\n transferNonce,\n bonderFee,\n 0,\n 0\n );\n function _bondWithdrawal(...) {...}\nfunction _fulfillWithdraw(...) {...}\n_bondWithdrawal(transferId, amount);\n _fulfillWithdraw(transferId, recipient, amount, bonderFee);\n }", "function _bondWithdrawal(bytes32 transferId, uint256 amount) internal {\n require(_bondedWithdrawalAmounts[msg.sender][transferId] == 0, \"BRG: Withdrawal has already been bonded\");\n _addDebit(msg.sender, amount);\n _bondedWithdrawalAmounts[msg.sender][transferId] = amount;\n emit WithdrawalBonded(transferId, amount);\n }", "function _addDebit(address bonder, uint256 amount) internal {\n _debit[bonder] = _debit[bonder].add(amount);\n }", "function _fulfillWithdraw(\n bytes32 transferId,\n address recipient,\n uint256 amount,\n uint256 bonderFee\n ) private {\n function _markTransferSpent(...) {...}\n_markTransferSpent(transferId);\n _transferFromBridge(recipient, amount.sub(bonderFee));\n if (bonderFee > 0) {\n _transferFromBridge(msg.sender, bonderFee);\n }\n }", "function _markTransferSpent(bytes32 transferId) internal {\n require(!_spentTransferIds[transferId], \"BRG: The transfer has already been withdrawn\");\n _spentTransferIds[transferId] = true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hop.Exchange", "functions": ["function withdraw(\n address recipient,\n uint256 amount,\n bytes32 transferNonce,\n uint256 bonderFee,\n uint256 amountOutMin,\n uint256 deadline,\n bytes32 rootHash,\n uint256 transferRootTotalAmount,\n uint256 transferIdTreeIndex,\n bytes32[] calldata siblings,\n uint256 totalLeaves\n )\n external\n nonReentrant\n {\n bytes32 transferId = getTransferId(\n getChainId(),\n recipient,\n amount,\n transferNonce,\n bonderFee,\n amountOutMin,\n deadline\n );\n require(\n rootHash.verify(\n transferId,\n transferIdTreeIndex,\n siblings,\n totalLeaves\n )\n , \"BRG: Invalid transfer proof\");\n bytes32 transferRootId = getTransferRootId(rootHash, transferRootTotalAmount);\n function _addToAmountWithdrawn(...) {...}\nfunction _fulfillWithdraw(...) {...}\n_addToAmountWithdrawn(transferRootId, amount);\n _fulfillWithdraw(transferId, recipient, amount, uint256(0));\n emit Withdrew(transferId, recipient, amount, transferNonce);\n }", "function _markTransferSpent(bytes32 transferId) internal {\n require(!_spentTransferIds[transferId], \"BRG: The transfer has already been withdrawn\");\n _spentTransferIds[transferId] = true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hop.Exchange", "functions": ["function _setTransferRoot(bytes32 rootHash, uint256 totalAmount) internal {\n bytes32 transferRootId = getTransferRootId(rootHash, totalAmount);\n require(_transferRoots[transferRootId].total == 0, \"BRG: Transfer root already set\");\n require(totalAmount > 0, \"BRG: Cannot set TransferRoot totalAmount of 0\");\n _transferRoots[transferRootId] = TransferRoot(totalAmount, 0, block.timestamp);\n emit TransferRootSet(rootHash, totalAmount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hop.Exchange", "functions": ["function _distributeTransferRoot(\n bytes32 rootHash,\n uint256 chainId,\n uint256 totalAmount\n )\n internal\n {\n \n if (chainId == getChainId()) {\n \n _setTransferRoot(rootHash, totalAmount);\n } else {\n chainBalance[chainId] = chainBalance[chainId].add(totalAmount);\n IMessengerWrapper messengerWrapper = crossDomainMessengerWrappers[chainId];\n require(messengerWrapper != IMessengerWrapper(0), \"L1_BRG: chainId not supported\");\n \n bytes memory setTransferRootMessage = abi.encodeWithSignature(\n \"setTransferRoot(bytes32,uint256)\",\n rootHash,\n totalAmount\n );\n messengerWrapper.sendCrossDomainMessage(setTransferRootMessage);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Horizon bridge", "functions": ["function lockToken(uint256 amount, address recipient) public {\n require(\n recipient != address(0),\n \"EthManager/recipient is a zero address\"\n );\n require(amount > 0, \"EthManager/zero token locked\");\n uint256 _balanceBefore = busd_.balanceOf(msg.sender);\n require(\n busd_.transferFrom(msg.sender, address(this), amount),\n \"EthManager/lock failed\"\n );\n uint256 _balanceAfter = busd_.balanceOf(msg.sender);\n uint256 _actualAmount = _balanceBefore.sub(_balanceAfter);\n emit Locked(address(busd_), msg.sender, _actualAmount, recipient);\n }", "function unlockToken(\n uint256 amount,\n address recipient,\n bytes32 receiptId\n ) public onlyWallet {\n require(\n !usedEvents_[receiptId],\n \"EthManager/The burn event cannot be reused\"\n );\n usedEvents_[receiptId] = true;\n require(busd_.transfer(recipient, amount), \"EthManager/unlock failed\");\n emit Unlocked(address(busd_), amount, recipient, receiptId);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Horizon bridge", "functions": ["function lockToken(\n address ethTokenAddr,\n uint256 amount,\n address recipient\n ) public {\n require(\n recipient != address(0),\n \"EthManager/recipient is a zero address\"\n );\n require(amount > 0, \"EthManager/zero token locked\");\n IERC20 ethToken = IERC20(ethTokenAddr);\n uint256 _balanceBefore = ethToken.balanceOf(msg.sender);\n function safeTransferFrom(...) {...}\nethToken.safeTransferFrom(msg.sender, address(this), amount);\n uint256 _balanceAfter = ethToken.balanceOf(msg.sender);\n uint256 _actualAmount = _balanceBefore.sub(_balanceAfter);\n emit Locked(address(ethToken), msg.sender, _actualAmount, recipient);\n }", "function unlockToken(\n address ethTokenAddr,\n uint256 amount,\n address recipient,\n bytes32 receiptId\n ) public onlyWallet {\n require(\n !usedEvents_[receiptId],\n \"EthManager/The burn event cannot be reused\"\n );\n IERC20 ethToken = IERC20(ethTokenAddr);\n usedEvents_[receiptId] = true;\n function safeTransfer(...) {...}\nethToken.safeTransfer(recipient, amount);\n emit Unlocked(ethTokenAddr, amount, recipient, receiptId);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Horizon bridge", "functions": ["function lockToken(uint256 amount, address recipient) public {\n require(\n recipient != address(0),\n \"EthManager/recipient is a zero address\"\n );\n require(amount > 0, \"EthManager/zero token locked\");\n uint256 _balanceBefore = link_.balanceOf(msg.sender);\n require(\n link_.transferFrom(msg.sender, address(this), amount),\n \"EthManager/lock failed\"\n );\n uint256 _balanceAfter = link_.balanceOf(msg.sender);\n uint256 _actualAmount = _balanceBefore.sub(_balanceAfter);\n emit Locked(address(link_), msg.sender, _actualAmount, recipient);\n }", "function unlockToken(\n uint256 amount,\n address recipient,\n bytes32 receiptId\n ) public onlyWallet {\n require(\n !usedEvents_[receiptId],\n \"EthManager/The burn event cannot be reused\"\n );\n usedEvents_[receiptId] = true;\n require(link_.transfer(recipient, amount), \"EthManager/unlock failed\");\n emit Unlocked(address(link_), amount, recipient, receiptId);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "HTLC Cross Bridge", "functions": ["function initPortal(bytes32 _commitment, bytes32 _hashLock, address _tokenContract, address _receiver, uint _amount) external noActiveTransferOut{\n IERC20 tokenContract = IERC20(_tokenContract);\n require(tokenContract.allowance(msg.sender, address(this)) >= _amount, \"Error: Insuficient allowance\");\n _hasActiveTransferOut[msg.sender] = true;\n _transfersOut[msg.sender] = Transfer(_commitment, msg.sender, _receiver, _tokenContract, _amount, _hashLock, block.timestamp + 1 hours);\n tokenContract.transferFrom(msg.sender, address(this), _amount);\n emit NewPortal(msg.sender, _amount, _tokenContract);\n }", "function portalFromOtherChain(\n bytes32 _commitment, \n bytes32 _hashLock, \n uint _timeLock, \n address _tokenContract, \n address _sender, \n address _receiver, \n uint _amount) \n external {\n \n require(contractToContract[_tokenContract] != address(0x0), \"Error: Token contract doesn't have a match in this chain\");\n _transfersIn[_receiver] = Transfer(_commitment, _sender, _receiver, contractToContract[_tokenContract], _amount, _hashLock, _timeLock);\n emit DestinationPortalOpened(_sender, _receiver, _amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "HTLC Cross Bridge", "functions": ["function finalizeInterPortalTransferDest(address _receiver, string memory _secretKey) public { \n Transfer memory transfer = _transfersIn[_receiver];\n IERC20 tokenContract = IERC20(contractToContract[transfer.tokenContract]);\n function encode(...) {...}\nfunction hashThis(...) {...}\nrequire(hashThis(abi.encode(_secretKey)) == transfer.hashLock, \"Error: hash lock does not match\");\n require(block.timestamp <= transfer.timeLock, \"Error: transfer wasn't finalized within time\");\n require(tokenContract.balanceOf(address(this)) >= transfer.amount, \"Error: not enough liquidity to bridge funds\");\n tokenContract.transfer(_receiver, transfer.amount);\n emit DestinationTransferFinalized(transfer.sender);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hyphen", "functions": ["function _depositErc20(\n address sender,\n uint256 toChainId,\n address tokenAddress,\n address receiver,\n uint256 amount\n ) internal returns (uint256) {\n require(\n toChainId != block.chainid,\n \"To chain must be different than current chain\"\n );\n require(tokenAddress != NATIVE, \"wrong function\");\n TokenConfig memory config = tokenManager.getDepositConfig(\n toChainId,\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Deposit amount not in Cap limit\"\n );\n require(receiver != address(0), \"Receiver address cannot be 0\");\n require(amount != 0, \"Amount cannot be 0\");\n uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n if (rewardAmount != 0) {\n incentivePool[tokenAddress] =\n incentivePool[tokenAddress] -\n rewardAmount;\n }\n liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n SafeERC20Upgradeable.safeTransferFrom(\n IERC20Upgradeable(tokenAddress),\n sender,\n address(this),\n amount\n );\n return rewardAmount;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hyphen", "functions": ["function depositAndSwapErc20(\n address tokenAddress,\n address receiver,\n uint256 toChainId,\n uint256 amount,\n string calldata tag,\n SwapRequest[] calldata swapRequest\n ) external tokenChecks(tokenAddress) whenNotPaused nonReentrant {\n uint256 totalPercentage = 0;\n {\n uint256 swapArrayLength = swapRequest.length;\n unchecked {\n for (uint256 index = 0; index < swapArrayLength; ++index) {\n totalPercentage += swapRequest[index].percentage;\n }\n }\n }\n require(\n totalPercentage <= 100 * BASE_DIVISOR,\n \"Total percentage cannot be > 100\"\n );\n address sender = _msgSender();\n uint256 rewardAmount = _depositErc20(\n sender,\n toChainId,\n tokenAddress,\n receiver,\n amount\n );\n \n emit DepositAndSwap(\n sender,\n tokenAddress,\n receiver,\n toChainId,\n amount + rewardAmount,\n rewardAmount,\n tag,\n swapRequest\n );\n }", "function _depositErc20(\n address sender,\n uint256 toChainId,\n address tokenAddress,\n address receiver,\n uint256 amount\n ) internal returns (uint256) {\n require(\n toChainId != block.chainid,\n \"To chain must be different than current chain\"\n );\n require(tokenAddress != NATIVE, \"wrong function\");\n TokenConfig memory config = tokenManager.getDepositConfig(\n toChainId,\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Deposit amount not in Cap limit\"\n );\n require(receiver != address(0), \"Receiver address cannot be 0\");\n require(amount != 0, \"Amount cannot be 0\");\n uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n if (rewardAmount != 0) {\n incentivePool[tokenAddress] =\n incentivePool[tokenAddress] -\n rewardAmount;\n }\n liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n SafeERC20Upgradeable.safeTransferFrom(\n IERC20Upgradeable(tokenAddress),\n sender,\n address(this),\n amount\n );\n return rewardAmount;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hyphen", "functions": ["function depositErc20( address tokenAddress, address receiver, uint256 amount, uint256 toChainId ) public tokenChecks(tokenAddress) whenNotPaused {\n require(tokensInfo[tokenAddress].minCap <= amount && tokensInfo[tokenAddress].maxCap >= amount, \"Deposit amount should be within allowed Cap limits\");\n require(receiver != address(0), \"Receiver address cannot be 0\");\n require(amount != 0, \"Amount cannot be 0\");\n address payable sender = _msgSender();\n SafeERC20.safeTransferFrom(IERC20(tokenAddress), sender, address(this),amount);\n emit Deposit(sender, tokenAddress, receiver, toChainId, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hyphen", "functions": ["function depositNative(\n address receiver,\n uint256 toChainId,\n string calldata tag\n ) external payable whenNotPaused nonReentrant {\n uint256 rewardAmount = _depositNative(receiver, toChainId);\n emit Deposit(\n _msgSender(),\n NATIVE,\n receiver,\n toChainId,\n msg.value + rewardAmount,\n rewardAmount,\n tag\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hyphen", "functions": ["function sendFundsToUser(\n address tokenAddress,\n uint256 amount,\n address payable receiver,\n bytes calldata depositHash,\n uint256 tokenGasPrice,\n uint256 fromChainId\n ) external nonReentrant onlyExecutor whenNotPaused {\n uint256 initialGas = gasleft();\n TokenConfig memory config = tokenManager.getTransferConfig(\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Withdraw amount not in Cap limit\"\n );\n require(receiver != address(0), \"Bad receiver address\");\n (bytes32 hashSendTransaction, bool status) = checkHashStatus(\n tokenAddress,\n amount,\n receiver,\n depositHash\n );\n require(!status, \"Already Processed\");\n processedHash[hashSendTransaction] = true;\n \n uint256[4] memory transferDetails = getAmountToTransfer(\n initialGas,\n tokenAddress,\n amount,\n tokenGasPrice\n );\n liquidityProviders.decreaseCurrentLiquidity(\n tokenAddress,\n transferDetails[0]\n );\n if (tokenAddress == NATIVE) {\n (bool success, ) = receiver.call{value: transferDetails[0]}(\"\");\n require(success, \"Native Transfer Failed\");\n } else {\n SafeERC20Upgradeable.safeTransfer(\n IERC20Upgradeable(tokenAddress),\n receiver,\n transferDetails[0]\n );\n }\n emit AssetSent(\n tokenAddress,\n amount,\n transferDetails[0],\n receiver,\n depositHash,\n fromChainId,\n transferDetails[1],\n transferDetails[2],\n transferDetails[3]\n );\n }", "function getAmountToTransfer(\n uint256 initialGas,\n address tokenAddress,\n uint256 amount,\n uint256 tokenGasPrice\n ) internal returns (uint256[4] memory) {\n TokenInfo memory tokenInfo = tokenManager.getTokensInfo(tokenAddress);\n uint256 transferFeePerc = _getTransferFee(\n tokenAddress,\n amount,\n tokenInfo\n );\n uint256 lpFee;\n if (transferFeePerc > tokenInfo.equilibriumFee) {\n \n lpFee = (amount * tokenInfo.equilibriumFee) / BASE_DIVISOR;\n unchecked {\n incentivePool[tokenAddress] +=\n (amount * (transferFeePerc - tokenInfo.equilibriumFee)) /\n BASE_DIVISOR;\n }\n } else {\n lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n }\n uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n liquidityProviders.addLPFee(tokenAddress, lpFee);\n uint256 totalGasUsed = initialGas +\n tokenInfo.transferOverhead +\n baseGas -\n gasleft();\n uint256 gasFee = totalGasUsed * tokenGasPrice;\n gasFeeAccumulatedByToken[tokenAddress] += gasFee;\n gasFeeAccumulated[tokenAddress][_msgSender()] += gasFee;\n uint256 amountToTransfer = amount - (transferFeeAmount + gasFee);\n return [amountToTransfer, lpFee, transferFeeAmount, gasFee];\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Hyphen", "functions": ["function swapAndSendFundsToUser(\n address tokenAddress,\n uint256 amount,\n address payable receiver,\n bytes calldata depositHash,\n uint256 nativeTokenPriceInTransferredToken,\n uint256 tokenGasBaseFee,\n uint256 fromChainId,\n uint256 swapGasOverhead,\n SwapRequest[] calldata swapRequests,\n string memory swapAdaptor\n ) external nonReentrant onlyExecutor whenNotPaused {\n require(swapRequests.length > 0, \"Wrong method call\");\n require(\n swapAdaptorMap[swapAdaptor] != address(0),\n \"Swap adaptor not found\"\n );\n uint256[4]\n memory transferDetails = _calculateAmountAndDecreaseAvailableLiquidity(\n tokenAddress,\n amount,\n receiver,\n depositHash,\n nativeTokenPriceInTransferredToken,\n tokenGasBaseFee\n );\n if (tokenAddress == NATIVE) {\n (bool success, ) = swapAdaptorMap[swapAdaptor].call{\n value: transferDetails[0]\n }(\"\");\n require(success, \"Native Transfer to Adaptor Failed\");\n ISwapAdaptor(swapAdaptorMap[swapAdaptor]).swapNative(\n transferDetails[0],\n receiver,\n swapRequests\n );\n } else {\n {\n uint256 gasBeforeApproval = gasleft();\n SafeERC20Upgradeable.safeApprove(\n IERC20Upgradeable(tokenAddress),\n address(swapAdaptorMap[swapAdaptor]),\n 0\n );\n SafeERC20Upgradeable.safeApprove(\n IERC20Upgradeable(tokenAddress),\n address(swapAdaptorMap[swapAdaptor]),\n transferDetails[0]\n );\n swapGasOverhead += (gasBeforeApproval - gasleft());\n }\n {\n uint256 swapGasFee = calculateGasFee(\n tokenAddress,\n nativeTokenPriceInTransferredToken,\n swapGasOverhead,\n 0,\n _msgSender()\n );\n transferDetails[0] -= swapGasFee; \n transferDetails[3] += swapGasFee; \n }\n ISwapAdaptor(swapAdaptorMap[swapAdaptor]).swap(\n tokenAddress,\n transferDetails[0],\n receiver,\n swapRequests\n );\n }\n emit AssetSent(\n tokenAddress,\n amount,\n transferDetails[0],\n receiver,\n depositHash,\n fromChainId,\n transferDetails[1],\n transferDetails[2],\n transferDetails[3]\n );\n }", "function _calculateAmountAndDecreaseAvailableLiquidity(\n address tokenAddress,\n uint256 amount,\n address payable receiver,\n bytes calldata depositHash,\n uint256 nativeTokenPriceInTransferredToken,\n uint256 tokenGasBaseFee\n ) internal returns (uint256[4] memory) {\n uint256 initialGas = gasleft();\n TokenConfig memory config = tokenManager.getTransferConfig(\n tokenAddress\n );\n require(\n config.min <= amount && config.max >= amount,\n \"Withdraw amount not in Cap limit\"\n );\n require(receiver != address(0), \"Bad receiver address\");\n (bytes32 hashSendTransaction, bool status) = checkHashStatus(\n tokenAddress,\n amount,\n receiver,\n depositHash\n );\n require(!status, \"Already Processed\");\n processedHash[hashSendTransaction] = true;\n \n uint256[4] memory transferDetails = getAmountToTransferV2(\n initialGas,\n tokenAddress,\n amount,\n nativeTokenPriceInTransferredToken,\n tokenGasBaseFee\n );\n liquidityProviders.decreaseCurrentLiquidity(\n tokenAddress,\n transferDetails[0]\n );\n return transferDetails;\n }", "function getAmountToTransferV2(\n uint256 initialGas,\n address tokenAddress,\n uint256 amount,\n uint256 nativeTokenPriceInTransferredToken,\n uint256 tokenGasBaseFee\n ) internal returns (uint256[4] memory) {\n TokenInfo memory tokenInfo = tokenManager.getTokensInfo(tokenAddress);\n uint256 transferFeePerc = _getTransferFee(\n tokenAddress,\n amount,\n tokenInfo\n );\n uint256 lpFee;\n if (transferFeePerc > tokenInfo.equilibriumFee) {\n \n lpFee = (amount * tokenInfo.equilibriumFee) / BASE_DIVISOR;\n unchecked {\n incentivePool[tokenAddress] +=\n (amount * (transferFeePerc - tokenInfo.equilibriumFee)) /\n BASE_DIVISOR;\n }\n } else {\n lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n }\n uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n liquidityProviders.addLPFee(tokenAddress, lpFee);\n uint256 totalGasUsed = initialGas +\n tokenInfo.transferOverhead +\n baseGas -\n gasleft();\n uint256 gasFee = calculateGasFee(\n tokenAddress,\n nativeTokenPriceInTransferredToken,\n totalGasUsed,\n tokenGasBaseFee,\n _msgSender()\n );\n require(\n transferFeeAmount + gasFee <= amount,\n \"Insufficient funds to cover transfer fee\"\n );\n unchecked {\n uint256 amountToTransfer = amount - (transferFeeAmount + gasFee);\n return [amountToTransfer, lpFee, transferFeeAmount, gasFee];\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "ICICB Bridge", "functions": ["function deposit(address _token, uint _amount, uint _targetChain) external override payable {\n\t\taddress _account = msg.sender;\n\t\tuint256 size;\n assembly {size := extcodesize(_account)}\n\t\trequire(size==0, \"bridge: only personal\");\n\t\trequire(_account!=address(0), \"bridge: zero sender\");\n\t\tif (_token==address(0)) {\n\t\t\trequire(msg.value==_amount, \"bridge: amount\");\n\t\t} else {\n\t\t\tbool isPegged = tokenIndexes[_token]!=0;\n\t\t\tif (isPegged) {\n\t\t\t\tIRC20(_token).burnFrom(_account, _amount);\n\t\t\t} else {\n\t\t\t\tIRC20(_token).transferFrom(_account, address(this), _amount);\n\t\t\t}\n\t\t}\n\t\temit Deposit(_token, _account, _amount, _targetChain);\n\t}", "function withdraw(uint wad) public payable {\n require(balanceOf[msg.sender] >= wad);\n balanceOf[msg.sender] -= wad;\n function transfer(...) {...}\npayable(msg.sender).transfer(wad);\n emit Withdrawal(msg.sender, wad);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "ICICB Bridge", "functions": ["function transfer(uint[][] memory _args) external override payable onlyAdmin {\n\t\tfor(uint i=0; i<_args.length; i++) {\n\t\t\taddress _token \t\t= address(uint160(_args[i][0]));\n\t\t\taddress _to\t\t\t= address(uint160(_args[i][1]));\n\t\t\tuint _amount \t\t= _args[i][2];\n\t\t\tbytes32 _extra \t\t= bytes32(_args[i][3]);\n\t\t\tbool isPegged = false;\n\t\t\tif (!exists[_extra]) {\n\t\t\t\tif (_token==address(0)) {\n\t\t\t\t\tfunction transfer(...) {...}\npayable(_to).transfer(_amount);\n\t\t\t\t} else {\n\t\t\t\t\tisPegged = tokenIndexes[_token]!=0;\n\t\t\t\t\tif (isPegged) {\n\t\t\t\t\t\tIRC20(_token).mintTo(_to, _amount);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tIRC20(_token).transfer(_to, _amount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\texists[_extra] = true;\n\t\t\t}\n\t\t}\n\t}", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Instant Cross", "functions": ["function exchangeBuy(bytes32 pmId,bytes32 channel,bytes32 xHash, bytes memory goodsInfo, address goodsReceiptor,address payToken)public {\n bytes32 cctTxHash = keccak256(abi.encodePacked(nonce,address(this)));\n ProofRecord storage proofRecord = proofHistory[cctTxHash];\n require((proofRecord.cctTxHash == 0x0),\"proofRecord is exists\");\n proofRecord.toChain = cctChannel.getChannelCrossChain(channel);\n proofRecord.pmId = pmId;\n proofRecord.channel = channel;\n proofRecord.cctTxHash = cctTxHash;\n proofRecord.status = ProofStatus.LOCK;\n \n exchangBuyLockHandle(cctTxHash, channel,xHash, goodsInfo, goodsReceiptor,payToken);\n nonce +=1;\n currentTxHash = cctTxHash;\n emit ExchangeBuy(chainId,proofRecord.toChain,proofRecord.pmId,proofRecord.channel,cctTxHash,SRVID,ENTRYMOD_EXCHANGEBUYLOCK,xHash,goodsInfo,goodsReceiptor,payToken);\n }", "function exchangBuyLockHandle(bytes32 cctTxHash, bytes32 channel,bytes32 xHash, bytes memory goodsInfo, address goodsReceiptor,address payToken) private returns(bool){\n \n address goodsOwner;\n address receiptToken;\n uint amount;\n address subSrvGoods;\n subSrvGoods = cctChannel.getChannelSubSrv(channel,SRVID_GOODS);\n require(contractExists(subSrvGoods),\"GoodsProxy not exists\");\n (goodsOwner,receiptToken,amount) = GoodsProxy(subSrvGoods).buyLock(cctTxHash,xHash, goodsInfo, goodsReceiptor);\n setSubSrvStatus(cctTxHash,SRVID_GOODS,ProofStatus.LOCK);\n address subSrvExchange;\n address exchangeReceiptor;\n subSrvExchange = cctChannel.getChannelSubSrv(channel,SRVID_EXCHANGE);\n require(contractExists(subSrvExchange),\"ExchangeProxy not exists\");\n (exchangeReceiptor,amount) = ExchangeProxy(subSrvExchange).exchangeLock(cctTxHash,xHash, payToken, receiptToken,amount,goodsOwner);\n setSubSrvStatus(cctTxHash,SRVID_EXCHANGE,ProofStatus.LOCK);\n wrch_.lock(cctTxHash,xHash, payToken, amount, msg.sender,exchangeReceiptor);\n setSubSrvStatus(cctTxHash,SRVID_WRCH,ProofStatus.CONFIRM);\n return true;\n }", "function commit( bytes32 cctTxHash, bytes32 x) public{\n ProofRecord storage proofRecord = proofHistory[cctTxHash];\n\t require(proofRecord.cctTxHash != 0x0, \"proofRecord not exists\");\n require(proofRecord.status == ProofStatus.CONFIRM,\"proofRecord valid\");\n uint i;\n for (i = 0; i < proofRecord.subSrvStatuList.length; i++) {\n address subSrv;\n if(proofRecord.subSrvStatuList[i].srvId == SRVID_EXCHANGE){\n subSrv = cctChannel.getChannelSubSrv(proofRecord.channel,SRVID_EXCHANGE);\n \n Exchange(subSrv).exchangeCommit(cctTxHash,x);\n }else if(proofRecord.subSrvStatuList[i].srvId == SRVID_GOODS){\n subSrv = cctChannel.getChannelSubSrv(proofRecord.channel,SRVID_GOODS);\n \n Goods(subSrv).buyCommit(cctTxHash, x);\n }else{\n require(false,\"\");\n }\n }\n proofRecord.status = ProofStatus.COMMIT;\n emit Commit(chainId,cctChannel.getChannelCrossChain(proofRecord.channel),proofRecord.pmId,proofRecord.channel,proofRecord.cctTxHash,SRVID,ENTRYMOD_EXCHANGEBUYCOMMIT,x);\n }", "function exchangeCommit(bytes32 cctTxHash, bytes32 x) public authorized returns(bool){\n bytes32 xHash = keccak256(abi.encodePacked(x));\n HTLCInfo storage htlc = htlcHistory[cctTxHash];\n if(htlc.xHash == 0x0 || htlc.xHash != xHash || htlc.expireTime < now || htlc.status != HTLCStatus.LOCKED){\n return false;\n }\n htlc.status = HTLCStatus.COMMIT;\n incomeMap[htlc.currencyToken] = SafeMath.add(incomeMap[htlc.currencyToken],htlc.originAmount);\n emit ExchangeCommit(cctTxHash);\n return true;\n }", "function buyCommit(bytes32 cctTxHash, bytes32 x) public authorized returns(bool){\n bytes32 xHash = keccak256(abi.encodePacked(x));\n HTLCInfo storage htlc = htlcHistory[cctTxHash];\n if(htlc.xHash == 0x0 || htlc.xHash != xHash || htlc.expireTime < now || htlc.status != HTLCStatus.LOCKED){\n return false;\n }\n htlc.status = HTLCStatus.COMMIT;\n emit GoodsCommit(cctTxHash);\n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Instant Cross", "functions": ["function exchangePay(bytes32 pmId,bytes32 channel,bytes32 xHash, address payToken, address receiptToken,address receiptAddress,uint receiptAmount)public {\n bytes32 cctTxHash = keccak256(abi.encodePacked(nonce,address(this)));\n ProofRecord storage proofRecord = proofHistory[cctTxHash];\n require((proofRecord.cctTxHash == 0x0),\"proofRecord is exists\");\n proofRecord.toChain = cctChannel.getChannelCrossChain(channel);\n proofRecord.pmId = pmId;\n proofRecord.channel = channel;\n proofRecord.cctTxHash = cctTxHash;\n proofRecord.status = ProofStatus.LOCK;\n \n exchangePayHandle(cctTxHash, channel,xHash, payToken, msg.sender, receiptToken, receiptAddress, receiptAmount);\n nonce +=1;\n currentTxHash = cctTxHash;\n emit ExchangePay(chainId,proofRecord.toChain,proofRecord.pmId,proofRecord.channel,cctTxHash,SRVID,ENTRYMOD_EXCHANGEPAYLOCK,xHash,payToken,msg.sender,receiptToken,receiptAddress,receiptAmount);\n }", "function exchangePayHandle(bytes32 cctTxHash, bytes32 channel, bytes32 xHash, address payToken, address payAddress,address receiptToken,address receiptAddress,uint receiptAmount)private returns(bool){\n address subSrvExchange;\n address exchangeReceiptor;\n uint payAmount;\n subSrvExchange = cctChannel.getChannelSubSrv(channel,SRVID_EXCHANGE);\n require(contractExists(subSrvExchange),\"ExchangeProxy not exists\");\n (exchangeReceiptor,payAmount) = ExchangeProxy(subSrvExchange).exchangeLock(cctTxHash,xHash, payToken, receiptToken,receiptAmount,receiptAddress);\n setSubSrvStatus(cctTxHash,SRVID_EXCHANGE,ProofStatus.LOCK);\n wrch_.lock(cctTxHash,xHash, payToken, payAmount, payAddress,exchangeReceiptor);\n setSubSrvStatus(cctTxHash,SRVID_WRCH,ProofStatus.CONFIRM);\n return true;\n }", "function exchangeCommit(bytes32 cctTxHash, bytes32 x) public authorized returns(bool){\n bytes32 xHash = keccak256(abi.encodePacked(x));\n HTLCInfo storage htlc = htlcHistory[cctTxHash];\n if(htlc.xHash == 0x0 || htlc.xHash != xHash || htlc.expireTime < now || htlc.status != HTLCStatus.LOCKED){\n return false;\n }\n htlc.status = HTLCStatus.COMMIT;\n incomeMap[htlc.currencyToken] = SafeMath.add(incomeMap[htlc.currencyToken],htlc.originAmount);\n emit ExchangeCommit(cctTxHash);\n return true;\n }", "function buyCommit(bytes32 cctTxHash, bytes32 x) public authorized returns(bool){\n bytes32 xHash = keccak256(abi.encodePacked(x));\n HTLCInfo storage htlc = htlcHistory[cctTxHash];\n if(htlc.xHash == 0x0 || htlc.xHash != xHash || htlc.expireTime < now || htlc.status != HTLCStatus.LOCKED){\n return false;\n }\n htlc.status = HTLCStatus.COMMIT;\n emit GoodsCommit(cctTxHash);\n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Instant Cross", "functions": ["function exchangeRevoke(bytes32 cctTxHash) public authorized returns(bool){\n \n HTLCInfo storage htlc = htlcHistory[cctTxHash];\n if(htlc.xHash == 0x0) return false;\n if(htlc.sender != msg.sender) return false;\n if(htlc.expireTime >= now) return false;\n if(htlc.status != HTLCStatus.LOCKED) return false;\n reserveFund[htlc.targetToken] = SafeMath.add(reserveFund[htlc.targetToken],htlc.targetAmount);\n htlc.status = HTLCStatus.REVOKE;\n emit ExchangeRevoke(cctTxHash);\n return true;\n }", "function buyRevoke(bytes32 cctTxHash)public authorized returns(bool){\n \n HTLCInfo storage htlc = goodsLockMap[cctTxHash];\n if(htlc.xHash == 0x0) return false;\n if(htlc.sender != msg.sender) return false;\n if(htlc.expireTime >= now) return false;\n if(htlc.status != HTLCStatus.LOCKED) return false;\n goodsMap[htlc.goodsId] = SafeMath.add(goodsMap[htlc.goodsId], htlc.goodsAmount);\n htlc.status = HTLCStatus.REVOKE;\n emit GoodsRevoke(cctTxHash, htlc.goodsId, htlc.goodsReceiptor);\n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Instant Cross", "functions": ["function addCrossData(bytes32 fromChain, bytes32 toChain, bytes32 pmId, bytes memory proofData, bytes memory crossData) public {\n require(fromChain != toChain,\"fromChain is the same as the toChain\");\n require(cctRoot.getChainId() == toChain, \"bad chainId\");\n require(cctRoot.verify(pmId,proofData,crossData),\"no authorized pmId\");\n \n RLP.RLPItem[] memory ls = crossData.toRLPItem().toList(); \n uint i;\n for(i = 0; i < ls.length; i++){\n RLP.RLPItem[] memory pd = ls[i].toList();\n if(pd.length !=5 && pd.length != 4) {\n emit BadProofData(crossData,1);\n continue;\n }\n bytes32 channel = pd[0].toBytes32();\n bytes32 cctTxHash = pd[1].toBytes32();\n bytes32 fromSrv = pd[2].toBytes32();\n uint entryMod = pd[3].toUint();\n bytes memory businessProof = pd[4].toBytes();\n if(!cctChannel.authorized(pmId,channel)) {\n emit BadProofData(crossData,2);\n continue;\n }\n address entry = cctChannel.getChannelEntry(channel);\n if(entry == address(0x0) || !contractExists(entry)){\n emit ProofEvent(fromChain,toChain, pmId,channel,fromSrv,entryMod,cctTxHash,businessProof,false);\n continue;\n }\n if(BIZ(entry).handleProof(fromChain,toChain, pmId,channel,fromSrv,entryMod,cctTxHash,businessProof)){\n emit ProofEvent(fromChain,toChain, pmId,channel,fromSrv,entryMod,cctTxHash,businessProof,true);\n }else{\n emit ProofEvent(fromChain,toChain, pmId,channel,fromSrv,entryMod,cctTxHash,businessProof,false);\n }\n }\n }", "function exchangeBuyLock(bytes32 toChain, bytes32 pmId, bytes32 channel,bytes32 cctTxHash, bytes memory businessProof) private returns(bool){\n ProofRecord storage proofRecord = proofHistory[cctTxHash];\n if(proofRecord.cctTxHash != 0x0) return false;\n bytes32 xHash;\n bytes memory goodsInfo; \n address goodsReceiptor;\n address payToken;\n \n (xHash,goodsInfo,goodsReceiptor,payToken) = decodeBuyLock(businessProof);\n if(xHash == 0x0 && goodsReceiptor == address(0x0) && payToken == address(0x0)) return false;\n proofRecord.toChain = toChain;\n proofRecord.pmId = pmId;\n proofRecord.channel = channel;\n proofRecord.cctTxHash = cctTxHash;\n proofRecord.status = ProofStatus.LOCK;\n exchangBuyLockHandle(cctTxHash,channel,xHash, goodsInfo, goodsReceiptor,payToken);\n calAndUpdateProofStatus(cctTxHash);\n if (proofRecord.status == ProofStatus.CONFIRM){\n emit ExchangeBuyConfirm(chainId, cctChannel.getChannelCrossChain(channel), proofRecord.pmId, proofRecord.channel,cctTxHash, SRVID, ENTRYMOD_EXCHANGEBUYCOMFIRM);\n return true;\n }else{\n return false;\n }\n }", "function exchangBuyLockHandle(bytes32 cctTxHash,bytes32 channel,bytes32 xHash, bytes memory goodsInfo, address goodsReceiptor,address payToken) private returns(bool){\n address goodsOwner;\n address receiptToken;\n uint amount;\n address subSrvGoods;\n address subSrvExchange;\n bool goodsFlag = false;\n subSrvGoods = cctChannel.getChannelSubSrv(channel,SRVID_GOODS);\n \n (goodsOwner,receiptToken,amount) = Goods(subSrvGoods).buyLock(cctTxHash,xHash, goodsInfo, goodsReceiptor);\n if(goodsOwner == address(0x0) && receiptToken == address(0x0) && amount == 0) {\n setSubSrvStatus(cctTxHash,SRVID_GOODS,ProofStatus.LOCK);\n goodsFlag = false;\n }else{\n setSubSrvStatus(cctTxHash,SRVID_GOODS,ProofStatus.CONFIRM);\n goodsFlag = true;\n }\n bool exchangeFlag = false;\n subSrvExchange = cctChannel.getChannelSubSrv(channel,SRVID_EXCHANGE);\n \n if(!Exchange(subSrvExchange).exchangeLock(cctTxHash,xHash, payToken, receiptToken, amount, goodsOwner)) {\n setSubSrvStatus(cctTxHash,SRVID_EXCHANGE,ProofStatus.LOCK);\n exchangeFlag = false;\n }else{\n setSubSrvStatus(cctTxHash,SRVID_EXCHANGE,ProofStatus.CONFIRM);\n exchangeFlag = true;\n }\n return exchangeFlag && goodsFlag;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "iotube", "functions": ["function depositTo(address _token, address _to, uint256 _amount) public whenNotPaused payable {\n require(_to != address(0), \"invalid destination\");\n bool isCoin = false;\n uint256 fee = msg.value;\n if (_token == address(0)) {\n require(msg.value >= _amount, \"insufficient msg.value\");\n fee = msg.value - _amount;\n wrappedCoin.deposit.value(_amount)();\n _token = address(wrappedCoin);\n isCoin = true;\n }\n require(fee >= depositFee, \"insufficient fee\");\n for (uint256 i = 0; i < tokenLists.length; i++) {\n if (tokenLists[i].isAllowed(_token)) {\n require(_amount >= tokenLists[i].minAmount(_token), \"amount too low\");\n require(_amount <= tokenLists[i].maxAmount(_token), \"amount too high\");\n if (tokenSafes[i] == address(0)) {\n require(!isCoin && safeTransferFrom(_token, msg.sender, address(this), _amount), \"fail to transfer token to cashier\");\n \n (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x42966c68, _amount));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"fail to burn token\");\n } else {\n if (isCoin) {\n require(safeTransfer(_token, tokenSafes[i], _amount), \"failed to put into safe\");\n } else {\n require(safeTransferFrom(_token, msg.sender, tokenSafes[i], _amount), \"failed to put into safe\");\n }\n }\n counts[_token] += 1;\n emit Receipt(_token, counts[_token], msg.sender, _to, _amount, fee);\n return;\n }\n }\n revert(\"not a whitelisted token\");\n }", "function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n \n (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x23b872dd, _from, _to, _amount));\n return success && (data.length == 0 || abi.decode(data, (bool)));\n }", "function safeTransfer(address _token, address _to, uint256 _amount) internal returns (bool) {\n \n (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0xa9059cbb, _to, _amount));\n return success && (data.length == 0 || abi.decode(data, (bool)));\n }", "function addToken(address _token, uint256 _min, uint256 _max) public onlyOwner returns (bool success_) {\n if (activateItem(_token)) {\n require(_min > 0 && _max > _min, \"invalid parameters\");\n settings[_token] = Setting(_min, _max);\n emit TokenAdded(_token, _min, _max);\n success_ = true;\n }\n }", "function activateItem(address _item) internal returns (bool) {\n if (existAndActives[_item].active) {\n return false;\n }\n if (!existAndActives[_item].exist) {\n items.push(_item);\n }\n num++;\n existAndActives[_item] = ExistAndActive(true, true);\n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "iotube", "functions": ["function deactivateItem(address _item) internal returns (bool) {\n if (existAndActives[_item].exist && existAndActives[_item].active) {\n num--;\n existAndActives[_item].active = false;\n return true;\n }\n return false;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "KCC", "functions": ["function depositNative(string memory _targetAddress, string memory chain) public payable {\n require(msg.value >= swapFee, \"Bridge:insufficient swap fee\");\n if (swapFee != 0) {\n payable(feeTo).transfer(swapFee);\n }\n emit DepositNative(msg.sender, msg.value - swapFee, _targetAddress, chain, swapFee);\n }", "function withdrawNative(address payable to, uint value, string memory proof, bytes32 taskHash) public\n onlyOperator\n whenNotPaused\n positiveValue(value)\n returns (bool)\n {\n require(address(this).balance >= value, \"Bridge:not enough native token\");\n require(taskHash == keccak256((abi.encodePacked(to, value, proof))), \"Bridge:taskHash is wrong\");\n require(!filledTx[taskHash], \"Bridge:tx filled already\");\n uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n if (status == logic.TASKPROCESSING()) {\n emit WithdrawingNative(to, value, proof);\n } else if (status == logic.TASKDONE()) {\n emit WithdrawingNative(to, value, proof);\n emit WithdrawDoneNative(to, value, proof);\n to.transfer(value);\n filledTx[taskHash] = true;\n logic.removeTask(taskHash);\n }\n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "KCC", "functions": ["function depositToken(address _token, uint value, string memory _targetAddress, string memory chain) public payable returns (bool) {\n require(msg.value == swapFee, \"Bridge:swap fee not equal\");\n if (swapFee != 0) {\n payable(feeTo).transfer(swapFee);\n }\n bool res = depositTokenLogic(_token, msg.sender, value);\n emit DepositToken(msg.sender, value, _token, _targetAddress, chain, swapFee);\n return res;\n }", "function depositTokenLogic(address token, address _from, uint256 _value) internal returns (bool) {\n bool status = false;\n bytes memory returnedData;\n if (bytes(depositSelector[token].selector).length == 0) {\n (status, returnedData) = token.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _from, this, _value));\n }\n else {\n assetSelector memory aselector = depositSelector[token];\n if (aselector.isValueFirst) {\n (status, returnedData) = token.call(abi.encodeWithSignature(aselector.selector, _value, _from));\n }\n else {\n (status, returnedData) = token.call(abi.encodeWithSignature(aselector.selector, _from, _value));\n }\n }\n require(status && (returnedData.length == 0 || abi.decode(returnedData, (bool))), 'Bridge:deposit failed');\n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "KCC", "functions": ["function withdrawNative(address payable to, uint value, string memory proof, bytes32 taskHash) public\n onlyOperator\n whenNotPaused\n positiveValue(value)\n returns (bool)\n {\n require(address(this).balance >= value, \"Bridge:not enough native token\");\n require(taskHash == keccak256((abi.encodePacked(to, value, proof))), \"Bridge:taskHash is wrong\");\n require(!filledTx[taskHash], \"Bridge:tx filled already\");\n function supportTask(...) {...}\nfunction removeTask(...) {...}\nuint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n if (status == logic.TASKPROCESSING()) {\n emit WithdrawingNative(to, value, proof);\n } else if (status == logic.TASKDONE()) {\n emit WithdrawingNative(to, value, proof);\n emit WithdrawDoneNative(to, value, proof);\n to.transfer(value);\n filledTx[taskHash] = true;\n logic.removeTask(taskHash);\n }\n return true;\n }", "function supportTask(uint256 taskType, bytes32 taskHash, address oneAddress, uint256 requireNum) external onlyCaller returns (uint256) {\n function supporterExists(...) {...}\nfunction addSupporter(...) {...}\nfunction setTaskInfo(...) {...}\nrequire(!store.supporterExists(taskHash, oneAddress), \"BridgeLogic:supporter already exists\");\n (uint256 theTaskType,uint256 theTaskStatus,uint256 theSupporterNum) = store.getTaskInfo(taskHash);\n require(theTaskStatus < TASKDONE, \"BridgeLogic:wrong status\");\n if (theTaskStatus != TASKINIT)\n require(theTaskType == taskType, \"BridgeLogic:task type not match\");\n store.addSupporter(taskHash, oneAddress);\n theSupporterNum++;\n if (theSupporterNum >= requireNum)\n theTaskStatus = TASKDONE;\n else\n theTaskStatus = TASKPROCESSING;\n store.setTaskInfo(taskHash, taskType, theTaskStatus);\n return theTaskStatus;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "KCC", "functions": ["function withdrawToken(address _token, address to, uint value, string memory proof, bytes32 taskHash) public\n onlyOperator\n whenNotPaused\n positiveValue(value)\n returns (bool)\n {\n require(taskHash == keccak256((abi.encodePacked(to, value, proof))), \"Bridge:taskHash is wrong\");\n require(!filledTx[taskHash], \"Bridge:tx filled already\");\n function supportTask(...) {...}\nfunction removeTask(...) {...}\nuint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n if (status == logic.TASKPROCESSING()) {\n emit WithdrawingToken(to, _token, value, proof);\n } else if (status == logic.TASKDONE()) {\n bool res = withdrawTokenLogic(_token, to, value);\n emit WithdrawingToken(to, _token, value, proof);\n emit WithdrawDoneToken(to, _token, value, proof);\n filledTx[taskHash] = true;\n logic.removeTask(taskHash);\n return res;\n }\n return true;\n }", "function supportTask(uint256 taskType, bytes32 taskHash, address oneAddress, uint256 requireNum) external onlyCaller returns (uint256) {\n function supporterExists(...) {...}\nfunction addSupporter(...) {...}\nfunction setTaskInfo(...) {...}\nrequire(!store.supporterExists(taskHash, oneAddress), \"BridgeLogic:supporter already exists\");\n (uint256 theTaskType,uint256 theTaskStatus,uint256 theSupporterNum) = store.getTaskInfo(taskHash);\n require(theTaskStatus < TASKDONE, \"BridgeLogic:wrong status\");\n if (theTaskStatus != TASKINIT)\n require(theTaskType == taskType, \"BridgeLogic:task type not match\");\n store.addSupporter(taskHash, oneAddress);\n theSupporterNum++;\n if (theSupporterNum >= requireNum)\n theTaskStatus = TASKDONE;\n else\n theTaskStatus = TASKPROCESSING;\n store.setTaskInfo(taskHash, taskType, theTaskStatus);\n return theTaskStatus;\n }", "function withdrawTokenLogic(address token, address _to, uint256 _value) internal returns (bool) {\n bool status = false;\n bytes memory returnedData;\n if (bytes(withdrawSelector[token].selector).length == 0) {\n (status, returnedData) = token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _value));\n }\n else {\n assetSelector memory aselector = withdrawSelector[token];\n if (aselector.isValueFirst) {\n (status, returnedData) = token.call(abi.encodeWithSignature(aselector.selector, _value, _to));\n }\n else {\n (status, returnedData) = token.call(abi.encodeWithSignature(aselector.selector, _to, _value));\n }\n }\n require(status && (returnedData.length == 0 || abi.decode(returnedData, (bool))), 'Bridge:withdraw failed');\n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "LI.FI", "functions": ["function startBridgeTokensViaAmarok(\n BridgeData calldata _bridgeData,\n AmarokData calldata _amarokData\n )\n external\n payable\n nonReentrant\n refundExcessNative(payable(msg.sender))\n doesNotContainSourceSwaps(_bridgeData)\n validateBridgeData(_bridgeData)\n noNativeAsset(_bridgeData)\n {\n validateDestinationCallFlag(_bridgeData, _amarokData);\n LibAsset.depositAsset(\n _bridgeData.sendingAssetId,\n _bridgeData.minAmount\n );\n function _startBridge(...) {...}\n_startBridge(_bridgeData, _amarokData);\n }", "function _startBridge(\n BridgeData memory _bridgeData,\n AmarokData calldata _amarokData\n ) private {\n \n LibAsset.maxApproveERC20(\n IERC20(_bridgeData.sendingAssetId),\n address(connextHandler),\n _bridgeData.minAmount\n );\n \n connextHandler.xcall{ value: _amarokData.relayerFee }(\n _amarokData.destChainDomainId,\n _amarokData.callTo,\n _bridgeData.sendingAssetId,\n _amarokData.delegate,\n _bridgeData.minAmount,\n _amarokData.slippageTol,\n _amarokData.callData\n );\n emit LiFiTransferStarted(_bridgeData);\n }", "function maxApproveERC20(\n IERC20 assetId,\n address spender,\n uint256 amount\n ) internal {\n if (isNativeAsset(address(assetId))) {\n return;\n }\n if (spender == NULL_ADDRESS) {\n revert NullAddrIsNotAValidSpender();\n }\n if (assetId.allowance(address(this), spender) < amount) {\n SafeERC20.safeApprove(IERC20(assetId), spender, 0);\n SafeERC20.safeApprove(IERC20(assetId), spender, MAX_UINT);\n }\n }", "function depositAsset(address assetId, uint256 amount) internal {\n if (amount == 0) revert InvalidAmount();\n if (isNativeAsset(assetId)) {\n if (msg.value < amount) revert InvalidAmount();\n } else {\n uint256 balance = IERC20(assetId).balanceOf(msg.sender);\n if (balance < amount) revert InsufficientBalance(amount, balance);\n transferFromERC20(assetId, msg.sender, address(this), amount);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MapProtocol", "functions": ["function transferOutNative(uint amount) external payable {\n IWToken(0xf984Ad9299B0102426a646aF72e2052a3A7eD0E2).deposit{value : amount}();\n }", "function transferInNative(address payable to, uint amount) external{\n IWToken(0xf70949Bc9B52DEFfCda63B0D15608d601e3a7C49).withdraw(amount);\n function safeTransferETH(...) {...}\nTransferHelper.safeTransferETH(to,amount);\n }", "function safeTransferETH(address to, uint value) internal {\n (bool success,) = to.call{value : value}(new bytes(0));\n require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MapProtocol", "functions": ["function transferOutTokenBurn(address token, address to, uint amount, uint toChainId) external payable\n checkBalance(token,msg.sender,amount) {\n function safeTransferFrom(...) {...}\nTransferHelper.safeTransferFrom(token,msg.sender,address(this),amount);\n collectChainFee(toChainId,0);\n uint outAmount = getAmountWithdraw(amount);\n transferFeeList[token] = transferFeeList[token].add(amount).sub(outAmount);\n IMAPToken(token).burn(outAmount);\n bytes32 orderId = getOrderID(token, msg.sender, to, outAmount, toChainId);\n emit mapTransferOut(token, msg.sender, to, orderId, outAmount, selfChainId, toChainId);\n }", "function safeTransferFrom(address token, address from, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n }", "function transferInToken(address token, address from, address payable to, uint amount, bytes32 orderId, uint fromChain, uint toChain)\n external checkOrder(orderId) nonReentrant onlyManager{\n uint outAmount = getAmountWithdraw(amount);\n if (toChain == selfChainId) {\n require(IERC20(token).balanceOf(address(this)) >= amount,\"balance too low\");\n function safeTransfer(...) {...}\nTransferHelper.safeTransfer(token,to,amount);\n emit mapTransferIn(token, from, to, orderId, outAmount, fromChain, toChain);\n }else{\n emit mapTransferOut(token, from, to, orderId, outAmount, fromChain, toChain);\n }\n }", "function safeTransfer(address token, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MapProtocol", "functions": ["function transferOutToken(address token, address to, uint amount, uint toChainId) external payable\n checkBalance(token,msg.sender,amount) {\n function safeTransferFrom(...) {...}\nTransferHelper.safeTransferFrom(token,msg.sender,address(this),amount);\n collectChainFee(toChainId,0);\n uint outAmount = getAmountWithdraw(amount);\n transferFeeList[token] = transferFeeList[token].add(amount).sub(outAmount);\n bytes32 orderId = getOrderID(token, msg.sender, to, outAmount, toChainId);\n emit mapTransferOut(token, msg.sender, to, orderId, outAmount, selfChainId, toChainId);\n }", "function safeTransferFrom(address token, address from, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n }", "function transferInTokenMint(address token, address from, address payable to, uint amount, bytes32 orderId, uint fromChain, uint toChain)\n external checkOrder(orderId) nonReentrant onlyManager{\n IMAPToken(token).mint(address(this), amount);\n uint outAmount = getAmountWithdraw(amount);\n if (toChain == selfChainId){\n function safeTransfer(...) {...}\nTransferHelper.safeTransfer(token,to,amount);\n emit mapTransferIn(token, from, to, orderId, outAmount, fromChain, toChain);\n }else{\n IMAPToken(token).burn(outAmount);\n emit mapTransferOut(token, from, to, orderId, outAmount, fromChain, toChain);\n }\n }", "function safeTransfer(address token, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MapProtocol", "functions": ["function register() external payable override {\n require(\n msg.value >= minStakeAmount,\n \"Relayer: insufficient stake amount\"\n );\n require(!_relayers.contains(msg.sender), \"Relayer: already registered\");\n function _addRelayer(...) {...}\n_addRelayer(msg.sender, msg.value);\n emit Register(msg.sender, msg.value);\n }", "function _addRelayer(address _relayer, uint256 _amount) internal {\n RelayerInfo storage ri = _relayerInfo[_relayer];\n ri.amount = _amount;\n _relayers.add(_relayer);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MapProtocol", "functions": ["function unregister() external override onlyRelayer {\n function _removeRelayer(...) {...}\nuint256 amount = _removeRelayer(msg.sender);\n refund[msg.sender] = amount;\n emit Unregister(msg.sender, amount);\n }", "function _removeRelayer(address _relayer)\n internal\n returns (uint256 amount)\n {\n RelayerInfo storage ri = _relayerInfo[_relayer];\n amount = ri.amount;\n \n for (uint256 i = 0; i < ri.chainIdList.length; i++) {\n uint256 chainId = ri.chainIdList[i];\n delete bindRelayer[ri.worker[chainId]][chainId];\n }\n delete _relayerInfo[_relayer];\n _relayers.remove(_relayer);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MapProtocol", "functions": ["function withdraw() external override {\n require(refund[msg.sender] > 0, \"Relayer: zero refund\");\n \n uint256 amount = refund[msg.sender];\n refund[msg.sender] = 0;\n Address.sendValue(payable(msg.sender), amount);\n emit Withdraw(msg.sender, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MapProtocol", "functions": ["function bindingWorker(uint256 _chainId, bytes32 _worker)\n external\n override\n onlyRelayer\n {\n require(\n bindRelayer[_worker][_chainId] == address(0),\n \"Relayer: worker already binded\"\n );\n _setBindAddress(msg.sender, _worker, _chainId);\n emit WorkerSet(msg.sender, _chainId, _worker);\n }", "function _setBindAddress(\n address _relayer,\n bytes32 _worker,\n uint256 _chainId\n ) internal {\n RelayerInfo storage ri = _relayerInfo[_relayer];\n if (ri.worker[_chainId] == bytes32(0)) {\n \n ri.chainIdList.push(_chainId);\n }\n ri.worker[_chainId] = _worker;\n bindRelayer[_worker][_chainId] = _relayer;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meson", "functions": ["function postSwap(uint256 encodedSwap, bytes32 r, bytes32 s, uint8 v, uint200 postingValue)\n external matchProtocolVersion(encodedSwap) forInitialChain(encodedSwap)\n {\n require(_postedSwaps[encodedSwap] == 0, \"Swap already exists\");\n uint256 amount = _amountFrom(encodedSwap);\n require(amount <= MAX_SWAP_AMOUNT, \"For security reason, amount cannot be greater than 100k\");\n uint256 delta = _expireTsFrom(encodedSwap) - block.timestamp;\n \n require(delta > MIN_BOND_TIME_PERIOD, \"Expire ts too early\");\n require(delta < MAX_BOND_TIME_PERIOD, \"Expire ts too late\");\n uint40 poolIndex = _poolIndexFromPosted(postingValue);\n if (poolIndex > 0) {\n \n require(poolOfAuthorizedAddr[_msgSender()] == poolIndex, \"Signer should be an authorized address of the given pool\");\n } \n address initiator = _initiatorFromPosted(postingValue);\n _checkRequestSignature(encodedSwap, r, s, v, initiator);\n _postedSwaps[encodedSwap] = postingValue;\n uint8 tokenIndex = _inTokenIndexFrom(encodedSwap);\n _unsafeDepositToken(tokenForIndex[tokenIndex], initiator, amount, tokenIndex);\n emit SwapPosted(encodedSwap);\n }", "function _checkRequestSignature(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_33 : TRON_SIGN_HEADER, encodedSwap));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER, encodedSwap));\n } else {\n bytes32 typehash = REQUEST_TYPE_HASH;\n assembly {\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 32))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }", "function _unsafeDepositToken(\n address token,\n address sender,\n uint256 amount,\n uint8 tokenIndex\n ) internal {\n require(token != address(0), \"Token not supported\");\n require(amount > 0, \"Amount must be greater than zero\");\n require(Address.isContract(token), \"The given token address is not a contract\");\n if (_needAdjustAmount(tokenIndex)) {\n amount *= 1e12;\n }\n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(\n ERC20_TRANSFER_FROM_SELECTOR,\n sender,\n address(this),\n amount\n ));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"transferFrom failed\");\n }", "function lock(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address initiator\n ) external matchProtocolVersion(encodedSwap) forTargetChain(encodedSwap) {\n bytes32 swapId = _getSwapId(encodedSwap, initiator);\n require(_lockedSwaps[swapId] == 0, \"Swap already exists\");\n _checkRequestSignature(encodedSwap, r, s, v, initiator);\n uint40 poolIndex = poolOfAuthorizedAddr[_msgSender()];\n require(poolIndex != 0, \"Caller not registered. Call depositAndRegister.\");\n uint256 until = block.timestamp + LOCK_TIME_PERIOD;\n require(until < _expireTsFrom(encodedSwap) - 5 minutes, \"Cannot lock because expireTs is soon.\");\n uint48 poolTokenIndex = _poolTokenIndexForOutToken(encodedSwap, poolIndex);\n \n _balanceOfPoolToken[poolTokenIndex] -= (_amountFrom(encodedSwap) - _feeForLp(encodedSwap));\n _lockedSwaps[swapId] = _lockedSwapFrom(until, poolIndex);\n emit SwapLocked(encodedSwap);\n }", "function _checkRequestSignature(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_33 : TRON_SIGN_HEADER, encodedSwap));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER, encodedSwap));\n } else {\n bytes32 typehash = REQUEST_TYPE_HASH;\n assembly {\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 32))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meson", "functions": ["function bondSwap(uint256 encodedSwap, uint40 poolIndex) external {\n uint200 postedSwap = _postedSwaps[encodedSwap];\n require(postedSwap > 1, \"Swap does not exist\");\n require(_poolIndexFromPosted(postedSwap) == 0, \"Swap bonded to another pool\");\n require(poolOfAuthorizedAddr[_msgSender()] == poolIndex, \"Signer should be an authorized address of the given pool\");\n _postedSwaps[encodedSwap] = postedSwap | poolIndex;\n emit SwapBonded(encodedSwap);\n }", "function release(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address initiator,\n address recipient\n ) external {\n bool feeWaived = _feeWaived(encodedSwap);\n if (feeWaived) {\n \n _onlyPremiumManager();\n }\n \n bytes32 swapId = _getSwapId(encodedSwap, initiator);\n uint80 lockedSwap = _lockedSwaps[swapId];\n require(lockedSwap != 0, \"Swap does not exist\");\n require(recipient != address(0), \"Recipient cannot be zero address\");\n function release(...) {...}\nrequire(_expireTsFrom(encodedSwap) > block.timestamp, \"Cannot release because expired\");\n _checkReleaseSignature(encodedSwap, recipient, r, s, v, initiator);\n _lockedSwaps[swapId] = 0;\n uint8 tokenIndex = _outTokenIndexFrom(encodedSwap);\n \n uint256 releaseAmount = _amountFrom(encodedSwap) - _feeForLp(encodedSwap);\n if (!feeWaived) { \n uint256 serviceFee = _serviceFee(encodedSwap);\n \n releaseAmount -= serviceFee;\n \n \n \n \n _balanceOfPoolToken[_poolTokenIndexForOutToken(encodedSwap, 0)] += serviceFee;\n }\n _release(encodedSwap, tokenIndex, initiator, recipient, releaseAmount);\n emit SwapReleased(encodedSwap);\n }", "function _checkReleaseSignature(\n uint256 encodedSwap,\n address recipient,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_53 : TRON_SIGN_HEADER, encodedSwap, recipient));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER_52, encodedSwap, recipient));\n } else {\n bytes32 typehash = _outChainFrom(encodedSwap) == 0x00c3 ? RELEASE_TO_TRON_TYPE_HASH : RELEASE_TYPE_HASH;\n assembly {\n mstore(20, recipient)\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 52))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }", "function _transferToContract(\n address token,\n address contractAddr,\n address beneficiary,\n uint256 amount,\n uint8 tokenIndex,\n uint64 data\n ) internal {\n require(Address.isContract(token), \"The given token address is not a contract\");\n require(Address.isContract(contractAddr), \"The given recipient address is not a contract\");\n if (_needAdjustAmount(tokenIndex)) {\n amount *= 1e12;\n }\n IERC20Minimal(token).approve(contractAddr, amount);\n ITransferWithBeneficiary(contractAddr).transferWithBeneficiary(token, amount, beneficiary, data);\n }", "function _safeTransfer(\n address token,\n address recipient,\n uint256 amount,\n uint8 tokenIndex\n ) internal {\n require(Address.isContract(token), \"The given token address is not a contract\");\n if (_needAdjustAmount(tokenIndex)) {\n amount *= 1e12;\n }\n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(\n ERC20_TRANSFER_SELECTOR,\n recipient,\n amount\n ));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"transfer failed\");\n \n \n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meson", "functions": ["function _checkRequestSignature(\n uint256 encodedSwap,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_33 : TRON_SIGN_HEADER, encodedSwap));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER, encodedSwap));\n } else {\n bytes32 typehash = REQUEST_TYPE_HASH;\n assembly {\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 32))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meson", "functions": ["function _checkReleaseSignature(\n uint256 encodedSwap,\n address recipient,\n bytes32 r,\n bytes32 s,\n uint8 v,\n address signer\n ) internal pure {\n require(signer != address(0), \"Signer cannot be empty address\");\n require(v == 27 || v == 28, \"Invalid signature\");\n require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature\");\n bool nonTyped = _signNonTyped(encodedSwap);\n bytes32 digest;\n if (_inChainFrom(encodedSwap) == 0x00c3) {\n digest = keccak256(abi.encodePacked(nonTyped ? TRON_SIGN_HEADER_53 : TRON_SIGN_HEADER, encodedSwap, recipient));\n } else if (nonTyped) {\n digest = keccak256(abi.encodePacked(ETH_SIGN_HEADER_52, encodedSwap, recipient));\n } else {\n bytes32 typehash = _outChainFrom(encodedSwap) == 0x00c3 ? RELEASE_TO_TRON_TYPE_HASH : RELEASE_TYPE_HASH;\n assembly {\n mstore(20, recipient)\n mstore(0, encodedSwap)\n mstore(32, keccak256(0, 52))\n mstore(0, typehash)\n digest := keccak256(0, 64)\n }\n }\n require(signer == ecrecover(digest, v, r, s), \"Invalid signature\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meter Passport", "functions": ["function deposit(\n bytes32 resourceID,\n uint8 destinationChainID,\n uint64 depositNonce,\n address depositer,\n bytes calldata data\n ) external override onlyBridge {\n bytes memory recipientAddress;\n uint256 amount;\n uint256 lenRecipientAddress;\n assembly {\n amount := calldataload(0xC4)\n recipientAddress := mload(0x40)\n lenRecipientAddress := calldataload(0xE4)\n mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))\n calldatacopy(\n recipientAddress, \n 0xE4, \n sub(calldatasize(), 0xE) \n )\n }\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress != _wtokenAddress) {\n if (_burnList[tokenAddress]) {\n burnERC20(tokenAddress, depositer, amount);\n } else {\n lockERC20(tokenAddress, depositer, address(this), amount);\n }\n }\n _depositRecords[destinationChainID][depositNonce] = DepositRecord(\n tokenAddress,\n uint8(lenRecipientAddress),\n destinationChainID,\n resourceID,\n recipientAddress,\n depositer,\n amount\n );\n }", "function burnERC20(address tokenAddress, address owner, uint256 amount) internal {\n ERC20Burnable erc20 = ERC20Burnable(tokenAddress);\n function burnFrom(...) {...}\nerc20.burnFrom(owner, amount);\n }", "function lockERC20(address tokenAddress, address owner, address recipient, uint256 amount) internal {\n IERC20 erc20 = IERC20(tokenAddress);\n function _safeTransferFrom(...) {...}\n_safeTransferFrom(erc20, owner, recipient, amount);\n }", "function _safeTransferFrom(IERC20 token, address from, address to, uint256 value) private {\n function _safeCall(...) {...}\n_safeCall(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n }", "function _safeCall(IERC20 token, bytes memory data) private { \n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"ERC20: call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"ERC20: operation did not succeed\");\n }\n }", "function deposit(\n bytes32 resourceID,\n uint8 destinationChainID,\n uint64 depositNonce,\n address depositer,\n bytes calldata data\n ) external override onlyBridge {\n bytes memory recipientAddress;\n uint256 amount;\n uint256 lenRecipientAddress;\n assembly {\n amount := calldataload(0xC4)\n recipientAddress := mload(0x40)\n lenRecipientAddress := calldataload(0xE4)\n mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))\n calldatacopy(\n recipientAddress, \n 0xE4, \n sub(calldatasize(), 0xE) \n )\n }\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress != _wtokenAddress) {\n if (_burnList[tokenAddress]) {\n burnERC20(tokenAddress, depositer, amount);\n } else {\n lockERC20(tokenAddress, depositer, address(this), amount);\n }\n }\n _depositRecords[destinationChainID][depositNonce] = DepositRecord(\n tokenAddress,\n uint8(lenRecipientAddress),\n destinationChainID,\n resourceID,\n recipientAddress,\n depositer,\n amount\n );\n }", "function burnERC20(address tokenAddress, address owner, uint256 amount) internal {\n ERC20Burnable erc20 = ERC20Burnable(tokenAddress);\n function burnFrom(...) {...}\nerc20.burnFrom(owner, amount);\n }", "function lockERC20(address tokenAddress, address owner, address recipient, uint256 amount) internal {\n IERC20 erc20 = IERC20(tokenAddress);\n function _safeTransferFrom(...) {...}\n_safeTransferFrom(erc20, owner, recipient, amount);\n }", "function _safeTransferFrom(IERC20 token, address from, address to, uint256 value) private {\n function _safeCall(...) {...}\n_safeCall(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n }", "function _safeCall(IERC20 token, bytes memory data) private { \n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"ERC20: call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"ERC20: operation did not succeed\");\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meter Passport", "functions": ["function voteProposal(uint8 chainID, uint64 depositNonce, bytes32 resourceID, bytes32 dataHash) external onlyRelayers whenNotPaused {\n uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(chainID);\n Proposal storage proposal = _proposals[nonceAndID][dataHash];\n require(_resourceIDToHandlerAddress[resourceID] != address(0), \"no handler for resourceID\");\n require(uint(proposal._status) <= 1, \"proposal already passed/executed/cancelled\");\n require(!_hasVotedOnProposal[nonceAndID][dataHash][msg.sender], \"relayer already voted\");\n if (uint(proposal._status) == 0) {\n ++_totalProposals;\n _proposals[nonceAndID][dataHash] = Proposal({\n _resourceID : resourceID,\n _dataHash : dataHash,\n _yesVotes : new address[](1),\n _noVotes : new address[](0),\n _status : ProposalStatus.Active,\n _proposedBlock : block.number\n });\n proposal._yesVotes[0] = msg.sender;\n emit ProposalEvent(chainID, depositNonce, ProposalStatus.Active, resourceID, dataHash);\n } else {\n if (sub(block.number, proposal._proposedBlock) > _expiry) {\n \n \n proposal._status = ProposalStatus.Cancelled;\n emit ProposalEvent(chainID, depositNonce, ProposalStatus.Cancelled, resourceID, dataHash);\n } else {\n require(dataHash == proposal._dataHash, \"datahash mismatch\");\n proposal._yesVotes.push(msg.sender);\n }\n }\n if (proposal._status != ProposalStatus.Cancelled) {\n _hasVotedOnProposal[nonceAndID][dataHash][msg.sender] = true;\n emit ProposalVote(chainID, depositNonce, proposal._status, resourceID);\n \n \n if (_relayerThreshold <= 1 || proposal._yesVotes.length >= _relayerThreshold) {\n proposal._status = ProposalStatus.Passed;\n emit ProposalEvent(chainID, depositNonce, ProposalStatus.Passed, resourceID, dataHash);\n }\n }\n }", "function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint256 amount;\n bytes memory destinationRecipientAddress;\n assembly {\n amount := calldataload(0x64)\n destinationRecipientAddress := mload(0x40)\n let lenDestinationRecipientAddress := calldataload(0x84)\n mstore(0x40, add(0x20, add(destinationRecipientAddress, lenDestinationRecipientAddress)))\n \n calldatacopy(\n destinationRecipientAddress, \n 0x84, \n sub(calldatasize(), 0x84) \n )\n }\n bytes20 recipientAddress;\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress == _wtokenAddress) {\n IWETH(_wtokenAddress).withdraw(amount);\n \n TransferHelper.safeTransferETH(address(recipientAddress), amount);\n return;\n }\n if (_burnList[tokenAddress]) {\n mintERC20(tokenAddress, address(recipientAddress), amount);\n } else {\n releaseERC20(tokenAddress, address(recipientAddress), amount);\n }\n }", "function mintERC20(address tokenAddress, address recipient, uint256 amount) internal {\n ERC20PresetMinterPauser erc20 = ERC20PresetMinterPauser(tokenAddress);\n function mint(...) {...}\nerc20.mint(recipient, amount);\n }", "function releaseERC20(address tokenAddress, address recipient, uint256 amount) internal {\n IERC20 erc20 = IERC20(tokenAddress);\n function _safeTransfer(...) {...}\n_safeTransfer(erc20, recipient, amount);\n }", "function _safeTransfer(IERC20 token, address to, uint256 value) private {\n function _safeCall(...) {...}\n_safeCall(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n }", "function _safeCall(IERC20 token, bytes memory data) private { \n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"ERC20: call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"ERC20: operation did not succeed\");\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meter Passport", "functions": ["function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint256 amount;\n bytes memory destinationRecipientAddress;\n assembly {\n amount := calldataload(0x64)\n destinationRecipientAddress := mload(0x40)\n let lenDestinationRecipientAddress := calldataload(0x84)\n mstore(0x40, add(0x20, add(destinationRecipientAddress, lenDestinationRecipientAddress)))\n \n calldatacopy(\n destinationRecipientAddress, \n 0x84, \n sub(calldatasize(), 0x84) \n )\n }\n bytes20 recipientAddress;\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress == _wtokenAddress) {\n IWETH(_wtokenAddress).withdraw(amount);\n \n TransferHelper.safeTransferETH(address(recipientAddress), amount);\n return;\n }\n if (_burnList[tokenAddress]) {\n mintERC20(tokenAddress, address(recipientAddress), amount);\n } else {\n releaseERC20(tokenAddress, address(recipientAddress), amount);\n }\n }", "function mintERC20(address tokenAddress, address recipient, uint256 amount) internal {\n ERC20PresetMinterPauser erc20 = ERC20PresetMinterPauser(tokenAddress);\n function mint(...) {...}\nerc20.mint(recipient, amount);\n }", "function releaseERC20(address tokenAddress, address recipient, uint256 amount) internal {\n IERC20 erc20 = IERC20(tokenAddress);\n function _safeTransfer(...) {...}\n_safeTransfer(erc20, recipient, amount);\n }", "function _safeTransfer(IERC20 token, address to, uint256 value) private {\n function _safeCall(...) {...}\n_safeCall(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n }", "function _safeCall(IERC20 token, bytes memory data) private { \n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"ERC20: call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"ERC20: operation did not succeed\");\n }\n }", "function voteProposal(\n uint8 domainID,\n uint64 depositNonce,\n bytes32 resourceID,\n bytes calldata data\n ) external onlyRelayers whenNotPaused nonReentrant {\n address handler = _resourceIDToHandlerAddress[resourceID];\n uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(domainID);\n bytes32 dataHash = keccak256(\n abi.encodePacked(resourceID, handler, data)\n );\n Proposal memory proposal = _proposals[nonceAndID][dataHash];\n require(\n _resourceIDToHandlerAddress[resourceID] != address(0),\n \"no handler for resourceID\"\n );\n if (proposal._status == ProposalStatus.Passed) {\n _executeProposal(domainID, depositNonce, data, resourceID, true);\n return;\n }\n address sender = _msgSender();\n require(\n uint256(proposal._status) <= 1,\n \"proposal already executed/cancelled\"\n );\n require(!_hasVoted(proposal, sender), \"relayer already voted\");\n if (proposal._status == ProposalStatus.Inactive) {\n proposal = Proposal({\n _status: ProposalStatus.Active,\n _yesVotes: 0,\n _yesVotesTotal: 0,\n _proposedBlock: uint40(block.number) \n });\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Active,\n dataHash\n );\n } else if (\n uint40(sub(block.number, proposal._proposedBlock)) > _expiry\n ) {\n \n \n proposal._status = ProposalStatus.Cancelled;\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Cancelled,\n dataHash\n );\n }\n if (proposal._status != ProposalStatus.Cancelled) {\n proposal._yesVotes = (proposal._yesVotes | _relayerBit(sender))\n .toUint200();\n proposal._yesVotesTotal++; \n emit ProposalVote(\n domainID,\n depositNonce,\n proposal._status,\n dataHash\n );\n \n if (proposal._yesVotesTotal >= _relayerThreshold) {\n proposal._status = ProposalStatus.Passed;\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Passed,\n dataHash\n );\n }\n }\n _proposals[nonceAndID][dataHash] = proposal;\n if (proposal._status == ProposalStatus.Passed) {\n _executeProposal(domainID, depositNonce, data, resourceID, false);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meter Passport", "functions": ["function grantRole(bytes32 role, address account) public virtual {\n function _msgSender(...) {...}\nfunction hasRole(...) {...}\nrequire(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n _grantRole(role, account);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meter Passport", "functions": ["function revokeRole(bytes32 role, address account) public virtual {\n function _msgSender(...) {...}\nfunction hasRole(...) {...}\nrequire(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n _revokeRole(role, account);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meter Passport", "functions": ["function voteProposal(\n uint8 domainID,\n uint64 depositNonce,\n bytes32 resourceID,\n bytes calldata data\n ) external onlyRelayers whenNotPaused nonReentrant {\n address handler = _resourceIDToHandlerAddress[resourceID];\n uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(domainID);\n bytes32 dataHash = keccak256(\n abi.encodePacked(resourceID, handler, data)\n );\n Proposal memory proposal = _proposals[nonceAndID][dataHash];\n require(\n _resourceIDToHandlerAddress[resourceID] != address(0),\n \"no handler for resourceID\"\n );\n if (proposal._status == ProposalStatus.Passed) {\n _executeProposal(domainID, depositNonce, data, resourceID, true);\n return;\n }\n address sender = _msgSender();\n require(\n uint256(proposal._status) <= 1,\n \"proposal already executed/cancelled\"\n );\n function _hasVoted(...) {...}\nfunction toUint200(...) {...}\nfunction _relayerBit(...) {...}\nrequire(!_hasVoted(proposal, sender), \"relayer already voted\");\n if (proposal._status == ProposalStatus.Inactive) {\n proposal = Proposal({\n _status: ProposalStatus.Active,\n _yesVotes: 0,\n _yesVotesTotal: 0,\n _proposedBlock: uint40(block.number) \n });\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Active,\n dataHash\n );\n } else if (\n uint40(sub(block.number, proposal._proposedBlock)) > _expiry\n ) {\n \n \n proposal._status = ProposalStatus.Cancelled;\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Cancelled,\n dataHash\n );\n }\n if (proposal._status != ProposalStatus.Cancelled) {\n proposal._yesVotes = (proposal._yesVotes | _relayerBit(sender))\n .toUint200();\n proposal._yesVotesTotal++; \n emit ProposalVote(\n domainID,\n depositNonce,\n proposal._status,\n dataHash\n );\n \n if (proposal._yesVotesTotal >= _relayerThreshold) {\n proposal._status = ProposalStatus.Passed;\n emit ProposalEvent(\n domainID,\n depositNonce,\n ProposalStatus.Passed,\n dataHash\n );\n }\n }\n _proposals[nonceAndID][dataHash] = proposal;\n if (proposal._status == ProposalStatus.Passed) {\n _executeProposal(domainID, depositNonce, data, resourceID, false);\n }\n }", "function _relayerBit(address relayer) private view returns (uint256) {\n return\n uint256(1) <<\n sub(AccessControlUpgradeable.getRoleMemberIndex(RELAYER_ROLE, relayer), 1);\n }", "function _hasVoted(Proposal memory proposal, address relayer)\n private\n view\n returns (bool)\n {\n function _relayerBit(...) {...}\nreturn (_relayerBit(relayer) & uint256(proposal._yesVotes)) > 0;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Meter Passport", "functions": ["function executeProposal(bytes32 resourceID, bytes calldata data)\n external\n override\n onlyBridge\n {\n uint256 amount;\n uint256 lenDestinationRecipientAddress;\n bytes memory destinationRecipientAddress;\n (amount, lenDestinationRecipientAddress) = abi.decode(\n data,\n (uint256, uint256)\n );\n destinationRecipientAddress = bytes(\n data[64:64 + lenDestinationRecipientAddress]\n );\n bytes20 recipientAddress;\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n require(\n _contractWhitelist[tokenAddress],\n \"provided tokenAddress is not whitelisted\"\n );\n if (_burnList[tokenAddress]) {\n mintERC20(tokenAddress, address(recipientAddress), amount);\n } else if (isNative[tokenAddress]) {\n withdrawETH(address(recipientAddress), amount);\n } else {\n releaseERC20(tokenAddress, address(recipientAddress), amount);\n }\n }", "function mintERC20(\n address tokenAddress,\n address recipient,\n uint256 amount\n ) internal {\n IERCMintBurn erc20 = IERCMintBurn(tokenAddress);\n erc20.mint(recipient, amount);\n }", "function releaseERC20(\n address tokenAddress,\n address recipient,\n uint256 amount\n ) internal {\n IERC20 erc20 = IERC20(tokenAddress);\n function _safeTransfer(...) {...}\n_safeTransfer(erc20, recipient, amount);\n }", "function _safeTransfer(\n IERC20 token,\n address to,\n uint256 value\n ) private {\n _safeCall(\n token,\n abi.encodeWithSelector(token.transfer.selector, to, value)\n );\n }", "function _safeCall(IERC20 token, bytes memory data) private { \n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"ERC20: call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"ERC20: operation did not succeed\");\n }\n }", "function withdrawETH(bytes memory data) external virtual override {}", "function _safeTransferETH(address to, uint256 value) private {\n (bool success, ) = to.call{value: value}(new bytes(0));\n require(\n success,\n \"TransferHelper::safeTransferETH: ETH transfer failed\"\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MultiBaas Bridge", "functions": ["function deposit(\n bytes32 resourceID,\n uint8 destinationChainID,\n uint64 depositNonce,\n address depositer,\n bytes calldata data\n ) external override onlyBridge {\n bytes memory recipientAddress;\n uint256 amount;\n uint256 lenRecipientAddress;\n (amount, lenRecipientAddress) = abi.decode(data, (uint, uint));\n recipientAddress = bytes(data[64:64 + lenRecipientAddress]);\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n if (_burnList[tokenAddress]) {\n burnERC20(tokenAddress, depositer, amount);\n } else {\n lockERC20(tokenAddress, depositer, address(this), amount);\n }\n _depositRecords[destinationChainID][depositNonce] = DepositRecord(\n tokenAddress,\n destinationChainID,\n resourceID,\n recipientAddress,\n depositer,\n amount\n );\n }", "function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint256 amount;\n uint256 lenDestinationRecipientAddress;\n bytes memory destinationRecipientAddress;\n (amount, lenDestinationRecipientAddress) = abi.decode(data, (uint, uint));\n destinationRecipientAddress = bytes(data[64:64 + lenDestinationRecipientAddress]);\n bytes20 recipientAddress;\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n if (_burnList[tokenAddress]) {\n mintERC20(tokenAddress, address(recipientAddress), amount);\n } else {\n releaseERC20(tokenAddress, address(recipientAddress), amount);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MultiBaas Bridge", "functions": ["function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint tokenID;\n uint lenDestinationRecipientAddress;\n bytes memory destinationRecipientAddress;\n uint offsetMetaData;\n uint lenMetaData;\n bytes memory metaData;\n (tokenID, lenDestinationRecipientAddress) = abi.decode(data, (uint, uint));\n offsetMetaData = 64 + lenDestinationRecipientAddress;\n destinationRecipientAddress = bytes(data[64:offsetMetaData]);\n lenMetaData = abi.decode(data[offsetMetaData:], (uint));\n metaData = bytes(data[offsetMetaData + 32:offsetMetaData + 32 + lenMetaData]);\n bytes20 recipientAddress;\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n if (_burnList[tokenAddress]) {\n mintERC721(tokenAddress, address(recipientAddress), tokenID, metaData);\n } else {\n releaseERC721(tokenAddress, address(this), address(recipientAddress), tokenID);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MultiBaas Bridge", "functions": ["function voteProposal(uint8 chainID, uint64 depositNonce, bytes32 resourceID, bytes32 dataHash) external onlyRelayers whenNotPaused {\n uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(chainID);\n Proposal memory proposal = _proposals[nonceAndID][dataHash];\n require(_resourceIDToHandlerAddress[resourceID] != address(0), \"no handler for resourceID\");\n require(uint(proposal._status) <= 1, \"proposal already passed/executed/cancelled\");\n function _hasVoted(...) {...}\nrequire(!_hasVoted(proposal, msg.sender), \"relayer already voted\");\n if (proposal._status == ProposalStatus.Inactive) {\n proposal = Proposal({\n _status : ProposalStatus.Active,\n _yesVotes : 0,\n _yesVotesTotal : 0,\n _proposedBlock : uint40(block.number) \n });\n emit ProposalEvent(chainID, resourceID, depositNonce, ProposalStatus.Active, dataHash);\n } else if (uint40(sub(block.number, proposal._proposedBlock)) > _expiry) {\n \n \n proposal._status = ProposalStatus.Cancelled;\n emit ProposalEvent(chainID, resourceID, depositNonce, ProposalStatus.Cancelled, dataHash);\n }\n if (proposal._status != ProposalStatus.Cancelled) {\n proposal._yesVotes = (proposal._yesVotes | _relayerBit(msg.sender)).toUint200();\n proposal._yesVotesTotal++; \n emit ProposalVote(chainID, resourceID, depositNonce, proposal._status, dataHash);\n \n if (proposal._yesVotesTotal >= _relayerThreshold) {\n proposal._status = ProposalStatus.Passed;\n emit ProposalEvent(chainID, resourceID, depositNonce, ProposalStatus.Passed, dataHash);\n }\n }\n _proposals[nonceAndID][dataHash] = proposal;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MultiBaas Bridge", "functions": ["function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint256 amount;\n uint256 lenDestinationRecipientAddress;\n bytes memory destinationRecipientAddress;\n (amount, lenDestinationRecipientAddress) = abi.decode(data, (uint, uint));\n destinationRecipientAddress = bytes(data[64:64 + lenDestinationRecipientAddress]);\n bytes20 recipientAddress;\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n if (_burnList[tokenAddress]) {\n mintERC20(tokenAddress, address(recipientAddress), amount);\n } else {\n releaseERC20(tokenAddress, address(recipientAddress), amount);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MultiBridge", "functions": ["function dispatchMessage(uint256 _toChainId, address _to, bytes calldata _data)\n external\n payable\n override\n onlyMultiMessageSender\n returns (bytes32 msgId)\n {\n address receiverAdapter = receiverAdapters[_toChainId];\n if (receiverAdapter == address(0)) {\n revert Error.ZERO_RECEIVER_ADAPTER();\n }\n string memory destinationChain = chainIdMap[_toChainId];\n if (bytes(destinationChain).length <= 0) {\n revert Error.INVALID_DST_CHAIN();\n }\n msgId = _getNewMessageId(_toChainId, _to);\n _callContract(destinationChain, receiverAdapter, msgId, _to, _data);\n emit MessageDispatched(msgId, msg.sender, _toChainId, _to, _data);\n }", "function _callContract(\n string memory destinationChain,\n address receiverAdapter,\n bytes32 msgId,\n address multibridgeReceiver,\n bytes calldata data\n ) internal {\n string memory receiverAdapterInString = StringAddressConversion.toString(receiverAdapter);\n bytes memory payload =\n abi.encode(AdapterPayload(msgId, address(msg.sender), receiverAdapter, multibridgeReceiver, data));\n gasService.payNativeGasForContractCall{value: msg.value}(\n msg.sender, destinationChain, receiverAdapterInString, payload, msg.sender\n );\n gateway.callContract(destinationChain, receiverAdapterInString, payload);\n }", "function executeMessage(bytes32 msgId) external {\n ExecutionData memory _execData = msgReceived[msgId];\n \n if (block.timestamp > _execData.expiration) {\n revert Error.MSG_EXECUTION_PASSED_DEADLINE();\n }\n \n if (isExecuted[msgId]) {\n revert Error.MSG_ID_ALREADY_EXECUTED();\n }\n isExecuted[msgId] = true;\n \n if (messageVotes[msgId] < quorum) {\n revert Error.INVALID_QUORUM_FOR_EXECUTION();\n }\n \n IGovernanceTimelock(governanceTimelock).scheduleTransaction(\n _execData.target, _execData.value, _execData.callData\n );\n emit MessageExecuted(msgId, _execData.target, _execData.value, _execData.nonce, _execData.callData);\n }", "function scheduleTransaction(address _target, uint256 _value, bytes memory _data) external override onlyAdmin {\n if (_target == address(0)) {\n revert Error.INVALID_TARGET();\n }\n \n ++txCounter;\n uint256 eta = block.timestamp + delay;\n scheduledTransaction[txCounter] = keccak256(abi.encodePacked(_target, _value, _data, eta));\n emit TransactionScheduled(txCounter, _target, _value, _data, eta);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MultiBridge", "functions": ["function dispatchMessage(uint256 _toChainId, address _to, bytes calldata _data)\n external\n payable\n override\n onlyMultiMessageSender\n returns (bytes32 msgId)\n {\n if (_toChainId == 0) {\n revert Error.ZERO_CHAIN_ID();\n }\n address receiverAdapter = receiverAdapters[_toChainId];\n if (receiverAdapter == address(0)) {\n revert Error.ZERO_RECEIVER_ADAPTER();\n }\n msgId = _getNewMessageId(_toChainId, _to);\n bytes memory payload = abi.encode(AdapterPayload(msgId, msg.sender, receiverAdapter, _to, _data));\n IMessageBus(msgBus).sendMessage{value: msg.value}(receiverAdapter, _toChainId, payload);\n emit MessageDispatched(msgId, msg.sender, _toChainId, _to, _data);\n }", "function executeTransaction(uint256 _txId, address _target, uint256 _value, bytes memory _data, uint256 _eta)\n external\n payable\n override\n {\n \n if (_txId == 0 || _txId > txCounter) {\n revert Error.INVALID_TX_ID();\n }\n \n if (isExecuted[_txId]) {\n revert Error.TX_ALREADY_EXECUTED();\n }\n \n if (scheduledTransaction[_txId] != keccak256(abi.encodePacked(_target, _value, _data, _eta))) {\n revert Error.INVALID_TX_INPUT();\n }\n \n if (_eta > block.timestamp) {\n revert Error.TX_TIMELOCKED();\n }\n \n if (block.timestamp > _eta + GRACE_PERIOD) {\n revert Error.TX_EXPIRED();\n }\n \n if (msg.value != _value) {\n revert Error.INVALID_MSG_VALUE();\n }\n isExecuted[_txId] = true;\n (bool status,) = _target.call{value: _value}(_data);\n if (!status) {\n revert Error.EXECUTION_FAILS_ON_DST();\n }\n emit TransactionExecuted(_txId, _target, _value, _data, _eta);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MultiBridge", "functions": ["function execute(\n bytes32 commandId,\n string calldata sourceChain,\n string calldata sourceAddress,\n bytes calldata payload\n ) external override {\n \n if (keccak256(bytes(sourceChain)) != keccak256(bytes(senderChain))) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, keccak256(payload))) {\n revert Error.NOT_APPROVED_BY_GATEWAY();\n }\n \n if (sourceAddress.toAddress() != senderAdapter) {\n revert Error.INVALID_SENDER_ADAPTER();\n }\n \n AdapterPayload memory decodedPayload = abi.decode(payload, (AdapterPayload));\n bytes32 msgId = decodedPayload.msgId;\n \n if (commandIdStatus[commandId] || isMessageExecuted[msgId]) {\n revert MessageIdAlreadyExecuted(msgId);\n }\n \n if (decodedPayload.finalDestination != gac.getMultiMessageReceiver(block.chainid)) {\n revert Error.INVALID_FINAL_DESTINATION();\n }\n isMessageExecuted[msgId] = true;\n commandIdStatus[commandId] = true;\n MessageLibrary.Message memory _data = abi.decode(decodedPayload.data, (MessageLibrary.Message));\n try IMultiMessageReceiver(decodedPayload.finalDestination).receiveMessage(_data, name) {\n emit MessageIdExecuted(_data.srcChainId, msgId);\n } catch (bytes memory lowLevelData) {\n revert MessageFailure(msgId, lowLevelData);\n }\n }", "function receiveMessage(MessageLibrary.Message calldata _message, string memory _bridgeName)\n external\n override\n onlyReceiverAdapter\n {\n if (_message.dstChainId != block.chainid) {\n revert Error.INVALID_DST_CHAIN();\n }\n if (_message.target == address(0)) {\n revert Error.INVALID_TARGET();\n }\n \n if (_message.srcChainId != 1) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n \n bytes32 msgId = MessageLibrary.computeMsgId(_message);\n if (isDuplicateAdapter[msgId][msg.sender]) {\n revert Error.DUPLICATE_MESSAGE_DELIVERY_BY_ADAPTER();\n }\n if (isExecuted[msgId]) {\n revert Error.MSG_ID_ALREADY_EXECUTED();\n }\n isDuplicateAdapter[msgId][msg.sender] = true;\n \n ++messageVotes[msgId];\n \n ExecutionData memory prevStored = msgReceived[msgId];\n \n if (prevStored.target == address(0)) {\n msgReceived[msgId] = ExecutionData(\n _message.target, _message.callData, _message.nativeValue, _message.nonce, _message.expiration\n );\n }\n emit SingleBridgeMsgReceived(msgId, _bridgeName, _message.nonce, msg.sender);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "MultiBridge", "functions": ["function executeMessage(\n address _srcContract,\n uint64 _srcChainId,\n bytes calldata _message,\n address \n ) external payable override onlyMessageBus returns (ExecutionStatus) {\n \n \n if (_srcChainId != senderChain) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n if (_srcContract != senderAdapter) {\n revert Error.INVALID_SENDER_ADAPTER();\n }\n \n AdapterPayload memory decodedPayload = abi.decode(_message, (AdapterPayload));\n bytes32 msgId = decodedPayload.msgId;\n \n if (isMessageExecuted[msgId]) {\n revert MessageIdAlreadyExecuted(msgId);\n }\n isMessageExecuted[decodedPayload.msgId] = true;\n \n if (decodedPayload.finalDestination != gac.getMultiMessageReceiver(block.chainid)) {\n revert Error.INVALID_FINAL_DESTINATION();\n }\n MessageLibrary.Message memory _data = abi.decode(decodedPayload.data, (MessageLibrary.Message));\n try IMultiMessageReceiver(decodedPayload.finalDestination).receiveMessage(_data, name) {\n emit MessageIdExecuted(_data.srcChainId, msgId);\n } catch (bytes memory lowLevelData) {\n revert MessageFailure(msgId, lowLevelData);\n }\n return ExecutionStatus.Success;\n }", "function receiveMessage(MessageLibrary.Message calldata _message, string memory _bridgeName)\n external\n override\n onlyReceiverAdapter\n {\n if (_message.dstChainId != block.chainid) {\n revert Error.INVALID_DST_CHAIN();\n }\n if (_message.target == address(0)) {\n revert Error.INVALID_TARGET();\n }\n \n if (_message.srcChainId != 1) {\n revert Error.INVALID_SENDER_CHAIN_ID();\n }\n \n \n bytes32 msgId = MessageLibrary.computeMsgId(_message);\n if (isDuplicateAdapter[msgId][msg.sender]) {\n revert Error.DUPLICATE_MESSAGE_DELIVERY_BY_ADAPTER();\n }\n if (isExecuted[msgId]) {\n revert Error.MSG_ID_ALREADY_EXECUTED();\n }\n isDuplicateAdapter[msgId][msg.sender] = true;\n \n ++messageVotes[msgId];\n \n ExecutionData memory prevStored = msgReceived[msgId];\n \n if (prevStored.target == address(0)) {\n msgReceived[msgId] = ExecutionData(\n _message.target, _message.callData, _message.nativeValue, _message.nonce, _message.expiration\n );\n }\n emit SingleBridgeMsgReceived(msgId, _bridgeName, _message.nonce, msg.sender);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "NFT OmniBridge", "functions": ["function bridgeSpecificActionsOnTokenTransfer(\n address _token,\n address _from,\n address _receiver,\n uint256[] memory _tokenIds,\n uint256[] memory _values\n ) internal override {\n if (!isTokenRegistered(_token)) {\n _setNativeTokenIsRegistered(_token, REGISTERED);\n }\n function _prepareMessage(...) {...}\nfunction _isOracleDrivenLaneAllowed(...) {...}\nfunction _recordBridgeOperation(...) {...}\nbytes memory data = _prepareMessage(_token, _receiver, _tokenIds, _values);\n bytes32 _messageId = _passMessage(data, _isOracleDrivenLaneAllowed(_token, _from, _receiver));\n _recordBridgeOperation(_messageId, _token, _from, _tokenIds, _values);\n }", "function _prepareMessage(\n address _token,\n address _receiver,\n uint256[] memory _tokenIds,\n uint256[] memory _values\n ) internal returns (bytes memory) {\n require(_receiver != address(0) && _receiver != mediatorContractOnOtherSide());\n address nativeToken = nativeTokenAddress(_token);\n \n if (nativeToken == address(0)) {\n string[] memory tokenURIs = new string[](_tokenIds.length);\n if (_values.length > 0) {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n uint256 oldBalance = mediatorOwns(_token, _tokenIds[i]);\n uint256 newBalance = oldBalance.add(_values[i]);\n require(IERC1155(_token).balanceOf(address(this), _tokenIds[i]) >= newBalance);\n _setMediatorOwns(_token, _tokenIds[i], newBalance);\n tokenURIs[i] = _readERC1155TokenURI(_token, _tokenIds[i]);\n }\n } else {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n require(mediatorOwns(_token, _tokenIds[i]) == 0);\n require(IERC721(_token).ownerOf(_tokenIds[i]) == address(this));\n _setMediatorOwns(_token, _tokenIds[i], 1);\n tokenURIs[i] = _readERC721TokenURI(_token, _tokenIds[i]);\n }\n }\n \n if (isBridgedTokenDeployAcknowledged(_token)) {\n require(_tokenIds.length <= MAX_BATCH_BRIDGE_LIMIT);\n return\n abi.encodeWithSelector(\n this.handleBridgedNFT.selector,\n _token,\n _receiver,\n _tokenIds,\n _values,\n tokenURIs\n );\n }\n require(_tokenIds.length <= MAX_BATCH_BRIDGE_AND_DEPLOY_LIMIT);\n string memory name = _readName(_token);\n string memory symbol = _readSymbol(_token);\n return\n abi.encodeWithSelector(\n this.deployAndHandleBridgedNFT.selector,\n _token,\n name,\n symbol,\n _receiver,\n _tokenIds,\n _values,\n tokenURIs\n );\n }\n \n if (_values.length > 0) {\n IBurnableMintableERC1155Token(_token).burn(_tokenIds, _values);\n } else {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n IBurnableMintableERC721Token(_token).burn(_tokenIds[i]);\n }\n }\n return abi.encodeWithSelector(this.handleNativeNFT.selector, nativeToken, _receiver, _tokenIds, _values);\n }", "function _handleTokens(\n address _token,\n bool _isNative,\n address _recipient,\n uint256[] calldata _tokenIds,\n uint256[] calldata _values\n ) internal {\n require(isTokenExecutionAllowed(_token));\n function _releaseTokens(...) {...}\n_releaseTokens(_token, _isNative, _recipient, _tokenIds, _values);\n emit TokensBridged(_token, _recipient, _tokenIds, _values, messageId());\n }", "function _releaseTokens(\n address _token,\n bool _isNative,\n address _recipient,\n uint256[] memory _tokenIds,\n uint256[] memory _values\n ) internal {\n if (_values.length > 0) {\n if (_isNative) {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n _setMediatorOwns(_token, _tokenIds[i], mediatorOwns(_token, _tokenIds[i]).sub(_values[i]));\n }\n IERC1155(_token).safeBatchTransferFrom(address(this), _recipient, _tokenIds, _values, new bytes(0));\n } else {\n IBurnableMintableERC1155Token(_token).mint(_recipient, _tokenIds, _values);\n }\n } else {\n if (_isNative) {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n _setMediatorOwns(_token, _tokenIds[i], 0);\n IERC721(_token).transferFrom(address(this), _recipient, _tokenIds[i]);\n }\n } else {\n for (uint256 i = 0; i < _tokenIds.length; i++) {\n IBurnableMintableERC721Token(_token).mint(_recipient, _tokenIds[i]);\n }\n }\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Nomad", "functions": ["function send(\n address _token,\n uint256 _amount,\n uint32 _destination,\n bytes32 _recipient,\n bool _enableFast\n ) external {\n require(_amount > 0, \"!amnt\");\n require(_recipient != bytes32(0), \"!recip\");\n \n bytes32 _remote = _mustHaveRemote(_destination);\n \n IBridgeToken _t = IBridgeToken(_token);\n bytes32 _detailsHash;\n \n if (tokenRegistry.isLocalOrigin(_token)) {\n \n \n IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n \n _detailsHash = BridgeMessage.getDetailsHash(\n _t.name(),\n _t.symbol(),\n _t.decimals()\n );\n } else {\n \n \n _t.burn(msg.sender, _amount);\n _detailsHash = _t.detailsHash();\n }\n \n bytes29 _action = BridgeMessage.formatTransfer(\n _recipient,\n _amount,\n _detailsHash,\n _enableFast\n );\n \n (uint32 _domain, bytes32 _id) = tokenRegistry.getTokenId(_token);\n bytes29 _tokenId = BridgeMessage.formatTokenId(_domain, _id);\n \n Home(xAppConnectionManager.home()).dispatch(\n _destination,\n _remote,\n BridgeMessage.formatMessage(_tokenId, _action)\n );\n \n emit Send(\n _token,\n msg.sender,\n _destination,\n _recipient,\n _amount,\n _enableFast\n );\n }", "function dispatch(\n uint32 _destinationDomain,\n bytes32 _recipientAddress,\n bytes memory _messageBody\n ) external notFailed {\n require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \"msg too long\");\n \n uint32 _nonce = nonces[_destinationDomain];\n nonces[_destinationDomain] = _nonce + 1;\n \n bytes memory _message = Message.formatMessage(\n localDomain,\n bytes32(uint256(uint160(msg.sender))),\n _nonce,\n _destinationDomain,\n _recipientAddress,\n _messageBody\n );\n \n bytes32 _messageHash = keccak256(_message);\n tree.insert(_messageHash);\n \n queue.enqueue(root());\n \n \n emit Dispatch(\n _messageHash,\n count() - 1,\n _destinationAndNonce(_destinationDomain, _nonce),\n committedRoot,\n _message\n );\n }", "function _handleTransfer(\n uint32 _origin,\n uint32 _nonce,\n bytes29 _tokenId,\n bytes29 _action,\n bool _fastEnabled\n ) internal {\n \n \n \n \n address _token = tokenRegistry.ensureLocalToken(\n _tokenId.domain(),\n _tokenId.id()\n );\n \n address _recipient = _action.evmRecipient();\n if (_fastEnabled) {\n \n \n bytes32 _id = BridgeMessage.getPreFillId(\n _origin,\n _nonce,\n _tokenId,\n _action\n );\n address _lp = liquidityProvider[_id];\n if (_lp != address(0)) {\n _recipient = _lp;\n delete liquidityProvider[_id];\n }\n }\n \n uint256 _amount = _action.amnt();\n \n if (tokenRegistry.isLocalOrigin(_token)) {\n \n \n \n \n IERC20(_token).safeTransfer(_recipient, _amount);\n } else {\n \n \n IBridgeToken(_token).mint(_recipient, _amount);\n \n IBridgeToken(_token).setDetailsHash(_action.detailsHash());\n }\n \n emit Receive(\n _originAndNonce(_origin, _nonce),\n _token,\n _recipient,\n address(0),\n _amount\n );\n }", "function safeTransfer(IERC20 token, address to, uint256 value) internal {\n function _callOptionalReturn(...) {...}\n_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Nomad", "functions": ["function dispatch(\n uint32 _destinationDomain,\n bytes32 _recipientAddress,\n bytes memory _messageBody\n ) external notFailed {\n require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \"msg too long\");\n \n uint32 _nonce = nonces[_destinationDomain];\n nonces[_destinationDomain] = _nonce + 1;\n \n bytes memory _message = Message.formatMessage(\n localDomain,\n bytes32(uint256(uint160(msg.sender))),\n _nonce,\n _destinationDomain,\n _recipientAddress,\n _messageBody\n );\n \n bytes32 _messageHash = keccak256(_message);\n tree.insert(_messageHash);\n \n queue.enqueue(root());\n \n \n emit Dispatch(\n _messageHash,\n count() - 1,\n _destinationAndNonce(_destinationDomain, _nonce),\n committedRoot,\n _message\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Nomad", "functions": ["function update(\n bytes32 _oldRoot,\n bytes32 _newRoot,\n bytes memory _signature\n ) external notFailed {\n \n require(_oldRoot == committedRoot, \"not current update\");\n \n require(\n _isUpdaterSignature(_oldRoot, _newRoot, _signature),\n \"!updater sig\"\n );\n \n _beforeUpdate();\n \n confirmAt[_newRoot] = block.timestamp + optimisticSeconds;\n \n committedRoot = _newRoot;\n emit Update(remoteDomain, _oldRoot, _newRoot, _signature);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Octus Bridge", "functions": ["function deposit(\n DepositParams memory d\n )\n external\n payable\n override\n nonReentrant\n tokenNotBlacklisted(d.token)\n initializeToken(d.token)\n onlyEmergencyDisabled\n {\n _deposit(d, msg.value, msg.sender);\n }", "function _deposit(\n DepositParams memory d,\n uint256 _value,\n address tokens_owner\n ) internal drainGas {\n MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\n uint fee = _calculateMovementFee(\n d.amount,\n d.token,\n IMultiVaultFacetFees.Fee.Deposit\n );\n bool isNative = s.tokens_[d.token].isNative;\n \n address token = s.tokens_[d.token].custom == address(0) ? d.token : s.tokens_[d.token].custom;\n if (isNative) {\n IMultiVaultToken(token).burn(\n msg.sender,\n d.amount\n );\n d.amount -= fee;\n _transferToEverscaleNative(d, fee, msg.value);\n } else {\n if (tokens_owner != address(this)) {\n IERC20(token).safeTransferFrom(\n tokens_owner,\n address(this),\n d.amount\n );\n }\n d.amount -= fee;\n _transferToEverscaleAlien(d, fee, _value);\n }\n _increaseTokenFee(d.token, fee);\n }", "function _withdraw(\n address recipient,\n uint amount,\n uint fee,\n IMultiVaultFacetTokens.TokenType tokenType,\n bytes32 payloadId,\n address token\n ) internal {\n if (tokenType == IMultiVaultFacetTokens.TokenType.Native) {\n IMultiVaultToken(token).mint(recipient, amount - fee);\n } else {\n IERC20(token).safeTransfer(recipient, amount - fee);\n }\n emit Withdraw(\n tokenType,\n payloadId,\n token,\n recipient,\n amount,\n fee\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Octus Bridge", "functions": ["function _withdraw(\n address recipient,\n uint amount,\n uint fee,\n IMultiVaultFacetTokens.TokenType tokenType,\n bytes32 payloadId,\n address token\n ) internal {\n if (tokenType == IMultiVaultFacetTokens.TokenType.Native) {\n IMultiVaultToken(token).mint(recipient, amount - fee);\n } else {\n IERC20(token).safeTransfer(recipient, amount - fee);\n }\n emit Withdraw(\n tokenType,\n payloadId,\n token,\n recipient,\n amount,\n fee\n );\n }", "function depositByNativeToken(\n DepositNativeTokenParams memory d\n )\n external\n payable\n override\n nonReentrant\n wethNotBlacklisted\n initializeWethToken\n onlyEmergencyDisabled\n {\n require(msg.value >= d.amount, \"Msg value to low\");\n MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\n function deposit(...) {...}\nIWETH(s.weth).deposit{value: d.amount}();\n _deposit(\n DepositParams({\n recipient: d.recipient,\n token: s.weth,\n amount: d.amount,\n expected_evers: d.expected_evers,\n payload: d.payload\n }),\n msg.value - d.amount,\n address(this)\n );\n }", "function _transferToEverscaleNative(\n IMultiVaultFacetDeposit.DepositParams memory deposit,\n uint fee,\n uint value\n ) internal checkDepositAmount(deposit.amount) {\n MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\n IEverscale.EverscaleAddress memory native = s.natives_[deposit.token];\n emit NativeTransfer(\n native.wid,\n native.addr,\n uint128(deposit.amount),\n deposit.recipient.wid,\n deposit.recipient.addr,\n value,\n deposit.expected_evers,\n deposit.payload\n );\n _emitDeposit(deposit, fee, true);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Octus Bridge", "functions": ["function _setRound(\n uint32 round,\n uint160[] memory _relays,\n uint32 roundEnd\n ) internal {\n uint32 requiredSignatures = uint32(_relays.length * 2 / 3) + 1;\n rounds[round] = Round(\n roundEnd,\n roundEnd + roundTTL,\n uint32(_relays.length),\n requiredSignatures < minimumRequiredSignatures ? minimumRequiredSignatures : requiredSignatures\n );\n emit NewRound(round, rounds[round]);\n for (uint i=0; i<_relays.length; i++) {\n address relay = address(_relays[i]);\n relays[round][relay] = true;\n emit RoundRelay(round, relay);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Octus Bridge", "functions": ["function setRoundRelays(\n bytes calldata payload,\n bytes[] calldata signatures\n ) override external notCached(payload) {\n require(\n verifySignedEverscaleEvent(\n payload,\n signatures\n ) == 0,\n \"Bridge: signatures verification failed\"\n );\n (EverscaleEvent memory _event) = abi.decode(payload, (EverscaleEvent));\n require(\n _event.configurationWid == roundRelaysConfiguration.wid &&\n _event.configurationAddress == roundRelaysConfiguration.addr,\n \"Bridge: wrong event configuration\"\n );\n (uint32 round, uint160[] memory _relays, uint32 roundEnd) = decodeRoundRelaysEventData(payload);\n require(round == lastRound + 1, \"Bridge: wrong round\");\n _setRound(round, _relays, roundEnd);\n lastRound++;\n }", "function _setRound(\n uint32 round,\n uint160[] memory _relays,\n uint32 roundEnd\n ) internal {\n uint32 requiredSignatures = uint32(_relays.length * 2 / 3) + 1;\n rounds[round] = Round(\n roundEnd,\n roundEnd + roundTTL,\n uint32(_relays.length),\n requiredSignatures < minimumRequiredSignatures ? minimumRequiredSignatures : requiredSignatures\n );\n emit NewRound(round, rounds[round]);\n for (uint i=0; i<_relays.length; i++) {\n address relay = address(_relays[i]);\n relays[round][relay] = true;\n emit RoundRelay(round, relay);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Octus Bridge", "functions": ["function banRelays(\n address[] calldata _relays\n ) override external onlyOwner {\n for (uint i=0; i<_relays.length; i++) {\n blacklist[_relays[i]] = true;\n emit BanRelay(_relays[i], true);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OKC Bridge", "functions": ["function _transfer(address from, address to, uint value) private {\n balanceOf[from] = balanceOf[from].sub(value);\n balanceOf[to] = balanceOf[to].add(value);\n emit Transfer(from, to, value);\n }", "function _transfer(address from, address to, uint value) private {\n balanceOf[from] = balanceOf[from].sub(value);\n balanceOf[to] = balanceOf[to].add(value);\n emit Transfer(from, to, value);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OKC Bridge", "functions": ["function _mint(address to, uint value) internal {\n totalSupply = totalSupply.add(value);\n balanceOf[to] = balanceOf[to].add(value);\n emit Transfer(address(0), to, value);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OKC Bridge", "functions": ["function _burn(address from, uint value) internal {\n balanceOf[from] = balanceOf[from].sub(value);\n totalSupply = totalSupply.sub(value);\n emit Transfer(from, address(0), value);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Omnisea", "functions": ["function create(CreateParams calldata params) public payable {\n require(bytes(params.name).length >= 2);\n if (keccak256(bytes(params.dstChainName)) == keccak256(bytes(chainName))) {\n function create(...) {...}\n_collectionsRepository.create(params, msg.sender);\n return;\n }\n omnichainRouter.send{value : msg.value}(\n params.dstChainName,\n remoteChainToOA[params.dstChainName],\n abi.encode(params, msg.sender),\n params.gas,\n msg.sender,\n params.redirectFee\n );\n }", "function _lzProcess(uint16 chainId, RouteCall memory params, bool isRedirect, bool isRedirected) internal {\n require(trustedRemoteLookup[chainId].length != 0, \"LzSend: destination chain is not a trusted source.\");\n bytes memory adapter = _getAdapter(isRedirect ? 0 : params.gas);\n if (isRedirected) {\n (uint messageFee,) = lzEndpoint.estimateFees(chainId, address(this), params.payload, false, adapter);\n lzEndpoint.send{value : messageFee}(chainId, this.getTrustedRemote(chainId), params.payload, payable(params.user), lzConfig.zroPaymentAddress, adapter);\n return;\n }\n lzEndpoint.send{value : (msg.value - params.redirectFee)}(chainId, this.getTrustedRemote(chainId), params.payload, payable(params.user), lzConfig.zroPaymentAddress, adapter);\n }", "function omReceive(bytes calldata _payload, address srcOA, string memory srcChain) external override {\n emit OmReceived(srcChain, srcOA);\n function isOA(...) {...}\nfunction create(...) {...}\nrequire(isOA(srcChain, srcOA));\n (CreateParams memory params, address creator) = abi.decode(_payload, (CreateParams, address));\n _collectionsRepository.create(\n params,\n creator\n );\n }", "function create(\n CreateParams calldata params,\n address creator\n ) external override {\n require(msg.sender == collectionFactory);\n OmniERC721 collection = function _getSymbolByName(...) {...}\nnew OmniERC721(_getSymbolByName(params.name), params, creator, tokenFactory);\n userCollections[creator].push(address(collection));\n emit Created(address(collection), creator);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OneSwap", "functions": ["function lockSend(address to, uint amount, address token, uint32 unlockTime) public override beforeUnlockTime(unlockTime) {\n require(amount != 0, \"LockSend: LOCKED_AMOUNT_SHOULD_BE_NONZERO\");\n bytes32 key = _getLockedSendKey(msg.sender, to, token, unlockTime);\n function _safeTransferToMe(...) {...}\nfunction add(...) {...}\n_safeTransferToMe(token, msg.sender, amount);\n lockSendInfos[key] = lockSendInfos[key].add(amount);\n emit Locksend(msg.sender, to, token, amount, unlockTime);\n }", "function _safeTransferToMe(address token, address from, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(_SELECTOR2, from, address(this), value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"LockSend: TRANSFER_TO_ME_FAILED\");\n }", "function unlock(address from, address to, address token, uint32 unlockTime) public override afterUnlockTime(unlockTime) {\n bytes32 key = _getLockedSendKey(from, to, token, unlockTime);\n uint amount = lockSendInfos[key];\n require(amount != 0, \"LockSend: UNLOCK_AMOUNT_SHOULD_BE_NONZERO\");\n delete lockSendInfos[key];\n function _safeTransfer(...) {...}\n_safeTransfer(token, to, amount);\n emit Unlock(from, to, token, amount, unlockTime);\n }", "function _safeTransfer(address token, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(_SELECTOR, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"LockSend: TRANSFER_FAILED\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OneSwap", "functions": ["function unlock(address from, address to, address token, uint32 unlockTime) public override afterUnlockTime(unlockTime) {\n bytes32 key = _getLockedSendKey(from, to, token, unlockTime);\n uint amount = lockSendInfos[key];\n require(amount != 0, \"LockSend: UNLOCK_AMOUNT_SHOULD_BE_NONZERO\");\n delete lockSendInfos[key];\n function _safeTransfer(...) {...}\n_safeTransfer(token, to, amount);\n emit Unlock(from, to, token, amount, unlockTime);\n }", "function _safeTransfer(address token, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(_SELECTOR, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"LockSend: TRANSFER_FAILED\");\n }", "function lockSend(address to, uint amount, address token, uint32 unlockTime) public override beforeUnlockTime(unlockTime) {\n require(amount != 0, \"LockSend: LOCKED_AMOUNT_SHOULD_BE_NONZERO\");\n bytes32 key = _getLockedSendKey(msg.sender, to, token, unlockTime);\n function _safeTransferToMe(...) {...}\nfunction add(...) {...}\n_safeTransferToMe(token, msg.sender, amount);\n lockSendInfos[key] = lockSendInfos[key].add(amount);\n emit Locksend(msg.sender, to, token, amount, unlockTime);\n }", "function _safeTransferToMe(address token, address from, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(_SELECTOR2, from, address(this), value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), \"LockSend: TRANSFER_TO_ME_FAILED\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OpenSwap", "functions": ["function addLiquidity(bool direction, uint256 index) external override lock {\n require(IOSWAP_RestrictedFactory(factory).isLive(), 'GLOBALLY PAUSED');\n require(isLive, \"PAUSED\");\n Offer storage offer = offers[direction][index];\n require(msg.sender == restrictedLiquidityProvider || msg.sender == offer.provider, \"Not from router or owner\");\n (uint256 newGovBalance, uint256 newToken0Balance, uint256 newToken1Balance) = getBalances();\n uint256 amountIn;\n if (direction) {\n amountIn = newToken1Balance.sub(lastToken1Balance);\n } else {\n amountIn = newToken0Balance.sub(lastToken0Balance);\n }\n require(amountIn > 0, \"No amount in\");\n offer.amount = offer.amount.add(amountIn);\n lastGovBalance = newGovBalance;\n lastToken0Balance = newToken0Balance;\n lastToken1Balance = newToken1Balance;\n emit AddLiquidity(offer.provider, direction, index, amountIn, offer.amount);\n }", "function addLiquidity(bool direction, uint256 index) external override lock {\n require(IOSWAP_RestrictedFactory(factory).isLive(), 'GLOBALLY PAUSED');\n require(isLive, \"PAUSED\");\n Offer storage offer = offers[direction][index];\n require(msg.sender == restrictedLiquidityProvider || msg.sender == offer.provider, \"Not from router or owner\");\n (uint256 newGovBalance, uint256 newToken0Balance, uint256 newToken1Balance) = getBalances();\n uint256 amountIn;\n if (direction) {\n amountIn = newToken1Balance.sub(lastToken1Balance);\n } else {\n amountIn = newToken0Balance.sub(lastToken0Balance);\n }\n require(amountIn > 0, \"No amount in\");\n offer.amount = offer.amount.add(amountIn);\n lastGovBalance = newGovBalance;\n lastToken0Balance = newToken0Balance;\n lastToken1Balance = newToken1Balance;\n emit AddLiquidity(offer.provider, direction, index, amountIn, offer.amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OpenSwap", "functions": ["function removeLiquidity(address provider, bool direction, uint256 index, uint256 amountOut, uint256 receivingOut) external override lock {\n require(msg.sender == restrictedLiquidityProvider || msg.sender == provider, \"Not from router or owner\");\n _removeLiquidity(provider, direction, index, amountOut, receivingOut);\n (address tokenA, address tokenB) = direction ? (token1,token0) : (token0,token1);\n _safeTransfer(tokenA, msg.sender, amountOut); \n _safeTransfer(tokenB, msg.sender, receivingOut); \n _sync();\n }", "function _removeLiquidity(address provider, bool direction, uint256 index, uint256 amountOut, uint256 receivingOut) internal {\n require(index > 0, \"Provider liquidity not found\");\n Offer storage offer = offers[direction][index]; \n require(offer.provider == provider, \"Not from provider\");\n if (offer.locked && amountOut > 0) {\n require(offer.expire < block.timestamp, \"Not expired\");\n }\n offer.amount = offer.amount.sub(amountOut);\n offer.receiving = offer.receiving.sub(receivingOut);\n emit RemoveLiquidity(provider, direction, index, amountOut, receivingOut, offer.amount, offer.receiving);\n }", "function removeLiquidity(address provider, bool direction, uint256 index, uint256 amountOut, uint256 receivingOut) external override lock {\n require(msg.sender == restrictedLiquidityProvider || msg.sender == provider, \"Not from router or owner\");\n _removeLiquidity(provider, direction, index, amountOut, receivingOut);\n (address tokenA, address tokenB) = direction ? (token1,token0) : (token0,token1);\n _safeTransfer(tokenA, msg.sender, amountOut); \n _safeTransfer(tokenB, msg.sender, receivingOut); \n _sync();\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OpenSwap", "functions": ["function swap(uint256 amount0Out, uint256 amount1Out, address to, address trader, bytes calldata ) external override lock {\n if (!IOSWAP_OracleFactory(whitelistFactory).isWhitelisted(msg.sender)) {\n require(tx.origin == msg.sender && !Address.isContract(msg.sender) && trader == msg.sender, \"Invalid trader\");\n }\n require(isLive, \"PAUSED\");\n uint256 amount0In = IERC20(token0).balanceOf(address(this)).sub(lastToken0Balance);\n uint256 amount1In = IERC20(token1).balanceOf(address(this)).sub(lastToken1Balance);\n uint256 amountOut;\n uint256 protocolFeeCollected;\n if (amount0Out == 0 && amount1Out != 0){\n (amountOut, protocolFeeCollected) = _swap(true, amount0In, trader);\n require(amountOut >= amount1Out, \"INSUFFICIENT_AMOUNT\");\n _safeTransfer(token1, to, amountOut); \n protocolFeeBalance0 = protocolFeeBalance0.add(protocolFeeCollected);\n } else if (amount0Out != 0 && amount1Out == 0){\n (amountOut, protocolFeeCollected) = _swap(false, amount1In, trader);\n require(amountOut >= amount0Out, \"INSUFFICIENT_AMOUNT\");\n _safeTransfer(token0, to, amountOut); \n protocolFeeBalance1 = protocolFeeBalance1.add(protocolFeeCollected);\n } else {\n revert(\"Not supported\");\n }\n _sync();\n }", "function _swap(bool direction, uint256 amountIn, address trader) internal returns (uint256 totalOut, uint256 totalProtocolFeeCollected) {\n (uint256[] memory idxList, uint256[] memory amountList) = _decodeData(0xa4);\n address oracle;\n uint256[2] memory fee;\n (oracle, fee[0], fee[1]) = IOSWAP_RestrictedFactory(factory).checkAndGetOracleSwapParams(token0, token1);\n uint256 totalIn;\n uint256 totalTradeFeeCollected;\n for (uint256 index = 0 ; index < idxList.length ; index++) {\n totalIn = totalIn.add(amountList[index]);\n uint256[3] memory amount;\n uint256 thisIn = amountList[index].mul(amountIn).div(1e18);\n (amount[0], amount[1], amount[2]) = _swap2(direction, trader, idxList[index], thisIn, oracle, fee);\n totalOut = totalOut.add(amount[0]);\n totalTradeFeeCollected = totalTradeFeeCollected.add(amount[1]);\n totalProtocolFeeCollected = totalProtocolFeeCollected.add(amount[2]);\n }\n require(totalIn == 1e18, \"Invalid input\");\n emit Swap(trader, direction, amountIn, totalOut, totalTradeFeeCollected, totalProtocolFeeCollected);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OpenSwap", "functions": ["function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock onlyEndUser {\n require(isLive, \"PAUSED\");\n uint256 amount0In;\n uint256 amount1In;\n amount0In = IERC20(token0).balanceOf(address(this)).sub(lastToken0Balance);\n amount1In = IERC20(token1).balanceOf(address(this)).sub(lastToken1Balance);\n uint256 protocolFeeCollected;\n if (amount0Out == 0 && amount1Out != 0){\n (amount1Out, protocolFeeCollected) = _swap(to, true, amount0In, amount1Out, data);\n _safeTransfer(token1, to, amount1Out); \n protocolFeeBalance0 = protocolFeeBalance0.add(protocolFeeCollected);\n } else if (amount0Out != 0 && amount1Out == 0){\n (amount0Out, protocolFeeCollected) = _swap(to, false, amount1In, amount0Out, data);\n _safeTransfer(token0, to, amount0Out); \n protocolFeeBalance1 = protocolFeeBalance1.add(protocolFeeCollected);\n } else {\n revert(\"Not supported\");\n }\n _sync();\n }", "function _swap(address to, bool direction, uint256 amountIn, uint256 _amountOut, bytes calldata data) internal returns (uint256 amountOut, uint256 protocolFeeCollected) {\n uint256 amountInMinusProtocolFee;\n {\n uint256 price;\n uint256 tradeFeeCollected;\n uint256 tradeFee;\n uint256 protocolFee;\n (amountOut, price, tradeFeeCollected, tradeFee, protocolFee) = _getSwappedAmount(direction, amountIn, data);\n require(amountOut >= _amountOut, \"INSUFFICIENT_AMOUNT\");\n if (protocolFee == 0) {\n amountInMinusProtocolFee = amountIn;\n } else {\n protocolFeeCollected = amountIn.mul(tradeFee.mul(protocolFee)).div(FEE_BASE_SQ);\n amountInMinusProtocolFee = amountIn.sub(protocolFeeCollected);\n }\n emit Swap(to, direction, price, amountIn, amountOut, tradeFeeCollected, protocolFeeCollected);\n }\n uint256 remainOut = amountOut;\n uint256 index = first[direction];\n Offer storage offer;\n Offer storage counteroffer;\n while (remainOut > 0 && index != 0) {\n offer = offers[direction][index];\n if (offer.expire < block.timestamp) {\n index = _dequeue(direction, index);\n } else {\n counteroffer = offers[!direction][index];\n uint256 amount = offer.amount;\n if (remainOut >= amount) {\n \n remainOut = remainOut.sub(amount);\n uint256 providerShare = amountInMinusProtocolFee.mul(amount).div(amountOut);\n counteroffer.reserve = counteroffer.reserve.add(providerShare);\n offer.amount = 0;\n emit SwappedOneProvider(offer.provider, direction, amount, providerShare, 0, counteroffer.reserve);\n \n index = _dequeue(direction, index);\n } else {\n \n uint256 providerShare = amountInMinusProtocolFee.mul(remainOut).div(amountOut);\n counteroffer.reserve = counteroffer.reserve.add(providerShare);\n offer.amount = offer.amount.sub(remainOut);\n emit SwappedOneProvider(offer.provider, direction, remainOut, providerShare, offer.amount, counteroffer.reserve);\n remainOut = 0;\n }\n }\n }\n require(remainOut == 0, \"Amount exceeds available fund\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "OpenSwap", "functions": ["function removeLiquidity(address provider, bool direction, uint256 unstake, uint256 afterIndex, uint256 amountOut, uint256 reserveOut, uint256 expire, bool enable) external override lock {\n require(msg.sender == oracleLiquidityProvider || msg.sender == provider, \"Not from router or owner\");\n require(expire > block.timestamp, \"Already expired\");\n uint256 index = providerOfferIndex[provider];\n require(index > 0, \"Provider liquidity not found\");\n Offer storage offer = offers[direction][index];\n uint256 newAmount = offer.amount.sub(amountOut);\n function minLotSize(...) {...}\nrequire(newAmount == 0 || newAmount >= minLotSize(direction), \"Minium lot size not met\");\n uint256 staked = offer.staked.sub(unstake);\n offer.enabled = enable;\n if (amountOut > 0)\n offer.amount = newAmount;\n if (unstake > 0)\n offer.staked = staked;\n offer.reserve = offer.reserve.sub(reserveOut);\n offer.expire = expire;\n if (enable) {\n if (offer.isActive) {\n if (unstake > 0 && (index != afterIndex || offers[direction][offer.next].staked >= staked)) {\n _halfDequeue(direction, index);\n _enqueue(direction, index, staked, afterIndex, newAmount, expire);\n }\n } else {\n _enqueue(direction, index, staked, afterIndex, newAmount, expire);\n }\n } else {\n if (offer.isActive)\n _dequeue(direction, index);\n }\n if (unstake > 0) {\n stakeBalance = stakeBalance.sub(unstake);\n _safeTransfer(govToken, msg.sender, unstake); \n }\n if (amountOut > 0 || reserveOut > 0)\n _safeTransfer(direction ? token1 : token0, msg.sender, amountOut.add(reserveOut)); \n emit RemoveLiquidity(provider, direction, unstake, amountOut, reserveOut, offer.staked, offer.amount, offer.reserve, expire, enable);\n _sync();\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Oswap CrossChain Bridge", "functions": ["function swap(\n bytes[] calldata signatures,\n address _owner,\n uint256 _orderId,\n uint256 amendment,\n uint256 protocolFee,\n address[] calldata pair,\n Order calldata order\n ) external override nonReentrant whenNotPaused returns (uint256 amount) {\n bytes32 orderId = hashOrder(_owner, order.peerChain, _orderId);\n amount = order.inAmount;\n \n require(swapOrderStatus[orderId] == OrderStatus.NotSpecified,\"BridgeVault: Order already processed\");\n require(trollRegistry.isSuperTroll(msg.sender, true), \"not a super troll\");\n function lastKnownBalance(...) {...}\nrequire(lastKnownBalance() >= amount, \"BridgeVault: insufficient balance\");\n address router;\n uint256 price;\n {\n uint256 fee;\n address govTokenOracle;\n address assetTokenOracle;\n uint256 baseFee;\n uint256 transactionFee; \n IOSWAP_SwapPolicy swapPolicy;\n (swapPolicy, router, govTokenOracle, assetTokenOracle, baseFee, transactionFee) = configStore.getBridgeParams(asset);\n if (address(swapPolicy) != address(0)) {\n require(swapPolicy.allowToSwap(order), \"swap policy not met\");\n }\n transactionFee = amount * transactionFee / 1e18;\n fee = transactionFee + baseFee + protocolFee;\n require(amount > fee, \"Input amount too small\");\n imbalance -= toInt256(amount);\n lpAssetBalance += transactionFee;\n protocolFeeBalance += baseFee + protocolFee;\n price = assetPriceAgainstGovToken(govTokenOracle, assetTokenOracle);\n amount = amount - fee;\n }\n (uint256[] memory signers, ) = _verifyStakedValue(signatures, hashSwapParams(orderId, amendment, order, protocolFee, pair), amount * 1e18 / price);\n swapOrderStatus[orderId] = OrderStatus.Executed;\n if (pair.length == 0) {\n require(address(asset) == order.outToken, \"Invalid token\");\n require(amount >= order.minOutAmount, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n IERC20(order.outToken).safeTransfer(order.to, amount);\n } else {\n asset.safeIncreaseAllowance(address(router), amount);\n uint[] memory amounts;\n if (order.outToken == address(0)) {\n (, amounts) = IOSWAP_HybridRouter2(router).swapExactTokensForETH(amount, order.minOutAmount, pair, order.to, order.expire, \"0x00\");\n } else {\n address[] memory paths;\n (paths, amounts) = IOSWAP_HybridRouter2(router).swapExactTokensForTokens(amount, order.minOutAmount, pair, address(asset), order.to, order.expire, \"0x00\");\n require(paths[paths.length-1] == order.outToken,\"BridgeVault: Token out not match\");\n }\n amount = amounts[amounts.length-1];\n }\n emit Swap(_orderId, msg.sender, signers, _owner, amendment, order, amount, imbalance, lpAssetBalance, protocolFeeBalance);\n }", "function _verifyStakedValue(address msgSender, bytes[] calldata signatures, bytes32 paramsHash) internal returns (uint256 superTrollCount, uint totalStake, uint256[] memory signers) {\n require(!usedNonce[paramsHash], \"nonce used\");\n usedNonce[paramsHash] = true;\n uint256 generalTrollCount;\n {\n uint256 length = signatures.length;\n signers = new uint256[](length);\n address lastSigningTroll;\n for (uint256 i = 0; i < length; ++i) {\n address troll = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", paramsHash)).recover(signatures[i]);\n require(troll != address(0), \"Invalid signer\");\n uint256 trollProfileIndex = trollRegistry.trollProfileInv(troll);\n if (trollProfileIndex > 0 && troll > lastSigningTroll) {\n signers[i] = trollProfileIndex;\n if (trollRegistry.isSuperTroll(troll, true)) {\n superTrollCount++;\n } else if (trollRegistry.isGeneralTroll(troll, true)) {\n generalTrollCount++;\n }\n totalStake += trollStakesBalances[trollProfileIndex];\n lastSigningTroll = troll;\n }\n }\n }\n (uint256 generalTrollMinCount, uint256 superTrollMinCount, uint256 transactionsGap) = configStore.getSignatureVerificationParams();\n require(generalTrollCount >= generalTrollMinCount, \"OSWAP_BridgeVault: Mininum general troll count not met\");\n require(superTrollCount >= superTrollMinCount, \"OSWAP_BridgeVault: Mininum super troll count not met\");\n \n uint256 _transactionsCount = (++transactionsCount);\n require((lastTrollTxCount[msgSender] + transactionsGap < _transactionsCount) || (_transactionsCount <= transactionsGap), \"too soon\");\n lastTrollTxCount[msgSender] = _transactionsCount;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Oswap CrossChain Bridge", "functions": ["function voidOrder(bytes[] calldata signatures, bytes32 orderId) external override {\n require(swapOrderStatus[orderId] == OrderStatus.NotSpecified,\"BridgeVault: Order already processed\");\n (uint256[] memory signers, ) = _verifyStakedValue(signatures, hashVoidOrderParams(orderId), 0);\n swapOrderStatus[orderId] = OrderStatus.Cancelled;\n emit VoidOrder(orderId, msg.sender, signers);\n }", "function _verifyStakedValue(address msgSender, bytes[] calldata signatures, bytes32 paramsHash) internal returns (uint256 superTrollCount, uint totalStake, uint256[] memory signers) {\n require(!usedNonce[paramsHash], \"nonce used\");\n usedNonce[paramsHash] = true;\n uint256 generalTrollCount;\n {\n uint256 length = signatures.length;\n signers = new uint256[](length);\n address lastSigningTroll;\n for (uint256 i = 0; i < length; ++i) {\n address troll = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", paramsHash)).recover(signatures[i]);\n require(troll != address(0), \"Invalid signer\");\n uint256 trollProfileIndex = trollRegistry.trollProfileInv(troll);\n if (trollProfileIndex > 0 && troll > lastSigningTroll) {\n signers[i] = trollProfileIndex;\n if (trollRegistry.isSuperTroll(troll, true)) {\n superTrollCount++;\n } else if (trollRegistry.isGeneralTroll(troll, true)) {\n generalTrollCount++;\n }\n totalStake += trollStakesBalances[trollProfileIndex];\n lastSigningTroll = troll;\n }\n }\n }\n (uint256 generalTrollMinCount, uint256 superTrollMinCount, uint256 transactionsGap) = configStore.getSignatureVerificationParams();\n require(generalTrollCount >= generalTrollMinCount, \"OSWAP_BridgeVault: Mininum general troll count not met\");\n require(superTrollCount >= superTrollMinCount, \"OSWAP_BridgeVault: Mininum super troll count not met\");\n \n uint256 _transactionsCount = (++transactionsCount);\n require((lastTrollTxCount[msgSender] + transactionsGap < _transactionsCount) || (_transactionsCount <= transactionsGap), \"too soon\");\n lastTrollTxCount[msgSender] = _transactionsCount;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Oswap CrossChain Bridge", "functions": ["function cancelOrder(bytes[] calldata signatures, uint256 orderId, bool canceledByOrderOwner, uint256 protocolFee) external override whenNotPaused {\n Order storage order = orders[orderId];\n require(orderStatus[orderId] == OrderStatus.Pending || orderStatus[orderId] == OrderStatus.RequestAmend, \"BridgeVault: cancel not requested\");\n (,,address govTokenOracle, address assetTokenOracle, uint256 baseFee,) = configStore.getBridgeParams(asset);\n uint256 price = assetPriceAgainstGovToken(govTokenOracle, assetTokenOracle);\n (uint256[] memory signers, ) = _verifyStakedValue(signatures, hashCancelOrderParams(orderId, canceledByOrderOwner, protocolFee), order.inAmount * 1e18 / price);\n uint256 refundAmount = orders[orderId].inAmount;\n \n uint256 fee;\n if (canceledByOrderOwner) {\n fee = baseFee + protocolFee;\n refundAmount -= fee;\n imbalance -= toInt256(fee);\n protocolFeeBalance += fee;\n }\n orderRefunds[orderId] = refundAmount;\n orderStatus[orderId] = OrderStatus.RefundApproved;\n emit OrderCanceled(orderId, msg.sender, signers, canceledByOrderOwner, imbalance, protocolFeeBalance);\n }", "function _verifyStakedValue(address msgSender, bytes[] calldata signatures, bytes32 paramsHash) internal returns (uint256 superTrollCount, uint totalStake, uint256[] memory signers) {\n require(!usedNonce[paramsHash], \"nonce used\");\n usedNonce[paramsHash] = true;\n uint256 generalTrollCount;\n {\n uint256 length = signatures.length;\n signers = new uint256[](length);\n address lastSigningTroll;\n for (uint256 i = 0; i < length; ++i) {\n address troll = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", paramsHash)).recover(signatures[i]);\n require(troll != address(0), \"Invalid signer\");\n uint256 trollProfileIndex = trollRegistry.trollProfileInv(troll);\n if (trollProfileIndex > 0 && troll > lastSigningTroll) {\n signers[i] = trollProfileIndex;\n if (trollRegistry.isSuperTroll(troll, true)) {\n superTrollCount++;\n } else if (trollRegistry.isGeneralTroll(troll, true)) {\n generalTrollCount++;\n }\n totalStake += trollStakesBalances[trollProfileIndex];\n lastSigningTroll = troll;\n }\n }\n }\n (uint256 generalTrollMinCount, uint256 superTrollMinCount, uint256 transactionsGap) = configStore.getSignatureVerificationParams();\n require(generalTrollCount >= generalTrollMinCount, \"OSWAP_BridgeVault: Mininum general troll count not met\");\n require(superTrollCount >= superTrollMinCount, \"OSWAP_BridgeVault: Mininum super troll count not met\");\n \n uint256 _transactionsCount = (++transactionsCount);\n require((lastTrollTxCount[msgSender] + transactionsGap < _transactionsCount) || (_transactionsCount <= transactionsGap), \"too soon\");\n lastTrollTxCount[msgSender] = _transactionsCount;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Oswap CrossChain Bridge", "functions": ["function execute(bytes[] calldata signatures, bytes32[] calldata params, uint256 nonce) external {\n require(params.length > 0, \"Invalid params length\");\n emit Execute(params);\n function executeHash(...) {...}\nbytes32 hash = executeHash(params, nonce);\n trollRegistry.verifySignatures(msg.sender, signatures, hash, nonce);\n bytes32 name = params[0];\n if (params.length == 1) {\n if (name == \"shutdown\") {\n trollRegistry.shutdownByVoting();\n return;\n } else if (name == \"resume\") {\n trollRegistry.resume();\n return;\n }\n } else {\n bytes32 param1 = params[1];\n if (params.length == 2) {\n if (name == \"upgradeConfigStore\") {\n configStore.upgrade(OSWAP_ConfigStore(address(bytes20(param1))));\n return;\n } else if (name == \"upgradeTrollRegistry\") {\n trollRegistry.upgrade(address(bytes20(param1)));\n return;\n }\n } else {\n bytes32 param2 = params[2];\n if (params.length == 3) {\n if (name == \"setConfig\") {\n configStore.setConfig(param1, param2);\n return;\n } else if (name == \"setConfigAddress\") {\n configStore.setConfigAddress(param1, param2);\n return;\n } else if (name == \"setVotingExecutor\") {\n trollRegistry.setVotingExecutor(address(bytes20(param1)), uint256(param2)!=0);\n return;\n }\n } else {\n bytes32 param3 = params[3];\n if (params.length == 4) {\n if (name == \"setConfig2\") {\n configStore.setConfig2(param1, param2, param3);\n return;\n }\n }\n }\n }\n }\n revert(\"Invalid parameters\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "QANX Bridge", "functions": ["function bridgeSend(address beneficiary, uint256 amount, uint256 withdrawChainId) external returns (bytes32) {\n \n bytes32 txid = keccak256(abi.encode(msg.sender, block.chainid, withdrawChainId, _nonces[msg.sender][block.chainid][withdrawChainId]++, beneficiary, amount));\n \n require(_qanx.transferFrom(msg.sender, address(this), amount));\n \n return txid;\n }", "function transferFrom(\n address from,\n address to,\n uint256 amount\n ) external virtual override returns (bool) {\n address spender = _msgSender();\n function _spendAllowance(...) {...}\nfunction _transfer(...) {...}\n_spendAllowance(from, spender, amount);\n _transfer(from, to, amount);\n return true;\n }", "function _transfer(\n address from,\n address to,\n uint256 amount\n ) internal virtual {\n require(from != address(0), \"ERC20: transfer from the zero address\");\n require(to != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(from, to, amount);\n uint256 fromBalance = _balances[from];\n require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n unchecked {\n _balances[from] = fromBalance - amount;\n \n \n _balances[to] += amount;\n }\n emit Transfer(from, to, amount);\n _afterTokenTransfer(from, to, amount);\n }", "function bridgeWithdraw(address beneficiary, uint256 amount, uint256 depositChainId, bytes calldata signature) external returns (bool) {\n \n bytes32 txid = keccak256(abi.encode(msg.sender, depositChainId, block.chainid, _nonces[msg.sender][depositChainId][block.chainid]++, beneficiary, amount));\n \n function verifySignature(...) {...}\nrequire(verifySignature(txid, signature, amount), \"ERR_SIG\");\n \n uint256 fee = amount / 100 * feePercentage;\n feesCollected += fee;\n \n require(_qanx.transfer(beneficiary, amount - fee), \"ERR_TXN\");\n return true;\n }", "function verifySignature(bytes32 txid, bytes memory signature, uint256 amount) internal view returns (bool) {\n \n bytes32 r;\n bytes32 vs;\n \n assembly {\n r := mload(add(signature, 32))\n vs := mload(add(signature, 64))\n }\n \n bytes32 s = vs & 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n uint8 v = 27 + uint8(uint256(vs) >> 255);\n \n return amount < signers[ecrecover(txid, v, r, s)];\n }", "function transfer(address to, uint256 amount) external virtual override returns (bool) {\n address owner = _msgSender();\n function _transfer(...) {...}\n_transfer(owner, to, amount);\n return true;\n }", "function _transfer(\n address from,\n address to,\n uint256 amount\n ) internal virtual {\n require(from != address(0), \"ERC20: transfer from the zero address\");\n require(to != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(from, to, amount);\n uint256 fromBalance = _balances[from];\n require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n unchecked {\n _balances[from] = fromBalance - amount;\n \n \n _balances[to] += amount;\n }\n emit Transfer(from, to, amount);\n _afterTokenTransfer(from, to, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "QBridge", "functions": ["function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n uint option;\n uint amount;\n (option, amount) = abi.decode(data, (uint, uint));\n address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n if (burnList[tokenAddress]) {\n require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n } else {\n require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n tokenAddress.safeTransferFrom(depositer, address(this), amount);\n }\n }", "function mint(address _to, uint _amount) public onlyMinter {\n _mint(_to, _amount);\n }", "function _mint(address account, uint amount) internal {\n require(account != address(0), \"BEP20: mint to the zero address\");\n _totalSupply = _totalSupply.add(amount);\n _balances[account] = _balances[account].add(amount);\n emit Transfer(address(0), account, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "QBridge", "functions": ["function voteProposal(uint8 originDomainID, uint64 depositNonce, bytes32 resourceID, bytes calldata data) external onlyRelayers notPaused {\n address handlerAddress = resourceIDToHandlerAddress[resourceID];\n require(handlerAddress != address(0), \"QBridge: invalid handler\");\n uint72 proposalID = combinedProposalId(originDomainID, depositNonce);\n bytes32 dataHash = keccak256(abi.encodePacked(handlerAddress, data));\n Proposal memory proposal = _proposals[proposalID][dataHash];\n if (proposal._status == ProposalStatus.Passed) {\n executeProposal(originDomainID, depositNonce, resourceID, data, true);\n return;\n }\n require(uint(proposal._status) <= 1, \"QBridge: proposal already executed/cancelled\");\n function _hasVoted(...) {...}\nrequire(!_hasVoted(proposal, msg.sender), \"QBridge: relayer already voted\");\n if (proposal._status == ProposalStatus.Inactive) {\n proposal = Proposal({_status : ProposalStatus.Active, _yesVotes : 0, _yesVotesTotal : 0, _proposedBlock : uint40(block.number)});\n emit ProposalEvent(originDomainID, depositNonce, ProposalStatus.Active, dataHash);\n } else if (uint40(block.number.sub(proposal._proposedBlock)) > expiry) {\n proposal._status = ProposalStatus.Cancelled;\n emit ProposalEvent(originDomainID, depositNonce, ProposalStatus.Cancelled, dataHash);\n }\n if (proposal._status != ProposalStatus.Cancelled) {\n proposal._yesVotes = _bitmap(proposal._yesVotes, _relayerBit(msg.sender));\n proposal._yesVotesTotal++;\n emit ProposalVote(originDomainID, depositNonce, proposal._status, dataHash);\n if (proposal._yesVotesTotal >= relayerThreshold) {\n proposal._status = ProposalStatus.Passed;\n emit ProposalEvent(originDomainID, depositNonce, ProposalStatus.Passed, dataHash);\n }\n }\n _proposals[proposalID][dataHash] = proposal;\n if (proposal._status == ProposalStatus.Passed) {\n executeProposal(originDomainID, depositNonce, resourceID, data, false);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "QBridge", "functions": ["function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint option;\n uint amount;\n address recipientAddress;\n (option, amount, recipientAddress) = abi.decode(data, (uint, uint, address));\n address tokenAddress = resourceIDToTokenContractAddress[resourceID];\n require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n if (burnList[tokenAddress]) {\n address delegatorAddress = delegators[option];\n if (delegatorAddress == address(0)) {\n QBridgeToken(tokenAddress).mint(recipientAddress, amount);\n } else {\n QBridgeToken(tokenAddress).mint(delegatorAddress, amount);\n IQBridgeDelegator(delegatorAddress).delegate(tokenAddress, recipientAddress, option, amount);\n }\n } else {\n tokenAddress.safeTransfer(recipientAddress, amount.sub(withdrawalFees[resourceID]));\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Radar Bridge", "functions": ["function bridgeTokens(\n address _token,\n uint256 _amount,\n bytes32 _destChain,\n address _destAddress\n ) external {\n require(isSupportedToken[_token], \"Token not supported\");\n require(IERC20(_token).balanceOf(msg.sender) >= _amount, \"Not enough tokens\");\n require(_destChain != CHAIN, \"Cannot send to same chain\");\n bytes32 _tokenId = tokenToId[_token];\n bool _handlerType = tokenToHandlerType[_token];\n uint256 _fee = 0;\n if (feeManager != address(0)) {\n uint256 _userFee;\n uint256 _feeBase;\n \n try IRadarBridgeFeeManager(feeManager).getBridgeFee(_token, msg.sender, _amount, _destChain, _destAddress) returns (uint256 _val) {\n _userFee = _val;\n } catch {\n _userFee = 0;\n }\n if (_userFee != 0) {\n try IRadarBridgeFeeManager(feeManager).getFeeBase() returns (uint256 _val2) {\n _feeBase = _val2;\n } catch {\n _feeBase = 0;\n }\n \n if (_feeBase != 0 && (_userFee * 10) <= _feeBase) {\n _fee = (_amount * _userFee) / _feeBase;\n }\n }\n }\n \n if (_handlerType) {\n \n IBridgedToken(_token).burn(msg.sender, _amount);\n if (_fee != 0) {\n IBridgedToken(_token).mint(feeManager, _fee);\n }\n } else {\n \n IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n if (_fee != 0) {\n IERC20(_token).safeTransfer(feeManager, _fee);\n }\n }\n emit TokensBridged(\n _tokenId,\n _amount,\n _destChain,\n _destAddress,\n block.timestamp,\n _fee,\n _amount-_fee\n );\n }", "function claimTokens(\n bytes32 _tokenId,\n uint256 _amount,\n bytes32 _srcChain,\n bytes32 _destChain,\n uint256 _srcTimestamp,\n bytes32 _nonce,\n address _destAddress,\n bytes calldata _signature\n ) external {\n address _token = idToToken[_tokenId];\n require(_token != address(0) && isSupportedToken[_token], \"Token not supported.\");\n require(_destChain == CHAIN, \"Claiming tokens on wrong chain\");\n bytes32 message = keccak256(abi.encodePacked(\n _tokenId,\n _amount,\n _srcChain,\n _destChain,\n _srcTimestamp,\n _nonce,\n _destAddress\n ));\n require(doubleSpendingProtection[message] == false, \"Double Spending\");\n require(nonceDoubleSpendingProtection[_nonce] == false, \"Nonce Double Spending\");\n require(SignatureLibrary.verify(message, _signature, idToRouter[_tokenId]) == true, \"Router Signature Invalid\");\n doubleSpendingProtection[message] = true;\n nonceDoubleSpendingProtection[_nonce] = true;\n bool _handlerType = tokenToHandlerType[_token];\n if (_handlerType) {\n \n IBridgedToken(_token).mint(_destAddress, _amount);\n } else {\n \n IERC20(_token).safeTransfer(_destAddress, _amount);\n }\n emit TokensClaimed(_tokenId, _amount, _srcChain, _srcTimestamp, _nonce, _destAddress);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Rainbow Bridge", "functions": ["function transferToNear(uint256 _amount, string memory _nearReceiverAccountId)\n external pausable (PAUSE_TRANSFER_TO_NEAR) {\n _burn(msg.sender, _amount);\n emit TransferToNearInitiated(msg.sender, _amount, _nearReceiverAccountId);\n }", "function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _beforeTokenTransfer(account, address(0), amount);\n _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n _totalSupply = _totalSupply.sub(amount);\n emit Transfer(account, address(0), amount);\n }", "function finaliseNearToEthTransfer(bytes memory proofData, uint64 proofBlockHeight)\n external pausable (PAUSE_FINALISE_FROM_NEAR) {\n ProofDecoder.ExecutionStatus memory status = _parseAndConsumeProof(proofData, proofBlockHeight);\n BridgeResult memory result = _decodeBridgeResult(status.successValue);\n _mint(result.recipient, result.amount);\n emit NearToEthTransferFinalised(result.amount, result.recipient);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n _totalSupply = _totalSupply.add(amount);\n _balances[account] = _balances[account].add(amount);\n emit Transfer(address(0), account, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Rainbow Bridge", "functions": ["function depositToEVM(\n string memory ethRecipientOnNear, \n uint256 fee\n )\n external\n payable\n pausable(PAUSED_DEPOSIT_TO_EVM)\n {\n require(\n fee < msg.value,\n 'The fee cannot be bigger than the transferred amount.'\n );\n string memory separator = ':';\n string memory protocolMessage = string(\n abi.encodePacked(\n string(nearProofProducerAccount_),\n separator, ethRecipientOnNear\n )\n );\n emit Deposited(\n msg.sender, \n protocolMessage, \n msg.value, \n fee\n );\n }", "function withdraw(\n bytes calldata proofData, \n uint64 proofBlockHeight\n )\n external\n pausable(PAUSED_WITHDRAW)\n {\n ProofDecoder.ExecutionStatus memory status = _parseAndConsumeProof(proofData, proofBlockHeight);\n BurnResult memory result = _decodeBurnResult(status.successValue);\n require(\n result.ethCustodian == address(this),\n 'Can only withdraw coins that were expected for the current contract'\n );\n payable(result.recipient).transfer(result.amount);\n emit Withdrawn(\n result.recipient,\n result.amount\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Rainbow Bridge", "functions": ["function _parseAndConsumeProof(bytes memory proofData, uint64 proofBlockHeight)\n internal\n returns (ProofDecoder.ExecutionStatus memory result)\n {\n require(prover.proveOutcome(proofData, proofBlockHeight), \"Proof should be valid\");\n \n Borsh.Data memory borshData = Borsh.from(proofData);\n ProofDecoder.FullOutcomeProof memory fullOutcomeProof = borshData.decodeFullOutcomeProof();\n require(\n fullOutcomeProof.block_header_lite.inner_lite.height >= minBlockAcceptanceHeight,\n \"Proof is from the ancient block\"\n );\n require(borshData.finished(), \"Argument should be exact borsh serialization\");\n bytes32 receiptId = fullOutcomeProof.outcome_proof.outcome_with_id.outcome.receipt_ids[0];\n require(!usedProofs[receiptId], \"The burn event proof cannot be reused\");\n usedProofs[receiptId] = true;\n require(keccak256(fullOutcomeProof.outcome_proof.outcome_with_id.outcome.executor_id)\n == keccak256(nearConnector),\n \"Can only unlock tokens from the linked proof producer on Near blockchain\");\n result = fullOutcomeProof.outcome_proof.outcome_with_id.outcome.status;\n require(!result.failed, \"Cannot use failed execution outcome for unlocking the tokens\");\n require(!result.unknown, \"Cannot use unknown execution outcome for unlocking the tokens\");\n emit ConsumedProof(receiptId);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Rainbow Bridge", "functions": ["function addLightClientBlock(bytes memory data) public override pausable(PAUSED_ADD_BLOCK) {\n require(initialized, \"Contract is not initialized\");\n require(balanceOf[msg.sender] >= lockEthAmount, \"Balance is not enough\");\n Borsh.Data memory borsh = Borsh.from(data);\n NearDecoder.LightClientBlock memory nearBlock = borsh.decodeLightClientBlock();\n borsh.done();\n \n if (block.timestamp < lastValidAt) {\n require(\n nearBlock.inner_lite.timestamp >= untrustedTimestamp.add(replaceDuration),\n \"Can only replace with a sufficiently newer block\"\n );\n } else if (lastValidAt != 0) {\n curHeight = untrustedHeight;\n if (untrustedNextEpoch) {\n curEpoch = (curEpoch + 1) % 3;\n }\n lastValidAt = 0;\n blockHashes_[curHeight] = untrustedHash;\n blockMerkleRoots_[curHeight] = untrustedMerkleRoot;\n }\n \n require(nearBlock.inner_lite.height > curHeight, \"New block must have higher height\");\n \n bool fromNextEpoch;\n if (nearBlock.inner_lite.epoch_id == epochs[curEpoch].epochId) {\n fromNextEpoch = false;\n } else if (nearBlock.inner_lite.epoch_id == epochs[(curEpoch + 1) % 3].epochId) {\n fromNextEpoch = true;\n } else {\n revert(\"Epoch id of the block is not valid\");\n }\n \n Epoch storage thisEpoch = epochs[fromNextEpoch ? (curEpoch + 1) % 3 : curEpoch];\n \n require(nearBlock.approvals_after_next.length >= thisEpoch.numBPs, \"Approval list is too short\");\n \n uint256 votedFor = 0;\n for ((uint i, uint cnt) = (0, thisEpoch.numBPs); i != cnt; ++i) {\n bytes32 stakes = thisEpoch.packedStakes[i >> 1];\n if (nearBlock.approvals_after_next[i].some) {\n votedFor += uint128(bytes16(stakes));\n }\n if (++i == cnt) {\n break;\n }\n if (nearBlock.approvals_after_next[i].some) {\n votedFor += uint128(uint256(stakes));\n }\n }\n require(votedFor > thisEpoch.stakeThreshold, \"Too few approvals\");\n \n if (fromNextEpoch) {\n require(nearBlock.next_bps.some, \"Next next_bps should not be None\");\n require(\n nearBlock.next_bps.hash == nearBlock.inner_lite.next_bp_hash,\n \"Hash of block producers does not match\"\n );\n }\n untrustedHeight = nearBlock.inner_lite.height;\n untrustedTimestamp = nearBlock.inner_lite.timestamp;\n untrustedHash = nearBlock.hash;\n untrustedMerkleRoot = nearBlock.inner_lite.block_merkle_root;\n untrustedNextHash = nearBlock.next_hash;\n uint256 signatureSet = 0;\n for ((uint i, uint cnt) = (0, thisEpoch.numBPs); i < cnt; i++) {\n NearDecoder.OptionalSignature memory approval = nearBlock.approvals_after_next[i];\n if (approval.some) {\n signatureSet |= 1 << i;\n untrustedSignatures[i] = approval.signature;\n }\n }\n untrustedSignatureSet = signatureSet;\n untrustedNextEpoch = fromNextEpoch;\n if (fromNextEpoch) {\n Epoch storage nextEpoch = epochs[(curEpoch + 2) % 3];\n nextEpoch.epochId = nearBlock.inner_lite.next_epoch_id;\n setBlockProducers(nearBlock.next_bps.blockProducers, nextEpoch);\n }\n lastSubmitter = msg.sender;\n lastValidAt = block.timestamp.add(lockDuration);\n }", "function setBlockProducers(NearDecoder.BlockProducer[] memory src, Epoch storage epoch) internal {\n uint cnt = src.length;\n require(cnt <= MAX_BLOCK_PRODUCERS);\n epoch.numBPs = cnt;\n for (uint i = 0; i < cnt; i++) {\n epoch.keys[i] = src[i].publicKey.k;\n }\n uint256 totalStake = 0; \n for (uint i = 0; i != cnt; ++i) {\n uint128 stake1 = src[i].stake;\n totalStake += stake1;\n if (++i == cnt) {\n epoch.packedStakes[i >> 1] = bytes32(bytes16(stake1));\n break;\n }\n uint128 stake2 = src[i].stake;\n totalStake += stake2;\n epoch.packedStakes[i >> 1] = bytes32(uint256(bytes32(bytes16(stake1))) + stake2);\n }\n epoch.stakeThreshold = (totalStake * 2) / 3;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Relay Chain Bridge", "functions": ["function deposit(\n bytes32 resourceID,\n uint8 destinationChainID,\n uint64 depositNonce,\n address depositer,\n bytes calldata data\n ) external override onlyBridge {\n bytes memory recipientAddress;\n uint256 amount;\n uint256 lenRecipientAddress;\n assembly {\n amount := calldataload(0xC4)\n recipientAddress := mload(0x40)\n lenRecipientAddress := calldataload(0xE4)\n mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))\n calldatacopy(\n recipientAddress, \n 0xE4, \n sub(calldatasize(), 0xE) \n )\n }\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n if (_burnList[tokenAddress]) {\n burnERC20(tokenAddress, depositer, amount);\n } else {\n lockERC20(tokenAddress, depositer, address(this), amount);\n }\n _depositRecords[destinationChainID][depositNonce] = DepositRecord(\n tokenAddress,\n uint8(lenRecipientAddress),\n destinationChainID,\n resourceID,\n recipientAddress,\n depositer,\n amount\n );\n }", "function executeProposal(bytes32 resourceID, bytes calldata data) external onlyBridge {\n bytes memory metaData;\n assembly {\n \n \n metaData := mload(0x40)\n \n let lenMeta := calldataload(0x64)\n mstore(0x40, add(0x60, add(metaData, lenMeta)))\n \n calldatacopy(\n metaData, \n 0x64, \n sub(calldatasize(), 0x64) \n )\n }\n address contractAddress = _resourceIDToContractAddress[resourceID];\n require(_contractWhitelist[contractAddress], \"provided contractAddress is not whitelisted\");\n bytes4 sig = _contractAddressToExecuteFunctionSignature[contractAddress];\n if (sig != bytes4(0)) {\n bytes memory callData = abi.encodePacked(sig, metaData);\n (bool success,) = contractAddress.call(callData);\n require(success, \"delegatecall to contractAddress failed\");\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Relay Chain Bridge", "functions": ["function voteProposal(uint8 chainID, uint64 depositNonce, bytes32 resourceID, bytes calldata data) external onlyRelayers whenNotPaused {\n address handler = _resourceIDToHandlerAddress[resourceID];\n bytes32 dataHash = keccak256(abi.encodePacked(handler, data));\n uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(chainID);\n Proposal storage proposal = _proposals[nonceAndID][dataHash];\n require(_resourceIDToHandlerAddress[resourceID] != address(0), \"no handler for resourceID\");\n require(uint(proposal._status) <= 1, \"proposal already executed\");\n require(!_hasVotedOnProposal[nonceAndID][dataHash][msg.sender], \"relayer already voted\");\n if (uint(proposal._status) == 0) {\n ++_totalProposals;\n _proposals[nonceAndID][dataHash] = Proposal({\n _resourceID : resourceID,\n _dataHash : dataHash,\n _yesVotes : new address[](1),\n _noVotes : new address[](0),\n _status : ProposalStatus.Active,\n _proposedBlock : block.number\n });\n proposal._yesVotes[0] = msg.sender;\n emit ProposalEvent(chainID, depositNonce, ProposalStatus.Active, resourceID, dataHash);\n } else {\n require(dataHash == proposal._dataHash, \"datahash mismatch\");\n proposal._yesVotes.push(msg.sender);\n }\n _hasVotedOnProposal[nonceAndID][dataHash][msg.sender] = true;\n emit ProposalVote(chainID, depositNonce, proposal._status, resourceID);\n \n if (proposal._yesVotes.length >= _relayerThreshold) {\n require(dataHash == proposal._dataHash, \"data doesn't match datahash\");\n proposal._status = ProposalStatus.Executed;\n IDepositExecute depositHandler = IDepositExecute(_resourceIDToHandlerAddress[proposal._resourceID]);\n depositHandler.executeProposal(proposal._resourceID, data);\n emit ProposalEvent(chainID, depositNonce, proposal._status, proposal._resourceID, proposal._dataHash);\n }\n }", "function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint256 amount;\n bytes memory destinationRecipientAddress;\n assembly {\n amount := calldataload(0x64)\n destinationRecipientAddress := mload(0x40)\n let lenDestinationRecipientAddress := calldataload(0x84)\n mstore(0x40, add(0x20, add(destinationRecipientAddress, lenDestinationRecipientAddress)))\n \n calldatacopy(\n destinationRecipientAddress, \n 0x84, \n sub(calldatasize(), 0x84) \n )\n }\n bytes20 recipientAddress;\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n if (_burnList[tokenAddress]) {\n mintERC20(tokenAddress, address(recipientAddress), amount);\n } else {\n releaseERC20(tokenAddress, address(recipientAddress), amount);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Ronin Bridge", "functions": ["function depositEthFor(address _owner)\n public\n whenNotPaused\n payable\n returns (uint256)\n {\n address _weth = registry.getContract(registry.WETH_TOKEN());\n WETH(_weth).deposit.value(msg.value)();\n return _createDepositEntry(_owner, _weth, 20, msg.value);\n }", "function _createDepositEntry(\n address _owner,\n address _token,\n uint32 _standard,\n uint256 _number\n )\n internal\n onlyMappedToken(_token, _standard)\n returns (uint256 _depositId)\n {\n (,address _sidechainToken, uint32 _tokenStandard) = registry.getMappedToken(_token, true);\n require(_standard == _tokenStandard);\n DepositEntry memory _entry = DepositEntry(\n _owner,\n _token,\n _sidechainToken,\n _standard,\n _number\n );\n deposits.push(_entry);\n _depositId = depositCount++;\n emit TokenDeposited(\n _depositId,\n _owner,\n _token,\n _sidechainToken,\n _standard,\n _number\n );\n }", "function depositERC20For(address _user, address _token, uint256 _amount)\n public\n whenNotPaused\n returns (uint256)\n {\n require(\n IERC20(_token).transferFrom(msg.sender, address(this), _amount),\n \"MainchainGatewayManager: ERC-20 token transfer failed\"\n );\n return _createDepositEntry(_user, _token, 20, _amount);\n }", "function depositERC721For(address _user, address _token, uint256 _tokenId)\n public\n whenNotPaused\n returns (uint256)\n {\n function transferFrom(...) {...}\nfunction _createDepositEntry(...) {...}\nIERC721(_token).transferFrom(msg.sender, address(this), _tokenId);\n return _createDepositEntry(_user, _token, 721, _tokenId);\n }", "function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external {\n require(!claimed[account], 'MerkleDistributor: Already claimed.');\n \n bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n function verify(...) {...}\nrequire(MerkleProof.verify(merkleProof, merkleRoot, node), 'MerkleDistributor: Invalid proof.');\n \n claimed[account] = true;\n require(IERC20(token).transfer(account, amount), 'MerkleDistributor: Transfer failed.');\n emit Claimed(index, account, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Ronin Bridge", "functions": ["function withdrawERC20For(\n uint256 _withdrawalId,\n address _user,\n address _token,\n uint256 _amount,\n bytes memory _signatures\n )\n public\n whenNotPaused\n onlyMappedToken(_token, 20)\n {\n bytes32 _hash = keccak256(\n abi.encodePacked(\n \"withdrawERC20\",\n _withdrawalId,\n _user,\n _token,\n _amount\n )\n );\n function verifySignatures(...) {...}\nfunction sub(...) {...}\nfunction mint(...) {...}\nfunction transfer(...) {...}\nrequire(verifySignatures(_hash, _signatures));\n if (_token == registry.getContract(registry.WETH_TOKEN())) {\n _withdrawETHFor(_user, _amount);\n } else {\n uint256 _gatewayBalance = IERC20(_token).balanceOf(address(this));\n if (_gatewayBalance < _amount) {\n require(\n IERC20Mintable(_token).mint(address(this), _amount.sub(_gatewayBalance)),\n \"MainchainGatewayManager: Minting ERC20 token to gateway failed\"\n );\n }\n require(IERC20(_token).transfer(_user, _amount), \"Transfer failed\");\n }\n _insertWithdrawalEntry(\n _withdrawalId,\n _user,\n _token,\n _amount\n );\n }", "function withdrawERC721For(\n uint256 _withdrawalId,\n address _user,\n address _token,\n uint256 _tokenId,\n bytes memory _signatures\n )\n public\n whenNotPaused\n onlyMappedToken(_token, 721)\n {\n bytes32 _hash = keccak256(\n abi.encodePacked(\n \"withdrawERC721\",\n _withdrawalId,\n _user,\n _token,\n _tokenId\n )\n );\n function verifySignatures(...) {...}\nfunction mint(...) {...}\nrequire(verifySignatures(_hash, _signatures));\n if (!_tryERC721TransferFrom(_token, address(this), _user, _tokenId)) {\n require(\n IERC721Mintable(_token).mint(_user, _tokenId),\n \"MainchainGatewayManager: Minting ERC721 token to gateway failed\"\n );\n }\n _insertWithdrawalEntry(_withdrawalId, _user, _token, _tokenId);\n }", "function _insertWithdrawalEntry(\n uint256 _withdrawalId,\n address _owner,\n address _token,\n uint256 _number\n )\n internal\n onlyNewWithdrawal(_withdrawalId)\n {\n WithdrawalEntry memory _entry = WithdrawalEntry(\n _owner,\n _token,\n _number\n );\n withdrawals[_withdrawalId] = _entry;\n emit TokenWithdrew(_withdrawalId, _owner, _token, _number);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Ronin Bridge", "functions": ["function addValidators(address[] calldata _validators) external onlyAdmin {\n for (uint256 _i; _i < _validators.length; ++_i) {\n function _addValidator(...) {...}\n_addValidator(nonce++, _validators[_i]);\n }\n }", "function _addValidator(uint256 _id, address _validator)\n internal\n {\n require(!validatorMap[_validator]);\n validators.push(_validator);\n validatorMap[_validator] = true;\n validatorCount++;\n emit ValidatorAdded(_id, _validator);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Ronin Bridge", "functions": ["function removeValidator(address _validator) external onlyAdmin {\n function _removeValidator(...) {...}\n_removeValidator(nonce++, _validator);\n }", "function _removeValidator(uint256 _id, address _validator)\n internal\n {\n function isValidator(...) {...}\nrequire(isValidator(_validator));\n uint256 _index;\n for (uint256 _i = 0; _i < validatorCount; _i++) {\n if (validators[_i] == _validator) {\n _index = _i;\n break;\n }\n }\n validatorMap[_validator] = false;\n validators[_index] = validators[validatorCount - 1];\n validators.pop();\n validatorCount--;\n emit ValidatorRemoved(_id, _validator);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Ronin Bridge", "functions": ["function updateQuorum(uint256 _numerator, uint256 _denominator) external onlyAdmin {\n function _updateQuorum(...) {...}\n_updateQuorum(nonce++, _numerator, _denominator);\n }", "function _updateQuorum(uint256 _id, uint256 _numerator, uint256 _denominator)\n internal\n {\n require(_numerator <= _denominator);\n uint256 _previousNumerator = num;\n uint256 _previousDenominator = denom;\n num = _numerator;\n denom = _denominator;\n emit ThresholdUpdated(\n _id,\n _numerator,\n _denominator,\n _previousNumerator,\n _previousDenominator\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Router Protocol", "functions": ["function deposit(\n uint8 destinationChainID,\n bytes32 resourceID,\n bytes calldata data,\n uint256[] memory distribution,\n uint256[] memory flags,\n address[] memory path,\n address feeTokenAddress\n ) public virtual nonReentrant whenNotPaused isWhitelisted {\n function _deposit(...) {...}\n_deposit(destinationChainID, resourceID, data, distribution, flags, path, feeTokenAddress);\n }", "function _deposit(\n uint8 destinationChainID,\n bytes32 resourceID,\n bytes calldata data,\n uint256[] memory distribution,\n uint256[] memory flags,\n address[] memory path,\n address feeTokenAddress\n ) private {\n IDepositExecute.SwapInfo memory swapDetails = unpackDepositData(data);\n swapDetails.depositer = msg.sender;\n swapDetails.distribution = distribution;\n swapDetails.flags = flags;\n swapDetails.path = path;\n swapDetails.feeTokenAddress = feeTokenAddress;\n swapDetails.handler = _resourceIDToHandlerAddress[resourceID];\n require(swapDetails.handler != address(0), \"resourceID not mapped to handler\");\n swapDetails.depositNonce = ++_depositCounts[destinationChainID];\n IDepositExecute depositHandler = IDepositExecute(swapDetails.handler);\n function deposit(...) {...}\ndepositHandler.deposit(resourceID, destinationChainID, swapDetails.depositNonce, swapDetails);\n emit Deposit(destinationChainID, resourceID, swapDetails.depositNonce);\n }", "function executeProposal(\n uint8 chainID,\n uint64 depositNonce,\n bytes calldata data,\n bytes32 resourceID,\n uint256[] memory distribution,\n uint256[] memory flags,\n address[] memory path\n ) public virtual onlyRole(RELAYER_ROLE) whenNotPaused {\n address settlementToken;\n IDepositExecute.SwapInfo memory swapDetails = unpackDepositData(data);\n swapDetails.distribution = distribution;\n swapDetails.flags = flags;\n swapDetails.path = path;\n swapDetails.index = chainID;\n swapDetails.depositNonce = depositNonce;\n bytes32 dataHash = keccak256(abi.encodePacked(_resourceIDToHandlerAddress[resourceID], data));\n bytes32 proposalHash = keccak256(abi.encodePacked(chainID, depositNonce, dataHash));\n IVoterUpgradeable.ProposalStatus currentStatus = _voter.getStatus(_proposals[proposalHash]);\n require(currentStatus == IVoterUpgradeable.ProposalStatus.Passed, \"Proposal must have Passed status\");\n _voter.executeProposal(_proposals[proposalHash]);\n IDepositExecute depositHandler = IDepositExecute(_resourceIDToHandlerAddress[resourceID]);\n (settlementToken, swapDetails.returnAmount) = depositHandler.executeProposal(swapDetails, resourceID);\n emit Settlement(\n chainID,\n depositNonce,\n settlementToken,\n swapDetails.returnAmount,\n IVoterUpgradeable.ProposalStatus.Executed\n );\n emit ProposalEvent(chainID, depositNonce, IVoterUpgradeable.ProposalStatus.Executed, dataHash);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Router Protocol", "functions": ["function stake(\n address handler,\n address tokenAddress,\n uint256 amount\n ) public virtual whenNotPaused {\n ILiquidityPool depositHandler = ILiquidityPool(handler);\n function stake(...) {...}\ndepositHandler.stake(msg.sender, tokenAddress, amount);\n emit Stake(msg.sender, amount, tokenAddress);\n }", "function unstake(\n address handler,\n address tokenAddress,\n uint256 amount\n ) public virtual whenNotPaused {\n ILiquidityPool depositHandler = ILiquidityPool(handler);\n function unstake(...) {...}\ndepositHandler.unstake(msg.sender, tokenAddress, amount);\n emit Unstake(msg.sender, amount, tokenAddress);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Router Protocol", "functions": ["function voteProposal(\n uint8 chainID,\n uint64 depositNonce,\n bytes32 resourceID,\n bytes32 dataHash\n ) public virtual isResourceID(resourceID) onlyRole(RELAYER_ROLE) whenNotPaused {\n bytes32 proposalHash = keccak256(abi.encodePacked(chainID, depositNonce, dataHash));\n if (_proposals[proposalHash] == 0) {\n uint256 id = _voter.createProposal(block.number + _expiry, _quorum);\n _proposals[proposalHash] = id;\n _proposalDetails[id] = proposalStruct(chainID, depositNonce, resourceID, dataHash);\n emit ProposalEvent(chainID, depositNonce, IVoterUpgradeable.ProposalStatus.Active, dataHash);\n } else if (_voter.fetchIsExpired(_proposals[proposalHash])) {\n _voter.setStatus(_proposals[proposalHash]);\n emit ProposalEvent(chainID, depositNonce, _voter.getStatus(_proposals[proposalHash]), dataHash);\n return;\n }\n if (_voter.getStatus(_proposals[proposalHash]) != IVoterUpgradeable.ProposalStatus.Cancelled) {\n _voter.vote(_proposals[proposalHash], 1, msg.sender);\n emit ProposalVote(chainID, depositNonce, _voter.getStatus(_proposals[proposalHash]), dataHash);\n if (_voter.getStatus(_proposals[proposalHash]) == IVoterUpgradeable.ProposalStatus.Passed) {\n emit ProposalEvent(chainID, depositNonce, _voter.getStatus(_proposals[proposalHash]), dataHash);\n }\n }\n }", "function vote(\n uint256 issueId,\n uint8 option,\n address relayer\n )\n public\n virtual\n isBridge\n isvalidIssue(issueId)\n isNotVoted(issueId, relayer)\n isValidOption(option)\n isNotEnded(issueId)\n isValidbalance(relayer)\n returns (bool success)\n {\n uint256 balance = balanceOf(relayer);\n hasVoted[issueId][relayer] = hasVotedStruct(true, option);\n voteWeight[issueId][option] = voteWeight[issueId][option] + balance;\n issueMap[issueId].maxVotes = issueMap[issueId].maxVotes + balance;\n uint256 yes = voteWeight[issueId][1];\n uint256 yesPercent = (yes * (10000)) / (totalSupply()); \n if (yesPercent > issueMap[issueId].quorum) _setStatus(issueId, 1, ProposalStatus.Passed);\n emit OnVote(issueId, relayer, balance);\n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Router Protocol", "functions": ["function executeProposal(SwapInfo memory swapDetails, bytes32 resourceID)\n public\n virtual\n override\n onlyBridgeOrSequencer\n returns (address settlementToken, uint256 settlementAmount)\n {\n swapDetails.destStableTokenAddress = _resourceIDToTokenContractAddress[resourceID];\n require(_contractWhitelist[swapDetails.destStableTokenAddress], \"provided token is not whitelisted\");\n if (address(swapDetails.destTokenAddress) == swapDetails.destStableTokenAddress) {\n \n (settlementToken, settlementAmount) = handleExecuteForReserveToken(swapDetails);\n setExecuteRecord(swapDetails.index, swapDetails.depositNonce);\n } else if (\n _reserve._contractToLP(swapDetails.destStableTokenAddress) == address(swapDetails.destTokenAddress)\n ) {\n \n handleExecuteForLPToken(swapDetails);\n settlementToken = address(swapDetails.destTokenAddress);\n settlementAmount = swapDetails.destStableTokenAmount;\n setExecuteRecord(swapDetails.index, swapDetails.depositNonce);\n } else {\n \n (settlementToken, settlementAmount) = handleExecuteForNonReserveToken(swapDetails);\n setExecuteRecord(swapDetails.index, swapDetails.depositNonce);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Router Protocol", "functions": ["function cancelProposal(\n uint8 chainID,\n uint64 depositNonce,\n bytes32 dataHash\n ) public onlyAdminOrRelayer whenNotPaused{\n bytes32 proposalHash = keccak256(abi.encodePacked(chainID, depositNonce, dataHash));\n IVoterUpgradeable.ProposalStatus currentStatus = _voter.getStatus(_proposals[proposalHash]);\n require(\n currentStatus == IVoterUpgradeable.ProposalStatus.Active ||\n currentStatus == IVoterUpgradeable.ProposalStatus.Passed,\n \"Proposal cannot be cancelled\"\n );\n _voter.setStatus(_proposals[proposalHash]);\n currentStatus = _voter.getStatus(_proposals[proposalHash]);\n emit ProposalEvent(chainID, depositNonce, currentStatus, dataHash);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Rubic", "functions": ["function crossChainWithSwap(\n BaseCrossChainParams calldata _params,\n string calldata _providerName\n )\n external\n payable\n nonReentrant\n whenNotPaused\n eventEmitter(_params, _providerName)\n {\n IntegratorFeeInfo memory _info = integratorToFeeInfo[\n _params.integrator\n ];\n IERC20(_params.srcInputToken).transferFrom(\n msg.sender,\n address(this),\n _params.srcInputAmount\n );\n accrueFixedCryptoFee(_params.integrator, _info);\n uint256 _amountIn = accrueTokenFees(\n _params.integrator,\n _info,\n _params.srcInputAmount,\n 0,\n _params.srcInputToken\n );\n SmartApprove.smartApprove(\n _params.srcInputToken,\n _amountIn,\n _params.router\n );\n ITestDEX(_params.router).swap(\n _params.srcInputToken,\n _amountIn,\n _params.dstOutputToken\n );\n }", "function accrueFixedCryptoFee(\n address _integrator,\n IntegratorFeeInfo memory _info\n ) internal returns (uint256) {\n uint256 _fixedCryptoFee;\n uint256 _RubicPart;\n if (_info.isIntegrator) {\n _fixedCryptoFee = uint256(_info.fixedFeeAmount);\n if (_fixedCryptoFee > 0) {\n _RubicPart =\n (_fixedCryptoFee *\n _info.RubicFixedCryptoShare) /\n DENOMINATOR;\n availableIntegratorCryptoFee[_integrator] +=\n _fixedCryptoFee -\n _RubicPart;\n }\n } else {\n _fixedCryptoFee = fixedCryptoFee;\n _RubicPart = _fixedCryptoFee;\n }\n availableRubicCryptoFee += _RubicPart;\n emit FixedCryptoFee(\n _RubicPart,\n _fixedCryptoFee - _RubicPart,\n _integrator\n );\n \n return (msg.value - _fixedCryptoFee);\n }", "function accrueTokenFees(\n address _integrator,\n IntegratorFeeInfo memory _info,\n uint256 _amountWithFee,\n uint256 _initBlockchainNum,\n address _token\n ) internal returns (uint256) {\n (uint256 _totalFees, uint256 _RubicFee) = _calculateFee(\n _info,\n _amountWithFee,\n _initBlockchainNum\n );\n if (_integrator != address(0)) {\n availableIntegratorTokenFee[_token][_integrator] +=\n _totalFees -\n _RubicFee;\n }\n availableRubicTokenFee[_token] += _RubicFee;\n emit TokenFee(\n _RubicFee,\n _totalFees - _RubicFee,\n _integrator,\n _token\n );\n return _amountWithFee - _totalFees;\n }", "function smartApprove(\n address _tokenIn,\n uint256 _amount,\n address _to\n ) internal {\n IERC20Upgradeable tokenIn = IERC20Upgradeable(_tokenIn);\n uint256 _allowance = tokenIn.allowance(\n address(this),\n _to\n );\n if (_allowance < _amount) {\n if (_allowance == 0) {\n tokenIn.safeApprove(_to, type(uint256).max);\n } else {\n try\n tokenIn.approve(_to, type(uint256).max)\n returns (bool res) {\n if (!res) {\n revert ApproveFailed();\n }\n } catch {\n tokenIn.safeApprove(_to, 0);\n tokenIn.safeApprove(_to, type(uint256).max);\n }\n }\n }\n }", "function swap(\n address _fromToken,\n uint256 _inputAmount,\n address _toToken\n ) external override {\n IERC20(_fromToken).transferFrom(\n msg.sender,\n address(this),\n _inputAmount\n );\n IERC20(_toToken).transfer(\n msg.sender,\n _inputAmount * price\n );\n }", "function changeTxStatus(\n bytes32 _id,\n SwapStatus _statusCode\n ) external onlyManagerOrAdmin {\n if (_statusCode == SwapStatus.Null) {\n revert CantSetToNull();\n }\n SwapStatus _status = processedTransactions[_id];\n if (\n _status == SwapStatus.Succeeded ||\n _status == SwapStatus.Fallback\n ) {\n revert Unchangeable();\n }\n processedTransactions[_id] = _statusCode;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Rubic Bridge", "functions": ["function crossChainWithSwap(\n BaseCrossChainParams calldata _params,\n string calldata _providerName\n )\n external\n payable\n nonReentrant\n whenNotPaused\n eventEmitter(_params, _providerName)\n {\n IntegratorFeeInfo memory _info = integratorToFeeInfo[\n _params.integrator\n ];\n IERC20(_params.srcInputToken).transferFrom(\n msg.sender,\n address(this),\n _params.srcInputAmount\n );\n accrueFixedCryptoFee(_params.integrator, _info);\n uint256 _amountIn = accrueTokenFees(\n _params.integrator,\n _info,\n _params.srcInputAmount,\n 0,\n _params.srcInputToken\n );\n SmartApprove.smartApprove(\n _params.srcInputToken,\n _amountIn,\n _params.router\n );\n ITestDEX(_params.router).swap(\n _params.srcInputToken,\n _amountIn,\n _params.dstOutputToken\n );\n }", "function accrueFixedCryptoFee(\n address _integrator,\n IntegratorFeeInfo memory _info\n ) internal returns (uint256) {\n uint256 _fixedCryptoFee;\n uint256 _RubicPart;\n if (_info.isIntegrator) {\n _fixedCryptoFee = uint256(_info.fixedFeeAmount);\n if (_fixedCryptoFee > 0) {\n _RubicPart =\n (_fixedCryptoFee *\n _info.RubicFixedCryptoShare) /\n DENOMINATOR;\n availableIntegratorCryptoFee[_integrator] +=\n _fixedCryptoFee -\n _RubicPart;\n }\n } else {\n _fixedCryptoFee = fixedCryptoFee;\n _RubicPart = _fixedCryptoFee;\n }\n availableRubicCryptoFee += _RubicPart;\n emit FixedCryptoFee(\n _RubicPart,\n _fixedCryptoFee - _RubicPart,\n _integrator\n );\n \n return (msg.value - _fixedCryptoFee);\n }", "function accrueTokenFees(\n address _integrator,\n IntegratorFeeInfo memory _info,\n uint256 _amountWithFee,\n uint256 _initBlockchainNum,\n address _token\n ) internal returns (uint256) {\n (uint256 _totalFees, uint256 _RubicFee) = _calculateFee(\n _info,\n _amountWithFee,\n _initBlockchainNum\n );\n if (_integrator != address(0)) {\n availableIntegratorTokenFee[_token][_integrator] +=\n _totalFees -\n _RubicFee;\n }\n availableRubicTokenFee[_token] += _RubicFee;\n emit TokenFee(\n _RubicFee,\n _totalFees - _RubicFee,\n _integrator,\n _token\n );\n return _amountWithFee - _totalFees;\n }", "function smartApprove(\n address _tokenIn,\n uint256 _amount,\n address _to\n ) internal {\n IERC20Upgradeable tokenIn = IERC20Upgradeable(_tokenIn);\n uint256 _allowance = tokenIn.allowance(\n address(this),\n _to\n );\n if (_allowance < _amount) {\n if (_allowance == 0) {\n tokenIn.safeApprove(_to, type(uint256).max);\n } else {\n try\n tokenIn.approve(_to, type(uint256).max)\n returns (bool res) {\n if (!res) {\n revert ApproveFailed();\n }\n } catch {\n tokenIn.safeApprove(_to, 0);\n tokenIn.safeApprove(_to, type(uint256).max);\n }\n }\n }\n }", "function changeTxStatus(\n bytes32 _id,\n SwapStatus _statusCode\n ) external onlyManagerOrAdmin {\n if (_statusCode == SwapStatus.Null) {\n revert CantSetToNull();\n }\n SwapStatus _status = processedTransactions[_id];\n if (\n _status == SwapStatus.Succeeded ||\n _status == SwapStatus.Fallback\n ) {\n revert Unchangeable();\n }\n processedTransactions[_id] = _statusCode;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Secret Bridge", "functions": ["function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(sender, recipient, amount);\n _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n _balances[recipient] = _balances[recipient].add(amount);\n emit Transfer(sender, recipient, amount);\n }", "function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(sender, recipient, amount);\n _balances[sender] = _balances[sender].sub(\n amount,\n \"ERC20: transfer amount exceeds balance\"\n );\n _balances[recipient] = _balances[recipient].add(amount);\n emit Transfer(sender, recipient, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Secret Bridge", "functions": ["function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n _totalSupply = _totalSupply.add(amount);\n _balances[account] = _balances[account].add(amount);\n emit Transfer(address(0), account, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Secret Bridge", "functions": ["function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _beforeTokenTransfer(account, address(0), amount);\n _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n _totalSupply = _totalSupply.sub(amount);\n emit Transfer(account, address(0), amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sifchain Bridge", "functions": ["function lock(\n bytes memory _recipient,\n address _token,\n uint256 _amount\n ) public payable onlyEthTokenWhiteList(_token) validSifAddress(_recipient) whenNotPaused {\n string memory symbol;\n \n if (msg.value > 0) {\n require(\n _token == address(0),\n \"!address(0)\"\n );\n require(\n msg.value == _amount,\n \"incorrect eth amount\"\n );\n symbol = \"eth\";\n \n } else {\n IERC20 tokenToTransfer = IERC20(_token);\n tokenToTransfer.safeTransferFrom(\n msg.sender,\n address(this),\n _amount\n );\n symbol = BridgeToken(_token).symbol();\n }\n if (_amount > maxTokenAmount[symbol]) {\n revert(\"Amount being transferred is over the limit\");\n }\n lockFunds(msg.sender, _recipient, _token, symbol, _amount);\n }", "function lockFunds(\n address payable _sender,\n bytes memory _recipient,\n address _token,\n string memory _symbol,\n uint256 _amount\n ) internal {\n lockBurnNonce = lockBurnNonce.add(1);\n \n lockedTokenList[_symbol] = _token;\n lockedFunds[_token] = lockedFunds[_token].add(_amount);\n emit LogLock(_sender, _recipient, _token, _symbol, _amount, lockBurnNonce);\n }", "function mintNewBridgeTokens(\n address payable _intendedRecipient,\n address _bridgeTokenAddress,\n string memory _symbol,\n uint256 _amount\n ) internal {\n require(\n controlledBridgeTokens[_symbol] == _bridgeTokenAddress,\n \"Token must be a controlled bridge token\"\n );\n \n require(\n BridgeToken(_bridgeTokenAddress).mint(_intendedRecipient, _amount),\n \"Attempted mint of bridge tokens failed\"\n );\n emit LogBridgeTokenMint(\n _bridgeTokenAddress,\n _symbol,\n _amount,\n _intendedRecipient\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sifchain Bridge", "functions": ["function burn(\n bytes memory _recipient,\n address _token,\n uint256 _amount\n ) public validSifAddress(_recipient) onlyCosmosTokenWhiteList(_token) whenNotPaused {\n string memory symbol = BridgeToken(_token).symbol();\n if (_amount > maxTokenAmount[symbol]) {\n revert(\"Amount being transferred is over the limit for this token\");\n }\n BridgeToken(_token).burnFrom(msg.sender, _amount);\n burnFunds(msg.sender, _recipient, _token, symbol, _amount);\n }", "function burnFunds(\n address payable _sender,\n bytes memory _recipient,\n address _token,\n string memory _symbol,\n uint256 _amount\n ) internal {\n lockBurnNonce = lockBurnNonce.add(1);\n emit LogBurn(_sender, _recipient, _token, _symbol, _amount, lockBurnNonce);\n }", "function unlockFunds(\n address payable _recipient,\n address _token,\n string memory _symbol,\n uint256 _amount\n ) internal {\n \n lockedFunds[_token] = lockedFunds[_token].sub(_amount);\n \n if (_token == address(0)) {\n (bool success,) = _recipient.call.value(_amount)(\"\");\n require(success, \"error sending ether\");\n } else {\n IERC20 tokenToTransfer = IERC20(_token);\n tokenToTransfer.safeTransfer(_recipient, _amount);\n }\n emit LogUnlock(_recipient, _token, _symbol, _amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sifchain Bridge", "functions": ["function newProphecyClaim(\n ClaimType _claimType,\n bytes memory _cosmosSender,\n uint256 _cosmosSenderSequence,\n address payable _ethereumReceiver,\n string memory _symbol,\n uint256 _amount\n ) public onlyValidator {\n uint256 _prophecyID = uint256(keccak256(abi.encodePacked(_claimType, _cosmosSender, _cosmosSenderSequence, _ethereumReceiver, _symbol, _amount)));\n (bool prophecyCompleted, , ) = getProphecyThreshold(_prophecyID);\n require(!prophecyCompleted, \"prophecyCompleted\");\n if (oracleClaimValidators[_prophecyID] == 0) {\n string memory symbol;\n if (_claimType == ClaimType.Burn) {\n symbol = BridgeBank(bridgeBank).safeLowerToUpperTokens(_symbol);\n require(\n BridgeBank(bridgeBank).getLockedFunds(symbol) >= _amount,\n \"Not enough locked assets to complete the proposed prophecy\"\n );\n address tokenAddress = BridgeBank(bridgeBank).getLockedTokenAddress(symbol);\n if (tokenAddress == address(0) && uint256(keccak256(abi.encodePacked(symbol))) != uint256(keccak256(\"eth\"))) {\n revert(\"Invalid token address\");\n }\n } else if (_claimType == ClaimType.Lock) {\n symbol = concat(COSMOS_NATIVE_ASSET_PREFIX, _symbol); \n symbol = BridgeBank(bridgeBank).safeLowerToUpperTokens(symbol);\n address bridgeTokenAddress = BridgeBank(bridgeBank).getBridgeToken(symbol);\n if (bridgeTokenAddress == address(0)) {\n \n BridgeBank(bridgeBank).createNewBridgeToken(symbol);\n }\n } else {\n revert(\"Invalid claim type, only burn and lock are supported.\");\n }\n emit LogNewProphecyClaim(\n _prophecyID,\n _claimType,\n _ethereumReceiver,\n symbol,\n _amount\n );\n }\n bool claimComplete = newOracleClaim(_prophecyID, msg.sender);\n if (claimComplete) {\n address tokenAddress;\n if (_claimType == ClaimType.Lock) {\n _symbol = concat(COSMOS_NATIVE_ASSET_PREFIX, _symbol);\n _symbol = BridgeBank(bridgeBank).safeLowerToUpperTokens(_symbol);\n tokenAddress = BridgeBank(bridgeBank).getBridgeToken(_symbol);\n } else {\n _symbol = BridgeBank(bridgeBank).safeLowerToUpperTokens(_symbol);\n tokenAddress = BridgeBank(bridgeBank).getLockedTokenAddress(_symbol);\n }\n completeProphecyClaim(\n _prophecyID,\n tokenAddress,\n _claimType,\n _ethereumReceiver,\n _symbol,\n _amount\n );\n }\n }", "function newOracleClaim(\n uint256 _prophecyID,\n address validatorAddress\n ) internal\n returns (bool)\n {\n \n require(\n !hasMadeClaim[_prophecyID][validatorAddress],\n \"Cannot make duplicate oracle claims from the same address.\"\n );\n hasMadeClaim[_prophecyID][validatorAddress] = true;\n \n oracleClaimValidators[_prophecyID] = oracleClaimValidators[_prophecyID].add(\n this.getValidatorPower(validatorAddress)\n );\n emit LogNewOracleClaim(\n _prophecyID,\n validatorAddress\n );\n \n (bool valid, , ) = getProphecyThreshold(_prophecyID);\n return valid;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sifchain Bridge", "functions": ["function mintNewBridgeTokens(\n address payable _intendedRecipient,\n address _bridgeTokenAddress,\n string memory _symbol,\n uint256 _amount\n ) internal {\n require(\n controlledBridgeTokens[_symbol] == _bridgeTokenAddress,\n \"Token must be a controlled bridge token\"\n );\n \n require(\n BridgeToken(_bridgeTokenAddress).mint(_intendedRecipient, _amount),\n \"Attempted mint of bridge tokens failed\"\n );\n emit LogBridgeTokenMint(\n _bridgeTokenAddress,\n _symbol,\n _amount,\n _intendedRecipient\n );\n }", "function unlock(\n address payable _recipient,\n string memory _symbol,\n uint256 _amount\n ) public onlyCosmosBridge whenNotPaused {\n \n require(\n getLockedFunds(_symbol) >= _amount,\n \"!Bank funds\"\n );\n \n address tokenAddress = lockedTokenList[_symbol];\n if (tokenAddress == address(0)) {\n require(\n ((address(this)).balance) >= _amount,\n \"Insufficient ethereum balance for delivery.\"\n );\n } else {\n require(\n BridgeToken(tokenAddress).balanceOf(address(this)) >= _amount,\n \"Insufficient ERC20 token balance for delivery.\"\n );\n }\n unlockFunds(_recipient, tokenAddress, _symbol, _amount);\n }", "function unlockFunds(\n address payable _recipient,\n address _token,\n string memory _symbol,\n uint256 _amount\n ) internal {\n \n lockedFunds[_token] = lockedFunds[_token].sub(_amount);\n \n if (_token == address(0)) {\n (bool success,) = _recipient.call.value(_amount)(\"\");\n require(success, \"error sending ether\");\n } else {\n IERC20 tokenToTransfer = IERC20(_token);\n tokenToTransfer.safeTransfer(_recipient, _amount);\n }\n emit LogUnlock(_recipient, _token, _symbol, _amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Snow Bridge", "functions": ["function submit(Message calldata message, bytes32[] calldata leafProof, bytes calldata headerProof) external {\n bytes32 leafHash = keccak256(abi.encode(message));\n bytes32 commitment = MerkleProof.processProof(leafProof, leafHash);\n if (!parachainClient.verifyCommitment(commitment, headerProof)) {\n revert InvalidProof();\n }\n if (message.nonce != nonce[message.origin] + 1) {\n revert InvalidNonce();\n }\n \n \n \n \n \n \n \n nonce[message.origin]++;\n \n \n \n vault.withdraw(message.origin, payable(msg.sender), reward);\n \n \n \n \n if (gasleft() < gasToForward + GAS_BUFFER) {\n revert NotEnoughGas();\n }\n address recipient = resolve(message.recipient);\n DispatchResult result = DispatchResult.Success;\n try IRecipient(recipient).handle{gas: gasToForward}(message.origin, message.payload) {}\n catch {\n result = DispatchResult.Failure;\n }\n emit MessageDispatched(message.origin, message.nonce, result);\n }", "function handle(ParaID origin, bytes calldata message) external override onlyRole(SENDER_ROLE) {\n ensureOrigin(origin, assetHubParaID);\n Message memory decoded = abi.decode(message, (Message));\n if (decoded.action == Action.Unlock) {\n UnlockPayload memory payload = abi.decode(decoded.payload, (UnlockPayload));\n vault.withdraw(payload.recipient, payload.token, payload.amount);\n emit Unlocked(payload.recipient, payload.token, payload.amount);\n }\n }", "function lock(address token, ParaID dest, bytes calldata recipient, uint128 amount) external payable {\n if (amount == 0) {\n revert InvalidAmount();\n }\n vault.deposit(msg.sender, token, amount);\n bytes memory payload = NativeTokensTypes.Mint(address(registry), token, dest, recipient, amount);\n outboundQueue().submit{value: msg.value}(assetHubParaID, payload);\n emit Locked(recipient, token, amount);\n }", "function deposit(address sender, address token, uint128 amount) external onlyRole(DEPOSIT_ROLE) {\n balance[token] += amount;\n IERC20(token).safeTransferFrom(sender, address(this), amount);\n emit Deposit(sender, token, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Snow Bridge", "functions": ["function submitFinal(Commitment calldata commitment, uint256[] calldata bitfield, ValidatorProof[] calldata proofs)\n public\n {\n (bytes32 commitmentHash, bytes32 ticketID) = validate(commitment, bitfield);\n Ticket storage ticket = tickets[ticketID];\n if (commitment.validatorSetID != currentValidatorSet.id) {\n revert InvalidCommitment();\n }\n verifyCommitment(commitmentHash, bitfield, currentValidatorSet, ticket, proofs);\n bytes32 newMMRRoot = getFirstMMRRoot(commitment);\n latestMMRRoot = newMMRRoot;\n latestBeefyBlock = commitment.blockNumber;\n emit NewMMRRoot(newMMRRoot, commitment.blockNumber);\n delete tickets[ticketID];\n }", "function verifyCommitment(\n bytes32 commitmentHash,\n uint256[] calldata bitfield,\n ValidatorSet memory vset,\n Ticket storage ticket,\n ValidatorProof[] calldata proofs\n ) internal view {\n \n uint256 signatureCount = minimumSignatureThreshold(vset.length);\n if (proofs.length != signatureCount) {\n revert InvalidValidatorProof();\n }\n \n uint256[] memory finalbitfield = Bitfield.subsample(ticket.prevRandao, bitfield, signatureCount, vset.length);\n for (uint256 i = 0; i < proofs.length;) {\n ValidatorProof calldata proof = proofs[i];\n \n if (!Bitfield.isSet(finalbitfield, proof.index)) {\n revert InvalidValidatorProof();\n }\n \n if (!isValidatorInSet(vset, proof.account, proof.index, proof.proof)) {\n revert InvalidValidatorProof();\n }\n \n if (ECDSA.recover(commitmentHash, proof.v, proof.r, proof.s) != proof.account) {\n revert InvalidSignature();\n }\n \n Bitfield.unset(finalbitfield, proof.index);\n unchecked {\n i++;\n }\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Snow Bridge", "functions": ["function submit(ParaID dest, bytes calldata payload) external payable onlyRole(SUBMIT_ROLE) {\n if (msg.value < fee) {\n revert FeePaymentToLow();\n }\n nonce[dest] = nonce[dest] + 1;\n vault.deposit{value: msg.value}(dest);\n emit Message(dest, nonce[dest], payload);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sovryn Bridge", "functions": ["function _send(\n address operator,\n address from,\n address to,\n uint256 amount,\n bytes memory userData,\n bytes memory operatorData,\n bool requireReceptionAck\n )\n internal\n {\n require(from != address(0), \"ERC777: send from zero address\");\n require(to != address(0), \"ERC777: send to zero address\");\n _callTokensToSend(operator, from, to, amount, userData, operatorData);\n _move(operator, from, to, amount, userData, operatorData);\n _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n }", "function _move(\n address operator,\n address from,\n address to,\n uint256 amount,\n bytes memory userData,\n bytes memory operatorData\n )\n internal\n {\n _balances[from] = _balances[from].sub(amount, \"ERC777: transfer amount exceeds balance\");\n _balances[to] = _balances[to].add(amount);\n emit Sent(operator, from, to, amount, userData, operatorData);\n emit Transfer(from, to, amount);\n }", "function _mint(\n address operator,\n address account,\n uint256 amount,\n bytes memory userData,\n bytes memory operatorData\n )\n internal\n {\n require(account != address(0), \"ERC777: mint to zero address\");\n \n _totalSupply = _totalSupply.add(amount);\n _balances[account] = _balances[account].add(amount);\n _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n emit Minted(operator, account, amount, userData, operatorData);\n emit Transfer(address(0), account, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sovryn Bridge", "functions": ["function burn(address usr, uint wad) external {\n require(balanceOf[usr] >= wad, \"Dai/insufficient-balance\");\n if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\n require(allowance[usr][msg.sender] >= wad, \"Dai/insufficient-allowance\");\n allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\n }\n function sub(...) {...}\nbalanceOf[usr] = sub(balanceOf[usr], wad);\n totalSupply = sub(totalSupply, wad);\n emit Transfer(usr, address(0), wad);\n }", "function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n uint fee = (_value.mul(basisPointsRate)).div(10000);\n if (fee > maximumFee) {\n fee = maximumFee;\n }\n uint sendAmount = _value.sub(fee);\n function sub(...) {...}\nfunction add(...) {...}\nbalances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(sendAmount);\n if (fee > 0) {\n balances[owner] = balances[owner].add(fee);\n Transfer(msg.sender, owner, fee);\n }\n Transfer(msg.sender, _to, sendAmount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sovryn Bridge", "functions": ["function _voteTransaction(\n address originalTokenAddress,\n address receiver,\n uint256 amount,\n string memory symbol,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex,\n uint8 decimals,\n uint256 granularity,\n bytes memory userData\n ) internal onlyMember returns (bool) {\n \n require(\n initStageDone == true,\n \"Federation: Cannot process TX while initStageDone == false\"\n );\n bytes32 transactionId = getTransactionId(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity\n );\n if (processed[transactionId]) return true;\n \n \n \n \n \n \n \n \n \n if (\n processTransaction(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n )\n ) {\n \n \n return true;\n }\n return true;\n }", "function processTransaction(\n address originalTokenAddress,\n address receiver,\n uint256 amount,\n string memory symbol,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex,\n uint8 decimals,\n uint256 granularity,\n bytes memory userData\n ) internal returns (bool) {\n bytes32 transactionIdU = getTransactionIdU(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n if (processed[transactionIdU]) return true;\n if (votes[transactionIdU][_msgSender()]) return true;\n function _msgSender(...) {...}\nvotes[transactionIdU][_msgSender()] = true;\n \n emit Voted(\n _msgSender(),\n transactionIdU,\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n uint256 transactionCount = getTransactionCount(transactionIdU);\n if (transactionCount >= required && transactionCount >= members.length / 2 + 1) {\n processed[transactionIdU] = true;\n bool acceptTransfer = bridge.acceptTransferAt(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n require(acceptTransfer, \"Federation: Bridge acceptTransfer error\");\n emit Executed(transactionIdU);\n return true;\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sovryn Bridge", "functions": ["function _executeTransaction(\n address originalTokenAddress,\n address receiver,\n uint256 amount,\n string memory symbol,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex,\n uint8 decimals,\n uint256 granularity,\n bytes memory userData,\n SignatureInfo[] memory signaturesInfos\n ) internal onlyMember returns (bool) {\n \n require(\n initStageDone == true,\n \"Federation: Cannot process TX while initStageDone == false\"\n );\n bytes32 transactionId = getTransactionId(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity\n );\n if (processed[transactionId]) return true;\n \n \n \n \n \n \n \n \n \n if (\n processSignedTransaction(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData,\n signaturesInfos\n )\n ) {\n \n \n return true;\n }\n return true;\n }", "function processSignedTransaction(\n address originalTokenAddress,\n address receiver,\n uint256 amount,\n string memory symbol,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex,\n uint8 decimals,\n uint256 granularity,\n bytes memory userData,\n SignatureInfo[] memory signaturesInfos\n ) internal returns (bool) {\n bytes32 transactionIdU = getTransactionIdU(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n if (processed[transactionIdU]) return true;\n \n function _msgSender(...) {...}\nvotes[transactionIdU][_msgSender()] = true;\n uint256 memberValidations = 1;\n emit Signed(transactionIdU, _msgSender());\n for (uint256 i; i < signaturesInfos.length; i += 1) {\n require(\n signaturesInfos[i].deadline > block.timestamp,\n \"Some signature is not valid anymore\"\n );\n uint256 chainId;\n assembly {\n chainId := chainid()\n }\n bytes32 hash = keccak256(\n abi.encodePacked(\n \"\\x19Ethereum Signed Message:\\n116\",\n abi.encodePacked(\n transactionIdU,\n chainId,\n address(this),\n signaturesInfos[i].deadline\n )\n )\n );\n address signer = ECDSA.recover(hash, signaturesInfos[i].signature);\n require(isMember[signer], \"Signature doesn't match any member\");\n if (!votes[transactionIdU][signer]) {\n votes[transactionIdU][signer] = true;\n memberValidations += 1;\n emit Signed(transactionIdU, signer);\n }\n }\n require(\n memberValidations >= required && memberValidations >= members.length / 2 + 1,\n \"Not enough validations\"\n );\n processed[transactionIdU] = true;\n releaseTokensOnBridge(\n transactionIdU,\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n emit Executed(transactionIdU);\n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sovryn Bridge", "functions": ["function releaseTokensOnBridge(\n bytes32 transactionIdU,\n address originalTokenAddress,\n address receiver,\n uint256 amount,\n string memory symbol,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex,\n uint8 decimals,\n uint256 granularity,\n bytes memory userData\n ) private {\n emit Voted(\n _msgSender(),\n transactionIdU,\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n bool acceptTransfer = bridge.acceptTransferAt(\n originalTokenAddress,\n receiver,\n amount,\n symbol,\n blockHash,\n transactionHash,\n logIndex,\n decimals,\n granularity,\n userData\n );\n require(acceptTransfer, \"Federation: Bridge acceptTransfer error\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "SOY Bridge", "functions": ["function depositTokens(\n address receiver, \n address token, \n uint256 value, \n uint256 toChainId \n ) \n external\n payable\n notFrozen\n {\n require(functionMapping & 1 == 0, \"locked\"); \n require(receiver != address(0), \"Incorrect receiver address\");\n address pair_token = _deposit(token, value, toChainId);\n emit Deposit(token, receiver, value, toChainId, pair_token);\n }", "function _deposit(\n address token, \n uint256 value, \n uint256 toChainId \n ) \n internal \n returns (address pair_token) \n {\n Token memory pair = tokenPair[toChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n pair_token = pair.token;\n uint256 fee = msg.value;\n if (token <= MAX_NATIVE_COINS) {\n require(value <= msg.value, \"Wrong value\");\n fee -= value;\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).burnFrom(msg.sender, value);\n } else {\n tokenDeposits[token] += value;\n token.safeTransferFrom(msg.sender, address(this), value);\n }\n }\n if (fee != 0) {\n feeTo.safeTransferETH(fee);\n emit Fee(msg.sender, fee);\n }\n }", "function claim(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n isTxProcessed[fromChainId][txId] = true;\n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n function safeTransfer(...) {...}\ntoken.safeTransfer(to, value);\n }\n }\n emit Claim(token, to, value, txId, fromChainId, pair.token);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "SOY Bridge", "functions": ["function bridgeToContract(\n address receiver, \n address token, \n uint256 value, \n uint256 toChainId, \n address toContract, \n bytes memory data \n )\n external\n payable\n notFrozen\n {\n require(functionMapping & 2 == 0, \"locked\"); \n require(receiver != address(0), \"Incorrect receiver address\");\n address pair_token = _deposit(token, value, toChainId);\n emit BridgeToContract(token, receiver, value, toChainId, pair_token, toContract, data);\n }", "function _deposit(\n address token, \n uint256 value, \n uint256 toChainId \n ) \n internal \n returns (address pair_token) \n {\n Token memory pair = tokenPair[toChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n pair_token = pair.token;\n uint256 fee = msg.value;\n if (token <= MAX_NATIVE_COINS) {\n require(value <= msg.value, \"Wrong value\");\n fee -= value;\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).burnFrom(msg.sender, value);\n } else {\n tokenDeposits[token] += value;\n token.safeTransferFrom(msg.sender, address(this), value);\n }\n }\n if (fee != 0) {\n feeTo.safeTransferETH(fee);\n emit Fee(msg.sender, fee);\n }\n }", "function claimToContract(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n address toContract, \n bytes memory data, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(functionMapping & 4 == 0, \"locked\"); \n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n {\n isTxProcessed[fromChainId][txId] = true;\n \n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid, toContract, data));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n }\n \n if(isContract(toContract) && toContract != address(this)) {\n if (token <= MAX_NATIVE_COINS) {\n IContractCaller(contractCaller).callContract{value: value}(to, token, value, toContract, data);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(contractCaller, value);\n } else {\n tokenDeposits[token] -= value;\n token.safeTransfer(contractCaller, value);\n }\n IContractCaller(contractCaller).callContract(to, token, value, toContract, data); \n }\n } else { \n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n token.safeTransfer(to, value);\n }\n }\n }\n emit ClaimToContract(token, to, value, txId, fromChainId, pair.token, toContract);\n }", "function callContract(address user, address token, uint256 value, address toContract, bytes memory data) external payable onlyBridge {\n if (token <= MAX_NATIVE_COINS) {\n value = msg.value;\n uint balanceBefore = address(this).balance - value; \n (bool success,) = toContract.call{value: value}(data);\n if (success) value = address(this).balance - balanceBefore; \n if (value != 0) user.safeTransferETH(value); \n } else {\n function safeApprove(...) {...}\nfunction safeTransfer(...) {...}\ntoken.safeApprove(toContract, value);\n (bool success,) = toContract.call{value: 0}(data);\n if (success) value = IERC223TokenCloned(token).allowance(address(this), toContract); \n if (value != 0) { \n token.safeApprove(toContract, 0);\n token.safeTransfer(user, value); \n } \n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "SOY Bridge", "functions": ["function claim(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n isTxProcessed[fromChainId][txId] = true;\n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n function safeTransfer(...) {...}\ntoken.safeTransfer(to, value);\n }\n }\n emit Claim(token, to, value, txId, fromChainId, pair.token);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "SOY Bridge", "functions": ["function claimToContract(\n address token, \n bytes32 txId, \n address to, \n uint256 value, \n uint256 fromChainId, \n address toContract, \n bytes memory data, \n bytes[] memory sig \n ) \n external\n notFrozen\n {\n require(functionMapping & 4 == 0, \"locked\"); \n require(!isTxProcessed[fromChainId][txId], \"Transaction already processed\");\n Token memory pair = tokenPair[fromChainId][token];\n require(pair.token != address(0), \"There is no pair\");\n {\n isTxProcessed[fromChainId][txId] = true;\n \n address must = requiredAuthority;\n bytes32 messageHash = keccak256(abi.encodePacked(token, to, value, txId, fromChainId, block.chainid, toContract, data));\n messageHash = prefixed(messageHash);\n uint256 uniqSig;\n uint256 set; \n for (uint i = 0; i < sig.length; i++) {\n address authority = recoverSigner(messageHash, sig[i]);\n if (authority == must) must = address(0);\n uint256 index = authorities.indexOf(authority);\n uint256 mask = 1 << index;\n if (index != 0 && (set & mask) == 0 ) {\n set |= mask;\n uniqSig++;\n }\n }\n require(threshold <= uniqSig, \"Require more signatures\");\n require(must == address(0), \"The required authority does not sign\");\n }\n \n if(isContract(toContract) && toContract != address(this)) {\n if (token <= MAX_NATIVE_COINS) {\n IContractCaller(contractCaller).callContract{value: value}(to, token, value, toContract, data);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(contractCaller, value);\n } else {\n tokenDeposits[token] -= value;\n token.safeTransfer(contractCaller, value);\n }\n IContractCaller(contractCaller).callContract(to, token, value, toContract, data); \n }\n } else { \n if (token <= MAX_NATIVE_COINS) {\n to.safeTransferETH(value);\n } else {\n if(pair.isWrapped) {\n IBEP20TokenCloned(token).mint(to, value);\n } else {\n tokenDeposits[token] -= value;\n token.safeTransfer(to, value);\n }\n }\n }\n emit ClaimToContract(token, to, value, txId, fromChainId, pair.token, toContract);\n }", "function callContract(address user, address token, uint256 value, address toContract, bytes memory data) external payable onlyBridge {\n if (token <= MAX_NATIVE_COINS) {\n value = msg.value;\n uint balanceBefore = address(this).balance - value; \n (bool success,) = toContract.call{value: value}(data);\n if (success) value = address(this).balance - balanceBefore; \n if (value != 0) user.safeTransferETH(value); \n } else {\n function safeApprove(...) {...}\nfunction safeTransfer(...) {...}\ntoken.safeApprove(toContract, value);\n (bool success,) = toContract.call{value: 0}(data);\n if (success) value = IERC223TokenCloned(token).allowance(address(this), toContract); \n if (value != 0) { \n token.safeApprove(toContract, 0);\n token.safeTransfer(user, value); \n } \n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sream Gold Bridge", "functions": ["function mapToken(address rootToken, address _bridgeToken) public {\n \n require(rootToBridgeTokens[rootToken] == address(0x0), \"FxERC20RootTunnel: ALREADY_MAPPED\");\n \n bytes memory message = abi.encode(MAP_TOKEN, abi.encode(rootToken, _bridgeToken));\n _sendMessageToBridge(message);\n \n rootToBridgeTokens[rootToken] = _bridgeToken;\n emit TokenMappedERC20(rootToken, _bridgeToken);\n }", "function sendMessageToBridge(address _receiver, bytes calldata _data) public override {\n bytes memory data = abi.encode(msg.sender, _receiver, _data);\n stateSender.syncState(fxBridge, data);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sream Gold Bridge", "functions": ["function _processMessageFromBridge(bytes memory data) internal override {\n (address rootToken, address bridgeToken, address to, uint256 amount) = abi.decode(\n data,\n (address, address, address, uint256)\n );\n \n require(rootToBridgeTokens[rootToken] == bridgeToken, \"FxERC20RootTunnel: INVALID_MAPPING_ON_EXIT\");\n \n IERC20(rootToken).safeTransfer(to, amount);\n emit FxWithdrawERC20(rootToken, bridgeToken, to, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sream Gold Bridge", "functions": ["function deposit(\n address rootToken,\n address bridgeToken,\n address user,\n uint256 amount,\n bytes memory data\n ) public {\n \n if (rootToBridgeTokens[rootToken] == address(0x0)) {\n mapToken(rootToken, bridgeToken);\n }\n \n IERC20(rootToken).safeTransferFrom(\n msg.sender, \n address(this), \n amount\n );\n \n bytes memory message = abi.encode(DEPOSIT, abi.encode(rootToken, msg.sender, user, amount, data));\n _sendMessageToBridge(message);\n emit FxDepositERC20(rootToken, msg.sender, user, amount);\n }", "function sendMessageToBridge(address _receiver, bytes calldata _data) public override {\n bytes memory data = abi.encode(msg.sender, _receiver, _data);\n stateSender.syncState(fxBridge, data);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sream Gold Bridge", "functions": ["function _mapToken(bytes memory syncData) internal {\n (address rootToken,address _bridgeToken) = abi.decode(\n syncData,\n (address,address)\n );\n require(_bridgeToken != address(0x0), \"Not the zeroth address\");\n address bridgeToken = rootToBridgeToken[rootToken];\n \n require(bridgeToken == address(0x0), \"FxERC20BridgeTunnel: ALREADY_MAPPED\");\n \n rootToBridgeToken[rootToken] = _bridgeToken;\n emit TokenMapped(rootToken, _bridgeToken);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sream Gold Bridge", "functions": ["function withdraw(address bridgeToken, uint256 amount) public {\n function _withdraw(...) {...}\n_withdraw(bridgeToken, msg.sender, amount);\n }", "function _withdraw(\n address bridgeToken,\n address receiver,\n uint256 amount\n ) internal {\n IFxERC20 bridgeTokenContract = IFxERC20(bridgeToken);\n \n address rootToken = bridgeTokenContract.connectedToken();\n \n require(\n bridgeToken != address(0x0) && rootToken != address(0x0) && bridgeToken == rootToBridgeToken[rootToken],\n \"FxERC20BridgeTunnel: NO_MAPPED_TOKEN\"\n );\n \n bridgeTokenContract.burn(msg.sender, amount);\n \n _sendMessageToRoot(abi.encode(rootToken, bridgeToken, receiver, amount));\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sream Gold Bridge", "functions": ["function _syncDeposit(bytes memory syncData) internal {\n (address rootToken, address depositor, address to, uint256 amount, bytes memory depositData) = abi.decode(\n syncData,\n (address, address, address, uint256, bytes)\n );\n address bridgeToken = rootToBridgeToken[rootToken];\n require(bridgeToken != address(0), \"Bridge Token cannot be zero address\");\n \n IFxERC20 bridgeTokenContract = IFxERC20(bridgeToken);\n bridgeTokenContract.mint(to, amount);\n \n \n if (_isContract(to)) {\n uint256 txGas = 2000000;\n bool success = false;\n bytes memory data = abi.encodeWithSignature(\n \"onTokenTransfer(address,address,address,address,uint256,bytes)\",\n rootToken,\n bridgeToken,\n depositor,\n to,\n amount,\n depositData\n );\n \n assembly {\n success := call(txGas, to, 0, add(data, 0x20), mload(data), 0, 0)\n }\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Sream Gold Bridge", "functions": ["function onStateReceive(uint256 stateId, bytes calldata _data) external override {\n require(msg.sender == address(0x0000000000000000000000000000000000001001), \"Invalid sender\");\n (address rootMessageSender, address receiver, bytes memory data) = abi.decode(_data, (address, address, bytes));\n emit NewFxMessage(rootMessageSender, receiver, data);\n IFxMessageProcessor(receiver).processMessageFromRoot(stateId, rootMessageSender, data);\n }", "function processMessageFromRoot(\n uint256 stateId,\n address rootMessageSender,\n bytes calldata data\n ) external override {\n require(msg.sender == fxBridge, \"FxBaseBridgeTunnel: INVALID_SENDER\");\n _processMessageFromRoot(stateId, rootMessageSender, data);\n }", "function _processMessageFromRoot(\n uint256, \n address sender,\n bytes memory data\n ) internal override validateSender(sender) {\n \n (bytes32 syncType, bytes memory syncData) = abi.decode(data, (bytes32, bytes));\n if (syncType == DEPOSIT) {\n function _syncDeposit(...) {...}\n_syncDeposit(syncData);\n } else if (syncType == MAP_TOKEN) {\n _mapToken(syncData);\n } else {\n revert(\"FxERC20BridgeTunnel: INVALID_SYNC_TYPE\");\n }\n }", "function _syncDeposit(bytes memory syncData) internal {\n (address rootToken, address depositor, address to, uint256 amount, bytes memory depositData) = abi.decode(\n syncData,\n (address, address, address, uint256, bytes)\n );\n address bridgeToken = rootToBridgeToken[rootToken];\n require(bridgeToken != address(0), \"Bridge Token cannot be zero address\");\n \n IFxERC20 bridgeTokenContract = IFxERC20(bridgeToken);\n bridgeTokenContract.mint(to, amount);\n \n \n if (_isContract(to)) {\n uint256 txGas = 2000000;\n bool success = false;\n bytes memory data = abi.encodeWithSignature(\n \"onTokenTransfer(address,address,address,address,uint256,bytes)\",\n rootToken,\n bridgeToken,\n depositor,\n to,\n amount,\n depositData\n );\n \n assembly {\n success := call(txGas, to, 0, add(data, 0x20), mload(data), 0, 0)\n }\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Symbiosis", "functions": ["function synthesize(\n uint256 _stableBridgingFee,\n address _token,\n uint256 _amount,\n address _chain2address,\n address _receiveSide,\n address _oppositeBridge,\n address _revertableAddress,\n uint256 _chainID,\n bytes32 _clientID\n ) external whenNotPaused returns (bytes32) {\n require(tokenWhitelist[_token], \"Symb: unauthorized token\");\n require(_amount >= tokenThreshold[_token], \"Symb: amount under threshold\");\n TransferHelper.safeTransferFrom(\n _token,\n _msgSender(),\n address(this),\n _amount\n );\n return\n sendSynthesizeRequest(\n _stableBridgingFee,\n _token,\n _amount,\n _chain2address,\n _receiveSide,\n _oppositeBridge,\n _revertableAddress,\n _chainID,\n _clientID\n );\n }", "function sendSynthesizeRequest(\n uint256 _stableBridgingFee,\n address _token,\n uint256 _amount,\n address _chain2address,\n address _receiveSide,\n address _oppositeBridge,\n address _revertableAddress,\n uint256 _chainID,\n bytes32 _clientID\n ) internal returns (bytes32 internalID) {\n balanceOf[_token] = balanceOf[_token] + _amount;\n if (_revertableAddress == address(0)) {\n _revertableAddress = _chain2address;\n }\n internalID = keccak256(abi.encodePacked(this, requestCount, block.chainid));\n {\n bytes32 externalID = keccak256(abi.encodePacked(internalID, _receiveSide, _revertableAddress, _chainID));\n {\n bytes memory out = abi.encodeWithSelector(\n bytes4(\n keccak256(\n bytes(\n \"mintSyntheticToken(uint256,bytes32,address,uint256,uint256,address)\"\n )\n )\n ),\n _stableBridgingFee,\n externalID,\n _token,\n block.chainid,\n _amount,\n _chain2address\n );\n requests[externalID] = TxState({\n recipient : _msgSender(),\n chain2address : _chain2address,\n rtoken : _token,\n amount : _amount,\n state : RequestState.Sent\n });\n requestCount++;\n IBridge(bridge).transmitRequestV2(\n out,\n _receiveSide,\n _oppositeBridge,\n _chainID\n );\n }\n }\n emit SynthesizeRequest(\n internalID,\n _msgSender(),\n _chainID,\n _revertableAddress,\n _chain2address,\n _amount,\n _token\n );\n emit ClientIdLog(internalID, _clientID);\n }", "function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n unchecked {\n _balances[sender] = senderBalance - amount;\n }\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);\n _afterTokenTransfer(sender, recipient, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Symbiosis", "functions": ["function revertBurnRequest(\n uint256 _stableBridgingFee,\n bytes32 _internalID,\n address _receiveSide,\n address _oppositeBridge,\n uint256 _chainId,\n bytes32 _clientID\n ) external whenNotPaused {\n bytes32 externalID = keccak256(abi.encodePacked(_internalID, address(this), _msgSender(), block.chainid));\n require(\n unsynthesizeStates[externalID] != UnsynthesizeState.Unsynthesized,\n \"Symb: Real tokens already transfered\"\n );\n unsynthesizeStates[externalID] = UnsynthesizeState.RevertRequest;\n {\n bytes memory out = abi.encodeWithSelector(\n bytes4(keccak256(bytes(\"revertBurn(uint256,bytes32)\"))),\n _stableBridgingFee,\n externalID\n );\n IBridge(bridge).transmitRequestV2(\n out,\n _receiveSide,\n _oppositeBridge,\n _chainId\n );\n }\n emit RevertBurnRequest(_internalID, _msgSender());\n emit ClientIdLog(_internalID, _clientID);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Synbiosis", "functions": ["function synthesize(\n uint256 _stableBridgingFee,\n address _token,\n uint256 _amount,\n address _chain2address,\n address _receiveSide,\n address _oppositeBridge,\n address _revertableAddress,\n uint256 _chainID,\n bytes32 _clientID\n ) external whenNotPaused returns (bytes32) {\n require(tokenWhitelist[_token], \"Symb: unauthorized token\");\n require(_amount >= tokenThreshold[_token], \"Symb: amount under threshold\");\n TransferHelper.safeTransferFrom(\n _token,\n _msgSender(),\n address(this),\n _amount\n );\n return\n sendSynthesizeRequest(\n _stableBridgingFee,\n _token,\n _amount,\n _chain2address,\n _receiveSide,\n _oppositeBridge,\n _revertableAddress,\n _chainID,\n _clientID\n );\n }", "function sendSynthesizeRequest(\n uint256 _stableBridgingFee,\n address _token,\n uint256 _amount,\n address _chain2address,\n address _receiveSide,\n address _oppositeBridge,\n address _revertableAddress,\n uint256 _chainID,\n bytes32 _clientID\n ) internal returns (bytes32 internalID) {\n balanceOf[_token] = balanceOf[_token] + _amount;\n if (_revertableAddress == address(0)) {\n _revertableAddress = _chain2address;\n }\n internalID = keccak256(abi.encodePacked(this, requestCount, block.chainid));\n {\n bytes32 externalID = keccak256(abi.encodePacked(internalID, _receiveSide, _revertableAddress, _chainID));\n {\n bytes memory out = abi.encodeWithSelector(\n bytes4(\n keccak256(\n bytes(\n \"mintSyntheticToken(uint256,bytes32,address,uint256,uint256,address)\"\n )\n )\n ),\n _stableBridgingFee,\n externalID,\n _token,\n block.chainid,\n _amount,\n _chain2address\n );\n requests[externalID] = TxState({\n recipient : _msgSender(),\n chain2address : _chain2address,\n rtoken : _token,\n amount : _amount,\n state : RequestState.Sent\n });\n requestCount++;\n IBridge(bridge).transmitRequestV2(\n out,\n _receiveSide,\n _oppositeBridge,\n _chainID\n );\n }\n }\n emit SynthesizeRequest(\n internalID,\n _msgSender(),\n _chainID,\n _revertableAddress,\n _chain2address,\n _amount,\n _token\n );\n emit ClientIdLog(internalID, _clientID);\n }", "function mintSyntheticToken(\n uint256 _stableBridgingFee,\n bytes32 _externalID,\n address _tokenReal,\n uint256 _chainID,\n uint256 _amount,\n address _to\n ) external onlyBridge whenNotPaused {\n require(\n synthesizeStates[_externalID] == SynthesizeState.Default,\n \"Symb: revertSynthesizedRequest called or tokens have been already synthesized\"\n );\n synthesizeStates[_externalID] = SynthesizeState.Synthesized;\n address syntReprAddr = ISyntFabric(fabric).getSyntRepresentation(_tokenReal, _chainID);\n require(syntReprAddr != address(0), \"Symb: There is no synt representation for this token\");\n ISyntFabric(fabric).synthesize(\n _to,\n _amount - _stableBridgingFee,\n syntReprAddr\n );\n ISyntFabric(fabric).synthesize(\n bridge,\n _stableBridgingFee,\n syntReprAddr\n );\n emit SynthesizeCompleted(_externalID, _to, _amount - _stableBridgingFee, _stableBridgingFee, _tokenReal);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Synbiosis", "functions": ["function burnSyntheticToken(\n uint256 _stableBridgingFee,\n address _stoken,\n uint256 _amount,\n address _chain2address,\n address _receiveSide,\n address _oppositeBridge,\n address _revertableAddress,\n uint256 _chainID,\n bytes32 _clientID\n ) external whenNotPaused returns (bytes32 internalID) {\n require(_amount >= tokenThreshold[_stoken], \"Symb: amount under threshold\");\n ISyntFabric(fabric).unsynthesize(_msgSender(), _amount, _stoken);\n if (_revertableAddress == address(0)) {\n _revertableAddress = _chain2address;\n }\n {\n address rtoken = ISyntFabric(fabric).getRealRepresentation(_stoken);\n require(rtoken != address(0), \"Symb: incorrect synt\");\n internalID = keccak256(\n abi.encodePacked(this, requestCount, block.chainid)\n );\n bytes32 externalID = keccak256(abi.encodePacked(internalID, _receiveSide, _revertableAddress, _chainID));\n bytes memory out = abi.encodeWithSelector(\n bytes4(\n keccak256(\n bytes(\"unsynthesize(uint256,bytes32,address,uint256,address)\")\n )\n ),\n _stableBridgingFee,\n externalID,\n rtoken,\n _amount,\n _chain2address\n );\n requests[externalID] = TxState({\n recipient: _msgSender(),\n chain2address: _chain2address,\n token: rtoken,\n stoken: _stoken,\n amount: _amount,\n state: RequestState.Sent\n });\n requestCount++;\n IBridge(bridge).transmitRequestV2(\n out,\n _receiveSide,\n _oppositeBridge,\n _chainID\n );\n }\n emit BurnRequest(internalID, _msgSender(), _chainID, _revertableAddress, _chain2address, _amount, _stoken);\n emit ClientIdLog(internalID, _clientID);\n }", "function unsynthesize(\n uint256 _stableBridgingFee,\n bytes32 _externalID,\n address _token,\n uint256 _amount,\n address _to\n ) external onlyBridge whenNotPaused {\n require(\n unsynthesizeStates[_externalID] == UnsynthesizeState.Default,\n \"Symb: synthetic tokens emergencyUnburn\"\n );\n balanceOf[_token] = balanceOf[_token] - _amount;\n unsynthesizeStates[_externalID] = UnsynthesizeState.Unsynthesized;\n TransferHelper.safeTransfer(_token, _to, _amount - _stableBridgingFee);\n TransferHelper.safeTransfer(_token, bridge, _stableBridgingFee);\n emit BurnCompleted(_externalID, _to, _amount - _stableBridgingFee, _stableBridgingFee, _token);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Synbiosis", "functions": ["function transmitRequestV2(\n bytes memory _callData,\n address _receiveSide,\n address _oppositeBridge,\n uint256 _chainId\n ) public onlyTransmitter {\n emit OracleRequest(\n address(this),\n _callData,\n _receiveSide,\n _oppositeBridge,\n _chainId\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Syndicate Bridge", "functions": ["function enter(\n Token memory token,\n address from,\n address to,\n uint256 amount\n ) internal returns (Token memory) {\n require(token.exist, \"RT: NOT_LISTED\");\n if (token.issueType == IssueType.MINTABLE) {\n IBridgeToken(token.addr).burn(from, amount);\n } else if (token.issueType == IssueType.DEFAULT) {\n IERC20(token.addr).safeTransferFrom(from, to, amount);\n } else {\n assert(false);\n }\n return token;\n }", "function burn(address _from, uint256 _amnt) external override onlyOwner {\n _burn(_from, _amnt);\n }", "function exit(\n Token memory token,\n address from,\n address to,\n uint256 amount\n ) internal returns (Token memory) {\n require(token.exist, \"RT: NOT_LISTED\");\n if (token.addr == address(0)) {\n unsafeTransfer(from, to, amount);\n } else if (token.issueType == IssueType.MINTABLE) {\n IBridgeToken(token.addr).mint(to, amount);\n } else if (token.issueType == IssueType.DEFAULT) {\n IERC20(token.addr).safeTransfer(to, amount);\n } else {\n assert(false);\n }\n return token;\n }", "function verify(\n bytes32 commitment,\n uint256 chainId,\n bytes[] calldata signatures\n ) external view override returns (bool) {\n uint8 _required = getCosignCount(chainId);\n if (_required > signatures.length) {\n return false;\n }\n address[] memory cached = new address[](signatures.length);\n uint8 signersMatch;\n for (uint8 i = 0; i < signatures.length; i++) {\n address signer = recover(commitment, signatures[i]);\n Cosigner memory cosigner = _cosigners[signer];\n if (\n cosigner.active &&\n cosigner.chainId == chainId &&\n !_inCache(cached, signer)\n ) {\n signersMatch++;\n cached[i] = signer;\n if (signersMatch == _required) return true;\n }\n }\n return false;\n }", "function mint(address _to, uint256 _amnt) external override onlyOwner {\n _mint(_to, _amnt);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Syndicate Bridge", "functions": ["function addCosigner(address cosaddr, uint256 chainId)\n public\n override\n onlyOwner\n {\n Cosigner memory cosigner = _cosigners[cosaddr];\n require(!cosigner.active, \"BCM: ALREADY_EXIST\");\n require(cosaddr != address(0), \"BCM: ZERO_ADDRESS\");\n uint256 currentChainId;\n assembly {\n currentChainId := chainid()\n }\n require(currentChainId != chainId, \"BCM: ONLY_EXTERNAL\");\n _cosaddrs[chainId].push(cosaddr);\n _cosigners[cosaddr] = Cosigner(\n cosaddr,\n chainId,\n _cosaddrs[chainId].length - 1,\n true\n );\n emit CosignerAdded(cosaddr, chainId);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Syndicate Bridge", "functions": ["function removeCosigner(address cosaddr) public override onlyOwner {\n require(cosaddr != address(0), \"BCM: ZERO_ADDRESS\");\n Cosigner memory cosigner = _cosigners[cosaddr];\n require(cosigner.active, \"BCM: NOT_EXIST\");\n address[] storage addrs = _cosaddrs[cosigner.chainId];\n if (addrs.length > 1) {\n \n addrs[cosigner.index] = _cosaddrs[cosigner.chainId][\n addrs.length - 1\n ];\n addrs.pop();\n \n address cosaddrLast = addrs[cosigner.index];\n _cosigners[cosaddrLast].index = cosigner.index;\n } else {\n \n addrs.pop();\n }\n delete _cosigners[cosaddr];\n emit CosignerRemoved(cosigner.addr, cosigner.chainId);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Terra Bridge", "functions": ["function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Terra Bridge", "functions": ["function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Terra Bridge", "functions": ["function mint(\n address user,\n uint256 amount,\n uint256 index\n ) external override onlyLendingPool returns (bool) {\n uint256 previousBalance = super.balanceOf(user);\n uint256 amountScaled = amount.rayDiv(index);\n require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n _mint(user, amountScaled);\n emit Transfer(address(0), user, amount);\n emit Mint(user, amount, index);\n return previousBalance == 0;\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), 'ERC20: mint to the zero address');\n _beforeTokenTransfer(address(0), account, amount);\n uint256 oldTotalSupply = _totalSupply;\n _totalSupply = oldTotalSupply.add(amount);\n uint256 oldAccountBalance = _balances[account];\n _balances[account] = oldAccountBalance.add(amount);\n if (address(_getIncentivesController()) != address(0)) {\n _getIncentivesController().handleAction(account, oldTotalSupply, oldAccountBalance);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Terra Bridge", "functions": ["function burn(\n address user,\n address receiverOfUnderlying,\n uint256 amount,\n uint256 index\n ) external override onlyLendingPool {\n uint256 amountScaled = amount.rayDiv(index);\n require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n _burn(user, amountScaled);\n IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n emit Transfer(user, address(0), amount);\n emit Burn(user, receiverOfUnderlying, amount, index);\n }", "function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), 'ERC20: burn from the zero address');\n _beforeTokenTransfer(account, address(0), amount);\n uint256 oldTotalSupply = _totalSupply;\n _totalSupply = oldTotalSupply.sub(amount);\n uint256 oldAccountBalance = _balances[account];\n _balances[account] = oldAccountBalance.sub(amount, 'ERC20: burn amount exceeds balance');\n if (address(_getIncentivesController()) != address(0)) {\n _getIncentivesController().handleAction(account, oldTotalSupply, oldAccountBalance);\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "THORChain", "functions": ["function deposit(uint value, string memory memo) public {\n require(value > 0, \"user must send assets\");\n iRUNE(RUNE).transferTo(address(this), value);\n emit Deposit(msg.sender, value, memo);\n }", "function transferOut(address payable to, address asset, uint amount, string memory memo) public payable {\n uint safeAmount;\n if(asset == address(0)){\n safeAmount = msg.value;\n to.call{value:msg.value}(\"\"); \n } else {\n vaultAllowance[msg.sender][asset] -= amount; \n asset.call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n safeAmount = amount;\n }\n emit TransferOut(msg.sender, to, asset, safeAmount, memo);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "THORChain", "functions": ["function transferOut(address to, uint value, string memory memo) public onlyAdmin {\n iRUNE(RUNE).transfer(to, value);\n emit Outbound(to, value, memo);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "TON bridge", "functions": ["function burn(uint256 amount, TonAddress memory addr) external {\n require(allowBurn, \"Burn is currently disabled\");\n _burn(msg.sender, amount);\n emit SwapEthToTon(msg.sender, addr.workchain, addr.address_hash, amount);\n }", "function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _beforeTokenTransfer(account, address(0), amount);\n uint256 accountBalance = _balances[account];\n require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n _balances[account] = accountBalance - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }", "function mint(SwapData memory sd) internal {\n _mint(sd.receiver, sd.amount);\n emit SwapTonToEth(sd.tx.address_.workchain, sd.tx.address_.address_hash, sd.tx.tx_hash, sd.tx.lt, sd.receiver, sd.amount);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n _totalSupply += amount;\n _balances[account] += amount;\n emit Transfer(address(0), account, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "TON bridge", "functions": ["function mint(SwapData memory sd) internal {\n _mint(sd.receiver, sd.amount);\n emit SwapTonToEth(sd.tx.address_.workchain, sd.tx.address_.address_hash, sd.tx.tx_hash, sd.tx.lt, sd.receiver, sd.amount);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n _totalSupply += amount;\n _balances[account] += amount;\n emit Transfer(address(0), account, amount);\n }", "function burn(uint256 amount, TonAddress memory addr) external {\n require(allowBurn, \"Burn is currently disabled\");\n _burn(msg.sender, amount);\n emit SwapEthToTon(msg.sender, addr.workchain, addr.address_hash, amount);\n }", "function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _beforeTokenTransfer(account, address(0), amount);\n uint256 accountBalance = _balances[account];\n require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n _balances[account] = accountBalance - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "TON bridge", "functions": ["function voteForMinting(SwapData memory data, Signature[] memory signatures) override public {\n bytes32 _id = getSwapDataId(data);\n function generalVote(...) {...}\nfunction executeMinting(...) {...}\ngeneralVote(_id, signatures);\n executeMinting(data);\n }", "function generalVote(bytes32 digest, Signature[] memory signatures) internal {\n \n \n require(signatures.length >= 2 * oraclesSet.length / 3, \"Not enough signatures\");\n require(!finishedVotings[digest], \"Vote is already finished\");\n uint signum = signatures.length;\n uint last_signer = 0;\n for(uint i=0; i<signum; i++) {\n address signer = signatures[i].signer;\n require(isOracle[signer], \"Unauthorized signer\");\n uint next_signer = uint(signer);\n require(next_signer > last_signer, \"Signatures are not sorted\");\n last_signer = next_signer;\n checkSignature(digest, signatures[i]);\n }\n finishedVotings[digest] = true;\n }", "function checkSignature(bytes32 digest, Signature memory sig) public pure {\n if (sig.signature.length != 65) {\n revert(\"ECDSA: invalid signature length\");\n }\n \n bytes32 r;\n bytes32 s;\n uint8 v;\n bytes memory signature = sig.signature;\n \n \n \n assembly {\n r := mload(add(signature, 0x20))\n s := mload(add(signature, 0x40))\n v := byte(0, mload(add(signature, 0x60)))\n }\n if (\n uint256(s) >\n 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n ) {\n revert(\"ECDSA: invalid signature 's' value\");\n }\n if (v != 27 && v != 28) {\n revert(\"ECDSA: invalid signature 'v' value\");\n }\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, digest));\n require(ecrecover(prefixedHash, v, r, s) == sig.signer, \"Wrong signature\");\n }", "function executeMinting(SwapData memory data) internal {\n mint(data);\n }", "function mint(SwapData memory sd) internal {\n _mint(sd.receiver, sd.amount);\n emit SwapTonToEth(sd.tx.address_.workchain, sd.tx.address_.address_hash, sd.tx.tx_hash, sd.tx.lt, sd.receiver, sd.amount);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n _totalSupply += amount;\n _balances[account] += amount;\n emit Transfer(address(0), account, amount);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "TON bridge", "functions": ["function voteForNewOracleSet(int oracleSetHash, address[] memory newOracles, Signature[] memory signatures) override public {\n bytes32 _id = getNewSetId(oracleSetHash, newOracles);\n require(newOracles.length > 2, \"New set is too short\");\n function generalVote(...) {...}\nfunction updateOracleSet(...) {...}\ngeneralVote(_id, signatures);\n updateOracleSet(oracleSetHash, newOracles);\n }", "function generalVote(bytes32 digest, Signature[] memory signatures) internal {\n \n \n require(signatures.length >= 2 * oraclesSet.length / 3, \"Not enough signatures\");\n require(!finishedVotings[digest], \"Vote is already finished\");\n uint signum = signatures.length;\n uint last_signer = 0;\n for(uint i=0; i<signum; i++) {\n address signer = signatures[i].signer;\n require(isOracle[signer], \"Unauthorized signer\");\n uint next_signer = uint(signer);\n require(next_signer > last_signer, \"Signatures are not sorted\");\n last_signer = next_signer;\n checkSignature(digest, signatures[i]);\n }\n finishedVotings[digest] = true;\n }", "function checkSignature(bytes32 digest, Signature memory sig) public pure {\n if (sig.signature.length != 65) {\n revert(\"ECDSA: invalid signature length\");\n }\n \n bytes32 r;\n bytes32 s;\n uint8 v;\n bytes memory signature = sig.signature;\n \n \n \n assembly {\n r := mload(add(signature, 0x20))\n s := mload(add(signature, 0x40))\n v := byte(0, mload(add(signature, 0x60)))\n }\n if (\n uint256(s) >\n 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n ) {\n revert(\"ECDSA: invalid signature 's' value\");\n }\n if (v != 27 && v != 28) {\n revert(\"ECDSA: invalid signature 'v' value\");\n }\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, digest));\n require(ecrecover(prefixedHash, v, r, s) == sig.signer, \"Wrong signature\");\n }", "function updateOracleSet(int oracleSetHash, address[] memory newSet) internal {\n uint oldSetLen = oraclesSet.length;\n for(uint i = 0; i < oldSetLen; i++) {\n isOracle[oraclesSet[i]] = false;\n }\n oraclesSet = newSet;\n uint newSetLen = oraclesSet.length;\n for(uint i = 0; i < newSetLen; i++) {\n require(!isOracle[newSet[i]], \"Duplicate oracle in Set\");\n isOracle[newSet[i]] = true;\n }\n emit NewOracleSet(oracleSetHash, newSet);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "TON bridge", "functions": ["function voteForSwitchBurn(bool newBurnStatus, int nonce, Signature[] memory signatures) override public {\n bytes32 _id = getNewBurnStatusId(newBurnStatus, nonce);\n function generalVote(...) {...}\ngeneralVote(_id, signatures);\n allowBurn = newBurnStatus;\n }", "function generalVote(bytes32 digest, Signature[] memory signatures) internal {\n \n \n require(signatures.length >= 2 * oraclesSet.length / 3, \"Not enough signatures\");\n require(!finishedVotings[digest], \"Vote is already finished\");\n uint signum = signatures.length;\n uint last_signer = 0;\n for(uint i=0; i<signum; i++) {\n address signer = signatures[i].signer;\n require(isOracle[signer], \"Unauthorized signer\");\n uint next_signer = uint(signer);\n require(next_signer > last_signer, \"Signatures are not sorted\");\n last_signer = next_signer;\n checkSignature(digest, signatures[i]);\n }\n finishedVotings[digest] = true;\n }", "function checkSignature(bytes32 digest, Signature memory sig) public pure {\n if (sig.signature.length != 65) {\n revert(\"ECDSA: invalid signature length\");\n }\n \n bytes32 r;\n bytes32 s;\n uint8 v;\n bytes memory signature = sig.signature;\n \n \n \n assembly {\n r := mload(add(signature, 0x20))\n s := mload(add(signature, 0x40))\n v := byte(0, mload(add(signature, 0x60)))\n }\n if (\n uint256(s) >\n 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n ) {\n revert(\"ECDSA: invalid signature 's' value\");\n }\n if (v != 27 && v != 28) {\n revert(\"ECDSA: invalid signature 'v' value\");\n }\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, digest));\n require(ecrecover(prefixedHash, v, r, s) == sig.signer, \"Wrong signature\");\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Transit Swap", "functions": ["function swap(TransitStructs.TransitSwapDescription calldata desc, TransitStructs.CallbytesDescription calldata callbytesDesc) external payable nonReentrant whenNotPaused {\n require(callbytesDesc.calldatas.length > 0, \"TransitSwap: data should be not zero\");\n require(desc.amount > 0, \"TransitSwap: amount should be greater than 0\");\n require(desc.dstReceiver != address(0), \"TransitSwap: receiver should be not address(0)\");\n require(desc.minReturnAmount > 0, \"TransitSwap: minReturnAmount should be greater than 0\");\n if (callbytesDesc.flag == uint8(TransitStructs.Flag.aggregate)) {\n require(desc.srcToken == callbytesDesc.srcToken, \"TransitSwap: invalid callbytesDesc\");\n }\n bool preTradeModel = !_swap_type_mode[desc.swapType];\n function _beforeSwap(...) {...}\nfunction _afterSwap(...) {...}\n(uint256 swapAmount, uint256 fee, uint256 beforeBalance) = _beforeSwap(preTradeModel, desc);\n {\n \n (bool success, bytes memory result) = _transit_swap.call{value:swapAmount}(abi.encodeWithSelector(0xccbe4007, callbytesDesc));\n if (!success) {\n revert(RevertReasonParser.parse(result,\"TransitSwap:\"));\n }\n }\n (uint256 returnAmount, uint256 postFee) = _afterSwap(preTradeModel, desc, beforeBalance);\n if (postFee > fee) {\n fee = postFee;\n }\n _emitTransit(desc, preTradeModel, fee, returnAmount);\n }", "function _beforeSwap(bool preTradeModel, TransitStructs.TransitSwapDescription calldata desc) private returns (uint256 swapAmount, uint256 fee, uint256 beforeBalance) {\n if (preTradeModel) {\n fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, desc.amount, desc.swapType, desc.channel);\n }\n if (TransferHelper.isETH(desc.srcToken)) {\n require(msg.value == desc.amount, \"TransitSwap: invalid msg.value\");\n swapAmount = desc.amount.sub(fee);\n } else {\n if (preTradeModel) {\n TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\n TransferHelper.safeTransfer(desc.srcToken, desc.srcReceiver, desc.amount.sub(fee));\n } else {\n TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, desc.srcReceiver, desc.amount);\n }\n }\n if (TransferHelper.isETH(desc.dstToken)) {\n if (preTradeModel) {\n beforeBalance = desc.dstReceiver.balance;\n } else {\n if (desc.swapType == uint8(TransitStructs.SwapTypes.swap)) {\n beforeBalance = IERC20(desc.wrappedNative).balanceOf(address(this));\n } else {\n beforeBalance = address(this).balance;\n }\n }\n } else {\n if (preTradeModel) {\n beforeBalance = IERC20(desc.dstToken).balanceOf(desc.dstReceiver);\n } else {\n beforeBalance = IERC20(desc.dstToken).balanceOf(address(this));\n }\n }\n }", "function _afterSwap(bool preTradeModel, TransitStructs.TransitSwapDescription calldata desc, uint256 beforeBalance) private returns (uint256 returnAmount, uint256 fee) {\n if (TransferHelper.isETH(desc.dstToken)) {\n if (preTradeModel) {\n returnAmount = desc.dstReceiver.balance.sub(beforeBalance);\n require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n } else {\n if (desc.swapType == uint8(TransitStructs.SwapTypes.swap)) {\n returnAmount = IERC20(desc.wrappedNative).balanceOf(address(this)).sub(beforeBalance);\n TransferHelper.safeWithdraw(desc.wrappedNative, returnAmount);\n } else {\n returnAmount = address(this).balance.sub(beforeBalance);\n }\n fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, returnAmount, desc.swapType, desc.channel);\n returnAmount = returnAmount.sub(fee);\n require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n TransferHelper.safeTransferETH(desc.dstReceiver, returnAmount);\n }\n } else {\n if (preTradeModel) {\n returnAmount = IERC20(desc.dstToken).balanceOf(desc.dstReceiver).sub(beforeBalance);\n require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n } else {\n returnAmount = IERC20(desc.dstToken).balanceOf(address(this)).sub(beforeBalance);\n fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, returnAmount, desc.swapType, desc.channel);\n returnAmount = returnAmount.sub(fee);\n uint256 receiverBeforeBalance = IERC20(desc.dstToken).balanceOf(desc.dstReceiver);\n TransferHelper.safeTransfer(desc.dstToken, desc.dstReceiver, returnAmount);\n returnAmount = IERC20(desc.dstToken).balanceOf(desc.dstReceiver).sub(receiverBeforeBalance);\n require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n }\n } \n }", "function cross(TransitStructs.TransitSwapDescription calldata desc, TransitStructs.CallbytesDescription calldata callbytesDesc) external payable nonReentrant whenNotPaused {\n require(callbytesDesc.calldatas.length > 0, \"TransitSwap: data should be not zero\");\n require(desc.amount > 0, \"TransitSwap: amount should be greater than 0\");\n require(desc.srcToken == callbytesDesc.srcToken, \"TransitSwap: invalid callbytesDesc\");\n function _beforeCross(...) {...}\n(uint256 swapAmount, uint256 fee, uint256 beforeBalance) = _beforeCross(desc);\n {\n \n (bool success, bytes memory result) = _transit_cross.call{value:swapAmount}(abi.encodeWithSelector(0xccbe4007, callbytesDesc));\n if (!success) {\n revert(RevertReasonParser.parse(result,\"TransitSwap:\"));\n }\n }\n if (!TransferHelper.isETH(desc.srcToken)) {\n require(IERC20(desc.srcToken).balanceOf(_transit_cross) >= beforeBalance, \"TransitSwap: invalid cross\");\n }\n _emitTransit(desc, true, fee, 0);\n }", "function _beforeCross(TransitStructs.TransitSwapDescription calldata desc) private returns (uint256 swapAmount, uint256 fee, uint256 beforeBalance) {\n fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, desc.amount, desc.swapType, desc.channel);\n if (TransferHelper.isETH(desc.srcToken)) {\n require(msg.value == desc.amount, \"TransitSwap: invalid msg.value\");\n swapAmount = desc.amount.sub(fee);\n } else {\n beforeBalance = IERC20(desc.srcToken).balanceOf(_transit_cross);\n if (fee == 0) {\n TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, _transit_cross, desc.amount);\n } else {\n TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\n TransferHelper.safeTransfer(desc.srcToken, _transit_cross, desc.amount.sub(fee));\n }\n }\n }", "function _emitTransit(TransitStructs.TransitSwapDescription calldata desc, bool preTradeModel, uint256 fee, uint256 returnAmount) private {\n emit TransitSwapped(\n desc.srcToken, \n desc.dstToken, \n desc.dstReceiver, \n msg.sender, \n preTradeModel, \n desc.amount, \n returnAmount, \n desc.minReturnAmount, \n fee, \n desc.toChainID, \n desc.channel,\n block.timestamp\n );\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "WanBridge", "functions": ["function buyWanCoin(address receipient) \n public \n payable \n notHalted \n initialized \n ceilingNotReached \n notEarlierThan(earlyReserveBeginTime)\n earlierThan(endTime)\n returns (bool) \n {\n require(receipient != 0x0);\n require(msg.value >= 0.1 ether);\n \n function isContract(...) {...}\nfunction buyEarlyAdopters(...) {...}\nfunction buyNormal(...) {...}\nrequire(!isContract(msg.sender)); \n if( now < startTime && now >= earlyReserveBeginTime)\n buyEarlyAdopters(receipient);\n else {\n require( tx.gasprice <= 50000000000 wei );\n require(msg.value <= normalBuyLimit);\n buyNormal(receipient);\n }\n return true;\n }", "function buyEarlyAdopters(address receipient) internal {\n uint quotaAvailable = earlyUserQuotas[receipient];\n require(quotaAvailable > 0);\n uint toFund = quotaAvailable.min256(msg.value);\n uint tokenAvailable4Adopter = toFund.mul(PRICE_RATE_FIRST);\n function sub(...) {...}\nearlyUserQuotas[receipient] = earlyUserQuotas[receipient].sub(toFund);\n buyCommon(receipient, toFund, tokenAvailable4Adopter);\n }", "function buyCommon(address receipient, uint toFund, uint wanTokenCollect) internal {\n require(msg.value >= toFund); \n if(toFund > 0) {\n function mintToken(...) {...}\nfunction transfer(...) {...}\nfunction add(...) {...}\nrequire(wanToken.mintToken(receipient, wanTokenCollect)); \n wanport.transfer(toFund);\n openSoldTokens = openSoldTokens.add(wanTokenCollect);\n NewSale(receipient, toFund, wanTokenCollect); \n }\n uint toReturn = msg.value.sub(toFund);\n if(toReturn > 0) {\n msg.sender.transfer(toReturn);\n }\n }", "function buyNormal(address receipient) internal {\n uint inWhiteListTag = fullWhiteList[receipient];\n require(inWhiteListTag > 0);\n \n uint tokenAvailable = MAX_OPEN_SOLD.sub(openSoldTokens);\n require(tokenAvailable > 0);\n uint toFund;\n uint toCollect;\n (toFund, toCollect) = costAndBuyTokens(tokenAvailable);\n buyCommon(receipient, toFund, toCollect);\n }", "function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n \n \n \n \n if (balances[msg.sender] >= _value) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "WanBridge", "functions": ["function claimTokens(address receipent)\n public\n onlyMinter\n {\n function add(...) {...}\nbalances[receipent] = balances[receipent].add(lockedBalances[receipent]);\n lockedBalances[receipent] = 0;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "WeiBridge", "functions": ["function lockTokensForOptimism() public payable {\n if (msg.value != 1003 ) { revert msgValueNot1003(); }\n \n function enqueue(...) {...}\nenqueue();\n payable(Owner).transfer(msg.value);\n }", "function enqueue() private { \n last += 1;\n queue[last] = msg.sender;\n }", "function ownerUnlockGoerliETH(address userToBridge) public {\n if (msg.sender != Owner) { revert notOwnerAddress(); }\n \n \n \n payable(userToBridge).transfer(1000);\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Wrap Protocol", "functions": ["function execTransaction(\n address to,\n uint256 value,\n bytes calldata data,\n string calldata tezosOperation,\n bytes calldata signatures\n )\n external\n returns (bool success)\n {\n require(tezosOperations[tezosOperation] == false, 'WRAP: TRANSACTION_ALREADY_PROCESSED');\n tezosOperations[tezosOperation] = true;\n bytes memory txHashData = encodeTransactionData(\n to, value, data,\n tezosOperation\n );\n bytes32 txHash = keccak256(txHashData);\n function _checkSignatures(...) {...}\nfunction _execute(...) {...}\n_checkSignatures(txHash, signatures);\n success = _execute(to, value, data, gasleft());\n if (success) emit ExecutionSuccess(txHash);\n else emit ExecutionFailure(txHash);\n }", "function _checkSignatures(\n bytes32 dataHash,\n bytes memory signatures\n )\n internal\n view\n {\n uint256 _threshold = threshold;\n require(_threshold > 0, \"WRAP: THRESHOLD_NOT_DEFINED\");\n require(signatures.length >= _threshold.mul(65), \"WRAP: SIGNATURES_DATA_TOO_SHORT\");\n address lastOwner = address(0);\n address currentOwner;\n uint8 v;\n bytes32 r;\n bytes32 s;\n uint256 i;\n for (i = 0; i < _threshold; i++) {\n (v, r, s) = _signatureSplit(signatures, i);\n currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v, r, s);\n require (\n currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n \"WRAP: INVALID_OWNER_PROVIDED\"\n );\n lastOwner = currentOwner;\n }\n }", "function _execute(\n address to,\n uint256 value,\n bytes memory data,\n uint256 txGas\n )\n internal\n returns (bool success)\n {\n assembly {\n success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "Wrap Protocol", "functions": ["function execTransaction(\n address to,\n uint256 value,\n bytes calldata data,\n string calldata tezosOperation,\n bytes calldata signatures\n )\n external\n returns (bool success)\n {\n require(tezosOperations[tezosOperation] == false, 'WRAP: TRANSACTION_ALREADY_PROCESSED');\n tezosOperations[tezosOperation] = true;\n bytes memory txHashData = encodeTransactionData(\n to, value, data,\n tezosOperation\n );\n bytes32 txHash = keccak256(txHashData);\n function _checkSignatures(...) {...}\nfunction _execute(...) {...}\n_checkSignatures(txHash, signatures);\n success = _execute(to, value, data, gasleft());\n if (success) emit ExecutionSuccess(txHash);\n else emit ExecutionFailure(txHash);\n }", "function _checkSignatures(\n bytes32 dataHash,\n bytes memory signatures\n )\n internal\n view\n {\n uint256 _threshold = threshold;\n require(_threshold > 0, \"WRAP: THRESHOLD_NOT_DEFINED\");\n require(signatures.length >= _threshold.mul(65), \"WRAP: SIGNATURES_DATA_TOO_SHORT\");\n address lastOwner = address(0);\n address currentOwner;\n uint8 v;\n bytes32 r;\n bytes32 s;\n uint256 i;\n for (i = 0; i < _threshold; i++) {\n (v, r, s) = _signatureSplit(signatures, i);\n currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v, r, s);\n require (\n currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n \"WRAP: INVALID_OWNER_PROVIDED\"\n );\n lastOwner = currentOwner;\n }\n }", "function _execute(\n address to,\n uint256 value,\n bytes memory data,\n uint256 txGas\n )\n internal\n returns (bool success)\n {\n assembly {\n success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n }\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "XDAGBridge", "functions": ["function acceptTransfer(\n address receiver,\n uint256 amount,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex\n ) external override returns (bool) {\n require(receiver != NULL_ADDRESS, \"Bridge: Receiver is null\");\n require(amount > 0, \"Bridge: Amount 0\");\n require(blockHash != NULL_HASH, \"Bridge: BlockHash is null\");\n require(transactionHash != NULL_HASH, \"Bridge: Transaction is null\");\n bytes32 compiledId =\n getTransactionId(\n blockHash,\n transactionHash,\n receiver,\n amount,\n logIndex\n );\n require(!processed[compiledId], \"Bridge: Already processed\");\n processed[compiledId] = true;\n BridgeToken(erc20XDAG).mint(receiver, amount); \n return true;\n }", "function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); \n            vaultAllowance[vault][asset] += safeAmount; \n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}

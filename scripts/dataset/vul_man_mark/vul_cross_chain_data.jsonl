{"project": "allbridge", "functions": ["function swap(uint256 amount, bytes32 token, bytes32 receiveToken, address recipient) external {\n Pool tokenPool = pools[token];\n Pool receiveTokenPool = pools[receiveToken];\n require(address(tokenPool) != address(0), \"Router: no pool\");\n require(address(receiveTokenPool) != address(0), \"Router: no pool\");\n uint256 vUsdAmount = tokenPool.swapToVUsd(msg.sender, amount);\n function swapFromVUsd(...) {...}\nreceiveTokenPool.swapFromVUsd(recipient, vUsdAmount);\n }", "function swapToVUsd(address user, uint256 amount) external onlyRouter returns (uint256) {\n uint256 result; \n uint256 fee;\n if (amount > 0) {\n fee = amount * feeShareBP / BP;\n uint256 amountIn = toSystemPrecision(amount - fee);\n \n fee = amount - fromSystemPrecision(amountIn);\n tokenBalance += amountIn;\n uint256 vUsdNewAmount = this.getY(tokenBalance);\n if (vUsdBalance > vUsdNewAmount) {\n result = vUsdBalance - vUsdNewAmount;\n }\n vUsdBalance = vUsdNewAmount;\n function safeTransferFrom(...) {...}\nfunction _addRewards(...) {...}\ntoken.safeTransferFrom(user, address(this), amount);\n _addRewards(fee);\n }\n emit SwappedToVUsd(user, address(token), amount, result, fee);\n return result;\n }", "function swapFromVUsd(address user, uint256 amount) external onlyRouter returns (uint256) {\n uint256 result; \n uint256 fee;\n if (amount > 0) {\n vUsdBalance += amount;\n uint256 newAmount = this.getY(vUsdBalance);\n if (tokenBalance > newAmount) {\n result = fromSystemPrecision(tokenBalance - newAmount);\n } \n fee = result * feeShareBP / BP;\n \n unchecked {\n result -= fee;\n }\n tokenBalance = newAmount;\n function safeTransfer(...) {...}\nfunction _addRewards(...) {...}\ntoken.safeTransfer(user, result);\n _addRewards(fee);\n }\n emit SwappedFromVUsd(user, address(token), amount, result, fee);\n return result;\n }"], "label": "Yes", "detail": "The attacker took out a 7.5 million BUSD flash loan, then made large deposits and swaps in the BUSD¨CvUSD and USDT¨CvUSD pools to manipulate exchange rates. They then swapped assets in the reverse direction to gain profits of approximately 550,000 BUSD before repaying the flash loan."}
{"project": "allbridge", "functions": ["function sendTokens(\n uint256 amount,\n bytes32 recipient,\n uint8 destinationChainId,\n bytes32 receiveToken,\n uint256 nonce,\n MessengerProtocol messenger\n ) internal override {\n uint8 sourceChainId = chainId; \n require(\n destinationChainId != sourceChainId,\n \"Bridge: wrong destination chain\"\n );\n require(\n otherBridgeTokens[destinationChainId][receiveToken],\n \"Bridge: unknown chain or token\"\n );\n bytes32 message = this.hashMessage(\n amount,\n recipient,\n sourceChainId,\n destinationChainId,\n receiveToken,\n nonce,\n messenger\n );\n bool wasMessageSent;\n assembly {\n mstore(0x00, message)\n mstore(0x20, sentMessages.slot)\n let key := keccak256(0, 0x40)\n wasMessageSent := sload(key)\n sstore(key, true)\n }\n require(!wasMessageSent, \"Bridge: tokens already sent\");\n uint256 bridgeTransactionCost = this.getTransactionCost(destinationChainId);\n uint256 messageTransactionCost = sendMessage(message, messenger);\n unchecked {\n require(\n msg.value >= bridgeTransactionCost + messageTransactionCost,\n \"Bridge: not enough fee\"\n );\n }\n emit TokensSent(\n amount,\n recipient,\n destinationChainId,\n receiveToken,\n nonce,\n messenger\n );\n }", "function receiveTokens(\n uint256 amount,\n bytes32 recipient,\n uint8 sourceChainId,\n bytes32 receiveToken,\n uint256 nonce,\n MessengerProtocol messenger\n ) external override {\n require(otherBridges[sourceChainId] != bytes32(0), \"Bridge: source not registered\");\n bytes32 messageWithSender = this.hashMessage(\n amount,\n recipient,\n sourceChainId,\n chainId,\n receiveToken,\n nonce,\n messenger\n ).hashWithSender(otherBridges[sourceChainId]);\n bool wasMessageProcessed;\n assembly {\n mstore(0x00, messageWithSender)\n mstore(0x20, processedMessages.slot)\n let key := keccak256(0, 0x40)\n wasMessageProcessed := sload(key)\n sstore(key, true)\n }\n require(!wasMessageProcessed, \"Bridge: message processed\");\n function hasReceivedMessage(...) {...}\nrequire(this.hasReceivedMessage(messageWithSender, messenger), \"Bridge: no message\");\n receiveAndSwap(\n amount,\n receiveToken,\n address(uint160(uint256(recipient)))\n );\n }", "function receiveAndSwap(uint256 vUsdAmount, bytes32 token, address recipient) internal {\n Pool tokenPool = pools[token];\n require(address(tokenPool) != address(0), \"Router: no pool\");\n function swapFromVUsd(...) {...}\ntokenPool.swapFromVUsd(recipient, vUsdAmount);\n }", "function swapFromVUsd(address user, uint256 amount) external onlyRouter returns (uint256) {\n uint256 result; \n uint256 fee;\n if (amount > 0) {\n vUsdBalance += amount;\n uint256 newAmount = this.getY(vUsdBalance);\n if (tokenBalance > newAmount) {\n result = fromSystemPrecision(tokenBalance - newAmount);\n } \n fee = result * feeShareBP / BP;\n \n unchecked {\n result -= fee;\n }\n tokenBalance = newAmount;\n function safeTransfer(...) {...}\nfunction _addRewards(...) {...}\ntoken.safeTransfer(user, result);\n _addRewards(fee);\n }\n emit SwappedFromVUsd(user, address(token), amount, result, fee);\n return result;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "anyswap", "functions": ["function depositWithPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns (uint) {\n function permit(...) {...}\nfunction safeTransferFrom(...) {...}\nIERC20(underlying).permit(target, address(this), value, deadline, v, r, s);\n IERC20(underlying).safeTransferFrom(target, address(this), value);\n return _deposit(value, to);\n }", "function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\n require(block.timestamp <= deadline, \"AnyswapV3ERC20: Expired permit\");\n bytes32 hashStruct = keccak256(\n abi.encode(\n PERMIT_TYPEHASH,\n target,\n spender,\n value,\n nonces[target]++,\n deadline));\n function verifyEIP712(...) {...}\nfunction verifyPersonalSign(...) {...}\nrequire(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));\n \n allowance[target][spender] = value;\n emit Approval(target, spender, value);\n }", "function _deposit(uint amount, address to) internal returns (uint) {\n require(underlying != address(0x0) && underlying != address(this));\n function _mint(...) {...}\n_mint(to, amount);\n return amount;\n }", "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _totalSupply += amount;\n balanceOf[account] += amount;\n emit Transfer(address(0), account, amount);\n }"], "label": "Yes", "detail": "The attacker exploited the fact that some tokens do not implement `permit()` but include a fallback function that silently accepts calls without reverting. By invoking `depositWithPermit`, the attacker could spoof the `target` (the victim address) and bypass approval checks because `permit()` succeeded trivially. Afterwards, `safeTransferFrom(target, ...)` would transfer tokens from the victim to the attacker-controlled contract. This is an authentication bypass in the cross-chain liquidity pool contract, allowing theft of user funds without a valid permit or signature."}
{"project": "anyswap", "functions": ["function anySwapOutUnderlyingWithPermit(\n address from,\n address token,\n address to,\n uint amount,\n uint deadline,\n uint8 v,\n bytes32 r,\n bytes32 s,\n uint toChainID\n ) external {\n address _underlying = AnyswapV1ERC20(token).underlying();\n IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n IERC20(_underlying).safeTransferFrom(from, token, amount);\n AnyswapV1ERC20(token).depositVault(amount, from);\n _anySwapOut(from, token, to, amount, toChainID);\n }", "function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n AnyswapV1ERC20(token).burn(from, amount);\n emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n }", "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _totalSupply += amount;\n balanceOf[account] += amount;\n emit Transfer(address(0), account, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "anyswap", "functions": ["func processRouterSwap(swap *mongodb.MgoSwap) (err error) {\n\tif router.IsChainIDPaused(swap.FromChainID) || router.IsChainIDPaused(swap.ToChainID) {\n\t\treturn errChainIsPaused\n\t}\n\tfromChainID := swap.FromChainID\n\ttoChainID := swap.ToChainID\n\ttxid := swap.TxID\n\tlogIndex := swap.LogIndex\n\tbind := swap.Bind\n\t\n\tif cachedSwapTasks.Contains(swap.Key) {\n\t\treturn errAlreadySwapped\n\t}\n\tif isBlacked(swap) {\n\t\tlogWorkerWarn(\"swap\", \"swap is in black list\", \"txid\", txid, \"logIndex\", logIndex, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"token\", swap.GetToken(), \"tokenID\", swap.GetTokenID())\n\t\terr = tokens.ErrSwapInBlacklist\n\t\t_ = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.SwapInBlacklist, now(), err.Error())\n\t\t_ = mongodb.UpdateRouterSwapResultStatus(fromChainID, txid, logIndex, mongodb.SwapInBlacklist, now(), err.Error())\n\t\treturn nil\n\t}\n\tres, err := mongodb.FindRouterSwapResult(fromChainID, txid, logIndex)\n\tif err != nil {\n\t\tif errors.Is(err, mongodb.ErrItemNotFound) {\n\t\t\t_ = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.TxNotStable, now(), \"\")\n\t\t}\n\t\treturn err\n\t}\n\tif strings.HasPrefix(res.Memo, tokens.ErrBuildTxErrorAndDelay.Error()) && res.Timestamp+300 > now() {\n\t\treturn nil\n\t}\n\tvar disagreeCount uint64\n\tcacheKey := mongodb.GetRouterSwapKey(fromChainID, txid, logIndex)\n\toldValue, exist := disagreeRecords.Load(cacheKey)\n\tif exist {\n\t\tdisagreeCount = oldValue.(uint64)\n\t}\n\tif disagreeCount > maxDisagreeCount {\n\t\tif res.Timestamp+disagreeWaitInterval > now() {\n\t\t\tlogWorkerTrace(\"swap\", \"disagree too many times\", \"txid\", txid, \"logIndex\", logIndex, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"token\", swap.GetToken(), \"tokenID\", swap.GetTokenID())\n\t\t\treturn nil\n\t\t}\n\t\tdisagreeRecords.Store(cacheKey, 0) \n\t}\n\tlogWorker(\"swap\", \"start process router swap\", \"fromChainID\", fromChainID, \"txid\", txid, \"logIndex\", logIndex, \"status\", swap.Status, \"value\", res.Value)\n\tdstBridge := router.GetBridgeByChainID(toChainID)\n\tif dstBridge == nil {\n\t\treturn tokens.ErrNoBridgeForChainID\n\t}\n\terr = preventReswap(res)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbiFromChainID, biToChainID, biValue, err := getFromToChainIDAndValue(fromChainID, toChainID, res.Value)\n\tif err != nil {\n\t\treturn err\n\t}\n\trouterMPC, err := router.GetRouterMPC(swap.GetTokenID(), toChainID)\n\tif err != nil {\n\t\treturn err\n\t}\n\targs := &tokens.BuildTxArgs{\n\t\tSwapArgs: tokens.SwapArgs{\n\t\t\tIdentifier: params.GetIdentifier(),\n\t\t\tSwapID: txid,\n\t\t\tSwapType: tokens.SwapType(swap.SwapType),\n\t\t\tBind: bind,\n\t\t\tLogIndex: swap.LogIndex,\n\t\t\tFromChainID: biFromChainID,\n\t\t\tToChainID: biToChainID,\n\t\t\tReswapping: res.Status == mongodb.Reswapping,\n\t\t},\n\t\tFrom: routerMPC,\n\t\tOriginFrom: swap.From,\n\t\tOriginTxTo: swap.TxTo,\n\t\tOriginValue: biValue,\n\t\tExtra: &tokens.AllExtras{},\n\t}\n\targs.SwapInfo, err = mongodb.ConvertFromSwapInfo(&res.SwapInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn dispatchSwapTask(args)\n}", "func dispatchSwapTask(args *tokens.BuildTxArgs) error {\n\tif !args.SwapType.IsValidType() {\n\t\treturn fmt.Errorf(\"unknown router swap type %d\", args.SwapType)\n\t}\n\tchainID := args.ToChainID.String()\n\ttaskQueue, exist := swapTaskQueues[chainID]\n\tif !exist {\n\t\tbridge := router.GetBridgeByChainID(chainID)\n\t\tif bridge == nil {\n\t\t\treturn tokens.ErrNoBridgeForChainID\n\t\t}\n\t\t\n\t\ttaskQueue = fifo.NewQueue()\n\t\tswapTaskQueues[chainID] = taskQueue\n\t\tmongodb.MgoWaitGroup.Add(1)\n\t\tgo startSwapConsumer(chainID)\n\t}\n\tlogWorker(\"doSwap\", \"dispatch router swap task\", \"fromChainID\", args.FromChainID, \"toChainID\", args.ToChainID, \"txid\", args.SwapID, \"logIndex\", args.LogIndex, \"value\", args.OriginValue, \"swapNonce\", args.GetTxNonce(), \"queue\", taskQueue.Len())\n\ttaskQueue.Add(args)\n\tcacheKey := mongodb.GetRouterSwapKey(args.FromChainID.String(), args.SwapID, args.LogIndex)\n\tswapTasksInQueue.Add(cacheKey)\n\treturn nil\n}", "func doSwap(args *tokens.BuildTxArgs) (err error) {\n\tif params.IsParallelSwapEnabled() {\n\t\treturn doSwapParallel(args)\n\t}\n\tfromChainID := args.FromChainID.String()\n\ttoChainID := args.ToChainID.String()\n\ttxid := args.SwapID\n\tlogIndex := args.LogIndex\n\toriginValue := args.OriginValue\n\tcacheKey := mongodb.GetRouterSwapKey(fromChainID, txid, logIndex)\n\terr = checkAndUpdateProcessSwapTaskCache(cacheKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogWorker(\"doSwap\", \"add swap cache\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\tisCachedSwapProcessed := false\n\tdefer func() {\n\t\tif !isCachedSwapProcessed {\n\t\t\tlogWorkerError(\"doSwap\", \"delete swap cache\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\t\t\tcachedSwapTasks.Remove(cacheKey)\n\t\t}\n\t}()\n\tlogWorker(\"doSwap\", \"start to process\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\tresBridge := router.GetBridgeByChainID(toChainID)\n\tif resBridge == nil {\n\t\treturn tokens.ErrNoBridgeForChainID\n\t}\n\tstart := time.Now()\n\trawTx, err := resBridge.BuildRawTransaction(args)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"build tx failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"timespent\", time.Since(start).String())\n\t\tif errors.Is(err, tokens.ErrBuildTxErrorAndDelay) {\n\t\t\t_ = updateSwapMemo(fromChainID, txid, logIndex, err.Error())\n\t\t}\n\t\treturn err\n\t}\n\tif args.SwapValue == nil {\n\t\treturn tokens.ErrNilSwapValue\n\t}\n\tswapTxNonce := args.GetTxNonce() \n\tlogWorker(\"doSwap\", \"build tx success\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\tstart = time.Now()\n\tsignedTx, txHash, err := resBridge.MPCSignTransaction(rawTx, args)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"sign tx failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"timespent\", time.Since(start).String())\n\t\tif errors.Is(err, mpc.ErrGetSignStatusHasDisagree) {\n\t\t\treverifySwap(args)\n\t\t}\n\t\treturn err\n\t}\n\tlogWorker(\"doSwap\", \"sign tx success\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"txHash\", txHash, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\tdisagreeRecords.Delete(cacheKey)\n\t\n\tres, err := mongodb.FindRouterSwapResult(fromChainID, txid, logIndex)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = preventReswap(res)\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n\taddSwapHistory(fromChainID, txid, logIndex, txHash)\n\tmatchTx := &MatchTx{\n\t\tSwapTx: txHash,\n\t\tSwapNonce: swapTxNonce,\n\t\tSwapValue: args.SwapValue.String(),\n\t\tMPC: args.From,\n\t}\n\tif args.Extra.TTL != nil {\n\t\tmatchTx.TTL = *args.Extra.TTL\n\t}\n\terr = updateRouterSwapResult(fromChainID, txid, logIndex, matchTx)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"update router swap result failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"swapNonce\", swapTxNonce)\n\t\treturn err\n\t}\n\tisCachedSwapProcessed = true\n\terr = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.TxProcessed, now(), \"\")\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"update router swap status failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex)\n\t\treturn err\n\t}\n\tstart = time.Now()\n\tsentTxHash, err := sendSignedTransaction(resBridge, signedTx, args)\n\tif err == nil && txHash != sentTxHash {\n\t\tlogWorkerError(\"doSwap\", \"send tx success but with different hash\", errSendTxWithDiffHash,\n\t\t\t\"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex,\n\t\t\t\"txHash\", txHash, \"sentTxHash\", sentTxHash, \"swapNonce\", swapTxNonce,\n\t\t\t\"timespent\", time.Since(start).String())\n\t\t_ = mongodb.UpdateRouterOldSwapTxs(fromChainID, txid, logIndex, sentTxHash)\n\t} else if err == nil {\n\t\tlogWorker(\"doSwap\", \"send tx success\",\n\t\t\t\"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex,\n\t\t\t\"txHash\", txHash, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\t}\n\tlogWorker(\"doSwap\", \"finish to process\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\treturn err\n}"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "anyswapv3", "functions": ["function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n AnyswapV3ERC20(token).burn(from, amount);\n emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n }", "function burn(address from, uint256 amount) external onlyVault returns (bool) {\n require(from != address(0), \"AnyswapV3ERC20: address(0x0)\");\n function _burn(...) {...}\n_burn(from, amount);\n return true;\n }", "function _burn(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: burn from the zero address\");\n balanceOf[account] -= amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }", "function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n AnyswapV3ERC20(token).mint(to, amount);\n emit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n }", "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _totalSupply += amount;\n balanceOf[account] += amount;\n emit Transfer(address(0), account, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "anyswapv3", "functions": ["func PutPreSign(pub string, val *PrePubData) {\n\tif val == nil {\n\t\treturn\n\t}\n\tdata, exsit := PreSignData.ReadMap(strings.ToLower(pub))\n\tif exsit {\n\t\tdatas := data.([]*PrePubData)\n\t\t\n\t\tfor _, v := range datas {\n\t\t\tif v != nil && strings.EqualFold(v.Key, val.Key) {\n\t\t\t\tcommon.Debug(\"========================PutPreSign,already have this key==================\", \"pub\", pub, \"key\", v.Key)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t\n\t\tdatas = append(datas, val)\n\t\tPreSignData.WriteMap(strings.ToLower(pub), datas)\n\t\treturn\n\t}\n\tdatas := make([]*PrePubData, 0)\n\tdatas = append(datas, val)\n\tPreSignData.WriteMap(strings.ToLower(pub), datas)\n}"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "anyswapv3", "functions": ["func processRouterSwap(swap *mongodb.MgoSwap) (err error) {\n\tif router.IsChainIDPaused(swap.FromChainID) || router.IsChainIDPaused(swap.ToChainID) {\n\t\treturn errChainIsPaused\n\t}\n\tfromChainID := swap.FromChainID\n\ttoChainID := swap.ToChainID\n\ttxid := swap.TxID\n\tlogIndex := swap.LogIndex\n\tbind := swap.Bind\n\t\n\tif cachedSwapTasks.Contains(swap.Key) {\n\t\treturn errAlreadySwapped\n\t}\n\tif isBlacked(swap) {\n\t\tlogWorkerWarn(\"swap\", \"swap is in black list\", \"txid\", txid, \"logIndex\", logIndex, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"token\", swap.GetToken(), \"tokenID\", swap.GetTokenID())\n\t\terr = tokens.ErrSwapInBlacklist\n\t\t_ = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.SwapInBlacklist, now(), err.Error())\n\t\t_ = mongodb.UpdateRouterSwapResultStatus(fromChainID, txid, logIndex, mongodb.SwapInBlacklist, now(), err.Error())\n\t\treturn nil\n\t}\n\tres, err := mongodb.FindRouterSwapResult(fromChainID, txid, logIndex)\n\tif err != nil {\n\t\tif errors.Is(err, mongodb.ErrItemNotFound) {\n\t\t\t_ = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.TxNotStable, now(), \"\")\n\t\t}\n\t\treturn err\n\t}\n\tif strings.HasPrefix(res.Memo, tokens.ErrBuildTxErrorAndDelay.Error()) && res.Timestamp+300 > now() {\n\t\treturn nil\n\t}\n\tvar disagreeCount uint64\n\tcacheKey := mongodb.GetRouterSwapKey(fromChainID, txid, logIndex)\n\toldValue, exist := disagreeRecords.Load(cacheKey)\n\tif exist {\n\t\tdisagreeCount = oldValue.(uint64)\n\t}\n\tif disagreeCount > maxDisagreeCount {\n\t\tif res.Timestamp+disagreeWaitInterval > now() {\n\t\t\tlogWorkerTrace(\"swap\", \"disagree too many times\", \"txid\", txid, \"logIndex\", logIndex, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"token\", swap.GetToken(), \"tokenID\", swap.GetTokenID())\n\t\t\treturn nil\n\t\t}\n\t\tdisagreeRecords.Store(cacheKey, 0) \n\t}\n\tlogWorker(\"swap\", \"start process router swap\", \"fromChainID\", fromChainID, \"txid\", txid, \"logIndex\", logIndex, \"status\", swap.Status, \"value\", res.Value)\n\tdstBridge := router.GetBridgeByChainID(toChainID)\n\tif dstBridge == nil {\n\t\treturn tokens.ErrNoBridgeForChainID\n\t}\n\terr = preventReswap(res)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbiFromChainID, biToChainID, biValue, err := getFromToChainIDAndValue(fromChainID, toChainID, res.Value)\n\tif err != nil {\n\t\treturn err\n\t}\n\trouterMPC, err := router.GetRouterMPC(swap.GetTokenID(), toChainID)\n\tif err != nil {\n\t\treturn err\n\t}\n\targs := &tokens.BuildTxArgs{\n\t\tSwapArgs: tokens.SwapArgs{\n\t\t\tIdentifier: params.GetIdentifier(),\n\t\t\tSwapID: txid,\n\t\t\tSwapType: tokens.SwapType(swap.SwapType),\n\t\t\tBind: bind,\n\t\t\tLogIndex: swap.LogIndex,\n\t\t\tFromChainID: biFromChainID,\n\t\t\tToChainID: biToChainID,\n\t\t\tReswapping: res.Status == mongodb.Reswapping,\n\t\t},\n\t\tFrom: routerMPC,\n\t\tOriginFrom: swap.From,\n\t\tOriginTxTo: swap.TxTo,\n\t\tOriginValue: biValue,\n\t\tExtra: &tokens.AllExtras{},\n\t}\n\targs.SwapInfo, err = mongodb.ConvertFromSwapInfo(&res.SwapInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn dispatchSwapTask(args)\n}", "func dispatchSwapTask(args *tokens.BuildTxArgs) error {\n\tif !args.SwapType.IsValidType() {\n\t\treturn fmt.Errorf(\"unknown router swap type %d\", args.SwapType)\n\t}\n\tchainID := args.ToChainID.String()\n\ttaskQueue, exist := swapTaskQueues[chainID]\n\tif !exist {\n\t\tbridge := router.GetBridgeByChainID(chainID)\n\t\tif bridge == nil {\n\t\t\treturn tokens.ErrNoBridgeForChainID\n\t\t}\n\t\t\n\t\ttaskQueue = fifo.NewQueue()\n\t\tswapTaskQueues[chainID] = taskQueue\n\t\tmongodb.MgoWaitGroup.Add(1)\n\t\tgo startSwapConsumer(chainID)\n\t}\n\tlogWorker(\"doSwap\", \"dispatch router swap task\", \"fromChainID\", args.FromChainID, \"toChainID\", args.ToChainID, \"txid\", args.SwapID, \"logIndex\", args.LogIndex, \"value\", args.OriginValue, \"swapNonce\", args.GetTxNonce(), \"queue\", taskQueue.Len())\n\ttaskQueue.Add(args)\n\tcacheKey := mongodb.GetRouterSwapKey(args.FromChainID.String(), args.SwapID, args.LogIndex)\n\tswapTasksInQueue.Add(cacheKey)\n\treturn nil\n}", "func doSwap(args *tokens.BuildTxArgs) (err error) {\n\tif params.IsParallelSwapEnabled() {\n\t\treturn doSwapParallel(args)\n\t}\n\tfromChainID := args.FromChainID.String()\n\ttoChainID := args.ToChainID.String()\n\ttxid := args.SwapID\n\tlogIndex := args.LogIndex\n\toriginValue := args.OriginValue\n\tcacheKey := mongodb.GetRouterSwapKey(fromChainID, txid, logIndex)\n\terr = checkAndUpdateProcessSwapTaskCache(cacheKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogWorker(\"doSwap\", \"add swap cache\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\tisCachedSwapProcessed := false\n\tdefer func() {\n\t\tif !isCachedSwapProcessed {\n\t\t\tlogWorkerError(\"doSwap\", \"delete swap cache\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\t\t\tcachedSwapTasks.Remove(cacheKey)\n\t\t}\n\t}()\n\tlogWorker(\"doSwap\", \"start to process\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\tresBridge := router.GetBridgeByChainID(toChainID)\n\tif resBridge == nil {\n\t\treturn tokens.ErrNoBridgeForChainID\n\t}\n\tstart := time.Now()\n\trawTx, err := resBridge.BuildRawTransaction(args)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"build tx failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"timespent\", time.Since(start).String())\n\t\tif errors.Is(err, tokens.ErrBuildTxErrorAndDelay) {\n\t\t\t_ = updateSwapMemo(fromChainID, txid, logIndex, err.Error())\n\t\t}\n\t\treturn err\n\t}\n\tif args.SwapValue == nil {\n\t\treturn tokens.ErrNilSwapValue\n\t}\n\tswapTxNonce := args.GetTxNonce() \n\tlogWorker(\"doSwap\", \"build tx success\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\tstart = time.Now()\n\tsignedTx, txHash, err := resBridge.MPCSignTransaction(rawTx, args)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"sign tx failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"timespent\", time.Since(start).String())\n\t\tif errors.Is(err, mpc.ErrGetSignStatusHasDisagree) {\n\t\t\treverifySwap(args)\n\t\t}\n\t\treturn err\n\t}\n\tlogWorker(\"doSwap\", \"sign tx success\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"txHash\", txHash, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\tdisagreeRecords.Delete(cacheKey)\n\t\n\tres, err := mongodb.FindRouterSwapResult(fromChainID, txid, logIndex)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = preventReswap(res)\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n\taddSwapHistory(fromChainID, txid, logIndex, txHash)\n\tmatchTx := &MatchTx{\n\t\tSwapTx: txHash,\n\t\tSwapNonce: swapTxNonce,\n\t\tSwapValue: args.SwapValue.String(),\n\t\tMPC: args.From,\n\t}\n\tif args.Extra.TTL != nil {\n\t\tmatchTx.TTL = *args.Extra.TTL\n\t}\n\terr = updateRouterSwapResult(fromChainID, txid, logIndex, matchTx)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"update router swap result failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"swapNonce\", swapTxNonce)\n\t\treturn err\n\t}\n\tisCachedSwapProcessed = true\n\terr = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.TxProcessed, now(), \"\")\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"update router swap status failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex)\n\t\treturn err\n\t}\n\tstart = time.Now()\n\tsentTxHash, err := sendSignedTransaction(resBridge, signedTx, args)\n\tif err == nil && txHash != sentTxHash {\n\t\tlogWorkerError(\"doSwap\", \"send tx success but with different hash\", errSendTxWithDiffHash,\n\t\t\t\"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex,\n\t\t\t\"txHash\", txHash, \"sentTxHash\", sentTxHash, \"swapNonce\", swapTxNonce,\n\t\t\t\"timespent\", time.Since(start).String())\n\t\t_ = mongodb.UpdateRouterOldSwapTxs(fromChainID, txid, logIndex, sentTxHash)\n\t} else if err == nil {\n\t\tlogWorker(\"doSwap\", \"send tx success\",\n\t\t\t\"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex,\n\t\t\t\"txHash\", txHash, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\t}\n\tlogWorker(\"doSwap\", \"finish to process\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\treturn err\n}"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "anyswapv4", "functions": ["function anySwapOutUnderlyingWithPermit(\n address from,\n address token,\n address to,\n uint amount,\n uint deadline,\n uint8 v,\n bytes32 r,\n bytes32 s,\n uint toChainID\n ) external {\n address _underlying = AnyswapV1ERC20(token).underlying();\n IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n function safeTransferFrom(...) {...}\nfunction _anySwapOut(...) {...}\nTransferHelper.safeTransferFrom(_underlying, from, token, amount);\n AnyswapV1ERC20(token).depositVault(amount, from);\n _anySwapOut(from, token, to, amount, toChainID);\n }", "function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\n require(block.timestamp <= deadline, \"AnyswapV3ERC20: Expired permit\");\n bytes32 hashStruct = keccak256(\n abi.encode(\n PERMIT_TYPEHASH,\n target,\n spender,\n value,\n nonces[target]++,\n deadline));\n function verifyEIP712(...) {...}\nfunction verifyPersonalSign(...) {...}\nrequire(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));\n \n allowance[target][spender] = value;\n emit Approval(target, spender, value);\n }", "function safeTransferFrom(address token, address from, address to, uint value) internal {\n \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n }", "function _deposit(uint amount, address to) internal returns (uint) {\n require(underlying != address(0x0) && underlying != address(this));\n _mint(to, amount);\n return amount;\n }", "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _totalSupply += amount;\n balanceOf[account] += amount;\n emit Transfer(address(0), account, amount);\n }", "function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n AnyswapV1ERC20(token).burn(from, amount);\n emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n }", "function burn(address from, uint256 amount) external onlyAuth returns (bool) {\n require(from != address(0), \"AnyswapV3ERC20: address(0x0)\");\n function _burn(...) {...}\n_burn(from, amount);\n return true;\n }", "function _burn(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: burn from the zero address\");\n balanceOf[account] -= amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }"], "label": "Yes", "detail": "On February 15, 2023, the AnyswapV4Router contract of Multichain was exploited via a frontrunning MEV bot. The attacker used a crafted transaction to call the anySwapOutUnderlyingWithPermit function before a legitimate user's transaction could execute. The function assumed the underlying token (WETH) supported the ERC-2612 permit interface, but WETH lacked the permit method. Consequently, the fallback deposit function was triggered instead of validating the signature. The attacker then successfully used safeTransferFrom to transfer the WETH to their own address without proper authorization, gaining approximately 87 ETH (~$130,000)."}
{"project": "anyswapv4", "functions": ["function burn(address from, uint256 amount) external onlyAuth returns (bool) {\n require(from != address(0), \"AnyswapV3ERC20: address(0x0)\");\n function _burn(...) {...}\n_burn(from, amount);\n return true;\n }", "function _burn(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: burn from the zero address\");\n balanceOf[account] -= amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }", "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _totalSupply += amount;\n balanceOf[account] += amount;\n emit Transfer(address(0), account, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "anyswapv4", "functions": ["func processRouterSwap(swap *mongodb.MgoSwap) (err error) {\n\tif router.IsChainIDPaused(swap.FromChainID) || router.IsChainIDPaused(swap.ToChainID) {\n\t\treturn errChainIsPaused\n\t}\n\tfromChainID := swap.FromChainID\n\ttoChainID := swap.ToChainID\n\ttxid := swap.TxID\n\tlogIndex := swap.LogIndex\n\tbind := swap.Bind\n\t\n\tif cachedSwapTasks.Contains(swap.Key) {\n\t\treturn errAlreadySwapped\n\t}\n\tif isBlacked(swap) {\n\t\tlogWorkerWarn(\"swap\", \"swap is in black list\", \"txid\", txid, \"logIndex\", logIndex, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"token\", swap.GetToken(), \"tokenID\", swap.GetTokenID())\n\t\terr = tokens.ErrSwapInBlacklist\n\t\t_ = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.SwapInBlacklist, now(), err.Error())\n\t\t_ = mongodb.UpdateRouterSwapResultStatus(fromChainID, txid, logIndex, mongodb.SwapInBlacklist, now(), err.Error())\n\t\treturn nil\n\t}\n\tres, err := mongodb.FindRouterSwapResult(fromChainID, txid, logIndex)\n\tif err != nil {\n\t\tif errors.Is(err, mongodb.ErrItemNotFound) {\n\t\t\t_ = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.TxNotStable, now(), \"\")\n\t\t}\n\t\treturn err\n\t}\n\tif strings.HasPrefix(res.Memo, tokens.ErrBuildTxErrorAndDelay.Error()) && res.Timestamp+300 > now() {\n\t\treturn nil\n\t}\n\tvar disagreeCount uint64\n\tcacheKey := mongodb.GetRouterSwapKey(fromChainID, txid, logIndex)\n\toldValue, exist := disagreeRecords.Load(cacheKey)\n\tif exist {\n\t\tdisagreeCount = oldValue.(uint64)\n\t}\n\tif disagreeCount > maxDisagreeCount {\n\t\tif res.Timestamp+disagreeWaitInterval > now() {\n\t\t\tlogWorkerTrace(\"swap\", \"disagree too many times\", \"txid\", txid, \"logIndex\", logIndex, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"token\", swap.GetToken(), \"tokenID\", swap.GetTokenID())\n\t\t\treturn nil\n\t\t}\n\t\tdisagreeRecords.Store(cacheKey, 0) \n\t}\n\tlogWorker(\"swap\", \"start process router swap\", \"fromChainID\", fromChainID, \"txid\", txid, \"logIndex\", logIndex, \"status\", swap.Status, \"value\", res.Value)\n\tdstBridge := router.GetBridgeByChainID(toChainID)\n\tif dstBridge == nil {\n\t\treturn tokens.ErrNoBridgeForChainID\n\t}\n\terr = preventReswap(res)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbiFromChainID, biToChainID, biValue, err := getFromToChainIDAndValue(fromChainID, toChainID, res.Value)\n\tif err != nil {\n\t\treturn err\n\t}\n\trouterMPC, err := router.GetRouterMPC(swap.GetTokenID(), toChainID)\n\tif err != nil {\n\t\treturn err\n\t}\n\targs := &tokens.BuildTxArgs{\n\t\tSwapArgs: tokens.SwapArgs{\n\t\t\tIdentifier: params.GetIdentifier(),\n\t\t\tSwapID: txid,\n\t\t\tSwapType: tokens.SwapType(swap.SwapType),\n\t\t\tBind: bind,\n\t\t\tLogIndex: swap.LogIndex,\n\t\t\tFromChainID: biFromChainID,\n\t\t\tToChainID: biToChainID,\n\t\t\tReswapping: res.Status == mongodb.Reswapping,\n\t\t},\n\t\tFrom: routerMPC,\n\t\tOriginFrom: swap.From,\n\t\tOriginTxTo: swap.TxTo,\n\t\tOriginValue: biValue,\n\t\tExtra: &tokens.AllExtras{},\n\t}\n\targs.SwapInfo, err = mongodb.ConvertFromSwapInfo(&res.SwapInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn dispatchSwapTask(args)\n}", "func dispatchSwapTask(args *tokens.BuildTxArgs) error {\n\tif !args.SwapType.IsValidType() {\n\t\treturn fmt.Errorf(\"unknown router swap type %d\", args.SwapType)\n\t}\n\tchainID := args.ToChainID.String()\n\ttaskQueue, exist := swapTaskQueues[chainID]\n\tif !exist {\n\t\tbridge := router.GetBridgeByChainID(chainID)\n\t\tif bridge == nil {\n\t\t\treturn tokens.ErrNoBridgeForChainID\n\t\t}\n\t\t\n\t\ttaskQueue = fifo.NewQueue()\n\t\tswapTaskQueues[chainID] = taskQueue\n\t\tmongodb.MgoWaitGroup.Add(1)\n\t\tgo startSwapConsumer(chainID)\n\t}\n\tlogWorker(\"doSwap\", \"dispatch router swap task\", \"fromChainID\", args.FromChainID, \"toChainID\", args.ToChainID, \"txid\", args.SwapID, \"logIndex\", args.LogIndex, \"value\", args.OriginValue, \"swapNonce\", args.GetTxNonce(), \"queue\", taskQueue.Len())\n\ttaskQueue.Add(args)\n\tcacheKey := mongodb.GetRouterSwapKey(args.FromChainID.String(), args.SwapID, args.LogIndex)\n\tswapTasksInQueue.Add(cacheKey)\n\treturn nil\n}", "func doSwap(args *tokens.BuildTxArgs) (err error) {\n\tif params.IsParallelSwapEnabled() {\n\t\treturn doSwapParallel(args)\n\t}\n\tfromChainID := args.FromChainID.String()\n\ttoChainID := args.ToChainID.String()\n\ttxid := args.SwapID\n\tlogIndex := args.LogIndex\n\toriginValue := args.OriginValue\n\tcacheKey := mongodb.GetRouterSwapKey(fromChainID, txid, logIndex)\n\terr = checkAndUpdateProcessSwapTaskCache(cacheKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogWorker(\"doSwap\", \"add swap cache\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\tisCachedSwapProcessed := false\n\tdefer func() {\n\t\tif !isCachedSwapProcessed {\n\t\t\tlogWorkerError(\"doSwap\", \"delete swap cache\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\t\t\tcachedSwapTasks.Remove(cacheKey)\n\t\t}\n\t}()\n\tlogWorker(\"doSwap\", \"start to process\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\tresBridge := router.GetBridgeByChainID(toChainID)\n\tif resBridge == nil {\n\t\treturn tokens.ErrNoBridgeForChainID\n\t}\n\tstart := time.Now()\n\trawTx, err := resBridge.BuildRawTransaction(args)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"build tx failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"timespent\", time.Since(start).String())\n\t\tif errors.Is(err, tokens.ErrBuildTxErrorAndDelay) {\n\t\t\t_ = updateSwapMemo(fromChainID, txid, logIndex, err.Error())\n\t\t}\n\t\treturn err\n\t}\n\tif args.SwapValue == nil {\n\t\treturn tokens.ErrNilSwapValue\n\t}\n\tswapTxNonce := args.GetTxNonce() \n\tlogWorker(\"doSwap\", \"build tx success\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\tstart = time.Now()\n\tsignedTx, txHash, err := resBridge.MPCSignTransaction(rawTx, args)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"sign tx failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"timespent\", time.Since(start).String())\n\t\tif errors.Is(err, mpc.ErrGetSignStatusHasDisagree) {\n\t\t\treverifySwap(args)\n\t\t}\n\t\treturn err\n\t}\n\tlogWorker(\"doSwap\", \"sign tx success\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"txHash\", txHash, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\tdisagreeRecords.Delete(cacheKey)\n\t\n\tres, err := mongodb.FindRouterSwapResult(fromChainID, txid, logIndex)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = preventReswap(res)\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n\taddSwapHistory(fromChainID, txid, logIndex, txHash)\n\tmatchTx := &MatchTx{\n\t\tSwapTx: txHash,\n\t\tSwapNonce: swapTxNonce,\n\t\tSwapValue: args.SwapValue.String(),\n\t\tMPC: args.From,\n\t}\n\tif args.Extra.TTL != nil {\n\t\tmatchTx.TTL = *args.Extra.TTL\n\t}\n\terr = updateRouterSwapResult(fromChainID, txid, logIndex, matchTx)\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"update router swap result failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"swapNonce\", swapTxNonce)\n\t\treturn err\n\t}\n\tisCachedSwapProcessed = true\n\terr = mongodb.UpdateRouterSwapStatus(fromChainID, txid, logIndex, mongodb.TxProcessed, now(), \"\")\n\tif err != nil {\n\t\tlogWorkerError(\"doSwap\", \"update router swap status failed\", err, \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex)\n\t\treturn err\n\t}\n\tstart = time.Now()\n\tsentTxHash, err := sendSignedTransaction(resBridge, signedTx, args)\n\tif err == nil && txHash != sentTxHash {\n\t\tlogWorkerError(\"doSwap\", \"send tx success but with different hash\", errSendTxWithDiffHash,\n\t\t\t\"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex,\n\t\t\t\"txHash\", txHash, \"sentTxHash\", sentTxHash, \"swapNonce\", swapTxNonce,\n\t\t\t\"timespent\", time.Since(start).String())\n\t\t_ = mongodb.UpdateRouterOldSwapTxs(fromChainID, txid, logIndex, sentTxHash)\n\t} else if err == nil {\n\t\tlogWorker(\"doSwap\", \"send tx success\",\n\t\t\t\"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex,\n\t\t\t\"txHash\", txHash, \"swapNonce\", swapTxNonce, \"timespent\", time.Since(start).String())\n\t}\n\tlogWorker(\"doSwap\", \"finish to process\", \"fromChainID\", fromChainID, \"toChainID\", toChainID, \"txid\", txid, \"logIndex\", logIndex, \"value\", originValue)\n\treturn err\n}"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Chainswap", "functions": ["function _sendFrom(address from, uint volume) virtual override internal {\n function safeTransferFrom(...) {...}\nIERC20(token).safeTransferFrom(from, address(this), volume);\n }", "function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n _chargeFee();\n require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n uint N = signatures.length;\n function getConfig(...) {...}\nrequire(N >= MappingTokenFactory(factory).getConfig(_minSignatures_), 'too few signatures');\n for(uint i=0; i<N; i++) {\n for(uint j=0; j<i; j++)\n require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _DOMAIN_SEPARATOR, structHash));\n address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n require(signatory != address(0), \"invalid signature\");\n require(signatory == signatures[i].signatory, \"unauthorized\");\n _decreaseAuthQuota(signatures[i].signatory, volume);\n emit Authorize(fromChainId, to, nonce, volume, signatory);\n }\n received[fromChainId][to][nonce] = volume;\n _receive(to, volume);\n emit Receive(fromChainId, to, nonce, volume);\n }"], "label": "Yes", "detail": "The receive function of the Chainswap contract failed to properly validate the signatory field of incoming signatures. By supplying a forged signatory, an attacker was able to bypass the authorization process. Due to the absence of mapping key validation in Solidity, the system calculated an unreasonably high quota for the forged signatory, enabling the attacker to mint and withdraw unauthorized funds. The root cause is improper validation of mapping-based access control. Additionally, the platform had reduced the required number of signatures to 1 prior to the attack, making exploitation easier."}
{"project": "EvoDeFi", "functions": ["function deposit(uint256 _pid, uint256 _amount) public {\n PoolInfo storage pool = poolInfo[_pid];\n UserInfo storage user = userInfo[_pid][msg.sender];\n function updatePool(...) {...}\nfunction updatePower(...) {...}\nupdatePool(_pid);\n claim(_pid);\n if(_amount > 0) {\n pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n if(pool.depositFeeBP > 0){\n uint256 depositFee = _amount.mul(pool.depositFeeBP).div(10000);\n pool.lpToken.safeTransfer(feeAddress, depositFee);\n user.amount = user.amount.add(_amount).sub(depositFee);\n }else{\n user.amount = user.amount.add(_amount);\n }\n }\n updatePower(_pid);\n user.rewardDebt = user.power.mul(pool.accGenPerPower).div(1e12);\n emit Deposit(msg.sender, _pid, _amount);\n }", "function updatePool(uint256 _pid) public {\n PoolInfo storage pool = poolInfo[_pid];\n if (block.number <= pool.lastRewardBlock) {\n return;\n }\n if (pool.totalPower == 0 || pool.allocPoint == 0) {\n pool.lastRewardBlock = block.number;\n return;\n }\n uint256 blockAmount = block.number.sub(pool.lastRewardBlock);\n uint256 genReward = blockAmount.mul(genPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n gen.mint(devaddr, genReward.div(10));\n gen.mint(address(this), genReward);\n pool.accGenPerPower = pool.accGenPerPower.add(genReward.mul(1e12).div(pool.totalPower));\n pool.lastRewardBlock = block.number;\n }", "function updatePower(uint256 _pid) public {\n PoolInfo storage pool = poolInfo[_pid];\n UserInfo storage user = userInfo[_pid][msg.sender];\n uint256 currentPower = user.power;\n uint powerBonus = 100;\n if (user.lastPoweredBlock >= block.number) {\n powerBonus += proxy.getNFTPowerBonus();\n }\n powerBonus += proxy.bonus(msg.sender);\n user.power = user.amount.mul(powerBonus).div(100);\n pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n }", "function withdraw(uint256 _pid, uint256 _amount) public {\n PoolInfo storage pool = poolInfo[_pid];\n UserInfo storage user = userInfo[_pid][msg.sender];\n require(user.amount >= _amount, \"withdraw: not good\");\n function updatePool(...) {...}\nfunction claim(...) {...}\nupdatePool(_pid);\n claim(_pid);\n if (_amount > 0) {\n user.amount = user.amount.sub(_amount);\n pool.lpToken.safeTransfer(address(msg.sender), _amount);\n }\n updatePower(_pid);\n user.rewardDebt = user.power.mul(pool.accGenPerPower).div(1e12);\n emit Withdraw(msg.sender, _pid, _amount);\n }", "function updatePool(uint256 _pid) public {\n PoolInfo storage pool = poolInfo[_pid];\n if (block.number <= pool.lastRewardBlock) {\n return;\n }\n if (pool.totalPower == 0 || pool.allocPoint == 0) {\n pool.lastRewardBlock = block.number;\n return;\n }\n uint256 blockAmount = block.number.sub(pool.lastRewardBlock);\n uint256 genReward = blockAmount.mul(genPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n gen.mint(devaddr, genReward.div(10));\n gen.mint(address(this), genReward);\n pool.accGenPerPower = pool.accGenPerPower.add(genReward.mul(1e12).div(pool.totalPower));\n pool.lastRewardBlock = block.number;\n }", "function updatePower(uint256 _pid) public {\n PoolInfo storage pool = poolInfo[_pid];\n UserInfo storage user = userInfo[_pid][msg.sender];\n uint256 currentPower = user.power;\n uint powerBonus = 100;\n if (user.lastPoweredBlock >= block.number) {\n powerBonus += proxy.getNFTPowerBonus();\n }\n powerBonus += proxy.bonus(msg.sender);\n user.power = user.amount.mul(powerBonus).div(100);\n pool.totalPower = pool.totalPower.add(user.power).sub(currentPower);\n }"], "label": "Yes", "detail": "The incident occurred because updatePower did not update rewardDebt after changing power, permitting attackers to repeatedly claim rewards by manipulating the calling sequence. This flaw led to reward inflation and economic loss."}
{"project": "EvoDeFi", "functions": ["function deposit(IERC20 token, uint amount, uint8 to, bool bonus, bytes calldata recipient) override external payable nonReentrant() {\n \n require(tx.origin == msg.sender || (operator[msg.sender] & (1 | 2) > 0), 'call from unauthorized contract');\n require(address(token) != address(0) && amount > 0 && recipient.length > 0, 'invalid input');\n if (address(token) == address(1)) {\n require(amount == msg.value, 'value must equal amount');\n } else {\n function safeTransferFrom(...) {...}\nsafeTransferFrom(token, msg.sender, address(this), amount);\n }\n emit Deposited(msg.sender, address(token), to, amount, bonus, recipient);\n }", "function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'transfer failed');\n }", "function withdraw(Withdraw[] calldata ws) override external nonReentrant() {\n \n require(operator[msg.sender] == 4 || (operator[tx.origin] == 4 && operator[msg.sender] == 2), 'forbidden');\n for (uint i = 0; i < ws.length; i++) {\n Withdraw memory w = ws[i];\n require(!withdrawn[w.id], 'already withdrawn');\n withdrawn[w.id] = true;\n if (address(w.token) == address(1)) {\n require(address(this).balance >= w.amount + w.bonus, 'too low token balance');\n (bool success, ) = w.recipient.call{value: w.amount}('');\n require(success, 'native transfer error');\n } else {\n require(\n w.token.balanceOf(address(this)) >= w.amount && address(this).balance >= w.bonus,\n 'too low token balance'\n );\n function safeTransfer(...) {...}\nsafeTransfer(w.token, w.recipient, w.amount);\n }\n if (w.bonus > 0) {\n \n w.recipient.call{value: w.bonus}('');\n }\n if (address(w.token) != address(1) && w.feeAmounts.length > 0) {\n for (uint j = 0; j < w.feeAmounts.length; j++) {\n require(w.token.balanceOf(address(this)) >= w.feeAmounts[j], 'too low token balance');\n safeTransfer(w.token, w.feeTargets[j], w.feeAmounts[j]);\n }\n }\n emit Withdrawn(w.id, address(w.token), w.recipient, w.amount);\n }\n }", "function safeTransfer(IERC20 token, address to, uint256 value) internal {\n (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(token.transfer.selector, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'transfer failed');\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Lifinance", "functions": ["function swapAndStartBridgeTokensViaCBridge(\n LiFiData memory _lifiData,\n LibSwap.SwapData[] calldata _swapData,\n CBridgeData memory _cBridgeData\n ) public payable {\n if (_cBridgeData.token != address(0)) {\n uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n \n for (uint8 i; i < _swapData.length; i++) {\n LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n }\n uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n _cBridgeData.amount = _postSwapBalance;\n } else {\n uint256 _fromBalance = address(this).balance;\n \n for (uint8 i; i < _swapData.length; i++) {\n LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n }\n uint256 _postSwapBalance = address(this).balance - _fromBalance;\n require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n _cBridgeData.amount = _postSwapBalance;\n }\n _startBridge(_cBridgeData);\n emit LiFiTransferStarted(\n _lifiData.transactionId,\n _lifiData.integrator,\n _lifiData.referrer,\n _lifiData.sendingAssetId,\n _lifiData.receivingAssetId,\n _lifiData.receiver,\n _lifiData.amount,\n _lifiData.destinationChainId,\n block.timestamp\n );\n }", "function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n uint256 fromAmount = _swapData.fromAmount;\n uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n address fromAssetId = _swapData.sendingAssetId;\n if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);\n }\n if (!LibAsset.isNativeAsset(fromAssetId)) {\n LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n }\n \n (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n if (!success) {\n string memory reason = LibUtil.getRevertMsg(res);\n revert(reason);\n }\n toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n emit AssetSwapped(\n transactionId,\n _swapData.callTo,\n _swapData.sendingAssetId,\n _swapData.receivingAssetId,\n fromAmount,\n toAmount,\n block.timestamp\n );\n }", "function _startBridge(CBridgeData memory _cBridgeData) internal {\n Storage storage s = getStorage();\n address bridge = _bridge();\n \n require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n ICBridge(bridge).sendNative(\n _cBridgeData.receiver,\n _cBridgeData.amount,\n _cBridgeData.dstChainId,\n _cBridgeData.nonce,\n _cBridgeData.maxSlippage\n );\n } else {\n \n LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n \n ICBridge(bridge).send(\n _cBridgeData.receiver,\n _cBridgeData.token,\n _cBridgeData.amount,\n _cBridgeData.dstChainId,\n _cBridgeData.nonce,\n _cBridgeData.maxSlippage\n );\n }\n }", "function send(\n address _receiver,\n address _token,\n uint256 _amount,\n uint64 _dstChainId,\n uint64 _nonce,\n uint32 _maxSlippage \n ) external nonReentrant whenNotPaused {\n bytes32 transferId = _send(_receiver, _token, _amount, _dstChainId, _nonce, _maxSlippage);\n IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n emit Send(transferId, msg.sender, _receiver, _token, _amount, _dstChainId, _nonce, _maxSlippage);\n }", "function _send(\n address _receiver,\n address _token,\n uint256 _amount,\n uint64 _dstChainId,\n uint64 _nonce,\n uint32 _maxSlippage\n ) private returns (bytes32) {\n require(_amount > minSend[_token], \"amount too small\");\n require(maxSend[_token] == 0 || _amount <= maxSend[_token], \"amount too large\");\n require(_maxSlippage > minimalMaxSlippage, \"max slippage too small\");\n bytes32 transferId = keccak256(\n \n \n abi.encodePacked(msg.sender, _receiver, _token, _amount, _dstChainId, _nonce, uint64(block.chainid))\n );\n require(transfers[transferId] == false, \"transfer exists\");\n transfers[transferId] = true;\n return transferId;\n }"], "label": "Yes", "detail": "The attacker crafted a payload where the first element performs a small legitimate swap to pass the function's flow, while subsequent entries invoke transferFrom calls directly¡ªleveraging users' infinite token approvals to siphon assets from multiple wallets. After draining funds, the contract continues normal bridge execution (_startBridge) to avoid transaction failure. The root cause is swapAndStartBridgeTokensViaCBridge allowing arbitrary call execution via LibSwap.swap() without any parameter validation or restrictions."}
{"project": "meter", "functions": ["function deposit(\n bytes32 resourceID,\n uint8 destinationChainID,\n uint64 depositNonce,\n address depositer,\n bytes calldata data\n ) external override onlyBridge {\n bytes memory recipientAddress;\n uint256 amount;\n uint256 lenRecipientAddress;\n assembly {\n amount := calldataload(0xC4)\n recipientAddress := mload(0x40)\n lenRecipientAddress := calldataload(0xE4)\n mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))\n calldatacopy(\n recipientAddress, \n 0xE4, \n sub(calldatasize(), 0xE) \n )\n }\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress != _wtokenAddress) {\n if (_burnList[tokenAddress]) {\n function burnERC20(...) {...}\nfunction lockERC20(...) {...}\nburnERC20(tokenAddress, depositer, amount);\n } else {\n lockERC20(tokenAddress, depositer, address(this), amount);\n }\n }\n _depositRecords[destinationChainID][depositNonce] = DepositRecord(\n tokenAddress,\n uint8(lenRecipientAddress),\n destinationChainID,\n resourceID,\n recipientAddress,\n depositer,\n amount\n );\n }", "function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n uint256 amount;\n bytes memory destinationRecipientAddress;\n assembly {\n amount := calldataload(0x64)\n destinationRecipientAddress := mload(0x40)\n let lenDestinationRecipientAddress := calldataload(0x84)\n mstore(0x40, add(0x20, add(destinationRecipientAddress, lenDestinationRecipientAddress)))\n \n calldatacopy(\n destinationRecipientAddress, \n 0x84, \n sub(calldatasize(), 0x84) \n )\n }\n bytes20 recipientAddress;\n address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n assembly {\n recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n }\n require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n \n if (tokenAddress == _wtokenAddress) {\n function withdraw(...) {...}\nfunction safeTransferETH(...) {...}\nfunction mintERC20(...) {...}\nfunction releaseERC20(...) {...}\nIWETH(_wtokenAddress).withdraw(amount);\n \n TransferHelper.safeTransferETH(address(recipientAddress), amount);\n return;\n }\n if (_burnList[tokenAddress]) {\n mintERC20(tokenAddress, address(recipientAddress), amount);\n } else {\n releaseERC20(tokenAddress, address(recipientAddress), amount);\n }\n }", "function mintERC20(address tokenAddress, address recipient, uint256 amount) internal {\n ERC20PresetMinterPauser erc20 = ERC20PresetMinterPauser(tokenAddress);\n function mint(...) {...}\nerc20.mint(recipient, amount);\n }"], "label": "Yes", "detail": "The Meter.io cross-chain bridge exploit occurred because the Bridge contract failed to properly handle deposits of wrapped assets like WBNB when using the deposit() function. Normally, WETH or WBNB should only be deposited via depositETH(), which handles asset wrapping and ensures actual value is transferred. However, deposit() allowed deposits for any resourceID¡ªincluding those mapped to WBNB¡ªwithout checking if tokens were truly received or burned. The attacker exploited this by submitting a fake deposit using a crafted resourceID that resolved to the WBNB contract address, but without sending real tokens. Since no validation was enforced and the event was indistinguishable from a legitimate deposit, the relayers propagated the deposit event to target chains (Ethereum, Moonriver), where equivalent tokens were minted and withdrawn by the attacker. This resulted in severe financial loss, as no real assets backed the minted tokens. The root cause lies in inconsistent validation paths between depositETH() and deposit(), and the lack of enforcement for secure asset custody when dealing with wrapped native tokens."}
{"project": "nerve", "functions": ["function crossOut(string memory to, uint256 amount, address ERC20) public payable returns (bool) {\n address from = msg.sender;\n require(amount > 0, \"ERROR: Zero amount\");\n if (ERC20 != address(0)) {\n require(msg.value == 0, \"ERC20: Does not accept Ethereum Coin\");\n function isContract(...) {...}\nfunction safeTransferFrom(...) {...}\nrequire(ERC20.isContract(), \"The address is not a contract address\");\n IERC20 token = IERC20(ERC20);\n uint256 allowance = token.allowance(from, address(this));\n require(allowance >= amount, \"No enough amount for authorization\");\n uint256 fromBalance = token.balanceOf(from);\n require(fromBalance >= amount, \"No enough balance of the token\");\n token.safeTransferFrom(from, address(this), amount);\n if (isMinterERC20(ERC20)) {\n \n IERC20Minter minterToken = IERC20Minter(ERC20);\n minterToken.burn(amount);\n }\n } else {\n require(msg.value == amount, \"Inconsistency Ethereum amount\");\n }\n emit CrossOutFunds(from, to, amount, ERC20);\n return true;\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n function add(...) {...}\n_totalSupply = _totalSupply.add(amount);\n _balances[account] = _balances[account].add(amount);\n emit Transfer(address(0), account, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "nerve", "functions": ["\n \n public static void heightNotice(int chainId, long height, String blockHeader) {\n \n if (!ModuleHelper.isSupportCrossChain()) {\n return;\n }\n NulsLogger logger = ContextManager.getContext(chainId).getLogger(); \n try {\n Map<String, Object> params = new HashMap<>(4);\n\n params.put(Constants.CHAIN_ID, chainId);\n params.put(\"height\", height);\n params.put(\"blockHeader\", blockHeader);\n NerveCoreResponseMessageProcessor.requestAndResponse(ModuleE.CC.abbr, \"newBlockHeight\", params);\n } catch (Exception e) {\n logger.error(\"\", e);\n }\n }", "\n protected String sendMainAssetWithdraw(String txKey, String toAddress, String value, int signCount) throws Exception {\n BigInteger bValue = new BigDecimal(value).multiply(BigDecimal.TEN.pow(18)).toBigInteger();\n String vHash = HtgUtil.encoderWithdraw(htgContext, txKey, toAddress, bValue, false, HtgConstant.ZERO_ADDRESS, VERSION);\n String signData = this.ethSign(vHash, signCount);\n \n String signData = this.ethSign(vHash, signCount);\nString vHash = HtgUtil.encoderWithdraw(htgContext, txKey, toAddress, bValue, false, HtgConstant.ZERO_ADDRESS, VERSION);\nfunction ethSign(...) {...}\nFunction function = HtgUtil.getCreateOrSignWithdrawFunction(txKey, toAddress, bValue, false, HtgConstant.ZERO_ADDRESS, signData);\nfunction Function(...) {...}\nfunction sendTx(...) {...}\nFunction function = HtgUtil.getCreateOrSignWithdrawFunction(txKey, toAddress, bValue, false, HtgConstant.ZERO_ADDRESS, signData);\n return this.sendTx(address, priKey, function, HeterogeneousChainTxType.WITHDRAW);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "nomad", "functions": ["function send(\n address _token,\n uint256 _amount,\n uint32 _destination,\n bytes32 _recipient,\n bool \n ) external {\n \n require(_recipient != bytes32(0), \"!recip\");\n \n (bytes29 _tokenId, bytes32 _detailsHash) = _takeTokens(_token, _amount);\n require(\n _destination == _tokenId.domain(),\n \"sends temporarily disabled\"\n );\n \n bytes29 _action = BridgeMessage.formatTransfer(\n _recipient,\n _amount,\n _detailsHash\n );\n \n _sendTransferMessage(_destination, _tokenId, _action);\n \n emit Send(_token, msg.sender, _destination, _recipient, _amount, false);\n }", "function _takeTokens(address _token, uint256 _amount)\n internal\n returns (bytes29 _tokenId, bytes32 _detailsHash)\n {\n \n require(_amount > 0, \"!amnt\");\n \n IBridgeToken _t = IBridgeToken(_token);\n \n if (tokenRegistry.isLocalOrigin(_token)) {\n \n \n IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n \n _detailsHash = BridgeMessage.getDetailsHash(\n _t.name(),\n _t.symbol(),\n _t.decimals()\n );\n } else {\n \n \n _t.burn(msg.sender, _amount);\n _detailsHash = _t.detailsHash();\n }\n \n (uint32 _domain, bytes32 _id) = tokenRegistry.getTokenId(_token);\n _tokenId = BridgeMessage.formatTokenId(_domain, _id);\n }", "function handle(\n uint32 _origin,\n uint32 _nonce,\n bytes32 _sender,\n bytes memory _message\n ) external override onlyReplica onlyRemoteRouter(_origin, _sender) {\n \n bytes29 _msg = _message.ref(0).mustBeMessage();\n bytes29 _tokenId = _msg.tokenId();\n bytes29 _action = _msg.action();\n \n if (_action.isTransfer()) {\n _handleTransfer(_origin, _nonce, _tokenId, _action);\n } else if (_action.isTransferToHook()) {\n _handleTransferToHook(_origin, _nonce, _tokenId, _action);\n } else {\n require(false, \"!valid action\");\n }\n }", "function _handleTransfer(\n uint32 _origin,\n uint32 _nonce,\n bytes29 _tokenId,\n bytes29 _action\n ) internal {\n \n address _recipient = _action.evmRecipient();\n \n function _giveTokens(...) {...}\nfunction _dust(...) {...}\n_giveTokens(_origin, _nonce, _tokenId, _action, _recipient);\n \n _dust(_recipient);\n }", "function _giveTokens(\n uint32 _origin,\n uint32 _nonce,\n bytes29 _tokenId,\n bytes29 _action,\n address _recipient\n ) internal returns (address _token) {\n \n \n \n \n _token = tokenRegistry.ensureLocalToken(\n _tokenId.domain(),\n _tokenId.id()\n );\n \n uint256 _amount = _action.amnt();\n \n if (tokenRegistry.isLocalOrigin(_token)) {\n _giveLocal(_token, _amount, _recipient);\n } else {\n _giveRepr(_token, _amount, _recipient, _action.detailsHash());\n }\n \n emit Receive(\n _originAndNonce(_origin, _nonce),\n _token,\n _recipient,\n address(0),\n _amount\n );\n }", "function _giveLocal(\n address _token,\n uint256 _amount,\n address _recipient\n ) internal virtual {\n IERC20(_token).safeTransfer(_recipient, _amount);\n }", "function _giveRepr(\n address _token,\n uint256 _amount,\n address _recipient,\n bytes32 _detailsHash\n ) internal {\n \n \n IBridgeToken(_token).mint(_recipient, _amount);\n \n IBridgeToken(_token).setDetailsHash(_detailsHash);\n }", "function _dust(address _recipient) internal {\n if (\n _recipient.balance < DUST_AMOUNT &&\n address(this).balance >= DUST_AMOUNT\n ) {\n \n \n \n \n \n \n \n function send(...) {...}\npayable(_recipient).send(DUST_AMOUNT);\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "nomad", "functions": ["function process(bytes memory _message) public returns (bool _success) {\n \n bytes29 _m = _message.ref(0);\n require(_m.destination() == localDomain, \"!destination\");\n \n bytes32 _messageHash = _m.keccak();\n function acceptableRoot(...) {...}\nrequire(acceptableRoot(messages[_messageHash]), \"!proven\");\n \n require(entered == 1, \"!reentrant\");\n entered = 0;\n \n messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n \n IMessageRecipient(_m.recipientAddress()).handle(\n _m.origin(),\n _m.nonce(),\n _m.sender(),\n _m.body().clone()\n );\n \n emit Process(_messageHash, true, \"\");\n \n entered = 1;\n \n return true;\n }"], "label": "Yes", "detail": "Because confirmAt[bytes32(0)] was initialized to 1, acceptableRoot(bytes32(0)) always returns true, so attackers can submit arbitrary messages without proof and drain funds by calling process()"}
{"project": "Poly_network", "functions": ["def lock(toChainId, fromAddress, toAddress, amount):\n\n \"\"\"\n decrease the btcx balance of 'fromAddress' in this contract, decrease the total supply.\n request cross chain transaction from Ontology network to the 'toChainId' blockchain by sending serialized parameter to\n Ontology Native contract method of 'createCrossChainTx'.\n :param toChainId: indicates which blockchain 'fromAddress' wants to do cross chain transaction, in integer format.\n :param fromAddress: indicates the requester of this crosschain transaction invocation, in Ontology address format\n :param toAddress: indicates the address that will receive btcx asset in the 'toChainId' blockchain, in hex format,\n if 'toAddress' belongs to Ethereum, we take the ethereum address and remove the '0x' then pass it as bytearray to contract\n if 'toAddress' belongs to BitCoin, we take the btc address and force formating it to bytes and take the hex of bytes then pass it as bytearray to contract\n :param amount: indicates how many btcx 'fromAddress' want to do cross chain transaction from Ontology to another chain, in integer format, should be >= minimum limit\n :return:\n \"\"\"\n btcRedeemScriptBytes = getBtcRedeemScript()\n assert(len(btcRedeemScriptBytes) != 0)\n \n if toChainId == BTC_ChainId:\n assert (amount >= getMinBackBTCLimit())\n argsList = [toAddress, amount, btcRedeemScriptBytes]\n else:\n assert (amount >=0 and toChainId != ONT_ChainId)\n argsList = [toAddress, amount]\n \n assert (CheckWitness(fromAddress))\n \n \n assert (len(toAddress) != 0)\n \n Put(ctx, concat(BALANCE_KEY, fromAddress), Sub(balanceOf(fromAddress), amount))\n \n Put(ctx, TOTAL_SUPPLY_KEY, Sub(totalSupply(), amount))\n \n inputArgs = _serialzieArgs(argsList)\n \n toAssetHash = getContractAddrWithChainId(toChainId)\n assert(len(toAssetHash) != 0)\n param = state(toChainId, toAssetHash, \"unlock\", inputArgs)\n assert (Invoke(0, CROSS_CHAIN_CONTRACT_ADDRESS, \"createCrossChainTx\", param))\n \n LockEvent(CONTRACT_ADDRESS, fromAddress, toChainId, toAssetHash, toAddress, amount)\n return True", "function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){\n ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n \n IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n \n address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\n uint n = polyChainBKs.length;\n if (header.height >= curEpochStartHeight) {\n \n require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n } else {\n \n require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n \n ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\n bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);\n require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n }\n \n bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\n \n ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\n require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n \n require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");\n \n address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\n \n function _executeCrossChainTx(...) {...}\nrequire(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n \n \n emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\n return true;\n }", "function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\n bytes32 hash = getHeaderHash(_rawHeader);\n uint sigCount = _sigList.length.div(POLYCHAIN_SIGNATURE_LEN);\n address[] memory signers = new address[](sigCount);\n bytes32 r;\n bytes32 s;\n uint8 v;\n for(uint j = 0; j < sigCount; j++){\n r = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN, 32));\n s = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN + 32, 32));\n v = uint8(_sigList[j*POLYCHAIN_SIGNATURE_LEN + 64]) + 27;\n signers[j] = ecrecover(sha256(abi.encodePacked(hash)), v, r, s);\n if (signers[j] == address(0)) return false;\n }\n return Utils.containMAddresses(_keepers, signers, _m);\n }", "function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {\n uint256 off = 0;\n bytes memory value;\n (value, off) = ZeroCopySource.NextVarBytes(_auditPath, off);\n bytes32 hash = Utils.hashLeaf(value);\n uint size = _auditPath.length.sub(off).div(33);\n bytes32 nodeHash;\n byte pos;\n for (uint i = 0; i < size; i++) {\n (pos, off) = ZeroCopySource.NextByte(_auditPath, off);\n (nodeHash, off) = ZeroCopySource.NextHash(_auditPath, off);\n if (pos == 0x00) {\n hash = Utils.hashChildren(nodeHash, hash);\n } else if (pos == 0x01) {\n hash = Utils.hashChildren(hash, nodeHash);\n } else {\n revert(\"merkleProve, NextByte for position info failed\");\n }\n }\n require(hash == _root, \"merkleProve, expect root is not equal actual root\");\n return value;\n }", "function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){\n \n require(Utils.isContract(_toContract), \"The passed in address is not a contract!\");\n bytes memory returnData;\n bool success;\n \n (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))), abi.encode(_args, _fromContractAddr, _fromChainId)));\n \n require(success == true, \"EthCrossChain call business contract failed\");\n \n require(returnData.length != 0, \"No return value from business contract!\");\n (bool res,) = ZeroCopySource.NextBool(returnData, 31);\n require(res == true, \"EthCrossChain call business contract return is not true\");\n return true;\n }"], "label": "Yes", "detail": "The PolyNetwork attack exploited a critical flaw in the EthCrossChainManager contract, which failed to properly validate the `method` string in incoming cross-chain requests. By crafting a transaction from Ontology that appeared legitimate and passed through PolyChain, the attacker called `putCurEpochConPubKeyBytes` on the Ethereum-side EthCrossChainData contract. This replaced the authorized keeper public keys with attacker-controlled keys. Subsequent fake transactions using forged signatures were accepted, leading to unauthorized asset minting and withdrawal across multiple blockchains. The exploit occurred because there was no method whitelist or contract-level access control on cross-chain delegated calls."}
{"project": "Poly_network", "functions": ["func (this *SyncService) SideToAlliance() {\n\tcurrentAliaChainSyncHeight, err := this.GetCurrentAliaChainSyncHeight(this.GetSideChainID())\n\tif err != nil {\n\t\tlog.Errorf(\"[SideToAlliance] this.GetCurrentAliaChainSyncHeight error:\", err)\n\t\tos.Exit(1)\n\t}\n\tthis.aliaSyncHeight = currentAliaChainSyncHeight\n\tif config.DefConfig.SideToAlliForceSyncHeight > 0 {\n\t\tthis.aliaSyncHeight = uint32(config.DefConfig.SideToAlliForceSyncHeight)\n\t}\n\tfor {\n\t\tcurrentSideChainHeight, err := this.sideSdk.GetCurrentBlockHeight()\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"[SideToAlliance] this.sideSdk.GetCurrentBlockHeight error:\", err)\n\t\t}\n\t\tfunc sideToAlliance(...) {...}\nerr = this.sideToAlliance(this.aliaSyncHeight, currentSideChainHeight)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"[SideToAlliance] this.sideToAlliance error:\", err)\n\t\t}\n\t\ttime.Sleep(time.Duration(this.config.ScanInterval) * time.Second)\n\t}\n}", "func (this *EthSender) sendTxToEth(info *EthTxInfo) error {\n\tnonce := this.nonceManager.GetAddressNonce(this.acc.Address)\n\ttx := types.NewTransaction(nonce, info.contractAddr, big.NewInt(0), info.gasLimit, info.gasPrice, info.txData)\n\tsignedtx, err := this.keyStore.SignTransaction(tx, this.acc)\n\tif err != nil {\n\t\tthis.nonceManager.ReturnNonce(this.acc.Address, nonce)\n\t\treturn fmt.Errorf(\"commitDepositEventsWithHeader - sign raw tx error and return nonce %d: %v\", nonce, err)\n\t}\n\terr = this.ethClient.SendTransaction(context.Background(), signedtx)\n\tif err != nil {\n\t\tthis.nonceManager.ReturnNonce(this.acc.Address, nonce)\n\t\treturn fmt.Errorf(\"commitDepositEventsWithHeader - send transaction error and return nonce %d: %v\", nonce, err)\n\t}\n\thash := signedtx.Hash()\n\tisSuccess := this.waitTransactionConfirm(info.polyTxHash, hash)\n\tif isSuccess {\n\t\tlog.Infof(\"successful to relay tx to ethereum: (eth_hash: %s, nonce: %d, poly_hash: %s, eth_explorer: %s)\",\n\t\t\thash.String(), nonce, info.polyTxHash, tools.GetExplorerUrl(this.keyStore.GetChainId())+hash.String())\n\t} else {\n\t\tlog.Errorf(\"failed to relay tx to ethereum: (eth_hash: %s, nonce: %d, poly_hash: %s, eth_explorer: %s)\",\n\t\t\thash.String(), nonce, info.polyTxHash, tools.GetExplorerUrl(this.keyStore.GetChainId())+hash.String())\n\t}\n\treturn nil\n}"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "QANX", "functions": [], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "QANX", "functions": ["function bridgeSend(address beneficiary, uint256 amount, uint256 withdrawChainId) external returns (bytes32) {\n \n bytes32 txid = keccak256(abi.encode(msg.sender, block.chainid, withdrawChainId, _nonces[msg.sender][block.chainid][withdrawChainId]++, beneficiary, amount));\n \n require(_qanx.transferFrom(msg.sender, address(this), amount));\n \n return txid;\n }", "function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n function transfer(...) {...}\nrequire(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }", "function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);\n }", "function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }", "function bridgeWithdraw(address beneficiary, uint256 amount, uint256 depositChainId, bytes calldata signature) external returns (bool) {\n \n bytes32 txid = keccak256(abi.encode(msg.sender, depositChainId, block.chainid, _nonces[msg.sender][depositChainId][block.chainid]++, beneficiary, amount));\n \n function verifySignature(...) {...}\nrequire(verifySignature(txid, signature, amount), \"ERR_SIG\");\n \n uint256 fee = amount / 100 * feePercentage;\n feesCollected += fee;\n \n require(_qanx.transfer(beneficiary, amount - fee), \"ERR_TXN\");\n return true;\n }", "function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse_Protocol", "functions": ["function swap(\n Swap storage self,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 dx,\n uint256 minDy\n ) external returns (uint256) {\n {\n \n IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n require(\n dx <= tokenFrom.balanceOf(msg.sender),\n \"Cannot swap more than you own\"\n );\n \n uint256 beforeBalance = tokenFrom.balanceOf(address(this)); \n tokenFrom.safeTransferFrom(msg.sender, address(this), dx); \n \n dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance); \n }\n uint256 dy; \n uint256 dyFee; \n uint256[] memory balances = self.balances;\n \n (dy, dyFee) = _calculateSwap(\n self,\n tokenIndexFrom,\n tokenIndexTo,\n dx,\n balances\n );\n require(dy >= minDy, \"Swap didn't result in min tokens\"); \n uint256 dyAdminFee =\n dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n self.tokenPrecisionMultipliers[tokenIndexTo]\n ); \n \n self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n \n self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(\n dyAdminFee\n );\n \n self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n \n emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n return dy;\n }", "function _calculateSwap(\n Swap storage self,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 dx,\n uint256[] memory balances\n ) internal view returns (uint256 dy, uint256 dyFee) {\n uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n uint256[] memory xp = _xp(balances, multipliers);\n require(\n tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\n \"Token index out of range\"\n );\n uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\n uint256 y =\n getY(getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\n dy = xp[tokenIndexTo].sub(y).sub(1);\n dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\n }", "function _xp(\n uint256[] memory balances,\n uint256[] memory precisionMultipliers\n ) internal pure returns (uint256[] memory) {\n uint256 numTokens = balances.length;\n require(\n numTokens == precisionMultipliers.length,\n \"Balances must match multipliers\"\n );\n uint256[] memory xp = new uint256[](numTokens);\n for (uint256 i = 0; i < numTokens; i++) {\n xp[i] = balances[i].mul(precisionMultipliers[i]);\n }\n return xp;\n }"], "label": "Yes", "detail": "The attack on Nerve's MetaPool was made possible by inconsistent implementations of the getXp() pricing function in two libraries: SwapUtils and MetaSwapUtils. The MetaSwap contract, which was forked from Saddle.Finance (itself a Solidity port of Curve's MetaPool), contained two key swap functions¡ªswap() and swapUnderlying()¡ªused for exchanging between LP tokens and stablecoins. During the attack, swap() underestimated the LP token value due to ignoring the virtual price, while swapUnderlying() calculated it correctly. The attacker repeatedly swapped stablecoins for undervalued LP tokens via swap(), removed liquidity to extract base tokens, and finally used swapUnderlying() to convert base tokens back to more stablecoins at a favorable rate. This loop drained the pool of liquidity. The vulnerability stems from inconsistent logic across forked components and highlights the risk of modifying or porting code without preserving behavioral equivalence. The attacker reportedly profited ~900 BNB. A similar attack had occurred on Synapse¡¯s MetaPool one week earlier, exploiting the same flaw."}
{"project": "Synapse_Protocol", "functions": ["function removeLiquidityOneToken(\n Swap storage self,\n uint256 tokenAmount,\n uint8 tokenIndex,\n uint256 minAmount\n ) external returns (uint256) {\n LPToken lpToken = self.lpToken;\n IERC20[] memory pooledTokens = self.pooledTokens;\n require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n require(tokenIndex < pooledTokens.length, \"Token not found\");\n uint256 totalSupply = lpToken.totalSupply();\n (uint256 dy, uint256 dyFee) =\n _calculateWithdrawOneToken(\n self,\n msg.sender,\n tokenAmount,\n tokenIndex,\n totalSupply\n );\n require(dy >= minAmount, \"dy < minAmount\");\n self.balances[tokenIndex] = self.balances[tokenIndex].sub(\n dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\n );\n lpToken.burnFrom(msg.sender, tokenAmount);\n pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n emit RemoveLiquidityOne(\n msg.sender,\n tokenAmount,\n totalSupply,\n tokenIndex,\n dy\n );\n return dy;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse_Protocol", "functions": ["function swapUnderlying(\n SwapUtils.Swap storage self,\n MetaSwap storage metaSwapStorage,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 dx,\n uint256 minDy\n ) external returns (uint256) {\n SwapUnderlyingInfo memory v =\n SwapUnderlyingInfo(\n 0,\n 0,\n 0,\n 0,\n 0,\n self.balances,\n metaSwapStorage.baseTokens,\n IERC20(address(0)),\n IERC20(address(0)),\n _updateBaseVirtualPrice(metaSwapStorage)\n );\n uint8 baseLPTokenIndex = uint8(v.oldBalances.length) - 1;\n {\n uint8 maxRange = baseLPTokenIndex + uint8(v.baseTokens.length);\n require(\n tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\n \"Token index out of range\"\n );\n }\n ISwap baseSwap = metaSwapStorage.baseSwap;\n \n if (tokenIndexFrom < baseLPTokenIndex) {\n v.tokenFrom = self.pooledTokens[tokenIndexFrom];\n v.metaIndexFrom = tokenIndexFrom;\n } else {\n v.tokenFrom = v.baseTokens[tokenIndexFrom - baseLPTokenIndex];\n v.metaIndexFrom = baseLPTokenIndex;\n }\n \n if (tokenIndexTo < baseLPTokenIndex) {\n v.tokenTo = self.pooledTokens[tokenIndexTo];\n v.metaIndexTo = tokenIndexTo;\n } else {\n v.tokenTo = v.baseTokens[tokenIndexTo - baseLPTokenIndex];\n v.metaIndexTo = baseLPTokenIndex;\n }\n v.dx = v.tokenFrom.balanceOf(address(this));\n v.tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n v.dx = v.tokenFrom.balanceOf(address(this)).sub(v.dx); \n if (\n tokenIndexFrom < baseLPTokenIndex || tokenIndexTo < baseLPTokenIndex\n ) {\n uint256[] memory xp = _xp(self, v.oldBalances, v.baseVirtualPrice);\n if (tokenIndexFrom < baseLPTokenIndex) {\n v.x =\n xp[tokenIndexFrom] +\n dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]);\n } else {\n \n uint256[] memory baseAmounts =\n new uint256[](v.baseTokens.length);\n baseAmounts[tokenIndexFrom - baseLPTokenIndex] = v.dx;\n IERC20 baseLPToken = self.pooledTokens[baseLPTokenIndex];\n v.x = baseLPToken.balanceOf(address(this));\n \n baseSwap.addLiquidity(baseAmounts, 0, block.timestamp);\n \n v.dx = baseLPToken.balanceOf(address(this)).sub(v.x);\n v.x = v\n .dx\n .mul(v.baseVirtualPrice)\n .div(BASE_VIRTUAL_PRICE_PRECISION)\n .add(xp[baseLPTokenIndex]);\n }\n uint256 dyFee;\n {\n uint256 y =\n getY(\n getAPrecise(self),\n v.metaIndexFrom,\n v.metaIndexTo,\n v.x,\n xp\n );\n v.dy = xp[v.metaIndexTo].sub(y).sub(1);\n dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n v.dy = v.dy.sub(dyFee).div(\n self.tokenPrecisionMultipliers[v.metaIndexTo]\n );\n }\n if (tokenIndexTo >= baseLPTokenIndex) {\n v.dy = v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(\n v.baseVirtualPrice\n );\n }\n {\n uint256 dyAdminFee =\n dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);\n dyAdminFee = dyAdminFee.div(\n self.tokenPrecisionMultipliers[v.metaIndexTo]\n );\n self.balances[v.metaIndexFrom] = v.oldBalances[v.metaIndexFrom]\n .add(v.dx);\n self.balances[v.metaIndexTo] = v.oldBalances[v.metaIndexTo]\n .sub(v.dy)\n .sub(dyAdminFee);\n }\n if (tokenIndexTo >= baseLPTokenIndex) {\n \n \n uint256 oldBalance = v.tokenTo.balanceOf(address(this));\n baseSwap.removeLiquidityOneToken(\n v.dy,\n tokenIndexTo - baseLPTokenIndex,\n 0,\n block.timestamp\n );\n v.dy = v.tokenTo.balanceOf(address(this)) - oldBalance;\n }\n require(v.dy >= minDy, \"Swap didn't result in min tokens\");\n } else {\n \n v.dy = v.tokenTo.balanceOf(address(this));\n baseSwap.swap(\n tokenIndexFrom - baseLPTokenIndex,\n tokenIndexTo - baseLPTokenIndex,\n v.dx,\n minDy,\n block.timestamp\n );\n v.dy = v.tokenTo.balanceOf(address(this)).sub(v.dy);\n }\n v.tokenTo.safeTransfer(msg.sender, v.dy);\n emit TokenSwapUnderlying(\n msg.sender,\n dx,\n v.dy,\n tokenIndexFrom,\n tokenIndexTo\n );\n return v.dy;\n }", "function _xp(\n uint256[] memory balances,\n uint256[] memory precisionMultipliers,\n uint256 baseVirtualPrice\n ) internal pure returns (uint256[] memory) {\n uint256 numTokens = balances.length;\n require(\n numTokens == precisionMultipliers.length,\n \"Balances must match multipliers\"\n );\n uint256[] memory xp = new uint256[](numTokens);\n for (uint256 i = 0; i < numTokens; i++) {\n xp[i] = balances[i].mul(precisionMultipliers[i]);\n }\n uint256 baseLPTokenIndex = numTokens - 1;\n xp[baseLPTokenIndex] = xp[baseLPTokenIndex].mul(baseVirtualPrice).div(\n BASE_VIRTUAL_PRICE_PRECISION\n );\n return xp;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse_Protocol", "functions": ["function deposit(\n address to,\n uint256 chainId,\n IERC20 token,\n uint256 amount\n ) external nonReentrant whenNotPaused {\n emit TokenDeposit(to, chainId, token, amount);\n token.safeTransferFrom(msg.sender, address(this), amount);\n }", "function mint(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(hasRole(NODEGROUP_ROLE, msg.sender), \"Caller is not a node group\");\n require(amount > fee, \"Amount must be greater than fee\");\n require(!kappaMap[kappa], \"Kappa is already present\");\n kappaMap[kappa] = true;\n fees[address(token)] = fees[address(token)].add(fee);\n emit TokenMint(to, token, amount.sub(fee), fee, kappa);\n function mint(...) {...}\ntoken.mint(address(this), amount);\n IERC20(token).safeTransfer(to, amount.sub(fee));\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "THORChain1", "functions": ["function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n uint safeAmount;\n if(asset == address(0)){\n safeAmount = msg.value;\n (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n require(success && (data.length == 0 || abi.decode(data, (bool))));\n } else if(asset == RUNE) {\n safeAmount = amount;\n iRUNE(RUNE).transferTo(address(this), amount);\n iERC20(RUNE).burn(amount);\n } else {\n safeAmount = safeTransferFrom(asset, amount); \n vaultAllowance[vault][asset] += safeAmount; \n }\n emit Deposit(vault, asset, safeAmount, memo);\n }", "function safeTransferFrom(address _asset, uint _amount) internal returns(uint amount) {\n uint _startBal = iERC20(_asset).balanceOf(address(this));\n (bool success, bytes memory data) = _asset.call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), _amount));\n require(success && (data.length == 0 || abi.decode(data, (bool))));\n return (iERC20(_asset).balanceOf(address(this)) - _startBal);\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n if (router == address(this)){\n for(uint i = 0; i < coins.length; i++){\n _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n }\n emit VaultTransfer(msg.sender, asgard, coins, memo); \n } else {\n for(uint i = 0; i < coins.length; i++){\n _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n }\n }\n (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n require(success && (data.length == 0 || abi.decode(data, (bool))));\n }", "function _routerDeposit(address _router, address _vault, address _asset, uint _amount, string memory _memo) internal {\n vaultAllowance[msg.sender][_asset] -= _amount;\n require(iERC20(_asset).approve(_router, _amount)); \n function deposit(...) {...}\niROUTER(_router).deposit(_vault, _asset, _amount, _memo); \n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "THORChain1", "functions": ["func (e *ETHScanner) FetchTxs(height int64) (stypes.TxIn, error) {\n\tblock, err := e.getRPCBlock(height)\n\tif err != nil {\n\t\treturn stypes.TxIn{}, err\n\t}\n\tfunc processBlock(...) {...}\ntxIn, err := e.processBlock(block)\n\tif err != nil {\n\t\te.logger.Error().Err(err).Int64(\"height\", height).Msg(\"fail to search tx in block\")\n\t\treturn stypes.TxIn{}, fmt.Errorf(\"fail to process block: %d, err:%w\", height, err)\n\t}\n\t\n\t\n\tblockMeta := types.NewBlockMeta(block.Header(), txIn)\n\tif err := e.blockMetaAccessor.SaveBlockMeta(blockMeta.Height, blockMeta); err != nil {\n\t\te.logger.Err(err).Msgf(\"fail to save block meta of height: %d \", blockMeta.Height)\n\t}\n\te.currentBlockHeight = height\n\tpruneHeight := height - BlockCacheSize\n\tif pruneHeight > 0 {\n\t\tdefer func() {\n\t\t\tif err := e.blockMetaAccessor.PruneBlockMeta(pruneHeight); err != nil {\n\t\t\t\te.logger.Err(err).Msgf(\"fail to prune block meta, height(%d)\", pruneHeight)\n\t\t\t}\n\t\t}()\n\t}\n\tif e.gasPriceChanged {\n\t\t\n\t\tgasPrice := e.GetGasPrice() \n\t\t\n\t\tgasPriceForThorchain := big.NewInt(0).Div(gasPrice, big.NewInt(common.One*100))\n\t\tgasValue := gasPriceForThorchain.Uint64()\n\t\tif gasValue == 0 {\n\t\t\tgasValue = 1\n\t\t}\n\t\t\n\t\tif big.NewInt(1).Mul(big.NewInt(int64(gasValue)), big.NewInt(common.One*100)).Cmp(gasPrice) < 0 {\n\t\t\tgasValue++\n\t\t}\n\t\t\n\t\tif gasValue != e.lastReportedGasPrice {\n\t\t\te.lastReportedGasPrice = gasValue\n\t\t\tif _, err := e.bridge.PostNetworkFee(height, common.ETHChain, MaxContractGas, gasValue); err != nil {\n\t\t\t\te.logger.Err(err).Msg(\"fail to post ETH chain single transfer fee to THORNode\")\n\t\t\t}\n\t\t}\n\t}\n\treturn txIn, nil\n}", "func (e *ETHScanner) processBlock(block *etypes.Block) (stypes.TxIn, error) {\n\theight := int64(block.NumberU64())\n\ttxIn := stypes.TxIn{\n\t\tChain: common.ETHChain,\n\t\tTxArray: nil,\n\t\tFiltered: false,\n\t\tMemPool: false,\n\t\tSentUnFinalised: false,\n\t\tFinalised: false,\n\t}\n\t\n\te.updateGasPrice()\n\tfunc processReorg(...) {...}\nfunc extractTxs(...) {...}\nreorgedTxIns, err := e.processReorg(block.Header())\n\tif err != nil {\n\t\te.logger.Error().Err(err).Msgf(\"fail to process reorg for block %d\", height)\n\t\treturn txIn, err\n\t}\n\tif len(reorgedTxIns) > 0 {\n\t\tfor _, item := range reorgedTxIns {\n\t\t\tif len(item.TxArray) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttxIn.TxArray = append(txIn.TxArray, item.TxArray...)\n\t\t}\n\t}\n\tif block.Transactions().Len() == 0 {\n\t\treturn txIn, nil\n\t}\n\ttxInBlock, err := e.extractTxs(block)\n\tif err != nil {\n\t\treturn txIn, err\n\t}\n\tif len(txInBlock.TxArray) > 0 {\n\t\ttxIn.TxArray = append(txIn.TxArray, txInBlock.TxArray...)\n\t}\n\treturn txIn, nil\n}", "func (e *ETHScanner) extractTxs(block *etypes.Block) (stypes.TxIn, error) {\n\ttxInbound := stypes.TxIn{\n\t\tChain: common.ETHChain,\n\t\tFiltered: false,\n\t\tMemPool: false,\n\t}\n\tfor _, tx := range block.Transactions() {\n\t\tif tx.To() == nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif err := e.blockMetaAccessor.RemoveSignedTxItem(tx.Hash().String()); err != nil {\n\t\t\te.logger.Err(err).Msgf(\"fail to remove signed tx item, hash:%s\", tx.Hash().String())\n\t\t}\n\t\tfunc fromTxToTxIn(...) {...}\ntxInItem, err := e.fromTxToTxIn(tx)\n\t\tif err != nil {\n\t\t\te.logger.Error().Err(err).Str(\"hash\", tx.Hash().Hex()).Msg(\"fail to get one tx from server\")\n\t\t\t\n\t\t\t\n\t\t\tif errors.Is(err, etypes.ErrInvalidChainId) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\te.errCounter.WithLabelValues(\"fail_get_tx\", \"\").Inc()\n\t\t\t\n\t\t\t\n\t\t\treturn stypes.TxIn{}, fmt.Errorf(\"fail to get one tx from server: %w\", err)\n\t\t}\n\t\tif txInItem == nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif len(txInItem.To) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif len([]byte(txInItem.Memo)) > constants.MaxMemoSize {\n\t\t\tcontinue\n\t\t}\n\t\ttxInItem.BlockHeight = block.Number().Int64()\n\t\ttxInbound.TxArray = append(txInbound.TxArray, *txInItem)\n\t\te.logger.Debug().Str(\"hash\", tx.Hash().Hex()).Msgf(\"%s got %d tx\", e.cfg.ChainID, 1)\n\t}\n\tif len(txInbound.TxArray) == 0 {\n\t\te.logger.Info().Int64(\"block\", int64(block.NumberU64())).Msg(\"no tx need to be processed in this block\")\n\t\treturn stypes.TxIn{}, nil\n\t}\n\ttxInbound.Count = strconv.Itoa(len(txInbound.TxArray))\n\te.logger.Debug().Int64(\"block\", int64(block.NumberU64())).Msgf(\"there are %s tx in this block need to process\", txInbound.Count)\n\treturn txInbound, nil\n}", "func (e *ETHScanner) fromTxToTxIn(tx *etypes.Transaction) (*stypes.TxInItem, error) {\n\tif tx == nil || tx.To() == nil {\n\t\treturn nil, nil\n\t}\n\treceipt, err := e.getReceipt(tx.Hash().Hex())\n\tif err != nil {\n\t\tif errors.Is(err, ethereum.NotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"fail to get transaction receipt: %w\", err)\n\t}\n\tif receipt.Status != 1 {\n\t\te.logger.Debug().Msgf(\"tx(%s) state: %d means failed , ignore\", tx.Hash().String(), receipt.Status)\n\t\treturn nil, nil\n\t}\n\tfunc isToSmartContract(...) {...}\nfunc getTxInFromSmartContract(...) {...}\nfunc getTxInFromTransaction(...) {...}\nsmartContract := e.isToSmartContract(receipt)\n\tif smartContract {\n\t\treturn e.getTxInFromSmartContract(tx, receipt)\n\t}\n\treturn e.getTxInFromTransaction(tx)\n}", "func (e *ETHScanner) getTxInFromSmartContract(tx *etypes.Transaction, receipt *etypes.Receipt) (*stypes.TxInItem, error) {\n\te.logger.Debug().Msg(\"parse tx from smart contract\")\n\ttxInItem := &stypes.TxInItem{\n\t\tTx: tx.Hash().Hex()[2:],\n\t}\n\tsender, err := e.eipSigner.Sender(tx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fail to get sender: %w\", err)\n\t}\n\ttxInItem.Sender = strings.ToLower(sender.String())\n\t\n\tif receipt.Status != 1 {\n\t\te.logger.Info().Msgf(\"tx(%s) state: %d means failed , ignore\", tx.Hash().String(), receipt.Status)\n\t\treturn nil, nil\n\t}\n\tfor _, item := range receipt.Logs {\n\t\tswitch item.Topics[0].String() {\n\t\tcase depositEvent:\n\t\t\tdepositEvt, err := e.parseDeposit(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse deposit event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"deposit:%+v\", depositEvt)\n\t\t\ttxInItem.To = depositEvt.To.String()\n\t\t\ttxInItem.Memo = depositEvt.Memo\n\t\t\tfunc getAssetFromTokenAddress(...) {...}\nasset, err := e.getAssetFromTokenAddress(depositEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(depositEvt.Asset.String())\n\t\t\te.logger.Info().Msgf(\"token:%s,decimals:%d\", depositEvt.Asset, decimals)\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(depositEvt.Asset.String(), depositEvt.Amount)).WithDecimals(decimals))\n\t\tcase transferOutEvent:\n\t\t\ttransferOutEvt, err := e.parseTransferOut(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse transfer out event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"transfer out: %+v\", transferOutEvt)\n\t\t\ttxInItem.Sender = transferOutEvt.Vault.String()\n\t\t\ttxInItem.To = transferOutEvt.To.String()\n\t\t\ttxInItem.Memo = transferOutEvt.Memo\n\t\t\tasset, err := e.getAssetFromTokenAddress(transferOutEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(transferOutEvt.Asset.String())\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(transferOutEvt.Asset.String(), transferOutEvt.Amount)).WithDecimals(decimals))\n\t\tcase transferAllowanceEvent:\n\t\t\ttransferAllowanceEvt, err := e.parseTransferAllowanceEvent(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse transfer allowance event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"transfer allowance: %+v\", transferAllowanceEvt)\n\t\t\ttxInItem.Sender = transferAllowanceEvt.OldVault.String()\n\t\t\ttxInItem.To = transferAllowanceEvt.NewVault.String()\n\t\t\ttxInItem.Memo = transferAllowanceEvt.Memo\n\t\t\tasset, err := e.getAssetFromTokenAddress(transferAllowanceEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(transferAllowanceEvt.Asset.String())\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(transferAllowanceEvt.Asset.String(), transferAllowanceEvt.Amount)).WithDecimals(decimals))\n\t\tcase vaultTransferEvent:\n\t\t\ttransferEvent, err := e.parseVaultTransfer(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse vault transfer event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"vault transfer: %+v\", transferEvent)\n\t\t\ttxInItem.Sender = transferEvent.OldVault.String()\n\t\t\ttxInItem.To = transferEvent.NewVault.String()\n\t\t\ttxInItem.Memo = transferEvent.Memo\n\t\t\tfor _, item := range transferEvent.Coins {\n\t\t\t\tasset, err := e.getAssetFromTokenAddress(item.Asset.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t\t}\n\t\t\t\tdecimals := e.getTokenDecimalsForTHORChain(item.Asset.String())\n\t\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(item.Asset.String(), item.Amount)).WithDecimals(decimals))\n\t\t\t}\n\t\t}\n\t}\n\t\n\tethValue := cosmos.NewUintFromBigInt(tx.Value())\n\tif !ethValue.IsZero() {\n\t\tethValue = e.convertAmount(ethToken, tx.Value())\n\t\tif txInItem.Coins.GetCoin(common.ETHAsset).IsEmpty() && !ethValue.IsZero() {\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(common.ETHAsset, ethValue))\n\t\t}\n\t}\n\te.logger.Info().Msgf(\"tx: %s, gas price: %s, gas used: %d,receipt status:%d\", txInItem.Tx, tx.GasPrice().String(), receipt.GasUsed, receipt.Status)\n\t\n\ttxGasPrice := tx.GasPrice()\n\tif txGasPrice.Cmp(big.NewInt(tenGwei)) < 0 {\n\t\ttxGasPrice = big.NewInt(tenGwei)\n\t}\n\ttxInItem.Gas = common.MakeETHGas(txGasPrice, receipt.GasUsed)\n\tif txInItem.Coins.IsEmpty() {\n\t\te.logger.Debug().Msgf(\"there is no coin in this tx, ignore, %+v\", txInItem)\n\t\treturn nil, nil\n\t}\n\te.logger.Debug().Msgf(\"tx in item: %+v\", txInItem)\n\treturn txInItem, nil\n}", "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\tfunc getTokenMeta(...) {...}\ntokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}", "func (e *ETHScanner) getTokenMeta(token string) (types.TokenMeta, error) {\n\ttokenMeta, err := e.tokens.GetTokenMeta(token)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tif tokenMeta.IsEmpty() {\n\t\tfunc getSymbol(...) {...}\nsymbol, err := e.getSymbol(token)\n\t\tif err != nil {\n\t\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get symbol: %w\", err)\n\t\t}\n\t\tdecimals, err := e.getDecimals(token)\n\t\tif err != nil {\n\t\t\te.logger.Err(err).Msgf(\"fail to get decimals from smart contract, default to: %d\", defaultDecimals)\n\t\t}\n\t\te.logger.Info().Msgf(\"token:%s, decimals: %d\", token, decimals)\n\t\ttokenMeta = types.NewTokenMeta(symbol, token, decimals)\n\t\tif err = e.tokens.SaveTokenMeta(symbol, token, decimals); err != nil {\n\t\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to save token meta: %w\", err)\n\t\t}\n\t}\n\treturn tokenMeta, nil\n}", "func (t *LevelDBTokenMeta) GetTokenMeta(address string) (types.TokenMeta, error) {\n\tfunc getTokenMetaKey(...) {...}\nkey := t.getTokenMetaKey(address)\n\texist, err := t.db.Has([]byte(key), nil)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to check whether token meta(%s) exist: %w\", key, err)\n\t}\n\tif !exist {\n\t\treturn types.TokenMeta{}, nil\n\t}\n\tv, err := t.db.Get([]byte(key), nil)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get token meta(%s) from storage: %w\", key, err)\n\t}\n\tvar tm types.TokenMeta\n\tif err := json.Unmarshal(v, &tm); err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to unmarshal token meta from json: %w\", err)\n\t}\n\treturn tm, nil\n}", "func (e *ETHScanner) getSymbol(token string) (string, error) {\n\tif IsETH(token) {\n\t\treturn \"ETH\", nil\n\t}\n\tto := ecommon.HexToAddress(token)\n\tinput, err := e.erc20ABI.Pack(symbolMethod)\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\tctx, cancel := e.getContext()\n\tdefer cancel()\n\tres, err := e.client.CallContract(ctx, ethereum.CallMsg{\n\t\tTo: &to,\n\t\tData: input,\n\t}, nil)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"fail to call to smart contract and get symbol: %w\", err)\n\t}\n\toutput, err := e.erc20ABI.Unpack(symbolMethod, res)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"fail to unpack symbol method call: %w\", err)\n\t}\n\tsymbol := *abi.ConvertType(output[0], new(string)).(*string)\n\treturn sanitiseSymbol(symbol), nil\n}", "func (t *LevelDBTokenMeta) SaveTokenMeta(symbol, address string, decimals uint64) error {\n\tfunc getTokenMetaKey(...) {...}\nkey := t.getTokenMetaKey(address)\n\ttokenMeta := types.NewTokenMeta(symbol, address, decimals)\n\tbuf, err := json.Marshal(tokenMeta)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"fail to marshal token meta to json: %w\", err)\n\t}\n\treturn t.db.Put([]byte(key), buf, nil)\n}", "func (e *ETHScanner) getTxInFromTransaction(tx *etypes.Transaction) (*stypes.TxInItem, error) {\n\ttxInItem := &stypes.TxInItem{\n\t\tTx: tx.Hash().Hex()[2:],\n\t}\n\tasset := common.ETHAsset\n\tsender, err := e.eipSigner.Sender(tx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fail to get sender: %w\", err)\n\t}\n\ttxInItem.Sender = strings.ToLower(sender.String())\n\ttxInItem.To = strings.ToLower(tx.To().String())\n\t\n\tdata := tx.Data()\n\tif len(data) > 0 {\n\t\tmemo, err := hex.DecodeString(string(data))\n\t\tif err != nil {\n\t\t\ttxInItem.Memo = string(data)\n\t\t} else {\n\t\t\ttxInItem.Memo = string(memo)\n\t\t}\n\t}\n\tethValue := e.convertAmount(ethToken, tx.Value())\n\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, ethValue))\n\ttxGasPrice := tx.GasPrice()\n\tif txGasPrice.Cmp(big.NewInt(tenGwei)) < 0 {\n\t\ttxGasPrice = big.NewInt(tenGwei)\n\t}\n\ttxInItem.Gas = common.MakeETHGas(txGasPrice, tx.Gas())\n\tif txInItem.Coins.IsEmpty() {\n\t\te.logger.Debug().Msgf(\"there is no coin in this tx, ignore, %+v\", txInItem)\n\t\treturn nil, nil\n\t}\n\treturn txInItem, nil\n}"], "label": "Yes", "detail": "The getAssetFromTokenAddress function in THORChain's Ethereum scanner fails to properly handle ERC20 tokens with 'ETH' symbol. When processing deposits, it defaults to native ETH asset type if the token metadata isn't found in local storage. An attacker can deploy a malicious ERC20 token with 'ETH' symbol, causing the bridge to incorrectly identify the token as native Ethereum. This allows fake tokens to be treated as genuine ETH in cross-chain transactions."}
{"project": "THORChain2", "functions": ["function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n uint safeAmount;\n if(asset == address(0)){\n safeAmount = msg.value;\n (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n require(success && (data.length == 0 || abi.decode(data, (bool))));\n } else if(asset == RUNE) {\n safeAmount = amount;\n iRUNE(RUNE).transferTo(address(this), amount);\n iERC20(RUNE).burn(amount);\n } else {\n safeAmount = safeTransferFrom(asset, amount); \n vaultAllowance[vault][asset] += safeAmount; \n }\n emit Deposit(vault, asset, safeAmount, memo);\n }", "function safeTransferFrom(address _asset, uint _amount) internal returns(uint amount) {\n uint _startBal = iERC20(_asset).balanceOf(address(this));\n (bool success, bytes memory data) = _asset.call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), _amount));\n require(success && (data.length == 0 || abi.decode(data, (bool))));\n return (iERC20(_asset).balanceOf(address(this)) - _startBal);\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n if (router == address(this)){\n for(uint i = 0; i < coins.length; i++){\n _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n }\n emit VaultTransfer(msg.sender, asgard, coins, memo); \n } else {\n for(uint i = 0; i < coins.length; i++){\n _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n }\n }\n (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n require(success && (data.length == 0 || abi.decode(data, (bool))));\n }", "function _routerDeposit(address _router, address _vault, address _asset, uint _amount, string memory _memo) internal {\n vaultAllowance[msg.sender][_asset] -= _amount;\n require(iERC20(_asset).approve(_router, _amount)); \n function deposit(...) {...}\niROUTER(_router).deposit(_vault, _asset, _amount, _memo); \n }"], "label": "Yes", "detail": "The attacker invoked the THORChain Router contract's deposit method via a malicious contract, passing an amount of 0. Then, the attacker initiated a transaction to call the malicious contract, setting a non-zero msg.value in the transaction. Due to a flaw in THORChain's code, the system used the msg.value from the transaction instead of the amount parameter in the deposit function when determining the deposit value. This allowed the attacker to fake a deposit and receive assets without actually transferring any real funds."}
{"project": "THORChain2", "functions": ["func (e *ETHScanner) FetchTxs(height int64) (stypes.TxIn, error) {\n\tblock, err := e.getRPCBlock(height)\n\tif err != nil {\n\t\treturn stypes.TxIn{}, err\n\t}\n\tfunc processBlock(...) {...}\ntxIn, err := e.processBlock(block)\n\tif err != nil {\n\t\te.logger.Error().Err(err).Int64(\"height\", height).Msg(\"fail to search tx in block\")\n\t\treturn stypes.TxIn{}, fmt.Errorf(\"fail to process block: %d, err:%w\", height, err)\n\t}\n\t\n\t\n\tblockMeta := types.NewBlockMeta(block.Header(), txIn)\n\tif err := e.blockMetaAccessor.SaveBlockMeta(blockMeta.Height, blockMeta); err != nil {\n\t\te.logger.Err(err).Msgf(\"fail to save block meta of height: %d \", blockMeta.Height)\n\t}\n\te.currentBlockHeight = height\n\tpruneHeight := height - BlockCacheSize\n\tif pruneHeight > 0 {\n\t\tdefer func() {\n\t\t\tif err := e.blockMetaAccessor.PruneBlockMeta(pruneHeight); err != nil {\n\t\t\t\te.logger.Err(err).Msgf(\"fail to prune block meta, height(%d)\", pruneHeight)\n\t\t\t}\n\t\t}()\n\t}\n\tif e.gasPriceChanged {\n\t\t\n\t\tgasPrice := e.GetGasPrice() \n\t\t\n\t\tgasPriceForThorchain := big.NewInt(0).Div(gasPrice, big.NewInt(common.One*100))\n\t\tgasValue := gasPriceForThorchain.Uint64()\n\t\tif gasValue == 0 {\n\t\t\tgasValue = 1\n\t\t}\n\t\t\n\t\tif big.NewInt(1).Mul(big.NewInt(int64(gasValue)), big.NewInt(common.One*100)).Cmp(gasPrice) < 0 {\n\t\t\tgasValue++\n\t\t}\n\t\t\n\t\tif gasValue != e.lastReportedGasPrice {\n\t\t\te.lastReportedGasPrice = gasValue\n\t\t\tif _, err := e.bridge.PostNetworkFee(height, common.ETHChain, MaxContractGas, gasValue); err != nil {\n\t\t\t\te.logger.Err(err).Msg(\"fail to post ETH chain single transfer fee to THORNode\")\n\t\t\t}\n\t\t}\n\t}\n\treturn txIn, nil\n}", "func (e *ETHScanner) processBlock(block *etypes.Block) (stypes.TxIn, error) {\n\theight := int64(block.NumberU64())\n\ttxIn := stypes.TxIn{\n\t\tChain: common.ETHChain,\n\t\tTxArray: nil,\n\t\tFiltered: false,\n\t\tMemPool: false,\n\t\tSentUnFinalised: false,\n\t\tFinalised: false,\n\t}\n\t\n\te.updateGasPrice()\n\tfunc processReorg(...) {...}\nfunc extractTxs(...) {...}\nreorgedTxIns, err := e.processReorg(block.Header())\n\tif err != nil {\n\t\te.logger.Error().Err(err).Msgf(\"fail to process reorg for block %d\", height)\n\t\treturn txIn, err\n\t}\n\tif len(reorgedTxIns) > 0 {\n\t\tfor _, item := range reorgedTxIns {\n\t\t\tif len(item.TxArray) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttxIn.TxArray = append(txIn.TxArray, item.TxArray...)\n\t\t}\n\t}\n\tif block.Transactions().Len() == 0 {\n\t\treturn txIn, nil\n\t}\n\ttxInBlock, err := e.extractTxs(block)\n\tif err != nil {\n\t\treturn txIn, err\n\t}\n\tif len(txInBlock.TxArray) > 0 {\n\t\ttxIn.TxArray = append(txIn.TxArray, txInBlock.TxArray...)\n\t}\n\treturn txIn, nil\n}", "func (e *ETHScanner) extractTxs(block *etypes.Block) (stypes.TxIn, error) {\n\ttxInbound := stypes.TxIn{\n\t\tChain: common.ETHChain,\n\t\tFiltered: false,\n\t\tMemPool: false,\n\t}\n\tfor _, tx := range block.Transactions() {\n\t\tif tx.To() == nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif err := e.blockMetaAccessor.RemoveSignedTxItem(tx.Hash().String()); err != nil {\n\t\t\te.logger.Err(err).Msgf(\"fail to remove signed tx item, hash:%s\", tx.Hash().String())\n\t\t}\n\t\tfunc fromTxToTxIn(...) {...}\ntxInItem, err := e.fromTxToTxIn(tx)\n\t\tif err != nil {\n\t\t\te.logger.Error().Err(err).Str(\"hash\", tx.Hash().Hex()).Msg(\"fail to get one tx from server\")\n\t\t\t\n\t\t\t\n\t\t\tif errors.Is(err, etypes.ErrInvalidChainId) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\te.errCounter.WithLabelValues(\"fail_get_tx\", \"\").Inc()\n\t\t\t\n\t\t\t\n\t\t\treturn stypes.TxIn{}, fmt.Errorf(\"fail to get one tx from server: %w\", err)\n\t\t}\n\t\tif txInItem == nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif len(txInItem.To) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif len([]byte(txInItem.Memo)) > constants.MaxMemoSize {\n\t\t\tcontinue\n\t\t}\n\t\ttxInItem.BlockHeight = block.Number().Int64()\n\t\ttxInbound.TxArray = append(txInbound.TxArray, *txInItem)\n\t\te.logger.Debug().Str(\"hash\", tx.Hash().Hex()).Msgf(\"%s got %d tx\", e.cfg.ChainID, 1)\n\t}\n\tif len(txInbound.TxArray) == 0 {\n\t\te.logger.Info().Int64(\"block\", int64(block.NumberU64())).Msg(\"no tx need to be processed in this block\")\n\t\treturn stypes.TxIn{}, nil\n\t}\n\ttxInbound.Count = strconv.Itoa(len(txInbound.TxArray))\n\te.logger.Debug().Int64(\"block\", int64(block.NumberU64())).Msgf(\"there are %s tx in this block need to process\", txInbound.Count)\n\treturn txInbound, nil\n}", "func (e *ETHScanner) fromTxToTxIn(tx *etypes.Transaction) (*stypes.TxInItem, error) {\n\tif tx == nil || tx.To() == nil {\n\t\treturn nil, nil\n\t}\n\treceipt, err := e.getReceipt(tx.Hash().Hex())\n\tif err != nil {\n\t\tif errors.Is(err, ethereum.NotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"fail to get transaction receipt: %w\", err)\n\t}\n\tif receipt.Status != 1 {\n\t\te.logger.Debug().Msgf(\"tx(%s) state: %d means failed , ignore\", tx.Hash().String(), receipt.Status)\n\t\treturn nil, nil\n\t}\n\tfunc isToSmartContract(...) {...}\nfunc getTxInFromSmartContract(...) {...}\nfunc getTxInFromTransaction(...) {...}\nsmartContract := e.isToSmartContract(receipt)\n\tif smartContract {\n\t\treturn e.getTxInFromSmartContract(tx, receipt)\n\t}\n\treturn e.getTxInFromTransaction(tx)\n}", "func (e *ETHScanner) getTxInFromSmartContract(tx *etypes.Transaction, receipt *etypes.Receipt) (*stypes.TxInItem, error) {\n\te.logger.Debug().Msg(\"parse tx from smart contract\")\n\ttxInItem := &stypes.TxInItem{\n\t\tTx: tx.Hash().Hex()[2:],\n\t}\n\tsender, err := e.eipSigner.Sender(tx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fail to get sender: %w\", err)\n\t}\n\ttxInItem.Sender = strings.ToLower(sender.String())\n\t\n\tif receipt.Status != 1 {\n\t\te.logger.Info().Msgf(\"tx(%s) state: %d means failed , ignore\", tx.Hash().String(), receipt.Status)\n\t\treturn nil, nil\n\t}\n\tfor _, item := range receipt.Logs {\n\t\tswitch item.Topics[0].String() {\n\t\tcase depositEvent:\n\t\t\tdepositEvt, err := e.parseDeposit(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse deposit event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"deposit:%+v\", depositEvt)\n\t\t\ttxInItem.To = depositEvt.To.String()\n\t\t\ttxInItem.Memo = depositEvt.Memo\n\t\t\tfunc getAssetFromTokenAddress(...) {...}\nasset, err := e.getAssetFromTokenAddress(depositEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(depositEvt.Asset.String())\n\t\t\te.logger.Info().Msgf(\"token:%s,decimals:%d\", depositEvt.Asset, decimals)\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(depositEvt.Asset.String(), depositEvt.Amount)).WithDecimals(decimals))\n\t\tcase transferOutEvent:\n\t\t\ttransferOutEvt, err := e.parseTransferOut(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse transfer out event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"transfer out: %+v\", transferOutEvt)\n\t\t\ttxInItem.Sender = transferOutEvt.Vault.String()\n\t\t\ttxInItem.To = transferOutEvt.To.String()\n\t\t\ttxInItem.Memo = transferOutEvt.Memo\n\t\t\tasset, err := e.getAssetFromTokenAddress(transferOutEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(transferOutEvt.Asset.String())\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(transferOutEvt.Asset.String(), transferOutEvt.Amount)).WithDecimals(decimals))\n\t\tcase transferAllowanceEvent:\n\t\t\ttransferAllowanceEvt, err := e.parseTransferAllowanceEvent(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse transfer allowance event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"transfer allowance: %+v\", transferAllowanceEvt)\n\t\t\ttxInItem.Sender = transferAllowanceEvt.OldVault.String()\n\t\t\ttxInItem.To = transferAllowanceEvt.NewVault.String()\n\t\t\ttxInItem.Memo = transferAllowanceEvt.Memo\n\t\t\tasset, err := e.getAssetFromTokenAddress(transferAllowanceEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(transferAllowanceEvt.Asset.String())\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(transferAllowanceEvt.Asset.String(), transferAllowanceEvt.Amount)).WithDecimals(decimals))\n\t\tcase vaultTransferEvent:\n\t\t\ttransferEvent, err := e.parseVaultTransfer(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse vault transfer event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"vault transfer: %+v\", transferEvent)\n\t\t\ttxInItem.Sender = transferEvent.OldVault.String()\n\t\t\ttxInItem.To = transferEvent.NewVault.String()\n\t\t\ttxInItem.Memo = transferEvent.Memo\n\t\t\tfor _, item := range transferEvent.Coins {\n\t\t\t\tasset, err := e.getAssetFromTokenAddress(item.Asset.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t\t}\n\t\t\t\tdecimals := e.getTokenDecimalsForTHORChain(item.Asset.String())\n\t\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(item.Asset.String(), item.Amount)).WithDecimals(decimals))\n\t\t\t}\n\t\t}\n\t}\n\t\n\tethValue := cosmos.NewUintFromBigInt(tx.Value())\n\tif !ethValue.IsZero() {\n\t\tethValue = e.convertAmount(ethToken, tx.Value())\n\t\tif txInItem.Coins.GetCoin(common.ETHAsset).IsEmpty() && !ethValue.IsZero() {\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(common.ETHAsset, ethValue))\n\t\t}\n\t}\n\te.logger.Info().Msgf(\"tx: %s, gas price: %s, gas used: %d,receipt status:%d\", txInItem.Tx, tx.GasPrice().String(), receipt.GasUsed, receipt.Status)\n\t\n\ttxGasPrice := tx.GasPrice()\n\tif txGasPrice.Cmp(big.NewInt(tenGwei)) < 0 {\n\t\ttxGasPrice = big.NewInt(tenGwei)\n\t}\n\ttxInItem.Gas = common.MakeETHGas(txGasPrice, receipt.GasUsed)\n\tif txInItem.Coins.IsEmpty() {\n\t\te.logger.Debug().Msgf(\"there is no coin in this tx, ignore, %+v\", txInItem)\n\t\treturn nil, nil\n\t}\n\te.logger.Debug().Msgf(\"tx in item: %+v\", txInItem)\n\treturn txInItem, nil\n}", "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\tfunc getTokenMeta(...) {...}\ntokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}", "func (e *ETHScanner) getTokenMeta(token string) (types.TokenMeta, error) {\n\ttokenMeta, err := e.tokens.GetTokenMeta(token)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tif tokenMeta.IsEmpty() {\n\t\tfunc getSymbol(...) {...}\nsymbol, err := e.getSymbol(token)\n\t\tif err != nil {\n\t\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get symbol: %w\", err)\n\t\t}\n\t\tdecimals, err := e.getDecimals(token)\n\t\tif err != nil {\n\t\t\te.logger.Err(err).Msgf(\"fail to get decimals from smart contract, default to: %d\", defaultDecimals)\n\t\t}\n\t\te.logger.Info().Msgf(\"token:%s, decimals: %d\", token, decimals)\n\t\ttokenMeta = types.NewTokenMeta(symbol, token, decimals)\n\t\tif err = e.tokens.SaveTokenMeta(symbol, token, decimals); err != nil {\n\t\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to save token meta: %w\", err)\n\t\t}\n\t}\n\treturn tokenMeta, nil\n}", "func (t *LevelDBTokenMeta) GetTokenMeta(address string) (types.TokenMeta, error) {\n\tfunc getTokenMetaKey(...) {...}\nkey := t.getTokenMetaKey(address)\n\texist, err := t.db.Has([]byte(key), nil)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to check whether token meta(%s) exist: %w\", key, err)\n\t}\n\tif !exist {\n\t\treturn types.TokenMeta{}, nil\n\t}\n\tv, err := t.db.Get([]byte(key), nil)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get token meta(%s) from storage: %w\", key, err)\n\t}\n\tvar tm types.TokenMeta\n\tif err := json.Unmarshal(v, &tm); err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to unmarshal token meta from json: %w\", err)\n\t}\n\treturn tm, nil\n}", "func (e *ETHScanner) getSymbol(token string) (string, error) {\n\tif IsETH(token) {\n\t\treturn \"ETH\", nil\n\t}\n\tto := ecommon.HexToAddress(token)\n\tinput, err := e.erc20ABI.Pack(symbolMethod)\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\tctx, cancel := e.getContext()\n\tdefer cancel()\n\tres, err := e.client.CallContract(ctx, ethereum.CallMsg{\n\t\tTo: &to,\n\t\tData: input,\n\t}, nil)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"fail to call to smart contract and get symbol: %w\", err)\n\t}\n\toutput, err := e.erc20ABI.Unpack(symbolMethod, res)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"fail to unpack symbol method call: %w\", err)\n\t}\n\tsymbol := *abi.ConvertType(output[0], new(string)).(*string)\n\treturn sanitiseSymbol(symbol), nil\n}", "func (t *LevelDBTokenMeta) SaveTokenMeta(symbol, address string, decimals uint64) error {\n\tfunc getTokenMetaKey(...) {...}\nkey := t.getTokenMetaKey(address)\n\ttokenMeta := types.NewTokenMeta(symbol, address, decimals)\n\tbuf, err := json.Marshal(tokenMeta)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"fail to marshal token meta to json: %w\", err)\n\t}\n\treturn t.db.Put([]byte(key), buf, nil)\n}", "func (e *ETHScanner) getTxInFromTransaction(tx *etypes.Transaction) (*stypes.TxInItem, error) {\n\ttxInItem := &stypes.TxInItem{\n\t\tTx: tx.Hash().Hex()[2:],\n\t}\n\tasset := common.ETHAsset\n\tsender, err := e.eipSigner.Sender(tx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fail to get sender: %w\", err)\n\t}\n\ttxInItem.Sender = strings.ToLower(sender.String())\n\ttxInItem.To = strings.ToLower(tx.To().String())\n\t\n\tdata := tx.Data()\n\tif len(data) > 0 {\n\t\tmemo, err := hex.DecodeString(string(data))\n\t\tif err != nil {\n\t\t\ttxInItem.Memo = string(data)\n\t\t} else {\n\t\t\ttxInItem.Memo = string(memo)\n\t\t}\n\t}\n\tethValue := e.convertAmount(ethToken, tx.Value())\n\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, ethValue))\n\ttxGasPrice := tx.GasPrice()\n\tif txGasPrice.Cmp(big.NewInt(tenGwei)) < 0 {\n\t\ttxGasPrice = big.NewInt(tenGwei)\n\t}\n\ttxInItem.Gas = common.MakeETHGas(txGasPrice, tx.Gas())\n\tif txInItem.Coins.IsEmpty() {\n\t\te.logger.Debug().Msgf(\"there is no coin in this tx, ignore, %+v\", txInItem)\n\t\treturn nil, nil\n\t}\n\treturn txInItem, nil\n}"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "THORChain3", "functions": ["function deposit(address payable vault, address asset, uint amount, string memory memo) external payable {\n uint safeAmount;\n if(asset == address(0)){\n safeAmount = msg.value;\n (bool success, bytes memory data) = vault.call{value:safeAmount}(\"\");\n require(success && (data.length == 0 || abi.decode(data, (bool))));\n } else if(asset == RUNE) {\n safeAmount = amount;\n iRUNE(RUNE).transferTo(address(this), amount);\n iERC20(RUNE).burn(amount);\n } else {\n safeAmount = safeTransferFrom(asset, amount); \n vaultAllowance[vault][asset] += safeAmount; \n }\n emit Deposit(vault, asset, safeAmount, memo);\n }", "function safeTransferFrom(address _asset, uint _amount) internal returns(uint amount) {\n uint _startBal = iERC20(_asset).balanceOf(address(this));\n (bool success, bytes memory data) = _asset.call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), _amount));\n require(success && (data.length == 0 || abi.decode(data, (bool))));\n return (iERC20(_asset).balanceOf(address(this)) - _startBal);\n }", "function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n if (router == address(this)){\n for(uint i = 0; i < coins.length; i++){\n _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n }\n emit VaultTransfer(msg.sender, asgard, coins, memo); \n } else {\n for(uint i = 0; i < coins.length; i++){\n _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n }\n }\n (bool success, bytes memory data) = asgard.call{value:msg.value}(\"\"); \n require(success && (data.length == 0 || abi.decode(data, (bool))));\n }", "function _routerDeposit(address _router, address _vault, address _asset, uint _amount, string memory _memo) internal {\n vaultAllowance[msg.sender][_asset] -= _amount;\n require(iERC20(_asset).approve(_router, _amount)); \n function deposit(...) {...}\niROUTER(_router).deposit(_vault, _asset, _amount, _memo); \n }"], "label": "Yes", "detail": "The attacker deployed a malicious contract and used the THORChain Router's `returnVaultAssets` function to send ETH to the malicious contract, falsely setting the contract as an Asgard vault. The malicious contract triggered the `deposit` event and allowed the attacker to arbitrarily craft the `asset` and `amount` parameters, along with an invalid `memo`. This invalid `memo` disrupted the THORChain node's processing logic, forcing it into the refund logic path. Because the refund logic didn¡¯t properly validate the entire transaction, the attacker was able to gain profits without transferring any legitimate value."}
{"project": "THORChain3", "functions": ["func (e *ETHScanner) FetchTxs(height int64) (stypes.TxIn, error) {\n\tblock, err := e.getRPCBlock(height)\n\tif err != nil {\n\t\treturn stypes.TxIn{}, err\n\t}\n\tfunc processBlock(...) {...}\ntxIn, err := e.processBlock(block)\n\tif err != nil {\n\t\te.logger.Error().Err(err).Int64(\"height\", height).Msg(\"fail to search tx in block\")\n\t\treturn stypes.TxIn{}, fmt.Errorf(\"fail to process block: %d, err:%w\", height, err)\n\t}\n\t\n\t\n\tblockMeta := types.NewBlockMeta(block.Header(), txIn)\n\tif err := e.blockMetaAccessor.SaveBlockMeta(blockMeta.Height, blockMeta); err != nil {\n\t\te.logger.Err(err).Msgf(\"fail to save block meta of height: %d \", blockMeta.Height)\n\t}\n\te.currentBlockHeight = height\n\tpruneHeight := height - BlockCacheSize\n\tif pruneHeight > 0 {\n\t\tdefer func() {\n\t\t\tif err := e.blockMetaAccessor.PruneBlockMeta(pruneHeight); err != nil {\n\t\t\t\te.logger.Err(err).Msgf(\"fail to prune block meta, height(%d)\", pruneHeight)\n\t\t\t}\n\t\t}()\n\t}\n\tif e.gasPriceChanged {\n\t\t\n\t\tgasPrice := e.GetGasPrice() \n\t\t\n\t\tgasPriceForThorchain := big.NewInt(0).Div(gasPrice, big.NewInt(common.One*100))\n\t\tgasValue := gasPriceForThorchain.Uint64()\n\t\tif gasValue == 0 {\n\t\t\tgasValue = 1\n\t\t}\n\t\t\n\t\tif big.NewInt(1).Mul(big.NewInt(int64(gasValue)), big.NewInt(common.One*100)).Cmp(gasPrice) < 0 {\n\t\t\tgasValue++\n\t\t}\n\t\t\n\t\tif gasValue != e.lastReportedGasPrice {\n\t\t\te.lastReportedGasPrice = gasValue\n\t\t\tif _, err := e.bridge.PostNetworkFee(height, common.ETHChain, MaxContractGas, gasValue); err != nil {\n\t\t\t\te.logger.Err(err).Msg(\"fail to post ETH chain single transfer fee to THORNode\")\n\t\t\t}\n\t\t}\n\t}\n\treturn txIn, nil\n}", "func (e *ETHScanner) processBlock(block *etypes.Block) (stypes.TxIn, error) {\n\theight := int64(block.NumberU64())\n\ttxIn := stypes.TxIn{\n\t\tChain: common.ETHChain,\n\t\tTxArray: nil,\n\t\tFiltered: false,\n\t\tMemPool: false,\n\t\tSentUnFinalised: false,\n\t\tFinalised: false,\n\t}\n\t\n\te.updateGasPrice()\n\tfunc processReorg(...) {...}\nfunc extractTxs(...) {...}\nreorgedTxIns, err := e.processReorg(block.Header())\n\tif err != nil {\n\t\te.logger.Error().Err(err).Msgf(\"fail to process reorg for block %d\", height)\n\t\treturn txIn, err\n\t}\n\tif len(reorgedTxIns) > 0 {\n\t\tfor _, item := range reorgedTxIns {\n\t\t\tif len(item.TxArray) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttxIn.TxArray = append(txIn.TxArray, item.TxArray...)\n\t\t}\n\t}\n\tif block.Transactions().Len() == 0 {\n\t\treturn txIn, nil\n\t}\n\ttxInBlock, err := e.extractTxs(block)\n\tif err != nil {\n\t\treturn txIn, err\n\t}\n\tif len(txInBlock.TxArray) > 0 {\n\t\ttxIn.TxArray = append(txIn.TxArray, txInBlock.TxArray...)\n\t}\n\treturn txIn, nil\n}", "func (e *ETHScanner) extractTxs(block *etypes.Block) (stypes.TxIn, error) {\n\ttxInbound := stypes.TxIn{\n\t\tChain: common.ETHChain,\n\t\tFiltered: false,\n\t\tMemPool: false,\n\t}\n\tfor _, tx := range block.Transactions() {\n\t\tif tx.To() == nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif err := e.blockMetaAccessor.RemoveSignedTxItem(tx.Hash().String()); err != nil {\n\t\t\te.logger.Err(err).Msgf(\"fail to remove signed tx item, hash:%s\", tx.Hash().String())\n\t\t}\n\t\tfunc fromTxToTxIn(...) {...}\ntxInItem, err := e.fromTxToTxIn(tx)\n\t\tif err != nil {\n\t\t\te.logger.Error().Err(err).Str(\"hash\", tx.Hash().Hex()).Msg(\"fail to get one tx from server\")\n\t\t\t\n\t\t\t\n\t\t\tif errors.Is(err, etypes.ErrInvalidChainId) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\te.errCounter.WithLabelValues(\"fail_get_tx\", \"\").Inc()\n\t\t\t\n\t\t\t\n\t\t\treturn stypes.TxIn{}, fmt.Errorf(\"fail to get one tx from server: %w\", err)\n\t\t}\n\t\tif txInItem == nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tif len(txInItem.To) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif len([]byte(txInItem.Memo)) > constants.MaxMemoSize {\n\t\t\tcontinue\n\t\t}\n\t\ttxInItem.BlockHeight = block.Number().Int64()\n\t\ttxInbound.TxArray = append(txInbound.TxArray, *txInItem)\n\t\te.logger.Debug().Str(\"hash\", tx.Hash().Hex()).Msgf(\"%s got %d tx\", e.cfg.ChainID, 1)\n\t}\n\tif len(txInbound.TxArray) == 0 {\n\t\te.logger.Info().Int64(\"block\", int64(block.NumberU64())).Msg(\"no tx need to be processed in this block\")\n\t\treturn stypes.TxIn{}, nil\n\t}\n\ttxInbound.Count = strconv.Itoa(len(txInbound.TxArray))\n\te.logger.Debug().Int64(\"block\", int64(block.NumberU64())).Msgf(\"there are %s tx in this block need to process\", txInbound.Count)\n\treturn txInbound, nil\n}", "func (e *ETHScanner) fromTxToTxIn(tx *etypes.Transaction) (*stypes.TxInItem, error) {\n\tif tx == nil || tx.To() == nil {\n\t\treturn nil, nil\n\t}\n\treceipt, err := e.getReceipt(tx.Hash().Hex())\n\tif err != nil {\n\t\tif errors.Is(err, ethereum.NotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"fail to get transaction receipt: %w\", err)\n\t}\n\tif receipt.Status != 1 {\n\t\te.logger.Debug().Msgf(\"tx(%s) state: %d means failed , ignore\", tx.Hash().String(), receipt.Status)\n\t\treturn nil, nil\n\t}\n\tfunc isToSmartContract(...) {...}\nfunc getTxInFromSmartContract(...) {...}\nfunc getTxInFromTransaction(...) {...}\nsmartContract := e.isToSmartContract(receipt)\n\tif smartContract {\n\t\treturn e.getTxInFromSmartContract(tx, receipt)\n\t}\n\treturn e.getTxInFromTransaction(tx)\n}", "func (e *ETHScanner) getTxInFromSmartContract(tx *etypes.Transaction, receipt *etypes.Receipt) (*stypes.TxInItem, error) {\n\te.logger.Debug().Msg(\"parse tx from smart contract\")\n\ttxInItem := &stypes.TxInItem{\n\t\tTx: tx.Hash().Hex()[2:],\n\t}\n\tsender, err := e.eipSigner.Sender(tx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fail to get sender: %w\", err)\n\t}\n\ttxInItem.Sender = strings.ToLower(sender.String())\n\t\n\tif receipt.Status != 1 {\n\t\te.logger.Info().Msgf(\"tx(%s) state: %d means failed , ignore\", tx.Hash().String(), receipt.Status)\n\t\treturn nil, nil\n\t}\n\tfor _, item := range receipt.Logs {\n\t\tswitch item.Topics[0].String() {\n\t\tcase depositEvent:\n\t\t\tdepositEvt, err := e.parseDeposit(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse deposit event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"deposit:%+v\", depositEvt)\n\t\t\ttxInItem.To = depositEvt.To.String()\n\t\t\ttxInItem.Memo = depositEvt.Memo\n\t\t\tfunc getAssetFromTokenAddress(...) {...}\nasset, err := e.getAssetFromTokenAddress(depositEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(depositEvt.Asset.String())\n\t\t\te.logger.Info().Msgf(\"token:%s,decimals:%d\", depositEvt.Asset, decimals)\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(depositEvt.Asset.String(), depositEvt.Amount)).WithDecimals(decimals))\n\t\tcase transferOutEvent:\n\t\t\ttransferOutEvt, err := e.parseTransferOut(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse transfer out event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"transfer out: %+v\", transferOutEvt)\n\t\t\ttxInItem.Sender = transferOutEvt.Vault.String()\n\t\t\ttxInItem.To = transferOutEvt.To.String()\n\t\t\ttxInItem.Memo = transferOutEvt.Memo\n\t\t\tasset, err := e.getAssetFromTokenAddress(transferOutEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(transferOutEvt.Asset.String())\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(transferOutEvt.Asset.String(), transferOutEvt.Amount)).WithDecimals(decimals))\n\t\tcase transferAllowanceEvent:\n\t\t\ttransferAllowanceEvt, err := e.parseTransferAllowanceEvent(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse transfer allowance event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"transfer allowance: %+v\", transferAllowanceEvt)\n\t\t\ttxInItem.Sender = transferAllowanceEvt.OldVault.String()\n\t\t\ttxInItem.To = transferAllowanceEvt.NewVault.String()\n\t\t\ttxInItem.Memo = transferAllowanceEvt.Memo\n\t\t\tasset, err := e.getAssetFromTokenAddress(transferAllowanceEvt.Asset.String())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t}\n\t\t\tdecimals := e.getTokenDecimalsForTHORChain(transferAllowanceEvt.Asset.String())\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(transferAllowanceEvt.Asset.String(), transferAllowanceEvt.Amount)).WithDecimals(decimals))\n\t\tcase vaultTransferEvent:\n\t\t\ttransferEvent, err := e.parseVaultTransfer(*item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"fail to parse vault transfer event: %w\", err)\n\t\t\t}\n\t\t\te.logger.Info().Msgf(\"vault transfer: %+v\", transferEvent)\n\t\t\ttxInItem.Sender = transferEvent.OldVault.String()\n\t\t\ttxInItem.To = transferEvent.NewVault.String()\n\t\t\ttxInItem.Memo = transferEvent.Memo\n\t\t\tfor _, item := range transferEvent.Coins {\n\t\t\t\tasset, err := e.getAssetFromTokenAddress(item.Asset.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"fail to get asset from token address: %w\", err)\n\t\t\t\t}\n\t\t\t\tdecimals := e.getTokenDecimalsForTHORChain(item.Asset.String())\n\t\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, e.convertAmount(item.Asset.String(), item.Amount)).WithDecimals(decimals))\n\t\t\t}\n\t\t}\n\t}\n\t\n\tethValue := cosmos.NewUintFromBigInt(tx.Value())\n\tif !ethValue.IsZero() {\n\t\tethValue = e.convertAmount(ethToken, tx.Value())\n\t\tif txInItem.Coins.GetCoin(common.ETHAsset).IsEmpty() && !ethValue.IsZero() {\n\t\t\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(common.ETHAsset, ethValue))\n\t\t}\n\t}\n\te.logger.Info().Msgf(\"tx: %s, gas price: %s, gas used: %d,receipt status:%d\", txInItem.Tx, tx.GasPrice().String(), receipt.GasUsed, receipt.Status)\n\t\n\ttxGasPrice := tx.GasPrice()\n\tif txGasPrice.Cmp(big.NewInt(tenGwei)) < 0 {\n\t\ttxGasPrice = big.NewInt(tenGwei)\n\t}\n\ttxInItem.Gas = common.MakeETHGas(txGasPrice, receipt.GasUsed)\n\tif txInItem.Coins.IsEmpty() {\n\t\te.logger.Debug().Msgf(\"there is no coin in this tx, ignore, %+v\", txInItem)\n\t\treturn nil, nil\n\t}\n\te.logger.Debug().Msgf(\"tx in item: %+v\", txInItem)\n\treturn txInItem, nil\n}", "func (e *ETHScanner) getAssetFromTokenAddress(token string) (common.Asset, error) {\n\tif IsETH(token) {\n\t\treturn common.ETHAsset, nil\n\t}\n\tfunc getTokenMeta(...) {...}\ntokenMeta, err := e.getTokenMeta(token)\n\tif err != nil {\n\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tasset := common.ETHAsset\n\tif tokenMeta.Symbol != common.ETHChain.String() {\n\t\tasset, err = common.NewAsset(fmt.Sprintf(\"ETH.%s-%s\", tokenMeta.Symbol, strings.ToUpper(tokenMeta.Address)))\n\t\tif err != nil {\n\t\t\treturn common.EmptyAsset, fmt.Errorf(\"fail to create asset: %w\", err)\n\t\t}\n\t}\n\treturn asset, nil\n}", "func (e *ETHScanner) getTokenMeta(token string) (types.TokenMeta, error) {\n\ttokenMeta, err := e.tokens.GetTokenMeta(token)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get token meta: %w\", err)\n\t}\n\tif tokenMeta.IsEmpty() {\n\t\tfunc getSymbol(...) {...}\nsymbol, err := e.getSymbol(token)\n\t\tif err != nil {\n\t\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get symbol: %w\", err)\n\t\t}\n\t\tdecimals, err := e.getDecimals(token)\n\t\tif err != nil {\n\t\t\te.logger.Err(err).Msgf(\"fail to get decimals from smart contract, default to: %d\", defaultDecimals)\n\t\t}\n\t\te.logger.Info().Msgf(\"token:%s, decimals: %d\", token, decimals)\n\t\ttokenMeta = types.NewTokenMeta(symbol, token, decimals)\n\t\tif err = e.tokens.SaveTokenMeta(symbol, token, decimals); err != nil {\n\t\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to save token meta: %w\", err)\n\t\t}\n\t}\n\treturn tokenMeta, nil\n}", "func (t *LevelDBTokenMeta) GetTokenMeta(address string) (types.TokenMeta, error) {\n\tfunc getTokenMetaKey(...) {...}\nkey := t.getTokenMetaKey(address)\n\texist, err := t.db.Has([]byte(key), nil)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to check whether token meta(%s) exist: %w\", key, err)\n\t}\n\tif !exist {\n\t\treturn types.TokenMeta{}, nil\n\t}\n\tv, err := t.db.Get([]byte(key), nil)\n\tif err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to get token meta(%s) from storage: %w\", key, err)\n\t}\n\tvar tm types.TokenMeta\n\tif err := json.Unmarshal(v, &tm); err != nil {\n\t\treturn types.TokenMeta{}, fmt.Errorf(\"fail to unmarshal token meta from json: %w\", err)\n\t}\n\treturn tm, nil\n}", "func (e *ETHScanner) getSymbol(token string) (string, error) {\n\tif IsETH(token) {\n\t\treturn \"ETH\", nil\n\t}\n\tto := ecommon.HexToAddress(token)\n\tinput, err := e.erc20ABI.Pack(symbolMethod)\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\tctx, cancel := e.getContext()\n\tdefer cancel()\n\tres, err := e.client.CallContract(ctx, ethereum.CallMsg{\n\t\tTo: &to,\n\t\tData: input,\n\t}, nil)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"fail to call to smart contract and get symbol: %w\", err)\n\t}\n\toutput, err := e.erc20ABI.Unpack(symbolMethod, res)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"fail to unpack symbol method call: %w\", err)\n\t}\n\tsymbol := *abi.ConvertType(output[0], new(string)).(*string)\n\treturn sanitiseSymbol(symbol), nil\n}", "func (t *LevelDBTokenMeta) SaveTokenMeta(symbol, address string, decimals uint64) error {\n\tfunc getTokenMetaKey(...) {...}\nkey := t.getTokenMetaKey(address)\n\ttokenMeta := types.NewTokenMeta(symbol, address, decimals)\n\tbuf, err := json.Marshal(tokenMeta)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"fail to marshal token meta to json: %w\", err)\n\t}\n\treturn t.db.Put([]byte(key), buf, nil)\n}", "func (e *ETHScanner) getTxInFromTransaction(tx *etypes.Transaction) (*stypes.TxInItem, error) {\n\ttxInItem := &stypes.TxInItem{\n\t\tTx: tx.Hash().Hex()[2:],\n\t}\n\tasset := common.ETHAsset\n\tsender, err := e.eipSigner.Sender(tx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fail to get sender: %w\", err)\n\t}\n\ttxInItem.Sender = strings.ToLower(sender.String())\n\ttxInItem.To = strings.ToLower(tx.To().String())\n\t\n\tdata := tx.Data()\n\tif len(data) > 0 {\n\t\tmemo, err := hex.DecodeString(string(data))\n\t\tif err != nil {\n\t\t\ttxInItem.Memo = string(data)\n\t\t} else {\n\t\t\ttxInItem.Memo = string(memo)\n\t\t}\n\t}\n\tethValue := e.convertAmount(ethToken, tx.Value())\n\ttxInItem.Coins = append(txInItem.Coins, common.NewCoin(asset, ethValue))\n\ttxGasPrice := tx.GasPrice()\n\tif txGasPrice.Cmp(big.NewInt(tenGwei)) < 0 {\n\t\ttxGasPrice = big.NewInt(tenGwei)\n\t}\n\ttxInItem.Gas = common.MakeETHGas(txGasPrice, tx.Gas())\n\tif txInItem.Coins.IsEmpty() {\n\t\te.logger.Debug().Msgf(\"there is no coin in this tx, ignore, %+v\", txInItem)\n\t\treturn nil, nil\n\t}\n\treturn txInItem, nil\n}"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "wormhole", "functions": ["fn verify_signatures(\n ctx: &ExecutionContext,\n accs: &mut VerifySignatures,\n data: VerifySignaturesData,\n) -> Result<()> {\n accs.guardian_set\n .verify_derivation(ctx.program_id, &(&*accs).into())?;\n let sig_infos: Vec<SigInfo> = data\n .signers\n .iter()\n .enumerate()\n .filter_map(|(i, p)| {\n if *p == -1 {\n return None;\n }\n return Some(SigInfo {\n sig_index: *p as u8,\n signer_index: i as u8,\n });\n })\n .collect();\n let current_instruction = solana_program::sysvar::instructions::load_current_index(\n &accs.instruction_acc.try_borrow_mut_data()?,\n );\n if current_instruction == 0 {\n return Err(InstructionAtWrongIndex.into());\n }\n \n let secp_ix_index = (current_instruction - 1) as u8;\n let secp_ix = solana_program::sysvar::instructions::load_instruction_at(\n secp_ix_index as usize,\n &accs.instruction_acc.try_borrow_mut_data()?,\n )\n .map_err(|_| ProgramError::InvalidAccountData)?;\n \n if secp_ix.program_id != solana_program::secp256k1_program::id() {\n return Err(InvalidSecpInstruction.into());\n }\n let secp_data_len = secp_ix.data.len();\n if secp_data_len < 2 {\n return Err(InvalidSecpInstruction.into());\n }\n let sig_len = secp_ix.data[0];\n let mut index = 1;\n let mut secp_ixs: Vec<SecpInstructionPart> = Vec::with_capacity(sig_len as usize);\n for i in 0..sig_len {\n let _sig_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]) as usize;\n index += 2;\n let sig_ix = secp_ix.data[index];\n index += 1;\n let address_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]) as usize;\n index += 2;\n let address_ix = secp_ix.data[index];\n index += 1;\n let msg_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]);\n index += 2;\n let msg_size = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]);\n index += 2;\n let msg_ix = secp_ix.data[index];\n index += 1;\n if address_ix != secp_ix_index || msg_ix != secp_ix_index || sig_ix != secp_ix_index {\n return Err(InvalidSecpInstruction.into());\n }\n let address: &[u8] = &secp_ix.data[address_offset..address_offset + 20];\n \n if i > 0 {\n if msg_offset != secp_ixs[0].msg_offset || msg_size != secp_ixs[0].msg_size {\n return Err(InvalidSecpInstruction.into());\n }\n }\n secp_ixs.push(SecpInstructionPart {\n address,\n msg_offset,\n msg_size,\n });\n }\n if sig_infos.len() != secp_ixs.len() {\n return Err(ProgramError::InvalidArgument.into());\n }\n \n if secp_ixs[0].msg_size != 32 {\n return Err(ProgramError::InvalidArgument.into());\n }\n \n let message = &secp_ix.data\n [secp_ixs[0].msg_offset as usize..(secp_ixs[0].msg_offset + secp_ixs[0].msg_size) as usize];\n \n let mut msg_hash: [u8; 32] = [0u8; 32];\n msg_hash.copy_from_slice(message);\n if !accs.signature_set.is_initialized() {\n accs.signature_set.signatures = vec![false; accs.guardian_set.keys.len()];\n accs.signature_set.guardian_set_index = accs.guardian_set.index;\n accs.signature_set.hash = msg_hash;\n let size = accs.signature_set.size();\n let ix = solana_program::system_instruction::create_account(\n accs.payer.key,\n accs.signature_set.info().key,\n Exempt.amount(size),\n size as u64,\n ctx.program_id,\n );\n solana_program::program::invoke(&ix, ctx.accounts)?;\n } else {\n \n if accs.signature_set.guardian_set_index != accs.guardian_set.index {\n return Err(GuardianSetMismatch.into());\n }\n if accs.signature_set.hash != msg_hash {\n return Err(InvalidHash.into());\n }\n }\n \n for s in sig_infos {\n if s.signer_index > accs.guardian_set.num_guardians() {\n return Err(ProgramError::InvalidArgument.into());\n }\n if s.sig_index + 1 > sig_len {\n return Err(ProgramError::InvalidArgument.into());\n }\n let key = accs.guardian_set.keys[s.signer_index as usize];\n \n if key != secp_ixs[s.sig_index as usize].address {\n return Err(ProgramError::InvalidArgument.into());\n }\n \n accs.signature_set.signatures[s.signer_index as usize] = true;\n }\n Ok(())\n}"], "label": "Yes", "detail": "The attacker used a forged sysvar account to call the \"verify_signatures\" function. The function \"load_current_index\" used inside did not verify whether the provided sysvar account was the legitimate system sysvar. This allowed the attacker to bypass signature verification, create a malicious VAA claiming to mint 120,000 WETH, and ultimately transfer the minted tokens to Ethereum."}
{"project": "wormhole", "functions": ["fn post_vaa(ctx: &ExecutionContext, accs: &mut PostVAA, vaa: PostVAAData) -> Result<()> {\n let msg_derivation = PostedVAADerivationData {\n payload_hash: hash_vaa(&vaa).to_vec(),\n };\n accs.message\n .verify_derivation(ctx.program_id, &msg_derivation)?;\n \n if !accs.message.is_initialized() {\n accs.message.nonce = vaa.nonce;\n accs.message.emitter_chain = vaa.emitter_chain;\n accs.message.emitter_address = vaa.emitter_address;\n accs.message.sequence = vaa.sequence;\n accs.message.payload = vaa.payload;\n accs.message.consistency_level = vaa.consistency_level;\n accs.message\n .create(&msg_derivation, ctx, accs.payer.key, Exempt)?;\n }\n \n accs.message.vaa_version = vaa.version;\n accs.message.vaa_time = vaa.timestamp;\n accs.message.vaa_signature_account = *accs.signature_set.info().key;\n Ok(())\n}", "fn complete_wrapped(\n ctx: &ExecutionContext,\n accs: &mut CompleteWrapped,\n _data: CompleteWrappedData,\n) -> Result<()> {\n \n let derivation_data: EndpointDerivationData = (&*accs).into();\n accs.chain_registration\n .verify_derivation(ctx.program_id, &derivation_data)?;\n \n accs.wrapped_meta.verify_derivation(\n ctx.program_id,\n &WrappedMetaDerivationData {\n mint_key: *accs.mint.info().key,\n },\n )?;\n if accs.wrapped_meta.token_address != accs.vaa.token_address\n || accs.wrapped_meta.chain != accs.vaa.token_chain\n {\n return Err(InvalidMint.into());\n }\n \n if *accs.mint.info().key != accs.to.mint {\n return Err(InvalidMint.into());\n }\n if *accs.mint.info().key != accs.to_fees.mint {\n return Err(InvalidMint.into());\n }\n \n if accs.vaa.to_chain != CHAIN_ID_SOLANA {\n return Err(InvalidChain.into());\n }\n if accs.vaa.to != accs.to.info().key.to_bytes() {\n return Err(InvalidRecipient.into());\n }\n if INVALID_VAAS.contains(&&*accs.vaa.info().key.to_string()) {\n return Err(InvalidVAA.into());\n }\n claim::consume(ctx, accs.payer.key, &mut accs.claim, &accs.vaa)?;\n let token_amount: u64 = accs\n .vaa\n .amount\n .as_u64()\n .checked_sub(accs.vaa.fee.as_u64())\n .ok_or(SolitaireError::InsufficientFunds)?;\n \n let mint_ix = spl_token::instruction::mint_to(\n &spl_token::id(),\n accs.mint.info().key,\n accs.to.info().key,\n accs.mint_authority.key,\n &[],\n token_amount,\n )?;\n invoke_seeded(&mint_ix, ctx, &accs.mint_authority, None)?;\n \n let mint_ix = spl_token::instruction::mint_to(\n &spl_token::id(),\n accs.mint.info().key,\n accs.to_fees.info().key,\n accs.mint_authority.key,\n &[],\n accs.vaa.fee.as_u64(),\n )?;\n invoke_seeded(&mint_ix, ctx, &accs.mint_authority, None)?;\n Ok(())\n}"], "label": "Yes", "detail": "The attacker used a forged sysvar account to call the \"verify_signatures\" function. The function \"load_current_index\" used inside did not verify whether the provided sysvar account was the legitimate system sysvar. This allowed the attacker to bypass signature verification, create a malicious VAA claiming to mint 120,000 WETH, and ultimately transfer the minted tokens to Ethereum."}
{"project": "wormhole", "functions": ["fn transfer_wrapped(\n ctx: &ExecutionContext,\n accs: &mut TransferWrapped,\n data: TransferWrappedData,\n) -> Result<()> {\n \n if data.target_chain == CHAIN_ID_SOLANA {\n return Err(InvalidChain.into());\n }\n let derivation_data: WrappedMetaDerivationData = (&*accs).into();\n verify_and_execute_wrapped_transfers(\n ctx,\n &derivation_data,\n &accs.payer,\n &accs.from,\n &accs.from_owner,\n &accs.mint,\n &accs.wrapped_meta,\n &accs.authority_signer,\n &accs.bridge,\n &accs.fee_collector,\n data.amount,\n data.fee,\n )?;\n \n let payload = PayloadTransfer {\n amount: U256::from(data.amount),\n token_address: accs.wrapped_meta.token_address,\n token_chain: accs.wrapped_meta.chain,\n to: data.target_address,\n to_chain: data.target_chain,\n fee: U256::from(data.fee),\n };\n let params = (\n bridge::instruction::Instruction::PostMessage,\n PostMessageData {\n nonce: data.nonce,\n payload: payload.try_to_vec()?,\n consistency_level: ConsistencyLevel::Finalized,\n },\n );\n let ix = Instruction::new_with_bytes(\n accs.config.wormhole_bridge,\n params.try_to_vec()?.as_slice(),\n vec![\n AccountMeta::new(*accs.bridge.info().key, false),\n AccountMeta::new(*accs.message.key, true),\n AccountMeta::new_readonly(*accs.emitter.key, true),\n AccountMeta::new(*accs.sequence.key, false),\n AccountMeta::new(*accs.payer.key, true),\n AccountMeta::new(*accs.fee_collector.key, false),\n AccountMeta::new_readonly(*accs.clock.info().key, false),\n AccountMeta::new_readonly(solana_program::system_program::id(), false),\n AccountMeta::new_readonly(solana_program::sysvar::rent::ID, false),\n ],\n );\n invoke_seeded(&ix, ctx, &accs.emitter, None)?;\n Ok(())\n}", "fn verify_and_execute_wrapped_transfers(\n ctx: &ExecutionContext,\n derivation_data: &WrappedMetaDerivationData,\n payer: &Mut<Signer<AccountInfo>>,\n from: &Mut<Data<SplAccount, { AccountState::Initialized }>>,\n from_owner: &MaybeMut<Signer<Info>>,\n mint: &Mut<WrappedMint<{ AccountState::Initialized }>>,\n wrapped_meta: &WrappedTokenMeta<{ AccountState::Initialized }>,\n authority_signer: &AuthoritySigner,\n bridge: &Mut<CoreBridge<{ AccountState::Initialized }>>,\n fee_collector: &Mut<Info>,\n amount: u64,\n fee: u64,\n) -> Result<()> {\n \n if &from.owner != from_owner.key {\n return Err(WrongAccountOwner.into());\n }\n \n if mint.info().key != &from.mint {\n return Err(TokenBridgeError::InvalidMint.into());\n }\n \n if fee > amount {\n return Err(InvalidFee.into());\n }\n \n wrapped_meta.verify_derivation(ctx.program_id, derivation_data)?;\n \n let burn_ix = spl_token::instruction::burn(\n &spl_token::id(),\n from.info().key,\n mint.info().key,\n authority_signer.key,\n &[],\n amount,\n )?;\n invoke_seeded(&burn_ix, ctx, authority_signer, None)?;\n \n let transfer_ix = solana_program::system_instruction::transfer(\n payer.key,\n fee_collector.key,\n bridge.config.fee,\n );\n invoke(&transfer_ix, ctx.accounts)?;\n Ok(())\n}", "function _completeTransfer(bytes memory encodedVm, bool unwrapWETH) internal returns (bytes memory) {\n (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n require(valid, reason);\n function verifyBridgeVM(...) {...}\nrequire(verifyBridgeVM(vm), \"invalid emitter\");\n BridgeStructs.Transfer memory transfer = _parseTransferCommon(vm.payload);\n \n address transferRecipient = _truncateAddress(transfer.to);\n if (transfer.payloadID == 3) {\n require(msg.sender == transferRecipient, \"invalid sender\");\n }\n require(!isTransferCompleted(vm.hash), \"transfer already completed\");\n setTransferCompleted(vm.hash);\n \n emit TransferRedeemed(vm.emitterChainId, vm.emitterAddress, vm.sequence);\n require(transfer.toChain == chainId(), \"invalid target chain\");\n IERC20 transferToken;\n if (transfer.tokenChain == chainId()) {\n transferToken = IERC20(_truncateAddress(transfer.tokenAddress));\n \n bridgedIn(address(transferToken), transfer.amount);\n } else {\n address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\n require(wrapped != address(0), \"no wrapper for this token created yet\");\n transferToken = IERC20(wrapped);\n }\n require(unwrapWETH == false || address(transferToken) == address(WETH()), \"invalid token, can only unwrap WETH\");\n \n (,bytes memory queriedDecimals) = address(transferToken).staticcall(abi.encodeWithSignature(\"decimals()\"));\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n \n uint256 nativeAmount = deNormalizeAmount(transfer.amount, decimals);\n uint256 nativeFee = deNormalizeAmount(transfer.fee, decimals);\n \n if (nativeFee > 0 && transferRecipient != msg.sender) {\n require(nativeFee <= nativeAmount, \"fee higher than transferred amount\");\n if (unwrapWETH) {\n WETH().withdraw(nativeFee);\n payable(msg.sender).transfer(nativeFee);\n } else {\n if (transfer.tokenChain != chainId()) {\n \n TokenImplementation(address(transferToken)).mint(msg.sender, nativeFee);\n } else {\n SafeERC20.safeTransfer(transferToken, msg.sender, nativeFee);\n }\n }\n } else {\n \n nativeFee = 0;\n }\n \n uint transferAmount = nativeAmount - nativeFee;\n if (unwrapWETH) {\n WETH().withdraw(transferAmount);\n payable(transferRecipient).transfer(transferAmount);\n } else {\n if (transfer.tokenChain != chainId()) {\n \n TokenImplementation(address(transferToken)).mint(transferRecipient, transferAmount);\n } else {\n SafeERC20.safeTransfer(transferToken, transferRecipient, transferAmount);\n }\n }\n return vm.payload;\n }"], "label": "Yes", "detail": "The attacker used a forged sysvar account to call the \"verify_signatures\" function. The function \"load_current_index\" used inside did not verify whether the provided sysvar account was the legitimate system sysvar. This allowed the attacker to bypass signature verification, create a malicious VAA claiming to mint 120,000 WETH, and ultimately transfer the minted tokens to Ethereum."}
{"project": "wormhole", "functions": ["func (v *VAA) AddSignature(key *ecdsa.PrivateKey, index uint8) {\n\tfunc SigningDigest(...) {...}\nfunc Bytes(...) {...}\nsig, err := crypto.Sign(v.SigningDigest().Bytes(), key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tsigData := [65]byte{}\n\tcopy(sigData[:], sig)\n\tv.Signatures = append(v.Signatures, &Signature{\n\t\tIndex: index,\n\t\tSignature: sigData,\n\t})\n}"], "label": "No", "detail": "No known vulnerability found in this function group."}

{"project": "BoringDAO Bridge", "functions": ["function pledge(\n bytes32 _tunnelKey,\n uint256 _amount\n ) public override whenNotPaused whenContractExist(_tunnelKey) {\n require(\n borERC20().allowance(msg.sender, address(this)) >= _amount,\n \"not allow enough boring\"\n );\n\n borERC20().transferFrom(\n msg.sender,\n address(tunnel(_tunnelKey)),\n _amount\n );\n\n tunnel(_tunnelKey).pledge(msg.sender, _amount);\n }", "function unlock(\n address token0,\n uint256 chainID,\n address from,\n address to,\n uint256 amount,\n string memory txid\n )\n public\n onlySupportToken(token0, chainID)\n onlyCrosser(token0, chainID)\n whenNotUnlocked(txid)\n {\n bool result = _vote(token0, from, to, amount, txid);\n\n if (result) {\n txUnlocked[txid] = true;\n\n function safeTransfer(...) {...}\nIERC20Upgradeable(token0).safeTransfer(to, amount);\n\n address token1 = supportToken[token0][chainID];\n\n emit Unlock(token0, token1, chainID, from, to, amount, txid);\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "BoringDAO Bridge", "functions": ["function redeem(\n bytes32 _tunnelKey,\n uint256 _amount\n ) public override whenNotPaused whenContractExist(_tunnelKey) {\n function redeem(...) {...}\nfunction tunnel(...) {...}\ntunnel(_tunnelKey).redeem(msg.sender, _amount);\n }", "function lock(\n address token0,\n uint256 chainID,\n address to,\n uint256 amount\n ) public onlySupportToken(token0, chainID) {\n IERC20Upgradeable(token0).safeTransferFrom(\n msg.sender,\n address(this),\n amount\n );\n\n emit Lock(\n token0,\n supportToken[token0][chainID],\n chainID,\n msg.sender,\n to,\n amount\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "BoringDAO Bridge", "functions": ["function approveMint(\n bytes32 _tunnelKey,\n string memory _txid,\n uint256 _amount,\n address to,\n string memory assetAddress\n )\n public\n override\n whenNotPaused\n whenTunnelNotPause(_tunnelKey)\n onlyTrustee(_tunnelKey)\n shouldMoreThan(_tunnelKey, _amount)\n {\n if (to == address(0)) {\n if (approveFlag[_txid] == false) {\n approveFlag[_txid] = true;\n\n emit ETHAddressNotExist(\n _tunnelKey,\n _txid,\n _amount,\n to,\n msg.sender,\n assetAddress\n );\n }\n\n return;\n }\n\n uint256 trusteeCount = getRoleMemberCount(_tunnelKey);\n\n bool shouldMint = mintProposal().approve(\n _tunnelKey,\n _txid,\n _amount,\n to,\n msg.sender,\n trusteeCount\n );\n\n if (!shouldMint) {\n return;\n }\n\n uint256 canIssueAmount = tunnel(_tunnelKey).canIssueAmount();\n\n if (_amount.add(otoken(_tunnelKey).totalSupply()) > canIssueAmount) {\n emit NotEnoughPledgeValue(\n _tunnelKey,\n _txid,\n _amount,\n to,\n msg.sender,\n assetAddress\n );\n\n return;\n }\n\n \n\n function tunnel(...) {...}\ntunnel(_tunnelKey).issue(to, _amount);\n\n uint borMintAmount = calculateMintBORAmount(_tunnelKey, _amount);\n\n if (borMintAmount != 0) {\n amountByMint = amountByMint.add(borMintAmount);\n\n borERC20().transferFrom(mine, to, borMintAmount);\n }\n\n emit ApproveMintSuccess(_tunnelKey, _txid, _amount, to, assetAddress);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "BoringDAO Bridge", "functions": ["function burnBToken(\n bytes32 _tunnelKey,\n uint256 amount,\n string memory assetAddress\n )\n public\n override\n whenNotPaused\n whenContractExist(_tunnelKey)\n whenTunnelNotPause(_tunnelKey)\n {\n function tunnel(...) {...}\ntunnel(_tunnelKey).burn(msg.sender, amount, assetAddress);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Celo Optics Bridge", "functions": ["function send(\n address _token,\n uint256 _amount,\n uint32 _destination,\n bytes32 _recipient\n ) external {\n require(_amount > 0, \"!amnt\");\n\n require(_recipient != bytes32(0), \"!recip\");\n\n \n\n bytes32 _remote = _mustHaveRemote(_destination);\n\n \n\n IERC20 _bridgeToken = IERC20(_token);\n\n if (_isLocalOrigin(_bridgeToken)) {\n \n\n \n\n _bridgeToken.safeTransferFrom(msg.sender, address(this), _amount);\n } else {\n \n\n \n\n _downcast(_bridgeToken).burn(msg.sender, _amount);\n }\n\n \n\n bytes29 _action = BridgeMessage.formatTransfer(_recipient, _amount);\n\n \n\n Home(xAppConnectionManager.home()).dispatch(\n _destination,\n _remote,\n BridgeMessage.formatMessage(_formatTokenId(_token), _action)\n );\n\n \n\n emit Send(\n address(_bridgeToken),\n msg.sender,\n _destination,\n _recipient,\n _amount\n );\n }", "function _mustHaveRemote(uint32 _domain)\n\n internal\n\n view\n\n returns (bytes32 _remote)\n\n {\n\n _remote = remotes[_domain];\n\n require(_remote != bytes32(0), \"!remote\");\n\n }", "function formatMessage(\n bytes29 _tokenId,\n bytes29 _action\n ) internal view typeAssert(_tokenId, Types.TokenId) returns (bytes memory) {\n function isValidAction(...) {...}\nrequire(isValidAction(_action), \"!action\");\n\n bytes29[] memory _views = new bytes29[](2);\n\n _views[0] = _tokenId;\n\n _views[1] = _action;\n\n return TypedMemView.join(_views);\n }", "function dispatch(\n uint32 _destinationDomain,\n bytes32 _recipientAddress,\n bytes memory _messageBody\n ) external notFailed {\n require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \"msg too long\");\n\n \n\n uint32 _nonce = nonces[_destinationDomain];\n\n nonces[_destinationDomain] = _nonce + 1;\n\n \n\n bytes memory _message = Message.formatMessage(\n localDomain,\n bytes32(uint256(uint160(msg.sender))),\n _nonce,\n _destinationDomain,\n _recipientAddress,\n _messageBody\n );\n\n \n\n bytes32 _messageHash = keccak256(_message);\n\n tree.insert(_messageHash);\n\n \n\n queue.enqueue(root());\n\n \n\n \n\n emit Dispatch(\n _messageHash,\n count() - 1,\n _destinationAndNonce(_destinationDomain, _nonce),\n committedRoot,\n _message\n );\n }", "function proveAndProcess(\n bytes memory _message,\n bytes32[32] calldata _proof,\n uint256 _index\n ) external {\n function prove(...) {...}\nrequire(prove(keccak256(_message), _proof, _index), \"!prove\");\n\n process(_message);\n }", "function prove(\n bytes32 _leaf,\n bytes32[32] calldata _proof,\n uint256 _index\n ) public returns (bool) {\n \n\n require(messages[_leaf] == MessageStatus.None, \"!MessageStatus.None\");\n\n \n\n bytes32 _calculatedRoot = MerkleLib.branchRoot(_leaf, _proof, _index);\n\n \n\n if (acceptableRoot(_calculatedRoot)) {\n messages[_leaf] = MessageStatus.Proven;\n\n return true;\n }\n\n return false;\n }", "function process(bytes memory _message) public returns (bool _success) {\n bytes29 _m = _message.ref(0);\n\n \n\n require(_m.destination() == localDomain, \"!destination\");\n\n \n\n bytes32 _messageHash = _m.keccak();\n\n require(messages[_messageHash] == MessageStatus.Proven, \"!proven\");\n\n \n\n require(entered == 1, \"!reentrant\");\n\n entered = 0;\n\n \n\n messages[_messageHash] = MessageStatus.Processed;\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n require(gasleft() >= PROCESS_GAS + RESERVE_GAS, \"!gas\");\n\n \n\n address _recipient = _m.recipientAddress();\n\n \n\n uint256 _toCopy;\n\n uint256 _maxCopy = 256;\n\n uint256 _gas = PROCESS_GAS;\n\n \n\n bytes memory _returnData = new bytes(_maxCopy);\n\n bytes memory _calldata = abi.encodeWithSignature(\n \"handle(uint32,bytes32,bytes)\",\n _m.origin(),\n _m.sender(),\n _m.body().clone()\n );\n\n \n\n \n\n \n\n \n\n assembly {\n _success := call(\n _gas, \n _recipient, \n 0, \n add(_calldata, 0x20), \n mload(_calldata), \n 0, \n 0 \n )\n\n \n\n _toCopy := returndatasize()\n\n if gt(_toCopy, _maxCopy) {\n _toCopy := _maxCopy\n }\n\n \n\n mstore(_returnData, _toCopy)\n\n \n\n returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n }\n\n \n\n emit Process(_messageHash, _success, _returnData);\n\n \n\n entered = 1;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Celo Optics Bridge", "functions": ["function dispatch(\n uint32 _destinationDomain,\n bytes32 _recipientAddress,\n bytes memory _messageBody\n ) external notFailed {\n require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \"msg too long\");\n\n \n\n uint32 _nonce = nonces[_destinationDomain];\n\n nonces[_destinationDomain] = _nonce + 1;\n\n \n\n bytes memory _message = Message.formatMessage(\n localDomain,\n bytes32(uint256(uint160(msg.sender))),\n _nonce,\n _destinationDomain,\n _recipientAddress,\n _messageBody\n );\n\n \n\n bytes32 _messageHash = keccak256(_message);\n\n tree.insert(_messageHash);\n\n \n\n queue.enqueue(root());\n\n \n\n \n\n emit Dispatch(\n _messageHash,\n count() - 1,\n _destinationAndNonce(_destinationDomain, _nonce),\n committedRoot,\n _message\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Celo Optics Bridge", "functions": ["function improperUpdate(\n bytes32 _oldRoot,\n bytes32 _newRoot,\n bytes memory _signature\n ) public notFailed returns (bool) {\n require(\n _isUpdaterSignature(_oldRoot, _newRoot, _signature),\n \"!updater sig\"\n );\n\n require(_oldRoot == committedRoot, \"not a current update\");\n\n \n\n \n\n if (!queue.contains(_newRoot)) {\n _fail();\n\n emit ImproperUpdate(_oldRoot, _newRoot, _signature);\n\n return true;\n }\n\n \n\n \n\n return false;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Celo Optics Bridge", "functions": ["function _fail() internal override {\n \n\n _setFailed();\n\n \n\n updaterManager.slashUpdater(msg.sender);\n\n emit UpdaterSlashed(updater, msg.sender);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Celo Optics Bridge", "functions": ["function improperUpdate(\n bytes32 _oldRoot,\n bytes32 _newRoot,\n bytes memory _signature\n ) public notFailed returns (bool) {\n require(\n _isUpdaterSignature(_oldRoot, _newRoot, _signature),\n \"!updater sig\"\n );\n\n require(_oldRoot == committedRoot, \"not a current update\");\n\n \n\n \n\n if (!queue.contains(_newRoot)) {\n _fail();\n\n emit ImproperUpdate(_oldRoot, _newRoot, _signature);\n\n return true;\n }\n\n \n\n \n\n return false;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ChainPort", "functions": ["function freezeToken(\n address token,\n uint256 amount\n ) public isNotFrozen onlyIfAmountGreaterThanZero(amount) {\n IERC20 ercToken = IERC20(token);\n\n bool result = ercToken.transferFrom(\n address(msg.sender),\n address(this),\n amount\n );\n\n require(result, \"Transfer did not go through.\");\n\n emit TokensFreezed(token, msg.sender, amount);\n }", "function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n\n _approve(\n sender,\n _msgSender(),\n _allowances[sender][_msgSender()].sub(\n amount,\n \"ERC20: transfer amount exceeds allowance\"\n )\n );\n\n return true;\n }", "function releaseTokens(\n bytes memory signature,\n address token,\n uint256 amount,\n uint256 nonce\n ) public isNotFrozen onlyIfAmountGreaterThanZero(amount) {\n require(\n isTokenHavingPendingWithdrawal[token] == false,\n \"Token is currently having pending withdrawal.\"\n );\n\n require(isSignatureUsed[signature] == false, \"Signature already used\");\n\n isSignatureUsed[signature] = true;\n\n \n\n address beneficiary = msg.sender;\n\n \n\n bool isMessageValid = signatureValidator.verifyWithdraw(\n signature,\n token,\n amount,\n beneficiary,\n nonce\n );\n\n \n\n require(isMessageValid == true, \"Error: Signature is not valid.\");\n\n if (\n isAboveThreshold(token, amount) && isAssetProtected[token] == true\n ) {\n PendingWithdrawal memory p = PendingWithdrawal({\n amount: amount,\n beneficiary: beneficiary,\n unlockingTime: now.add(freezeLength)\n });\n\n tokenToPendingWithdrawal[token] = p;\n\n isTokenHavingPendingWithdrawal[token] = true;\n\n \n\n emit CreatedPendingWithdrawal(\n token,\n beneficiary,\n amount,\n p.unlockingTime\n );\n } else {\n bool result = IERC20(token).transfer(beneficiary, amount);\n\n require(result, \"Transfer did not go through.\");\n\n emit TokensUnfreezed(token, beneficiary, amount);\n }\n }", "function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender);\n\n _balances[sender] = _balances[sender].sub(\n amount,\n \"ERC20: transfer amount exceeds balance\"\n );\n\n _balances[recipient] = _balances[recipient].add(amount);\n\n emit Transfer(sender, recipient, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ChainPort", "functions": ["function releaseTokens(\n bytes memory signature,\n address token,\n uint256 amount,\n uint256 nonce\n ) public isNotFrozen onlyIfAmountGreaterThanZero(amount) {\n require(\n isTokenHavingPendingWithdrawal[token] == false,\n \"Token is currently having pending withdrawal.\"\n );\n\n require(isSignatureUsed[signature] == false, \"Signature already used\");\n\n isSignatureUsed[signature] = true;\n\n \n\n address beneficiary = msg.sender;\n\n \n\n bool isMessageValid = signatureValidator.verifyWithdraw(\n signature,\n token,\n amount,\n beneficiary,\n nonce\n );\n\n \n\n require(isMessageValid == true, \"Error: Signature is not valid.\");\n\n if (\n isAboveThreshold(token, amount) && isAssetProtected[token] == true\n ) {\n PendingWithdrawal memory p = PendingWithdrawal({\n amount: amount,\n beneficiary: beneficiary,\n unlockingTime: now.add(freezeLength)\n });\n\n tokenToPendingWithdrawal[token] = p;\n\n isTokenHavingPendingWithdrawal[token] = true;\n\n \n\n emit CreatedPendingWithdrawal(\n token,\n beneficiary,\n amount,\n p.unlockingTime\n );\n } else {\n bool result = IERC20(token).transfer(beneficiary, amount);\n\n require(result, \"Transfer did not go through.\");\n\n emit TokensUnfreezed(token, beneficiary, amount);\n }\n }", "function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender);\n\n _balances[sender] = _balances[sender].sub(\n amount,\n \"ERC20: transfer amount exceeds balance\"\n );\n\n _balances[recipient] = _balances[recipient].add(amount);\n\n emit Transfer(sender, recipient, amount);\n }", "function freezeToken(\n address token,\n uint256 amount\n ) public isNotFrozen onlyIfAmountGreaterThanZero(amount) {\n IERC20 ercToken = IERC20(token);\n\n bool result = ercToken.transferFrom(\n address(msg.sender),\n address(this),\n amount\n );\n\n require(result, \"Transfer did not go through.\");\n\n emit TokensFreezed(token, msg.sender, amount);\n }", "function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender);\n\n _balances[sender] = _balances[sender].sub(\n amount,\n \"ERC20: transfer amount exceeds balance\"\n );\n\n _balances[recipient] = _balances[recipient].add(amount);\n\n emit Transfer(sender, recipient, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ChainPort", "functions": ["function releaseTokens(\n bytes memory signature,\n address token,\n uint256 amount,\n uint256 nonce\n ) public isNotFrozen onlyIfAmountGreaterThanZero(amount) {\n require(\n isTokenHavingPendingWithdrawal[token] == false,\n \"Token is currently having pending withdrawal.\"\n );\n\n require(isSignatureUsed[signature] == false, \"Signature already used\");\n\n isSignatureUsed[signature] = true;\n\n \n\n address beneficiary = msg.sender;\n\n \n\n bool isMessageValid = signatureValidator.verifyWithdraw(\n signature,\n token,\n amount,\n beneficiary,\n nonce\n );\n\n \n\n require(isMessageValid == true, \"Error: Signature is not valid.\");\n\n if (\n isAboveThreshold(token, amount) && isAssetProtected[token] == true\n ) {\n PendingWithdrawal memory p = PendingWithdrawal({\n amount: amount,\n beneficiary: beneficiary,\n unlockingTime: now.add(freezeLength)\n });\n\n tokenToPendingWithdrawal[token] = p;\n\n isTokenHavingPendingWithdrawal[token] = true;\n\n \n\n emit CreatedPendingWithdrawal(\n token,\n beneficiary,\n amount,\n p.unlockingTime\n );\n } else {\n bool result = IERC20(token).transfer(beneficiary, amount);\n\n require(result, \"Transfer did not go through.\");\n\n emit TokensUnfreezed(token, beneficiary, amount);\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ChainPort", "functions": ["function approveWithdrawalAndTransferFunds(\n address token\n ) public onlyChainportCongress isNotFrozen {\n require(isTokenHavingPendingWithdrawal[token] == true);\n\n \n\n PendingWithdrawal memory p = tokenToPendingWithdrawal[token];\n\n \n\n bool result = IERC20(token).transfer(p.beneficiary, p.amount);\n\n require(result, \"Transfer did not go through.\");\n\n \n\n emit TokensUnfreezed(token, p.beneficiary, p.amount);\n\n emit WithdrawalApproved(token, p.beneficiary, p.amount);\n\n \n\n delete tokenToPendingWithdrawal[token];\n\n isTokenHavingPendingWithdrawal[token] = false;\n }", "function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender);\n\n _balances[sender] = _balances[sender].sub(\n amount,\n \"ERC20: transfer amount exceeds balance\"\n );\n\n _balances[recipient] = _balances[recipient].add(amount);\n\n emit Transfer(sender, recipient, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ChainPort", "functions": ["function rejectWithdrawal(\n address token\n ) public onlyChainportCongress isNotFrozen {\n require(isTokenHavingPendingWithdrawal[token] == true);\n\n \n\n PendingWithdrawal memory p = tokenToPendingWithdrawal[token];\n\n emit WithdrawalRejected(token, p.beneficiary, p.amount);\n\n \n\n delete tokenToPendingWithdrawal[token];\n\n isTokenHavingPendingWithdrawal[token] = false;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ElkNet Bridge", "functions": ["function stake(\n uint256 amount\n ) external nonReentrant whenNotPaused updateReward(msg.sender) {\n require(amount > 0, \"Cannot stake 0\");\n\n _totalSupply = _totalSupply + amount;\n\n _balances[msg.sender] = _balances[msg.sender] + amount;\n\n lastStakedTime[msg.sender] = block.timestamp;\n\n function safeTransferFrom(...) {...}\nstakingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n emit Staked(msg.sender, amount);\n }", "function safeTransferFrom(\n address token,\n address from,\n address to,\n uint256 value\n ) internal {\n \n\n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0x23b872dd, from, to, value)\n );\n\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper: TRANSFER_FROM_FAILED\"\n );\n }", "function withdraw(\n uint256 amount\n ) public nonReentrant updateReward(msg.sender) {\n _withdraw(amount);\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n\n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper: TRANSFER_FAILED\"\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ElkNet Bridge", "functions": ["function _withdraw(uint256 amount) private {\n require(amount > 0, \"Cannot withdraw 0\");\n\n uint256 balance = _balances[msg.sender];\n\n require(amount <= balance, \"Cannot withdraw more than account balance\");\n\n _totalSupply = _totalSupply - amount;\n\n function fee(...) {...}\nfunction safeTransfer(...) {...}\nuint256 collectedFee = fee(msg.sender, amount);\n\n _balances[msg.sender] = balance - amount;\n\n uint256 withdrawableBalance = amount - collectedFee;\n\n stakingToken.safeTransfer(msg.sender, withdrawableBalance);\n\n emit Withdrawn(msg.sender, withdrawableBalance);\n\n if (collectedFee > 0) {\n emit FeesCollected(msg.sender, collectedFee);\n\n totalFees = totalFees + collectedFee;\n }\n }", "function safeTransfer(address token, address to, uint256 value) internal {\n \n\n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0xa9059cbb, to, value)\n );\n\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper: TRANSFER_FAILED\"\n );\n }", "function stake(\n uint256 amount\n ) external nonReentrant whenNotPaused updateReward(msg.sender) {\n require(amount > 0, \"Cannot stake 0\");\n\n _totalSupply = _totalSupply + amount;\n\n _balances[msg.sender] = _balances[msg.sender] + amount;\n\n lastStakedTime[msg.sender] = block.timestamp;\n\n function safeTransferFrom(...) {...}\nstakingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n emit Staked(msg.sender, amount);\n }", "function safeTransferFrom(\n address token,\n address from,\n address to,\n uint256 value\n ) internal {\n \n\n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(0x23b872dd, from, to, value)\n );\n\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"TransferHelper: TRANSFER_FROM_FAILED\"\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ElkNet Bridge", "functions": ["function mint(address to) external lock returns (uint liquidity) {\n (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); \n\n uint balance0 = IERC20(token0).balanceOf(address(this));\n\n uint balance1 = IERC20(token1).balanceOf(address(this));\n\n uint amount0 = balance0.sub(_reserve0);\n\n uint amount1 = balance1.sub(_reserve1);\n\n bool feeOn = _mintFee(_reserve0, _reserve1);\n\n uint _totalSupply = totalSupply; \n\n if (_totalSupply == 0) {\n liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n\n _mint(address(0), MINIMUM_LIQUIDITY); \n } else {\n liquidity = Math.min(\n amount0.mul(_totalSupply) / _reserve0,\n amount1.mul(_totalSupply) / _reserve1\n );\n }\n\n require(liquidity > 0, \"Elk: INSUFFICIENT_LIQUIDITY_MINTED\");\n\n _mint(to, liquidity);\n\n _update(balance0, balance1, _reserve0, _reserve1);\n\n if (feeOn) kLast = uint(reserve0).mul(reserve1); \n\n emit Mint(msg.sender, amount0, amount1);\n }", "function _mint(address to, uint value) internal {\n function add(...) {...}\ntotalSupply = totalSupply.add(value);\n\n balanceOf[to] = balanceOf[to].add(value);\n\n emit Transfer(address(0), to, value);\n }", "function _update(\n uint balance0,\n uint balance1,\n uint112 _reserve0,\n uint112 _reserve1\n ) private {\n require(\n balance0 <= uint112(-1) && balance1 <= uint112(-1),\n \"Elk: OVERFLOW\"\n );\n\n uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n\n uint32 timeElapsed = blockTimestamp - blockTimestampLast; \n\n if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n \n\n price0CumulativeLast +=\n uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n timeElapsed;\n\n price1CumulativeLast +=\n uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n timeElapsed;\n }\n\n reserve0 = uint112(balance0);\n\n reserve1 = uint112(balance1);\n\n blockTimestampLast = blockTimestamp;\n\n emit Sync(reserve0, reserve1);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ElkNet Bridge", "functions": ["function burn(\n address to\n ) external lock returns (uint amount0, uint amount1) {\n (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); \n\n address _token0 = token0; \n\n address _token1 = token1; \n\n uint balance0 = IERC20(_token0).balanceOf(address(this));\n\n uint balance1 = IERC20(_token1).balanceOf(address(this));\n\n uint liquidity = balanceOf[address(this)];\n\n bool feeOn = _mintFee(_reserve0, _reserve1);\n\n uint _totalSupply = totalSupply; \n\n amount0 = liquidity.mul(balance0) / _totalSupply; \n\n amount1 = liquidity.mul(balance1) / _totalSupply; \n\n require(\n amount0 > 0 && amount1 > 0,\n \"Elk: INSUFFICIENT_LIQUIDITY_BURNED\"\n );\n\n _burn(address(this), liquidity);\n\n _safeTransfer(_token0, to, amount0);\n\n _safeTransfer(_token1, to, amount1);\n\n balance0 = IERC20(_token0).balanceOf(address(this));\n\n balance1 = IERC20(_token1).balanceOf(address(this));\n\n _update(balance0, balance1, _reserve0, _reserve1);\n\n if (feeOn) kLast = uint(reserve0).mul(reserve1); \n\n emit Burn(msg.sender, amount0, amount1, to);\n }", "function _burn(address from, uint value) internal {\n function sub(...) {...}\nbalanceOf[from] = balanceOf[from].sub(value);\n\n totalSupply = totalSupply.sub(value);\n\n emit Transfer(from, address(0), value);\n }", "function _safeTransfer(address token, address to, uint value) private {\n (bool success, bytes memory data) = token.call(\n abi.encodeWithSelector(SELECTOR, to, value)\n );\n\n require(\n success && (data.length == 0 || abi.decode(data, (bool))),\n \"Elk: TRANSFER_FAILED\"\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Governance Bridge", "functions": ["function processMessageFromRoot(\n uint256 stateId,\n address rootMessageSender,\n bytes calldata data\n ) external override onlyFxChild {\n if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();\n\n address[] memory targets;\n\n uint256[] memory values;\n\n string[] memory signatures;\n\n bytes[] memory calldatas;\n\n bool[] memory withDelegatecalls;\n\n (targets, values, signatures, calldatas, withDelegatecalls) = abi\n .decode(data, (address[], uint256[], string[], bytes[], bool[]));\n\n _queue(targets, values, signatures, calldatas, withDelegatecalls);\n }", "function _queue(\n address[] memory targets,\n uint256[] memory values,\n string[] memory signatures,\n bytes[] memory calldatas,\n bool[] memory withDelegatecalls\n ) internal {\n if (targets.length == 0) revert EmptyTargets();\n\n uint256 targetsLength = targets.length;\n\n if (\n targetsLength != values.length ||\n targetsLength != signatures.length ||\n targetsLength != calldatas.length ||\n targetsLength != withDelegatecalls.length\n ) revert InconsistentParamsLength();\n\n uint256 actionsSetId = _actionsSetCounter;\n\n uint256 executionTime = block.timestamp + _delay;\n\n unchecked {\n ++_actionsSetCounter;\n }\n\n for (uint256 i = 0; i < targetsLength; ) {\n bytes32 actionHash = keccak256(\n abi.encode(\n targets[i],\n values[i],\n signatures[i],\n calldatas[i],\n executionTime,\n withDelegatecalls[i]\n )\n );\n\n if (isActionQueued(actionHash)) revert DuplicateAction();\n\n _queuedActions[actionHash] = true;\n\n unchecked {\n ++i;\n }\n }\n\n ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n\n actionsSet.targets = targets;\n\n actionsSet.values = values;\n\n actionsSet.signatures = signatures;\n\n actionsSet.calldatas = calldatas;\n\n actionsSet.withDelegatecalls = withDelegatecalls;\n\n actionsSet.executionTime = executionTime;\n\n emit ActionsSetQueued(\n actionsSetId,\n targets,\n values,\n signatures,\n calldatas,\n withDelegatecalls,\n executionTime\n );\n }", "function processMessageFromRoot(\n uint256 stateId,\n address rootMessageSender,\n bytes calldata data\n ) external override onlyFxChild {\n if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();\n\n address[] memory targets;\n\n uint256[] memory values;\n\n string[] memory signatures;\n\n bytes[] memory calldatas;\n\n bool[] memory withDelegatecalls;\n\n (targets, values, signatures, calldatas, withDelegatecalls) = abi\n .decode(data, (address[], uint256[], string[], bytes[], bool[]));\n\n _queue(targets, values, signatures, calldatas, withDelegatecalls);\n }", "function _queue(\n address[] memory targets,\n uint256[] memory values,\n string[] memory signatures,\n bytes[] memory calldatas,\n bool[] memory withDelegatecalls\n ) internal {\n if (targets.length == 0) revert EmptyTargets();\n\n uint256 targetsLength = targets.length;\n\n if (\n targetsLength != values.length ||\n targetsLength != signatures.length ||\n targetsLength != calldatas.length ||\n targetsLength != withDelegatecalls.length\n ) revert InconsistentParamsLength();\n\n uint256 actionsSetId = _actionsSetCounter;\n\n uint256 executionTime = block.timestamp + _delay;\n\n unchecked {\n ++_actionsSetCounter;\n }\n\n for (uint256 i = 0; i < targetsLength; ) {\n bytes32 actionHash = keccak256(\n abi.encode(\n targets[i],\n values[i],\n signatures[i],\n calldatas[i],\n executionTime,\n withDelegatecalls[i]\n )\n );\n\n if (isActionQueued(actionHash)) revert DuplicateAction();\n\n _queuedActions[actionHash] = true;\n\n unchecked {\n ++i;\n }\n }\n\n ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n\n actionsSet.targets = targets;\n\n actionsSet.values = values;\n\n actionsSet.signatures = signatures;\n\n actionsSet.calldatas = calldatas;\n\n actionsSet.withDelegatecalls = withDelegatecalls;\n\n actionsSet.executionTime = executionTime;\n\n emit ActionsSetQueued(\n actionsSetId,\n targets,\n values,\n signatures,\n calldatas,\n withDelegatecalls,\n executionTime\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Holograph Bridge", "functions": ["function bridgeIn(\n uint32 fromChain,\n bytes calldata payload\n ) external onlyBridge returns (bytes4) {\n (address from, address to, uint256 tokenId, bytes memory data) = abi\n .decode(payload, (address, address, uint256, bytes));\n\n require(!_exists(tokenId), \"ERC721: token already exists\");\n\n delete _burnedTokens[tokenId];\n\n _mint(to, tokenId);\n\n if (_isEventRegistered(HolographERC721Event.bridgeIn)) {\n require(\n _sourceCall(\n abi.encodeWithSelector(\n HolographedERC721.bridgeIn.selector,\n fromChain,\n from,\n to,\n tokenId,\n data\n )\n ),\n \"HOLOGRAPH: bridge in failed\"\n );\n }\n\n return Holographable.bridgeIn.selector;\n }", "function bridgeIn(\n uint32 fromChain,\n bytes calldata payload\n ) external onlyBridge returns (bytes4) {\n (address from, address to, uint256 tokenId, bytes memory data) = abi\n .decode(payload, (address, address, uint256, bytes));\n\n require(!_exists(tokenId), \"ERC721: token already exists\");\n\n delete _burnedTokens[tokenId];\n\n _mint(to, tokenId);\n\n if (_isEventRegistered(HolographERC721Event.bridgeIn)) {\n require(\n _sourceCall(\n abi.encodeWithSelector(\n HolographedERC721.bridgeIn.selector,\n fromChain,\n from,\n to,\n tokenId,\n data\n )\n ),\n \"HOLOGRAPH: bridge in failed\"\n );\n }\n\n return Holographable.bridgeIn.selector;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Holograph Bridge", "functions": ["function bridgeOut(\n uint32 toChain,\n address sender,\n bytes calldata payload\n ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n (address from, address to, uint256 tokenId) = abi.decode(\n payload,\n (address, address, uint256)\n );\n\n require(to != address(0), \"ERC721: zero address\");\n\n require(_isApproved(sender, tokenId), \"ERC721: sender not approved\");\n\n require(from == _tokenOwner[tokenId], \"ERC721: from is not owner\");\n\n if (_isEventRegistered(HolographERC721Event.bridgeOut)) {\n \n\n bytes memory sourcePayload = abi.encodeWithSelector(\n HolographedERC721.bridgeOut.selector,\n toChain,\n from,\n to,\n tokenId\n );\n\n assembly {\n \n\n mstore(\n add(sourcePayload, add(mload(sourcePayload), 0x20)),\n caller()\n )\n\n let result := call(\n gas(),\n sload(_sourceContractSlot),\n callvalue(),\n \n\n add(sourcePayload, 0x20),\n \n\n add(mload(sourcePayload), 0x20),\n 0,\n 0\n )\n\n \n\n \n\n returndatacopy(data, 0x20, sub(returndatasize(), 0x20))\n\n switch result\n case 0 {\n revert(0, returndatasize())\n }\n }\n }\n\n _burn(from, tokenId);\n\n return (\n Holographable.bridgeOut.selector,\n abi.encode(from, to, tokenId, data)\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "iCrossChain", "functions": ["function sendValue(address payable recipient, uint256 amount) internal {\n require(\n address(this).balance >= amount,\n \"Address: insufficient balance\"\n );\n\n \n\n (bool success, ) = recipient.call{value: amount}(\"\");\n\n require(\n success,\n \"Address: unable to send value, recipient may have reverted\"\n );\n }", "function sendValue(address payable recipient, uint256 amount) internal {\n require(\n address(this).balance >= amount,\n \"Address: insufficient balance\"\n );\n\n \n\n (bool success, ) = recipient.call{value: amount}(\"\");\n\n require(\n success,\n \"Address: unable to send value, recipient may have reverted\"\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "iCrossChain", "functions": ["function functionCall(\n address target,\n bytes memory data\n ) internal returns (bytes memory) {\n return functionCall(target, data, \"Address: low-level call failed\");\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Kintsugi", "functions": ["function purchaseFor(\n bytes32 collectionId,\n address recipient\n ) public payable {\n require(!_msgSender().isContract(), \"cannot purchase from contract\");\n\n require(\n msg.value >= collections[collectionId].priceInWei,\n \"insufficient funds sent to purchase\"\n );\n\n Collection memory collection = getCollection(collectionId);\n\n bool allowedToMint = false;\n\n if (collection.useAllowList && collection.allowList.length > 0) {\n for (uint i = 0; i < collection.allowList.length; i++) {\n if (_msgSender() == collection.allowList[i]) {\n allowedToMint = true;\n\n break;\n }\n }\n } else {\n allowedToMint = true;\n }\n\n function mint(...) {...}\nrequire(allowedToMint, \"mint not approved\");\n\n mint(collectionId, _msgSender(), recipient);\n\n require(ownerAddresses.length > 0, \"no owner addresses\");\n\n require(\n ownerSplits.length == ownerAddresses.length,\n \"invalid owner splits\"\n );\n\n require(collection.creatorAddresses.length > 0, \"no creator addresses\");\n\n require(\n collection.creatorSplits.length ==\n collection.creatorAddresses.length,\n \"invalid creator splits\"\n );\n\n distributeFunds(collection);\n }", "function mint(\n bytes32 collectionId,\n address minter,\n address recipient\n ) internal {\n Collection memory collection = getCollection(collectionId);\n\n require(collections[collectionId].seed != 0, \"seed not set\");\n\n require(collection.active, \"collection inactive\");\n\n require(\n collection.minted + 1 <= collection.mintedMax,\n \"minted max tokens\"\n );\n\n require(\n collection.mintedMaxPerOwner == 0 ||\n ownerMints[collectionId][minter] < collection.mintedMaxPerOwner,\n \"minter exceeds max mints\"\n );\n\n uint256 nextTokenId = lastTokenId + 1;\n\n int32 seed = int32(\n int(\n uint(\n keccak256(\n abi.encodePacked(\n collection.seed,\n block.number,\n _msgSender(),\n recipient,\n nextTokenId\n )\n )\n )\n )\n );\n\n lastTokenId = nextTokenId;\n\n collectionTokens[collectionId].push(lastTokenId);\n\n tokenCollection[lastTokenId] = collectionId;\n\n collectionSeeds[collectionId].push(seed);\n\n tokenSeed[lastTokenId] = seed;\n\n collections[collectionId].minted = collection.minted + 1;\n\n ownerMints[collectionId][recipient] =\n ownerMints[collectionId][recipient] +\n 1;\n\n _safeMint(recipient, nextTokenId);\n\n emit CollectionMinted(\n collectionId,\n nextTokenId,\n recipient,\n collection.minted,\n collection.priceInWei,\n seed\n );\n\n if (collection.pauseAt > 0) {\n if (lastTokenId >= collection.pauseAt) _pause();\n }\n }", "function _safeMint(address to, uint256 tokenId) internal virtual {\n _safeMint(to, tokenId, \"\");\n }", "function _mint(address to, uint256 tokenId) internal virtual {\n require(to != address(0), \"ERC721: mint to the zero address\");\n\n function _exists(...) {...}\nrequire(!_exists(tokenId), \"ERC721: token already minted\");\n\n _beforeTokenTransfer(address(0), to, tokenId);\n\n _balances[to] += 1;\n\n _owners[tokenId] = to;\n\n emit Transfer(address(0), to, tokenId);\n }", "function purchaseFor(\n bytes32 collectionId,\n address recipient\n ) public payable {\n require(!_msgSender().isContract(), \"cannot purchase from contract\");\n\n require(\n msg.value >= collections[collectionId].priceInWei,\n \"insufficient funds sent to purchase\"\n );\n\n Collection memory collection = getCollection(collectionId);\n\n bool allowedToMint = false;\n\n if (collection.useAllowList && collection.allowList.length > 0) {\n for (uint i = 0; i < collection.allowList.length; i++) {\n if (_msgSender() == collection.allowList[i]) {\n allowedToMint = true;\n\n break;\n }\n }\n } else {\n allowedToMint = true;\n }\n\n require(allowedToMint, \"mint not approved\");\n\n mint(collectionId, _msgSender(), recipient);\n\n require(ownerAddresses.length > 0, \"no owner addresses\");\n\n require(\n ownerSplits.length == ownerAddresses.length,\n \"invalid owner splits\"\n );\n\n require(collection.creatorAddresses.length > 0, \"no creator addresses\");\n\n require(\n collection.creatorSplits.length ==\n collection.creatorAddresses.length,\n \"invalid creator splits\"\n );\n\n distributeFunds(collection);\n }", "function mint(\n bytes32 collectionId,\n address minter,\n address recipient\n ) internal {\n Collection memory collection = getCollection(collectionId);\n\n require(collections[collectionId].seed != 0, \"seed not set\");\n\n require(collection.active, \"collection inactive\");\n\n require(\n collection.minted + 1 <= collection.mintedMax,\n \"minted max tokens\"\n );\n\n require(\n collection.mintedMaxPerOwner == 0 ||\n ownerMints[collectionId][minter] < collection.mintedMaxPerOwner,\n \"minter exceeds max mints\"\n );\n\n uint256 nextTokenId = lastTokenId + 1;\n\n int32 seed = int32(\n int(\n uint(\n keccak256(\n abi.encodePacked(\n collection.seed,\n block.number,\n _msgSender(),\n recipient,\n nextTokenId\n )\n )\n )\n )\n );\n\n lastTokenId = nextTokenId;\n\n collectionTokens[collectionId].push(lastTokenId);\n\n tokenCollection[lastTokenId] = collectionId;\n\n collectionSeeds[collectionId].push(seed);\n\n tokenSeed[lastTokenId] = seed;\n\n collections[collectionId].minted = collection.minted + 1;\n\n ownerMints[collectionId][recipient] =\n ownerMints[collectionId][recipient] +\n 1;\n\n _safeMint(recipient, nextTokenId);\n\n emit CollectionMinted(\n collectionId,\n nextTokenId,\n recipient,\n collection.minted,\n collection.priceInWei,\n seed\n );\n\n if (collection.pauseAt > 0) {\n if (lastTokenId >= collection.pauseAt) _pause();\n }\n }", "function _safeMint(address to, uint256 tokenId) internal virtual {\n _safeMint(to, tokenId, \"\");\n }", "function _mint(address to, uint256 tokenId) internal virtual {\n require(to != address(0), \"ERC721: mint to the zero address\");\n\n require(!_exists(tokenId), \"ERC721: token already minted\");\n\n _beforeTokenTransfer(address(0), to, tokenId);\n\n _balances[to] += 1;\n\n _owners[tokenId] = to;\n\n emit Transfer(address(0), to, tokenId);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Kintsugi", "functions": ["function render(\n IRenderer.RenderArgs memory args\n ) external view override returns (IRenderer.RenderArgs memory results) {\n require(msg.sender == _owner || msg.sender == _executor, \"denied\");\n\n require(args.index != -1, \"rendering is finished\");\n\n require(\n args.index >= 0 && args.index < 64,\n \"index must be in range 0-63\"\n );\n\n require(\n args.stage >= 0 && args.stage < 104,\n \"stage must be in range 0-103\"\n );\n\n require(args.seed != 0, \"seed not specified\");\n\n RandomV1.PRNG memory prng = RandomV1.buildSeedTable(args.seed);\n\n HatchLayer.HatchParameters memory hatch;\n\n {\n HatchLayer.HatchParameters memory h = HatchLayer.getParameters(\n prng\n );\n\n hatch = h;\n\n prng = h.prng;\n }\n\n WatercolorLayer.WatercolorParameters memory watercolors;\n\n {\n WatercolorLayer.WatercolorParameters memory w = WatercolorLayer\n .getParameters(prng);\n\n watercolors = w;\n\n prng = w.prng;\n }\n\n KintsugiLayer.KintsugiParameters memory kintsugi;\n\n {\n (\n KintsugiLayer.KintsugiParameters memory k,\n RandomV1.PRNG memory p\n ) = KintsugiLayer.getParameters(prng, args.seed);\n\n kintsugi = k;\n\n prng = p;\n }\n\n if (args.stage == 0) {\n return background_stage(args);\n } else if (args.stage == 1) {\n return hatch_stage(hatch, prng, args);\n } else if (args.stage > 1 && args.stage < 103) {\n return watercolor_stage(watercolors, args.prng, args);\n } else if (args.stage == 103) {\n return kintsugi_stage(kintsugi, args);\n } else {\n revert(\"invalid render arguments\");\n }\n }", "function background(\n uint32[16384] memory result,\n uint32 color,\n TypesV1.Chunk2D memory chunk\n ) internal pure {\n for (uint256 x = 0; x < chunk.chunkWidth; x++) {\n for (uint256 y = 0; y < chunk.chunkHeight; y++) {\n GraphicsV1.setPixel(\n result,\n chunk.chunkWidth,\n int256(x),\n int256(y),\n color\n );\n }\n }\n }", "function hatch_stage(\n HatchLayer.HatchParameters memory hatch,\n RandomV1.PRNG memory prng,\n RenderArgs memory args\n ) private pure returns (IRenderer.RenderArgs memory results) {\n require(hatch.opacity > 0, \"opacity not set\");\n\n require(hatch.spacing > 0, \"spacing not set\");\n\n require(hatch.color > 0, \"color not set\");\n\n uint32[16384] memory buffer = HatchDraw.draw(\n HatchDraw.Draw(\n args.buffer,\n hatch,\n TypesV1.Chunk2D(\n uint16(args.index),\n 1024,\n 1024,\n 128,\n 128,\n (uint16(args.index) % 8) * 128,\n (uint16(args.index) / 8) * 128\n )\n )\n );\n\n return\n IRenderer.RenderArgs(\n args.index,\n args.stage + 1,\n args.seed,\n buffer,\n prng\n );\n }", "function line(\n uint32[16384] memory result,\n GeometryV1.Line2D memory f\n ) internal pure {\n int256 x0 = f.v0.x;\n\n int256 x1 = f.v1.x;\n\n int256 y0 = f.v0.y;\n\n int256 y1 = f.v1.y;\n\n int256 dx = MathV1.abs(x1 - x0);\n\n int256 dy = MathV1.abs(y1 - y0);\n\n int256 err = (dx > dy ? dx : -dy) / 2;\n\n int256 e2;\n\n for (;;) {\n if (\n x0 <= int32(f.chunk.startX) + int16(f.chunk.chunkWidth) - 1 &&\n x0 >= int32(f.chunk.startX) &&\n y0 <= int32(f.chunk.startY) + int16(f.chunk.chunkHeight) - 1 &&\n y0 >= int32(f.chunk.startY)\n ) {\n GraphicsV1.setPixel(\n result,\n f.chunk.chunkWidth,\n x0 - int32(f.chunk.startX),\n y0 - int32(f.chunk.startY),\n f.color\n );\n }\n\n if (x0 == x1 && y0 == y1) break;\n\n e2 = err;\n\n if (e2 > -dx) {\n err -= dy;\n\n x0 += x0 < x1 ? int8(1) : -1;\n }\n\n if (e2 < dy) {\n err += dx;\n\n y0 += y0 < y1 ? int8(1) : -1;\n }\n }\n }", "function watercolor_stage(\n WatercolorLayer.WatercolorParameters memory watercolors,\n RandomV1.PRNG memory prng,\n IRenderer.RenderArgs memory args\n ) private pure returns (IRenderer.RenderArgs memory results) {\n require(watercolors.stackCount > 0, \"stackCount not set\");\n\n require(watercolors.stackColors.length > 0, \"stackColors not set\");\n\n WatercolorLayer.StackList memory stackList;\n\n {\n WatercolorLayer.StackList memory s = WatercolorLayer.buildStackList(\n prng,\n watercolors\n );\n\n stackList = s;\n\n prng = s.prng;\n }\n\n uint32[16384] memory buffer = WatercolorDraw.draw(\n WatercolorDraw.Draw(\n args.buffer,\n watercolors,\n stackList,\n TypesV1.Chunk2D(\n uint16(args.index),\n 1024,\n 1024,\n 128,\n 128,\n (uint16(args.index) % 8) * 128,\n (uint16(args.index) / 8) * 128\n )\n )\n );\n\n return\n IRenderer.RenderArgs(\n args.index,\n args.stage + 1,\n args.seed,\n buffer,\n prng\n );\n }", "function buildStackList(\n RandomV1.PRNG memory prng,\n WatercolorParameters memory p\n ) external pure returns (StackList memory stackList) {\n require(p.stackCount > 0 && p.stackCount < 5, \"invalid stack count\");\n\n for (uint8 i = 0; i < p.stackCount; i++) {\n (\n TypesV1.Point2D[MAX_POLYGONS] memory stack,\n uint32 vertexCount\n ) = createPolyStack(\n CreatePolyStack(p.r[i], p.basePoly[i], p.basePolyCount[i]),\n prng\n );\n\n if (i == 0) {\n stackList.stack1 = stack;\n\n stackList.stack1Count = vertexCount;\n } else if (i == 1) {\n stackList.stack2 = stack;\n\n stackList.stack2Count = vertexCount;\n } else if (i == 2) {\n stackList.stack3 = stack;\n\n stackList.stack3Count = vertexCount;\n } else if (i == 3) {\n stackList.stack4 = stack;\n\n stackList.stack4Count = vertexCount;\n }\n }\n\n stackList.prng = prng;\n }", "function createPolyStack(\n CreatePolyStack memory f,\n RandomV1.PRNG memory prng\n )\n private\n pure\n returns (TypesV1.Point2D[MAX_POLYGONS] memory stack, uint32 vertexCount)\n {\n int32 variance = RandomV1.next(\n prng,\n int32(Fix64V1.div(f.r, 10 * Fix64V1.ONE) >> 32),\n int32(Fix64V1.div(f.r, 4 * Fix64V1.ONE) >> 32)\n );\n\n (TypesV1.Point2D[MAX_POLYGONS] memory poly, uint32 polyCount) = deform(\n prng,\n f.basePoly,\n f.basePolyCount,\n 5, \n variance, \n 4 * Fix64V1.ONE \n );\n\n require(polyCount == MAX_POLYGONS, \"invalid algorithm\");\n\n stack = poly;\n\n vertexCount = polyCount;\n }", "function deform(\n RandomV1.PRNG memory prng,\n TypesV1.Point2D[MAX_POLYGONS] memory points,\n uint32 pointCount,\n int32 depth,\n int32 variance,\n int64 vdiv\n )\n private\n pure\n returns (\n TypesV1.Point2D[MAX_POLYGONS] memory newPoints,\n uint32 newPointCount\n )\n {\n if (pointCount < 2) {\n return (newPoints, 0);\n }\n\n newPointCount = 0;\n\n for (uint32 i = 0; i < pointCount; i++) {\n int32 sx1 = int32(points[i].x);\n\n int32 sy1 = int32(points[i].y);\n\n int32 sx2 = int32(points[(i + 1) % pointCount].x);\n\n int32 sy2 = int32(points[(i + 1) % pointCount].y);\n\n newPoints[newPointCount++] = TypesV1.Point2D(sx1, sy1);\n\n newPointCount = subdivide(\n Subdivide(\n depth,\n variance * Fix64V1.ONE,\n vdiv,\n newPoints,\n newPointCount,\n sx1 * Fix64V1.ONE,\n sy1 * Fix64V1.ONE,\n sx2 * Fix64V1.ONE,\n sy2 * Fix64V1.ONE\n ),\n prng\n );\n }\n\n return (newPoints, newPointCount);\n }", "function subdivide_midpoint(\n Subdivide memory f,\n RandomV1.PRNG memory prng,\n int64 t1,\n int64 t2\n ) private pure returns (int64) {\n int64 mid = Fix64V1.div(Fix64V1.add(t1, t2), Fix64V1.TWO);\n\n int64 g = RandomV1.nextGaussian(prng);\n\n int64 n = Fix64V1.add(mid, Fix64V1.mul(g, f.variance));\n\n return n;\n }", "function kintsugi_stage(\n KintsugiLayer.KintsugiParameters memory kintsugi,\n IRenderer.RenderArgs memory args\n ) private pure returns (IRenderer.RenderArgs memory results) {\n require(kintsugi.layers > 0, \"layers not set\");\n\n int64[4096] memory noiseTable = NoiseV1.buildNoiseTable(args.seed);\n\n uint32[16384] memory buffer = KintsugiDraw.draw(\n KintsugiDraw.Draw(\n args.buffer,\n kintsugi,\n noiseTable,\n TypesV1.Chunk2D(\n uint16(args.index),\n 1024,\n 1024,\n 128,\n 128,\n (uint16(args.index) % 8) * 128,\n (uint16(args.index) / 8) * 128\n )\n )\n );\n\n return\n IRenderer.RenderArgs(\n args.index == 63 ? -1 : args.index + 1,\n 0,\n args.seed,\n buffer,\n args.prng\n );\n }", "function draw(\n Draw memory f\n ) external pure returns (uint32[16384] memory buffer) {\n f.p.iteration = 0;\n\n f.p.frame = 0;\n\n while (f.p.frame < FRAME_COUNT) {\n f.p.frame++;\n\n if (f.p.iteration >= f.p.layers) {\n break;\n }\n\n bool dead = true;\n\n {\n for (uint256 i = 0; i < f.p.layers; i++) {\n ParticleSetV1.ParticleSet2D memory particleSet = f\n .p\n .particleSets[i];\n\n update(\n f.noiseTable,\n particleSet,\n PARTICLE_COUNT,\n f.chunk.width,\n f.chunk.height\n );\n\n if (!particleSet.dead) {\n dead = false;\n }\n\n draw(particleSet, PARTICLE_COUNT, f.result, f.chunk);\n }\n }\n\n if (dead) {\n f.p.iteration++;\n }\n }\n\n return f.result;\n }", "function update(\n int64[NOISE_TABLE_SIZE] memory noiseTable,\n Particle2D memory p,\n uint256 width,\n uint256 height\n ) internal pure {\n p.frames++;\n\n if (p.frames >= p._lifetime) {\n p.dead = true;\n\n return;\n }\n\n p.force = forceAt(noiseTable, p, p.x, p.y);\n\n if (\n p.x >= int256(width) + int256(width) / 2 ||\n p.x < -int256(width) / 2 ||\n p.y >= int256(height) + int256(height) / 2 ||\n p.y < -int256(height) / 2\n ) {\n p.dead = true;\n\n return;\n }\n\n p.px = p.x;\n\n p.py = p.y;\n\n p.x += int64(p.force.x);\n\n p.y += int64(p.force.y);\n }", "function step(\n ParticleV1.Particle2D memory p,\n uint32[16384] memory result,\n TypesV1.Chunk2D memory chunk\n ) internal pure {\n if (p.frames < 40) {\n return;\n }\n\n uint32 dark = GraphicsV1.setOpacity(0xFFF4BB29, 10);\n\n TypesV1.Point2D memory v0 = TypesV1.Point2D(int32(p.x), int32(p.y));\n\n TypesV1.Point2D memory v1 = TypesV1.Point2D(int32(p.px), int32(p.py));\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y - 2),\n TypesV1.Point2D(v1.x, v1.y - 2),\n dark,\n chunk\n )\n );\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y + 2),\n TypesV1.Point2D(v1.x, v1.y + 2),\n dark,\n chunk\n )\n );\n\n uint32 bright = GraphicsV1.setOpacity(0xFFD5B983, 10);\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y - 1),\n TypesV1.Point2D(v1.x, v1.y - 1),\n bright,\n chunk\n )\n );\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y),\n TypesV1.Point2D(v1.x, v1.y),\n bright,\n chunk\n )\n );\n\n ProcessingV1.line(\n result,\n GeometryV1.Line2D(\n TypesV1.Point2D(v0.x, v0.y + 1),\n TypesV1.Point2D(v1.x, v1.y + 1),\n bright,\n chunk\n )\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Metis Bridge", "functions": ["function _initiateETHDepositByChainId(\n uint256 _chainId,\n address _from,\n address _to,\n uint32 _l2Gas,\n bytes memory _data\n ) internal {\n iMVM_DiscountOracle oracle = iMVM_DiscountOracle(\n Lib_AddressManager(addressmgr).getAddress(\"MVM_DiscountOracle\")\n );\n\n uint32 mingas = uint32(oracle.getMinL2Gas());\n\n if (_l2Gas < mingas) {\n _l2Gas = mingas;\n }\n\n uint256 fee = _l2Gas * oracle.getDiscount();\n\n require(\n fee <= msg.value,\n string(\n abi.encodePacked(\n \"insufficient fee supplied. send at least \",\n uint2str(fee)\n )\n )\n );\n\n \n\n bytes memory message = abi.encodeWithSelector(\n IL2ERC20Bridge.finalizeDeposit.selector,\n address(0),\n Lib_PredeployAddresses.OVM_ETH,\n _from,\n _to,\n msg.value - fee,\n _data\n );\n\n \n\n sendCrossDomainMessageViaChainId(\n _chainId,\n l2TokenBridge,\n _l2Gas,\n message,\n fee \n );\n\n emit ETHDepositInitiated(_from, _to, msg.value, _data, _chainId);\n }", "function sendMessageViaChainId(\n uint256 _chainId,\n address _target,\n bytes memory _message,\n uint32 _gasLimit\n ) public payable override {\n iMVM_DiscountOracle oracle = iMVM_DiscountOracle(\n resolve(\"MVM_DiscountOracle\")\n );\n\n \n\n oracle.processL2SeqGas{value: msg.value}(msg.sender, _chainId);\n\n address ovmCanonicalTransactionChain = resolve(\n \"CanonicalTransactionChain\"\n );\n\n \n\n uint40 nonce = ICanonicalTransactionChain(ovmCanonicalTransactionChain)\n .getQueueLengthByChainId(_chainId);\n\n bytes memory xDomainCalldataRaw = Lib_CrossDomainUtils\n .encodeXDomainCalldata(_target, msg.sender, _message, nonce);\n\n _sendXDomainMessageViaChainId(\n _chainId,\n ovmCanonicalTransactionChain,\n xDomainCalldataRaw,\n _gasLimit\n );\n\n emit SentMessage(\n _target,\n msg.sender,\n _message,\n nonce,\n _gasLimit,\n _chainId\n );\n }", "function _sendXDomainMessageViaChainId(\n uint256 _chainId,\n address _canonicalTransactionChain,\n bytes memory _message,\n uint256 _gasLimit\n ) internal {\n ICanonicalTransactionChain(_canonicalTransactionChain).enqueueByChainId(\n _chainId,\n Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\n _gasLimit,\n _message\n );\n }", "function finalizeETHWithdrawalByChainId(\n uint256 _chainid,\n address _from,\n address _to,\n uint256 _amount,\n bytes calldata _data\n ) external override onlyFromCrossDomainAccount(l2TokenBridge) {\n (bool success, ) = _to.call{value: _amount}(new bytes(0));\n\n require(\n success,\n \"TransferHelper::safeTransferETH: ETH transfer failed\"\n );\n\n emit ETHWithdrawalFinalized(_from, _to, _amount, _data, _chainid);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Metis Bridge", "functions": ["function sendMessageViaChainId(\n uint256 _chainId,\n address _target,\n bytes memory _message,\n uint32 _gasLimit\n ) public payable override {\n iMVM_DiscountOracle oracle = iMVM_DiscountOracle(\n resolve(\"MVM_DiscountOracle\")\n );\n\n \n\n oracle.processL2SeqGas{value: msg.value}(msg.sender, _chainId);\n\n address ovmCanonicalTransactionChain = resolve(\n \"CanonicalTransactionChain\"\n );\n\n \n\n uint40 nonce = ICanonicalTransactionChain(ovmCanonicalTransactionChain)\n .getQueueLengthByChainId(_chainId);\n\n bytes memory xDomainCalldataRaw = Lib_CrossDomainUtils\n .encodeXDomainCalldata(_target, msg.sender, _message, nonce);\n\n _sendXDomainMessageViaChainId(\n _chainId,\n ovmCanonicalTransactionChain,\n xDomainCalldataRaw,\n _gasLimit\n );\n\n emit SentMessage(\n _target,\n msg.sender,\n _message,\n nonce,\n _gasLimit,\n _chainId\n );\n }", "function _sendXDomainMessageViaChainId(\n uint256 _chainId,\n address _canonicalTransactionChain,\n bytes memory _message,\n uint256 _gasLimit\n ) internal {\n ICanonicalTransactionChain(_canonicalTransactionChain).enqueueByChainId(\n _chainId,\n Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\n _gasLimit,\n _message\n );\n }", "function enqueueByChainId(\n uint256 _chainId,\n address _target,\n uint256 _gasLimit,\n bytes memory _data\n ) public override {\n require(\n msg.sender == resolve(\"Proxy__OVM_L1CrossDomainMessenger\"),\n \"only the cross domain messenger can enqueue\"\n );\n\n require(\n _data.length <= MAX_ROLLUP_TX_SIZE,\n \"Transaction data size exceeds maximum for rollup transaction.\"\n );\n\n require(\n _gasLimit <= maxTransactionGasLimit,\n \"Transaction gas limit exceeds maximum for rollup transaction.\"\n );\n\n require(\n _gasLimit >= MIN_ROLLUP_TX_GAS,\n \"Transaction gas limit too low to enqueue.\"\n );\n\n \n\n \n\n \n\n \n\n \n\n address sender;\n\n if (msg.sender == tx.origin) {\n sender = msg.sender;\n } else {\n sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n }\n\n bytes32 transactionHash = keccak256(\n abi.encode(sender, _target, _gasLimit, _data)\n );\n\n queueElements[_chainId].push(\n Lib_OVMCodec.QueueElement({\n transactionHash: transactionHash,\n timestamp: uint40(block.timestamp),\n blockNumber: uint40(block.number)\n })\n );\n\n \n\n \n\n \n\n uint256 queueIndex = queueElements[_chainId].length - 1;\n\n emit TransactionEnqueued(\n _chainId,\n sender,\n _target,\n _gasLimit,\n _data,\n queueIndex,\n block.timestamp\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Metis Bridge", "functions": ["function relayMessageViaChainId(\n uint256 _chainId,\n address _target,\n address _sender,\n bytes memory _message,\n uint256 _messageNonce,\n L2MessageInclusionProof memory _proof\n ) public override nonReentrant whenNotPaused {\n bytes memory xDomainCalldata = Lib_CrossDomainUtils\n .encodeXDomainCalldata(_target, _sender, _message, _messageNonce);\n\n require(\n _verifyXDomainMessageByChainId(_chainId, xDomainCalldata, _proof) ==\n true,\n \"Provided message could not be verified.\"\n );\n\n bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\n require(\n successfulMessages[xDomainCalldataHash] == false,\n \"Provided message has already been received.\"\n );\n\n require(\n blockedMessages[xDomainCalldataHash] == false,\n \"Provided message has been blocked.\"\n );\n\n require(\n _target != resolve(\"CanonicalTransactionChain\"),\n \"Cannot send L2->L1 messages to L1 system contracts.\"\n );\n\n xDomainMsgSender = _sender;\n\n (bool success, ) = _target.call(_message);\n\n xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n \n\n \n\n if (success == true) {\n successfulMessages[xDomainCalldataHash] = true;\n\n emit RelayedMessage(xDomainCalldataHash);\n } else {\n emit FailedRelayedMessage(xDomainCalldataHash);\n }\n\n \n\n \n\n bytes32 relayId = keccak256(\n abi.encodePacked(xDomainCalldata, msg.sender, block.number)\n );\n\n relayedMessages[relayId] = true;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Multichain", "functions": ["function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n AnyswapV1ERC20(token).burn(from, amount);\n emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n }", "function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n AnyswapV1ERC20(token).mint(to, amount);\n function cID(...) {...}\nemit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Multichain", "functions": ["function anySwapInUnderlying(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n _anySwapIn(txs, token, to, amount, fromChainID);\n AnyswapV1ERC20(token).withdrawVault(to, amount, to);\n }", "function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n AnyswapV1ERC20(token).mint(to, amount);\n function cID(...) {...}\nemit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Multichain", "functions": ["function anySwapOutExactTokensForNative(\n uint amountIn,\n uint amountOutMin,\n address[] calldata path,\n address to,\n uint deadline,\n uint toChainID\n ) external virtual ensure(deadline) {\n AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n function cID(...) {...}\nemit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n }", "function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n AnyswapV1ERC20(token).mint(to, amount);\n function cID(...) {...}\nemit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Multichain", "functions": ["function mint(address to, uint256 amount) external onlyAuth returns (bool) {\n function _mint(...) {...}\n_mint(to, amount);\n return true;\n }", "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n _totalSupply += amount;\n balanceOf[account] += amount;\n emit Transfer(address(0), account, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Multichain", "functions": ["function burn(address from, uint256 amount) external onlyAuth returns (bool) {\n require(from != address(0), \"AnyswapV3ERC20: address(0x0)\");\n function _burn(...) {...}\n_burn(from, amount);\n return true;\n }", "function _burn(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: burn from the zero address\");\n\n balanceOf[account] -= amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Multichain", "functions": ["function depositVault(uint amount, address to) external onlyVault returns (uint) {\n return function _deposit(...) {...}\n_deposit(amount, to);\n }", "function _deposit(uint amount, address to) internal returns (uint) {\n require(underlying != address(0x0) && underlying != address(this));\n function _mint(...) {...}\n_mint(to, amount);\n return amount;\n }", "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n _totalSupply += amount;\n balanceOf[account] += amount;\n emit Transfer(address(0), account, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Multichain", "functions": ["function _withdraw(address from, uint amount, address to) internal returns (uint) {\n function _burn(...) {...}\nfunction safeTransfer(...) {...}\n_burn(from, amount);\n IERC20(underlying).safeTransfer(to, amount);\n return amount;\n }", "function _burn(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: burn from the zero address\");\n\n balanceOf[account] -= amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "MVM Bridge", "functions": ["function bind(address receiver) public {\n require(receiver != address(0), \"invalid address\");\n bridges[msg.sender] = receiver;\n emit Bound(msg.sender, receiver);\n }", "function bind(address receiver) public {\n require(receiver != address(0), \"invalid address\");\n bridges[msg.sender] = receiver;\n emit Bound(msg.sender, receiver);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "MVM Bridge", "functions": ["function pass(address asset, uint256 amount) public {\n address receiver = bridges[msg.sender];\n require(receiver != address(0), \"no address bound\");\n require(amount > 0, \"too small\");\n\n function canonical(...) {...}\nasset = canonical(asset);\n if (asset == XIN) {\n passXIN(receiver, amount);\n } else {\n IERC20(asset).transferFrom(msg.sender, receiver, amount);\n }\n\n emit Through(asset, msg.sender, receiver, amount);\n }", "function canonical(address asset) internal view returns (address) {\n uint256 id = uint256(uint160(asset));\n address another = Factory(FACTORY).contracts(id);\n if (another != address(0)) {\n return another;\n }\n return asset;\n }", "function passXIN(address receiver, uint256 amount) internal {\n IERC20(XIN).transferFrom(msg.sender, address(this), amount);\n payable(receiver).transfer(amount * BASE);\n }", "function vault(address asset, uint256 amount) public {\n function canonical(...) {...}\nasset = canonical(asset);\n require(asset == XIN, \"only XIN accepted\");\n IERC20(asset).transferFrom(msg.sender, address(this), amount);\n emit Vault(msg.sender, amount);\n }", "function canonical(address asset) internal view returns (address) {\n uint256 id = uint256(uint160(asset));\n address another = Factory(FACTORY).contracts(id);\n if (another != address(0)) {\n return another;\n }\n return asset;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "MVM Bridge", "functions": ["function release(address receiver, bytes memory input) public payable {\n uint256 amount = msg.value / BASE;\n require(amount > 0, \"value too small\");\n\n address bound = bridges[msg.sender];\n require(bound == address(0) || receiver == bound, \"bound not match\");\n\n IERC20(XIN).transferWithExtra(receiver, amount, input);\n emit Through(XIN, msg.sender, receiver, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "OmniBridge", "functions": ["function relayTokens(address _receiver, uint256 _amount) external {\n require(_receiver != address(0));\n\n require(_receiver != address(this));\n\n require(_amount > 0);\n\n function withinLimit(...) {...}\nfunction addTotalSpentPerDay(...) {...}\nfunction getCurrentDay(...) {...}\nfunction erc20token(...) {...}\nrequire(withinLimit(_amount));\n\n addTotalSpentPerDay(getCurrentDay(), _amount);\n\n erc20token().transferFrom(msg.sender, address(this), _amount);\n\n emit UserRequestForAffirmation(_receiver, _amount);\n }", "function claimTokens(\n address _token,\n address _to\n ) external onlyIfUpgradeabilityOwner {\n \n\n require(_token != address(erc20token()));\n\n function claimValues(...) {...}\nclaimValues(_token, _to);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "OmniBridge", "functions": ["function claimTokens(\n address _token,\n address _to\n ) external onlyIfUpgradeabilityOwner {\n \n\n require(_token != address(erc20token()));\n\n function claimValues(...) {...}\nclaimValues(_token, _to);\n }", "function onExecuteMessageGSN(\n address recipient,\n uint256 amount,\n uint256 fee\n ) internal returns (bool) {\n addTotalExecutedPerDay(getCurrentDay(), amount);\n\n \n\n function erc20token(...) {...}\nERC20 token = erc20token();\n\n bool first = token.transfer(addressStorage[PAYMASTER], fee);\n\n bool second = token.transfer(recipient, amount - fee);\n\n return first && second;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "OmniBridge", "functions": ["function executeSignatures(bytes message, bytes signatures) external {\n Message.hasEnoughValidSignatures(\n message,\n signatures,\n validatorContract(),\n false\n );\n\n address recipient;\n\n uint256 amount;\n\n bytes32 txHash;\n\n address contractAddress;\n\n (recipient, amount, txHash, contractAddress) = Message.parseMessage(\n message\n );\n\n if (withinExecutionLimit(amount)) {\n require(contractAddress == address(this));\n\n require(!relayedMessages(txHash));\n\n setRelayedMessages(txHash, true);\n\n require(onExecuteMessage(recipient, amount, txHash));\n\n emit RelayedMessage(recipient, amount, txHash);\n } else {\n onFailedMessage(recipient, amount, txHash);\n }\n }", "function onExecuteMessageGSN(\n address recipient,\n uint256 amount,\n uint256 fee\n ) internal returns (bool) {\n addTotalExecutedPerDay(getCurrentDay(), amount);\n\n \n\n ERC20 token = erc20token();\n\n bool first = token.transfer(addressStorage[PAYMASTER], fee);\n\n bool second = token.transfer(recipient, amount - fee);\n\n return first && second;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "OmniBridge", "functions": ["function onFailedMessage(address, uint256, bytes32) internal {\n revert();\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Optimism", "functions": ["function _initiateBridgeETH(\n address _from,\n address _to,\n uint256 _amount,\n uint32 _minGasLimit,\n bytes memory _extraData\n ) internal {\n require(\n msg.value == _amount,\n \"StandardBridge: bridging ETH must include sufficient ETH value\"\n );\n\n \n\n \n\n _emitETHBridgeInitiated(_from, _to, _amount, _extraData);\n\n MESSENGER.sendMessage{value: _amount}(\n address(OTHER_BRIDGE),\n abi.encodeWithSelector(\n this.finalizeBridgeETH.selector,\n _from,\n _to,\n _amount,\n _extraData\n ),\n _minGasLimit\n );\n }", "function relayMessage(\n uint256 _nonce,\n address _sender,\n address _target,\n uint256 _value,\n uint256 _minGasLimit,\n bytes calldata _message\n ) external payable {\n (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n\n require(\n version < 2,\n \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n );\n\n \n\n \n\n if (version == 0) {\n bytes32 oldHash = Hashing.hashCrossDomainMessageV0(\n _target,\n _sender,\n _message,\n _nonce\n );\n\n require(\n successfulMessages[oldHash] == false,\n \"CrossDomainMessenger: legacy withdrawal already relayed\"\n );\n }\n\n \n\n \n\n bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n _nonce,\n _sender,\n _target,\n _value,\n _minGasLimit,\n _message\n );\n\n if (_isOtherMessenger()) {\n \n\n \n\n assert(msg.value == _value);\n\n assert(!failedMessages[versionedHash]);\n } else {\n require(\n msg.value == 0,\n \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n );\n\n require(\n failedMessages[versionedHash],\n \"CrossDomainMessenger: message cannot be replayed\"\n );\n }\n\n require(\n _isUnsafeTarget(_target) == false,\n \"CrossDomainMessenger: cannot send message to blocked system address\"\n );\n\n require(\n successfulMessages[versionedHash] == false,\n \"CrossDomainMessenger: message has already been relayed\"\n );\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n if (\n !SafeCall.hasMinGas(\n _minGasLimit,\n RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER\n ) || xDomainMsgSender != Constants.DEFAULT_L2_SENDER\n ) {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n\n return;\n }\n\n xDomainMsgSender = _sender;\n\n bool success = SafeCall.call(\n _target,\n gasleft() - RELAY_RESERVED_GAS,\n _value,\n _message\n );\n\n xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n if (success) {\n successfulMessages[versionedHash] = true;\n\n emit RelayedMessage(versionedHash);\n } else {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n }\n }", "function finalizeBridgeETH(\n address _from,\n address _to,\n uint256 _amount,\n bytes calldata _extraData\n ) public payable onlyOtherBridge {\n require(\n msg.value == _amount,\n \"StandardBridge: amount sent does not match amount required\"\n );\n\n require(_to != address(this), \"StandardBridge: cannot send to self\");\n\n require(\n _to != address(MESSENGER),\n \"StandardBridge: cannot send to messenger\"\n );\n\n \n\n \n\n _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\n\n bool success = SafeCall.call(_to, gasleft(), _amount, hex\"\");\n\n require(success, \"StandardBridge: ETH transfer failed\");\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Optimism", "functions": ["function relayMessage(\n uint256 _nonce,\n address _sender,\n address _target,\n uint256 _value,\n uint256 _minGasLimit,\n bytes calldata _message\n ) external payable {\n (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n\n require(\n version < 2,\n \"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\"\n );\n\n \n\n \n\n if (version == 0) {\n bytes32 oldHash = Hashing.hashCrossDomainMessageV0(\n _target,\n _sender,\n _message,\n _nonce\n );\n\n require(\n successfulMessages[oldHash] == false,\n \"CrossDomainMessenger: legacy withdrawal already relayed\"\n );\n }\n\n \n\n \n\n bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n _nonce,\n _sender,\n _target,\n _value,\n _minGasLimit,\n _message\n );\n\n if (_isOtherMessenger()) {\n \n\n \n\n assert(msg.value == _value);\n\n assert(!failedMessages[versionedHash]);\n } else {\n require(\n msg.value == 0,\n \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n );\n\n require(\n failedMessages[versionedHash],\n \"CrossDomainMessenger: message cannot be replayed\"\n );\n }\n\n require(\n _isUnsafeTarget(_target) == false,\n \"CrossDomainMessenger: cannot send message to blocked system address\"\n );\n\n require(\n successfulMessages[versionedHash] == false,\n \"CrossDomainMessenger: message has already been relayed\"\n );\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n if (\n !SafeCall.hasMinGas(\n _minGasLimit,\n RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER\n ) || xDomainMsgSender != Constants.DEFAULT_L2_SENDER\n ) {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n\n return;\n }\n\n xDomainMsgSender = _sender;\n\n bool success = SafeCall.call(\n _target,\n gasleft() - RELAY_RESERVED_GAS,\n _value,\n _message\n );\n\n xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n if (success) {\n successfulMessages[versionedHash] = true;\n\n emit RelayedMessage(versionedHash);\n } else {\n failedMessages[versionedHash] = true;\n\n emit FailedRelayedMessage(versionedHash);\n\n \n\n \n\n \n\n \n\n \n\n if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n revert(\"CrossDomainMessenger: failed to relay message\");\n }\n }\n }", "function finalizeBridgeETH(\n address _from,\n address _to,\n uint256 _amount,\n bytes calldata _extraData\n ) public payable onlyOtherBridge {\n require(\n msg.value == _amount,\n \"StandardBridge: amount sent does not match amount required\"\n );\n\n require(_to != address(this), \"StandardBridge: cannot send to self\");\n\n require(\n _to != address(MESSENGER),\n \"StandardBridge: cannot send to messenger\"\n );\n\n \n\n \n\n _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\n\n bool success = SafeCall.call(_to, gasleft(), _amount, hex\"\");\n\n require(success, \"StandardBridge: ETH transfer failed\");\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Orbit Bridge", "functions": ["function depositToken(address token, string memory toChain, bytes memory toAddr, uint amount) public onlyActivated{\n function getChainId(...) {...}\nrequire(isValidChain[getChainId(toChain)]);\n require(token != address(0));\n require(amount > 0);\n\n uint8 decimal = 0;\n if(token == tetherAddress){\n TIERC20(token).transferFrom(msg.sender, address(this), amount);\n decimal = TIERC20(token).decimals();\n }else{\n if(!IERC20(token).transferFrom(msg.sender, address(this), amount)) revert();\n decimal = IERC20(token).decimals();\n }\n \n require(decimal > 0);\n\n depositCount = depositCount + 1;\n emit Deposit(chain, toChain, msg.sender, toAddr, token, decimal, amount, depositCount, block.number);\n }", "function withdraw(\n address hubContract,\n string memory fromChain,\n bytes memory fromAddr,\n bytes memory toAddr,\n bytes memory token,\n bytes32[] memory bytes32s,\n uint[] memory uints,\n uint8[] memory v,\n bytes32[] memory r,\n bytes32[] memory s\n ) public onlyActivated {\n require(bytes32s.length >= 1);\n require(bytes32s[0] == sha256(abi.encodePacked(hubContract, chain, address(this))));\n require(uints.length >= 2);\n function getChainId(...) {...}\nfunction _validate(...) {...}\nrequire(isValidChain[getChainId(fromChain)]);\n\n bytes32 whash = sha256(abi.encodePacked(hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints));\n\n require(!isUsedWithdrawal[whash]);\n isUsedWithdrawal[whash] = true;\n\n uint validatorCount = _validate(whash, v, r, s);\n require(validatorCount >= required);\n\n address payable _toAddr = bytesToAddress(toAddr);\n address tokenAddress = bytesToAddress(token);\n if(tokenAddress == address(0)){\n if(!_toAddr.send(uints[0])) revert();\n }else{\n if(tokenAddress == tetherAddress){\n TIERC20(tokenAddress).transfer(_toAddr, uints[0]);\n }\n else{\n if(!IERC20(tokenAddress).transfer(_toAddr, uints[0])) revert();\n }\n }\n\n emit Withdraw(hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints);\n }", "function _validate(bytes32 whash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) private view returns(uint){\n uint validatorCount = 0;\n address[] memory vaList = new address[](owners.length);\n\n uint i=0;\n uint j=0;\n\n for(i; i<v.length; i++){\n address va = ecrecover(whash,v[i],r[i],s[i]);\n if(isOwner[va]){\n for(j=0; j<validatorCount; j++){\n require(vaList[j] != va);\n }\n\n vaList[validatorCount] = va;\n validatorCount += 1;\n }\n }\n\n return validatorCount;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Orbit Bridge", "functions": ["function _depositNFT(address token, string memory toChain, bytes memory toAddr, uint tokenId, bytes memory data) private onlyActivated {\n function getChainId(...) {...}\nrequire(isValidChain[getChainId(toChain)]);\n require(token != address(0));\n require(IERC721(token).ownerOf(tokenId) == msg.sender);\n require(!silentTokenList[token]);\n\n IERC721(token).transferFrom(msg.sender, address(this), tokenId);\n require(IERC721(token).ownerOf(tokenId) == address(this));\n\n depositCount = depositCount + 1;\n emit DepositNFT(toChain, msg.sender, toAddr, token, tokenId, 1, depositCount, data);\n }", "function withdrawNFT(\n address hubContract,\n string memory fromChain,\n bytes memory fromAddr,\n address payable toAddr,\n address token,\n bytes32[] memory bytes32s,\n uint[] memory uints,\n bytes memory data,\n uint8[] memory v,\n bytes32[] memory r,\n bytes32[] memory s\n ) public onlyActivated {\n require(bytes32s.length == 2);\n function getChainId(...) {...}\nrequire(uints.length == chainUintsLength[getChainId(fromChain)]);\n require(fromAddr.length == chainAddressLength[getChainId(fromChain)]);\n\n require(bytes32s[0] == sha256(abi.encodePacked(hubContract, chain, address(this))));\n require(isValidChain[getChainId(fromChain)]);\n\n {\n bytes32 whash = sha256(abi.encodePacked(\"NFT\", hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints, data));\n\n require(!isUsedWithdrawal[whash]);\n isUsedWithdrawal[whash] = true;\n\n uint validatorCount = _validate(whash, v, r, s);\n require(validatorCount >= required);\n }\n\n require(IERC721(token).ownerOf(uints[1]) == address(this));\n IERC721(token).transferFrom(address(this), toAddr, uints[1]);\n require(IERC721(token).ownerOf(uints[1]) == toAddr);\n\n if(isContract(toAddr) && data.length != 0){\n (bool result, bytes memory returndata) = LibCallBridgeReceiver.callReceiver(false, gasLimitForBridgeReceiver, token, uints[1], data, toAddr);\n emit BridgeReceiverResult(result, fromAddr, token, data);\n emit OnBridgeReceived(result, returndata, fromAddr, token, data);\n }\n\n emit WithdrawNFT(fromChain, fromAddr, abi.encodePacked(toAddr), abi.encodePacked(token), bytes32s, uints, data);\n }", "function _validate(bytes32 whash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) private view returns(uint){\n uint validatorCount = 0;\n address[] memory vaList = new address[](owners.length);\n\n uint i=0;\n uint j=0;\n\n for(i; i<v.length; i++){\n address va = ecrecover(whash,v[i],r[i],s[i]);\n if(isOwner[va]){\n for(j=0; j<validatorCount; j++){\n require(vaList[j] != va);\n }\n\n vaList[validatorCount] = va;\n validatorCount += 1;\n }\n }\n\n return validatorCount;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Orbit Bridge", "functions": ["function withdraw(\n address hubContract,\n string memory fromChain,\n bytes memory fromAddr,\n address payable toAddr,\n address token,\n bytes32[] memory bytes32s,\n uint[] memory uints,\n bytes memory data,\n uint8[] memory v,\n bytes32[] memory r,\n bytes32[] memory s\n ) public onlyActivated {\n require(bytes32s.length == 2);\n function getChainId(...) {...}\nrequire(uints.length == chainUintsLength[getChainId(fromChain)]);\n require(uints[1] <= 100);\n require(fromAddr.length == chainAddressLength[getChainId(fromChain)]);\n\n require(bytes32s[0] == sha256(abi.encodePacked(hubContract, chain, address(this))));\n require(isValidChain[getChainId(fromChain)]);\n\n {\n bytes32 whash = sha256(abi.encodePacked(hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints, data));\n\n require(!isUsedWithdrawal[whash]);\n isUsedWithdrawal[whash] = true;\n\n uint validatorCount = _validate(whash, v, r, s);\n require(validatorCount >= required);\n }\n\n emit Withdraw(fromChain, fromAddr, abi.encodePacked(toAddr), abi.encodePacked(token), bytes32s, uints, data);\n\n if(token == edai){\n token = dai;\n }\n else if(unwrappedWithdraw[token] != address(0)){\n token = unwrappedWithdraw[token];\n }\n\n _transferToken(token, toAddr, uints[0]);\n\n if(isContract(toAddr) && data.length != 0){\n (bool result, bytes memory returndata) = LibCallBridgeReceiver.callReceiver(true, gasLimitForBridgeReceiver, token, uints[0], data, toAddr);\n emit BridgeReceiverResult(result, fromAddr, token, data);\n emit OnBridgeReceived(result, returndata, fromAddr, token, data);\n }\n }", "function _validate(bytes32 whash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) private view returns(uint){\n uint validatorCount = 0;\n address[] memory vaList = new address[](owners.length);\n\n uint i=0;\n uint j=0;\n\n for(i; i<v.length; i++){\n address va = ecrecover(whash,v[i],r[i],s[i]);\n if(isOwner[va]){\n for(j=0; j<validatorCount; j++){\n require(vaList[j] != va);\n }\n\n vaList[validatorCount] = va;\n validatorCount += 1;\n }\n }\n\n return validatorCount;\n }", "function _transferToken(address token, address payable destination, uint amount) private {\n if(token == address(0)){\n require((address(this)).balance >= amount);\n (bool transfered,) = destination.call.value(amount)(\"\");\n require(transfered);\n }\n else{\n require(IERC20(token).balanceOf(address(this)) >= amount);\n IERC20(token).safeTransfer(destination, amount);\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Orbit Bridge", "functions": ["function withdrawNFT(\n address hubContract,\n string memory fromChain,\n bytes memory fromAddr,\n address payable toAddr,\n address token,\n bytes32[] memory bytes32s,\n uint[] memory uints,\n bytes memory data,\n uint8[] memory v,\n bytes32[] memory r,\n bytes32[] memory s\n ) public onlyActivated {\n require(bytes32s.length == 2);\n function getChainId(...) {...}\nrequire(uints.length == chainUintsLength[getChainId(fromChain)]);\n require(fromAddr.length == chainAddressLength[getChainId(fromChain)]);\n\n require(bytes32s[0] == sha256(abi.encodePacked(hubContract, chain, address(this))));\n require(isValidChain[getChainId(fromChain)]);\n\n {\n bytes32 whash = sha256(abi.encodePacked(\"NFT\", hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints, data));\n\n require(!isUsedWithdrawal[whash]);\n isUsedWithdrawal[whash] = true;\n\n uint validatorCount = _validate(whash, v, r, s);\n require(validatorCount >= required);\n }\n\n require(IERC721(token).ownerOf(uints[1]) == address(this));\n IERC721(token).transferFrom(address(this), toAddr, uints[1]);\n require(IERC721(token).ownerOf(uints[1]) == toAddr);\n\n if(isContract(toAddr) && data.length != 0){\n (bool result, bytes memory returndata) = LibCallBridgeReceiver.callReceiver(false, gasLimitForBridgeReceiver, token, uints[1], data, toAddr);\n emit BridgeReceiverResult(result, fromAddr, token, data);\n emit OnBridgeReceived(result, returndata, fromAddr, token, data);\n }\n\n emit WithdrawNFT(fromChain, fromAddr, abi.encodePacked(toAddr), abi.encodePacked(token), bytes32s, uints, data);\n }", "function _validate(bytes32 whash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) private view returns(uint){\n uint validatorCount = 0;\n address[] memory vaList = new address[](owners.length);\n\n uint i=0;\n uint j=0;\n\n for(i; i<v.length; i++){\n address va = ecrecover(whash,v[i],r[i],s[i]);\n if(isOwner[va]){\n for(j=0; j<validatorCount; j++){\n require(vaList[j] != va);\n }\n\n vaList[validatorCount] = va;\n validatorCount += 1;\n }\n }\n\n return validatorCount;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "PolkaBridge", "functions": ["function purchaseIDO(uint256 pid) public payable nonReentrant {\n uint256 poolIndex = pid.sub(1);\n\n require(\n pools[poolIndex].IsActived && !pools[poolIndex].IsStoped,\n \"invalid pool\"\n );\n\n require(\n block.timestamp >= pools[poolIndex].Begin &&\n block.timestamp <= pools[poolIndex].End,\n \"invalid time\"\n );\n\n \n\n require(\n whitelist[pid][msg.sender].IsWhitelist &&\n whitelist[pid][msg.sender].IsActived,\n \"invalid user\"\n );\n\n \n\n uint256 ethAmount = msg.value;\n\n uint256 tokenAmount = ethAmount.mul(pools[poolIndex].RatePerETH).div(\n 1e18\n );\n\n require(\n ethAmount <= pools[poolIndex].MaxPurchase,\n \"invalid maximum contribute\"\n );\n\n whitelist[pid][msg.sender].TotalETHPurchase = whitelist[pid][msg.sender]\n .TotalETHPurchase\n .add(ethAmount);\n\n if (\n whitelist[pid][msg.sender].TotalETHPurchase >\n pools[poolIndex].MaxPurchase\n ) {\n revert(\"invalid maximum contribute\"); \n }\n\n uint256 remainToken = getRemainIDOToken(pid);\n\n require(\n remainToken > pools[poolIndex].MinimumTokenSoldout,\n \"IDO sold out\"\n );\n\n require(remainToken >= tokenAmount, \"IDO sold out\");\n\n if (pools[poolIndex].Type == 2) \n\n {\n require(\n polkaBridgeToken.balanceOf(msg.sender) >=\n pools[poolIndex].AmountPBRRequire,\n \"must hold enough PBR\"\n );\n }\n\n whitelist[pid][msg.sender].TotalTokenPurchase = whitelist[pid][\n msg.sender\n ].TotalTokenPurchase.add(tokenAmount);\n\n pools[poolIndex].TotalSold = pools[poolIndex].TotalSold.add(\n tokenAmount\n );\n }", "function withdrawToken(address poolAddress, uint256 amount) public {\n require(\n msg.sender == owner,\n \"RewardPool: only owner can withdraw token\"\n );\n\n require(amount > 0, \"RewardPool: not enough balance\");\n\n require(amount <= tokenBalance(), \"RewardPool: not enough balance\");\n\n require(\n poolAddress != address(0),\n \"RewardPool: transfer to the zero address\"\n );\n\n polkaBridge.transfer(poolAddress, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "PolkaBridge", "functions": ["function claimToken(uint256 pid) public nonReentrant {\n require(!whitelist[pid][msg.sender].IsClaimed, \"user already claimed\");\n\n uint256 poolIndex = pid.sub(1);\n\n require(\n block.timestamp >=\n pools[poolIndex].End.add(pools[poolIndex].LockDuration),\n \"not on time for claiming token\"\n );\n\n uint256 userBalance = getUserTotalPurchase(pid);\n\n require(userBalance > 0, \"invalid claim\");\n\n pools[poolIndex].IDOToken.transfer(msg.sender, userBalance);\n\n whitelist[pid][msg.sender].IsClaimed = true;\n }", "function mintNFT(\n address recipient_,\n uint256 id_,\n uint256 amount_\n ) public onlyOwner {\n _mint(recipient_, id_, amount_, \"\");\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "PolyBridge", "functions": ["function lock(\n address fromAssetHash,\n uint64 toChainId,\n bytes memory toAddress,\n uint256 amount\n ) public payable returns (bool) {\n require(amount != 0, \"amount cannot be zero!\");\n\n require(\n _transferToContract(fromAssetHash, amount),\n \"transfer asset from fromAddress to lock_proxy contract failed!\"\n );\n\n bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId];\n\n require(toAssetHash.length != 0, \"empty illegal toAssetHash\");\n\n TxArgs memory txArgs = TxArgs({\n toAssetHash: toAssetHash,\n toAddress: toAddress,\n amount: amount\n });\n\n bytes memory txData = _serializeTxArgs(txArgs);\n\n IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(\n managerProxyContract\n );\n\n address eccmAddr = eccmp.getEthCrossChainManager();\n\n IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n\n bytes memory toProxyHash = proxyHashMap[toChainId];\n\n require(toProxyHash.length != 0, \"empty illegal toProxyHash\");\n\n require(\n eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData),\n \"EthCrossChainManager crossChain executed error!\"\n );\n\n emit LockEvent(\n fromAssetHash,\n _msgSender(),\n toChainId,\n toAssetHash,\n toAddress,\n amount\n );\n\n return true;\n }", "function _transferToContract(\n address fromAssetHash,\n uint256 amount\n ) internal returns (bool) {\n if (fromAssetHash == address(0)) {\n \n\n \n\n require(msg.value != 0, \"transferred ether cannot be zero!\");\n\n require(\n msg.value == amount,\n \"transferred ether is not equal to amount!\"\n );\n } else {\n \n\n require(msg.value == 0, \"there should be no ether transfer!\");\n\n \n\n require(\n _transferERC20ToContract(\n fromAssetHash,\n _msgSender(),\n address(this),\n amount\n ),\n \"transfer erc20 asset to lock_proxy contract failed!\"\n );\n }\n\n return true;\n }", "function _transferERC20ToContract(\n address fromAssetHash,\n address fromAddress,\n address toAddress,\n uint256 amount\n ) internal returns (bool) {\n IERC20 erc20Token = IERC20(fromAssetHash);\n\n \n\n function safeTransferFrom(...) {...}\nerc20Token.safeTransferFrom(fromAddress, toAddress, amount);\n\n return true;\n }", "function unlock(\n bytes memory argsBs,\n bytes memory fromContractAddr,\n uint64 fromChainId\n ) public onlyManagerContract returns (bool) {\n TxArgs memory args = _deserializeTxArgs(argsBs);\n\n require(\n fromContractAddr.length != 0,\n \"from proxy contract address cannot be empty\"\n );\n\n require(\n Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr),\n \"From Proxy contract address error!\"\n );\n\n require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\");\n\n address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\n\n require(args.toAddress.length != 0, \"toAddress cannot be empty\");\n\n address toAddress = Utils.bytesToAddress(args.toAddress);\n\n require(\n _transferFromContract(toAssetHash, toAddress, args.amount),\n \"transfer asset from lock_proxy contract to toAddress failed!\"\n );\n\n emit UnlockEvent(toAssetHash, toAddress, args.amount);\n\n return true;\n }", "function _transferFromContract(\n address toAssetHash,\n address toAddress,\n uint256 amount\n ) internal returns (bool) {\n if (\n toAssetHash == address(0x0000000000000000000000000000000000000000)\n ) {\n \n\n \n\n address(uint160(toAddress)).transfer(amount);\n } else {\n \n\n require(\n _transferERC20FromContract(toAssetHash, toAddress, amount),\n \"transfer erc20 asset to lock_proxy contract failed!\"\n );\n }\n\n return true;\n }", "function _transferERC20FromContract(\n address toAssetHash,\n address toAddress,\n uint256 amount\n ) internal returns (bool) {\n IERC20 erc20Token = IERC20(toAssetHash);\n\n \n\n function safeTransfer(...) {...}\nerc20Token.safeTransfer(toAddress, amount);\n\n return true;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "PolyBridge", "functions": ["function crossChain(\n uint64 toChainId,\n bytes calldata toContract,\n bytes calldata method,\n bytes calldata txData\n ) external whenNotPaused returns (bool) {\n \n\n require(whiteListFromContract[msg.sender], \"Invalid from contract\");\n\n \n\n IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n\n \n\n uint256 txHashIndex = eccd.getEthTxHashIndex();\n\n \n\n bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex);\n\n \n\n bytes memory rawParam = abi.encodePacked(\n ZeroCopySink.WriteVarBytes(paramTxHash),\n ZeroCopySink.WriteVarBytes(\n abi.encodePacked(\n sha256(abi.encodePacked(address(this), paramTxHash))\n )\n ),\n ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)),\n ZeroCopySink.WriteUint64(toChainId),\n ZeroCopySink.WriteVarBytes(toContract),\n ZeroCopySink.WriteVarBytes(method),\n ZeroCopySink.WriteVarBytes(txData)\n );\n\n \n\n require(\n eccd.putEthTxHash(keccak256(rawParam)),\n \"Save ethTxHash by index to Data contract failed!\"\n );\n\n \n\n emit CrossChainEvent(\n tx.origin,\n paramTxHash,\n msg.sender,\n toChainId,\n toContract,\n rawParam\n );\n\n return true;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "PolyBridge", "functions": ["function verifyHeaderAndExecuteTx(\n bytes memory proof,\n bytes memory rawHeader,\n bytes memory headerProof,\n bytes memory curRawHeader,\n bytes memory headerSig\n ) public whenNotPaused returns (bool) {\n ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n\n \n\n IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n\n \n\n address[] memory polyChainBKs = ECCUtils.deserializeKeepers(\n eccd.getCurEpochConPubKeyBytes()\n );\n\n uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\n\n uint n = polyChainBKs.length;\n\n if (header.height >= curEpochStartHeight) {\n \n\n require(\n ECCUtils.verifySig(\n rawHeader,\n headerSig,\n polyChainBKs,\n n - (n - 1) / 3\n ),\n \"Verify poly chain header signature failed!\"\n );\n } else {\n \n\n require(\n ECCUtils.verifySig(\n curRawHeader,\n headerSig,\n polyChainBKs,\n n - (n - 1) / 3\n ),\n \"Verify poly chain current epoch header signature failed!\"\n );\n\n \n\n ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(\n curRawHeader\n );\n\n bytes memory proveValue = ECCUtils.merkleProve(\n headerProof,\n curHeader.blockRoot\n );\n\n require(\n ECCUtils.getHeaderHash(rawHeader) ==\n Utils.bytesToBytes32(proveValue),\n \"verify header proof failed!\"\n );\n }\n\n \n\n bytes memory toMerkleValueBs = ECCUtils.merkleProve(\n proof,\n header.crossStatesRoot\n );\n\n \n\n ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils\n .deserializeMerkleValue(toMerkleValueBs);\n\n require(\n !eccd.checkIfFromChainTxExist(\n toMerkleValue.fromChainID,\n Utils.bytesToBytes32(toMerkleValue.txHash)\n ),\n \"the transaction has been executed!\"\n );\n\n require(\n eccd.markFromChainTxExist(\n toMerkleValue.fromChainID,\n Utils.bytesToBytes32(toMerkleValue.txHash)\n ),\n \"Save crosschain tx exist failed!\"\n );\n\n \n\n require(\n toMerkleValue.makeTxParam.toChainId == chainId,\n \"This Tx is not aiming at this network!\"\n );\n\n \n\n address toContract = Utils.bytesToAddress(\n toMerkleValue.makeTxParam.toContract\n );\n\n \n\n require(\n whiteListContractMethodMap[toContract][\n toMerkleValue.makeTxParam.method\n ],\n \"Invalid to contract or method\"\n );\n\n \n\n require(\n _executeCrossChainTx(\n toContract,\n toMerkleValue.makeTxParam.method,\n toMerkleValue.makeTxParam.args,\n toMerkleValue.makeTxParam.fromContract,\n toMerkleValue.fromChainID\n ),\n \"Execute CrossChain Tx failed!\"\n );\n\n \n\n \n\n emit VerifyHeaderAndExecuteTxEvent(\n toMerkleValue.fromChainID,\n toMerkleValue.makeTxParam.toContract,\n toMerkleValue.txHash,\n toMerkleValue.makeTxParam.txHash\n );\n\n return true;\n }", "function _executeCrossChainTx(\n address _toContract,\n bytes memory _method,\n bytes memory _args,\n bytes memory _fromContractAddr,\n uint64 _fromChainId\n ) internal returns (bool) {\n \n\n require(\n Utils.isContract(_toContract),\n \"The passed in address is not a contract!\"\n );\n\n bytes memory returnData;\n\n bool success;\n\n \n\n (success, returnData) = _toContract.call(\n abi.encodePacked(\n bytes4(\n keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))\n ),\n abi.encode(_args, _fromContractAddr, _fromChainId)\n )\n );\n\n \n\n require(success == true, \"EthCrossChain call business contract failed\");\n\n \n\n require(\n returnData.length != 0,\n \"No return value from business contract!\"\n );\n\n (bool res, ) = ZeroCopySource.NextBool(returnData, 31);\n\n require(\n res == true,\n \"EthCrossChain call business contract return is not true\"\n );\n\n return true;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Polygon Bridge", "functions": ["function _depositFor(\n address user,\n address rootToken,\n bytes memory depositData\n ) private {\n bytes32 tokenType = tokenToType[rootToken];\n\n require(\n rootToChildToken[rootToken] != address(0x0) && tokenType != 0,\n \"RootChainManager: TOKEN_NOT_MAPPED\"\n );\n\n address predicateAddress = typeToPredicate[tokenType];\n\n require(\n predicateAddress != address(0),\n \"RootChainManager: INVALID_TOKEN_TYPE\"\n );\n\n require(user != address(0), \"RootChainManager: INVALID_USER\");\n\n ITokenPredicate(predicateAddress).lockTokens(\n _msgSender(),\n user,\n rootToken,\n depositData\n );\n\n bytes memory syncData = abi.encode(user, rootToken, depositData);\n\n _stateSender.syncState(\n childChainManagerAddress,\n abi.encode(DEPOSIT, syncData)\n );\n }", "function safeBatchTransferFrom(\n address from,\n address to,\n uint256[] memory ids,\n uint256[] memory amounts,\n bytes memory data\n ) public virtual override {\n require(\n ids.length == amounts.length,\n \"ERC1155: ids and amounts length mismatch\"\n );\n\n require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n require(\n from == _msgSender() || isApprovedForAll(from, _msgSender()),\n \"ERC1155: transfer caller is not owner nor approved\"\n );\n\n address operator = _msgSender();\n\n _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n for (uint256 i = 0; i < ids.length; ++i) {\n uint256 id = ids[i];\n\n uint256 amount = amounts[i];\n\n uint256 fromBalance = _balances[id][from];\n\n require(\n fromBalance >= amount,\n \"ERC1155: insufficient balance for transfer\"\n );\n\n _balances[id][from] = fromBalance - amount;\n\n _balances[id][to] += amount;\n }\n\n emit TransferBatch(operator, from, to, ids, amounts);\n\n _doSafeBatchTransferAcceptanceCheck(\n operator,\n from,\n to,\n ids,\n amounts,\n data\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Polygon Bridge", "functions": ["function exitTokens(\n address,\n address rootToken,\n bytes memory log\n ) public override only(MANAGER_ROLE) {\n RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();\n\n RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); \n\n address withdrawer = address(logTopicRLPList[1].toUint()); \n\n require(\n bytes32(logTopicRLPList[0].toUint()) == TRANSFER_EVENT_SIG,\n \"ERC721Predicate: INVALID_SIGNATURE\"\n );\n\n require(\n address(logTopicRLPList[2].toUint()) == address(0), \n \"ERC721Predicate: INVALID_RECEIVER\"\n );\n\n uint256 tokenId = logTopicRLPList[3].toUint(); \n\n IERC721(rootToken).safeTransferFrom(address(this), withdrawer, tokenId);\n\n emit ExitedERC721(withdrawer, rootToken, tokenId);\n }", "function safeTransferFrom(\n\n address from,\n\n address to,\n\n uint256 tokenId\n\n ) public virtual override {\n\n safeTransferFrom(from, to, tokenId, \"\");\n\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Polygon Bridge", "functions": ["function submitCheckpoint(\n bytes calldata data,\n uint[3][] calldata sigs\n ) external {\n (\n address proposer,\n uint256 start,\n uint256 end,\n bytes32 rootHash,\n bytes32 accountHash,\n uint256 _borChainID\n ) = abi.decode(\n data,\n (address, uint256, uint256, bytes32, bytes32, uint256)\n );\n\n require(CHAINID == _borChainID, \"Invalid bor chain id\");\n\n require(\n _buildHeaderBlock(proposer, start, end, rootHash),\n \"INCORRECT_HEADER_DATA\"\n );\n\n \n\n IStakeManager stakeManager = IStakeManager(\n registry.getStakeManagerAddress()\n );\n\n uint256 _reward = stakeManager.checkSignatures(\n end.sub(start).add(1),\n \n\n keccak256(abi.encodePacked(bytes(hex\"01\"), data)),\n accountHash,\n proposer,\n sigs\n );\n\n require(_reward != 0, \"Invalid checkpoint\");\n\n emit NewHeaderBlock(\n proposer,\n _nextHeaderBlock,\n _reward,\n start,\n end,\n rootHash\n );\n\n _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);\n\n _blockDepositId = 1;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "RenBridge", "functions": ["function register(\n address _darknodeID,\n bytes calldata _publicKey\n ) external onlyRefunded(_darknodeID) {\n require(\n _darknodeID != address(0),\n \"DarknodeRegistry: darknode address cannot be zero\"\n );\n\n require(\n ren.transferFrom(msg.sender, address(store), minimumBond),\n \"DarknodeRegistry: bond transfer failed\"\n );\n\n store.appendDarknode(\n _darknodeID,\n msg.sender,\n minimumBond,\n _publicKey,\n currentEpoch.blocktime.add(minimumEpochInterval),\n 0\n );\n\n numDarknodesNextEpoch = numDarknodesNextEpoch.add(1);\n\n emit LogDarknodeRegistered(msg.sender, _darknodeID, minimumBond);\n }", "function appendDarknode(\n\n address _darknodeID,\n\n address payable _darknodeOperator,\n\n uint256 _bond,\n\n bytes calldata _publicKey,\n\n uint256 _registeredAt,\n\n uint256 _deregisteredAt\n\n ) external onlyOwner {\n\n Darknode memory darknode = Darknode({\n\n owner: _darknodeOperator,\n\n bond: _bond,\n\n publicKey: _publicKey,\n\n registeredAt: _registeredAt,\n\n deregisteredAt: _deregisteredAt\n\n });\n\n darknodeRegistry[_darknodeID] = darknode;\n\n function append(...) {...}\nLinkedList.append(darknodes, _darknodeID);\n\n }", "function claim(address _darknode) external onlyDarknode(_darknode) {\n require(\n darknodeRegistry.isRegisteredInPreviousEpoch(_darknode),\n \"DarknodePayment: cannot claim for this epoch\"\n );\n\n function _claimDarknodeReward(...) {...}\nfunction isRegisteredInPreviousEpoch(...) {...}\n_claimDarknodeReward(_darknode);\n\n emit LogDarknodeClaim(_darknode, previousCycle);\n }", "function _claimDarknodeReward(address _darknode) private {\n require(\n !rewardClaimed[_darknode][previousCycle],\n \"DarknodePayment: reward already claimed\"\n );\n\n rewardClaimed[_darknode][previousCycle] = true;\n\n uint256 arrayLength = registeredTokens.length;\n\n for (uint256 i = 0; i < arrayLength; i++) {\n address token = registeredTokens[i];\n\n if (previousCycleRewardShare[token] > 0) {\n unclaimedRewards[token] = unclaimedRewards[token].sub(\n previousCycleRewardShare[token],\n \"DarknodePayment: share exceeds unclaimed rewards\"\n );\n\n store.incrementDarknodeBalance(\n _darknode,\n token,\n previousCycleRewardShare[token]\n );\n }\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "RenBridge", "functions": ["function deregister(\n address _darknodeID\n )\n external\n onlyDeregisterable(_darknodeID)\n onlyDarknodeOperator(_darknodeID)\n {\n function deregisterDarknode(...) {...}\nderegisterDarknode(_darknodeID);\n }", "function deregisterDarknode(address _darknodeID) private {\n function darknodeOperator(...) {...}\nfunction add(...) {...}\nfunction updateDarknodeDeregisteredAt(...) {...}\nfunction sub(...) {...}\naddress darknodeOperator = store.darknodeOperator(_darknodeID);\n\n store.updateDarknodeDeregisteredAt(\n _darknodeID,\n currentEpoch.blocktime.add(minimumEpochInterval)\n );\n\n numDarknodesNextEpoch = numDarknodesNextEpoch.sub(1);\n\n emit LogDarknodeDeregistered(darknodeOperator, _darknodeID);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "RenBridge", "functions": ["function slashDuplicatePropose(\n uint256 _height,\n uint256 _round,\n bytes calldata _blockhash1,\n uint256 _validRound1,\n bytes calldata _signature1,\n bytes calldata _blockhash2,\n uint256 _validRound2,\n bytes calldata _signature2\n ) external {\n address signer = Validate.duplicatePropose(\n _height,\n _round,\n _blockhash1,\n _validRound1,\n _signature1,\n _blockhash2,\n _validRound2,\n _signature2\n );\n\n require(\n !slashed[_height][_round][signer],\n \"DarknodeSlasher: already slashed\"\n );\n\n slashed[_height][_round][signer] = true;\n\n function slash(...) {...}\ndarknodeRegistry.slash(signer, msg.sender, maliciousSlashPercent);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "RenBridge", "functions": ["function slashDuplicatePrevote(\n uint256 _height,\n uint256 _round,\n bytes calldata _blockhash1,\n bytes calldata _signature1,\n bytes calldata _blockhash2,\n bytes calldata _signature2\n ) external {\n address signer = Validate.duplicatePrevote(\n _height,\n _round,\n _blockhash1,\n _signature1,\n _blockhash2,\n _signature2\n );\n\n require(\n !slashed[_height][_round][signer],\n \"DarknodeSlasher: already slashed\"\n );\n\n slashed[_height][_round][signer] = true;\n\n function slash(...) {...}\ndarknodeRegistry.slash(signer, msg.sender, maliciousSlashPercent);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "RenBridge", "functions": ["function slashDuplicatePrecommit(\n uint256 _height,\n uint256 _round,\n bytes calldata _blockhash1,\n bytes calldata _signature1,\n bytes calldata _blockhash2,\n bytes calldata _signature2\n ) external {\n address signer = Validate.duplicatePrecommit(\n _height,\n _round,\n _blockhash1,\n _signature1,\n _blockhash2,\n _signature2\n );\n\n require(\n !slashed[_height][_round][signer],\n \"DarknodeSlasher: already slashed\"\n );\n\n slashed[_height][_round][signer] = true;\n\n function slash(...) {...}\ndarknodeRegistry.slash(signer, msg.sender, maliciousSlashPercent);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "RenBridge", "functions": ["function slashSecretReveal(\n uint256 _a,\n uint256 _b,\n uint256 _c,\n uint256 _d,\n uint256 _e,\n uint256 _f,\n bytes calldata _signature\n ) external {\n address signer = Validate.recoverSecret(\n _a,\n _b,\n _c,\n _d,\n _e,\n _f,\n _signature\n );\n\n require(!secretRevealed[signer], \"DarknodeSlasher: already slashed\");\n\n secretRevealed[signer] = true;\n\n function slash(...) {...}\ndarknodeRegistry.slash(signer, msg.sender, secretRevealSlashPercent);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "RSK Token Bridge", "functions": ["function receiveTokensTo(\n address tokenToUse,\n address to,\n uint256 amount\n ) public override {\n address sender = _msgSender();\n\n \n\n function safeTransferFrom(...) {...}\nIERC20(tokenToUse).safeTransferFrom(sender, address(this), amount);\n\n crossTokens(tokenToUse, sender, to, amount, \"\");\n }", "function crossTokens(\n address tokenToUse,\n address from,\n address to,\n uint256 amount,\n bytes memory userData\n ) internal whenNotUpgrading whenNotPaused nonReentrant {\n knownTokens[tokenToUse] = true;\n\n function div(...) {...}\nfunction mul(...) {...}\nfunction sub(...) {...}\nfunction safeTransfer(...) {...}\nfunction owner(...) {...}\nuint256 fee = amount.mul(feePercentage).div(feePercentageDivider);\n\n uint256 amountMinusFees = amount.sub(fee);\n\n uint8 decimals = LibUtils.getDecimals(tokenToUse);\n\n uint formattedAmount = amount;\n\n if (decimals != 18) {\n formattedAmount = amount.mul(uint256(10) ** (18 - decimals));\n }\n\n \n\n \n\n allowTokens.updateTokenTransfer(tokenToUse, formattedAmount);\n\n address originalTokenAddress = tokenToUse;\n\n if (originalTokens[tokenToUse] != NULL_ADDRESS) {\n \n\n originalTokenAddress = originalTokens[tokenToUse];\n\n uint256 granularity = LibUtils.getGranularity(tokenToUse);\n\n uint256 modulo = amountMinusFees.mod(granularity);\n\n fee = fee.add(modulo);\n\n amountMinusFees = amountMinusFees.sub(modulo);\n\n IERC777(tokenToUse).burn(amountMinusFees, userData);\n }\n\n emit Cross(originalTokenAddress, from, to, amountMinusFees, userData);\n\n if (fee > 0) {\n \n\n IERC20(tokenToUse).safeTransfer(owner(), fee);\n }\n }", "function depositTo(address to) external payable override {\n address sender = _msgSender();\n\n require(\n address(wrappedCurrency) != NULL_ADDRESS,\n \"Bridge: wrappedCurrency empty\"\n );\n\n wrappedCurrency.deposit{value: msg.value}();\n\n function crossTokens(...) {...}\ncrossTokens(address(wrappedCurrency), sender, to, msg.value, \"\");\n }", "function tokensReceived(\n address operator,\n address from,\n address to,\n uint amount,\n bytes calldata userData,\n bytes calldata\n ) external override(IBridge, IERC777Recipient) {\n \n\n if (operator == address(this)) return; \n\n require(to == address(this), \"Bridge: Not to this address\");\n\n address tokenToUse = _msgSender();\n\n require(\n erc1820.getInterfaceImplementer(tokenToUse, _erc777Interface) !=\n NULL_ADDRESS,\n \"Bridge: Not ERC777 token\"\n );\n\n require(\n userData.length != 0 || !from.isContract(),\n \"Bridge: Specify receiver address in data\"\n );\n\n address receiver = userData.length == 0\n ? from\n : LibUtils.bytesToAddress(userData);\n\n crossTokens(tokenToUse, from, receiver, amount, userData);\n }", "function claim(\n ClaimData calldata _claimData\n ) external override returns (uint256 receivedAmount) {\n receivedAmount = _claim(\n _claimData,\n _claimData.to,\n payable(address(0)),\n 0\n );\n\n return receivedAmount;\n }", "function _claim(\n ClaimData calldata _claimData,\n address payable _reciever,\n address payable _relayer,\n uint256 _fee\n ) internal nonReentrant returns (uint256 receivedAmount) {\n address originalTokenAddress = originalTokenAddresses[\n _claimData.transactionHash\n ];\n\n require(originalTokenAddress != NULL_ADDRESS, \"Bridge: Tx not crossed\");\n\n bytes32 transactionDataHash = getTransactionDataHash(\n _claimData.to,\n _claimData.amount,\n _claimData.blockHash,\n _claimData.transactionHash,\n _claimData.logIndex\n );\n\n require(\n transactionsDataHashes[_claimData.transactionHash] ==\n transactionDataHash,\n \"Bridge: Wrong transactionDataHash\"\n );\n\n require(!claimed[transactionDataHash], \"Bridge: Already claimed\");\n\n claimed[transactionDataHash] = true;\n\n if (knownTokens[originalTokenAddress]) {\n receivedAmount = _claimCrossBackToToken(\n originalTokenAddress,\n _reciever,\n _claimData.amount,\n _relayer,\n _fee\n );\n } else {\n receivedAmount = _claimCrossToSideToken(\n originalTokenAddress,\n _reciever,\n _claimData.amount,\n _relayer,\n _fee\n );\n }\n\n emit Claimed(\n _claimData.transactionHash,\n originalTokenAddress,\n _claimData.to,\n senderAddresses[_claimData.transactionHash],\n _claimData.amount,\n _claimData.blockHash,\n _claimData.logIndex,\n _reciever,\n _relayer,\n _fee\n );\n\n return receivedAmount;\n }", "function _claimCrossToSideToken(\n address _originalTokenAddress,\n address payable _receiver,\n uint256 _amount,\n address payable _relayer,\n uint256 _fee\n ) internal returns (uint256 receivedAmount) {\n address sideToken = mappedTokens[_originalTokenAddress];\n\n uint256 granularity = IERC777(sideToken).granularity();\n\n function mul(...) {...}\nuint256 formattedAmount = _amount.mul(granularity);\n\n require(_fee <= formattedAmount, \"Bridge: fee too high\");\n\n receivedAmount = formattedAmount - _fee;\n\n ISideToken(sideToken).mint(_receiver, receivedAmount, \"\", \"\");\n\n if (_fee > 0) {\n ISideToken(sideToken).mint(_relayer, _fee, \"\", \"relayer fee\");\n }\n\n return receivedAmount;\n }", "function _claimCrossBackToToken(\n address _originalTokenAddress,\n address payable _receiver,\n uint256 _amount,\n address payable _relayer,\n uint256 _fee\n ) internal returns (uint256 receivedAmount) {\n function getDecimals(...) {...}\nfunction div(...) {...}\nfunction safeTransfer(...) {...}\nuint256 decimals = LibUtils.getDecimals(_originalTokenAddress);\n\n \n\n uint256 formattedAmount = _amount.div(uint256(10) ** (18 - decimals));\n\n require(_fee <= formattedAmount, \"Bridge: fee too high\");\n\n receivedAmount = formattedAmount - _fee;\n\n if (address(wrappedCurrency) == _originalTokenAddress) {\n wrappedCurrency.withdraw(formattedAmount);\n\n _receiver.transfer(receivedAmount);\n\n if (_fee > 0) {\n _relayer.transfer(_fee);\n }\n } else {\n IERC20(_originalTokenAddress).safeTransfer(\n _receiver,\n receivedAmount\n );\n\n if (_fee > 0) {\n IERC20(_originalTokenAddress).safeTransfer(_relayer, _fee);\n }\n }\n\n return receivedAmount;\n }", "function claimFallback(\n ClaimData calldata _claimData\n ) external override returns (uint256 receivedAmount) {\n require(\n _msgSender() == senderAddresses[_claimData.transactionHash],\n \"Bridge: invalid sender\"\n );\n\n receivedAmount = _claim(\n _claimData,\n _msgSender(),\n payable(address(0)),\n 0\n );\n\n return receivedAmount;\n }", "function claimGasless(\n ClaimData calldata _claimData,\n address payable _relayer,\n uint256 _fee,\n uint256 _deadline,\n uint8 _v,\n bytes32 _r,\n bytes32 _s\n ) external override returns (uint256 receivedAmount) {\n require(_deadline >= block.timestamp, \"Bridge: EXPIRED\");\n\n function getDigest(...) {...}\nfunction _claim(...) {...}\nbytes32 digest = getDigest(_claimData, _relayer, _fee, _deadline);\n\n address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n require(\n _claimData.to != address(0) && recoveredAddress == _claimData.to,\n \"Bridge: INVALID_SIGNATURE\"\n );\n\n receivedAmount = _claim(_claimData, _claimData.to, _relayer, _fee);\n\n return receivedAmount;\n }", "function getDigest(\n ClaimData memory _claimData,\n address payable _relayer,\n uint256 _fee,\n uint256 _deadline\n ) internal returns (bytes32) {\n return\n LibEIP712.hashEIP712Message(\n DOMAIN_SEPARATOR,\n keccak256(\n abi.encode(\n CLAIM_TYPEHASH,\n _claimData.to,\n _claimData.amount,\n _claimData.transactionHash,\n _relayer,\n _fee,\n nonces[_claimData.to]++,\n _deadline\n )\n )\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "RSK Token Bridge", "functions": ["function voteTransaction(\n address originalTokenAddress,\n address payable sender,\n address payable receiver,\n uint256 amount,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex\n ) public onlyMember returns (bool) {\n bytes32 transactionId = getTransactionId(\n originalTokenAddress,\n sender,\n receiver,\n amount,\n blockHash,\n transactionHash,\n logIndex\n );\n\n if (processed[transactionId]) return true;\n\n if (votes[transactionId][_msgSender()]) return true;\n\n votes[transactionId][_msgSender()] = true;\n\n emit Voted(\n _msgSender(),\n transactionHash,\n transactionId,\n originalTokenAddress,\n sender,\n receiver,\n amount,\n blockHash,\n logIndex\n );\n\n uint transactionCount = getTransactionCount(transactionId);\n\n if (\n transactionCount >= required &&\n transactionCount >= members.length / 2 + 1\n ) {\n processed[transactionId] = true;\n\n bridge.acceptTransfer(\n originalTokenAddress,\n sender,\n receiver,\n amount,\n blockHash,\n transactionHash,\n logIndex\n );\n\n emit Executed(\n _msgSender(),\n transactionHash,\n transactionId,\n originalTokenAddress,\n sender,\n receiver,\n amount,\n blockHash,\n logIndex\n );\n\n return true;\n }\n\n return true;\n }", "function getTransactionCount(\n bytes32 transactionId\n ) public view returns (uint) {\n uint count = 0;\n\n for (uint i = 0; i < members.length; i++) {\n if (votes[transactionId][members[i]]) count += 1;\n }\n\n return count;\n }", "function getTransactionId(\n address originalTokenAddress,\n address sender,\n address receiver,\n uint256 amount,\n bytes32 blockHash,\n bytes32 transactionHash,\n uint32 logIndex\n ) public pure returns (bytes32) {\n return\n keccak256(\n abi.encodePacked(\n originalTokenAddress,\n sender,\n receiver,\n amount,\n blockHash,\n transactionHash,\n logIndex\n )\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "RSK Token Bridge", "functions": ["function acceptTransfer(\n address _originalTokenAddress,\n address payable _from,\n address payable _to,\n uint256 _amount,\n bytes32 _blockHash,\n bytes32 _transactionHash,\n uint32 _logIndex\n ) external override whenNotPaused nonReentrant {\n function _msgSender(...) {...}\nfunction getTransactionDataHash(...) {...}\nrequire(_msgSender() == federation, \"Bridge: Not Federation\");\n\n require(\n knownTokens[_originalTokenAddress] ||\n mappedTokens[_originalTokenAddress] != NULL_ADDRESS,\n \"Bridge: Unknown token\"\n );\n\n require(_to != NULL_ADDRESS, \"Bridge: Null To\");\n\n require(_amount > 0, \"Bridge: Amount 0\");\n\n require(_blockHash != NULL_HASH, \"Bridge: Null BlockHash\");\n\n require(_transactionHash != NULL_HASH, \"Bridge: Null TxHash\");\n\n require(\n transactionsDataHashes[_transactionHash] == bytes32(0),\n \"Bridge: Already accepted\"\n );\n\n bytes32 _transactionDataHash = getTransactionDataHash(\n _to,\n _amount,\n _blockHash,\n _transactionHash,\n _logIndex\n );\n\n \n\n \n\n require(!claimed[_transactionDataHash], \"Bridge: Already claimed\");\n\n transactionsDataHashes[_transactionHash] = _transactionDataHash;\n\n originalTokenAddresses[_transactionHash] = _originalTokenAddress;\n\n senderAddresses[_transactionHash] = _from;\n\n emit AcceptedCrossTransfer(\n _transactionHash,\n _originalTokenAddress,\n _to,\n _from,\n _amount,\n _blockHash,\n _logIndex\n );\n }", "function getTransactionDataHash(\n address _to,\n uint256 _amount,\n bytes32 _blockHash,\n bytes32 _transactionHash,\n uint32 _logIndex\n ) public pure override returns (bytes32) {\n return\n keccak256(\n abi.encodePacked(\n _blockHash,\n _transactionHash,\n _to,\n _amount,\n _logIndex\n )\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "SafeBridge", "functions": ["function mint(address to, uint256 amount) public onlyOwner {\n function _mint(...) {...}\n_mint(to, amount);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n function _beforeTokenTransfer(...) {...}\nfunction _afterTokenTransfer(...) {...}\n_beforeTokenTransfer(address(0), account, amount);\n\n _totalSupply += amount;\n\n _balances[account] += amount;\n\n emit Transfer(address(0), account, amount);\n\n _afterTokenTransfer(address(0), account, amount);\n }", "function burn(uint256 amount) public virtual {\n _burn(_msgSender(), amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Satellite", "functions": ["function sendToken(\n string calldata destinationChain,\n string calldata destinationAddress,\n string calldata symbol,\n uint256 amount\n ) external {\n function _burnTokenFrom(...) {...}\n_burnTokenFrom(msg.sender, symbol, amount);\n\n emit TokenSent(\n msg.sender,\n destinationChain,\n destinationAddress,\n symbol,\n amount\n );\n }", "function _burnTokenFrom(\n address sender,\n string memory symbol,\n uint256 amount\n ) internal {\n function tokenAddresses(...) {...}\naddress tokenAddress = tokenAddresses(symbol);\n\n if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n if (amount == 0) revert InvalidAmount();\n\n TokenType tokenType = _getTokenType(symbol);\n\n bool burnSuccess;\n\n if (tokenType == TokenType.External) {\n burnSuccess = _callERC20Token(\n tokenAddress,\n abi.encodeWithSelector(\n IERC20.transferFrom.selector,\n sender,\n address(this),\n amount\n )\n );\n\n if (!burnSuccess) revert BurnFailed(symbol);\n\n return;\n }\n\n if (tokenType == TokenType.InternalBurnableFrom) {\n burnSuccess = _callERC20Token(\n tokenAddress,\n abi.encodeWithSelector(\n IBurnableMintableCappedERC20.burnFrom.selector,\n sender,\n amount\n )\n );\n\n if (!burnSuccess) revert BurnFailed(symbol);\n\n return;\n }\n\n burnSuccess = _callERC20Token(\n tokenAddress,\n abi.encodeWithSelector(\n IERC20.transferFrom.selector,\n sender,\n IBurnableMintableCappedERC20(tokenAddress).depositAddress(\n bytes32(0)\n ),\n amount\n )\n );\n\n if (!burnSuccess) revert BurnFailed(symbol);\n\n IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n }", "function burnToken(bytes calldata params, bytes32) external onlySelf {\n (string memory symbol, bytes32 salt) = abi.decode(\n params,\n (string, bytes32)\n );\n\n function tokenAddresses(...) {...}\naddress tokenAddress = tokenAddresses(symbol);\n\n if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n if (_getTokenType(symbol) == TokenType.External) {\n DepositHandler depositHandler = new DepositHandler{salt: salt}();\n\n (bool success, bytes memory returnData) = depositHandler.execute(\n tokenAddress,\n abi.encodeWithSelector(\n IERC20.transfer.selector,\n address(this),\n IERC20(tokenAddress).balanceOf(address(depositHandler))\n )\n );\n\n if (\n !success ||\n (returnData.length != uint256(0) &&\n !abi.decode(returnData, (bool)))\n ) revert BurnFailed(symbol);\n\n \n\n depositHandler.destroy(address(this));\n } else {\n IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Satellite", "functions": ["function callContract(\n string calldata destinationChain,\n string calldata destinationContractAddress,\n bytes calldata payload\n ) external {\n emit ContractCall(\n msg.sender,\n destinationChain,\n destinationContractAddress,\n keccak256(payload),\n payload\n );\n }", "function approveContractCall(\n bytes calldata params,\n bytes32 commandId\n ) external onlySelf {\n (\n string memory sourceChain,\n string memory sourceAddress,\n address contractAddress,\n bytes32 payloadHash,\n bytes32 sourceTxHash,\n uint256 sourceEventIndex\n ) = abi.decode(\n params,\n (string, string, address, bytes32, bytes32, uint256)\n );\n\n _setContractCallApproved(\n commandId,\n sourceChain,\n sourceAddress,\n contractAddress,\n payloadHash\n );\n\n emit ContractCallApproved(\n commandId,\n sourceChain,\n sourceAddress,\n contractAddress,\n payloadHash,\n sourceTxHash,\n sourceEventIndex\n );\n }", "function _setContractCallApproved(\n bytes32 commandId,\n string memory sourceChain,\n string memory sourceAddress,\n address contractAddress,\n bytes32 payloadHash\n ) internal {\n _setBool(\n _getIsContractCallApprovedKey(\n commandId,\n sourceChain,\n sourceAddress,\n contractAddress,\n payloadHash\n ),\n true\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Satellite", "functions": ["function callContractWithToken(\n string calldata destinationChain,\n string calldata destinationContractAddress,\n bytes calldata payload,\n string calldata symbol,\n uint256 amount\n ) external {\n function _burnTokenFrom(...) {...}\n_burnTokenFrom(msg.sender, symbol, amount);\n\n emit ContractCallWithToken(\n msg.sender,\n destinationChain,\n destinationContractAddress,\n keccak256(payload),\n payload,\n symbol,\n amount\n );\n }", "function _burnTokenFrom(\n address sender,\n string memory symbol,\n uint256 amount\n ) internal {\n function tokenAddresses(...) {...}\naddress tokenAddress = tokenAddresses(symbol);\n\n if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n if (amount == 0) revert InvalidAmount();\n\n TokenType tokenType = _getTokenType(symbol);\n\n bool burnSuccess;\n\n if (tokenType == TokenType.External) {\n burnSuccess = _callERC20Token(\n tokenAddress,\n abi.encodeWithSelector(\n IERC20.transferFrom.selector,\n sender,\n address(this),\n amount\n )\n );\n\n if (!burnSuccess) revert BurnFailed(symbol);\n\n return;\n }\n\n if (tokenType == TokenType.InternalBurnableFrom) {\n burnSuccess = _callERC20Token(\n tokenAddress,\n abi.encodeWithSelector(\n IBurnableMintableCappedERC20.burnFrom.selector,\n sender,\n amount\n )\n );\n\n if (!burnSuccess) revert BurnFailed(symbol);\n\n return;\n }\n\n burnSuccess = _callERC20Token(\n tokenAddress,\n abi.encodeWithSelector(\n IERC20.transferFrom.selector,\n sender,\n IBurnableMintableCappedERC20(tokenAddress).depositAddress(\n bytes32(0)\n ),\n amount\n )\n );\n\n if (!burnSuccess) revert BurnFailed(symbol);\n\n IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n }", "function approveContractCallWithMint(\n bytes calldata params,\n bytes32 commandId\n ) external onlySelf {\n (\n string memory sourceChain,\n string memory sourceAddress,\n address contractAddress,\n bytes32 payloadHash,\n string memory symbol,\n uint256 amount,\n bytes32 sourceTxHash,\n uint256 sourceEventIndex\n ) = abi.decode(\n params,\n (\n string,\n string,\n address,\n bytes32,\n string,\n uint256,\n bytes32,\n uint256\n )\n );\n\n _setContractCallApprovedWithMint(\n commandId,\n sourceChain,\n sourceAddress,\n contractAddress,\n payloadHash,\n symbol,\n amount\n );\n\n emit ContractCallApprovedWithMint(\n commandId,\n sourceChain,\n sourceAddress,\n contractAddress,\n payloadHash,\n symbol,\n amount,\n sourceTxHash,\n sourceEventIndex\n );\n }", "function _setContractCallApprovedWithMint(\n bytes32 commandId,\n string memory sourceChain,\n string memory sourceAddress,\n address contractAddress,\n bytes32 payloadHash,\n string memory symbol,\n uint256 amount\n ) internal {\n _setBool(\n _getIsContractCallApprovedWithMintKey(\n commandId,\n sourceChain,\n sourceAddress,\n contractAddress,\n payloadHash,\n symbol,\n amount\n ),\n true\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Satellite", "functions": ["function execute(\n address callee,\n bytes calldata data\n ) external noReenter returns (bool success, bytes memory returnData) {\n if (callee.code.length == 0) revert NotContract();\n\n (success, returnData) = callee.call(data);\n }", "function validateProof(bytes32 messageHash, bytes calldata proof) external view returns (bool) {\n\n (address[] memory operators, uint256[] memory weights, uint256 threshold, bytes[] memory signatures) = abi.decode(\n\n proof,\n\n (address[], uint256[], uint256, bytes[])\n\n );\n\n\n\n bytes32 operatorsHash = keccak256(abi.encode(operators, weights, threshold));\n\n uint256 operatorsEpoch = epochForHash[operatorsHash];\n\n uint256 epoch = currentEpoch;\n\n\n\n if (operatorsEpoch == 0 || epoch - operatorsEpoch >= OLD_KEY_RETENTION) revert InvalidOperators();\n\n\n\n _validateSignatures(messageHash, operators, weights, threshold, signatures);\n\n\n\n return operatorsEpoch == epoch;\n\n }", "function _validateSignatures(\n\n bytes32 messageHash,\n\n address[] memory operators,\n\n uint256[] memory weights,\n\n uint256 threshold,\n\n bytes[] memory signatures\n\n ) internal pure {\n\n uint256 operatorsLength = operators.length;\n\n uint256 operatorIndex = 0;\n\n uint256 weight = 0;\n\n \n\n \n\n for (uint256 i = 0; i < signatures.length; ++i) {\n\n function recover(...) {...}\naddress signer = ECDSA.recover(messageHash, signatures[i]);\n\n \n\n for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}\n\n \n\n if (operatorIndex == operatorsLength) revert MalformedSigners();\n\n \n\n weight += weights[operatorIndex];\n\n \n\n if (weight >= threshold) return;\n\n \n\n ++operatorIndex;\n\n }\n\n \n\n revert LowSignaturesWeight();\n\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "SolarBeam Bridge", "functions": ["function depositPool(\n uint256 _amount,\n uint8 _pid\n ) external override onlyWhenActive nonReentrant {\n UserInfo storage user = userInfo[msg.sender][_pid];\n\n require(_pid < numberPools, \"pool does not exist\");\n\n require(\n poolInfo[_pid].offeringAmount > 0 &&\n poolInfo[_pid].raisingAmount > 0,\n \"Pool not set\"\n );\n\n for (uint8 i = 0; i < numberPools; i++) {\n if (i != _pid) {\n require(\n userInfo[msg.sender][i].amount == 0,\n \"already commited in another pool\"\n );\n }\n }\n\n for (uint256 i = 0; i < NUMBER_VAULT_POOLS; i++) {\n vault.deposit(i, 0);\n }\n\n bool success = getUserEligibility(address(msg.sender));\n\n require(success, \"user not eligible\");\n\n lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n\n user.amount += _amount;\n\n if (poolInfo[_pid].baseLimitInLP > 0) {\n uint16 multiplier = getUserMultiplier(msg.sender);\n\n require(\n user.amount <=\n (poolInfo[_pid].baseLimitInLP * uint256(multiplier)),\n \"New amount above user limit\"\n );\n } else {\n uint16 multiplier = getUserMultiplier(msg.sender);\n\n poolInfo[_pid].totalAllocPoints -= userInfo[msg.sender][_pid]\n .allocPoints;\n\n userInfo[msg.sender][_pid].allocPoints =\n user.amount *\n uint256(multiplier);\n\n poolInfo[_pid].totalAllocPoints += userInfo[msg.sender][_pid]\n .allocPoints;\n }\n\n poolInfo[_pid].totalAmountPool += _amount;\n\n emit Deposit(msg.sender, _amount, _pid);\n }", "function harvestPool(\n uint8 _pid,\n uint8 _harvestPeriod\n ) external nonReentrant {\n require(_pid < 2, \"invalid pid\");\n\n require(\n _harvestPeriod < HARVEST_PERIODS,\n \"harvest period out of range\"\n );\n\n require(\n block.timestamp >\n eclipseV2.harvestReleaseTimestamps(_harvestPeriod),\n \"not harvest time\"\n );\n\n require(\n !userInfo[msg.sender][_pid].claimed[_harvestPeriod],\n \"harvest for period already claimed\"\n );\n\n \n\n uint8[] memory _pids = new uint8[](1);\n\n _pids[0] = _pid;\n\n uint256[3][] memory amountPools = eclipseV2\n .viewUserOfferingAndRefundingAmountsForPools(msg.sender, _pids);\n\n uint256 offeringTokenAmount = amountPools[0][0];\n\n uint256 offeringTokenAmountPerPeriod;\n\n require(offeringTokenAmount > 0, \"did not participate\");\n\n userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;\n\n if (offeringTokenAmount > 0) {\n offeringTokenAmountPerPeriod =\n (offeringTokenAmount *\n eclipseV2.harvestReleasePercent(_harvestPeriod)) /\n 1e4;\n\n offeringTokenAmountPerPeriod =\n offeringTokenAmountPerPeriod *\n exchangeRate;\n\n offeringToken.safeTransfer(\n address(msg.sender),\n offeringTokenAmountPerPeriod\n );\n }\n\n userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;\n\n emit Harvest(msg.sender, offeringTokenAmountPerPeriod, _pid);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "SolarBeam Bridge", "functions": ["function harvestPool(\n uint8 _pid,\n uint8 _harvestPeriod\n ) external override nonReentrant onlyFinished {\n require(_pid < numberPools, \"pool does not exist\");\n\n require(\n _harvestPeriod < HARVEST_PERIODS,\n \"harvest period out of range\"\n );\n\n require(\n block.number > harvestReleaseBlocks[_harvestPeriod],\n \"not harvest time\"\n );\n\n require(userInfo[msg.sender][_pid].amount > 0, \"did not participate\");\n\n require(\n !userInfo[msg.sender][_pid].claimed[_harvestPeriod],\n \"harvest for period already claimed\"\n );\n\n userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;\n\n uint256 offeringTokenAmount;\n\n uint256 refundingTokenAmount;\n\n uint256 userTaxOverflow;\n\n (\n offeringTokenAmount,\n refundingTokenAmount,\n userTaxOverflow\n ) = _calcOfferingAndRefundingAmounts(msg.sender, _pid);\n\n if (userTaxOverflow > 0 && !userInfo[msg.sender][_pid].isRefunded) {\n poolInfo[_pid].sumTaxesOverflow += userTaxOverflow;\n }\n\n if (\n refundingTokenAmount > 0 && !userInfo[msg.sender][_pid].isRefunded\n ) {\n userInfo[msg.sender][_pid].isRefunded = true;\n\n lpToken.safeTransfer(address(msg.sender), refundingTokenAmount);\n }\n\n uint256 offeringTokenAmountPerPeriod;\n\n if (offeringTokenAmount > 0) {\n offeringTokenAmountPerPeriod =\n (offeringTokenAmount * harvestReleasePercent[_harvestPeriod]) /\n 1e4;\n\n offeringToken.safeTransfer(\n address(msg.sender),\n offeringTokenAmountPerPeriod\n );\n }\n\n userInfo[msg.sender][_pid].claimed[_harvestPeriod] = true;\n\n emit Harvest(\n msg.sender,\n offeringTokenAmountPerPeriod,\n refundingTokenAmount,\n _pid\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "SolarBeam Bridge", "functions": ["function create(\n uint256 _value,\n uint256 _days\n ) external override nonReentrant {\n require(_value >= minLockedAmount, \"create: less than min amount\");\n\n require(\n locked[_msgSender()].amount == 0,\n \"create: withdraw old tokens first\"\n );\n\n require(_days >= MINDAYS, \"create: less than min amount of 7 days\");\n\n require(_days <= MAXDAYS, \"create: voting lock can be 4 years max\");\n\n _deposit(_msgSender(), _value, _days);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "SolarBeam Bridge", "functions": ["function withdraw() external override lock {\n LockedBalance storage _locked = locked[_msgSender()];\n\n uint256 _now = block.timestamp;\n\n require(_locked.amount > 0, \"withdraw: nothing to withdraw\");\n\n require(_now >= _locked.end, \"withdraw: user still locked\");\n\n uint256 _amount = _locked.amount;\n\n _locked.end = 0;\n\n _locked.amount = 0;\n\n _burn(_msgSender(), mintedForLock[_msgSender()]);\n\n mintedForLock[_msgSender()] = 0;\n\n IBoringERC20(lockedToken).safeTransfer(_msgSender(), _amount);\n\n emit Withdraw(_msgSender(), _amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "SpookySwap", "functions": ["function mint(address to) external lock returns (uint liquidity) {\n\n (uint112 _reserve0, uint112 _reserve1,) = getReserves(); \n\n uint balance0 = IERC20(token0).balanceOf(address(this));\n\n uint balance1 = IERC20(token1).balanceOf(address(this));\n\n uint amount0 = balance0.sub(_reserve0);\n\n uint amount1 = balance1.sub(_reserve1);\n\n\n\n bool feeOn = _mintFee(_reserve0, _reserve1);\n\n uint _totalSupply = totalSupply; \n\n if (_totalSupply == 0) {\n\n liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n\n _mint(address(0), MINIMUM_LIQUIDITY); \n\n } else {\n\n liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n\n }\n\n require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n\n function _mint(...) {...}\nfunction _update(...) {...}\n_mint(to, liquidity);\n\n\n\n _update(balance0, balance1, _reserve0, _reserve1);\n\n if (feeOn) kLast = uint(reserve0).mul(reserve1); \n\n emit Mint(msg.sender, amount0, amount1);\n\n }", "function _mint(address to, uint value) internal {\n\n function add(...) {...}\ntotalSupply = totalSupply.add(value);\n\n balanceOf[to] = balanceOf[to].add(value);\n\n emit Transfer(address(0), to, value);\n\n }", "function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n\n require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n\n uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n\n uint32 timeElapsed = blockTimestamp - blockTimestampLast; \n\n if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n\n \n\n price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n\n price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n\n }\n\n reserve0 = uint112(balance0);\n\n reserve1 = uint112(balance1);\n\n blockTimestampLast = blockTimestamp;\n\n emit Sync(reserve0, reserve1);\n\n }", "function burn(address to) external lock returns (uint amount0, uint amount1) {\n\n (uint112 _reserve0, uint112 _reserve1,) = getReserves(); \n\n address _token0 = token0; \n\n address _token1 = token1; \n\n uint balance0 = IERC20(_token0).balanceOf(address(this));\n\n uint balance1 = IERC20(_token1).balanceOf(address(this));\n\n uint liquidity = balanceOf[address(this)];\n\n\n\n bool feeOn = _mintFee(_reserve0, _reserve1);\n\n uint _totalSupply = totalSupply; \n\n amount0 = liquidity.mul(balance0) / _totalSupply; \n\n amount1 = liquidity.mul(balance1) / _totalSupply; \n\n require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n\n function _burn(...) {...}\nfunction _safeTransfer(...) {...}\n_burn(address(this), liquidity);\n\n _safeTransfer(_token0, to, amount0);\n\n _safeTransfer(_token1, to, amount1);\n\n balance0 = IERC20(_token0).balanceOf(address(this));\n\n balance1 = IERC20(_token1).balanceOf(address(this));\n\n\n\n _update(balance0, balance1, _reserve0, _reserve1);\n\n if (feeOn) kLast = uint(reserve0).mul(reserve1); \n\n emit Burn(msg.sender, amount0, amount1, to);\n\n }", "function _burn(address from, uint value) internal {\n\n function sub(...) {...}\nbalanceOf[from] = balanceOf[from].sub(value);\n\n totalSupply = totalSupply.sub(value);\n\n emit Transfer(from, address(0), value);\n\n }", "function _safeTransfer(address token, address to, uint value) private {\n\n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Strudel Finance", "functions": ["function deposit(\n address _owner,\n uint256 _amountOrTokenId,\n uint16 _color\n ) public {\n require(_owner == msg.sender, \"owner different from msg.sender\");\n\n _deposit(_amountOrTokenId, _color);\n }", "function _deposit(uint256 _amountOrTokenId, uint16 _color) internal {\n TransferrableToken token = tokens[_color].addr;\n\n require(address(token) != address(0), \"Token color already registered\");\n\n require(\n _amountOrTokenId > 0 || _color > 32769,\n \"no 0 deposits for fungible tokens\"\n );\n\n bytes32 _tokenData;\n\n if (_color >= NST_FIRST_COLOR) {\n IERC1948 nst = IERC1948(address(token));\n\n \n\n _tokenData = nst.readData(_amountOrTokenId);\n }\n\n token.transferFrom(msg.sender, address(this), _amountOrTokenId);\n\n bytes32 tipHash = bridge.tipHash();\n\n uint256 timestamp;\n\n (, timestamp, , ) = bridge.periods(tipHash);\n\n depositCount++;\n\n deposits[depositCount] = Deposit({\n time: uint32(timestamp),\n owner: msg.sender,\n color: _color,\n amount: _amountOrTokenId\n });\n\n if (_color >= NST_FIRST_COLOR) {\n tokenData[depositCount] = _tokenData;\n\n emit NewDepositV2(\n depositCount,\n msg.sender,\n _color,\n _amountOrTokenId,\n _tokenData\n );\n } else {\n emit NewDeposit(depositCount, msg.sender, _color, _amountOrTokenId);\n }\n }", "function startExit(\n bytes32[] memory _youngestInputProof,\n bytes32[] memory _proof,\n uint8 _outputIndex,\n uint8 _inputIndex\n ) public payable {\n require(\n msg.value >= exitStake,\n \"Not enough ether sent to pay for exit stake\"\n );\n\n uint32 timestamp;\n\n (, timestamp) = bridge.periods(_proof[0]);\n\n require(\n timestamp > 0,\n \"The referenced period was not submitted to bridge\"\n );\n\n if (_youngestInputProof.length > 0) {\n (, timestamp) = bridge.periods(_youngestInputProof[0]);\n\n require(\n timestamp > 0,\n \"The referenced period was not submitted to bridge\"\n );\n }\n\n \n\n bytes32 txHash;\n\n bytes memory txData;\n\n uint64 txPos;\n\n (txPos, txHash, txData) = TxLib.validateProof(\n 32 * (_youngestInputProof.length + 2) + 64,\n _proof\n );\n\n \n\n TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n\n TxLib.Output memory out = exitingTx.outs[_outputIndex];\n\n bytes32 utxoId = bytes32(\n (uint256(_outputIndex) << 120) | uint120(uint256(txHash))\n );\n\n require(out.owner == msg.sender, \"Only UTXO owner can start exit\");\n\n require(out.value > 0, \"UTXO has no value\");\n\n require(\n exits[utxoId].amount == 0,\n \"The exit for UTXO has already been started\"\n );\n\n require(\n !exits[utxoId].finalized,\n \"The exit for UTXO has already been finalized\"\n );\n\n uint256 priority;\n\n if (_youngestInputProof.length > 0) {\n \n\n bytes32 inputTxHash;\n\n (txPos, inputTxHash, ) = TxLib.validateProof(\n 96,\n _youngestInputProof\n );\n\n require(\n inputTxHash == exitingTx.ins[_inputIndex].outpoint.hash,\n \"Input from the proof is not referenced in exiting tx\"\n );\n\n if (isNft(out.color)) {\n priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n\n nftExitCounter++;\n } else {\n priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n }\n } else {\n require(\n exitingTx.txType == TxLib.TxType.Deposit,\n \"Expected deposit tx\"\n );\n\n if (isNft(out.color)) {\n priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n\n nftExitCounter++;\n } else {\n priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n }\n }\n\n function insert(...) {...}\ntokens[out.color].insert(priority);\n\n exits[utxoId] = Exit({\n owner: out.owner,\n color: out.color,\n amount: out.value,\n finalized: false,\n stake: exitStake,\n priorityTimestamp: timestamp\n });\n\n emit ExitStarted(txHash, _outputIndex, out.color, out.owner, out.value);\n }", "function insert(Token storage self, uint256 k) public {\n self.heapList.push(k);\n\n function add(...) {...}\nfunction percUp(...) {...}\nself.currentSize = self.currentSize.add(1);\n\n percUp(self, self.currentSize);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Strudel Finance", "functions": ["function finalizeExits(uint16 _color) public {\n bytes32 utxoId;\n\n uint256 exitableAt;\n\n Exit memory currentExit;\n\n (utxoId, exitableAt) = getNextExit(_color);\n\n require(tokens[_color].currentSize > 0, \"Queue empty for color.\");\n\n for (uint i = 0; i < 20; i++) {\n \n\n if (exitableAt > block.timestamp) {\n return;\n }\n\n currentExit = exits[utxoId];\n\n if (currentExit.owner != address(0) || currentExit.amount != 0) {\n \n\n \n\n if (isNft(currentExit.color)) {\n tokens[currentExit.color].addr.transferFrom(\n address(this),\n currentExit.owner,\n currentExit.amount\n );\n } else {\n tokens[currentExit.color].addr.approve(\n address(this),\n currentExit.amount\n );\n\n tokens[currentExit.color].addr.transferFrom(\n address(this),\n currentExit.owner,\n currentExit.amount\n );\n }\n\n \n\n address(uint160(currentExit.owner)).send(currentExit.stake);\n }\n\n tokens[currentExit.color].delMin();\n\n exits[utxoId].finalized = true;\n\n if (tokens[currentExit.color].currentSize > 0) {\n (utxoId, exitableAt) = getNextExit(_color);\n } else {\n return;\n }\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Strudel Finance", "functions": ["function proofOpReturnAndMint(\n bytes calldata _header,\n bytes calldata _proof,\n bytes4 _version,\n bytes4 _locktime,\n uint256 _index,\n uint32 _crossingOutputIndex,\n bytes calldata _vin,\n bytes calldata _vout\n ) external returns (bool) {\n return\n _provideProof(\n _header,\n _proof,\n _version,\n _locktime,\n _index,\n _crossingOutputIndex,\n _vin,\n _vout\n );\n }", "function _provideProof(\n bytes memory _header,\n bytes memory _proof,\n bytes4 _version,\n bytes4 _locktime,\n uint256 _index,\n uint32 _crossingOutputIndex,\n bytes memory _vin,\n bytes memory _vout\n ) internal returns (bool) {\n bytes32 txId = abi\n .encodePacked(_version, _vin, _vout, _locktime)\n .ref(0)\n .hash256();\n\n bytes32 outpoint = makeCompressedOutpoint(txId, _crossingOutputIndex);\n\n require(!knownOutpoints[outpoint], \"already processed outputs\");\n\n _checkInclusion(\n _header.ref(0).tryAsHeader().assertValid(),\n _proof.ref(0).tryAsMerkleArray().assertValid(),\n _index,\n txId\n );\n\n \n\n knownOutpoints[outpoint] = true;\n\n \n\n address account;\n\n uint256 amount;\n\n (account, amount) = doPayouts(\n _vout.ref(0).tryAsVout(),\n _crossingOutputIndex\n );\n\n emit Crossing(txId, account, amount, _crossingOutputIndex);\n\n return true;\n }", "function doPayouts(\n bytes29 _vout,\n uint32 _crossingOutputIndex\n ) internal returns (address account, uint256 amount) {\n bytes29 output = _vout.indexVout(_crossingOutputIndex);\n\n \n\n amount = output.value() * 10 ** 10; \n\n require(amount > 0, \"output has 0 value\");\n\n bytes29 opReturnPayload = output.scriptPubkey().opReturnPayload();\n\n require(\n opReturnPayload.len() == ADDR_LEN + 3,\n \"invalid op-return payload length\"\n );\n\n require(\n bytes3(opReturnPayload.index(0, 3)) == PROTOCOL_ID,\n \"invalid protocol id\"\n );\n\n account = address(bytes20(opReturnPayload.index(3, ADDR_LEN)));\n\n uint256 sqrtVbtcBefore = Babylonian.sqrt(totalSupply());\n\n _mint(account, amount);\n\n uint256 sqrtVbtcAfter = Babylonian.sqrt(totalSupply());\n\n \n\n \n\n \n\n uint256 rewardAmount = BTC_CAP\n .mul(3)\n .mul(sqrtVbtcAfter)\n .add(sqrtVbtcBefore ** 3)\n .sub(BTC_CAP.mul(3).mul(sqrtVbtcBefore))\n .sub(sqrtVbtcAfter ** 3)\n .div(3)\n .div(BTC_CAP_SQRT);\n\n strudel.mint(account, rewardAmount);\n\n strudel.mint(owner(), rewardAmount.div(devFundDivRate));\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Strudel Finance", "functions": ["function challengeYoungestInput(\n bytes32[] memory _youngerInputProof,\n bytes32[] memory _exitingTxProof,\n uint8 _outputIndex,\n uint8 _inputIndex\n ) public {\n \n\n bytes32 txHash;\n\n bytes memory txData;\n\n (, txHash, txData) = TxLib.validateProof(\n 32 * (_youngerInputProof.length + 2) + 64,\n _exitingTxProof\n );\n\n bytes32 utxoId = bytes32(\n (uint256(_outputIndex) << 120) | uint120(uint256(txHash))\n );\n\n \n\n require(exits[utxoId].amount > 0, \"There is no exit for this UTXO\");\n\n TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n\n \n\n (, txHash, ) = TxLib.validateProof(96, _youngerInputProof);\n\n \n\n require(\n txHash == exitingTx.ins[_inputIndex].outpoint.hash,\n \"Given output is not referenced in exiting tx\"\n );\n\n uint32 youngerInputTimestamp;\n\n (, youngerInputTimestamp) = bridge.periods(_youngerInputProof[0]);\n\n require(\n youngerInputTimestamp > 0,\n \"The referenced period was not submitted to bridge\"\n );\n\n require(\n exits[utxoId].priorityTimestamp < youngerInputTimestamp,\n \"Challenged input should be older\"\n );\n\n \n\n msg.sender.transfer(exits[utxoId].stake);\n\n \n\n delete exits[utxoId];\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Suter Bridge", "functions": ["function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n\n require(_value <= balances[msg.sender]);\n\n balances[msg.sender] = sub(balances[msg.sender], _value);\n\n balances[_to] = add(balances[_to], _value);\n\n emit Transfer(msg.sender, _to, _value);\n\n return true;\n }", "function transfer(address recipient, uint256 amount) public returns (bool) {\n _transfer(msg.sender, recipient, amount);\n\n return true;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Suter Bridge", "functions": ["function transferFrom(\n address _from,\n address _to,\n uint256 _value\n ) public returns (bool) {\n require(_to != address(0));\n\n require(_value <= balances[_from]);\n\n require(_value <= allowed[_from][msg.sender]);\n\n function sub(...) {...}\nfunction add(...) {...}\nbalances[_from] = sub(balances[_from], _value);\n\n balances[_to] = add(balances[_to], _value);\n\n allowed[_from][msg.sender] = sub(allowed[_from][msg.sender], _value);\n\n emit Transfer(_from, _to, _value);\n\n return true;\n }", "function _mint(address account, uint256 amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n function add(...) {...}\n_totalSupply = _totalSupply.add(amount);\n\n _balances[account] = _balances[account].add(amount);\n\n emit Transfer(address(0), account, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse Protocol", "functions": ["function deposit(\n address to,\n uint256 chainId,\n IERC20 token,\n uint256 amount\n ) external nonReentrant whenNotPaused {\n emit TokenDeposit(to, chainId, token, amount);\n\n token.safeTransferFrom(msg.sender, address(this), amount);\n }", "function withdraw(\n address to,\n IERC20 token,\n uint256 amount,\n uint256 fee,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\n IWETH9(WETH_ADDRESS).withdraw(amount.sub(fee));\n\n (bool success, ) = to.call{value: amount.sub(fee)}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenWithdraw(to, token, amount, fee, kappa);\n } else {\n emit TokenWithdraw(to, token, amount, fee, kappa);\n\n token.safeTransfer(to, amount.sub(fee));\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse Protocol", "functions": ["function depositAndSwap(\n address to,\n uint256 chainId,\n IERC20 token,\n uint256 amount,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline\n ) external nonReentrant whenNotPaused {\n emit TokenDepositAndSwap(\n to,\n chainId,\n token,\n amount,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline\n );\n\n token.safeTransferFrom(msg.sender, address(this), amount);\n }", "function mintAndSwap(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateSwap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee)\n );\n\n if (expectedOutput >= minDy) {\n \n\n token.mint(address(this), amount);\n\n token.safeIncreaseAllowance(address(pool), amount);\n\n try\n ISwap(pool).swap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee),\n minDy,\n deadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(tokenIndexTo);\n\n if (\n address(swappedTokenTo) == WETH_ADDRESS &&\n WETH_ADDRESS != address(0)\n ) {\n IWETH9(WETH_ADDRESS).withdraw(finalSwappedAmount);\n\n (bool success, ) = to.call{value: finalSwappedAmount}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n } else {\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n }\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n } else {\n token.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse Protocol", "functions": ["function redeem(\n address to,\n uint256 chainId,\n ERC20Burnable token,\n uint256 amount\n ) external nonReentrant whenNotPaused {\n emit TokenRedeem(to, chainId, token, amount);\n\n token.burnFrom(msg.sender, amount);\n }", "function mint(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n emit TokenMint(to, token, amount.sub(fee), fee, kappa);\n\n token.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse Protocol", "functions": ["function redeemAndSwap(\n address to,\n uint256 chainId,\n ERC20Burnable token,\n uint256 amount,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline\n ) external nonReentrant whenNotPaused {\n emit TokenRedeemAndSwap(\n to,\n chainId,\n token,\n amount,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline\n );\n\n token.burnFrom(msg.sender, amount);\n }", "function mintAndSwap(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateSwap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee)\n );\n\n if (expectedOutput >= minDy) {\n \n\n token.mint(address(this), amount);\n\n token.safeIncreaseAllowance(address(pool), amount);\n\n try\n ISwap(pool).swap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee),\n minDy,\n deadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(tokenIndexTo);\n\n if (\n address(swappedTokenTo) == WETH_ADDRESS &&\n WETH_ADDRESS != address(0)\n ) {\n IWETH9(WETH_ADDRESS).withdraw(finalSwappedAmount);\n\n (bool success, ) = to.call{value: finalSwappedAmount}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n } else {\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n }\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n } else {\n token.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse Protocol", "functions": ["function redeemAndRemove(\n address to,\n uint256 chainId,\n ERC20Burnable token,\n uint256 amount,\n uint8 swapTokenIndex,\n uint256 swapMinAmount,\n uint256 swapDeadline\n ) external nonReentrant whenNotPaused {\n emit TokenRedeemAndRemove(\n to,\n chainId,\n token,\n amount,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline\n );\n\n token.burnFrom(msg.sender, amount);\n }", "function withdrawAndRemove(\n address to,\n IERC20 token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 swapTokenIndex,\n uint256 swapMinAmount,\n uint256 swapDeadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateRemoveLiquidityOneToken(\n amount.sub(fee),\n swapTokenIndex\n );\n\n if (expectedOutput >= swapMinAmount) {\n token.safeIncreaseAllowance(address(pool), amount.sub(fee));\n\n try\n ISwap(pool).removeLiquidityOneToken(\n amount.sub(fee),\n swapTokenIndex,\n swapMinAmount,\n swapDeadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(swapTokenIndex);\n\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n finalSwappedAmount,\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n true,\n kappa\n );\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n amount.sub(fee),\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n false,\n kappa\n );\n }\n } else {\n token.safeTransfer(to, amount.sub(fee));\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n amount.sub(fee),\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n false,\n kappa\n );\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse Protocol", "functions": ["function mint(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n emit TokenMint(to, token, amount.sub(fee), fee, kappa);\n\n function mint(...) {...}\ntoken.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse Protocol", "functions": ["function withdraw(\n address to,\n IERC20 token,\n uint256 amount,\n uint256 fee,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\n IWETH9(WETH_ADDRESS).withdraw(amount.sub(fee));\n\n (bool success, ) = to.call{value: amount.sub(fee)}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenWithdraw(to, token, amount, fee, kappa);\n } else {\n emit TokenWithdraw(to, token, amount, fee, kappa);\n\n token.safeTransfer(to, amount.sub(fee));\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse Protocol", "functions": ["function mintAndSwap(\n address payable to,\n IERC20Mintable token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 tokenIndexFrom,\n uint8 tokenIndexTo,\n uint256 minDy,\n uint256 deadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n if (chainGasAmount != 0 && address(this).balance > chainGasAmount) {\n to.call.value(chainGasAmount)(\"\");\n }\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateSwap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee)\n );\n\n if (expectedOutput >= minDy) {\n \n\n function mint(...) {...}\ntoken.mint(address(this), amount);\n\n token.safeIncreaseAllowance(address(pool), amount);\n\n try\n ISwap(pool).swap(\n tokenIndexFrom,\n tokenIndexTo,\n amount.sub(fee),\n minDy,\n deadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(tokenIndexTo);\n\n if (\n address(swappedTokenTo) == WETH_ADDRESS &&\n WETH_ADDRESS != address(0)\n ) {\n IWETH9(WETH_ADDRESS).withdraw(finalSwappedAmount);\n\n (bool success, ) = to.call{value: finalSwappedAmount}(\"\");\n\n require(success, \"ETH_TRANSFER_FAILED\");\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n } else {\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenMintAndSwap(\n to,\n token,\n finalSwappedAmount,\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n true,\n kappa\n );\n }\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n } else {\n function mint(...) {...}\ntoken.mint(address(this), amount);\n\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenMintAndSwap(\n to,\n token,\n amount.sub(fee),\n fee,\n tokenIndexFrom,\n tokenIndexTo,\n minDy,\n deadline,\n false,\n kappa\n );\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Synapse Protocol", "functions": ["function withdrawAndRemove(\n address to,\n IERC20 token,\n uint256 amount,\n uint256 fee,\n ISwap pool,\n uint8 swapTokenIndex,\n uint256 swapMinAmount,\n uint256 swapDeadline,\n bytes32 kappa\n ) external nonReentrant whenNotPaused {\n require(\n hasRole(NODEGROUP_ROLE, msg.sender),\n \"Caller is not a node group\"\n );\n\n require(amount > fee, \"Amount must be greater than fee\");\n\n require(!kappaMap[kappa], \"Kappa is already present\");\n\n kappaMap[kappa] = true;\n\n fees[address(token)] = fees[address(token)].add(fee);\n\n \n\n uint256 expectedOutput = ISwap(pool).calculateRemoveLiquidityOneToken(\n amount.sub(fee),\n swapTokenIndex\n );\n\n if (expectedOutput >= swapMinAmount) {\n token.safeIncreaseAllowance(address(pool), amount.sub(fee));\n\n try\n ISwap(pool).removeLiquidityOneToken(\n amount.sub(fee),\n swapTokenIndex,\n swapMinAmount,\n swapDeadline\n )\n returns (uint256 finalSwappedAmount) {\n \n\n IERC20 swappedTokenTo = ISwap(pool).getToken(swapTokenIndex);\n\n swappedTokenTo.safeTransfer(to, finalSwappedAmount);\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n finalSwappedAmount,\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n true,\n kappa\n );\n } catch {\n IERC20(token).safeTransfer(to, amount.sub(fee));\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n amount.sub(fee),\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n false,\n kappa\n );\n }\n } else {\n token.safeTransfer(to, amount.sub(fee));\n\n emit TokenWithdrawAndRemove(\n to,\n token,\n amount.sub(fee),\n fee,\n swapTokenIndex,\n swapMinAmount,\n swapDeadline,\n false,\n kappa\n );\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ThunderCore Bridge", "functions": ["function transferAndCall(address _to, uint _value, bytes _data)\n external validRecipient(_to) returns (bool)\n {\n function superTransfer(...) {...}\nfunction fundReceiver(...) {...}\nfunction contractFallback(...) {...}\nrequire(superTransfer(_to, _value));\n fundReceiver(_to);\n emit Transfer(msg.sender, _to, _value, _data);\n\n if (isContract(_to)) {\n require(contractFallback(_to, _value, _data));\n }\n return true;\n }", "function superTransfer(address _to, uint256 _value) internal returns(bool)\n {\n function transfer(...) {...}\nreturn super.transfer(_to, _value);\n }", "function fundReceiver(address _to) internal {\n \n if(block.number > fundingRules.periodLength + lastFundingPeriod) {\n lastFundingPeriod = block.number;\n totalPeriodFundedAmount = 0;\n }\n \n if(address(_to).balance < fundingRules.threshold && fundingRules.amount + totalPeriodFundedAmount <= fundingRules.maxPeriodFunds) {\n if(address(_to).send(fundingRules.amount)){\n totalPeriodFundedAmount += fundingRules.amount;\n }\n }\n }", "function contractFallback(address _to, uint _value, bytes _data)\n private\n returns(bool)\n {\n return _to.call(abi.encodeWithSignature(\"onTokenTransfer(address,uint256,bytes)\", msg.sender, _value, _data));\n }", "function tokenTransfer(address _recipient, uint256 _amount) internal returns(bool) {\n return erc20token().call(bytes4(keccak256(\"transfer(address,uint256)\")), _recipient, _amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ThunderCore Bridge", "functions": ["function executeSignatures(uint8[] vs, bytes32[] rs, bytes32[] ss, bytes message) external {\n function hasEnoughValidSignatures(...) {...}\nfunction validatorContract(...) {...}\nfunction relayedMessages(...) {...}\nfunction setRelayedMessages(...) {...}\nfunction onExecuteMessage(...) {...}\nMessage.hasEnoughValidSignatures(message, vs, rs, ss, validatorContract());\n address recipient;\n uint256 amount;\n bytes32 txHash;\n address contractAddress;\n (recipient, amount, txHash, contractAddress) = Message.parseMessage(message);\n if (messageWithinLimits(amount)) {\n require(contractAddress == address(this));\n require(!relayedMessages(txHash));\n setRelayedMessages(txHash, true);\n require(onExecuteMessage(recipient, amount));\n emit RelayedMessage(recipient, amount, txHash);\n } else {\n onFailedMessage(recipient, amount, txHash);\n }\n }", "function hasEnoughValidSignatures(\n bytes _message,\n uint8[] _vs,\n bytes32[] _rs,\n bytes32[] _ss,\n IBridgeValidators _validatorContract) internal view {\n function isMessageValid(...) {...}\nfunction requiredSignatures(...) {...}\nrequire(isMessageValid(_message));\n uint256 requiredSignatures = _validatorContract.requiredSignatures();\n require(_vs.length >= requiredSignatures);\n bytes32 hash = hashMessage(_message);\n address[] memory encounteredAddresses = new address[](requiredSignatures);\n\n for (uint256 i = 0; i < requiredSignatures; i++) {\n address recoveredAddress = ecrecover(hash, _vs[i], _rs[i], _ss[i]);\n require(_validatorContract.isValidator(recoveredAddress));\n if (addressArrayContains(encounteredAddresses, recoveredAddress)) {\n revert();\n }\n encounteredAddresses[i] = recoveredAddress;\n }\n }", "function onExecuteMessage(address _recipient, uint256 _amount) internal returns(bool){\n setTotalExecutedPerDay(getCurrentDay(), totalExecutedPerDay(getCurrentDay()).add(_amount));\n if (feePercent() == 0) {\n function tokenTransfer(...) {...}\nreturn tokenTransfer(_recipient, _amount);\n } else {\n bool result = true;\n uint256 userValue = subtractFee(_amount);\n address[] memory validators = validatorContract().validatorsList();\n uint256 entireValidatorValue = _amount.sub(userValue);\n uint256 particularValidatorValue = entireValidatorValue.div(validators.length);\n for(uint256 i = 0; i < validators.length - 1; i++) {\n result = result && tokenTransfer(validators[i], particularValidatorValue);\n }\n \n uint256 lastValidatorValue = entireValidatorValue.sub(\n particularValidatorValue.mul(validators.length.sub(1))\n );\n result = result && tokenTransfer(validators[validators.length - 1], lastValidatorValue);\n result = result && tokenTransfer(_recipient, userValue);\n return result;\n }\n }", "function tokenTransfer(address _recipient, uint256 _amount) internal returns(bool) {\n function erc20token(...) {...}\nreturn erc20token().call(bytes4(keccak256(\"transfer(address,uint256)\")), _recipient, _amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Time Bridge", "functions": ["function lock(uint256 _toChainId, uint256 _amount) external {\n require(_amount > 0, \"The amount of the lock must not be zero\");\n\n (bool found, ) = indexOfChainId(_toChainId);\n\n require(found, \"ChainId not allowed\");\n\n require(\n erc20Time.allowance(_msgSender(), address(this)) >= _amount,\n \"Not enough allowance\"\n );\n\n erc20Time.safeTransferFrom(_msgSender(), address(this), _amount);\n\n lastLockId++;\n\n emit Locked(_msgSender(), _toChainId, lastLockId, _amount);\n }", "function unlock(\n uint256 _fromChainId,\n uint256 _burnId,\n uint256 _amount,\n bytes[] memory _signatures\n ) external {\n require(!burnIdsUsed[_fromChainId][_burnId], \"Burn id already used\");\n\n bytes32 messageHash = keccak256(\n abi.encodePacked(\n _msgSender(),\n _fromChainId,\n block.chainid,\n _burnId,\n _amount\n )\n );\n\n require(\n checkSignatures(messageHash, _signatures),\n \"Incorrect signature(s)\"\n );\n\n burnIdsUsed[_fromChainId][_burnId] = true;\n\n erc20Time.safeTransfer(_msgSender(), _amount);\n\n emit Unlocked(_msgSender(), _fromChainId, _burnId, _amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Time Bridge", "functions": ["function unlock(\n uint256 _fromChainId,\n uint256 _burnId,\n uint256 _amount,\n bytes[] memory _signatures\n ) external {\n require(!burnIdsUsed[_fromChainId][_burnId], \"Burn id already used\");\n\n bytes32 messageHash = keccak256(\n abi.encodePacked(\n _msgSender(),\n _fromChainId,\n block.chainid,\n _burnId,\n _amount\n )\n );\n\n require(\n checkSignatures(messageHash, _signatures),\n \"Incorrect signature(s)\"\n );\n\n burnIdsUsed[_fromChainId][_burnId] = true;\n\n erc20Time.safeTransfer(_msgSender(), _amount);\n\n emit Unlocked(_msgSender(), _fromChainId, _burnId, _amount);\n }", "function checkSignatures(bytes32 _messageHash, bytes[] memory _signatures) public view returns (bool) {\n\n require(bridgeValidators.length > 0, 'Validators not added');\n\n require(_signatures.length == bridgeValidators.length, 'The number of signatures does not match the number of validators');\n\n bool[] memory markedValidators = new bool[](bridgeValidators.length);\n\n for (uint i = 0; i < _signatures.length; i++) {\n\n address extractedAddress = _messageHash.toEthSignedMessageHash().recover(_signatures[i]);\n\n (bool found, uint index) = indexOfBridgeValidator(extractedAddress);\n\n if (found && !markedValidators[index]) {\n\n markedValidators[index] = true;\n\n } else {\n\n return false;\n\n }\n\n }\n\n return true;\n\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Umbrella Token Bridge", "functions": ["function withdraw(\n bytes32 transactionHash,\n address tokenContract,\n address recipient,\n uint256 value,\n uint8[] memory v,\n bytes32[] memory r,\n bytes32[] memory s\n ) external {\n require(tokenContract != address(0x0), \"should provide a token contract\");\n require(value > 0, \"should provide value\");\n require(transactionHash > 0, \"TX hash should be provided\");\n require(recipient == msg.sender, \"should be the recipient\");\n\n bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));\n\n hashStore.addHash(hash);\n\n require(v.length > 0, \"should provide signatures at least one signature\");\n require(v.length == r.length, \"should the same number of inputs for signatures (r)\");\n require(v.length == s.length, \"should the same number of inputs for signatures (s)\");\n\n require(checkSignatures(hash, v.length, v, r, s) >= requiredOperators, \"not enough signatures to proceed\");\n\n ERC721Mintable(tokenContract).transfer(recipient, value);\n\n LogWithdraw(transactionHash, tokenContract, recipient, value);\n }", "function checkSignatures(\n bytes32 hash,\n uint256 length,\n uint8[] memory v,\n bytes32[] memory r,\n bytes32[] memory s\n ) public view returns(uint8) {\n uint8 approvals = 0;\n\n address prevOperator = address(0x0);\n\n for (uint i = 0; i < length; ++i) {\n address operator = ecrecover(hash, v[i], r[i], s[i]);\n function isOperator(...) {...}\nrequire(isOperator(operator), \"should be an operator\");\n require(prevOperator < operator, \"signatures are out of order\");\n prevOperator = operator;\n approvals ++;\n }\n\n return approvals;\n }", "function canWithdraw(\n bytes32 transactionHash,\n address tokenContract,\n address recipient,\n uint256 value\n ) public view returns (bool) {\n require(tokenContract != address(0x0), \"should provide a token contract\");\n require(recipient != address(0x0), \"should provide a recipient\");\n require(value > 0, \"should provide value\");\n require(transactionHash > 0, \"TX hash should be provided\");\n\n bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));\n\n return !hashStore.hashes(hash);\n }", "function prefixed(bytes32 hash) internal pure returns (bytes32) {\n return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Umbrella Token Bridge", "functions": ["function canMint(\n bytes32 transactionHash,\n address tokenContract,\n address recipient,\n uint256 value\n ) public view returns (bool) {\n require(tokenContract != address(0x0), \"should provide a token contract\");\n require(recipient != address(0x0), \"should provide a recipient\");\n require(value > 0, \"should provide value\");\n require(transactionHash > 0, \"TX hash should be provided\");\n\n bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));\n\n return !hashStore.hashes(hash);\n }", "function prefixed(bytes32 hash) internal pure returns (bytes32) {\n return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Umbrella Token Bridge", "functions": ["function mint(\n bytes32 transactionHash,\n address tokenContract,\n address recipient,\n uint256 value,\n uint8[] memory v,\n bytes32[] memory r,\n bytes32[] memory s\n ) external {\n require(tokenContract != address(0x0), \"should provide a token contract\");\n require(value > 0, \"should provide value\");\n require(transactionHash > 0, \"TX hash should be provided\");\n require(recipient == msg.sender, \"should be the recipient\");\n\n bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));\n\n hashStore.addHash(hash);\n\n require(v.length > 0, \"should provide signatures at least one signature\");\n require(v.length == r.length, \"should the same number of inputs for signatures (r)\");\n require(v.length == s.length, \"should the same number of inputs for signatures (s)\");\n\n require(checkSignatures(hash, v.length, v, r, s) >= requiredOperators, \"not enough signatures to proceed\");\n\n function mint(...) {...}\nERC721Mintable(tokenContract).mint(recipient, value);\n\n emit LogMint(transactionHash, tokenContract, recipient, value);\n }", "function prefixed(bytes32 hash) internal pure returns (bytes32) {\n return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Umbrella Token Bridge", "functions": ["function withdraw(\n bytes32 transactionHash,\n address tokenContract,\n address recipient,\n uint256 value,\n uint8[] memory v,\n bytes32[] memory r,\n bytes32[] memory s\n ) external {\n require(tokenContract != address(0x0), \"should provide a token contract\");\n require(value > 0, \"should provide value\");\n require(transactionHash > 0, \"TX hash should be provided\");\n require(recipient == msg.sender, \"should be the recipient\");\n\n bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));\n\n hashStore.addHash(hash);\n\n require(v.length > 0, \"should provide signatures at least one signature\");\n require(v.length == r.length, \"should the same number of inputs for signatures (r)\");\n require(v.length == s.length, \"should the same number of inputs for signatures (s)\");\n\n require(checkSignatures(hash, v.length, v, r, s) >= requiredOperators, \"not enough signatures to proceed\");\n\n ERC721Mintable(tokenContract).transfer(recipient, value);\n\n LogWithdraw(transactionHash, tokenContract, recipient, value);\n }", "function prefixed(bytes32 hash) internal pure returns (bytes32) {\n return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Umbria Narni Bridge", "functions": ["function transfer(\n address recipient,\n uint256 amount\n ) public virtual override returns (bool) {\n function _transfer(...) {...}\nfunction _msgSender(...) {...}\n_transfer(_msgSender(), recipient, amount);\n\n return true;\n }", "function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender, recipient, amount);\n\n _balances[sender] = _balances[sender].sub(\n amount,\n \"ERC20: transfer amount exceeds balance\"\n );\n\n _balances[recipient] = _balances[recipient].add(amount);\n\n emit Transfer(sender, recipient, amount);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n _beforeTokenTransfer(address(0), account, amount);\n\n function add(...) {...}\n_totalSupply = _totalSupply.add(amount);\n\n _balances[account] = _balances[account].add(amount);\n\n emit Transfer(address(0), account, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Umbria Narni Bridge", "functions": ["function approve(\n address spender,\n uint256 amount\n ) public virtual override returns (bool) {\n function _msgSender(...) {...}\nfunction _approve(...) {...}\n_approve(_msgSender(), spender, amount);\n\n return true;\n }", "function _approve(\n address owner,\n address spender,\n uint256 amount\n ) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n\n emit Approval(owner, spender, amount);\n }", "function _approve(\n address owner,\n address spender,\n uint256 amount\n ) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n\n emit Approval(owner, spender, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Voltage Bridge", "functions": ["function requireToPassMessage(address _contract, bytes _data, uint256 _gas) public returns (bytes32) {\n \n function messageId(...) {...}\nfunction maxGasPerTx(...) {...}\nfunction getMinimumGasUsage(...) {...}\nrequire(messageId() == bytes32(0));\n\n require(_gas >= getMinimumGasUsage(_data) && _gas <= maxGasPerTx());\n\n bytes32 _messageId;\n bytes memory header = _packHeader(_contract, _gas);\n _setNonce(_nonce() + 1);\n\n assembly {\n _messageId := mload(add(header, 32))\n }\n\n bytes memory eventData = abi.encodePacked(header, _data);\n\n emitEventOnMessageRequest(_messageId, eventData);\n return _messageId;\n }", "function handleBridgedTokens(ERC677 _token, address _recipient, uint256 _value) external onlyMediator {\n ERC677 homeToken = ERC677(homeTokenAddress(_token));\n require(isTokenRegistered(homeToken));\n _handleBridgedTokens(homeToken, _recipient, _value);\n }", "function _handleBridgedTokens(ERC677 _token, address _recipient, uint256 _value) internal {\n if (withinExecutionLimit(_token, _value)) {\n addTotalExecutedPerDay(_token, getCurrentDay(), _value);\n executeActionOnBridgedTokens(_token, _recipient, _value);\n } else {\n executeActionOnBridgedTokensOutOfLimit(_token, _recipient, _value);\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Voltage Bridge", "functions": ["function fixFailedMessage(bytes32 _messageId) public onlyMediator {\n function messageFixed(...) {...}\nrequire(!messageFixed(_messageId));\n\n address token = messageToken(_messageId);\n address recipient = messageRecipient(_messageId);\n uint256 value = messageValue(_messageId);\n setMessageFixed(_messageId);\n executeActionOnFixedTokens(token, recipient, value);\n emit FailedMessageFixed(_messageId, token, recipient, value);\n }", "function fixFailedMessage(bytes32 _messageId) public onlyMediator {\n function messageFixed(...) {...}\nrequire(!messageFixed(_messageId));\n\n address token = messageToken(_messageId);\n address recipient = messageRecipient(_messageId);\n uint256 value = messageValue(_messageId);\n setMessageFixed(_messageId);\n executeActionOnFixedTokens(token, recipient, value);\n emit FailedMessageFixed(_messageId, token, recipient, value);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Voltage Bridge", "functions": ["function executeSignatures(bytes _data, bytes _signatures) external {\n function hasEnoughValidSignatures(...) {...}\nfunction validatorContract(...) {...}\nfunction _isMessageVersionValid(...) {...}\nfunction _isDestinationChainIdValid(...) {...}\nfunction relayedMessages(...) {...}\nMessage.hasEnoughValidSignatures(_data, _signatures, validatorContract(), true);\n\n bytes32 messageId;\n address sender;\n address executor;\n uint32 gasLimit;\n bytes1 dataType;\n uint256[2] memory chainIds;\n uint256 gasPrice;\n bytes memory data;\n\n (messageId, sender, executor, gasLimit, dataType, chainIds, gasPrice, data) = ArbitraryMessage.unpackData(\n _data\n );\n require(_isMessageVersionValid(messageId));\n require(_isDestinationChainIdValid(chainIds[1]));\n require(!relayedMessages(messageId));\n setRelayedMessages(messageId, true);\n processMessage(sender, executor, messageId, gasLimit, dataType, gasPrice, chainIds[0], data);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "WAX Token Bridge", "functions": ["function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n\n require(_to != contractAddress);\n\n require(_value <= balances[msg.sender]);\n\n \n\n balances[msg.sender] = balances[msg.sender].sub(_value);\n\n balances[_to] = balances[_to].add(_value);\n\n Transfer(msg.sender, _to, _value);\n\n return true;\n }", "function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n\n require(_to != contractAddress);\n\n require(_value <= balances[msg.sender]);\n\n \n\n balances[msg.sender] = balances[msg.sender].sub(_value);\n\n balances[_to] = balances[_to].add(_value);\n\n Transfer(msg.sender, _to, _value);\n\n return true;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Wormhole", "functions": ["function _transferTokens(address token, uint256 amount, uint256 arbiterFee) internal returns (BridgeStructs.TransferResult memory transferResult) {\n\n \n\n uint16 tokenChain;\n\n bytes32 tokenAddress;\n\n if (isWrappedAsset(token)) {\n\n tokenChain = TokenImplementation(token).chainId();\n\n tokenAddress = TokenImplementation(token).nativeContract();\n\n } else {\n\n tokenChain = chainId();\n\n tokenAddress = bytes32(uint256(uint160(token)));\n\n }\n\n\n\n \n\n (,bytes memory queriedDecimals) = token.staticcall(abi.encodeWithSignature(\"decimals()\"));\n\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n\n\n \n\n amount = deNormalizeAmount(normalizeAmount(amount, decimals), decimals);\n\n\n\n if (tokenChain == chainId()) {\n\n \n\n (,bytes memory queriedBalanceBefore) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\n\n uint256 balanceBefore = abi.decode(queriedBalanceBefore, (uint256));\n\n\n\n \n\n SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n\n\n\n \n\n (,bytes memory queriedBalanceAfter) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\n\n uint256 balanceAfter = abi.decode(queriedBalanceAfter, (uint256));\n\n\n\n \n\n amount = balanceAfter - balanceBefore;\n\n } else {\n\n SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);\n\n\n\n TokenImplementation(token).burn(address(this), amount);\n\n }\n\n\n\n \n\n uint256 normalizedAmount = normalizeAmount(amount, decimals);\n\n uint256 normalizedArbiterFee = normalizeAmount(arbiterFee, decimals);\n\n\n\n \n\n if (tokenChain == chainId()) {\n\n bridgeOut(token, normalizedAmount);\n\n }\n\n\n\n transferResult = BridgeStructs.TransferResult({\n\n tokenChain : tokenChain,\n\n tokenAddress : tokenAddress,\n\n normalizedAmount : normalizedAmount,\n\n normalizedArbiterFee : normalizedArbiterFee,\n\n wormholeFee : msg.value\n\n });\n\n }", "function logTransfer(\n\n uint16 tokenChain,\n\n bytes32 tokenAddress,\n\n uint256 amount,\n\n uint16 recipientChain,\n\n bytes32 recipient,\n\n uint256 fee,\n\n uint256 callValue,\n\n uint32 nonce\n\n ) internal returns (uint64 sequence) {\n\n require(fee <= amount, \"fee exceeds amount\");\n\n\n\n BridgeStructs.Transfer memory transfer = BridgeStructs.Transfer({\n\n payloadID: 1,\n\n amount: amount,\n\n tokenAddress: tokenAddress,\n\n tokenChain: tokenChain,\n\n to: recipient,\n\n toChain: recipientChain,\n\n fee: fee\n\n });\n\n\n\n sequence = wormhole().publishMessage{value: callValue}(\n\n nonce,\n\n encodeTransfer(transfer),\n\n finality()\n\n );\n\n }", "function _completeTransfer(bytes memory encodedVm, bool unwrapWETH) internal returns (bytes memory) {\n\n (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n\n\n require(valid, reason);\n\n function verifyBridgeVM(...) {...}\nrequire(verifyBridgeVM(vm), \"invalid emitter\");\n\n\n\n BridgeStructs.Transfer memory transfer = _parseTransferCommon(vm.payload);\n\n\n\n \n\n address transferRecipient = _truncateAddress(transfer.to);\n\n if (transfer.payloadID == 3) {\n\n require(msg.sender == transferRecipient, \"invalid sender\");\n\n }\n\n\n\n require(!isTransferCompleted(vm.hash), \"transfer already completed\");\n\n setTransferCompleted(vm.hash);\n\n\n\n require(transfer.toChain == chainId(), \"invalid target chain\");\n\n\n\n IERC20 transferToken;\n\n if (transfer.tokenChain == chainId()) {\n\n transferToken = IERC20(_truncateAddress(transfer.tokenAddress));\n\n\n\n \n\n bridgedIn(address(transferToken), transfer.amount);\n\n } else {\n\n address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\n\n require(wrapped != address(0), \"no wrapper for this token created yet\");\n\n\n\n transferToken = IERC20(wrapped);\n\n }\n\n\n\n require(unwrapWETH == false || address(transferToken) == address(WETH()), \"invalid token, can only unwrap WETH\");\n\n\n\n \n\n (,bytes memory queriedDecimals) = address(transferToken).staticcall(abi.encodeWithSignature(\"decimals()\"));\n\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n\n\n \n\n uint256 nativeAmount = deNormalizeAmount(transfer.amount, decimals);\n\n uint256 nativeFee = deNormalizeAmount(transfer.fee, decimals);\n\n\n\n \n\n if (nativeFee > 0 && transferRecipient != msg.sender) {\n\n require(nativeFee <= nativeAmount, \"fee higher than transferred amount\");\n\n\n\n if (unwrapWETH) {\n\n WETH().withdraw(nativeFee);\n\n\n\n payable(msg.sender).transfer(nativeFee);\n\n } else {\n\n if (transfer.tokenChain != chainId()) {\n\n \n\n TokenImplementation(address(transferToken)).mint(msg.sender, nativeFee);\n\n } else {\n\n SafeERC20.safeTransfer(transferToken, msg.sender, nativeFee);\n\n }\n\n }\n\n } else {\n\n \n\n nativeFee = 0;\n\n }\n\n\n\n \n\n uint transferAmount = nativeAmount - nativeFee;\n\n\n\n if (unwrapWETH) {\n\n WETH().withdraw(transferAmount);\n\n\n\n payable(transferRecipient).transfer(transferAmount);\n\n } else {\n\n if (transfer.tokenChain != chainId()) {\n\n \n\n TokenImplementation(address(transferToken)).mint(transferRecipient, transferAmount);\n\n } else {\n\n SafeERC20.safeTransfer(transferToken, transferRecipient, transferAmount);\n\n }\n\n }\n\n\n\n return vm.payload;\n\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Wormhole", "functions": ["function _wrapAndTransferETH(uint256 arbiterFee) internal returns (BridgeStructs.TransferResult memory transferResult) {\n\n uint wormholeFee = wormhole().messageFee();\n\n\n\n require(wormholeFee < msg.value, \"value is smaller than wormhole fee\");\n\n\n\n uint amount = msg.value - wormholeFee;\n\n\n\n require(arbiterFee <= amount, \"fee is bigger than amount minus wormhole fee\");\n\n\n\n uint normalizedAmount = normalizeAmount(amount, 18);\n\n uint normalizedArbiterFee = normalizeAmount(arbiterFee, 18);\n\n\n\n \n\n uint dust = amount - deNormalizeAmount(normalizedAmount, 18);\n\n if (dust > 0) {\n\n payable(msg.sender).transfer(dust);\n\n }\n\n\n\n \n\n WETH().deposit{\n\n value : amount - dust\n\n }();\n\n\n\n \n\n bridgeOut(address(WETH()), normalizedAmount);\n\n\n\n transferResult = BridgeStructs.TransferResult({\n\n tokenChain : chainId(),\n\n tokenAddress : bytes32(uint256(uint160(address(WETH())))),\n\n normalizedAmount : normalizedAmount,\n\n normalizedArbiterFee : normalizedArbiterFee,\n\n wormholeFee : wormholeFee\n\n });\n\n }", "function logTransfer(\n\n uint16 tokenChain,\n\n bytes32 tokenAddress,\n\n uint256 amount,\n\n uint16 recipientChain,\n\n bytes32 recipient,\n\n uint256 fee,\n\n uint256 callValue,\n\n uint32 nonce\n\n ) internal returns (uint64 sequence) {\n\n require(fee <= amount, \"fee exceeds amount\");\n\n\n\n BridgeStructs.Transfer memory transfer = BridgeStructs.Transfer({\n\n payloadID: 1,\n\n amount: amount,\n\n tokenAddress: tokenAddress,\n\n tokenChain: tokenChain,\n\n to: recipient,\n\n toChain: recipientChain,\n\n fee: fee\n\n });\n\n\n\n sequence = wormhole().publishMessage{value: callValue}(\n\n nonce,\n\n encodeTransfer(transfer),\n\n finality()\n\n );\n\n }", "function _completeTransfer(bytes memory encodedVm, bool unwrapWETH) internal returns (bytes memory) {\n\n (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n\n\n require(valid, reason);\n\n function verifyBridgeVM(...) {...}\nrequire(verifyBridgeVM(vm), \"invalid emitter\");\n\n\n\n BridgeStructs.Transfer memory transfer = _parseTransferCommon(vm.payload);\n\n\n\n \n\n address transferRecipient = _truncateAddress(transfer.to);\n\n if (transfer.payloadID == 3) {\n\n require(msg.sender == transferRecipient, \"invalid sender\");\n\n }\n\n\n\n require(!isTransferCompleted(vm.hash), \"transfer already completed\");\n\n setTransferCompleted(vm.hash);\n\n\n\n require(transfer.toChain == chainId(), \"invalid target chain\");\n\n\n\n IERC20 transferToken;\n\n if (transfer.tokenChain == chainId()) {\n\n transferToken = IERC20(_truncateAddress(transfer.tokenAddress));\n\n\n\n \n\n bridgedIn(address(transferToken), transfer.amount);\n\n } else {\n\n address wrapped = wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\n\n require(wrapped != address(0), \"no wrapper for this token created yet\");\n\n\n\n transferToken = IERC20(wrapped);\n\n }\n\n\n\n require(unwrapWETH == false || address(transferToken) == address(WETH()), \"invalid token, can only unwrap WETH\");\n\n\n\n \n\n (,bytes memory queriedDecimals) = address(transferToken).staticcall(abi.encodeWithSignature(\"decimals()\"));\n\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n\n\n \n\n uint256 nativeAmount = deNormalizeAmount(transfer.amount, decimals);\n\n uint256 nativeFee = deNormalizeAmount(transfer.fee, decimals);\n\n\n\n \n\n if (nativeFee > 0 && transferRecipient != msg.sender) {\n\n require(nativeFee <= nativeAmount, \"fee higher than transferred amount\");\n\n\n\n if (unwrapWETH) {\n\n WETH().withdraw(nativeFee);\n\n\n\n payable(msg.sender).transfer(nativeFee);\n\n } else {\n\n if (transfer.tokenChain != chainId()) {\n\n \n\n TokenImplementation(address(transferToken)).mint(msg.sender, nativeFee);\n\n } else {\n\n SafeERC20.safeTransfer(transferToken, msg.sender, nativeFee);\n\n }\n\n }\n\n } else {\n\n \n\n nativeFee = 0;\n\n }\n\n\n\n \n\n uint transferAmount = nativeAmount - nativeFee;\n\n\n\n if (unwrapWETH) {\n\n WETH().withdraw(transferAmount);\n\n\n\n payable(transferRecipient).transfer(transferAmount);\n\n } else {\n\n if (transfer.tokenChain != chainId()) {\n\n \n\n TokenImplementation(address(transferToken)).mint(transferRecipient, transferAmount);\n\n } else {\n\n SafeERC20.safeTransfer(transferToken, transferRecipient, transferAmount);\n\n }\n\n }\n\n\n\n return vm.payload;\n\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Wormhole", "functions": ["function attestToken(address tokenAddress, uint32 nonce) public payable returns (uint64 sequence) {\n\n \n\n (,bytes memory queriedDecimals) = tokenAddress.staticcall(abi.encodeWithSignature(\"decimals()\"));\n\n (,bytes memory queriedSymbol) = tokenAddress.staticcall(abi.encodeWithSignature(\"symbol()\"));\n\n (,bytes memory queriedName) = tokenAddress.staticcall(abi.encodeWithSignature(\"name()\"));\n\n\n\n uint8 decimals = abi.decode(queriedDecimals, (uint8));\n\n\n\n string memory symbolString = abi.decode(queriedSymbol, (string));\n\n string memory nameString = abi.decode(queriedName, (string));\n\n\n\n bytes32 symbol;\n\n bytes32 name;\n\n assembly {\n\n \n\n symbol := mload(add(symbolString, 32))\n\n name := mload(add(nameString, 32))\n\n }\n\n\n\n BridgeStructs.AssetMeta memory meta = BridgeStructs.AssetMeta({\n\n payloadID : 2,\n\n tokenAddress : bytes32(uint256(uint160(tokenAddress))), \n\n tokenChain : chainId(), \n\n decimals : decimals, \n\n symbol : symbol, \n\n name : name \n\n });\n\n\n\n function encodeAssetMeta(...) {...}\nbytes memory encoded = encodeAssetMeta(meta);\n\n\n\n sequence = wormhole().publishMessage{\n\n value : msg.value\n\n }(nonce, encoded, finality());\n\n }", "function updateWrapped(bytes memory encodedVm) external returns (address token) {\n\n (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole().parseAndVerifyVM(encodedVm);\n\n\n\n require(valid, reason);\n\n function verifyBridgeVM(...) {...}\nrequire(verifyBridgeVM(vm), \"invalid emitter\");\n\n\n\n BridgeStructs.AssetMeta memory meta = parseAssetMeta(vm.payload);\n\n return _updateWrapped(meta, vm.sequence);\n\n }", "function _updateWrapped(BridgeStructs.AssetMeta memory meta, uint64 sequence) internal returns (address token) {\n\n address wrapped = wrappedAsset(meta.tokenChain, meta.tokenAddress);\n\n require(wrapped != address(0), \"wrapped asset does not exists\");\n\n\n\n \n\n TokenImplementation(wrapped).updateDetails(bytes32ToString(meta.name), bytes32ToString(meta.symbol), sequence);\n\n\n\n return wrapped;\n\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Wormhole", "functions": ["function verifySignatures(\n bytes32 hash,\n Structs.Signature[] memory signatures,\n Structs.GuardianSet memory guardianSet\n ) public pure returns (bool valid, string memory reason) {\n uint8 lastIndex = 0;\n\n uint256 guardianCount = guardianSet.keys.length;\n\n for (uint i = 0; i < signatures.length; i++) {\n Structs.Signature memory sig = signatures[i];\n\n \n\n require(\n i == 0 || sig.guardianIndex > lastIndex,\n \"signature indices must be ascending\"\n );\n\n lastIndex = sig.guardianIndex;\n\n \n\n \n\n \n\n \n\n \n\n \n\n require(\n sig.guardianIndex < guardianCount,\n \"guardian index out of bounds\"\n );\n\n \n\n if (\n ecrecover(hash, sig.v, sig.r, sig.s) !=\n guardianSet.keys[sig.guardianIndex]\n ) {\n return (false, \"VM signature invalid\");\n }\n }\n\n \n\n return (true, \"\");\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "xDai Bridge", "functions": ["function _relayTokens(\n address _sender,\n address _receiver,\n uint256 _amount\n ) internal {\n require(_receiver != address(0));\n\n require(_receiver != address(this));\n\n require(_amount > 0);\n\n function withinLimit(...) {...}\nrequire(withinLimit(_amount));\n\n setTotalSpentPerDay(\n getCurrentDay(),\n totalSpentPerDay(getCurrentDay()).add(_amount)\n );\n\n erc20token().transferFrom(_sender, address(this), _amount);\n\n emit UserRequestForAffirmation(_receiver, _amount);\n }", "function claimTokens(\n address _token,\n address _to\n ) external onlyIfUpgradeabilityOwner {\n \n\n require(_token != address(erc20token()));\n\n function claimValues(...) {...}\nclaimValues(_token, _to);\n }", "function claimErc20Tokens(address _token, address _to) internal {\n ERC20Basic token = ERC20Basic(_token);\n\n uint256 balance = token.balanceOf(this);\n\n function safeTransfer(...) {...}\n_token.safeTransfer(_to, balance);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "xDai Bridge", "functions": ["function claimTokens(\n address _token,\n address _to\n ) public onlyIfUpgradeabilityOwner validAddress(_to) {\n function claimValues(...) {...}\nclaimValues(_token, _to);\n }", "function claimValues(address _token, address _to) internal {\n if (_token == address(0)) {\n function claimNativeCoins(...) {...}\nfunction claimErc20Tokens(...) {...}\nclaimNativeCoins(_to);\n } else {\n claimErc20Tokens(_token, _to);\n }\n }", "function claimErc20Tokens(address _token, address _to) internal {\n\n IERC20 token = IERC20(_token);\n\n uint256 balance = token.balanceOf(address(this));\n\n token.safeTransfer(_to, balance);\n\n }", "function onExecuteMessage(\n address _recipient,\n uint256 _amount,\n bytes32 \n ) internal returns (bool) {\n function addTotalExecutedPerDay(...) {...}\nfunction getCurrentDay(...) {...}\naddTotalExecutedPerDay(getCurrentDay(), _amount);\n\n return erc20token().transfer(_recipient, _unshiftValue(_amount));\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "xDai Bridge", "functions": ["function executeSignatures(bytes _data, bytes _signatures) public {\n function _allowMessageExecution(...) {...}\n_allowMessageExecution(_data, _signatures);\n\n bytes32 msgId;\n\n address sender;\n\n address executor;\n\n uint32 gasLimit;\n\n uint8 dataType;\n\n uint256[2] memory chainIds;\n\n bytes memory data;\n\n (\n msgId,\n sender,\n executor,\n gasLimit,\n dataType,\n chainIds,\n data\n ) = ArbitraryMessage.unpackData(_data);\n\n _executeMessage(\n msgId,\n sender,\n executor,\n gasLimit,\n dataType,\n chainIds,\n data\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "xDai Bridge", "functions": ["function executeSignaturesGSN(\n bytes message,\n bytes signatures,\n uint256 maxTokensFee\n ) external {\n \n\n require(isTrustedForwarder(msg.sender), \"invalid forwarder\");\n\n Message.hasEnoughValidSignatures(\n message,\n signatures,\n validatorContract(),\n false\n );\n\n address recipient;\n\n uint256 amount;\n\n bytes32 txHash;\n\n address contractAddress;\n\n (recipient, amount, txHash, contractAddress) = Message.parseMessage(\n message\n );\n\n if (withinExecutionLimit(amount)) {\n require(maxTokensFee <= amount);\n\n require(contractAddress == address(this));\n\n require(!relayedMessages(txHash));\n\n setRelayedMessages(txHash, true);\n\n require(onExecuteMessageGSN(recipient, amount, maxTokensFee));\n\n emit RelayedMessage(recipient, amount, txHash);\n } else {\n onFailedMessage(recipient, amount, txHash);\n }\n }", "function onExecuteMessageGSN(\n address recipient,\n uint256 amount,\n uint256 fee\n ) internal returns (bool) {\n function addTotalExecutedPerDay(...) {...}\nfunction getCurrentDay(...) {...}\nfunction erc20token(...) {...}\naddTotalExecutedPerDay(getCurrentDay(), amount);\n\n \n\n ERC20 token = erc20token();\n\n bool first = token.transfer(addressStorage[PAYMASTER], fee);\n\n bool second = token.transfer(recipient, amount - fee);\n\n return first && second;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Xenum", "functions": ["function _transferFungible(\n address token,\n uint256 amount,\n uint256 networkId\n ) internal {\n \n\n IERC20Upgradeable(token).transferFrom(\n _msgSender(),\n address(this),\n amount\n );\n\n emit TokenTransferFungible(_msgSender(), token, amount, networkId);\n }", "function bridgeClaimFungible(\n address _token,\n address _to,\n uint256 _amount\n ) external virtual override onlyController {\n if (IERC20Upgradeable(_token).balanceOf(address(this)) < _amount)\n revert InsufficientFunds(\n _amount,\n IERC20Upgradeable(_token).balanceOf(address(this))\n );\n\n IERC20Upgradeable(_token).transfer(_to, _amount);\n\n emit TokenClaimedFungible(_to, _token, _amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Xenum", "functions": ["function _transferNonFungible(\n address _token,\n uint256 _tokenId,\n uint256 _networkId\n ) internal {\n \n\n IERC721Upgradeable(_token).transferFrom(\n _msgSender(),\n address(this),\n _tokenId\n );\n\n emit TokenTransferNonFungible(\n _msgSender(),\n _token,\n _tokenId,\n _networkId\n );\n }", "function bridgeClaimNonFungible(\n address _token,\n address _to,\n uint256 _tokenId\n ) external virtual override onlyController {\n address tokenOwner;\n\n \n\n try IERC721Bridgable(_token).ownerOf(_tokenId) returns (address owner) {\n tokenOwner = owner;\n } catch {\n tokenOwner = address(0);\n }\n\n \n\n \n\n \n\n \n\n if (tokenOwner == address(0)) {\n IERC721Bridgable(_token).bridgeMint(_to, _tokenId);\n } else {\n \n\n IERC721Bridgable(_token).transferFrom(address(this), _to, _tokenId);\n }\n\n emit TokenClaimedNonFungible(_to, _token, _tokenId);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Xenum", "functions": ["function _transferMixedFungible(\n address _token,\n uint256 _tokenId,\n uint256 _amount,\n uint256 _networkId\n ) internal {\n \n\n IERC1155Upgradeable(_token).safeTransferFrom(\n _msgSender(),\n address(this),\n _tokenId,\n _amount,\n \"\"\n );\n\n emit TokenTransferMixedFungible(\n _msgSender(),\n _token,\n _tokenId,\n _amount,\n _networkId\n );\n }", "function bridgeClaimMixedFungible(\n address token,\n address to,\n uint256 tokenId,\n uint256 amount\n ) external virtual override onlyController {\n \n\n uint256 balance = IERC1155Bridgable(token).balanceOf(\n address(this),\n tokenId\n );\n\n uint256 balanceToMint = 0;\n\n uint256 balanceToTransfer = amount;\n\n if (balance < amount) {\n balanceToMint = amount - balance;\n\n balanceToTransfer = balance;\n }\n\n IERC1155Bridgable(token).safeTransferFrom(\n address(this),\n to,\n tokenId,\n balanceToTransfer,\n \"\"\n );\n\n if (balanceToMint > 0) {\n IERC1155Bridgable(token).bridgeMint(to, tokenId, balanceToMint);\n }\n\n emit TokenClaimedMixedFungible(to, token, tokenId, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Xenum", "functions": ["function sendMessage(\n uint256 _messageId,\n uint256 _destination,\n string calldata _recipient,\n bool _receipt,\n bytes calldata _message,\n bytes calldata\n ) external payable virtual override {\n \n\n if (msg.value != 0) revert FunctionNotPayable();\n\n function _sendMessage(...) {...}\n_sendMessage(_messageId, _destination, _recipient, _receipt, _message);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Xenum", "functions": ["function sendBroadcast(\n uint256 _messageId,\n bool _receipt,\n bytes calldata _message,\n bytes calldata\n ) external payable virtual override {\n \n\n if (msg.value != 0) revert FunctionNotPayable();\n\n function _sendBroadcast(...) {...}\n_sendBroadcast(_messageId, _receipt, _message);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Xenum", "functions": ["function relayMessage(\n IMessageReceiver _recipient,\n uint256 _messageId,\n string calldata _sender,\n uint256 _fromNetworkId,\n bool _receipt,\n bytes calldata _message\n ) external virtual override onlyController returns (bool success) {\n try\n _recipient.receiveBridgeMessage(_sender, _fromNetworkId, _message)\n returns (bool result) {\n success = result;\n } catch {\n success = false;\n }\n\n emit MessageReceived(\n _recipient,\n _sender,\n _fromNetworkId,\n success,\n _messageId,\n _receipt\n );\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "XP Network Bridge", "functions": ["function mint(\n address to,\n uint256 id,\n bytes calldata\n ) external override onlyOwner {\n _safeMint(to, id);\n }", "function _safeMint(address to, uint256 tokenId) internal virtual {\n _safeMint(to, tokenId, \"\");\n }", "function _mint(address to, uint256 tokenId) internal virtual {\n require(to != address(0), \"ERC721: mint to the zero address\");\n\n function _exists(...) {...}\nfunction _beforeTokenTransfer(...) {...}\nfunction _afterTokenTransfer(...) {...}\nrequire(!_exists(tokenId), \"ERC721: token already minted\");\n\n _beforeTokenTransfer(address(0), to, tokenId);\n\n _balances[to] += 1;\n\n _owners[tokenId] = to;\n\n emit Transfer(address(0), to, tokenId);\n\n _afterTokenTransfer(address(0), to, tokenId);\n }", "function burnFor(address from, uint256 id) external override onlyOwner {\n require(ownerOf(id) == from, \"You don't own this nft!\");\n\n _burn(id);\n }", "function _burn(uint256 tokenId) internal virtual {\n function ownerOf(...) {...}\nfunction _beforeTokenTransfer(...) {...}\nfunction _approve(...) {...}\nfunction _afterTokenTransfer(...) {...}\naddress owner = ERC721.ownerOf(tokenId);\n\n _beforeTokenTransfer(owner, address(0), tokenId);\n\n \n\n _approve(address(0), tokenId);\n\n _balances[owner] -= 1;\n\n delete _owners[tokenId];\n\n emit Transfer(owner, address(0), tokenId);\n\n _afterTokenTransfer(owner, address(0), tokenId);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Zapper", "functions": ["function ZapIn(\n address fromToken,\n uint256 amountIn,\n address cToken,\n uint256 minCtokens,\n address swapTarget,\n bytes calldata swapData,\n address affiliate\n ) external payable stopInEmergency returns (uint256 cTokensRec) {\n uint256 toInvest = _pullTokens(fromToken, amountIn, affiliate, true);\n\n address toToken = getUnderlyingToken(cToken);\n\n uint256 tokensBought =\n _fillQuote(fromToken, toToken, toInvest, swapTarget, swapData);\n\n (cTokensRec) = enterCompound(cToken, toToken, tokensBought);\n require(cTokensRec > minCtokens, \"High Slippage\");\n\n IERC20(cToken).safeTransfer(msg.sender, cTokensRec);\n\n emit zapIn(msg.sender, cToken, cTokensRec);\n }", "function _pullTokens(\n address token,\n uint256 amount,\n bool shouldSellEntireBalance\n ) internal returns (uint256) {\n if (shouldSellEntireBalance) {\n require(\n Address.isContract(msg.sender),\n \"ERR: shouldSellEntireBalance is true for EOA\"\n );\n\n uint256 allowance = IERC20(token).allowance(\n msg.sender,\n address(this)\n );\n\n IERC20(token).safeTransferFrom(\n msg.sender,\n address(this),\n allowance\n );\n\n return allowance;\n } else {\n IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n return amount;\n }\n }", "function safeTransferFrom(\n address from,\n address to,\n uint256 id,\n uint256 amount,\n bytes memory data\n ) public virtual override {\n require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n require(\n from == _msgSender() || isApprovedForAll(from, _msgSender()),\n \"ERC1155: caller is not owner nor approved\"\n );\n\n address operator = _msgSender();\n\n _beforeTokenTransfer(\n operator,\n from,\n to,\n _asSingletonArray(id),\n _asSingletonArray(amount),\n data\n );\n\n uint256 fromBalance = _balances[id][from];\n\n require(\n fromBalance >= amount,\n \"ERC1155: insufficient balance for transfer\"\n );\n\n _balances[id][from] = fromBalance - amount;\n\n _balances[id][to] += amount;\n\n emit TransferSingle(operator, from, to, id, amount);\n\n _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n }", "function ZapOut(\n address fromToken,\n uint256 amountIn,\n address toToken,\n uint256 minToTokens,\n address swapTarget,\n bytes calldata swapData,\n address affiliate\n ) public stopInEmergency returns (uint256 tokensRec) {\n amountIn = _pullTokens(fromToken, amountIn);\n\n address underlyingToken = getUnderlyingToken(fromToken);\n\n uint256 underlyingRec =\n exitCompound(fromToken, amountIn, underlyingToken);\n\n tokensRec = _fillQuote(\n underlyingToken,\n toToken,\n underlyingRec,\n swapTarget,\n swapData\n );\n\n require(tokensRec >= minToTokens, \"High Slippage\");\n\n uint256 totalGoodwillPortion;\n\n if (toToken == address(0)) {\n totalGoodwillPortion = _subtractGoodwill(\n ETHAddress,\n tokensRec,\n affiliate,\n true\n );\n\n payable(msg.sender).transfer(tokensRec - totalGoodwillPortion);\n } else {\n totalGoodwillPortion = _subtractGoodwill(\n toToken,\n tokensRec,\n affiliate,\n true\n );\n\n IERC20(toToken).safeTransfer(\n msg.sender,\n tokensRec - totalGoodwillPortion\n );\n }\n\n tokensRec = tokensRec - totalGoodwillPortion;\n\n emit zapOut(msg.sender, toToken, tokensRec);\n }", "function _pullTokens(\n address token,\n uint256 amount,\n bool shouldSellEntireBalance\n ) internal returns (uint256) {\n if (shouldSellEntireBalance) {\n require(\n Address.isContract(msg.sender),\n \"ERR: shouldSellEntireBalance is true for EOA\"\n );\n\n uint256 allowance = IERC20(token).allowance(\n msg.sender,\n address(this)\n );\n\n IERC20(token).safeTransferFrom(\n msg.sender,\n address(this),\n allowance\n );\n\n return allowance;\n } else {\n IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n return amount;\n }\n }", "function safeTransferFrom(\n address from,\n address to,\n uint256 id,\n uint256 amount,\n bytes memory data\n ) public virtual override {\n require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n require(\n from == _msgSender() || isApprovedForAll(from, _msgSender()),\n \"ERC1155: caller is not owner nor approved\"\n );\n\n address operator = _msgSender();\n\n _beforeTokenTransfer(\n operator,\n from,\n to,\n _asSingletonArray(id),\n _asSingletonArray(amount),\n data\n );\n\n uint256 fromBalance = _balances[id][from];\n\n require(\n fromBalance >= amount,\n \"ERC1155: insufficient balance for transfer\"\n );\n\n _balances[id][from] = fromBalance - amount;\n\n _balances[id][to] += amount;\n\n emit TransferSingle(operator, from, to, id, amount);\n\n _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Zapper", "functions": ["function _fillQuote(\n address fromToken,\n address toToken,\n uint256 _amount,\n address swapTarget,\n bytes memory swapData\n ) internal returns (uint256 amountBought) {\n if (fromToken == toToken) {\n return _amount;\n }\n\n if (fromToken == address(0) && toToken == wethTokenAddress) {\n IWETH(wethTokenAddress).deposit{ value: _amount }();\n return _amount;\n }\n\n if (fromToken == wethTokenAddress && toToken == address(0)) {\n IWETH(wethTokenAddress).withdraw(_amount);\n return _amount;\n }\n\n uint256 valueToSend;\n if (fromToken == address(0)) {\n valueToSend = _amount;\n } else {\n _approveToken(fromToken, swapTarget);\n }\n\n uint256 initialBalance = _getBalance(toToken);\n\n require(approvedTargets[swapTarget], \"Target not Authorized\");\n (bool success, ) = swapTarget.call{ value: valueToSend }(swapData);\n require(success, \"Error Swapping Tokens\");\n\n amountBought = _getBalance(toToken) - initialBalance;\n\n require(amountBought > 0, \"Swapped To Invalid Intermediate\");\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Zapper", "functions": ["function _subtractGoodwill(\n address token,\n uint256 amount,\n address affiliate,\n bool enableGoodwill\n ) internal returns (uint256 totalGoodwillPortion) {\n bool whitelisted = feeWhitelist[msg.sender];\n\n if (enableGoodwill && !whitelisted && goodwill > 0) {\n totalGoodwillPortion = (amount * goodwill) / 10000;\n\n if (affiliates[affiliate]) {\n if (token == address(0)) {\n token = ETHAddress;\n }\n\n uint256 affiliatePortion = (totalGoodwillPortion *\n affiliateSplit) / 100;\n\n affiliateBalance[affiliate][token] += affiliatePortion;\n\n totalAffiliateBalance[token] += affiliatePortion;\n }\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Zeroswap", "functions": ["function stake(uint256 amount) public updateReward(msg.sender) {\n require(amount > 0, \"Cannot stake 0\");\n\n function add(...) {...}\nfunction safeTransferFrom(...) {...}\n_totalSupply = _totalSupply.add(amount);\n\n _balances[msg.sender] = _balances[msg.sender].add(amount);\n\n stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n\n emit Staked(msg.sender, amount);\n }", "function safeTransferFrom(\n IERC20 token,\n address from,\n address to,\n uint256 value\n ) internal {\n _callOptionalReturn(\n token,\n abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n );\n }", "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n \n\n \n\n \n\n bytes memory returndata = address(token).functionCall(\n data,\n \"SafeERC20: low-level call failed\"\n );\n\n if (returndata.length > 0) {\n \n\n \n\n require(\n abi.decode(returndata, (bool)),\n \"SafeERC20: ERC20 operation did not succeed\"\n );\n }\n }", "function unstake(uint256 amount) public updateReward(msg.sender) {\n require(amount > 0, \"Cannot withdraw 0\");\n\n function sub(...) {...}\nfunction safeTransfer(...) {...}\n_totalSupply = _totalSupply.sub(amount);\n\n _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n stakeToken.safeTransfer(msg.sender, amount);\n\n emit Unstaked(msg.sender, amount);\n }", "function safeTransfer(IERC20 token, address to, uint256 value) internal {\n _callOptionalReturn(\n token,\n abi.encodeWithSelector(token.transfer.selector, to, value)\n );\n }", "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n \n\n \n\n \n\n bytes memory returndata = address(token).functionCall(\n data,\n \"SafeERC20: low-level call failed\"\n );\n\n if (returndata.length > 0) {\n \n\n \n\n require(\n abi.decode(returndata, (bool)),\n \"SafeERC20: ERC20 operation did not succeed\"\n );\n }\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "Zeroswap", "functions": ["function notifyRewardAmount(\n uint256 reward\n ) external onlyRewardDistribution updateReward(address(0)) {\n if (block.timestamp >= periodFinish) {\n rewardRate = reward.div(DURATION);\n } else {\n uint256 remaining = periodFinish.sub(block.timestamp);\n\n uint256 leftover = remaining.mul(rewardRate);\n\n rewardRate = reward.add(leftover).div(DURATION);\n }\n\n lastUpdateTime = block.timestamp;\n\n function add(...) {...}\nperiodFinish = block.timestamp.add(DURATION);\n\n emit RewardAdded(reward);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "ZigZag Bridge", "functions": ["function _transfer(\n address from,\n address to,\n uint256 amount\n ) internal virtual {\n require(from != address(0), \"ERC20: transfer from the zero address\");\n\n require(to != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(from, to, amount);\n\n uint256 fromBalance = _balances[from];\n\n require(\n fromBalance >= amount,\n \"ERC20: transfer amount exceeds balance\"\n );\n\n unchecked {\n _balances[from] = fromBalance - amount;\n }\n\n _balances[to] += amount;\n\n emit Transfer(from, to, amount);\n\n _afterTokenTransfer(from, to, amount);\n }", "function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n _beforeTokenTransfer(address(0), account, amount);\n\n _totalSupply += amount;\n\n _balances[account] += amount;\n\n emit Transfer(address(0), account, amount);\n\n _afterTokenTransfer(address(0), account, amount);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "zkSync Portal Bridge", "functions": ["function depositERC20(\n IERC20 _token,\n uint104 _amount,\n address _zkSyncAddress\n ) external nonReentrant {\n require(_zkSyncAddress != SPECIAL_ACCOUNT_ADDRESS, \"P\");\n\n requireActive();\n\n \n\n uint16 tokenId = governance.validateTokenAddress(address(_token));\n\n require(!governance.pausedTokens(tokenId), \"b\"); \n\n uint256 balanceBefore = _token.balanceOf(address(this));\n\n _token.transferFrom(msg.sender, address(this), _amount);\n\n uint256 balanceAfter = _token.balanceOf(address(this));\n\n uint128 depositAmount = SafeCast.toUint128(\n balanceAfter.sub(balanceBefore)\n );\n\n require(depositAmount > 0 && depositAmount <= MAX_DEPOSIT_AMOUNT, \"C\");\n\n function registerDeposit(...) {...}\nregisterDeposit(tokenId, depositAmount, _zkSyncAddress);\n }", "function registerDeposit(\n uint16 _tokenId,\n uint128 _amount,\n address _owner\n ) internal {\n \n\n Operations.Deposit memory op = Operations.Deposit({\n accountId: 0, \n owner: _owner,\n tokenId: _tokenId,\n amount: _amount\n });\n\n bytes memory pubData = Operations.writeDepositPubdataForPriorityQueue(\n op\n );\n\n function addPriorityRequest(...) {...}\naddPriorityRequest(Operations.OpType.Deposit, pubData);\n\n emit Deposit(_tokenId, _amount);\n }", "function withdraw() external onlyOwner {\n uint256 balance = address(this).balance;\n\n payable(msg.sender).transfer(balance);\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "zkSync Portal Bridge", "functions": ["function withdrawPendingBalance(\n address payable _owner,\n address _token,\n uint128 _amount\n ) external nonReentrant {\n uint16 tokenId = 0;\n\n if (_token != address(0)) {\n tokenId = governance.validateTokenAddress(_token);\n }\n\n bytes22 packedBalanceKey = packAddressAndTokenId(_owner, tokenId);\n\n uint128 balance = pendingBalances[packedBalanceKey].balanceToWithdraw;\n\n uint128 amount = Utils.minU128(balance, _amount);\n\n require(amount > 0, \"f1\"); \n\n if (tokenId == 0) {\n (bool success, ) = _owner.call{value: amount}(\"\");\n\n require(success, \"d\"); \n } else {\n \n\n \n\n \n\n amount = this.transferERC20(\n IERC20(_token),\n _owner,\n amount,\n balance\n );\n }\n\n pendingBalances[packedBalanceKey].balanceToWithdraw = balance - amount;\n\n emit Withdrawal(tokenId, amount);\n }", "function minU128(uint128 a, uint128 b) internal pure returns (uint128) {\n\n return a < b ? a : b;\n\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
{"project": "zkSync Portal Bridge", "functions": ["function proveBlocks(\n StoredBlockInfo[] memory _committedBlocks,\n ProofInput memory _proof\n ) external nonReentrant {\n requireActive();\n\n uint32 currentTotalBlocksProven = totalBlocksProven;\n\n for (uint256 i = 0; i < _committedBlocks.length; ++i) {\n require(\n hashStoredBlockInfo(_committedBlocks[i]) ==\n storedBlockHashes[currentTotalBlocksProven + 1],\n \"o1\"\n );\n\n ++currentTotalBlocksProven;\n\n require(\n _proof.commitments[i] & INPUT_MASK ==\n uint256(_committedBlocks[i].commitment) & INPUT_MASK,\n \"o\"\n ); \n }\n\n bool success = verifier.verifyAggregatedBlockProof(\n _proof.recursiveInput,\n _proof.proof,\n _proof.vkIndexes,\n _proof.commitments,\n _proof.subproofsLimbs\n );\n\n require(success, \"p\"); \n\n require(currentTotalBlocksProven <= totalBlocksCommitted, \"q\");\n\n totalBlocksProven = currentTotalBlocksProven;\n }"], "label": "No", "detail": "No known vulnerability found in this function group."}
